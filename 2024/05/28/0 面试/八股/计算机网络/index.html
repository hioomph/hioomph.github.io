<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch_cat_logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/site_cat-32%C3%9732.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/site_cat-16%C3%9716.png">
  <link rel="mask-icon" href="/images/cat_logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、基础篇1、TCP&#x2F;IP 网络模型概述1、应用层 应用层工作在操作系统的用户态，不关心数据如何传输，只需要为用户提供应用功能，如 HTTP、FTP、Telent、DNS 和 SMTP 等。 2、传输层 传输层为应用层提供网络支持，只负责作为应用间数据传输的媒介，包含两个传输协议，TCP（可靠）和UDP（不可靠）。由于应用需要传输的数据可能会非常大，因此当传输层的数据包超过 MSS（">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://example.com/2024/05/28/0%20%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="MIDORII&#39;S JOURNEY">
<meta property="og:description" content="一、基础篇1、TCP&#x2F;IP 网络模型概述1、应用层 应用层工作在操作系统的用户态，不关心数据如何传输，只需要为用户提供应用功能，如 HTTP、FTP、Telent、DNS 和 SMTP 等。 2、传输层 传输层为应用层提供网络支持，只负责作为应用间数据传输的媒介，包含两个传输协议，TCP（可靠）和UDP（不可靠）。由于应用需要传输的数据可能会非常大，因此当传输层的数据包超过 MSS（">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405280953095.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281022515.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281022489.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281023787.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281111484.jpeg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/25.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281119851.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281124646.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281501833.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/57fc82764f3c4ca9b45bef7d402a083a.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291014235.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291021674.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291431547.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291431269.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291035054.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291109906.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291122854.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291125568.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405301058385.jpeg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291132705.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291145819.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291443907.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291444931.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291445813.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291447597.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/25-HTTP2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291449629.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291450660.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291450575.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291452845.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291453175.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291453212.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291455599.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291455330.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291456442.jpeg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/quic%E6%97%A0%E9%98%BB%E5%A1%9E.jpeg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309231026577.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405301235768.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/tls%E6%8F%A1%E6%89%8B.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405301449682.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405301537291.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/tls%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101258417.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230436594.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230445811.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%9B%B8%E5%90%8Cack.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230633447.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230628926.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101543018.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101541969.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101556792.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/fin_wait_2.drawio.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/fin_wait_2%E6%AD%BB%E7%AD%89.drawio.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101604609.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101603186.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TIME-WAIT%E8%BF%9E%E6%8E%A5%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%AD.drawio.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230545997.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/socket%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/3.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/6.jpg?">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/7.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/8.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/15.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/24.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/25.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101710378.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/02dce678f870c8c70482b6e37dbb5574.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/f58b70cde860188b8f95a433e2f5293b.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/68080e783d7acc842fa254e4f9ec5630.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/a49a6bb8cd38ae1738d9c00aec68b444.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/est_syn.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5p6XY29kaW5n,size_20,color_FFFFFF,t_70,g_se,x_16-20230309230147654.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/74b53919396dcda634cfd5b5795cbf16.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/20210615134059647.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/bf004909d9e44c3bc740737ced6731a0.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406102019052.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406102019869.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/udp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97.jpeg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/5.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/%E7%AB%AF%E5%8F%A3%E9%80%89%E6%8B%A9.jpg">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/88416aa95d255495e07fb3a002b2167b.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/54ee363e149ee3dfba30efb1a542ef5c.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406102122868.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/33f3d2d54a924b0a80f565038327e0e4.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/41da16ec3ea04e27bcb35a93c0193855.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/06c4ed62087040438f86ba64e9e609e7.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/dadf9a94328a4446b32ebabf1623c729.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/942c2a1e67224c8c8bd41b13d7c89a96.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/ae18cbf6071c47b98014a68d05c37d16.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111917261.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111919871.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111919210.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111920242.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111920442.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111920900.png">
<meta property="article:published_time" content="2024-05-28T01:30:35.530Z">
<meta property="article:modified_time" content="2024-07-22T01:59:56.696Z">
<meta property="article:author" content="midorii">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png">

<link rel="canonical" href="http://example.com/2024/05/28/0%20%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机网络 | MIDORII'S JOURNEY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MIDORII'S JOURNEY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">a little bit sweet</p>
      <a>
        <img class="custom-logo-image" src="/images/cat.jpeg" alt="MIDORII'S JOURNEY">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/28/0%20%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-28 09:30:35" itemprop="dateCreated datePublished" datetime="2024-05-28T09:30:35+08:00">2024-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-22 09:59:56" itemprop="dateModified" datetime="2024-07-22T09:59:56+08:00">2024-07-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>47k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2:50</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <span id="more"></span>

<h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h2 id="1、TCP-IP-网络模型概述"><a href="#1、TCP-IP-网络模型概述" class="headerlink" title="1、TCP&#x2F;IP 网络模型概述"></a>1、TCP&#x2F;IP 网络模型概述</h2><p><strong>1、应用层</strong></p>
<p>应用层工作在操作系统的<strong>用户态</strong>，<strong>不关心数据如何传输，只需要为用户提供应用功能</strong>，如 HTTP、FTP、Telent、DNS 和 SMTP 等。</p>
<p><strong>2、传输层</strong></p>
<p>传输层<strong>为应用层提供网络支持，只负责作为应用间数据传输的媒介</strong>，包含两个传输协议，TCP（可靠）和UDP（不可靠）。由于应用需要传输的数据可能会非常大，因此当传输层的数据包超过 MSS（TCP 最大报文段长度）时 ，就要将数据包分块（即TCP段）。当设备作为接收方时，传输层则要负责把数据包传给应用，根据传输层报文中携带的端口号，应用层识别出该报文发送给哪个应用。</p>
<p><strong>3、网络层</strong></p>
<p>网络层<strong>负责将数据从一个设备传输到另一个设备</strong>。网络层最常使用的是 IP 协议（Internet Protocol），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。包含<strong>寻址</strong>和<strong>路由</strong>两个重要能力。</p>
<p><strong>4、网络接口层</strong></p>
<p>网络接口层<strong>主要为网络层提供链路级别传输的服务</strong>，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备，可以通过 ARP 协议获取对方的 MAC 地址。</p>
<p><strong>5、总结</strong></p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png" alt="img" style="zoom: 50%;" />

<p>每一层的封装格式：</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img" style="zoom: 50%;" />

<h2 id="2、键入网址到网页显示，期间发生了什么？"><a href="#2、键入网址到网页显示，期间发生了什么？" class="headerlink" title="2、键入网址到网页显示，期间发生了什么？"></a>2、键入网址到网页显示，期间发生了什么？</h2><blockquote>
<p><strong>第一步</strong>，浏览器对 URL 进行解析，确定 Web 服务器和文件名；</p>
<p><strong>第二步</strong>，生成发送给 Web 服务器的 HTTP 请求信息；</p>
<p><strong>第三步</strong>，通过 DNS 查询与服务器域名对应的 IP 地址；</p>
<p><strong>第四步</strong>，将 HTTP 的传输工作交给操作系统中的协议栈；</p>
<p><strong>第五步</strong>，将请求信息封装为 TCP 报文，交给下面的网络层处理；</p>
<p><strong>第六步</strong>，根据查询到的 IP 信息将 TCP 报文封装为 IP 报文；</p>
<p><strong>第七步</strong>，根据自己的网络获取源 MAC 地址，根据 ARP 协议找到目的 IP 地址对应的 MAC 地址，从而封装好 MAC 报文，生成最终的网络包；</p>
<p><strong>第八步</strong>，通过网卡将网络包这串数字信号转为电信号，通过网线发送出去；</p>
<p><strong>第九步</strong>，通过交换机和路由器的转发，最终到达Web服务器；</p>
<p><strong>第十步</strong>，Web 服务器的 HTTP 进程接收到请求报文后，将请求的网页封装在 HTTP 响应报文里，根据类似的步骤发送至客户端。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405280953095.png" alt="简单的网络模型"></p>
<p>1、第一步，浏览器对URL进行解析，确定Web服务器和文件名；</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281022515.jpeg" alt="URL 解析"></p>
<ul>
<li><strong>当URL中并未给出表示数据源&#x2F;文件的路径名时，请求的是哪个文件？</strong></li>
</ul>
<p>当没有路径名时，就代表访问根目录下事先设置的<strong>默认文件</strong>，也就是 &#x2F;index.html 或者 &#x2F;default.html 等这些文件。</p>
<p>2、第二步，生成发送给Web服务器的HTTP请求信息；</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281022489.png" alt="HTTP 的消息格式" style="zoom:50%;" />

<p>3、<strong>第三步：通过DNS查询与服务器域名对应的IP地址；</strong></p>
<p>DNS服务器负责保存Web服务器域名与IP的对应关系。当然，首先会考虑是否能在缓存中直接找到，因此总的寻找顺序如下：</p>
<p>1、浏览器自身的缓存；</p>
<p>2、操作系统自身的缓存；</p>
<p>3、hosts文件；</p>
<p>4、本地DNS服务器。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281023787.png" alt="域名解析的工作流程"></p>
<p>4、第四步，将HTTP的传输工作交给操作系统中的协议栈；</p>
<ul>
<li>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作；</li>
<li>TCP&#x2F;UDP接受应用层的委托，执行收发数据的操作；</li>
<li>IP协议控制网络包的收发操作；</li>
<li>网卡驱动程序负责控制网卡硬件；</li>
<li>网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</li>
</ul>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg" alt="img" style="zoom:50%;" />

<p>5、第五步，将请求信息封装为TCP报文，交给下面的网络层处理；</p>
<ul>
<li>根据三次握手建立连接；</li>
<li>将HTTP信息以 <code>MSS</code> 的长度为单位进行拆分；</li>
<li>封装TCP报文。</li>
</ul>
<p>6、第六步，根据查询到的IP信息将TCP报文封装为IP报文；</p>
<ul>
<li><strong>假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？</strong></li>
</ul>
<p>当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。这个时候就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址 IP。</p>
<p>7、第七步，根据自己的网络获取源MAC地址，根据ARP协议找到目的IP地址对应的MAC地址，从而封装好MAC报文，生成最终的网络包；</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281111484.jpeg" alt="MAC 层报文" style="zoom:50%;" />

<p>8、第八步，通过网卡将网络包这串数字信号转为电信号，通过网线发送出去；</p>
<p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png" alt="数据包" style="zoom: 67%;" />

<p>9、第九步，通过交换机和路由器的转发，最终到达Web服务器；</p>
<p><strong>交换机的工作方式和网卡不同：</strong></p>
<p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p>
<p>10、第十步，Web服务器的HTTP进程接收到请求报文后，将请求的网页封装在HTTP相应报文里，根据类似的步骤发送至客户端。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/25.jpg" alt="网络分层模型" style="zoom:50%;" />

<blockquote>
<ul>
<li>读者问：“请问公网服务器的 Mac 地址是在什么时机通过什么方式获取到的？我看 arp 获取Mac地址只能获取到内网机器的 Mac 地址吧？”</li>
</ul>
<p>在发送数据包时，如果目标主机不是本地局域网，填入的MAC地址是路由器，也就是把数据包转发给路由器，路由器一直转发下一个路由器，直到转发到目标主机的路由器，发现 IP 地址是自己局域网内的主机，就会 ARP 请求获取目标主机的 MAC 地址，从而转发到这个服务器主机。</p>
<p>转发的过程中，源IP地址和目标IP地址是不会变的（前提：没有使用 NAT 网络的），源 MAC 地址和目标 MAC 地址是会变化的。</p>
</blockquote>
<h2 id="3、Linux-接收网络包的流程"><a href="#3、Linux-接收网络包的流程" class="headerlink" title="3、Linux 接收网络包的流程"></a>3、Linux 接收网络包的流程</h2><blockquote>
<p>当网卡接收到网络包后，通过 DMA 将网络包写入 Ring Buffer 中，并通过中断和轮询的方式告诉操作系统该网络包已到达。</p>
<p>操作系统首先调用<strong>硬中断</strong>处理函数表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以，不需要再通知 CPU 了，接着发起<strong>软中断</strong>，恢复刚才屏蔽的中断。软中断则从 Ring Buffer 中获取一个数据帧，即<code>sk_buff</code>，作为网络包交给网络协议栈进行逐层处理。</p>
<p>逐层处理的过程是（1）先进入网络接口层，检查报文的合法性，并并找出上层协议的类型；（2）交给网络层，取出 IP 包，判断是要转发出去还是交给本机上层处理；（3）传输层取出 TCP&#x2F;UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，将数据放入 Socket 对应的接收缓冲区；（4）最后，应用进程调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。</p>
</blockquote>
<p><strong>Linux 系统是如何收发网络包的？</strong></p>
<p>Linux 网络协议栈：</p>
<ul>
<li>应用程序需要通过系统调用，来跟 Socket 层进行数据交互；</li>
<li>Socket 层的下面就是传输层、网络层和网络接口层；</li>
<li>最下面的一层，则是网卡驱动程序和硬件网卡设备；</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281119851.png" alt="img" style="zoom: 50%;" />





<p>一个网络包的收发流程：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281124646.png" alt="img"></p>
<p>（1）网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。</p>
<p>（2）通过触发中断的方式来告诉操作系统这个网络包已到达，但为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 <strong>NAPI 机制</strong>，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是<strong>不采用中断的方式读取数据</strong>，而是首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据。</p>
<ul>
<li>硬件中断处理函数：<ul>
<li>需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。</li>
<li>接着，发起「软中断」，然后恢复刚才屏蔽的中断。</li>
</ul>
</li>
<li>软件中断处理函数：<ul>
<li>内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，轮询处理数据。</li>
<li>ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 <code>sk_buff</code> 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</li>
</ul>
</li>
</ul>
<p>（3）逐层处理的流程如下。</p>
<ul>
<li>首先，会先进入到网络接口层，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给网络层。</li>
<li>到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。</li>
<li>传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。</li>
<li>最后，应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。</li>
</ul>
<p>至此，一个网络包的接收过程就已经结束了。</p>
<h2 id="4、Linux-发送网络包的流程"><a href="#4、Linux-发送网络包的流程" class="headerlink" title="4、Linux 发送网络包的流程"></a>4、Linux 发送网络包的流程</h2><blockquote>
<p>首先，应用进程调用 Socket 发送数据的接口，从用户态进入内核态，内核申请一个<code>sk_buff</code>内存，将用户待发送的数据拷贝到<code>sk_buff</code>内存，并将其加入到发送缓冲区。</p>
<p>其次，网络协议栈从Socket发送缓冲区取出<code>sk_buff</code>，<code>sk_buff</code>通过调整其 data 的指针，可以表示各个层的数据包。因此按照TCP&#x2F;IP协议栈从上到下逐层处理，最终将<code>sk_buff</code>放到网卡的发送队列中。注意如果使用的是 TCP 传输协议发送数据，需要先拷贝一个新的 <code>sk_buff</code> 副本。</p>
<p>此时，会触发「软中断」告诉网卡驱动程序有新的网络包需要发送。驱动程序从发送队列中读取<code>sk_buff</code>并挂到<code>Ring Buffer</code>中，并将<code>sk_buff</code>的数据映射到网卡可访问的内存 DMA 区域，并触发真实的发送。</p>
<p>当数据发送完成后，网卡设备会触发「硬中断」释放内存，主要是释放<code>sk_buff</code> 内存和清理<code>Ring Buffer</code>内存。并且，当收到这个 TCP 报文的 ACK 应答时，传输层会释放原始的<code>sk_buff</code>。</p>
</blockquote>
<p>（1）首先，应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 <code>sk_buff</code>内存，<strong>将用户待发送的数据拷贝到 <code>sk_buff</code> 内存，并将其加入到发送缓冲区</strong>。</p>
<p>（2）接下来，网络协议栈从 Socket 发送缓冲区中取出<code>sk_buff</code>，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理。</p>
<p><strong>（3）如果使用的是 TCP 传输协议发送数据，那么先拷贝一个新的 <code>sk_buff</code> 副本 ，这是因为 <code>sk_buff</code>后续在调用网络层，最后到达网卡发送完成的时候，这个<code>sk_buff</code>会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK  之前，这个<code>sk_buff</code>不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是<code>sk_buff</code>的一个拷贝，等收到 ACK 再真正删除。</strong></p>
<p>（4）接着，对<code>sk_buff</code> 填充 TCP 头。这里提一下，<code>sk_buff</code>可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。</p>
<blockquote>
<p>为了在层级之间传递数据时不发生拷贝，只用<code>sk_buff</code> 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 <code>sk_buff</code> 中 <code>data</code> 的指针，比如：</p>
<ul>
<li>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb-&gt;data 的值，来逐步剥离协议首部。</li>
<li>当要发送报文时，创建 <code>sk_buff</code> 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb-&gt;data 的值来增加协议首部。</li>
</ul>
</blockquote>
<p>（5）然后交给网络层，在网络层里会做这些工作：选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。处理完这些工作后会交给网络接口层处理。</p>
<p>（6）网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对<code>sk_buff</code> 填充帧头和帧尾，接着将 <code>sk_buff</code> 放到网卡的发送队列中。</p>
<p>（7）这一些工作准备好后，会触发「软中断」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取<code>sk_buff</code>，将这个<code>sk_buff</code>挂到 RingBuffer 中，接着将<code>sk_buff</code>数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。</p>
<p>（8）当数据发送完成以后，其实工作并没有结束，因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存，主要是释放<code>sk_buff</code> 内存和清理 RingBuffer 内存。</p>
<p>（9）最后，当收到这个 TCP 报文的 ACK 应答时，传输层就会释放原始的<code>sk_buff</code>。</p>
<blockquote>
<ul>
<li>发送网络数据的时候，涉及几次内存拷贝操作？</li>
</ul>
<p>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 <code>sk_buff</code> 内存，将用户待发送的数据拷贝到 <code>sk_buff</code> 内存，并将其加入到发送缓冲区。</p>
<p>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 <code>sk_buff</code> 都会被克隆一个新的副本出来。副本 <code>sk_buff</code>  会被送往网络层，等它发送完的时候就会释放掉，然后原始的 <code>sk_buff</code> 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的  ACK 时，才会释放原始的 <code>sk_buff</code> 。</p>
<p>第三次，当 IP 层发现 <code>sk_buff</code> 大于 MTU 时才需要进行。会再申请额外的 <code>sk_buff</code>，并将原来的 <code>sk_buff</code> 拷贝为多个小的 <code>sk_buff</code>。</p>
</blockquote>
<h3 id="技术补充"><a href="#技术补充" class="headerlink" title="技术补充"></a>技术补充</h3><h4 id="（1）DMA（Direct-Memory-Access）"><a href="#（1）DMA（Direct-Memory-Access）" class="headerlink" title="（1）DMA（Direct Memory Access）"></a>（1）DMA（Direct Memory Access）</h4><p>一种内存访问技术，允许某些电脑内部的硬件子系统（电脑外设）可以独立地直接读写系统内存，而不需要中央处理器（CPU）介入处理。</p>
<ol>
<li>传统CPU存取数据</li>
</ol>
<p>CPU 不直接存取外设的原因：</p>
<ul>
<li>CPU 的工作速度和外设的工作速度差距太大；</li>
<li>外设格式种类繁多，无法直接存取，需要经过转换</li>
</ul>
<p>基于上述原因，CPU 不能直接从外设获取或者向外设写入内容。传统CPU 获取数据的步骤如下：</p>
<blockquote>
<p>1、CPU 将外设数据加载到内存（和CPU的处理速度最接近）</p>
<p>2、CPU 检查 cache 是否有自己需要的数据（是否命中）</p>
<p>3、如果命中，直接返回数据；如未命中，继续从内存获取（这里暂时不考虑MMU）</p>
<p>4、返回数据</p>
</blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281501833.png" alt="img" style="zoom:50%;" />

<ol start="2">
<li>DMA</li>
</ol>
<p>由上面CPU 读取数据来看，无论是将外设数据搬移到内存，还是从内存读取数据，都需要CPU 的参与。为了让 CPU 能够专注于处理手中事务，DMA 将负责数据的搬移工作。</p>
<p>DMA（Direct Memory Access）即直接存储器访问，借助内部的控制器来实现内存和外设之间的数据传输。有了DMA，CPU 可以专注于内存数据的存取；数据的搬运过程完全可以交由DMA硬件完成。有了DMA以后，不代表完全不需要CPU了，只是不会像中断那样频繁向CPU发送请求。</p>
<img src="https://img-blog.csdnimg.cn/57fc82764f3c4ca9b45bef7d402a083a.png" alt="img" style="zoom:50%;" />

<h4 id="（2）ksoftirqd内核线程"><a href="#（2）ksoftirqd内核线程" class="headerlink" title="（2）ksoftirqd内核线程"></a>（2）ksoftirqd内核线程</h4><p><a target="_blank" rel="noopener" href="https://www.kerneltravel.net/blog/2020/ksoftirqd_ljr/">Linux内核网络中的软中断ksoftirqd</a></p>
<p>当执行到网卡通过硬件中断（IRQ）通知CPU，告诉它有数据来了，CPU会根据中断表，调用已经注册的中断函数，这个中断函数会调到驱动程序（NIC Driver）中相应的函数。驱动先禁用网卡的中断，表示驱动程序已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知CPU了，这样可以提高效率，避免CPU不停的被中断。</p>
<p>由于硬中断处理程序执行的过程中不能被中断，所以如果它执行时间过长，会导致CPU没法响应其它硬件的中断，于是内核引入软中断，这样可以将硬中断处理函数中耗时的部分移到软中断处理函数里面来慢慢处理。内核中的<code>ksoftirqd</code>进程专门负责软中断的处理，当它收到软中断后，就会调用相应软中断所对应的处理函数，网卡驱动模块抛出的软中断，<code>ksoftirqd</code>会调用网络模块的<code>net_rx_action</code>函数。</p>
<p>中断是一种异步的事件处理机制，用来提高系统的并发处理能力。中断事件发生，会触发执行中断处理程序，而中断处理程序被分为上半部和下半部这两个部分。上半部对应硬中断，用来快速处理中断；下半部对应软中断，用来异步处理上半部未完成的工作。Linux 中的软中断包括网络收发、定时、调度、RCU 锁等各种类型，我们可以查看 proc 文件系统中的 <code>/proc/softirqs</code>  ，观察软中断的运行情况。在 Linux 中，每个 CPU 都对应一个软中断内核线程，名字是 <code>ksoftirqd/CPU </code>编号。当软中断事件的频率过高时，内核线程也会因为 CPU 使用率过高而导致软中断处理不及时，进而引发网络收发延迟、调度缓慢等性能问题。</p>
<h4 id="（3）NAPI机制分析"><a href="#（3）NAPI机制分析" class="headerlink" title="（3）NAPI机制分析"></a>（3）NAPI机制分析</h4><h1 id="二、HTTP篇"><a href="#二、HTTP篇" class="headerlink" title="二、HTTP篇"></a>二、HTTP篇</h1><blockquote>
<p>HTTP 是一个用于在<strong>服务器和服务器之间</strong>，或<strong>服务器和本地浏览器之间</strong>传输文字、图片、音频和视频等超文本数据的规范和约定。</p>
<p>HTTP是超文本传输协议，也就是<code>HyperText Transfer Protocol</code>。</p>
<p>「超文本」：文字、图片和视频等的混合体。其本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现出来的就是一个有文字、有画面的网页了。</p>
</blockquote>
<h2 id="5、HTTP-的常见状态码有哪些？"><a href="#5、HTTP-的常见状态码有哪些？" class="headerlink" title="5、HTTP 的常见状态码有哪些？"></a>5、HTTP 的常见状态码有哪些？</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291014235.png" alt="HTTP常见状态码"></p>
<h2 id="6、HTTP-的常见字段有哪些？"><a href="#6、HTTP-的常见字段有哪些？" class="headerlink" title="6、HTTP 的常见字段有哪些？"></a>6、HTTP 的常见字段有哪些？</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291021674.png" alt="HTTP常见字段"></p>
<h2 id="7、Get-与-Post"><a href="#7、Get-与-Post" class="headerlink" title="7、Get 与 Post"></a>7、Get 与 Post</h2><p><strong>GET 的语义是从服务器获取指定的资源</strong>。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。GET 方法是安全、幂等、可被缓存的。</p>
<p><strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>。POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。POST 不安全，不幂等，（大部分实现）不可缓存。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291431547.png" alt="GET 请求"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291431269.png" alt="POST 请求"></p>
<h2 id="【-】8、HTTP缓存技术"><a href="#【-】8、HTTP缓存技术" class="headerlink" title="【*】8、HTTP缓存技术"></a>【*】8、HTTP缓存技术</h2><blockquote>
<p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p>
<p><strong>强制缓存</strong>指的是<strong>只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存</strong>。决定是否使用缓存的主动性在于浏览器这边。基于两个HTTP响应头部字段实现：Cache-Control和Expires。</p>
<p><strong>协商缓存</strong>指的是<strong>与服务端协商之后，通过协商结果来判断是否使用本地缓存，涉及304状态码</strong>。基于两种头部来实现，一种是请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段，另一种是请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段。注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p>
</blockquote>
<h3 id="（1）强制缓存"><a href="#（1）强制缓存" class="headerlink" title="（1）强制缓存"></a>（1）强制缓存</h3><p>下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291035054.png" alt="img"></p>
<p>强缓存利用下面两个HTTP响应头部字段实现：</p>
<ul>
<li><code>Cache-Control</code>， 是一个相对时间，优先级较高；</li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
<h3 id="（2）协商缓存"><a href="#（2）协商缓存" class="headerlink" title="（2）协商缓存"></a>（2）协商缓存</h3><p>当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 <code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</p>
<p>协商缓存的过程如下：</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png" alt="img" style="zoom:50%;" />

<p>协商缓存可以基于两种头部来实现。</p>
<p>第一种：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现，这两个字段的意思是：</p>
<ul>
<li>响应头部中的 <code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li>
<li>请求头部中的 <code>If-Modified-Since</code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有  If-Modified-Since，则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP  200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li>
</ul>
<p>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段，这两个字段的意思是：</p>
<ul>
<li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li>
<li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li>
</ul>
<p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291109906.png" alt="img"></p>
<p><strong>当使用 ETag 字段实现的协商缓存的过程：</strong></p>
<ul>
<li><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</p>
</li>
<li><p>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：</p>
<ul>
<li>如果没有过期，则直接使用本地缓存；</li>
<li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</li>
</ul>
</li>
<li><p>服务器再次收到请求后，</p>
<p>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：</p>
<ul>
<li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li>
<li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>
</ul>
</li>
<li><p>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</p>
</li>
</ul>
<h2 id="9、HTTP-与-HTTPS-有哪些区别？"><a href="#9、HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="9、HTTP 与 HTTPS 有哪些区别？"></a>9、HTTP 与 HTTPS 有哪些区别？</h2><blockquote>
<ul>
<li>H TTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li>两者的默认端口不一样，HTTP 默认端口号是 <code>80</code>，HTTPS 默认端口号是 <code>443</code>。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
</blockquote>
<h2 id="10、HTTPS-解决了-HTTP-的哪些问题？"><a href="#10、HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="10、HTTPS 解决了 HTTP 的哪些问题？"></a>10、HTTPS 解决了 HTTP 的哪些问题？</h2><blockquote>
<p>HTTP 存在三个风险：1）窃听风险；2）篡改风险；3）冒充风险。</p>
<p>HTTPS 通过在 HTTP 与 TCP 之间加入<code>SLL/TLS</code>协议，解决上述风险，具体实现如下：</p>
<p>1、<strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险，采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式。</p>
<ul>
<li><strong>对称加密：</strong> 在对称加密中，加密和解密使用相同的密钥。发送方和接收方必须共享同一个密钥，这种密钥的管理相对简单，但存在密钥分发和安全性的挑战。</li>
<li><strong>非对称加密：</strong> 非对称加密使用一对密钥，公钥和私钥。公钥用于加密数据，私钥用于解密数据。发送方可以使用接收方的公钥加密数据，只有接收方拥有相应的私钥才能解密数据。</li>
</ul>
<p>2、<strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</p>
<p>3、将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</p>
</blockquote>
<p>HTTP 存在三个风险：<strong>1）窃听风险；2）篡改风险；3）冒充风险。</strong></p>
<p>HTTPS 通过在 HTTP 与 TCP 之间加入<code>SLL/TLS</code>协议，解决上述风险，具体实现如下：</p>
<blockquote>
<p>1、<strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291122854.png" alt="混合加密" style="zoom:80%;" />

<blockquote>
<ol>
<li><strong>对称加密 vs. 非对称加密：</strong></li>
</ol>
<ul>
<li><strong>对称加密：</strong> 在对称加密中，加密和解密使用相同的密钥。发送方和接收方必须共享同一个密钥，这种密钥的管理相对简单，但存在密钥分发和安全性的挑战。</li>
<li><strong>非对称加密：</strong> 非对称加密使用一对密钥，公钥和私钥。公钥用于加密数据，私钥用于解密数据。发送方可以使用接收方的公钥加密数据，只有接收方拥有相应的私钥才能解密数据。</li>
</ul>
<ol start="2">
<li><strong>哈希散列算法：</strong></li>
</ol>
<ul>
<li><strong>哈希散列算法不是加密算法：</strong> 哈希散列算法是一种单向函数，它将任意长度的输入转换为固定长度的输出，称为哈希值。哈希算法是不可逆的，即无法从哈希值还原出原始输入。因此，哈希散列算法不属于加密算法，而是用于数据完整性验证、数字签名等领域。</li>
</ul>
</blockquote>
<p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p>
<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」方式加密明文数据。</li>
</ul>
<p>采用「混合加密」的方式的原因：</p>
<ul>
<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>
</ul>
<blockquote>
<p>2、<strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291125568.png" alt="img"></p>
<p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。为了避免这种情况，计算机里会用<strong>非对称加密算法</strong>来解决，共有两个密钥：</p>
<ul>
<li>一个是公钥，这个是可以公开给所有人的；</li>
<li>一个是私钥，这个必须由本人管理，不可泄露。</li>
</ul>
<p>这两个密钥可以<strong>双向加解密</strong>的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。</p>
<p>流程的不同，意味着目的也不相同：</p>
<ul>
<li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li>
<li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li>
</ul>
<p>一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。</p>
<p>所以非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p>
<blockquote>
<p>3、将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</p>
</blockquote>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="数子证书工作流程" style="zoom: 80%;" />

<h2 id="11、HTTPS-是如何建立连接的？其间交互了什么？"><a href="#11、HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="11、HTTPS  是如何建立连接的？其间交互了什么？"></a>11、HTTPS  是如何建立连接的？其间交互了什么？</h2><blockquote>
<p>SSL&#x2F;TLS 协议基本流程：</p>
<ol>
<li><p>TLS 的「握手阶段」（根据不同的密钥算法，有不同的握手流程）</p>
<ul>
<li><p>客户端向服务器索要并验证服务器的公钥；</p>
</li>
<li><p>双方协商产生「会话秘钥」；</p>
</li>
</ul>
</li>
<li><p>通信阶段</p>
<ul>
<li>采用「会话秘钥」进行通信。</li>
</ul>
</li>
</ol>
</blockquote>
<p>常见的密钥交换算法：<code>RSA</code>算法和<code>ECDHE</code>算法。</p>
<p>以<code>RSA</code>算法为例，展示TLS握手流程（<strong>四次握手</strong>）：</p>
<p>注意：<strong>服务器和客户端通过三个随机数（Client Random、Server Random、pre-master key），以及双方协商的加密算法，<em>各自</em>生成本次通信的「会话秘钥」</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405301058385.jpeg" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p>
<h2 id="12、HTTPS-一定安全可靠吗？"><a href="#12、HTTPS-一定安全可靠吗？" class="headerlink" title="12、HTTPS 一定安全可靠吗？"></a>12、HTTPS 一定安全可靠吗？</h2><h4 id="（1）HTTPS一定安全可靠吗，如果有假基站获取了转发全部信息的作用，这样是不是假基站就获取到了全部信息，从而造成信息泄露？"><a href="#（1）HTTPS一定安全可靠吗，如果有假基站获取了转发全部信息的作用，这样是不是假基站就获取到了全部信息，从而造成信息泄露？" class="headerlink" title="（1）HTTPS一定安全可靠吗，如果有假基站获取了转发全部信息的作用，这样是不是假基站就获取到了全部信息，从而造成信息泄露？"></a>（1）HTTPS一定安全可靠吗，如果有假基站获取了转发全部信息的作用，这样是不是假基站就获取到了全部信息，从而造成信息泄露？</h4><blockquote>
<p>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。</p>
</blockquote>
<p>这个问题的场景是这样的：客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.png" alt="img" style="zoom:50%;" />



<p>从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。那么中间人就可以解开浏览器发起的 HTTPS  请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS  请求和响应的数据。</p>
<p>但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291132705.png" alt="img"></p>
<p>所以，<strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p>
<h4 id="（2）为什么抓包工具能截取-HTTPS-数据？"><a href="#（2）为什么抓包工具能截取-HTTPS-数据？" class="headerlink" title="（2）为什么抓包工具能截取 HTTPS 数据？"></a>（2）为什么抓包工具能截取 HTTPS 数据？</h4><blockquote>
<p>抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，就会认为这个证书是有效的。</p>
</blockquote>
<p>很多抓包工具 之所以可以明文看到 HTTPS 数据，工作原理与中间人一致。</p>
<p>对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:</p>
<ol>
<li>中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；</li>
<li>中间人，作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；</li>
</ol>
<p>中间人要拿到私钥只能通过如下方式：</p>
<ol>
<li>去网站服务端拿到私钥；</li>
<li>去CA处拿域名签发私钥；</li>
<li>自己签发证书，切要被浏览器信任；</li>
</ol>
<p>不用解释，抓包工具只能使用第三种方式取得中间人的身份。使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。</p>
<p>抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。</p>
<h4 id="（3）如何避免被中间人抓取数据？"><a href="#（3）如何避免被中间人抓取数据？" class="headerlink" title="（3）如何避免被中间人抓取数据？"></a>（3）如何避免被中间人抓取数据？</h4><blockquote>
<p>1、不要点击任务证书非法的网站；</p>
<p>2、通过 HTTPS 双向认证来避免，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</p>
</blockquote>
<p>我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样 HTTPS 数据就不会被中间人截取到了。</p>
<p>当然，我们还可以通过 <strong>HTTPS 双向认证</strong>来避免这种问题。一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。<strong>如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291145819.png" alt="img"></p>
<h2 id="14、HTTP-1-1"><a href="#14、HTTP-1-1" class="headerlink" title="14、HTTP&#x2F;1.1"></a>14、HTTP&#x2F;1.1</h2><blockquote>
<p>优点：</p>
<ol>
<li>简单</li>
<li>灵活和易于拓展</li>
<li>应用广泛和跨平台</li>
</ol>
<p>缺点：</p>
<ol>
<li>无状态</li>
<li>明文传输</li>
<li>不安全</li>
</ol>
<p>性能：</p>
<ol>
<li>长连接</li>
<li>管道网络传输</li>
</ol>
</blockquote>
<p><strong>优点：</strong></p>
<ol>
<li><p>简单</p>
<p>基本的报文格式是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式。</p>
</li>
<li><p>灵活和易于拓展</p>
<p>HTTP 协议里的各类请求方法、URI&#x2F;URL、状态码和头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</p>
<p>同时 HTTP 由于是工作在应用层（ <code>OSI</code> 第七层），其<strong>下层可以随意变化</strong>，比如：</p>
<ul>
<li>HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL&#x2F;TLS 安全传输层；</li>
<li>HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 传输协议使用的是 TCP 协议，而到了 HTTP&#x2F;3.0 传输协议改用了 UDP 协议。</li>
</ul>
</li>
<li><p>应用广泛和跨平台</p>
</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><p>无状态</p>
<p>HTTP协议本身是无状态的，也就是说每个请求之间是相互独立的，服务器不会在不同请求之间保留任何关于客户端请求的状态信息。这意味着<strong>每个HTTP请求都是独立的，服务器不会记住之前的请求或会话信息。</strong></p>
<p>对于无状态的问题，解法方案有很多种，其中比较简单的方式用 <strong>Cookie</strong> 技术。</p>
<p><code>Cookie</code> 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291443907.png" alt="Cookie 技术"></p>
</li>
<li><p>明文传输</p>
</li>
<li><p>不安全</p>
</li>
</ol>
<p><strong>性能：</strong></p>
<ol>
<li><p>长连接：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。如果某个 HTTP 长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291444931.png" alt="短连接与长连接"></p>
</li>
<li><p>管道网络传输：在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong>但是<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。所以，<strong>HTTP&#x2F;1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291445813.png" alt="管道网络传输"></p>
</li>
</ol>
<blockquote>
<p><strong>注意</strong></p>
<p>实际上 HTTP&#x2F;1.1 管道化技术不是默认开启，而且浏览器基本都没有支持，所以<strong>后面所有文章讨论 HTTP&#x2F;1.1 都是建立在没有使用管道化的前提</strong>。大家知道有这个功能，但是没有被使用就行了。</p>
</blockquote>
<ol start="3">
<li><p>队头阻塞：当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291447597.png" alt="队头阻塞"></p>
</li>
</ol>
<h2 id="15、HTTP-2"><a href="#15、HTTP-2" class="headerlink" title="15、HTTP&#x2F;2"></a>15、HTTP&#x2F;2</h2><blockquote>
<p>HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p>
<ol>
<li>头部压缩</li>
<li>二进制格式</li>
<li>并发传输</li>
<li>服务器主动推送资源</li>
</ol>
<p>但其缺陷在于：HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</p>
</blockquote>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/25-HTTP2.png" alt="HTT/1 ~ HTTP/2" style="zoom:80%;" />

<ol>
<li><p>头部压缩</p>
<p>HTTP&#x2F;2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p>
<p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p>
</li>
<li><p>二进制格式</p>
<p>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291449629.png" alt="HTTP/1 与 HTTP/2 "></p>
<p>比如状态码 200 ，在 HTTP&#x2F;1.1 是用 ‘2’’0’’0’ 三个字符来表示（二进制：00110010 00110000 00110000），共用了 3 个字节，如下图</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291450660.png" alt="img"></p>
<p>在 HTTP&#x2F;2 对于状态码 200 的二进制编码是 10001000，只用了 1 字节就能表示，相比于 HTTP&#x2F;1.1 节省了 2 个字节，如下图：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291450575.png" alt="img"></p>
</li>
<li><p>并发传输</p>
<p>引入了 Stream 概念，多个 Stream 复用在一条 TCP 连接。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291452845.png" alt="img"></p>
<p>1 个 TCP 连接包含多个 Stream，1个Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP&#x2F;1  中的请求或响应，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP&#x2F;2  最小单位，以二进制压缩格式存放 HTTP&#x2F;1 中的内容（头部和包体）。</p>
<p><strong>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP  消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应</strong>。</p>
<p>比如下图，服务端<strong>并行交错地</strong>发送了两个响应： Stream 1 和 Stream 3，这两个 Stream 都是跑在一个 TCP 连接上，客户端收到后，会根据相同的 Stream ID 有序组装成 HTTP 消息。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291453175.jpeg" alt="img"></p>
</li>
<li><p>服务器主动推送资源</p>
<p>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p>
<p>比如下图，Stream 1 是客户端向服务端请求的资源，属于客户端建立的 Stream，所以该 Stream 的 ID 是奇数（数字  1）；Stream 2 和 4 都是服务端主动向客户端推送的资源，属于服务端建立的 Stream，所以这两个 Stream 的 ID  是偶数（数字 2 和 4）。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291453212.png" alt="img"></p>
<p>HTTP&#x2F;2的仍旧存在“队头阻塞”问题，但是问题不是在HTTP层面，而是在TCP层面。</p>
<p><strong>HTTP&#x2F;2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP  层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1  个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2  应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291455599.jpeg" alt="img" style="zoom:67%;" />

<p>举个例子，如下图：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291455330.gif" alt="img"></p>
</li>
</ol>
<h2 id="16、HTTP-3"><a href="#16、HTTP-3" class="headerlink" title="16、HTTP&#x2F;3"></a>16、HTTP&#x2F;3</h2><blockquote>
<p>为了解决HTTP&#x2F;2的队头阻塞问题，HTTP&#x2F;3将下层的TCP协议修改成了UDP协议。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291456442.jpeg" alt="HTTP/1 ~ HTTP/3"></p>
<p>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP&#x2F;2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p>
<p>QUIC 有以下 3 个特点。</p>
<ul>
<li>无队头阻塞</li>
<li>更快的连接建立</li>
<li>连接迁移</li>
</ul>
<p>1、无队头阻塞</p>
<p>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p>
<p>QUIC 有自己的一套机制可以保证传输的可靠性的。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>，这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/quic%E6%97%A0%E9%98%BB%E5%A1%9E.jpeg" alt="img" style="zoom: 67%;" />

<p>2、更快的连接建立</p>
<p>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p>
<p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。此外，HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS&#x2F;1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.png" alt="TCP HTTPS（TLS/1.3） 和 QUIC HTTPS "></p>
<p>3、连接迁移</p>
<p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309231026577.png" alt="TCP 四元组" style="zoom:50%;" />

<p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p>
<p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p>
<p><strong>所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</strong></p>
<p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而  QUIC 是基于 UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。HTTP&#x2F;3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。</p>
<h2 id="17、HTTP-1-1-该如何优化？"><a href="#17、HTTP-1-1-该如何优化？" class="headerlink" title="17、HTTP&#x2F;1.1 该如何优化？"></a>17、HTTP&#x2F;1.1 该如何优化？</h2><blockquote>
<p><strong>HTTP&#x2F;1.1 如何优化&#x2F;大量网络请求如何优化？</strong></p>
<p>第一个思路是，通过缓存技术来避免具有重复性的 HTTP 请求。客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带资源的 304 响应，告诉客户端缓存的响应仍然有效。</p>
<p>第二个思路是，减少 HTTP 请求的次数，有以下方法：</p>
<ol>
<li>将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数；</li>
<li>将多个小资源合并成一个大资源再传输，减少 HTTP 请求次数以及头部的重复传输，以及减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗；</li>
<li>按需访问资源，只访问当前用户看得到&#x2F;用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数。</li>
</ol>
<p>第三个思路是，通过压缩响应资源，降低传输资源的大小，从而提高传输效率，所以应当选择更优秀的压缩算法。</p>
</blockquote>
<ol>
<li><p>对于一些具有重复性的HTTP请求，可以考虑将这对「请求-响应」的数据<strong>缓存在本地</strong>，这样在下一次就可以直接读取本地的数据，不必再通过网络获取服务器响应了。</p>
<ul>
<li>具体来说，客户端会把第一次请求以及响应的数据以key-value的形式保存在本地磁盘上，其中请求的URL为key，响应为数据。当后续发起相同请求时，就可以先在本地磁盘上进行查询和读取。</li>
<li>客户端在重新发送请求时，会在请求的<code>Etag</code>头部带上第一次请求的响应头部中的摘要，作为唯一标识响应的资源。服务器收到该请求时，会将本地资源的摘要与请求中的摘要进行对比：<ul>
<li>若相同，则返回<code>304</code>状态码，告诉客户端该缓存仍有效；</li>
<li>若不同，则返回最新的资源。</li>
</ul>
</li>
</ul>
</li>
<li><p>减少HTTP请求可以从以下三方面入手：</p>
<ol>
<li>减少重定向请求次数。<ul>
<li>重定向请求是指当服务器的某个资源从url1转移到url2后，对于不知情的客户端来说，它将继续请求url1，这时服务器将返回<code>302</code>状态码和<code>Location</code>头部，告诉客户端资源已经转移到url2了，于是客户端再重新发送url2请求以获取资源。</li>
<li>重定向请求越多，客户端发起的HTTP请求就越多；此外，若通过「客户端-代理服务器-服务器」来传送资源，客户端与服务器之间需要进行2次消息传递。以上做法无疑将大大降低网络性能。</li>
<li>因此，如果<strong>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了</strong>。</li>
</ul>
</li>
<li>合并请求。<ul>
<li>将多个访问小文件的请求合并成一个大的请求。这样虽然传输的总资源大小不变，但减少了重复发送的HTTP头部。</li>
<li>此外，由于HTTP&#x2F;1.1是请求响应模型，为了防止单个请求的阻塞，一般浏览器会同时发送5-6个请求，每个请求都是不同的TCP连接。若能够合并请求，将减少TCP连接的数量，并省去TCP握手和慢启动过程耗费的时间。</li>
</ul>
</li>
<li>延迟发送请求。<ul>
<li>对于资源进行<strong>按需获取</strong>。比如请求网页时，没必要一次性获取全部资源，而是只获取用户所看到的页面资源，当用户向下滑动页面时再向服务器接着获取，从而达到延迟发送请求的效果。</li>
</ul>
</li>
</ol>
</li>
<li><p>通过压缩的方式减少HTTP响应的数据大小。</p>
<ul>
<li><p>无损压缩。</p>
<ul>
<li>指资源经过压缩后信息不被破坏，还能完全恢复到压缩前的原样。适用于文本文件、程序可执行文件和程序源代码等。</li>
<li>在请求字段中通过<code>Accept-Encoding</code>告知服务器客户端支持的压缩算法；在响应头部中通过<code>Content-Encoding</code>字段告诉客户端服务器采用的压缩算法。</li>
<li>常见算法：<code>gzip</code>、<code>Brotli</code></li>
</ul>
</li>
<li><p>有损压缩。</p>
<ul>
<li><p>将次要的数据合并，牺牲一些质量来减少数据量、提高压缩比。适用于多媒体数据，如音频、视频和图片等。</p>
</li>
<li><p>在请求字段中通过<code>Accept</code>字段里的「 q 质量因子」，告诉服务器期望的资源质量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: audio/*; q=0.2, audio/basic</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="【-】、HTTPS-RSA-握手解析"><a href="#【-】、HTTPS-RSA-握手解析" class="headerlink" title="【-】、HTTPS RSA 握手解析"></a>【-】、HTTPS RSA 握手解析</h2><blockquote>
<p>传统的TLS握手采用RSA算法实现密钥交换。在将TLS证书部署服务器端时，证书文件其实就是服务器端的公钥，会在TLS握手阶段传递给客户端。而服务器端的私钥则一直留在服务器端，并确保其不被窃取。</p>
<p>在RSA密钥协商算法中，客户端会生成随机密钥，并使用服务器端的公钥加密后传给服务器端。根据非对称加密算法，公钥加密的信息仅能通过similarity解密，这样服务器端解密后，双方就得到了相同的密钥，再用这个密钥来加密应用信息。</p>
<p><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。为了解决这个问题，后面就出现了 ECDHE 密钥协商算法。</p>
<p>包含四次握手过程：</p>
<ul>
<li><strong>第一次握手</strong></li>
<li>客户端发送「<strong>Client Hello</strong>」，包含<ul>
<li>1）LS版本号；</li>
<li>2）支持的密码套件列表；</li>
<li>3）生成的随机数<strong>Client Random</strong>。</li>
</ul>
</li>
<li><strong>第二次握手</strong></li>
<li>服务器端返回「<strong>Server Hello</strong>」，包含<ul>
<li>1）确认的TLS版本号；</li>
<li>2）从密码套件列表中选择的密码套件；</li>
<li>3）生成的随机数<strong>Server Random</strong>。</li>
</ul>
</li>
<li>服务器端发送「<strong>Server Certificate</strong>」，包含数字证书；</li>
<li>服务器端发送「<strong>Server Hello Done</strong>」，表明自己本次发送完毕。</li>
<li><strong>第三次握手</strong></li>
<li>客户端发送「<strong>Client Key Exchange</strong>」；</li>
<li>双方根据已经得到的三个随机数（<strong>Client Random、Server Random、pre-master</strong>），生成<strong>会话密钥（Master Secret）</strong>；</li>
<li>客户端发送「<strong>Change Cipher Spec</strong>」，告诉服务器端开始使用加密方式发送消息；</li>
<li>客户端再发送「<strong>Encrypted Handshake Message（Finishd）</strong>」；</li>
<li><strong>第四次握手</strong>：</li>
<li>服务器也是同样的操作，发送「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」；如果双方都验证加密和解密没问题，那么握手正式完成。</li>
</ul>
</blockquote>
<p><code>RSA</code>算法需要经过四次握手，也就是<code>2</code>个RTT的时延。由于HTTPS是应用层协议，因此需要先完成TCP连接建立，再完成TLS握手过程，才能建立通信安全的连接。</p>
<ul>
<li><p><strong>第一次握手</strong></p>
<ul>
<li>客户端发送「<strong>Client Hello</strong>」，包含<ul>
<li>1）LS版本号；</li>
<li>2）支持的密码套件列表；</li>
<li>3）生成的随机数<strong>Client Random</strong>；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>第二次握手</strong></p>
<ul>
<li><p>服务器端返回「<strong>Server Hello</strong>」，包含</p>
<ul>
<li>1）确认的TLS版本号；</li>
<li>2）从密码套件列表中选择的密码套件；</li>
<li>3）生成的随机数<strong>Server Random</strong>；</li>
</ul>
</li>
<li><p>服务器端发送「<strong>Server Certificate</strong>」，包含数字证书</p>
<ul>
<li><p>数字证书中包含以下信息：公钥、持有者信息、证书认证机构（CA）的信息、CA 对这份文件的数字签名及使用的算法、证书有效期，以及一些其他的额外信息；</p>
</li>
<li><p>证书由CA（Certificate Authority，证书认证机构）签名，签发和认证流程如下，主要涉及1）Hash算法；2）CA私钥加密，CA公钥解密：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405301235768.png" alt="img"></p>
</li>
</ul>
<blockquote>
<p><strong>CA 签发证书</strong>的过程，如上图左边部分：</p>
<ul>
<li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li>
<li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li>
<li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li>
</ul>
<p><strong>客户端校验服务端的数字证书</strong>的过程，如上图右边部分：</p>
<ul>
<li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li>
<li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li>
<li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li>
</ul>
</blockquote>
</li>
<li><p>服务器端发送「<strong>Server Hello Done</strong>」，表明自己本次发送完毕</p>
</li>
</ul>
</li>
<li><p><strong>第三次握手</strong></p>
<ul>
<li>客户端发送「<strong>Client Key Exchange</strong>」，包含新生成的随机数<strong>pre-master</strong>，并由服务器的 RSA 公钥加密；</li>
<li>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (<strong>pre-master</strong>)；</li>
<li>双方根据已经得到的三个随机数（<strong>Client Random、Server Random、pre-master</strong>），生成<strong>会话密钥（Master Secret）</strong>，它是对称密钥，用于对后续的 HTTP 请求&#x2F;响应的数据加解密；</li>
<li>客户端发送「<strong>Change Cipher Spec</strong>」，告诉服务器端开始使用加密方式发送消息；</li>
<li>客户端再发送「<strong>Encrypted Handshake Message（Finishd）</strong>」消息，把之前所有发送的数据做个<strong>摘要</strong>，再用会话密钥（<strong>Master Secret</strong>）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。</li>
</ul>
</li>
<li><p><strong>第四次握手</strong></p>
<ul>
<li>服务器也是同样的操作，发送「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息；</li>
<li>如果双方都验证加密和解密没问题，那么握手正式完成。</li>
</ul>
</li>
</ul>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/tls%E6%8F%A1%E6%89%8B.png" alt="img" style="zoom: 67%;" />

<h2 id="【-】、HTTPS-ECDHE-握手解析"><a href="#【-】、HTTPS-ECDHE-握手解析" class="headerlink" title="【-】、HTTPS ECDHE 握手解析"></a>【-】、HTTPS ECDHE 握手解析</h2><blockquote>
<p>算法演进：DH -&gt; DHE -&gt; DCDHE</p>
</blockquote>
<p>（1）DH算法</p>
<p>核心数学思想：离散对数。离散对数的概念如下图：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405301449682.png" alt="img" style="zoom:67%;" />

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405301537291.png" alt="image-20240530153742715"></p>
<p>四次握手过程：</p>
<ul>
<li><strong>第一次握手</strong><ul>
<li>客户端发送「<strong>Client Hello</strong>」，包含<ul>
<li>1）LS版本号；</li>
<li>2）支持的密码套件列表；</li>
<li>3）生成的随机数<strong>Client Random</strong>；</li>
</ul>
</li>
</ul>
</li>
<li><strong>第二次握手</strong><ul>
<li>服务器端返回「<strong>Server Hello</strong>」，包含<ul>
<li>1）确认的TLS版本号；</li>
<li>2）从密码套件列表中选择的密码套件；</li>
<li>3）生成的随机数<strong>Server Random</strong>；</li>
</ul>
</li>
<li>服务器端发送「<strong>Server Certificate</strong>」，包含数字证书</li>
<li>服务器端发送「<strong>Server Hello Done</strong>」，包含<ul>
<li>选择<strong>椭圆曲线</strong>，选好了椭圆曲线相当于椭圆曲线<strong>基点 G</strong> 也定好了，这些都会公开给客户端；</li>
<li>生成随机数作为服务端椭圆曲线的私钥，保留到本地；</li>
<li>根据基点 G 和私钥计算出<strong>服务端的椭圆曲线公钥</strong>，这个会公开给客户端。</li>
</ul>
</li>
<li>服务器端发送「<strong>Server Key Exchange</strong>」，表明自己本次发送完毕</li>
</ul>
</li>
<li><strong>第三次握手</strong><ul>
<li>客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成<strong>客户端的椭圆曲线公钥；</strong></li>
<li>客户端发送「<strong>Client Key Exchange</strong>」；</li>
<li>双方根据已经得到的<strong>对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G</strong>，计算出点(x, y)；<strong>最终的会话密钥，就是用「客户端随机数 + 服务端随机数 +  x 」三个材料生成的</strong>。</li>
<li>客户端发送「<strong>Change Cipher Spec</strong>」，告诉服务器端开始使用加密方式发送消息；</li>
<li>客户端再发送「<strong>Encrypted Handshake Message（Finishd）</strong>」消息，把之前所有发送的数据做个<strong>摘要</strong>，再用会话密钥（<strong>Master Secret</strong>）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。</li>
</ul>
</li>
<li><strong>第四次握手</strong><ul>
<li>服务器也是同样的操作，发送「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息；</li>
<li>如果双方都验证加密和解密没问题，那么握手正式完成。</li>
</ul>
</li>
</ul>
<h2 id="18、HTTPS-如何优化？"><a href="#18、HTTPS-如何优化？" class="headerlink" title="18、HTTPS 如何优化？"></a>18、HTTPS 如何优化？</h2><blockquote>
<p>产生性能消耗的两个环节：</p>
<ul>
<li>第一个环节， TLS 协议握手过程；</li>
<li>第二个环节，握手后的对称加密报文传输。</li>
</ul>
<p>主要针对第一个环节进行优化，考虑以下方面：</p>
<ul>
<li><strong>硬件优化</strong><ul>
<li>由于HTTPS 协议是计算密集型，而不是 I&#x2F;O 密集型，因此对CPU性能进行提升，选择可以支持 AES-NI 特性的 CPU；</li>
</ul>
</li>
<li><strong>协议优化</strong><ul>
<li>用ECDHE算法替代RSA算法；</li>
<li>椭圆曲线尽量选择x25519曲线；</li>
<li>对称加密算法方面，如果对安全性需求不是特别高，可以选用 AES_128_GCM，由于密钥长度较短，比 AES_256_GCM 速度更快；</li>
</ul>
</li>
<li><strong>证书优化</strong><ul>
<li><strong>证书传输</strong>方面，选择椭圆曲线（ECDSA）证书而不是 RSA 证书，因为在相同安全强度下， ECC 密钥长度比 RSA 短的多；</li>
<li><strong>证书验证</strong>方面，采用OSCP Stapling；</li>
</ul>
</li>
<li><strong>会话复用：</strong>把首次 TLS 握手协商的对称加密密钥缓存起来，待下次需要建立 HTTPS 连接时，直接「复用」这个密钥<ul>
<li><strong>Session ID</strong>：客户端和服务器首次  TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识，Session ID 和会话密钥相当于 key-value 的关系。</li>
<li><strong>Session Ticket</strong>：服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端，类似于 HTTP 的 Cookie。客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信。</li>
</ul>
</li>
</ul>
</blockquote>
<p>TLS 协议握手过程的性能消耗：</p>
<ul>
<li>对于 ECDHE 密钥协商算法，握手过程中会客户端和服务端都需要临时生成椭圆曲线公私钥；</li>
<li>客户端验证证书时，会访问 CA 获取 CRL 或者 OCSP，目的是验证服务器的证书是否有被吊销；</li>
<li>双方计算 Pre-Master，也就是对称加密密钥；</li>
</ul>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/tls%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97.png" alt="img" style="zoom:67%;" />

<h1 id="三、TCP篇"><a href="#三、TCP篇" class="headerlink" title="三、TCP篇"></a>三、TCP篇</h1><h2 id="19、TCP头格式"><a href="#19、TCP头格式" class="headerlink" title="19、TCP头格式"></a>19、TCP头格式</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101258417.png" alt="TCP 头格式" style="zoom:50%;" />

<p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p>
<p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p>
<p><strong>控制位：</strong></p>
<ul>
<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li>
</ul>
<h2 id="20、什么是-TCP-？"><a href="#20、什么是-TCP-？" class="headerlink" title="20、什么是 TCP ？"></a>20、什么是 TCP ？</h2><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p>
<ul>
<li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP  报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP  报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li>
</ul>
<h2 id="21、如何唯一确定一个TCP连接？"><a href="#21、如何唯一确定一个TCP连接？" class="headerlink" title="21、如何唯一确定一个TCP连接？"></a>21、如何唯一确定一个TCP连接？</h2><p>通过TCP四元组确定：源地址、源端口、目的地址和目的端口。</p>
<blockquote>
<p>有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？</p>
</blockquote>
<p>服务端通常固定在某个本地端口上监听，等待客户端的连接请求。因此，客户端 IP 和端口是可变的，其理论值计算公式如下:</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230436594.png" alt="img" style="zoom: 67%;" />

<p>对 IPv4，客户端的 IP 数最多为 <code>2</code> 的 <code>32</code> 次方，客户端的端口数最多为 <code>2</code> 的 <code>16</code> 次方，也就是服务端单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方。</p>
<p>当然，服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：</p>
<ul>
<li>文件描述符限制，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：<ul>
<li><strong>系统级</strong>：当前系统可打开的最大数量，通过 <code>cat /proc/sys/fs/file-max</code> 查看；</li>
<li><strong>用户级</strong>：指定用户可打开的最大数量，通过 <code>cat /etc/security/limits.conf</code> 查看；</li>
<li><strong>进程级</strong>：单个进程可打开的最大数量，通过 <code>cat /proc/sys/fs/nr_open</code> 查看；</li>
</ul>
</li>
<li><strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。</li>
</ul>
<h2 id="22、TCP和UDP的区别，分别的应用场景？"><a href="#22、TCP和UDP的区别，分别的应用场景？" class="headerlink" title="22、TCP和UDP的区别，分别的应用场景？"></a>22、TCP和UDP的区别，分别的应用场景？</h2><h3 id="1、TCP-和-UDP-区别"><a href="#1、TCP-和-UDP-区别" class="headerlink" title="1、TCP 和 UDP 区别"></a>1、TCP 和 UDP 区别</h3><p><em><strong>1. 连接</strong></em></p>
<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p><em><strong>2. 服务对象</strong></em></p>
<ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<p><em><strong>3. 可靠性</strong></em></p>
<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP 协议实现可靠传输？</a></li>
</ul>
<p><em><strong>4. 拥塞控制、流量控制</strong></em></p>
<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<p><em><strong>5. 首部开销</strong></em></p>
<ul>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
<p><em><strong>6. 传输方式</strong></em></p>
<ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
<p><em><strong>7. 分片不同</strong></em></p>
<ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>
<h3 id="2、TCP-和-UDP-应用场景"><a href="#2、TCP-和-UDP-应用场景" class="headerlink" title="2、TCP 和 UDP 应用场景"></a>2、TCP 和 UDP 应用场景</h3><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<ul>
<li><code>FTP</code> 文件传输；</li>
<li><code>HTTP</code> &#x2F; <code>HTTPS</code>；</li>
</ul>
<p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li>
<li>视频、音频等多媒体通信；</li>
<li>广播通信；</li>
</ul>
<blockquote>
<p>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</p>
</blockquote>
<p>原因是 TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p>
<blockquote>
<p>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</p>
</blockquote>
<p>先说说 TCP 是如何计算负载数据长度：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230445811.png" alt="img" style="zoom:50%;" />

<p>其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。</p>
<p>大家这时就奇怪了问：“UDP 也是基于 IP 层的呀，那 UDP 的数据长度也可以通过这个公式计算呀？ 为何还要有「包长度」呢？”</p>
<p>这么一问，确实感觉 UDP 的「包长度」是冗余的。</p>
<p>我查阅了很多资料，我觉得有两个比较靠谱的说法：</p>
<ul>
<li>第一种说法：因为为了网络设备硬件设计和处理方便，首部长度需要是 <code>4</code> 字节的整数倍。如果去掉 UDP 的「包长度」字段，那 UDP 首部长度就不是 <code>4</code> 字节的整数倍了，所以我觉得这可能是为了补全 UDP 首部长度是  <code>4</code> 字节的整数倍，才补充了「包长度」字段。</li>
<li>第二种说法：如今的 UDP 协议是基于 IP 协议发展的，而当年可能并非如此，依赖的可能是别的不提供自身报文长度或首部长度的网络层协议，因此 UDP 报文首部需要有长度字段以供计算。</li>
</ul>
<h2 id="23、详细说明三次握手"><a href="#23、详细说明三次握手" class="headerlink" title="23、详细说明三次握手"></a>23、详细说明三次握手</h2><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手" style="zoom:50%;" />

<ol>
<li>服务端主动监听某个端口，处于 <code>LISTEN</code> 状态，等待客户端的连接请求；</li>
<li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态；</li>
<li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态；</li>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED</code> 状态；</li>
<li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li>
</ol>
<blockquote>
<p><strong>TIP：客户端发送三次握手（ack 报文）后就可以发送数据了，而被动方此时还是 syn_received 状态，如果 ack 丢了，那客户端发的数据是不是也白白浪费了？</strong></p>
<p>不是的，即使服务端还是在 syn_received 状态，收到了客户端发送的数据，还是可以建立连接的，并且还可以正常收到这个数据包。这是因为数据报文中是有 ack 标识位，也有确认号，这个确认号就是确认收到了第二次握手。如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%9B%B8%E5%90%8Cack.png" alt="img"></p>
<p>所以，服务端收到这个数据报文，是可以正常建立连接的，然后就可以正常接收这个数据包了。</p>
</blockquote>
<h2 id="24、为什么是三次握手？不是两次、四次？"><a href="#24、为什么是三次握手？不是两次、四次？" class="headerlink" title="24、为什么是三次握手？不是两次、四次？"></a>24、为什么是三次握手？不是两次、四次？</h2><blockquote>
<p>不使用「两次握手」和「四次握手」的原因：</p>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
<p>从以下两个原因进行分析：</p>
<p>原因一：避免历史连接，造成资源浪费；</p>
<p>原因二：同步双方初始序列号。</p>
</blockquote>
<p><strong>（1）原因一：避免历史连接，造成资源浪费</strong></p>
<p>防止已经失效的连接请求报文段突然又传到服务端，因而产生错误。</p>
<p>这种情况是：<strong>客户端发出的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到下一个连接释放以后的某个时间才到达服务器端。</strong>当服务器端收到此失效报文后，会误认为是客户端发出的一个新连接请求，于是客户端又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要服务器端发出确认报文就会认为新的连接已经建立了，但此时客户端并没有发出建立连接的请求，因此不会向服务器端发送数据。服务器端没有收到数据就会一直等待，这样就会白白浪费掉很多资源。</p>
<blockquote>
<p><strong>TIP：如果服务端在收到 RST 报文之前，先收到了「新 SYN 报文」，也就是服务端收到客户端报文的顺序是：「旧 SYN 报文」-&gt;「新 SYN 报文」，此时会发生什么?</strong></p>
<p>当服务端第一次收到 SYN 报文，也就是收到 「旧 SYN 报文」时，就会回复 <code>SYN + ACK</code> 报文给客户端，此报文中的确认号是 91（90+1）。</p>
<p>然后这时再收到「新 SYN 报文」时，就会回 <a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/challenge_ack.html">Challenge Ack</a>报文给客户端，<strong>这个 ack 报文并不是确认收到「新 SYN 报文」的，而是上一次的 ack 确认号</strong>，也就是91（90+1）。所以客户端收到此 ACK 报文时，发现自己期望收到的确认号应该是 101，而不是 91，于是就会回 RST 报文。</p>
</blockquote>
<p><strong>（2）原因二：同步双方初始序列号</strong></p>
<p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li>
</ul>
<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p>
<p>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<h2 id="25、为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#25、为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="25、为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>25、为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h2><blockquote>
<p>主要原因有两个方面：</p>
<ul>
<li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li>
<li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收。</li>
</ul>
</blockquote>
<p><strong>详述方面一：为了防止历史报文被下一个相同四元组的连接接收</strong></p>
<p>如果每次建立连接客户端和服务端的初始化序列号都「不一样」，就有大概率因为历史报文的序列号「不在」对方接收窗口，从而很大程度上避免了历史报文，相反，如果每次建立连接客户端和服务端的初始化序列号都「一样」，就有大概率遇到历史报文的序列号刚「好在」对方的接收窗口内，从而导致历史报文被新连接成功接收。</p>
<p>所以，每次初始化序列号不一样很大程度上能够避免历史报文被下一个相同四元组的连接接收，注意是很大程度上，并不是完全避免了，<strong>因为序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据</strong>，所以需要用时间戳的机制来判断历史报文。</p>
<h2 id="26、初始序列号-ISN-是如何随机产生的？"><a href="#26、初始序列号-ISN-是如何随机产生的？" class="headerlink" title="26、初始序列号 ISN 是如何随机产生的？"></a>26、初始序列号 ISN 是如何随机产生的？</h2><p>起始 <code>ISN</code> 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时。</p>
<p>RFC793 提到初始化序列号 ISN 随机生成算法：ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)。</p>
<ul>
<li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li>
<li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li>
</ul>
<p>可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。</p>
<h2 id="27、既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#27、既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="27、既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>27、既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h2><blockquote>
<p>如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，此时，<strong>如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP  层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 +  数据）」。</p>
<p>所以，为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。经过 TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片，大大增加了重传的效率。</p>
</blockquote>
<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230633447.png" alt="MTU 与 MSS" style="zoom: 67%;" />

<ul>
<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li>
<li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li>
</ul>
<p>如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，当 IP 层有一个超过 <code>MTU</code> 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上一层 TCP 传输层。</p>
<p>此时，<strong>如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP  层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 +  数据）」。</p>
<p>因此，可以得知由 IP 层进行分片传输，是非常没有效率的。</p>
<p>所以，为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230628926.png" alt="握手阶段协商 MSS"></p>
<p>经过 TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片，大大增加了重传的效率。</p>
<h2 id="28、第一次握手丢失了，会发生什么？"><a href="#28、第一次握手丢失了，会发生什么？" class="headerlink" title="28、第一次握手丢失了，会发生什么？"></a>28、第一次握手丢失了，会发生什么？</h2><blockquote>
<p>当第一次握手丢失了（SYN 丢失），客户端会重传 SYN 报文。</p>
<p>若重传 SYN 报文达到最大重传次数，还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</p>
</blockquote>
<p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 <code>SYN_SENT</code> 状态。</p>
<p>若第一次握手丢失，导致客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</p>
<p>根据不同内核的设定，超时时间也有所不同。当客户端在超时时间后依旧没收到服务端的 SYN-ACK 报文时，客户端就会重发 SYN 报文N次，在 Linux 里，客户端的 SYN 报文最大重传次数N由 <code>tcp_syn_retries</code>内核参数控制，这个参数是可以自定义的，默认值一般是 5。</p>
<p>若重发N次后还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</p>
<h2 id="29、第二次握手丢失了，会发生什么？"><a href="#29、第二次握手丢失了，会发生什么？" class="headerlink" title="29、第二次握手丢失了，会发生什么？"></a>29、第二次握手丢失了，会发生什么？</h2><blockquote>
<p>当第二次握手丢失了（SYN, ACK 报文丢失），客户端和服务端都会重传：</p>
<ul>
<li>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 <code>tcp_syn_retries</code>内核参数决定；</li>
<li>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定。</li>
</ul>
<p>当客户端超时重传 SYN 报文达到最大重传次数，再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</p>
<p>同理，当服务端超时重传 SYN-ACK 报文达到最大重传次数，再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。</p>
</blockquote>
<p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 <code>SYN_RCVD</code> 状态。</p>
<p>第二次握手的 <code>SYN-ACK</code> 报文其实有两个目的 ：</p>
<ul>
<li>第二次握手里的 ACK， 是对第一次握手的确认报文；</li>
<li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</li>
</ul>
<p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。</p>
<p>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p>
<h2 id="30、第三次握手丢失了，会发生什么？"><a href="#30、第三次握手丢失了，会发生什么？" class="headerlink" title="30、第三次握手丢失了，会发生什么？"></a>30、第三次握手丢失了，会发生什么？</h2><blockquote>
<p>当第三次握手丢失了（ACK 报文丢失），服务器端会重传 SYN-ACK 报文。</p>
<p>当服务端超时重传 SYN-ACK 报文达到最大重传次数时，再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接</p>
</blockquote>
<p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 <code>ESTABLISH</code> 状态。</p>
<p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p>
<h2 id="31、为什么ACK信号是SYN信号值-1？"><a href="#31、为什么ACK信号是SYN信号值-1？" class="headerlink" title="31、为什么ACK信号是SYN信号值+1？"></a>31、为什么ACK信号是SYN信号值+1？</h2><p>TCP（传输控制协议）的三次握手过程是建立一个可靠的连接会话的关键步骤。在这个过程中，ACK（确认）信号的值为SYN（同步）信号的值加1的原因主要是为了确认双方的接收能力和确保序列号的同步。</p>
<h2 id="32、三次握手的过程中可以携带数据吗"><a href="#32、三次握手的过程中可以携带数据吗" class="headerlink" title="32、三次握手的过程中可以携带数据吗"></a>32、三次握手的过程中可以携带数据吗</h2><p>第三次握手的时候可以携带数据，第一次和第二次握手不可以。</p>
<h2 id="33、什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#33、什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="33、什么是 SYN 攻击？如何避免 SYN 攻击？"></a>33、什么是 SYN 攻击？如何避免 SYN 攻击？</h2><p><strong>（1）什么是SYN攻击？</strong></p>
<p><strong>什么是 TCP 半连接和全连接队列。</strong></p>
<p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<ul>
<li>半连接队列，也称 SYN 队列；</li>
<li>全连接队列，也称 accept 队列；</li>
</ul>
<p>我们先来看下 Linux 内核的 <code>SYN</code> 队列（半连接队列）与 <code>Accpet</code> 队列（全连接队列）是如何工作的？</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101543018.png" alt="正常流程" style="zoom:50%;" />

<p>正常流程：</p>
<ul>
<li>当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；</li>
<li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li>
<li>服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；</li>
<li>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出连接对象。</li>
</ul>
<p>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文。</p>
<p> TCP 连接建立需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，<strong>当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃，导致客户端无法和服务端建立连接</strong>，使得服务端不能为正常用户服务。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101541969.png" alt="SYN 攻击" style="zoom: 80%;" />

<p><strong>（2）如何避免 SYN 攻击？</strong></p>
<blockquote>
<p>避免 SYN 攻击方式，可以有以下四种方法：</p>
<ul>
<li>调大 netdev_max_backlog；</li>
<li>增大 TCP 半连接队列；</li>
<li>开启 tcp_syncookies；</li>
<li>减少 SYN+ACK 重传次数</li>
</ul>
</blockquote>
<h2 id="34、详细说明四次挥手"><a href="#34、详细说明四次挥手" class="headerlink" title="34、详细说明四次挥手"></a>34、详细说明四次挥手</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101556792.png" alt="客户端主动关闭连接 —— TCP 四次挥手" style="zoom: 67%;" />

<ul>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<p>可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p>
<h2 id="35、为什么挥手需要四次？"><a href="#35、为什么挥手需要四次？" class="headerlink" title="35、为什么挥手需要四次？"></a>35、为什么挥手需要四次？</h2><p>再来回顾下四次挥手双方发 <code>FIN</code> 包的过程，就能理解为什么需要四次了。</p>
<ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，因此是需要四次挥手。</p>
<h2 id="36、第一次挥手丢失了，会发生什么？"><a href="#36、第一次挥手丢失了，会发生什么？" class="headerlink" title="36、第一次挥手丢失了，会发生什么？"></a>36、第一次挥手丢失了，会发生什么？</h2><p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 <code>FIN_WAIT_1</code> 状态。</p>
<p>正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 <code>FIN_WAIT2</code>状态。如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 <code>tcp_orphan_retries</code> 参数控制。</p>
<p>当客户端重传 FIN 报文的次数超过 <code>tcp_orphan_retries</code> 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么直接进入到 <code>close</code> 状态。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.png" alt="img" style="zoom:50%;" />

<h2 id="37、第二次挥手丢失了，会发生什么？"><a href="#37、第二次挥手丢失了，会发生什么？" class="headerlink" title="37、第二次挥手丢失了，会发生什么？"></a>37、第二次挥手丢失了，会发生什么？</h2><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 <code>CLOSE_WAIT</code> 状态。</p>
<p>在前面我们也提了，<strong>ACK 报文是不会重传的</strong>，所以如果服务端的第二次挥手丢失了，<strong>客户端就会触发超时重传机制，重传 FIN 报文</strong>，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.png" alt="img" style="zoom:50%;" />

<p>这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 <code>FIN_WAIT2</code> 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。</p>
<p>对于 <strong>close 函数</strong>关闭的连接，由于无法再发送和接收数据，所以<code>FIN_WAIT2</code> 状态不可以持续太久，而 <code>tcp_fin_timeout</code> 控制了这个状态下连接的持续时长，默认值是 60 秒。这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/fin_wait_2.drawio.png" alt="img" style="zoom:50%;" />

<p>但是注意，如果主动关闭方使用 <strong>shutdown 函数</strong>关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 <code>FIN_WAIT2</code> 状态（<code>tcp_fin_timeout</code> 无法控制 shutdown 关闭的连接）。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/fin_wait_2%E6%AD%BB%E7%AD%89.drawio.png" alt="img" style="zoom:50%;" />

<h2 id="38、第三次挥手丢失了，会发生什么？"><a href="#38、第三次挥手丢失了，会发生什么？" class="headerlink" title="38、第三次挥手丢失了，会发生什么？"></a>38、第三次挥手丢失了，会发生什么？</h2><p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 <code>CLOSE_WAIT</code> 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。</p>
<p>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 <code>tcp_orphan_retries</code> 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101604609.png" alt="img" style="zoom:50%;" />

<h2 id="39、第四次挥手丢失了，会发生什么？"><a href="#39、第四次挥手丢失了，会发生什么？" class="headerlink" title="39、第四次挥手丢失了，会发生什么？"></a>39、第四次挥手丢失了，会发生什么？</h2><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 <code>TIME_WAIT</code> 状态。</p>
<p>在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 <code>tcp_orphan_retries</code> 参数控制。</p>
<p>举个例子，假设 tcp_orphan_retries 为 2，当第四次挥手一直丢失时，发生的过程如下：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101603186.png" alt="img" style="zoom:50%;" />

<h2 id="40、为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#40、为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="40、为什么 TIME_WAIT 等待的时间是 2MSL？"></a>40、为什么 TIME_WAIT 等待的时间是 2MSL？</h2><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 <code>TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。<strong>TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</strong>。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p>
<p>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 <code>FIN</code> 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。可以看到 <strong>2MSL时长</strong> 这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。<code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p>
<p><strong>Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。其定义在 Linux 内核代码里的名称为 TCP_TIMEWAIT_LEN：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_TIMEWAIT_LEN (60*HZ) <span class="comment">/* how long to wait to destroy TIME-WAIT </span></span></span><br><span class="line"><span class="comment"><span class="meta">                                    state, about 60 seconds  */</span></span></span><br></pre></td></tr></table></figure>

<p>如果要修改 TIME_WAIT 的时间长度，只能修改 Linux 内核代码里 TCP_TIMEWAIT_LEN 的值，并重新编译 Linux 内核。</p>
<h2 id="41、为什么需要-TIME-WAIT-状态？"><a href="#41、为什么需要-TIME-WAIT-状态？" class="headerlink" title="41、为什么需要 TIME_WAIT 状态？"></a>41、为什么需要 TIME_WAIT 状态？</h2><blockquote>
<p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p>
<p>需要 TIME-WAIT 状态，主要是两个原因：</p>
<ul>
<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li>
<li>保证「被动关闭连接」的一方，能被正确的关闭；</li>
</ul>
</blockquote>
<p><strong>（1）原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收</strong></p>
<p>为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 <code>2MSL</code> 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p>
<p><strong>（2）原因二：保证「被动关闭连接」的一方，能被正确的关闭</strong></p>
<p>TIME-WAIT 的另一个作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p>
<p>如果客户端（主动关闭方）最后一次 ACK 报文（第四次挥手）在网络中丢失了，那么按照 TCP 可靠性原则，服务端（被动关闭方）会重发 FIN 报文。</p>
<p>假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSE 状态，如果该  ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说不是一个优雅的终止方式。</p>
<p>为了防止这种情况出现，客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TIME-WAIT%E8%BF%9E%E6%8E%A5%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%AD.drawio.png" alt="TIME-WAIT 时间正常，确保了连接正常关闭" style="zoom:50%;" />

<p>客户端在收到服务端重传的 FIN 报文时，TIME_WAIT 状态的等待时间，会重置回 2MSL。</p>
<h2 id="42、TIME-WAIT-过多有什么危害？"><a href="#42、TIME-WAIT-过多有什么危害？" class="headerlink" title="42、TIME_WAIT 过多有什么危害？"></a>42、TIME_WAIT 过多有什么危害？</h2><p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ul>
<li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li>
<li>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</li>
</ul>
<p>客户端和服务端 TIME_WAIT 过多，造成的影响是不同的。</p>
<p><strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的。因此，客户端（发起连接方）都是和「目的 IP+ 目的 PORT 」都一样的服务端建立连接的话，当客户端的 TIME_WAIT  状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的 IP+ 目的 PORT」都一样的服务端建立连接了。不过，即使是在这种场景下，只要连接的是不同的服务端，端口是可以重复使用的，所以客户端还是可以向其他服务端发起连接的，这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。</p>
<p><strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。</p>
<h2 id="43、如何优化-TIME-WAIT？"><a href="#43、如何优化-TIME-WAIT？" class="headerlink" title="43、如何优化 TIME_WAIT？"></a>43、如何优化 TIME_WAIT？</h2><blockquote>
<p>这里给出优化 TIME-WAIT 的几个方式，都是有利有弊：</p>
<ul>
<li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li>
<li>net.ipv4.tcp_max_tw_buckets</li>
<li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li>
</ul>
</blockquote>
<h2 id="44、服务器出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#44、服务器出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="44、服务器出现大量 TIME_WAIT 状态的原因有哪些？"></a>44、服务器出现大量 TIME_WAIT 状态的原因有哪些？</h2><blockquote>
<p>首先要知道 TIME_WAIT 状态是主动关闭连接方才会出现的状态，所以<strong>如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接</strong>。</p>
<p>问题来了，<strong>什么场景下服务端会主动断开连接呢？</strong></p>
<ul>
<li>第一个场景：HTTP 没有使用长连接</li>
<li>第二个场景：HTTP 长连接超时</li>
<li>第三个场景：HTTP 长连接的请求数量达到上限</li>
</ul>
</blockquote>
<p>接下来，分别介绍下。</p>
<p><strong>（1）第一个场景：HTTP 没有使用长连接</strong></p>
<p>只要任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，就无法使用 HTTP 长连接机制，这样在完成一次 HTTP 请求&#x2F;处理后，就会关闭连接。<strong>根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<blockquote>
<p>客户端禁用了 HTTP Keep-Alive，服务端开启 HTTP Keep-Alive，谁是主动关闭方？</p>
</blockquote>
<p>当客户端禁用了 HTTP Keep-Alive，这时候 HTTP 请求的 header 就会有 <code>Connection:close</code> 信息，这时服务端在发完 HTTP 响应后，就会主动关闭连接。</p>
<p>为什么要这么设计呢？HTTP 是请求-响应模型，发起方一直是客户端，HTTP Keep-Alive 的初衷是<strong>为客户端后续的请求重用连接</strong>，如果我们<strong>在某次 HTTP 请求-响应模型中，请求的 header 定义了 <code>connection：close</code> 信息，那不再重用这个连接的时机就只有在服务端了</strong>，所以我们在 HTTP 请求-响应这个周期的「末端」关闭连接是合理的。</p>
<blockquote>
<p>客户端开启了 HTTP Keep-Alive，服务端禁用了 HTTP Keep-Alive，谁是主动关闭方？</p>
</blockquote>
<p>当客户端开启了 HTTP Keep-Alive，而服务端禁用了 HTTP Keep-Alive，这时服务端在发完 HTTP 响应后，服务端也会主动关闭连接。</p>
<p><strong>因此，当服务端出现大量的 TIME_WAIT 状态连接的时候，可以排查下是否客户端和服务端都开启了 HTTP Keep-Alive，因为任意一方没有开启  HTTP Keep-Alive，都会导致服务端在处理完一个 HTTP 请求后，就主动关闭连接，此时服务端上就会出现大量的 TIME_WAIT 状态的连接。</strong></p>
<p>针对这个场景下，解决的方式也很简单，让客户端和服务端都开启 HTTP Keep-Alive 机制。</p>
<p><strong>（2）第二个场景：HTTP 长连接超时</strong></p>
<p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。HTTP 长连接可以在同一个 TCP 连接上接收和发送多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销。</p>
<p>为了避免资源浪费的情况，web 服务软件一般都会提供一个参数，用来指定 HTTP 长连接的超时时间，比如 nginx 提供的 keepalive_timeout 参数。假设设置了 HTTP 长连接的超时时间是 60 秒，nginx 就会启动一个「定时器」，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<p><strong>当服务端出现大量 TIME_WAIT 状态的连接时，如果现象是有大量的客户端建立完 TCP 连接后，很长一段时间没有发送数据，那么大概率就是因为 HTTP 长连接超时，导致服务端主动关闭连接，产生大量处于 TIME_WAIT 状态的连接。可以往网络问题的方向排查，比如是否是因为网络问题，导致客户端发送的数据一直没有被服务端接收到，以至于 HTTP 长连接超时。</strong></p>
<p><strong>（3）第三个场景：HTTP 长连接的请求数量达到上限</strong></p>
<p>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。比如 nginx 的 keepalive_requests 这个参数，这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个 HTTP 长连接上已经接收并处理的客户端请求的数量。<strong>如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<p>keepalive_requests 参数的默认值是 100 ，意味着每个 HTTP 长连接最多只能跑 100  次请求，这个参数往往被大多数人忽略，因为当 QPS (每秒请求数) 不是很高时，默认值 100 凑合够用。</p>
<p>但是，<strong>对于一些 QPS 比较高的场景，比如超过 10000 QPS，甚至达到 30000 , 50000 甚至更高，如果 keepalive_requests 参数值是 100，这时候就 nginx 就会很频繁地关闭连接，那么此时服务端上就会出大量的 TIME_WAIT 状态</strong>。</p>
<p>针对这个场景下，解决的方式也很简单，调大 nginx 的 keepalive_requests 参数就行。</p>
<h2 id="45、服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#45、服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="45、服务器出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>45、服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h2><p>CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p>
<p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p>
<p>那什么情况会导致服务端的程序没有调用 close 函数关闭连接？这时候通常需要排查代码。</p>
<p>我们先来分析一个普通的 TCP 服务端的流程：</p>
<ol>
<li>创建服务端 socket，bind 绑定端口、listen 监听端口</li>
<li>将服务端 socket 注册到 epoll</li>
<li>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</li>
<li>将已连接的 socket 注册到 epoll</li>
<li>epoll_wait 等待事件发生</li>
<li>对方连接关闭时，我方调用 close</li>
</ol>
<p>可能导致服务端没有调用 close 函数的原因，如下。</p>
<p><strong>第一个原因</strong>：第 2 步没有做，没有将服务端 socket 注册到 epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了。</p>
<p>不过这种原因发生的概率比较小，这种属于明显的代码逻辑 bug，在前期 read view 阶段就能发现的了。</p>
<p><strong>第二个原因</strong>： 第 3 步没有做，有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。</p>
<p>发生这种情况可能是因为服务端在执行 accpet  函数之前，代码卡在某一个逻辑或者提前抛出了异常。</p>
<p><strong>第三个原因</strong>：第 4 步没有做，通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。发生这种情况可能是因为服务端在将已连接的 socket 注册到 epoll 之前，代码卡在某一个逻辑或者提前抛出了异常。</p>
<p><strong>第四个原因</strong>：第 6 步没有做，当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。</p>
<p>可以发现，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。</p>
<h2 id="46、如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#46、如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="46、如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>46、如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于   <code>ESTABLISH</code> 状态，占用着系统资源。</p>
<p>为了避免这种情况，TCP 设置了<strong>保活机制</strong>。这个机制的原理是这样的：</p>
<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP  连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<h2 id="47、如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a href="#47、如果已经建立了连接，但是服务端的进程崩溃会发生什么？" class="headerlink" title="47、如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a>47、如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h2><p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN  报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p>
<blockquote>
<p>我自己做了个实验，使用 kill -9 来模拟进程崩溃的情况，发现<strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。</p>
</blockquote>
<h2 id="48、针对-TCP-应该如何-Socket-编程？"><a href="#48、针对-TCP-应该如何-Socket-编程？" class="headerlink" title="48、针对 TCP 应该如何 Socket 编程？"></a>48、针对 TCP 应该如何 Socket 编程？</h2><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230545997.png" alt="基于 TCP 协议的客户端和服务端工作"></p>
<ul>
<li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li>
<li>服务端调用 <code>bind</code>，将 socket 绑定在指定的 IP 地址和端口;</li>
<li>服务端调用 <code>listen</code>，进行监听；</li>
<li>服务端调用 <code>accept</code>，等待客户端连接；</li>
<li>客户端调用 <code>connect</code>，向服务端的地址和端口发起连接请求；</li>
<li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li>
<li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li>
<li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li>
</ul>
<p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p>
<p>所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p>
<p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>
<h2 id="49、accept-发生在三次握手的哪一步？"><a href="#49、accept-发生在三次握手的哪一步？" class="headerlink" title="49、accept 发生在三次握手的哪一步？"></a>49、accept 发生在三次握手的哪一步？</h2><p>我们先看看客户端连接服务端时，发送了什么？</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/socket%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="socket 三次握手" style="zoom:50%;" />

<ul>
<li>客户端的协议栈向服务端发送了 SYN 包，并告诉服务端当前发送序列号 client_isn，客户端进入 SYN_SENT 状态；</li>
<li>服务端的协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 client_isn+1，表示对 SYN 包 client_isn 的确认，同时服务端也发送一个 SYN  包，告诉客户端当前我的发送序列号为 server_isn，服务端进入 SYN_RCVD 状态；</li>
<li>客户端协议栈收到 ACK 之后，使得应用程序从 <code>connect</code> 调用返回，表示客户端到服务端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务端的 SYN 包进行应答，应答数据为 server_isn+1；</li>
<li>ACK 应答包到达服务端后，服务端的 TCP 连接进入 ESTABLISHED 状态，同时服务端协议栈使得 <code>accept</code> 阻塞调用返回，这个时候服务端到客户端的单向连接也建立成功。至此，客户端与服务端两个方向的连接都建立成功。</li>
</ul>
<p>从上面的描述过程，我们可以得知<strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。</strong></p>
<h2 id="49、TCP可靠性相关"><a href="#49、TCP可靠性相关" class="headerlink" title="49、TCP可靠性相关"></a>49、TCP可靠性相关</h2><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/3.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="img" style="zoom:50%;" />

<h3 id="1、重传机制"><a href="#1、重传机制" class="headerlink" title="1、重传机制"></a>1、重传机制</h3><blockquote>
<p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p>
<p>常见的重传机制：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
<li>SACK</li>
<li>D-SACK</li>
</ul>
</blockquote>
<p><strong>（1）超时重传</strong></p>
<p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p>
<p>TCP 会在以下两种情况发生超时重传：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<p><strong>超时重传时间 RTO 的值应该略大于报文往返  RTT 的值</strong>。如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是<strong>超时间隔加倍。</strong>也就是<strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p>
<blockquote>
<p>超时时间应该设置为多少呢？</p>
</blockquote>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/6.jpg?" alt="RTT" style="zoom:50%;" />

<p><code>RTT</code>（Round-Trip Time 往返时延）指的是<strong>数据发送时刻到接收到确认的时刻的差值</strong>，也就是包的往返时间。实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个<strong>动态变化的值</strong>。</p>
<p>超时重传时间是以 <code>RTO</code> （Retransmission Timeout 超时重传时间）表示。假设在重传的情况下，超时时间 <code>RTO</code> 「较长或较短」时的表现如下：</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/7.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="超时时间较长与较短" style="zoom:50%;" />

<p>因此，<strong>超时重传时间 RTO 的值应该略大于报文往返  RTT 的值</strong>。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/8.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="RTO 应略大于 RTT" style="zoom: 67%;" />

<p><strong>（2）快速重传</strong></p>
<p>TCP 还有另外一种<strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
<p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<strong>重传的时候，是重传一个，还是重传所有的问题。</strong></p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传机制" style="zoom: 80%;" />



<p>为了解决不知道该重传哪些 TCP 报文，于是就有 <code>SACK</code> 方法。</p>
<p><strong>（3）SACK 方法</strong></p>
<p><code>SACK</code>（ Selective Acknowledgment）， <strong>选择性确认</strong>。</p>
<p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<p>如果要支持 <code>SACK</code>，必须双方都要支持。在 Linux 下，可以通过 <code>net.ipv4.tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）。</p>
<p><strong>（4）Duplicate SACK</strong></p>
<p>Duplicate SACK 又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</strong></p>
<p><code>D-SACK</code> 有这么几个好处：</p>
<ol>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了;</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了;</li>
</ol>
<p>在 Linux 下可以通过 <code>net.ipv4.tcp_dsack</code> 参数开启&#x2F;关闭这个功能（Linux 2.4 后默认打开）。</p>
<h3 id="2、滑动窗口"><a href="#2、滑动窗口" class="headerlink" title="2、滑动窗口"></a>2、滑动窗口</h3><blockquote>
<p>引入窗口概念的原因</p>
</blockquote>
<p>TCP 每发送一个数据，都要进行一次确认应答。这样的传输方式有一个缺点：数据包的<strong>往返时间越长，通信的效率就越低</strong>。为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。窗口大小是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p>
<p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/15.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="用滑动窗口方式并行处理" style="zoom: 67%;" />

<p>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p>
<blockquote>
<p>窗口大小由哪一方决定？</p>
</blockquote>
<p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</p>
<p><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong></p>
<p>所以，通常窗口的大小是由接收方的窗口大小来决定的。</p>
<p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>
<blockquote>
<p>接收窗口和发送窗口的大小是相等的吗？</p>
</blockquote>
<p>并不是完全相等，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。</p>
<p>因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</p>
<h3 id="3、流量控制"><a href="#3、流量控制" class="headerlink" title="3、流量控制"></a>3、流量控制</h3><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p>
<p>为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p>
<p><strong>（1）窗口关闭</strong></p>
<p>TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。<strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</strong></p>
<blockquote>
<p>窗口关闭潜在的危险</p>
</blockquote>
<p>接收方向发送方通告窗口大小时，是通过 <code>ACK</code> 报文来通告的。那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/24.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="窗口关闭潜在的危险" style="zoom:50%;" />

<blockquote>
<p>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</p>
</blockquote>
<p>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/25.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="窗口探测" style="zoom: 50%;" />

<ul>
<li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；</li>
<li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li>
</ul>
<p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code>RST</code> 报文来中断连接。</p>
<h3 id="4、拥塞控制"><a href="#4、拥塞控制" class="headerlink" title="4、拥塞控制"></a>4、拥塞控制</h3><blockquote>
<p>为什么要有拥塞控制呀，不是有流量控制了吗？</p>
</blockquote>
<p>前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p>
<p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。<strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p>
<p>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。</p>
<blockquote>
<p>什么是拥塞窗口？和发送窗口有什么关系呢？</p>
</blockquote>
<p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p>
<p>我们在前面提到过发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p>
<p>拥塞窗口 <code>cwnd</code> 变化的规则：</p>
<ul>
<li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li>
<li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li>
</ul>
<blockquote>
<p>那么怎么知道当前网络是否出现了拥塞呢？</p>
</blockquote>
<p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p>
<blockquote>
<p>拥塞控制有哪些控制算法？</p>
</blockquote>
<p>拥塞控制主要是四个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<h2 id="50、如何理解是-TCP-面向字节流协议？"><a href="#50、如何理解是-TCP-面向字节流协议？" class="headerlink" title="50、如何理解是 TCP 面向字节流协议？"></a>50、如何理解是 TCP 面向字节流协议？</h2><p>之所以会说 TCP 是面向字节流的协议，UDP 是面向报文的协议，是因为操作系统对 TCP 和 UDP 协议的<strong>发送方的机制不同</strong>，也就是问题原因在发送方。</p>
<blockquote>
<p>先来说说为什么 UDP 是面向报文的协议？</p>
</blockquote>
<p>当用户消息通过 UDP 协议传输时，<strong>操作系统不会对消息进行拆分</strong>，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是<strong>每个 UDP 报文就是一个用户消息的边界</strong>，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。</p>
<p>操作系统在收到 UDP 报文后，会将其插入到队列里，<strong>队列里的每一个元素就是一个 UDP 报文</strong>，这样当用户调用 recvfrom() 系统调用读数据的时候，就会从队列里取出一个数据，然后从内核里拷贝给用户缓冲区。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101710378.png" alt="图片" style="zoom: 67%;" />

<blockquote>
<p>再来说说为什么 TCP 是面向字节流的协议？</p>
</blockquote>
<p>当用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。这时，接收方的程序如果不知道发送方发送的消息的长度，也就是不知道消息的边界时，是无法读出一个有效的用户消息的，因为用户消息被拆分成多个 TCP 报文后，并不能像 UDP 那样，一个 UDP 报文就能代表一个完整的用户消息。</p>
<p>举个实际的例子来说明。</p>
<p>发送方准备发送 「Hi.」和「I am Xiaolin」这两个消息。</p>
<p>在发送端，当我们调用 send 函数完成数据“发送”以后，数据并没有被真正从网络上发送出去，只是从应用程序拷贝到了操作系统内核协议栈中。至于什么时候真正被发送，<strong>取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件</strong>。也就是说，我们不能认为每次 send 调用发送的数据，都会作为一个整体完整地消息被发送出去。</p>
<p>如果我们考虑实际网络传输过程中的各种影响，假设发送端陆续调用 send 函数先后发送 「Hi.」和「I am Xiaolin」 报文，那么实际的发送很有可能是这几种情况。</p>
<p>第一种情况，这两个消息被分到同一个 TCP 报文，像这样：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/02dce678f870c8c70482b6e37dbb5574.png" alt="图片" style="zoom:67%;" />

<p>第二种情况，「I am Xiaolin」的部分随 「Hi」 在一个 TCP 报文中发送出去，像这样：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/f58b70cde860188b8f95a433e2f5293b.png" alt="图片" style="zoom: 67%;" />

<p>第三种情况，「Hi.」 的一部分随 TCP 报文被发送出去，另一部分和 「I am Xiaolin」 一起随另一个 TCP 报文发送出去，像这样。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/68080e783d7acc842fa254e4f9ec5630.png" alt="图片" style="zoom:67%;" />

<p>类似的情况还能举例很多种，因此，<strong>我们不能认为一个用户消息对应一个 TCP 报文，正因为这样，所以 TCP 是面向字节流的协议</strong>。当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 TCP 粘包问题，这时接收方不知道消息的边界的话，是无法读出有效的消息。要解决这个问题，要交给<strong>应用程序</strong>。</p>
<h2 id="51、如何解决粘包？"><a href="#51、如何解决粘包？" class="headerlink" title="51、如何解决粘包？"></a>51、如何解决粘包？</h2><blockquote>
<p>粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。</p>
<p>一般有三种方式分包的方式：</p>
<ul>
<li>固定长度的消息；</li>
<li>特殊字符作为边界；</li>
<li>自定义消息结构。</li>
</ul>
</blockquote>
<p><strong>（1）固定长度的消息</strong></p>
<p>这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。</p>
<p><strong>（2）特殊字符作为边界</strong></p>
<p>在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。</p>
<p>HTTP 是一个非常好的例子。HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/a49a6bb8cd38ae1738d9c00aec68b444.png" alt="图片" style="zoom:50%;" />

<p>有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。</p>
<p><strong>（3）自定义消息结构</strong></p>
<p>自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。</p>
<p>比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    <span class="type">u_int32_t</span> message_length; </span><br><span class="line">    <span class="type">char</span> message_data[]; </span><br><span class="line">&#125; message;</span><br></pre></td></tr></table></figure>

<p>当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。</p>
<h2 id="52、已建立连接的TCP，收到SYN会发生什么？"><a href="#52、已建立连接的TCP，收到SYN会发生什么？" class="headerlink" title="52、已建立连接的TCP，收到SYN会发生什么？"></a>52、已建立连接的TCP，收到SYN会发生什么？</h2><p><strong>1. 客户端的 SYN 报文里的端口号与历史连接不相同</strong></p>
<p>如果客户端恢复后发送的 SYN 报文中的源端口号跟上一次连接的源端口号不一样，此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。</p>
<p>那旧连接里处于 Established 状态的服务端最后会怎么样呢？</p>
<ul>
<li>如果服务端发送了数据包给客户端，由于客户端的连接已经被关闭了，此时客户的内核就会回 RST 报文，服务端收到后就会释放连接；</li>
<li>如果服务端一直没有发送数据包给客户端，在超过一段时间后，TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。</li>
</ul>
<p><strong>2. 客户端的 SYN 报文里的端口号与历史连接相同</strong></p>
<p>如果客户端恢复后，发送的 SYN 报文中的源端口号跟上一次连接的源端口号一样，也就是处于 Established 状态的服务端收到了这个 SYN 报文。</p>
<p><strong>处于 Established 状态的服务端，如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN  报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。</strong></p>
<p><strong>接着，客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。</strong></p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/est_syn.png" alt="img" style="zoom:50%;" />

<h2 id="53、四次挥手中收到乱序的-FIN-包会如何处理？"><a href="#53、四次挥手中收到乱序的-FIN-包会如何处理？" class="headerlink" title="53、四次挥手中收到乱序的 FIN 包会如何处理？"></a>53、四次挥手中收到乱序的 FIN 包会如何处理？</h2><blockquote>
<p><strong>在 FIN_WAIT_2 状态下，是如何处理收到的乱序到 FIN 报文，然后 TCP 连接又是什么时候才进入到 TIME_WAIT 状态?</strong></p>
</blockquote>
<p><strong>在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文，那么就被会加入到「乱序队列」，并不会进入到 TIME_WAIT 状态。</strong></p>
<p><strong>等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，然后会检测乱序队列中是否有可用的数据，如果能在乱序队列中找到与当前报文的序列号保持的顺序的报文，就会看该报文是否有 FIN 标志，如果发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。</strong></p>
<img src="https://cdn.xiaolincoding.com//mysql/other/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5p6XY29kaW5n,size_20,color_FFFFFF,t_70,g_se,x_16-20230309230147654.png" alt="img" style="zoom: 67%;" />

<h2 id="54、在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？"><a href="#54、在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？" class="headerlink" title="54、在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？"></a>54、在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？</h2><blockquote>
<p><strong>1、收到合法 SYN</strong></p>
<p>如果处于 TIME_WAIT 状态的连接收到「合法的 SYN 」后，<strong>就会重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程</strong>。</p>
<p><strong>2、收到非法的 SYN</strong></p>
<p>如果处于 TIME_WAIT 状态的连接收到「非法的 SYN 」后，就会<strong>再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号（ack num），就回 RST 报文给服务端</strong>。</p>
</blockquote>
<img src="https://cdn.xiaolincoding.com//mysql/other/74b53919396dcda634cfd5b5795cbf16.png" alt="图片" style="zoom: 67%;" />

<p>针对这个问题，<strong>关键是要看 SYN 的「序列号和时间戳」是否合法</strong>，因为处于 TIME_WAIT 状态的连接收到 SYN 后，会判断 SYN 的「序列号和时间戳」是否合法，然后根据判断结果的不同做不同的处理。</p>
<ul>
<li><strong>合法 SYN</strong>：客户端的  SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>，<strong>并且</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>大</strong>。</li>
<li><strong>非法 SYN</strong>：客户端的  SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>，<strong>或者</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>小</strong>。</li>
</ul>
<p>上面 SYN 合法判断是基于双方都开启了 TCP 时间戳机制的场景，如果双方都没有开启 TCP 时间戳机制，则 SYN 合法判断如下：</p>
<ul>
<li><strong>合法 SYN</strong>：客户端的  SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>。</li>
<li><strong>非法 SYN</strong>：客户端的  SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>。</li>
</ul>
<h2 id="55、在-TIME-WAIT-状态，收到-RST-会断开连接吗？"><a href="#55、在-TIME-WAIT-状态，收到-RST-会断开连接吗？" class="headerlink" title="55、在 TIME_WAIT 状态，收到 RST 会断开连接吗？"></a>55、在 TIME_WAIT 状态，收到 RST 会断开连接吗？</h2><p>在前面我留了一个疑问，处于 TIME_WAIT 状态的连接，收到 RST 会断开连接吗？</p>
<p>会不会断开，关键看 <code>net.ipv4.tcp_rfc1337</code> 这个内核参数（默认情况是为 0）：</p>
<ul>
<li>如果这个参数设置为 0， 收到 RST 报文会提前结束 TIME_WAIT 状态，释放连接。</li>
<li>如果这个参数设置为 1， 就会丢掉 RST 报文。</li>
</ul>
<h2 id="56、针对某个TCP-连接，一端断电和进程崩溃有什么区别？"><a href="#56、针对某个TCP-连接，一端断电和进程崩溃有什么区别？" class="headerlink" title="56、针对某个TCP 连接，一端断电和进程崩溃有什么区别？"></a>56、针对某个TCP 连接，一端断电和进程崩溃有什么区别？</h2><blockquote>
<p>如果是「<strong>客户端进程崩溃</strong>」，那么内核会发送 FIN 报文，与服务端进行四次挥手。</p>
<p>但是，「<strong>客户端主机宕机</strong>」，后续还要看服务端会不会发送数据：</p>
<ul>
<li>如果服务端有发送数据，由于客户端已经不存在，收不到数据报文的响应报文，服务端的数据报文会超时重传，当重传总间隔时长达到一定阈值（内核会根据 tcp_retries2 设置的值计算出一个阈值）后，会断开 TCP 连接；</li>
<li>如果服务端一直不会发送数据，再看服务端有没有开启 TCP keepalive 机制？</li>
<li>如果有开启，服务端在一段时间没有进行数据交互时，会触发 TCP keepalive 机制，探测对方是否存在，如果探测到对方已经消亡，则会断开自身的 TCP 连接；</li>
<li>如果没有开启，服务端的 TCP 连接会一直存在，并且一直保持在 ESTABLISHED 状态。</li>
</ul>
</blockquote>
<h3 id="1、没有数据传输的情况"><a href="#1、没有数据传输的情况" class="headerlink" title="1、没有数据传输的情况"></a>1、没有数据传输的情况</h3><blockquote>
<p>一个TCP连接，没有打开keepalive，没有数据交互，现在一端突然掉电和一端的进程crush了，这两种情况有什么区别呢？</p>
</blockquote>
<ul>
<li><p>TCP keepalive实际上就是 <strong>TCP 的保活机制</strong>：</p>
<p>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</p>
<ul>
<li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li>
<li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li>
</ul>
<p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。</p>
</li>
</ul>
<h4 id="（1）主机崩溃"><a href="#（1）主机崩溃" class="headerlink" title="（1）主机崩溃"></a>（1）主机崩溃</h4><p>知道了 TCP keepalive 作用，我们再回过头看题目中的「主机崩溃」这种情况。</p>
<blockquote>
<p>在没有开启 TCP keepalive，且双方一直没有数据交互的情况下，如果客户端的「主机崩溃」了，会发生什么？</p>
</blockquote>
<p>客户端主机崩溃了，服务端是<strong>无法感知到的</strong>，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程。</p>
<p>所以，我们可以得知一个点，<strong>在没有使用 TCP 保活机制且双方不传输数据的情况下</strong>，一方的 TCP 连接处在 ESTABLISHED 状态，并不代表另一方的连接还一定正常。</p>
<h4 id="（2）进程崩溃"><a href="#（2）进程崩溃" class="headerlink" title="（2）进程崩溃"></a>（2）进程崩溃</h4><blockquote>
<p>那题目中的「进程崩溃」的情况呢？</p>
</blockquote>
<p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN  报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP四次挥手的过程。</p>
<p>使用 kill -9 来模拟进程崩溃的情况，发现<strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</p>
<h3 id="2、有数据传输的情况"><a href="#2、有数据传输的情况" class="headerlink" title="2、有数据传输的情况"></a>2、有数据传输的情况</h3><h4 id="（1）客户端主机宕机，又迅速重启"><a href="#（1）客户端主机宕机，又迅速重启" class="headerlink" title="（1）客户端主机宕机，又迅速重启"></a>（1）客户端主机宕机，又迅速重启</h4><p>在客户端主机宕机后，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的报文。服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：</p>
<ul>
<li>如果客户端主机上<strong>没有</strong>进程绑定该 TCP 报文的目标端口号，那么客户端内核就会<strong>回复 RST 报文，重置该 TCP 连接</strong>；</li>
<li>如果客户端主机上<strong>有</strong>进程绑定该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会<strong>回复 RST 报文，重置该 TCP 连接</strong>。</li>
</ul>
<p>所以，<strong>只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接</strong>。</p>
<h4 id="（2）客户端主机宕机，一直没有重启"><a href="#（2）客户端主机宕机，一直没有重启" class="headerlink" title="（2）客户端主机宕机，一直没有重启"></a>（2）客户端主机宕机，一直没有重启</h4><p>这种情况，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。</p>
<blockquote>
<p>那 TCP 的数据报文具体重传几次呢？</p>
</blockquote>
<p>在 Linux 系统中，提供一个叫 tcp_retries2 配置项，默认值是 15，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/20210615134059647.png" alt="在这里插入图片描述"></p>
<p>这个内核参数是控制在 TCP 连接建立的情况下，超时重传的最大次数。</p>
<p>不过 tcp_retries2 设置了 15 次，并不代表 TCP 超时重传了 15 次才会通知应用程序终止该 TCP 连接，<strong>内核会根据 tcp_retries2 设置的值，计算出一个 timeout</strong>（<em>如果 tcp_retries2 &#x3D;15，那么计算得到的 timeout &#x3D; 924600 ms</em>），<strong>如果重传间隔超过这个 timeout，则认为超过了阈值，就会停止重传，然后就会断开 TCP 连接</strong>。</p>
<p>在发生超时重传的过程中，每一轮的超时时间（RTO）都是<strong>倍数增长</strong>的，比如如果第一轮 RTO 是 200 毫秒，那么第二轮 RTO 是 400 毫秒，第三轮 RTO 是 800 毫秒，以此类推。而 RTO 是基于 RTT（一个包的往返时间） 来计算的，如果 RTT 较大，那么计算出来的 RTO 就越大，那么经过几轮重传后，很快就达到了上面的 timeout 值了。</p>
<p>最小 RTO 和最大 RTO 是在 Linux 内核中定义好了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_RTO_MAX ((unsigned)(120*HZ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_RTO_MIN ((unsigned)(HZ/5))</span></span><br></pre></td></tr></table></figure>

<p>Linux 2.6+ 使用 1000 毫秒的 HZ，因此<code>TCP_RTO_MIN</code>约为 200 毫秒，<code>TCP_RTO_MAX</code>约为 120 秒。</p>
<h2 id="57、拔掉网线后，-原本的-TCP-连接还存在吗？"><a href="#57、拔掉网线后，-原本的-TCP-连接还存在吗？" class="headerlink" title="57、拔掉网线后， 原本的 TCP 连接还存在吗？"></a>57、拔掉网线后， 原本的 TCP 连接还存在吗？</h2><p>实际上，TCP 连接在 Linux 内核中是一个名为 <code>struct socket</code> 的结构体，该结构体的内容包含 TCP 连接的状态等信息。当拔掉网线的时候，操作系统并不会变更该结构体的任何内容，所以 TCP 连接的状态也不会发生改变。</p>
<p><strong>因此，拔掉网线这个动作并不会影响 TCP 连接的状态。</strong>接下来，要看拔掉网线后，双方做了什么动作，此问题需要分场景来讨论：</p>
<ul>
<li>拔掉网线后，有数据传输；</li>
<li>拔掉网线后，没有数据传输。</li>
</ul>
<h3 id="1、拔掉网线后，有数据传输"><a href="#1、拔掉网线后，有数据传输" class="headerlink" title="1、拔掉网线后，有数据传输"></a>1、拔掉网线后，有数据传输</h3><p>在客户端拔掉网线后，服务端向客户端发送的数据报文会得不到任何的响应，在等待一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的数据报文。</p>
<ul>
<li><p><strong>如果在服务端重传报文的过程中，客户端刚好把网线插回去了</strong>，由于拔掉网线并不会改变客户端的 TCP 连接状态，并且还是处于 ESTABLISHED 状态，所以这时客户端是可以正常接收服务端发来的数据报文的，然后客户端就会回 ACK 响应报文。</p>
<p>此时，客户端和服务端的 TCP 连接依然存在的，就感觉什么事情都没有发生；</p>
</li>
<li><p>但是，<strong>如果如果在服务端重传报文的过程中，客户端一直没有将网线插回去</strong>，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。</p>
<p>而等客户端插回网线后，如果客户端向服务端发送了数据，由于服务端已经没有与客户端相同四元祖的 TCP 连接了，因此服务端内核就会回复 RST 报文，客户端收到后就会释放该 TCP 连接。</p>
<p>此时，客户端和服务端的 TCP 连接都已经断开了。</p>
</li>
</ul>
<h3 id="2、拔掉网线后，没有数据传输"><a href="#2、拔掉网线后，没有数据传输" class="headerlink" title="2、拔掉网线后，没有数据传输"></a>2、拔掉网线后，没有数据传输</h3><p>针对拔掉网线后，没有数据传输的场景，还得看是否开启了 TCP keepalive 机制 （TCP 保活机制）。</p>
<ul>
<li><p>如果<strong>没有开启</strong> TCP keepalive 机制，在客户端拔掉网线后，并且双方都没有进行数据传输，那么客户端和服务端的 TCP 连接将会一直保持存在。</p>
</li>
<li><p>而如果<strong>开启</strong>了 TCP keepalive 机制，在客户端拔掉网线后，即使双方都没有进行数据传输，在持续一段时间后，TCP 就会发送探测报文：</p>
<ul>
<li><p>如果<strong>对端是正常工作</strong>的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</p>
</li>
<li><p>如果<strong>对端主机宕机</strong>（<em>注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机</em>），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</p>
</li>
</ul>
<p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。</p>
</li>
</ul>
<h2 id="58、tcp-tw-reuse-为什么默认是关闭的？"><a href="#58、tcp-tw-reuse-为什么默认是关闭的？" class="headerlink" title="58、tcp_tw_reuse 为什么默认是关闭的？"></a>58、tcp_tw_reuse 为什么默认是关闭的？</h2><blockquote>
<p>其实这题在变相问「<strong>如果 TIME_WAIT 状态持续时间过短或者没有，会有什么问题？</strong>」因为开启 tcp_tw_reuse 参数可以快速复用处于 TIME_WAIT 状态的 TCP 连接时，相当于缩短了 TIME_WAIT 状态的持续时间。</p>
</blockquote>
<blockquote>
<p>tcp_tw_reuse 的作用是让客户端快速复用处于 TIME_WAIT 状态的端口，相当于跳过了 TIME_WAIT 状态，这可能会出现这样的两个问题：</p>
<ul>
<li>历史 RST 报文可能会终止后面相同四元组的连接，因为 PAWS 检查到即使 RST 是过期的，也不会丢弃。</li>
<li>如果第四次挥手的 ACK 报文丢失了，有可能被动关闭连接的一方不能被正常的关闭;</li>
</ul>
</blockquote>
<h3 id="1、tcp-tw-reuse-是什么？"><a href="#1、tcp-tw-reuse-是什么？" class="headerlink" title="1、tcp_tw_reuse 是什么？"></a>1、tcp_tw_reuse 是什么？</h3><p>在 Linux  操作系统下，TIME_WAIT 状态的持续时间是 60 秒，这意味着这 60 秒内，客户端一直会占用着这个端口。要知道，端口资源也是有限的，一般可以开启的端口为 32768~61000 ，也可以通过如下参数设置指定范围：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_local_port_range</span><br></pre></td></tr></table></figure>

<p><strong>如果客户端（主动关闭连接方）的 TIME_WAIT 状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务器发起连接了，但是被使用的端口，还是可以继续对另外一个服务器发起连接的。这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。</p>
<p>好在，Linux 操作系统提供了两个可以系统参数来快速回收处于 TIME_WAIT 状态的连接，这两个参数都是默认关闭的：</p>
<ul>
<li>net.ipv4.tcp_tw_reuse，如果开启该选项的话，客户端（连接发起方） 在调用 connect() 函数时，<strong>如果内核选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了</strong>。所以该选项只适用于连接发起方。</li>
<li>net.ipv4.tcp_tw_recycle，如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收，该参数在 <strong>NAT 的网络下是不安全的</strong>！详细见这篇文章介绍：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/syn_drop.html">SYN 报文什么时候情况下会被丢弃？</a></li>
</ul>
<p>要使得上面这两个参数生效，有一个前提条件，就是要打开 TCP 时间戳，即 net.ipv4.tcp_timestamps&#x3D;1（默认即为 1）。开启了 tcp_timestamps 参数，TCP 头部就会使用时间戳选项，它有两个好处，<strong>一个是便于精确计算 RTT ，另一个是能防止序列号回绕（PAWS）</strong>。</p>
<p>序列号是一个 32 位的无符号整型，上限值是 4GB，超过 4GB  后就需要将序列号回绕进行重用。这在以前网速慢的年代不会造成什么问题，但在一个速度足够快的网络中传输大量数据时，序列号的回绕时间就会变短。如果序列号回绕的时间极短，我们就会再次面临之前延迟的报文抵达后序列号依然有效的问题。</p>
<p>为了解决这个问题，就需要有 TCP 时间戳。</p>
<p>试看下面的示例，假设 TCP 的发送窗口是 1 GB，并且使用了时间戳选项，发送方会为每个 TCP 报文分配时间戳数值，我们假设每个报文时间加 1，然后使用这个连接传输一个 6GB 大小的数据流。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/bf004909d9e44c3bc740737ced6731a0.png" alt="图片"></p>
<p>32 位的序列号在时刻 D 和 E 之间回绕。假设在时刻B有一个报文丢失并被重传，又假设这个报文段在网络上绕了远路并在时刻 F 重新出现。如果 TCP 无法识别这个绕回的报文，那么数据完整性就会遭到破坏。</p>
<p>使用时间戳选项能够有效的防止上述问题，如果丢失的报文会在时刻 F 重新出现，由于它的时间戳为 2，小于最近的有效时间戳（5 或 6），因此防回绕序列号算法（PAWS）会将其丢弃。</p>
<p>防回绕序列号算法要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，<strong>如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包</strong>。</p>
<h3 id="2、为什么-tcp-tw-reuse-默认是关闭的？"><a href="#2、为什么-tcp-tw-reuse-默认是关闭的？" class="headerlink" title="2、为什么 tcp_tw_reuse  默认是关闭的？"></a>2、为什么 tcp_tw_reuse  默认是关闭的？</h3><h4 id="（1）第一个问题"><a href="#（1）第一个问题" class="headerlink" title="（1）第一个问题"></a>（1）第一个问题</h4><p>我们知道开启 tcp_tw_reuse 的同时，也需要开启 tcp_timestamps，意味着可以用时间戳的方式有效的判断回绕序列号的历史报文。但是，防回绕序列号函数的源码中，对于 <strong>RST 报文</strong>， <strong>即使其时间戳过期了，只要 RST 报文的序列号在对方的接收窗口内，也是能被接受的</strong>。</p>
<p>假设有这样的场景：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406102019052.png" alt="img"></p>
<ul>
<li>客户端向一个还没有被服务端监听的端口发起了 HTTP 请求，接着服务端就会回 RST 报文给对方，很可惜的是 <strong>RST 报文被网络阻塞了</strong>。</li>
<li>由于客户端迟迟没有收到 TCP 第二次握手，于是重发了 SYN 包，与此同时服务端已经开启了服务，监听了对应的端口。于是接下来，客户端和服务端就进行了 TCP 三次握手、数据传输（HTTP应答-响应）、四次挥手。</li>
<li>因为<strong>客户端开启了 tcp_tw_reuse，于是快速复用 TIME_WAIT 状态的端口，又与服务端建立了一个与刚才相同的四元组的连接</strong>。</li>
<li>接着，<strong>前面被网络延迟 RST 报文这时抵达了客户端，而且 RST 报文的序列号在客户端的接收窗口内，由于防回绕序列号算法不会防止过期的 RST，所以 RST 报文会被客户端接受了，于是客户端的连接就断开了</strong>。</li>
</ul>
<p>上面这个场景就是开启 tcp_tw_reuse 的风险，<strong>因为快速复用 TIME_WAIT 状态的端口，导致新连接可能被回绕序列号的 RST 报文断开，而如果不跳过 TIME_WAIT 状态，而是停留 2MSL 时长，那么这个 RST 报文就不会出现在下一个新的连接</strong>。</p>
<h4 id="（2）第二个问题"><a href="#（2）第二个问题" class="headerlink" title="（2）第二个问题"></a>（2）第二个问题</h4><p>开启 tcp_tw_reuse 来快速复用 TIME_WAIT 状态的连接，如果第四次挥手的 ACK 报文丢失了，服务端会触发超时重传，重传第三次挥手报文，处于 syn_sent 状态的客户端收到服务端重传第三次挥手报文，则会回 RST 给服务端。如下图：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406102019869.png" alt="img" style="zoom:67%;" />



<h2 id="59、TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？"><a href="#59、TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？" class="headerlink" title="59、TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？"></a>59、TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</h2><p>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。</p>
<p>TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。</p>
<h2 id="60、TCP-和-UDP-可以同时绑定相同的端口吗？"><a href="#60、TCP-和-UDP-可以同时绑定相同的端口吗？" class="headerlink" title="60、TCP 和 UDP 可以同时绑定相同的端口吗？"></a>60、TCP 和 UDP 可以同时绑定相同的端口吗？</h2><p>TCP 和 UDP 服务端网络相似的一个地方，就是会调用 bind 绑定端口。</p>
<p>TCP 网络编程如下，服务端执行 listen() 系统调用就是监听端口的动作。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.png" alt="img" style="zoom: 67%;" />

<p>UDP 网络编程如下，服务端是没有监听这个动作的，只有执行  bind()  系统调用来绑定端口的动作。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/udp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.png" alt="img" style="zoom: 80%;" />

<blockquote>
<p>TCP 和 UDP 可以同时绑定相同的端口吗？</p>
</blockquote>
<p>答案：<strong>可以的</strong>。</p>
<p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。</p>
<p>所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。</p>
<p>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。</p>
<p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。因此， TCP&#x2F;UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80 号端口，二者并不冲突。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97.jpeg" alt="img" style="zoom:50%;" />

<h2 id="61、多个-TCP-服务进程可以绑定同一个端口吗？"><a href="#61、多个-TCP-服务进程可以绑定同一个端口吗？" class="headerlink" title="61、多个 TCP 服务进程可以绑定同一个端口吗？"></a>61、多个 TCP 服务进程可以绑定同一个端口吗？</h2><blockquote>
<p>默认情况下，<strong>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”</strong>。</p>
<p>如果想多个进程绑定相同的 IP 地址和端口，也是有办法的，就是对 socket 设置 SO_REUSEPORT 属性。SO_REUSEADDR 作用是：<strong>如果当前启动进程绑定的 IP+PORT 与处于TIME_WAIT 状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了 SO_REUSEADDR 选项，那么该进程就可以绑定成功</strong>。</p>
</blockquote>
<p>默认情况下，<strong>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”</strong>。</p>
<p>注意，如果 TCP 服务进程 A 绑定的地址是  0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是 192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。这是因为 0.0.0.0  地址比较特殊，代表任意地址，意味着绑定了 0.0.0.0  地址，相当于把主机上的所有 IP 地址都绑定了。</p>
<p>如果想多个进程绑定相同的 IP 地址和端口，也是有办法的，就是对 socket 设置 SO_REUSEPORT 属性（内核 3.9 版本提供的新特性）。</p>
<blockquote>
<p>重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？</p>
</blockquote>
<p>当 TCP 服务进程重启之后，总是碰到“Address in use”的报错信息，TCP 服务进程不能很快地重启，而是要过一会才能重启成功。这是因为当我们重启 TCP 服务进程的时候，意味着通过服务器端发起了关闭连接操作，于是就会经过四次挥手，而对于主动关闭方，会在 TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。</p>
<p><strong>当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT  仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind()  函数的时候，就会返回了 Address already in use 的错误</strong>。</p>
<p>而等 TIME_WAIT 状态的连接结束后，重启 TCP 服务进程就能成功。</p>
<blockquote>
<p>重启 TCP 服务进程时，如何避免“Address in use”的报错信息？</p>
</blockquote>
<p>我们可以在调用 bind 前，对 socket 设置 SO_REUSEADDR 属性，可以解决这个问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br></pre></td></tr></table></figure>

<p>因为 SO_REUSEADDR 作用是：<strong>如果当前启动进程绑定的 IP+PORT 与处于TIME_WAIT 状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了 SO_REUSEADDR 选项，那么该进程就可以绑定成功</strong>。</p>
<p>举个例子，服务端有个监听 0.0.0.0 地址和 8888 端口的 TCP 服务进程。‍</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/5.png" alt="img"></p>
<p>有个客户端（IP地址：192.168.1.100）已经和服务端（IP 地址：172.19.11.200）建立了 TCP 连接，那么在 TCP 服务进程重启时，服务端会与客户端经历四次挥手，服务端的 TCP 连接会短暂处于 TIME_WAIT 状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端地址:端口           服务端地址:端口        TCP 连接状态</span><br><span class="line">192.168.1.100:37272     172.19.11.200:8888    TIME_WAI</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 TCP 服务进程没有对 socket 设置 SO_REUSEADDR  属性，那么在重启时，由于存在一个和绑定 IP+PORT 一样的 TIME_WAIT 状态的连接，那么在执行 bind() 函数的时候，就会返回了 Address already in use 的错误；</li>
<li>如果 TCP 服务进程对 socket 设置 SO_REUSEADDR 属性了，那么在重启时，即使存在一个和绑定 IP+PORT 一样的 TIME_WAIT 状态的连接，依然可以正常绑定成功，因此可以正常重启成功。</li>
</ul>
<p>因此，在所有 TCP 服务器程序中，调用 bind 之前最好对 socket 设置 SO_REUSEADDR 属性，这不会产生危害，相反，它会帮助我们在很快时间内重启服务端程序。‍</p>
<p><strong>前面我提到过这个问题</strong>：如果 TCP 服务进程 A 绑定的地址是  0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是 192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。</p>
<p>这个问题也可以由 SO_REUSEADDR 解决，因为它的<strong>另外一个作用</strong>：绑定的 IP地址 + 端口时，只要 IP 地址不是正好(exactly)相同，那么允许绑定。比如，0.0.0.0:8888 和192.168.1.100:8888，虽然逻辑意义上前者包含了后者，但是 0.0.0.0 泛指所有本地 IP，而 192.168.1.100 特指某一IP，两者并不是完全相同，所以在对 socket 设置 SO_REUSEADDR 属性后，那么执行 bind() 时候就会绑定成功。</p>
<h2 id="62、客户端的端口可以重复使用吗？"><a href="#62、客户端的端口可以重复使用吗？" class="headerlink" title="62、客户端的端口可以重复使用吗？"></a>62、客户端的端口可以重复使用吗？</h2><p>TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP  连接的。所以如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992  的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。</p>
<blockquote>
<p>客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？</p>
</blockquote>
<p>针对这个问题要看，客户端是否都是与同一个服务器（目标地址和目标端口一样）建立连接。</p>
<p>如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。</p>
<p>但是，<strong>因为只要客户端连接的服务器不同，端口资源可以重复使用的</strong>。</p>
<p>所以，如果客户端都是与不同的服务器建立连接，即使客户端端口资源只有几万个， 客户端发起百万级连接也是没问题的（当然这个过程还会受限于其他资源，比如文件描述符、内存、CPU 等）。</p>
<blockquote>
<p>如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？</p>
</blockquote>
<p>前面我们提到，如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。</p>
<p>针对这个问题，也是有解决办法的，那就是在客户端打开 <code>net.ipv4.tcp_tw_reuse</code> 这个内核参数。</p>
<p><strong>因为开启了这个内核参数后，客户端调用 connect  函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于  TIME_WAIT  状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1  秒，那么就会重用这个连接，然后就可以正常使用该端口了。</strong></p>
<p>再次提醒一次，开启了 net.ipv4.tcp_tw_reuse  内核参数，是客户端（连接发起方） 在调用 connect() 函数时才起作用，所以在服务端开启这个参数是没有效果的。</p>
<blockquote>
<p>客户端端口选择的流程总结</p>
</blockquote>
<p>至此，我们已经把客户端在执行 connect 函数时，内核选择端口的情况大致说了一遍，为了让大家更明白客户端端口的选择过程，我画了一流程图。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/%E7%AB%AF%E5%8F%A3%E9%80%89%E6%8B%A9.jpg" alt="img"></p>
<h2 id="63、服务端没有-listen，客户端发起连接建立，会发生什么？"><a href="#63、服务端没有-listen，客户端发起连接建立，会发生什么？" class="headerlink" title="63、服务端没有 listen，客户端发起连接建立，会发生什么？"></a>63、服务端没有 listen，客户端发起连接建立，会发生什么？</h2><blockquote>
<p>服务端如果只 bind了 ip 和端口，但是没有调用 listen 让这个 socket 监听连接，这时候如果客户端朝这个服务端 socket 发数据，会发生啥？</p>
</blockquote>
<p>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，此时客户端对服务端发起连接建立，服务端会回 RST 报文。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>Linux 内核处理收到 TCP 报文的入口函数是  tcp_v4_rcv，在收到 TCP 报文后，会调用 __inet_lookup_skb 函数找到 TCP 报文所属 socket 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">  </span><br><span class="line"> sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, th-&gt;source, th-&gt;dest);</span><br><span class="line"> <span class="keyword">if</span> (!sk)</span><br><span class="line">  <span class="keyword">goto</span> no_tcp_socket;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__inet_lookup_skb</code> 函数首先查找连接建立状态的socket（<code>__inet_lookup_established</code>），在没有命中的情况下，才会查找监听套接口（<code>__inet_lookup_listener</code>）。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/88416aa95d255495e07fb3a002b2167b.png" alt="图片"></p>
<p>查找监听套接口（<code>__inet_lookup_listener</code>）这个函数的实现是，<strong>根据目的地址和目的端口算出一个哈希值，然后在哈希表找到对应监听该端口的 socket。</strong>本次的案例中，服务端是没有调用 listen 函数的，所以自然也是找不到监听该端口的 socket。所以，__inet_lookup_skb 函数最终找不到对应的 socket，于是跳转到no_tcp_socket。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/54ee363e149ee3dfba30efb1a542ef5c.png" alt="图片"></p>
<p>在这个错误处理中，只要收到的报文（skb）的「校验和」没问题的话，内核就会调用 tcp_v4_send_reset 发送 RST 中止这个连接。</p>
<p>至此，整个源码流程就解析完。</p>
<h2 id="64、没有-listen，能建立-TCP-连接吗？"><a href="#64、没有-listen，能建立-TCP-连接吗？" class="headerlink" title="64、没有 listen，能建立 TCP 连接吗？"></a>64、没有 listen，能建立 TCP 连接吗？</h2><blockquote>
<p>不使用 listen ，可以建立 TCP 连接吗？</p>
</blockquote>
<p>答案，<strong>是可以的，客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有listen，就能建立连接</strong>。</p>
<blockquote>
<p>那没有listen，为什么还能建立连接？</p>
</blockquote>
<p>我们知道执行 listen 方法时，会创建半连接队列和全连接队列。三次握手的过程中会在这两个队列中暂存连接信息。所以形成连接，前提是你得有个地方存放着，方便握手的时候能根据 IP + 端口等信息找到对应的 socket。</p>
<blockquote>
<p>那么客户端会有半连接队列吗？</p>
</blockquote>
<p>显然没有，因为客户端没有执行listen，而半连接队列和全连接队列都是在执行 listen 方法时，内核自动创建的。但内核还有个全局 hash 表，可以用于存放 sock 连接的信息。这个全局 hash 表其实还细分为 ehash，bhash和listen_hash等，但因为过于细节，大家理解成有一个全局 hash 就够了，</p>
<p><strong>在 TCP 自连接的情况中，客户端在 connect 方法时，最后会将自己的连接信息放入到这个全局 hash  表中，然后将信息发出，消息在经过回环地址重新回到 TCP 传输层的时候，就会根据 IP + 端口信息，再一次从这个全局 hash  中取出信息。于是握手包一来一回，最后成功建立连接</strong>。</p>
<p>TCP 同时打开的情况也类似，只不过从一个客户端变成了两个客户端而已。</p>
<h2 id="65、TCP-四次挥手，可以变成三次吗？"><a href="#65、TCP-四次挥手，可以变成三次吗？" class="headerlink" title="65、TCP 四次挥手，可以变成三次吗？"></a>65、TCP 四次挥手，可以变成三次吗？</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406102122868.png" alt="在这里插入图片描述" style="zoom: 80%;" />

<blockquote>
<p>当被动关闭方在 TCP 挥手过程中，<strong>如果「没有数据要发送」，同时「没有开启 TCP_QUICKACK（默认情况就是没有开启，没有开启  TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制）」</strong>，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</p>
</blockquote>
<p><strong>所以，出现三次挥手现象，是因为 TCP 延迟确认机制导致的。</strong></p>
<blockquote>
<p>什么是  TCP 延迟确认机制？</p>
</blockquote>
<p>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。 TCP 延迟确认的策略：</p>
<ul>
<li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li>
<li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li>
<li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li>
</ul>
<img src="https://cdn.xiaolincoding.com//mysql/other/33f3d2d54a924b0a80f565038327e0e4.png" alt="img" style="zoom: 67%;" />

<h2 id="66、TCP-序列号和确认号是如何变化的？"><a href="#66、TCP-序列号和确认号是如何变化的？" class="headerlink" title="66、TCP 序列号和确认号是如何变化的？"></a>66、TCP 序列号和确认号是如何变化的？</h2><ul>
<li>三次握手中 TCP 序列号和确认号的变化</li>
<li>数据传输中 TCP 序列号和确认号的变化</li>
<li>四次挥手中 TCP 序列号和确认号的变化</li>
</ul>
<h3 id="1、万能公式"><a href="#1、万能公式" class="headerlink" title="1、万能公式"></a>1、万能公式</h3><p>我根据经验总结了一条万能公式。</p>
<p><strong>发送的 TCP 报文：</strong></p>
<ul>
<li><strong>公式一：序列号 &#x3D; 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</strong></li>
<li><strong>公式二：确认号 &#x3D; 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</strong></li>
</ul>
<p>TCP 序列号和确认号在 TCP 头部的位置：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/41da16ec3ea04e27bcb35a93c0193855.png" alt="在这里插入图片描述" style="zoom:50%;" />

<p>这里重点关注这三个字段的作用：</p>
<ul>
<li><strong>序列号</strong>：在建立连接时由内核生成的随机数作为其初始值，通过 SYN 报文传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></li>
<li><strong>确认号</strong>：指下一次「期望」收到的数据的序列号，发送端收到接收方发来的 ACK 确认报文以后，就可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></li>
<li><strong>控制位：</strong>用来标识 TCP 报文是什么类型的报文，比如是 SYN 报文、数据报文、ACK 报文，FIN 报文等。</li>
</ul>
<h3 id="2、三次握手阶段的变化"><a href="#2、三次握手阶段的变化" class="headerlink" title="2、三次握手阶段的变化"></a>2、三次握手阶段的变化</h3><p>先来说说三次握手中 TCP 序列号和确认号的变化。</p>
<p>假设客户端的初始化序列号为 client_isn，服务端的初始化序列号为 server_isn，TCP 三次握手的流程如下：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/06c4ed62087040438f86ba64e9e609e7.png" alt="在这里插入图片描述" style="zoom:50%;" />

<blockquote>
<p>为什么第二次和第三次握手报文中的确认号是将对方的序列号 + 1 后作为确认号呢？</p>
</blockquote>
<p>SYN 报文是特殊的 TCP 报文，用于建立连接时使用，虽然 SYN 报文不携带用户数据，但是 <strong>TCP 将 SYN 报文视为 1 字节的数据</strong>，当对方收到了 SYN 报文后，在回复 ACK 报文时，就需要将 ACK 报文中的确认号设置为 SYN 的序列号 + 1 ，这样做是有两个目的：</p>
<ul>
<li><strong>告诉对方，我方已经收到 SYN 报文。</strong></li>
<li><strong>告诉对方，我方下一次「期望」收到的报文的序列号为此确认号，比如客户端与服务端完成三次握手之后，服务端接下来期望收到的是序列号为  client_isn + 1 的 TCP 数据报文。</strong></li>
</ul>
<h3 id="2、数据传输阶段的变化"><a href="#2、数据传输阶段的变化" class="headerlink" title="2、数据传输阶段的变化"></a>2、数据传输阶段的变化</h3><p>完成了，三次握手后，客户端就可以发送第一个 ** **TCP 数据报文了，假设客户端即将要发送 10 字节的数据，流程图下：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/dadf9a94328a4446b32ebabf1623c729.png" alt="在这里插入图片描述" style="zoom:50%;" />

<p>可以看到，<strong>客户端与服务端完成 TCP 三次握手后，发送的第一个 「TCP 数据报文的序列号和确认号」都是和「第三次握手的 ACK 报文中序列号和确认号」一样的</strong>。</p>
<blockquote>
<p>之前有读者问，如果客户端发送的第三次握手  ACK 报文丢失了，处于 SYN_RCVD 状态服务端收到了客户端第一个 TCP 数据报文会发生什么？</p>
</blockquote>
<p>刚才前面我也说了，发送的第一个 「TCP 数据报文的序列号和确认号」都是和「第三次握手的 ACK 报文中序列号和确认号」一样的，并且该 TCP 数据报文也有将 ACK 标记位置为 1。如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/942c2a1e67224c8c8bd41b13d7c89a96.png" alt="在这里插入图片描述"></p>
<p>所以，服务端收到这个数据报文，是可以正常完成连接的建立，然后就可以正常接收这个数据包了。</p>
<h3 id="4、四次挥手阶段的变化"><a href="#4、四次挥手阶段的变化" class="headerlink" title="4、四次挥手阶段的变化"></a>4、四次挥手阶段的变化</h3><p>最后，我们来看看四次挥手阶段中，序列号和确认号的变化。</p>
<p>数据传输阶段结束后，客户端发起了 FIN 报文，请求服务端端开该 TCP 连接，此时就进入了 TCP 四次挥手阶段，如下图。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/ae18cbf6071c47b98014a68d05c37d16.png" alt="在这里插入图片描述" style="zoom:50%;" />

<h2 id="67、TCP报文中的时间戳有什么作用？"><a href="#67、TCP报文中的时间戳有什么作用？" class="headerlink" title="67、TCP报文中的时间戳有什么作用？"></a>67、TCP报文中的时间戳有什么作用？</h2><p>TCP Timestamps Option 由四部分构成：</p>
<p>类别（kind）、长度（Length）、发送⽅时间戳（TS value）、回显时间戳（TS Echo Reply）。</p>
<p>TCP 的时间戳主要解决两⼤问题：</p>
<ul>
<li><p><strong>计算往返时延 RTT(Round-Trip Time)：</strong></p>
<p>在启⽤ Timestamps 选项以后，因为 ACK 包⾥包含了 TSval 和 TSecr，这样⽆论是正常确认包，还是</p>
<p>重传确认包，都可以通过这两个值计算出 RTT。</p>
</li>
<li><p><strong>防止序列号的回绕问题：</strong></p>
<p>TCP 的序列号⽤ 32bit 来表示，因此在 2^32 字节的数据传输后序列号就会溢出回绕。TCP 的窗⼝经过</p>
<p>窗⼝缩放可以最⾼到 1GB（2^30)，在⾼速⽹络中，序列号在很短的时间内就会被重复使⽤。</p>
</li>
</ul>
<h2 id="68、收到-IP-数据包解析以后，怎么知道这个分组应该投递到上层的哪一个协议（UDP-或-TCP）？"><a href="#68、收到-IP-数据包解析以后，怎么知道这个分组应该投递到上层的哪一个协议（UDP-或-TCP）？" class="headerlink" title="68、收到 IP 数据包解析以后，怎么知道这个分组应该投递到上层的哪一个协议（UDP 或 TCP）？"></a>68、收到 IP 数据包解析以后，怎么知道这个分组应该投递到上层的哪一个协议（UDP 或 TCP）？</h2><p>通过查看 IP 头部中的 “协议字段”（Protocol field）来实现的。</p>
<ol>
<li><strong>接收 IP 数据包</strong>： 当一个 IP 数据包到达时，首先由网络层（即 IP 协议栈）进行处理。此时，系统会解析 IP 头部以提取相关信息。</li>
<li><strong>解析 IP 头部</strong>： IP 头部包含了很多重要的信息，其中包括源地址、目的地址、总长度、标识、片偏移、TTL（生存时间）、协议字段等。我们关心的是其中的协议字段。</li>
<li><strong>检查协议字段</strong>： IP 头部中的协议字段（Protocol field）位于 IP 头部的第 9 个字节。这个字段是一个 8 位的值，用来指示上层协议的类型。不同的协议有不同的编号：<ul>
<li>6：TCP（传输控制协议）</li>
<li>17：UDP（用户数据报协议）</li>
<li>1：ICMP（互联网控制消息协议）</li>
<li>其他值：对应其他上层协议</li>
</ul>
</li>
<li><strong>投递到相应的上层协议</strong>： 根据协议字段的值，IP 协议栈会将数据包投递到相应的上层协议处理程序。例如：<ul>
<li>如果协议字段的值是 6，系统会将数据包投递到 TCP 协议栈处理。</li>
<li>如果协议字段的值是 17，系统会将数据包投递到 UDP 协议栈处理。</li>
</ul>
</li>
</ol>
<h2 id="69、TCP-提供了一种字节流服务，而收发双方都不保持记录的边界，应用程序应该如何提供他们自己的记录标识呢？"><a href="#69、TCP-提供了一种字节流服务，而收发双方都不保持记录的边界，应用程序应该如何提供他们自己的记录标识呢？" class="headerlink" title="69、TCP 提供了一种字节流服务，而收发双方都不保持记录的边界，应用程序应该如何提供他们自己的记录标识呢？"></a>69、TCP 提供了一种字节流服务，而收发双方都不保持记录的边界，应用程序应该如何提供他们自己的记录标识呢？</h2><p>应⽤程序使⽤⾃⼰约定的规则来表示消息的边界，⽐如有⼀些使⽤回⻋+换⾏（”\r\n”），⽐如 Redis的通信协议（RESP protocol）。</p>
<h2 id="70、telnet的用法"><a href="#70、telnet的用法" class="headerlink" title="70、telnet的用法"></a>70、telnet的用法</h2><p>Telnet 是一个网络协议和程序，允许用户通过命令行接口登录到远程计算机或网络设备。它使用 TCP 端口 23，提供一个简单的、未加密的通信方式，适用于访问和管理远程设备。</p>
<h3 id="1、连接到远程主机"><a href="#1、连接到远程主机" class="headerlink" title="1、连接到远程主机"></a>1、连接到远程主机</h3><p>要使用 Telnet 连接到远程主机，可以在命令行输入以下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet [hostname] [port]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>[hostname]</code> 是远程主机的 IP 地址或域名。</li>
<li><code>[port]</code> 是可选的端口号。如果未指定，默认端口为 23。</li>
</ul>
<p>例如，连接到 IP 地址为 <code>192.168.1.1</code> 的主机：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.1.1</span><br></pre></td></tr></table></figure>

<p>或连接到 <code>example.com</code> 的主机：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet example.com</span><br></pre></td></tr></table></figure>

<h3 id="2、检查端口是否开放"><a href="#2、检查端口是否开放" class="headerlink" title="2、检查端口是否开放"></a>2、检查端口是否开放</h3><p>Telnet 还可以用于检查某个端口是否在远程主机上开放。例如，检查 <code>example.com</code> 上的端口 80：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet example.com 80</span><br></pre></td></tr></table></figure>

<p>如果连接成功，表示端口 80 是开放的。</p>
<h3 id="3、使用-Telnet-脚本自动化任务"><a href="#3、使用-Telnet-脚本自动化任务" class="headerlink" title="3、使用 Telnet 脚本自动化任务"></a>3、使用 Telnet 脚本自动化任务</h3><p>Telnet 客户端支持自动化脚本，可以使用 Expect 等工具来实现自动化。例如，使用 Expect 脚本登录远程主机并执行命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/expect -f</span></span><br><span class="line"></span><br><span class="line">spawn telnet 192.168.1.1</span><br><span class="line">expect <span class="string">&quot;login:&quot;</span></span><br><span class="line">send <span class="string">&quot;your_username\r&quot;</span></span><br><span class="line">expect <span class="string">&quot;Password:&quot;</span></span><br><span class="line">send <span class="string">&quot;your_password\r&quot;</span></span><br><span class="line">expect <span class="string">&quot;$&quot;</span></span><br><span class="line">send <span class="string">&quot;ls -la\r&quot;</span></span><br><span class="line">expect <span class="string">&quot;$&quot;</span></span><br><span class="line">send <span class="string">&quot;exit\r&quot;</span></span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure>

<p>将上述内容保存为 <code>telnet_script.exp</code>，然后运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect telnet_script.exp</span><br></pre></td></tr></table></figure>

<h2 id="71、netstat的⽤法"><a href="#71、netstat的⽤法" class="headerlink" title="71、netstat的⽤法"></a>71、netstat的⽤法</h2><p>netstat 命令⽤于显示各种⽹络相关信息。</p>
<p>常⻅参数</p>
<blockquote>
<p>-a (all)显示所有选项，默认不显示LISTEN相关</p>
<p>-t (tcp)仅显示tcp相关选项</p>
<p>-u (udp)仅显示udp相关选项</p>
<p>-n 拒绝显示别名，能显示数字的全部转化成数字。</p>
<p>-l 仅列出有在 Listen (监听) 的服務状态</p>
<p>-p 显示建⽴相关链接的程序名</p>
<p>-r 显示路由信息，路由表</p>
<p>-e 显示扩展信息，例如uid等</p>
<p>-s 按各个协议进⾏统计</p>
<p>-c 每隔⼀个固定时间，执⾏该netstat命令</p>
</blockquote>
<h2 id="72、如果要设计一个QQ，在网络协议上如何设计？"><a href="#72、如果要设计一个QQ，在网络协议上如何设计？" class="headerlink" title="72、如果要设计一个QQ，在网络协议上如何设计？"></a>72、如果要设计一个QQ，在网络协议上如何设计？</h2><p>登陆采用TCP协议和HTTP协议，你和好友之间发送消息，主要采用UDP协议，内⽹传⽂件采用了P2P技术。</p>
<p>总的来说：</p>
<ol>
<li><p>登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会有⼀个TCP连接来保持在线状态。</p>
</li>
<li><p>和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。</p>
</li>
<li><p>如果是在内网里面的两个客户端传⽂件，QQ采用的是P2P技术，不需要服务器中转。</p>
</li>
</ol>
<h2 id="73、用了TCP协议，一定不会丢包吗？"><a href="#73、用了TCP协议，一定不会丢包吗？" class="headerlink" title="73、用了TCP协议，一定不会丢包吗？"></a>73、用了TCP协议，一定不会丢包吗？</h2><h3 id="1、数据包的发送流程"><a href="#1、数据包的发送流程" class="headerlink" title="1、数据包的发送流程"></a>1、数据包的发送流程</h3><ol>
<li>把消息从用户空间拷贝到内核空间的发送缓冲区(send_buffer)；</li>
<li>顺着传输层、网络层，通过 Qdisc(排队规则) 进行流控进入到数据链路层；</li>
<li>通过 RingBuffer 发送到物理层的网卡；</li>
<li>目的机器 DMA 从网卡收包到 RingBuffer，网卡触发硬中断给 CPU；</li>
<li>CPU触发软中断让 ksoftirqd 去 RingBuffer收包，按着协议栈向上传输。</li>
</ol>
<h3 id="2、几个丢包的可能性"><a href="#2、几个丢包的可能性" class="headerlink" title="2、几个丢包的可能性"></a>2、几个丢包的可能性</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111917261.png" alt="image-20240611191756056" style="zoom: 67%;" />

<h2 id="74、QUIC如何实现可靠传输？"><a href="#74、QUIC如何实现可靠传输？" class="headerlink" title="74、QUIC如何实现可靠传输？"></a>74、QUIC如何实现可靠传输？</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111919871.png" alt="image-20240611191943734"></p>
<h2 id="75、QUIC如何解决TCP队头阻塞问题？"><a href="#75、QUIC如何解决TCP队头阻塞问题？" class="headerlink" title="75、QUIC如何解决TCP队头阻塞问题？"></a>75、QUIC如何解决TCP队头阻塞问题？</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111919210.png" alt="image-20240611191958139"></p>
<h2 id="76、QUIC如何做流量控制？"><a href="#76、QUIC如何做流量控制？" class="headerlink" title="76、QUIC如何做流量控制？"></a>76、QUIC如何做流量控制？</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111920242.png" alt="image-20240611192007166"></p>
<h2 id="77、QUIC更快的连接建立"><a href="#77、QUIC更快的连接建立" class="headerlink" title="77、QUIC更快的连接建立"></a>77、QUIC更快的连接建立</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111920442.png" alt="image-20240611192013378"></p>
<h2 id="78、QUIC如何迁移连接？"><a href="#78、QUIC如何迁移连接？" class="headerlink" title="78、QUIC如何迁移连接？"></a>78、QUIC如何迁移连接？</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111920900.png" alt="image-20240611192018839"></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/06/1%20C++/STL/C++%20Allocator/" rel="prev" title="C++ Allocator">
      <i class="fa fa-chevron-left"></i> C++ Allocator
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/06/11/5%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4&%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" rel="next" title="时间&空间复杂度">
      时间&空间复杂度 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="nav-text">一、基础篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81TCP-IP-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0"><span class="nav-text">1、TCP&#x2F;IP 网络模型概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">2、键入网址到网页显示，期间发生了什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81Linux-%E6%8E%A5%E6%94%B6%E7%BD%91%E7%BB%9C%E5%8C%85%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-text">3、Linux 接收网络包的流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81Linux-%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E5%8C%85%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-text">4、Linux 发送网络包的流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%80%E6%9C%AF%E8%A1%A5%E5%85%85"><span class="nav-text">技术补充</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89DMA%EF%BC%88Direct-Memory-Access%EF%BC%89"><span class="nav-text">（1）DMA（Direct Memory Access）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89ksoftirqd%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="nav-text">（2）ksoftirqd内核线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89NAPI%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90"><span class="nav-text">（3）NAPI机制分析</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81HTTP%E7%AF%87"><span class="nav-text">二、HTTP篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81HTTP-%E7%9A%84%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">5、HTTP 的常见状态码有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81HTTP-%E7%9A%84%E5%B8%B8%E8%A7%81%E5%AD%97%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">6、HTTP 的常见字段有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81Get-%E4%B8%8E-Post"><span class="nav-text">7、Get 与 Post</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%90-%E3%80%918%E3%80%81HTTP%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="nav-text">【*】8、HTTP缓存技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="nav-text">（1）强制缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="nav-text">（2）协商缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81HTTP-%E4%B8%8E-HTTPS-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">9、HTTP 与 HTTPS 有哪些区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81HTTPS-%E8%A7%A3%E5%86%B3%E4%BA%86-HTTP-%E7%9A%84%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">10、HTTPS 解决了 HTTP 的哪些问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81HTTPS-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%EF%BC%9F%E5%85%B6%E9%97%B4%E4%BA%A4%E4%BA%92%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">11、HTTPS  是如何建立连接的？其间交互了什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12%E3%80%81HTTPS-%E4%B8%80%E5%AE%9A%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E5%90%97%EF%BC%9F"><span class="nav-text">12、HTTPS 一定安全可靠吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89HTTPS%E4%B8%80%E5%AE%9A%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E5%90%97%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%E5%81%87%E5%9F%BA%E7%AB%99%E8%8E%B7%E5%8F%96%E4%BA%86%E8%BD%AC%E5%8F%91%E5%85%A8%E9%83%A8%E4%BF%A1%E6%81%AF%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E8%BF%99%E6%A0%B7%E6%98%AF%E4%B8%8D%E6%98%AF%E5%81%87%E5%9F%BA%E7%AB%99%E5%B0%B1%E8%8E%B7%E5%8F%96%E5%88%B0%E4%BA%86%E5%85%A8%E9%83%A8%E4%BF%A1%E6%81%AF%EF%BC%8C%E4%BB%8E%E8%80%8C%E9%80%A0%E6%88%90%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%EF%BC%9F"><span class="nav-text">（1）HTTPS一定安全可靠吗，如果有假基站获取了转发全部信息的作用，这样是不是假基站就获取到了全部信息，从而造成信息泄露？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E8%83%BD%E6%88%AA%E5%8F%96-HTTPS-%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-text">（2）为什么抓包工具能截取 HTTPS 数据？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%A2%AB%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%8A%93%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-text">（3）如何避免被中间人抓取数据？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14%E3%80%81HTTP-1-1"><span class="nav-text">14、HTTP&#x2F;1.1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15%E3%80%81HTTP-2"><span class="nav-text">15、HTTP&#x2F;2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16%E3%80%81HTTP-3"><span class="nav-text">16、HTTP&#x2F;3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17%E3%80%81HTTP-1-1-%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-text">17、HTTP&#x2F;1.1 该如何优化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%90-%E3%80%91%E3%80%81HTTPS-RSA-%E6%8F%A1%E6%89%8B%E8%A7%A3%E6%9E%90"><span class="nav-text">【-】、HTTPS RSA 握手解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%90-%E3%80%91%E3%80%81HTTPS-ECDHE-%E6%8F%A1%E6%89%8B%E8%A7%A3%E6%9E%90"><span class="nav-text">【-】、HTTPS ECDHE 握手解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18%E3%80%81HTTPS-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-text">18、HTTPS 如何优化？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81TCP%E7%AF%87"><span class="nav-text">三、TCP篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#19%E3%80%81TCP%E5%A4%B4%E6%A0%BC%E5%BC%8F"><span class="nav-text">19、TCP头格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-TCP-%EF%BC%9F"><span class="nav-text">20、什么是 TCP ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21%E3%80%81%E5%A6%82%E4%BD%95%E5%94%AF%E4%B8%80%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="nav-text">21、如何唯一确定一个TCP连接？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22%E3%80%81TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%88%86%E5%88%AB%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-text">22、TCP和UDP的区别，分别的应用场景？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81TCP-%E5%92%8C-UDP-%E5%8C%BA%E5%88%AB"><span class="nav-text">1、TCP 和 UDP 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81TCP-%E5%92%8C-UDP-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">2、TCP 和 UDP 应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23%E3%80%81%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-text">23、详细说明三次握手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="nav-text">24、为什么是三次握手？不是两次、四次？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E6%AC%A1%E5%BB%BA%E7%AB%8B-TCP-%E8%BF%9E%E6%8E%A5%E6%97%B6%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7%E9%83%BD%E8%A6%81%E6%B1%82%E4%B8%8D%E4%B8%80%E6%A0%B7%E5%91%A2%EF%BC%9F"><span class="nav-text">25、为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26%E3%80%81%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7-ISN-%E6%98%AF%E5%A6%82%E4%BD%95%E9%9A%8F%E6%9C%BA%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="nav-text">26、初始序列号 ISN 是如何随机产生的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27%E3%80%81%E6%97%A2%E7%84%B6-IP-%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88-TCP-%E5%B1%82%E8%BF%98%E9%9C%80%E8%A6%81-MSS-%E5%91%A2%EF%BC%9F"><span class="nav-text">27、既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28%E3%80%81%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">28、第一次握手丢失了，会发生什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29%E3%80%81%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">29、第二次握手丢失了，会发生什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30%E3%80%81%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">30、第三次握手丢失了，会发生什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88ACK%E4%BF%A1%E5%8F%B7%E6%98%AFSYN%E4%BF%A1%E5%8F%B7%E5%80%BC-1%EF%BC%9F"><span class="nav-text">31、为什么ACK信号是SYN信号值+1？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%90%97"><span class="nav-text">32、三次握手的过程中可以携带数据吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-SYN-%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-SYN-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="nav-text">33、什么是 SYN 攻击？如何避免 SYN 攻击？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34%E3%80%81%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-text">34、详细说明四次挥手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%A5%E6%89%8B%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="nav-text">35、为什么挥手需要四次？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36%E3%80%81%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">36、第一次挥手丢失了，会发生什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37%E3%80%81%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">37、第二次挥手丢失了，会发生什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38%E3%80%81%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">38、第三次挥手丢失了，会发生什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39%E3%80%81%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">39、第四次挥手丢失了，会发生什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88-TIME-WAIT-%E7%AD%89%E5%BE%85%E7%9A%84%E6%97%B6%E9%97%B4%E6%98%AF-2MSL%EF%BC%9F"><span class="nav-text">40、为什么 TIME_WAIT 等待的时间是 2MSL？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-TIME-WAIT-%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-text">41、为什么需要 TIME_WAIT 状态？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42%E3%80%81TIME-WAIT-%E8%BF%87%E5%A4%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3%EF%BC%9F"><span class="nav-text">42、TIME_WAIT 过多有什么危害？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43%E3%80%81%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-TIME-WAIT%EF%BC%9F"><span class="nav-text">43、如何优化 TIME_WAIT？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F-TIME-WAIT-%E7%8A%B6%E6%80%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">44、服务器出现大量 TIME_WAIT 状态的原因有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F-CLOSE-WAIT-%E7%8A%B6%E6%80%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">45、服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46%E3%80%81%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-text">46、如果已经建立了连接，但是客户端突然出现故障了怎么办？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47%E3%80%81%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">47、如果已经建立了连接，但是服务端的进程崩溃会发生什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48%E3%80%81%E9%92%88%E5%AF%B9-TCP-%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95-Socket-%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="nav-text">48、针对 TCP 应该如何 Socket 编程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#49%E3%80%81accept-%E5%8F%91%E7%94%9F%E5%9C%A8%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%93%AA%E4%B8%80%E6%AD%A5%EF%BC%9F"><span class="nav-text">49、accept 发生在三次握手的哪一步？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#49%E3%80%81TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9B%B8%E5%85%B3"><span class="nav-text">49、TCP可靠性相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="nav-text">1、重传机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">2、滑动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">3、流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text">4、拥塞控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#50%E3%80%81%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%98%AF-TCP-%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="nav-text">50、如何理解是 TCP 面向字节流协议？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#51%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%EF%BC%9F"><span class="nav-text">51、如何解决粘包？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52%E3%80%81%E5%B7%B2%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84TCP%EF%BC%8C%E6%94%B6%E5%88%B0SYN%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">52、已建立连接的TCP，收到SYN会发生什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%AD%E6%94%B6%E5%88%B0%E4%B9%B1%E5%BA%8F%E7%9A%84-FIN-%E5%8C%85%E4%BC%9A%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-text">53、四次挥手中收到乱序的 FIN 包会如何处理？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#54%E3%80%81%E5%9C%A8-TIME-WAIT-%E7%8A%B6%E6%80%81%E7%9A%84-TCP-%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%94%B6%E5%88%B0-SYN-%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">54、在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55%E3%80%81%E5%9C%A8-TIME-WAIT-%E7%8A%B6%E6%80%81%EF%BC%8C%E6%94%B6%E5%88%B0-RST-%E4%BC%9A%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E5%90%97%EF%BC%9F"><span class="nav-text">55、在 TIME_WAIT 状态，收到 RST 会断开连接吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#56%E3%80%81%E9%92%88%E5%AF%B9%E6%9F%90%E4%B8%AATCP-%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%B8%80%E7%AB%AF%E6%96%AD%E7%94%B5%E5%92%8C%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">56、针对某个TCP 连接，一端断电和进程崩溃有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-text">1、没有数据传输的情况</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%B8%BB%E6%9C%BA%E5%B4%A9%E6%BA%83"><span class="nav-text">（1）主机崩溃</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83"><span class="nav-text">（2）进程崩溃</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%9C%89%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-text">2、有数据传输的情况</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%BB%E6%9C%BA%E5%AE%95%E6%9C%BA%EF%BC%8C%E5%8F%88%E8%BF%85%E9%80%9F%E9%87%8D%E5%90%AF"><span class="nav-text">（1）客户端主机宕机，又迅速重启</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%BB%E6%9C%BA%E5%AE%95%E6%9C%BA%EF%BC%8C%E4%B8%80%E7%9B%B4%E6%B2%A1%E6%9C%89%E9%87%8D%E5%90%AF"><span class="nav-text">（2）客户端主机宕机，一直没有重启</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#57%E3%80%81%E6%8B%94%E6%8E%89%E7%BD%91%E7%BA%BF%E5%90%8E%EF%BC%8C-%E5%8E%9F%E6%9C%AC%E7%9A%84-TCP-%E8%BF%9E%E6%8E%A5%E8%BF%98%E5%AD%98%E5%9C%A8%E5%90%97%EF%BC%9F"><span class="nav-text">57、拔掉网线后， 原本的 TCP 连接还存在吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%8B%94%E6%8E%89%E7%BD%91%E7%BA%BF%E5%90%8E%EF%BC%8C%E6%9C%89%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-text">1、拔掉网线后，有数据传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%8B%94%E6%8E%89%E7%BD%91%E7%BA%BF%E5%90%8E%EF%BC%8C%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-text">2、拔掉网线后，没有数据传输</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#58%E3%80%81tcp-tw-reuse-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%98%AF%E5%85%B3%E9%97%AD%E7%9A%84%EF%BC%9F"><span class="nav-text">58、tcp_tw_reuse 为什么默认是关闭的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81tcp-tw-reuse-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1、tcp_tw_reuse 是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88-tcp-tw-reuse-%E9%BB%98%E8%AE%A4%E6%98%AF%E5%85%B3%E9%97%AD%E7%9A%84%EF%BC%9F"><span class="nav-text">2、为什么 tcp_tw_reuse  默认是关闭的？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="nav-text">（1）第一个问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%AC%AC%E4%BA%8C%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="nav-text">（2）第二个问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#59%E3%80%81TCP-Keepalive-%E5%92%8C-HTTP-Keep-Alive-%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%9C%E8%A5%BF%E5%90%97%EF%BC%9F"><span class="nav-text">59、TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#60%E3%80%81TCP-%E5%92%8C-UDP-%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E7%BB%91%E5%AE%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%90%97%EF%BC%9F"><span class="nav-text">60、TCP 和 UDP 可以同时绑定相同的端口吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#61%E3%80%81%E5%A4%9A%E4%B8%AA-TCP-%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E7%BB%91%E5%AE%9A%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97%EF%BC%9F"><span class="nav-text">61、多个 TCP 服务进程可以绑定同一个端口吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F"><span class="nav-text">62、客户端的端口可以重复使用吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#63%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B2%A1%E6%9C%89-listen%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E8%B5%B7%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">63、服务端没有 listen，客户端发起连接建立，会发生什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">源码分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64%E3%80%81%E6%B2%A1%E6%9C%89-listen%EF%BC%8C%E8%83%BD%E5%BB%BA%E7%AB%8B-TCP-%E8%BF%9E%E6%8E%A5%E5%90%97%EF%BC%9F"><span class="nav-text">64、没有 listen，能建立 TCP 连接吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#65%E3%80%81TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%98%E6%88%90%E4%B8%89%E6%AC%A1%E5%90%97%EF%BC%9F"><span class="nav-text">65、TCP 四次挥手，可以变成三次吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#66%E3%80%81TCP-%E5%BA%8F%E5%88%97%E5%8F%B7%E5%92%8C%E7%A1%AE%E8%AE%A4%E5%8F%B7%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E7%9A%84%EF%BC%9F"><span class="nav-text">66、TCP 序列号和确认号是如何变化的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%B8%87%E8%83%BD%E5%85%AC%E5%BC%8F"><span class="nav-text">1、万能公式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E9%98%B6%E6%AE%B5%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-text">2、三次握手阶段的变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%98%B6%E6%AE%B5%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-text">2、数据传输阶段的变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%98%B6%E6%AE%B5%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-text">4、四次挥手阶段的变化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#67%E3%80%81TCP%E6%8A%A5%E6%96%87%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-text">67、TCP报文中的时间戳有什么作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#68%E3%80%81%E6%94%B6%E5%88%B0-IP-%E6%95%B0%E6%8D%AE%E5%8C%85%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%90%8E%EF%BC%8C%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E8%BF%99%E4%B8%AA%E5%88%86%E7%BB%84%E5%BA%94%E8%AF%A5%E6%8A%95%E9%80%92%E5%88%B0%E4%B8%8A%E5%B1%82%E7%9A%84%E5%93%AA%E4%B8%80%E4%B8%AA%E5%8D%8F%E8%AE%AE%EF%BC%88UDP-%E6%88%96-TCP%EF%BC%89%EF%BC%9F"><span class="nav-text">68、收到 IP 数据包解析以后，怎么知道这个分组应该投递到上层的哪一个协议（UDP 或 TCP）？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#69%E3%80%81TCP-%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E7%A7%8D%E5%AD%97%E8%8A%82%E6%B5%81%E6%9C%8D%E5%8A%A1%EF%BC%8C%E8%80%8C%E6%94%B6%E5%8F%91%E5%8F%8C%E6%96%B9%E9%83%BD%E4%B8%8D%E4%BF%9D%E6%8C%81%E8%AE%B0%E5%BD%95%E7%9A%84%E8%BE%B9%E7%95%8C%EF%BC%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9B%E4%BB%96%E4%BB%AC%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AE%B0%E5%BD%95%E6%A0%87%E8%AF%86%E5%91%A2%EF%BC%9F"><span class="nav-text">69、TCP 提供了一种字节流服务，而收发双方都不保持记录的边界，应用程序应该如何提供他们自己的记录标识呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#70%E3%80%81telnet%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-text">70、telnet的用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%BF%9E%E6%8E%A5%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA"><span class="nav-text">1、连接到远程主机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%A3%80%E6%9F%A5%E7%AB%AF%E5%8F%A3%E6%98%AF%E5%90%A6%E5%BC%80%E6%94%BE"><span class="nav-text">2、检查端口是否开放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8-Telnet-%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BB%BB%E5%8A%A1"><span class="nav-text">3、使用 Telnet 脚本自动化任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#71%E3%80%81netstat%E7%9A%84%E2%BD%A4%E6%B3%95"><span class="nav-text">71、netstat的⽤法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#72%E3%80%81%E5%A6%82%E6%9E%9C%E8%A6%81%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AAQQ%EF%BC%8C%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%8A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="nav-text">72、如果要设计一个QQ，在网络协议上如何设计？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#73%E3%80%81%E7%94%A8%E4%BA%86TCP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%B8%80%E5%AE%9A%E4%B8%8D%E4%BC%9A%E4%B8%A2%E5%8C%85%E5%90%97%EF%BC%9F"><span class="nav-text">73、用了TCP协议，一定不会丢包吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B"><span class="nav-text">1、数据包的发送流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%87%A0%E4%B8%AA%E4%B8%A2%E5%8C%85%E7%9A%84%E5%8F%AF%E8%83%BD%E6%80%A7"><span class="nav-text">2、几个丢包的可能性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#74%E3%80%81QUIC%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%9F"><span class="nav-text">74、QUIC如何实现可靠传输？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#75%E3%80%81QUIC%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3TCP%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">75、QUIC如何解决TCP队头阻塞问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#76%E3%80%81QUIC%E5%A6%82%E4%BD%95%E5%81%9A%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="nav-text">76、QUIC如何做流量控制？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#77%E3%80%81QUIC%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="nav-text">77、QUIC更快的连接建立</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#78%E3%80%81QUIC%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BB%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="nav-text">78、QUIC如何迁移连接？</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="midorii"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">midorii</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">midorii</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">256k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">15:32</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
