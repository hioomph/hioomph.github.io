<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch_cat_logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/site_cat-32%C3%9732.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/site_cat-16%C3%9716.png">
  <link rel="mask-icon" href="/images/cat_logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、源码测试过程报错">
<meta property="og:type" content="article">
<meta property="og:title" content="diyx86os">
<meta property="og:url" content="http://example.com/2024/05/08/Project/diyx86os/diyx86os/index.html">
<meta property="og:site_name" content="MIDORII&#39;S JOURNEY">
<meta property="og:description" content="一、源码测试过程报错">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081530696.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081641135.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081654966.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081957449.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081959718.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082011134.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082008662.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082009410.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082034893.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082059875.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082102910.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082107803.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082110449.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082112921.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090906770.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090908623.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090926726.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090931367.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091016385.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091022007.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091941355.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092034455.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092042975.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092111828.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092111423.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405100950973.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405100954581.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101016115.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101452241.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101453798.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101455214.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101500881.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101510647.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101622446.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101952279.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101954937.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102027415.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102027751.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102049124.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102050925.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102052194.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102054365.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102057812.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102108837.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102108978.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102114815.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102116737.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102111597.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102138372.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112014421.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112021480.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112105777.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112030942.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112120766.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112119587.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112121617.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121404633.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121404406.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121405202.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121550258.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121551856.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121555355.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121558156.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121603986.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121603112.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121656373.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121657737.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121701389.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122031495.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122032412.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122035869.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122035976.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122039950.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122044231.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122109920.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122109701.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122113907.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122124096.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122152287.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122149517.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122150962.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122152287.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122236298.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131022114.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131026877.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131032907.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131033545.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131034526.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131036123.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131039358.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131104164.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131104668.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131105155.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131125038.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131125775.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131532647.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131707991.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131857119.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131859253.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131901488.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131902640.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131920596.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131933225.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131920596.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405132011988.png">
<meta property="article:published_time" content="2024-05-08T07:15:01.228Z">
<meta property="article:modified_time" content="2024-05-13T12:11:30.488Z">
<meta property="article:author" content="midorii">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081530696.png">

<link rel="canonical" href="http://example.com/2024/05/08/Project/diyx86os/diyx86os/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>diyx86os | MIDORII'S JOURNEY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MIDORII'S JOURNEY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">a little bit sweet</p>
      <a>
        <img class="custom-logo-image" src="/images/cat.jpeg" alt="MIDORII'S JOURNEY">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/08/Project/diyx86os/diyx86os/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          diyx86os
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-08 15:15:01" itemprop="dateCreated datePublished" datetime="2024-05-08T15:15:01+08:00">2024-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-13 20:11:30" itemprop="dateModified" datetime="2024-05-13T20:11:30+08:00">2024-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Project/" itemprop="url" rel="index"><span itemprop="name">Project</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Project/diyx86os/" itemprop="url" rel="index"><span itemprop="name">diyx86os</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>42 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一、源码测试过程报错"><a href="#一、源码测试过程报错" class="headerlink" title="一、源码测试过程报错"></a>一、源码测试过程报错</h1><span id="more"></span>

<p>1、出现报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[build] x86_64-elf-objdump: Dwarf Error: found dwarf version <span class="string">&#x27;7424&#x27;</span>, this reader only handles version 2, 3 and 4 information.</span><br></pre></td></tr></table></figure>

<p>工具链相关错误，可忽略。</p>
<p>2、测试过程中的编译时遇到错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DiskPart 遇到错误: 由于虚拟磁盘系统限制，无法完成请求的操作。虚拟硬盘文件必须是未压缩和未加密的文件，并且不能是稀疏文件。</span><br></pre></td></tr></table></figure>

<p>解决：取消勾选“压缩或加密属性”</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081530696.png" alt="image-20240508153049493" style="zoom: 67%;" />

<p>3、dd命令不存在：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;dd if=kernel.elf of=disk1.vhd bs=512 conv=notrunc seek=100 &#x27;dd&#x27; 不是内部或外部命令，也不是可运行的程序 或批处理文件。</span><br></pre></td></tr></table></figure>

<p>在Git的安装路径下找到dd.exe文件，并将对应的bin目录添加到系统变量中：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081641135.png" alt="image-20240508164113684"></p>
<p>4、调试成功时，终端显示如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> not exist <span class="string">&quot;disk1.vhd&quot;</span> (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;disk1.vhd not found in image directory&quot;</span></span><br><span class="line"> notepad win_error.txt</span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> not exist <span class="string">&quot;disk2.vhd&quot;</span> (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;disk2.vhd not found in image directory&quot;</span></span><br><span class="line"> notepad win_error.txt</span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">set</span> DISK1_NAME=disk1.vhd</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">dd</span> <span class="keyword">if</span>=boot.bin of=disk1.vhd bs=512 conv=notrunc count=1 </span><br><span class="line">1+0 records <span class="keyword">in</span></span><br><span class="line">1+0 records out</span><br><span class="line">512 bytes copied, 0.009362 s, 54.7 kB/s</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">dd</span> <span class="keyword">if</span>=loader.bin of=disk1.vhd bs=512 conv=notrunc seek=1 </span><br><span class="line">24+0 records <span class="keyword">in</span></span><br><span class="line">24+0 records out</span><br><span class="line">12288 bytes (12 kB, 12 KiB) copied, 0.0077902 s, 1.6 MB/s</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">dd</span> <span class="keyword">if</span>=kernel.elf of=disk1.vhd bs=512 conv=notrunc seek=100 </span><br><span class="line">98+1 records <span class="keyword">in</span></span><br><span class="line">98+1 records out</span><br><span class="line">50452 bytes (50 kB, 49 KiB) copied, 0.0353497 s, 1.4 MB/s</span><br><span class="line">83+1 records <span class="keyword">in</span></span><br><span class="line">83+1 records out</span><br><span class="line">42968 bytes (43 kB, 42 KiB) copied, 0.0838259 s, 513 kB/s</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">set</span> DISK2_NAME=disk2.vhd</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">set</span> TARGET_PATH=k</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> <span class="keyword">select</span> vdisk file=<span class="string">&quot;D:\PostGraduate\cppex\diyx86os\image\disk2.vhd&quot;</span>  1&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> attach vdisk  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> <span class="keyword">select</span> partition 1  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> assign letter=k  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;diskpart /s a.txt</span><br><span class="line"></span><br><span class="line">Microsoft DiskPart 版本 10.0.19041.3636</span><br><span class="line"></span><br><span class="line">Copyright (C) Microsoft Corporation.</span><br><span class="line">在计算机上: DESKTOP-TVGU2EA</span><br><span class="line"></span><br><span class="line">DiskPart 已成功选择虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">  100 百分比已完成</span><br><span class="line"></span><br><span class="line">DiskPart 已成功连接虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">分区 1 现在是所选分区。</span><br><span class="line"></span><br><span class="line">DiskPart 成功地分配了驱动器号或装载点。</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> 0 NEQ 0 (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;attach disk2.vhd failed&quot;</span></span><br><span class="line"> notepad win_error.txt</span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;del a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;copy /Y *.elf k:\</span><br><span class="line">init.elf</span><br><span class="line">kernel.elf</span><br><span class="line">loop.elf</span><br><span class="line">shell.elf</span><br><span class="line">snake.elf</span><br><span class="line">已复制         5 个文件。</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> <span class="keyword">select</span> vdisk file=<span class="string">&quot;D:\PostGraduate\cppex\diyx86os\image\disk2.vhd&quot;</span>  1&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> detach vdisk  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;diskpart /s a.txt</span><br><span class="line"></span><br><span class="line">Microsoft DiskPart 版本 10.0.19041.3636</span><br><span class="line"></span><br><span class="line">Copyright (C) Microsoft Corporation.</span><br><span class="line">在计算机上: DESKTOP-TVGU2EA</span><br><span class="line"></span><br><span class="line">DiskPart 已成功选择虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">DiskPart 已成功分离虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> 0 NEQ 0 (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;detach disk2.vhd failed&quot;</span></span><br><span class="line"> notepad win_error.txt  </span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;del a.txt</span><br><span class="line"> *  终端将被任务重用，按任意键关闭。 </span><br><span class="line"></span><br><span class="line"> *  正在执行任务: D:\PostGraduate\cppex\diyx86os\start\<span class="built_in">test</span>/script/qemu-debug-win.bat </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;start qemu-system-i386  -m 128M -s -S -serial stdio -drive file=disk1.vhd,index=0,media=disk,format=raw -drive file=disk2.vhd,index=1,media=disk,format=raw -d pcall,page,mmu,cpu_reset,guest_errors,page,trace:ps2_keyboard_set_translation</span><br><span class="line"> *  终端将被任务重用，按任意键关闭。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二、引导程序：接管控制权"><a href="#二、引导程序：接管控制权" class="headerlink" title="二、引导程序：接管控制权"></a>二、引导程序：接管控制权</h1><h2 id="2-1-计算机启动流程简介"><a href="#2-1-计算机启动流程简介" class="headerlink" title="2.1 计算机启动流程简介"></a>2.1 计算机启动流程简介</h2><p>从上电到运行计算机经历了什么？</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081654966.png" alt="image-20240508165407603"></p>
<p><code>BIOS</code>：基本输入输出系统。固化在flash芯片上。</p>
<p><strong>BIOS程序由硬件自己控制，本项目编写自己的引导代码和操作系统代码。</strong></p>
<p><code>disk1</code>是<code>qemu</code>的启动硬盘，<code>qemu</code>启动时会从磁盘最开始取<code>512</code>字节。</p>
<p><code>BIOS</code>在加载引导代码时，会根据用户的配置选择从磁盘加载还是从软盘加载，整个课程处理从磁盘加载的情况。</p>
<h2 id="2-2-接管计算机运行控制权"><a href="#2-2-接管计算机运行控制权" class="headerlink" title="2.2 接管计算机运行控制权"></a>2.2 接管计算机运行控制权</h2><p>硬盘的分类：</p>
<ul>
<li><p>机械硬盘：包含电机。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081957449.png" alt="image-20240508195742085"></p>
</li>
<li><p>固态硬盘：容量小但速度快。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081959718.png" alt="image-20240508195937467"></p>
</li>
</ul>
<p>启动时，<code>BIOS</code>会将磁盘的第<code>0</code>个扇区加载到<code>0x7c00</code>处开始运行。即只需要将程序放在第<code>0</code>号扇区，就会自动被加载到内存中运行。完成从<code>BIOS</code>程序到引导程序的跳转过程。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082011134.png" alt="image-20240508201149042"></p>
<p>在<code>vscode</code>中以十六进制编辑器模式打开<code>disk1.vhd</code>，在<code>000001F0</code>处（即第<code>0</code>号扇区的最后两个字节）可看到<code>1FE:0x55</code>, <code>1FF:0xAA</code>，即为上图所示的两个引导标志所在位置。只有这两个引导标志正确时，<code>BIOS</code>才会将磁盘的第<code>0</code>个扇区加载到<code>0x7c00</code>处开始运行。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082008662.png" alt="image-20240508200825616"></p>
<p>此时，若将<code>55/AA</code>进行改动，并重新启动<code>qemu</code>，操作系统将无法被正常启动，会显示如下结果：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082009410.png" alt="image-20240508200958280" style="zoom:67%;" />

<p><strong>为简化，本项目不考虑引导过程中一个磁盘包含多个分区的情况。</strong></p>
<h2 id="2-3-创建可引导的启动程序"><a href="#2-3-创建可引导的启动程序" class="headerlink" title="2.3 创建可引导的启动程序"></a>2.3 创建可引导的启动程序</h2><h3 id="1-整体的项目逻辑"><a href="#1-整体的项目逻辑" class="headerlink" title="1. 整体的项目逻辑"></a>1. 整体的项目逻辑</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-.vscode</span><br><span class="line">	- launch.json	// GDB调试相关信息</span><br><span class="line">	- settings.json</span><br><span class="line">	- tasks.json	// 定义[终端-运行任务]中的相关任务</span><br><span class="line">	</span><br><span class="line">// 定义了[终端-运行任务]中相关任务的命令脚本</span><br><span class="line">- script	</span><br><span class="line"></span><br><span class="line">// 包含若干个子工程</span><br><span class="line">- <span class="built_in">source</span>			</span><br><span class="line">    - applib		// 系统调用库</span><br><span class="line">    - boot			// 引导程序</span><br><span class="line">    - <span class="built_in">comm</span></span><br><span class="line">    - init			// 初始进程</span><br><span class="line">    - kernel		// 操作系统内核</span><br><span class="line">    	- cpu			// 存放cpu相关</span><br><span class="line">    	- include		// 存放头文件</span><br><span class="line">    	- init			// 相关初始化</span><br><span class="line">    - loader		// 加载程序</span><br><span class="line">    - loop			// 应用程序</span><br><span class="line">    - shell			// 命令行应用</span><br><span class="line">    </span><br><span class="line">- CMakeLists.txt</span><br></pre></td></tr></table></figure>

<h3 id="2-整体的开发工作流程："><a href="#2-整体的开发工作流程：" class="headerlink" title="2. 整体的开发工作流程："></a>2. 整体的开发工作流程：</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082034893.png" alt="image-20240508203408507" style="zoom:150%;" />

<h2 id="2-4-初始化引导程序"><a href="#2-4-初始化引导程序" class="headerlink" title="2.4 初始化引导程序"></a>2.4 初始化引导程序</h2><p><strong>主要任务：对boot程序进行简单初始化。</strong></p>
<h3 id="1-什么是引导程序？"><a href="#1-什么是引导程序？" class="headerlink" title="1. 什么是引导程序？"></a>1. 什么是引导程序？</h3><ul>
<li><p>主要用于为操作系统运行初始化运行环境，并加载操作系统运行。</p>
</li>
<li><p><strong>本项目中的引导程序涉及以下三个工作</strong>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082059875.png" alt="image-20240508205916747"></p>
</li>
</ul>
<p>由于BIOS只加载磁盘的第0扇区（512字节）到内存中，对于上述功能来说这个代码大小是不够的，因此需要考虑采用扩展程序的办法。</p>
<p>有以下两种方式，<strong>本项目采用方式二</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082102910.png" alt="image-20240508210246804"></p>
<h3 id="2-为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。"><a href="#2-为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。" class="headerlink" title="2. 为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。"></a>2. 为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。</h3><p>实模式包含以下特点：</p>
<ul>
<li>16位代码</li>
<li>无保护机制</li>
<li>无分页机制</li>
<li>仅使用1MB内存</li>
</ul>
<h3 id="3-x86与编程相关的主要内核寄存器"><a href="#3-x86与编程相关的主要内核寄存器" class="headerlink" title="3. x86与编程相关的主要内核寄存器"></a>3. x86与编程相关的主要内核寄存器</h3><p>   <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082107803.png" alt="image-20240508210729628"></p>
<ul>
<li><p>CS&#x2F;DS&#x2F;SS&#x2F;ES&#x2F;FS&#x2F;GS为段寄存器</p>
<ul>
<li><p>当访问特定内存地址时，需要采用<code>段:偏移</code>的形式，即实际地址为<code>段值&lt;&lt;4+偏移</code>。</p>
</li>
<li><p>例如：访问<code>0x7c00</code>，需要使用<code>0x7c0:0</code>，或<code>0:0x7c00</code></p>
</li>
<li><p>注意：初始化段寄存器时无需显示初始化<code>CS</code>。</p>
<blockquote>
<p>在 x86 架构中，CS（Code Segment）寄存器是用于存放代码段的选择子，在实模式下，CS 寄存器的初始化通常由处理器自动完成。</p>
<p>在启动阶段，处理器会将 CS 寄存器设置为默认值，通常为 0xFFFF，这意味着 CS 段选择子为 0xFFFF，代码段的起始地址是 0xFFFF0。这个默认的值使得处理器能够正常从 BIOS 的 ROM 中加载启动代码，并执行第一条指令。因此，在启动阶段，通常不需要显式地设置 CS 寄存器。</p>
<p>相反，通过设置 DS、SS、ES、FS、GS 等段寄存器为 0，可以将默认的段地址 0 应用于数据段、栈段和其他段。这样，CPU 将能够正确访问位于物理地址 0 处的引导程序代码，并且在实模式下，所有的段都共享同一个地址空间，因此 CS 寄存器的设置可以由 CPU 自动处理。</p>
</blockquote>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082110449.png" alt="image-20240508211028354"></p>
</li>
</ul>
<h3 id="4-实模式下的内存映射（8086）"><a href="#4-实模式下的内存映射（8086）" class="headerlink" title="4. 实模式下的内存映射（8086）"></a>4. 实模式下的内存映射（8086）</h3><ul>
<li><p>其中灰色为可用区域。</p>
 <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082112921.png" alt="image-20240508211243702" style="zoom:50%;" /></li>
</ul>
<h2 id="2-5-使用BIOS中断显示字符"><a href="#2-5-使用BIOS中断显示字符" class="headerlink" title="2.5 使用BIOS中断显示字符"></a>2.5 使用BIOS中断显示字符</h2><h3 id="1-如何显示字符？"><a href="#1-如何显示字符？" class="headerlink" title="1. 如何显示字符？"></a>1. 如何显示字符？</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090906770.png" alt="image-20240509090652672" style="zoom: 80%;" />

<p>BIOS提供了一组服务，可以方便地帮助我们操纵硬件，避免与硬件细节打交道。</p>
<ul>
<li>当调用<code>INT</code>软中断时，<code>CPU</code>会转到中断向量表处（<code>0x00000000~0x000003FF</code>），从中取出相应的地址位置，取出<code>BIOS</code>程序的入口地址，从而转到<code>BIOS</code>程序中运行。</li>
<li>参数通过寄存器传递。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090908623.png" alt="image-20240509090809536" />

<ul>
<li>本项目采用<code>INT 10, AH=0xE</code>显示字符<ul>
<li>该<code>BIOS</code>中断的作用是：显示字符，同时光标前移，其中（寄存器）<code>AL=字符</code>、<code>BL=前景色</code>、<code>BH=页码</code>。</li>
<li>具体来说<ul>
<li><code>BH</code>为目前的显示页。若在图形模式，<code>BH</code>需设置为0；</li>
<li>假如在图形模式下，也可设定<code>BL</code>来表示文字的颜色，文字模式下的<code>BL</code>则无此功能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-6-使用BIOS中断读取磁盘"><a href="#2-6-使用BIOS中断读取磁盘" class="headerlink" title="2.6 使用BIOS中断读取磁盘"></a>2.6 使用BIOS中断读取磁盘</h2><h3 id="1-怎样完成从Boot加载loader的过程？"><a href="#1-怎样完成从Boot加载loader的过程？" class="headerlink" title="1. 怎样完成从Boot加载loader的过程？"></a>1. 怎样完成从Boot加载loader的过程？</h3><p><code>BIOS</code>提供了磁盘读取的接口，便于从磁盘上读取<code>loader</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090926726.png" alt="image-20240509092600575"></p>
<p><strong>本项目的设计是在磁盘的第<code>0</code>号扇区（即<code>Boot</code>程序后）紧挨着放置<code>loader</code>程序。在加载时，考虑将其加载到<code>0x8000</code>处。</strong></p>
<ul>
<li>从磁盘上的第<code>1</code>号扇区开始，读取指定数量的扇区；</li>
<li>将其加载到内存中的指定地址处（<code>0x8000</code>）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090931367.png" alt="image-20240509093110267"></p>
<h3 id="2-INT-13磁盘读取"><a href="#2-INT-13磁盘读取" class="headerlink" title="2. INT 13磁盘读取"></a>2. INT 13磁盘读取</h3><p>（1）BIOS提供了磁盘操作的服务中断，其具体使用方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口参数								</span></span><br><span class="line">    AH = <span class="number">02</span>H							   						</span><br><span class="line">    AL = 扇区数								 </span><br><span class="line">    CH = 柱面									  </span><br><span class="line">    CL = 扇区								     </span><br><span class="line">    DH = 磁头								 </span><br><span class="line">    DL = 驱动器</span><br><span class="line">      - <span class="number">00</span>H~<span class="number">7F</span>H  ：软盘</span><br><span class="line">      - <span class="number">80</span>H~<span class="number">0F</span>FH ：硬盘</span><br><span class="line">    ES:BX = 缓冲区地址（即要加载到的内存中的地址）</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 出口参数</span></span><br><span class="line">- 若传输成功，	</span><br><span class="line">	CF = <span class="number">0</span></span><br><span class="line">	AH = <span class="number">00</span>H</span><br><span class="line">	AL = 传输的扇区数</span><br><span class="line">- 若传输失败，AH = 状态码</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cx=ch:cl</code>（<code>ch</code>占高<code>8</code>位，<code>cl</code>占低<code>8</code>位）。<ul>
<li>因此<code>mov $0x2, %cx</code>相当于直接一步到位，将<code>ch</code>设置为<code>0</code>，<code>cl</code>设置为<code>2</code>。</li>
<li>注意<code>cl</code>为<code>2</code>是因为：<strong>在本项目采用的读取方法下，BIOS认为磁盘的编号是从1开始的。</strong></li>
</ul>
</li>
<li><code>mov $64, %al</code><ul>
<li><code>al</code>为读取的扇区数量，必须小于<code>128</code>，暂设置成<code>32KB</code></li>
<li>因为一个扇区大小是<code>512B</code>，即<code>0.5KB</code>。因此若要暂设成<code>32KB</code>，即相当于<code>64</code>个扇区。</li>
</ul>
</li>
</ul>
<p>（2）运行完成后，将会把磁盘<code>1</code>中的相关内容加载到内存的<code>0x8000</code>处：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091016385.png" alt="image-20240509101626325"></p>
<h2 id="2-7-初始化引导程序"><a href="#2-7-初始化引导程序" class="headerlink" title="2.7 初始化引导程序"></a>2.7 初始化引导程序</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091022007.png" alt="image-20240509102201895"></p>
<h3 id="1、如何生成loader并写入磁盘映像？"><a href="#1、如何生成loader并写入磁盘映像？" class="headerlink" title="1、如何生成loader并写入磁盘映像？"></a>1、如何生成loader并写入磁盘映像？</h3><h3 id="2、怎样从boot跳转到loader执行？"><a href="#2、怎样从boot跳转到loader执行？" class="headerlink" title="2、怎样从boot跳转到loader执行？"></a>2、怎样从boot跳转到loader执行？</h3><h1 id="三、加载器loader的实现"><a href="#三、加载器loader的实现" class="headerlink" title="三、加载器loader的实现"></a>三、加载器loader的实现</h1><h2 id="3-1-利用内联汇编显示字符串"><a href="#3-1-利用内联汇编显示字符串" class="headerlink" title="3.1 利用内联汇编显示字符串"></a>3.1 利用内联汇编显示字符串</h2><p>用于显示loader加载过程，从而提示加载到哪一步时出现问题。</p>
<h3 id="1、内联汇编理论"><a href="#1、内联汇编理论" class="headerlink" title="1、内联汇编理论"></a>1、内联汇编理论</h3><ul>
<li><p><strong>概述</strong></p>
<p>在开发操作系统过程中，有时必须使用某些特殊的指令（如<code>int/outb/hlt</code>等），而<code>C</code>编译器无法自动使用这些指令。因此，如果要使用这些指令，有两种方式：</p>
<ul>
<li>在汇编文件中为该指令的使用<strong>创建汇编函数（子程序）</strong>，然后在C代码中以函数调用的方式去使用；</li>
<li>使用<strong>内联汇编</strong>，即在C代码中嵌入汇编程序。</li>
</ul>
<p>在大多数情况下，使用内联汇编会更加简单、易用。因此，以下将简要介绍本项目中所用的相关的GCC内联汇编的写法。</p>
</li>
<li><p><strong>基本格式</strong></p>
<p>基本格式如下，以<code>asm</code>关键字开头，包含<code>3</code>个可选的配置项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(汇编语句</span><br><span class="line"> :输出操作数(可选)</span><br><span class="line"> :输入操作数(可选)</span><br><span class="line"> :被破坏的寄存器列表(可选)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>下面举个例子，其功能为将<code>a</code>的值赋值给<code>b</code>，具体代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>, b;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;movl %1,%%eax; movl %%eax, %0;&quot;</span></span><br><span class="line">	:<span class="string">&quot;=r&quot;</span>(b)	<span class="comment">/* 输出 */</span></span><br><span class="line">	:<span class="string">&quot;r&quot;</span>(a)		<span class="comment">/* 输入 */</span></span><br><span class="line">	:<span class="string">&quot;%eax&quot;</span>		<span class="comment">/* 破坏寄存器 */</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其效果等价于<code>movl a, %%eax; movl %%eax, b</code>，即：将<code>a</code>的值先给<code>eax</code>寄存器，再将<code>eax</code>寄存器的值给到<code>b</code>，最终实现<code>b=a</code>的效果。</p>
</li>
<li><p><strong>具体格式说明</strong></p>
<ul>
<li><p>只有一条汇编语句</p>
<p>在内联汇编中，可以只有汇编语句，即没有输出、输入操作数，没有被破坏的寄存器列表。例如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;hlt&quot;</span>);  <span class="comment">// 让CPU暂停运行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有多条汇编语句</p>
<p>当有多条汇编语句时，需要写在同一字符串中，不同语句之间用<code>;</code>或者<code>\n\t</code>分隔。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;sti; hlt&quot;</span>);	<span class="comment">// 开启中断，然后让CPU暂停运行</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;sti\n\thlt&quot;</span>);	<span class="comment">// 开启中断，然后让CPU暂停运行</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;sti\n\t&quot;</span>		<span class="comment">// 同上。C语言中多个连续的字符串，会被认为是同一字符串</span></span><br><span class="line">    <span class="string">&quot;hlt&quot;</span>);			<span class="comment">// 开启中断，然后让CPU暂停运行</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>有输出操作数</strong></p>
<p>当汇编语句中有些数据需要存储到<code>C</code>语言中的某些变量中时，则可以使用输出操作数。例如，下面的代码是将<code>c</code>变量的值通过<code>mov $3, c</code>设置成<code>3</code>。其中<code>%[out]</code>为定义的一个输出约束，其名称应与<code>:</code>后的<code>out</code>相同，<code>&quot;=r&quot;(c)</code>指定了<code>c</code>变量映射到某个寄存器中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;mov $3, %[out]&quot;</span>:[out]<span class="string">&quot;=r&quot;</span>(c));</span><br></pre></td></tr></table></figure>

<p>通过上述方式，即实现了类似<code>mov $3,c</code>的效果。</p>
<p>其中<code>=r</code>还可以设置成其它，如下表所示</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">寄存器</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="center">任意寄存器</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">%eax,%ax,%al</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">%ebx,%bx,%bl</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">%ecx,%cx,%cl</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">%edx,%dx,%d</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">%esi,%si</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">%edi,%di</td>
</tr>
</tbody></table>
</li>
<li><p><strong>有输入操作数</strong></p>
<p>当需要从<code>C</code>语言中读取变量的值到汇编语句中时，则需要使用输入操作数。例如，下面的代码中，<code>mov%[ch], %%al</code>用于将<code>c</code>变量中的字符写到<code>al</code>中。因此，在输入操作数中使用了<code>[ch]&quot;r&quot;(c)</code>，即<code>c</code>变量映射到某个寄存器上（见上文中输出操作数的类似设置）。最终的效果为：<code>mov$0xe,%%ah、mov%[c],%%al</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line">    <span class="string">&quot;mov $0xe, %%ah\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;mov %[ch], %%al\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;int $Ox10&quot;</span>::[ch]<span class="string">&quot;r&quot;</span>(c)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免优化</p>
<p>在某些情况下，<code>GCC</code>编译器会对内联汇编中的汇编语句进行优化处理，最终导致生成语句和预期的不同，影响程序的执行结果。为了避免这些问题，可以强制要求<code>GCC</code>不对其进行优化，即原样的生成。要达到这点，可以使用<code>__asm__ __volatile_</code>替代原来的<code>asm</code>。</p>
</li>
<li><p>参考资料</p>
<p>GCC内联汇编介绍：<a target="_blank" rel="noopener" href="https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a><br>GCC内联汇编介绍：<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Inline_Assembly">https://wiki.osdev.org/Inline_Assembly</a><br>内联汇编示例：<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Inline_Assembly/Examples">https://wiki.osdev.org/Inline_Assembly/Examples</a></p>
</li>
</ul>
<h3 id="2、示例"><a href="#2、示例" class="headerlink" title="2、示例"></a>2、示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_msg</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> * msg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = *msg++) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 利用内联汇编显示字符串</span></span><br><span class="line">        <span class="keyword">asm</span>(</span><br><span class="line">            <span class="string">&quot;mov $0xe, %%ah\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;mov %[ch], %%al\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;int $0x10&quot;</span></span><br><span class="line">            ::[ch]<span class="string">&quot;r&quot;</span>(c)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loader_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    show_msg(<span class="string">&quot;....loading....\n\r&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091941355.png" alt="image-20240509194129987"></p>
<h2 id="3-2-检测内存容量"><a href="#3-2-检测内存容量" class="headerlink" title="3.2 检测内存容量"></a>3.2 检测内存容量</h2><p>对<code>loader</code>做一些功能扩展。</p>
<h3 id="1、内存检测方法理论"><a href="#1、内存检测方法理论" class="headerlink" title="1、内存检测方法理论"></a>1、内存检测方法理论</h3><p>内存检测方法：<code>INT 0x15, EAX = 0xE820</code></p>
<p>没有找到专门介绍内存检测方法的官方文档，只在<code>osdev</code>网站上（见下文参考资料）中找到相关的检测方法。具体来看，其中有简单也有复杂的方法，有的只在某些机器上可用。最推荐的一种方法如下（摘自osdev）：</p>
<blockquote>
<p><strong>第一次调用时，ES: DI存储保存读取的信息的存储位置：</strong><br>清除<code>EBX</code>，设置为<code>0</code><br><code>EDX</code>设置成	<code>0x534D4150</code><br><code>EAX</code>设置成	<code>0xE820</code><br><code>ECX</code>设置成	<code>24</code><br>执行		   	 <code>INT 0x15</code><br>返回结果      <code>EAX=0x534D4150</code>，<code>CF</code>标志清<code>0</code>，<code>EBX</code>被设置成某个数值用于下次调用，<code>CL</code>&#x3D;实际读取的字节数</p>
<p><strong>后续调用：</strong><br><code>EDX</code>设置成	<code>0x534D4150</code><br><code>EAX</code>重设为	<code>0xE820</code><br><code>ECX</code>重设为	<code>24</code><br>执行				  <code>INT 0x15</code><br>返回结果	   <code>EAX=0x534D4150</code>，<code>CF</code>标志清<code>0</code>。如果<code>EBX=0</code>，则表明读取完毕，否则当前条目有效。</p>
</blockquote>
<p>参考资料——内存检测方法：<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Detecting_Memory_(x86)">https://wiki.osdev.org/Detecting_Memory_(x86)</a></p>
<h3 id="2、示例-1"><a href="#2、示例-1" class="headerlink" title="2、示例"></a>2、示例</h3><p>首先需要自定义一个结构体来保存boot获取到的硬件信息，以便后期传递给操作系统使用。定义在comm中</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092034455.png" alt="image-20240509203459102"></p>
<p>当<code>for</code>循环执行完毕后，<code>boot_info</code>内部的信息如下，共分配两块内存区域：</p>
<ul>
<li>第1块，<code>0-640KB</code>左右，在<code>1MB</code>以内；</li>
<li>第2块，<code>1MB-128MB</code>左右。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092042975.png" alt="image-20240509204234901"></p>
<p>可以结合<code>qemu</code>的配置脚本来看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@REM 适用于windows</span><br><span class="line">start qemu-system-i386  -m 128M -s -S  -drive file=disk1.vhd,index=0,media=disk,format=raw -drive file=disk2.vhd,index=1,media=disk,format=raw -d pcall,page,mmu,cpu_reset,guest_errors,page,trace:ps2_keyboard_set_translation</span><br></pre></td></tr></table></figure>

<p><code>qemu</code>启动时内存大小分配即为<code>128M</code>，即<code>-m 128M</code>。</p>
<h2 id="3-3-切换至保护模式"><a href="#3-3-切换至保护模式" class="headerlink" title="3.3 切换至保护模式"></a>3.3 切换至保护模式</h2><h3 id="1、理论基础"><a href="#1、理论基础" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092111828.png" alt="image-20240509211140943"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092111423.png" alt="image-20240509211151568"></p>
<h3 id="2、编程细节"><a href="#2、编程细节" class="headerlink" title="2、编程细节"></a>2、编程细节</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdt.start31_16 = start &gt;&gt; <span class="number">16</span>;</span><br><span class="line">gdt.start15_0 = start &amp; <span class="number">0xffff</span>;</span><br></pre></td></tr></table></figure>

<p><strong>（1）关闭中断</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关中断</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">cli</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;cli&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 禁用中断</span></span><br><span class="line">cli();</span><br></pre></td></tr></table></figure>

<p><code>cli()</code>会影响<code>eflags</code>寄存器：</p>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405100950973.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405100954581.png" width="300"/>
</center>
**（2）打开`A20`地址线**

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 打开A20地址线</span></span><br><span class="line"><span class="type">uint8_t</span> v = inb(<span class="number">0x92</span>);</span><br><span class="line">outb(<span class="number">0x92</span>, v | <span class="number">0x2</span>);  <span class="comment">// 0x00000010</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）加载<code>GDT</code>表</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> gdt_table[][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xffff</span>, <span class="number">0x0000</span>, <span class="number">0x9a00</span>, <span class="number">0x00cf</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xffff</span>, <span class="number">0x0000</span>, <span class="number">0x9200</span>, <span class="number">0x00cf</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 加载GDT表</span></span><br><span class="line">lgdt((<span class="type">uint32_t</span>)gdt_table, <span class="keyword">sizeof</span>(gdt_table));</span><br></pre></td></tr></table></figure>

<p>在<code>qemu</code>的<code>[view-&gt;compatmonitor()]</code>中输入<code>info registers</code>，可以看到<code>GDT</code>的信息变化：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101016115.png" alt="image-20240510101651071"></p>
<p><code>GDT</code>表写入后，<code>GDT=00009358 00000017</code>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101452241.png" alt="image-20240510145235174"></p>
<p>加载的<code>GDT</code>表项与所给出的表项一致：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101453798.png" alt="image-20240510145356743"></p>
<p><strong>（4）开启保护模式使能位</strong></p>
<p>开启保护位时，需设置<code>CR0</code>寄存器的<code>PE</code>位为<code>1</code>。由于<code>CR0</code>无法直接读写，必须先读取到某个中间寄存器，修改值后，再将值回写到<code>CR0</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 开启保护模式使能位</span></span><br><span class="line"><span class="type">uint32_t</span> cr0 = read_cr0();</span><br><span class="line">write_cr0(cr0 | (<span class="number">1</span> &lt;&lt; <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p><strong>（5）远跳转</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5. 远跳转，跳转到32位指令的入口处</span></span><br><span class="line">far_jump(<span class="number">8</span>, (<span class="type">uint32_t</span>)protect_mode_entry);  <span class="comment">// 这个8和保护模式的硬件细节，以及GDT表有关</span></span><br></pre></td></tr></table></figure>

<p>当跳转到<code>protect_mode_entry</code>后，可以看到段寄存器<code>CS</code>项变为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 00000000 0000ffff 00cf9a00 DPL=0 CS32</span><br></pre></td></tr></table></figure>

<p>即进入<code>32</code>位代码模式。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101455214.png" alt="image-20240510145523144"></p>
<p>将剩余的寄存器也修改到32位模式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protect_mode_entry:</span><br><span class="line">	mov $<span class="number">16</span>, %ax</span><br><span class="line">	mov %ax, %ds</span><br><span class="line">	mov %ax, %ss</span><br><span class="line">	mov %ax, %es</span><br><span class="line">	mov %ax, %fs</span><br><span class="line">	mov %ax, %gs</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101500881.png" alt="image-20240510150001767"></p>
<h2 id="3-4-使用LBA读取磁盘"><a href="#3-4-使用LBA读取磁盘" class="headerlink" title="3.4 使用LBA读取磁盘"></a>3.4 使用LBA读取磁盘</h2><p>参考资料：<a target="_blank" rel="noopener" href="https://wiki.osdev.org/ATA_PIO_Mode">硬盘访问模式及相关寄存器</a></p>
<p>虽然<code>BIOS</code>提供了磁盘读取的接口，方便从磁盘上读取<code>loader</code>，但在进入保护模式后，<code>BIOS</code>功能无法使用，<strong>读取磁盘需要使用到<code>LBA</code>模式</strong>。因此必须自己设计磁盘读取的代码。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101510647.png" alt="image-20240510151038444"></p>
<p>具体来讲，本项目采用<code>LBA48</code>模式。<code>LBA48</code>模式将硬盘上所有的扇区看成线性排列，没有磁盘、柱面等概念，因此访问起来更加简单，序号从<code>0</code>开始，其访问序列如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">outb(0x1F6,0x40|(slavebit&lt;&lt;4))  	// 选择硬盘:主盘或从盘</span><br><span class="line"></span><br><span class="line">outb(0x1F2,sectorcount high byte)	// 将扇区数量的高8位写入端口0x1F2</span><br><span class="line">// 分别将LBA(Logical Block Address)的第4、5、6个字节写入端口0x1F3、0x1F4、0x1F5</span><br><span class="line">outb(0x1F3,LBA4)							 </span><br><span class="line">outb(0x1F4,LBA5)</span><br><span class="line">outb(0x1F5,LBA6)</span><br><span class="line"></span><br><span class="line">outb (0x1F2,sectorcount low byte)	// 将扇区数量的低8位写入端口0x1F2</span><br><span class="line">// 分别将LBA(Logical Block Address)的第1、2、3个字节写入端口0x1F3、0x1F4、0x1F5</span><br><span class="line">outb(0x1F3,LBA1)</span><br><span class="line">outb(0x1F4,LBA2)</span><br><span class="line">outb(0x1F5,LBA3)</span><br><span class="line"></span><br><span class="line">Send the &quot;READ SECTORS EXT&quot; command (0x24) to port 0x1F7: </span><br><span class="line">outb(0x1F7,0x24)	// 告诉硬盘要读取扇区的数据</span><br></pre></td></tr></table></figure>

<p>各寄存器说明如下:</p>
<table>
<thead>
<tr>
<th>寄存器偏移</th>
<th>读写</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>R&#x2F;W</td>
<td>数据寄存器</td>
</tr>
<tr>
<td>1</td>
<td>R</td>
<td>错误寄存器</td>
</tr>
<tr>
<td>1</td>
<td>W</td>
<td>特性寄存器</td>
</tr>
<tr>
<td>2</td>
<td>R&#x2F;W</td>
<td>扇区数量寄存器</td>
</tr>
<tr>
<td>3</td>
<td>R&#x2F;W</td>
<td>Sector Number Register (LBAlo)</td>
</tr>
<tr>
<td>4</td>
<td>R&#x2F;W</td>
<td>Cylinder Low Register &#x2F;(LBAmid)</td>
</tr>
<tr>
<td>5</td>
<td>R&#x2F;W</td>
<td>Cylinder High Register &#x2F;(LBAhi)</td>
</tr>
<tr>
<td>6</td>
<td>R&#x2F;W</td>
<td>Drive &#x2F; Head Register</td>
</tr>
<tr>
<td>7</td>
<td>R</td>
<td>状态寄存器</td>
</tr>
<tr>
<td>7</td>
<td>W</td>
<td>命令寄存器</td>
</tr>
</tbody></table>
<ul>
<li>其中<code>0x1F6</code>寄存器（<code>Drive/Head</code>）对应的位如下：</li>
</ul>
<table>
<thead>
<tr>
<th>位</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0-3</td>
<td></td>
<td>在, bits 24 to 27 of the block number.</td>
</tr>
<tr>
<td>4</td>
<td>DRV</td>
<td>驱动器号（驱动器号：主盘和从盘。当只有一块硬盘时，默认第一块硬盘上放在主盘上。）</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>LBA</td>
<td>LBA模式下设置为1</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><code>Status Register(I/O base + 7)</code></li>
</ul>
<table>
<thead>
<tr>
<th>位</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>ERR</td>
<td>发生错误</td>
</tr>
<tr>
<td>1</td>
<td>IDX</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>CORR</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>DRQ</td>
<td>就绪，可以写数据或读取数据</td>
</tr>
<tr>
<td>4</td>
<td>SRV</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>DF</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>RDY</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>BSY</td>
<td>忙</td>
</tr>
</tbody></table>
<p>由于<code>loader</code>占用的大小较大，约几十<code>kb</code>的样子。由于不确定具体大小，因此尽量将内核往后放，放在第<code>100</code>个扇区的位置，并且将内核的大小为<code>500</code>，即<code>250kb</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static void read_disk (uint32_t sector, uint32_t sector_count, uint8_t *buf);</span></span><br><span class="line">read_disk(<span class="number">100</span>, <span class="number">500</span>, (<span class="type">uint8_t</span> *)SYS_KERNEL_LOAD_ADDR);</span><br></pre></td></tr></table></figure>

<h2 id="3-5-创建内核工程"><a href="#3-5-创建内核工程" class="headerlink" title="3.5 创建内核工程"></a>3.5 创建内核工程</h2><p>创建内核工程，并将工程写到磁盘上第<code>1MB</code>位置处，<code>loader</code>加载后将跳转过去。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101622446.png" alt="image-20240510162243231"></p>
<p>新建<code>kernel</code>文件夹，并在内部新建<code>CMakeLists.txt</code>如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">project(kernel LANGUAGES C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的链接器</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;-m elf_i386  -Ttext=0x100000&quot;</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_LINK_EXECUTABLE <span class="string">&quot;<span class="variable">$&#123;LINKER_TOOL&#125;</span> &lt;OBJECTS&gt; <span class="variable">$&#123;CMAKE_EXE_LINKER_FLAGS&#125;</span> -o <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有的汇编、C文件加入工程</span></span><br><span class="line"><span class="comment"># 注意保证start.asm在最前头，这样对应的程序会放在bin文件开头，从而在加载到0x8000时能在开头处</span></span><br><span class="line">file(GLOB_RECURSE C_LIST <span class="string">&quot;*.c&quot;</span> <span class="string">&quot;*.h&quot;</span>)</span><br><span class="line"><span class="comment"># 将GLOB改为GLOB_RECURSE，因为kernel目录下包含init等子目录，需要进行递归</span></span><br><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> init/start.S <span class="variable">$&#123;C_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bin文件生成，写入到image目录下</span></span><br><span class="line">add_custom_command(TARGET <span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">                   POST_BUILD</span><br><span class="line">                   COMMAND <span class="variable">$&#123;OBJCOPY_TOOL&#125;</span> -O binary <span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../../image/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.bin</span><br><span class="line">                   COMMAND <span class="variable">$&#123;OBJDUMP_TOOL&#125;</span> -x -d -S -m i386 <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf &gt; <span class="variable">$&#123;PROJECT_NAME&#125;</span>_dis.txt</span><br><span class="line">                   <span class="comment"># i8086改为i386，即从16位模式改为32位模式</span></span><br><span class="line">                   COMMAND <span class="variable">$&#123;READELF_TOOL&#125;</span> -a <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf &gt; <span class="variable">$&#123;PROJECT_NAME&#125;</span>_elf.txt</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="3-6-向内核传递启动信息"><a href="#3-6-向内核传递启动信息" class="headerlink" title="3.6 向内核传递启动信息"></a>3.6 向内核传递启动信息</h2><h3 id="1、如何实现从loader到kernel的信息传输？"><a href="#1、如何实现从loader到kernel的信息传输？" class="headerlink" title="1、如何实现从loader到kernel的信息传输？"></a>1、如何实现从loader到kernel的信息传输？</h3><p>信息的传递流程为：<code>boot_info-&gt;loader-&gt;kernel</code>。现在的问题就是如何实现从<code>loader</code>到<code>kernel</code>的传输？</p>
<ul>
<li><p>方式一：将<code>boot_info</code>写到某个固定的地址，再由<code>kernel</code>自行去取：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101952279.png" alt="image-20240510195254050"></p>
</li>
<li><p>方式二：将内核的入口地址处视为存放着一个接受启动信息参数的函数，使用函数调用：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101954937.png" alt="image-20240510195449809"></p>
<blockquote>
<p><code>(void(*)(boot_info_t *))(SYS_KERNEL_LOAD_ADDR)(&amp;boot_info)</code></p>
<p>这个表达式是一个函数指针的类型转换，用于将一个特定地址处的函数映射到一个特定类型的函数指针。调用这个函数指针，并将 <code>boot_info</code> 作为参数传递给该函数。</p>
<ol>
<li><code>(SYS_KERNEL_LOAD_ADDR)</code>：<ul>
<li>这部分表示一个地址，即内核加载的地址 <code>SYS_KERNEL_LOAD_ADDR</code>。</li>
</ul>
</li>
<li><code>(void (*)(boot_info_t *))</code>：<ul>
<li>这部分是一个函数指针类型的转换。</li>
<li><code>void (*)(boot_info_t *)</code> 表示一个函数指针，指向一个接受 <code>boot_info_t *</code> 类型参数并返回 <code>void</code> 类型的函数。</li>
</ul>
</li>
<li><code>(SYS_KERNEL_LOAD_ADDR)(&amp;boot_info)</code>：<ul>
<li>这部分将 <code>boot_info</code> 的地址作为参数传递给地址 <code>SYS_KERNEL_LOAD_ADDR</code> 处的函数，并且将返回的结果转换为 <code>(void (*)(boot_info_t *))</code> 类型的函数指针。</li>
</ul>
</li>
</ol>
<p>综合起来，整个表达式的作用是将位于地址 <code>SYS_KERNEL_LOAD_ADDR</code> 处的函数转换为一个接受 <code>boot_info_t *</code> 类型参数的函数指针，并且调用这个函数，将 <code>boot_info</code> 作为参数传递给它。</p>
</blockquote>
</li>
</ul>
<h3 id="2、x86栈的基本结构"><a href="#2、x86栈的基本结构" class="headerlink" title="2、x86栈的基本结构"></a>2、x86栈的基本结构</h3><p>保护模式下，栈单元大小为<code>32</code>位&#x2F;<code>4</code>字节。（在<code>32</code>位系统中）</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102027415.png" alt="image-20240510202728422"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102027751.png" alt="image-20240510202743173"></p>
<h3 id="3、实现细节"><a href="#3、实现细节" class="headerlink" title="3、实现细节"></a>3、实现细节</h3><p>（1）总体程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    .text</span><br><span class="line">    .extern kernel_init</span><br><span class="line">    .global _start</span><br><span class="line">    # void start (boot_info_t *boot_info)</span><br><span class="line">_start:</span><br><span class="line">    /*</span><br><span class="line">        将boot_info压入栈中，并传递给kernel_init</span><br><span class="line">        boot_info则来自_start被调用时，((void (*)(boot_info_t *))SYS_KERNEL_LOAD_ADDR)(&amp;boot_info);也会压栈</span><br><span class="line">            ((void (*)(boot_info_t *))SYS_KERNEL_LOAD_ADDR)(&amp;boot_info);</span><br><span class="line">            84d8:	83 ec 0c             	sub    $0xc,%sp</span><br><span class="line">            84db:	68 40 95             	push   $0x9540</span><br><span class="line">            84de:	00 00                	add    %al,(%bx,%si)</span><br><span class="line">            84e0:	b8 00 00             	mov    $0x0,%ax</span><br><span class="line">            84e3:	10 00                	adc    %al,(%bx,%si)</span><br><span class="line">            84e5:	ff d0                	call   *%ax</span><br><span class="line">            84e7:	83 c4 10             	add    $0x10,%sp</span><br><span class="line">        也即是说_start实际上是被调函数，参考讲义中的test函数的逻辑来操作</span><br><span class="line">    */</span><br><span class="line">    push %ebp</span><br><span class="line">    mov %esp, %ebp</span><br><span class="line">    mov 0x8(%ebp), %eax</span><br><span class="line">    /*</span><br><span class="line">        通过ebp+偏移来取得boot_info</span><br><span class="line">        由于_start仅1个参数，因此栈的局部结构为：</span><br><span class="line">            - 参数：boot_info</span><br><span class="line">            - 返回地址</span><br><span class="line">            - ebp当前指向位置（esp当前指向位置）</span><br><span class="line">        所以为0x8(%ebp)</span><br><span class="line">    */  </span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        由于最终是原地跳转，不会回到loader中，因此也可以不考虑ebp恢复的情况，此时上述三行可用一行来实现：</span><br><span class="line">            mov 4(%esp), %eax</span><br><span class="line"></span><br><span class="line">        当不考虑ebp时，esp+4即可取到boot_info</span><br><span class="line">        由于_start仅1个参数，因此栈的局部结构为：</span><br><span class="line">            - 参数：boot_info</span><br><span class="line">            - 返回地址（esp当前指向位置）</span><br><span class="line">        所以为4(%esp)</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    # kernel_init (boot_info)</span><br><span class="line">    push %eax  </span><br><span class="line">    call kernel_init  # 此时的kernel_init是被_start调用的函数</span><br><span class="line"></span><br><span class="line">    jmp .</span><br></pre></td></tr></table></figure>

<p>（2）具体执行</p>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push %ebp</span><br><span class="line">mov %esp, %ebp</span><br><span class="line">mov 0x8(%ebp), %eax</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102049124.png" alt="image-20240510204938049"></p>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov 0x8(%ebp), %eax</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102050925.png" alt="image-20240510205045871"></p>
<p>而在<code>./build/source/loader/loder_elf.txt</code>的符号表中，可以看到<code>boot_info</code>的地址即为<code>0x9540</code>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102052194.png" alt="image-20240510205246084"></p>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push %eax  </span><br><span class="line">call kernel_init  # 此时的kernel_init是被_start调用的函数</span><br><span class="line">jmp .</span><br></pre></td></tr></table></figure>

<p>当进入<code>kernel_init</code>函数后，可以看到传入的<code>boot_info</code>的地址也是<code>0x9540</code>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102054365.png" alt="image-20240510205443276"></p>
<h2 id="3-7-代码-数据段与链接脚本"><a href="#3-7-代码-数据段与链接脚本" class="headerlink" title="3.7 代码&#x2F;数据段与链接脚本"></a>3.7 代码&#x2F;数据段与链接脚本</h2><h3 id="1、链接的理论基础"><a href="#1、链接的理论基础" class="headerlink" title="1、链接的理论基础"></a>1、链接的理论基础</h3><blockquote>
<p>可参考【Computer-&gt;CSAPP-CSAPP_Ch7 链接】相关笔记。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102057812.png" alt="image-20240510205719578"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102108837.png" alt="image-20240510210839581"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102108978.png" alt="image-20240510210855757"></p>
<p>举例如下：</p>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102114815.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102116737.png" width="300"/>
</center>


<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102111597.png" alt="image-20240510211122344"></p>
<h3 id="2、自定义链接脚本"><a href="#2、自定义链接脚本" class="headerlink" title="2、自定义链接脚本"></a>2、自定义链接脚本</h3><p>上述所讲为编译器默认配置。可自定义链接脚本，定义工程中相应的代码或数据放在哪些位置。</p>
<p>编写<code>kernel.lds</code>文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x20000;  // 控制.text section的起始地址，后续的section也可以进行相应的设置</span><br><span class="line"></span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text)  // 通配符： *</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		*(.rodata)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.data : &#123;</span><br><span class="line">		*(.data)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.bss : &#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并修改对应的<code>[kernel/CMakeLists.txt]</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_EXE_LINKER_FLAGS &quot;-m elf_i386  -T $&#123;PROJECT_SOURCE_DIR&#125;/kernel.lds&quot;)</span><br></pre></td></tr></table></figure>

<p>也就是说链接脚本控制了各个<code>section</code>具体的存放位置，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102138372.png" alt="image-20240510213841287"></p>
<blockquote>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html">GCC LD官方文档</a></p>
<p><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Linker_Scripts">linker脚本(较易阅读)</a></p>
<p><a target="_blank" rel="noopener" href="http://www.bravegnu.org/gnu-eprog/linker.html">ARM Linker链接脚本</a></p>
<p><a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/ld/">ld脚本编写</a></p>
</blockquote>
<h2 id="3-8-加载内核映像文件"><a href="#3-8-加载内核映像文件" class="headerlink" title="3.8 加载内核映像文件"></a>3.8 加载内核映像文件</h2><h3 id="1、理论基础-1"><a href="#1、理论基础-1" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112014421.png" alt="image-20240511201413000"></p>
<p>若在<code>#12</code>行设置<code>. = 200000</code>，则会导致在<code>.rodata</code>和<code>.data</code>中间出现较大的空闲空间，导致最终的文件大小大于<code>1MB</code>，这个大小过大了。且如果采用二进制映像文件，操作系统是无法得知各个<code>section</code>在内存中分布的具体位置的。</p>
<p>为了更好地组织程序和数据，一般需要专用的文件格式，如<code>PE</code>格式或者<code>ELF</code>格式。<code>ELF</code>用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件的文件格式。</p>
<blockquote>
<p>ELF文件的详细细节可参考【Computer-&gt;CSAPP-CSAPP_Ch7 链接】相关笔记。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112021480.png" alt="image-20240511202122375"></p>
<ul>
<li><p>可执行代码段和数据段从<code>p_offset</code>的位置拷贝到内存的<code>p_paddr</code>中，拷贝的大小为<code>p_filesz</code>。</p>
</li>
<li><p>在<code>ELF</code>文件格式中，<code>.data</code> 和 <code>.bss</code> 区域通常用来存储程序的已初始化和未初始化数据。在加载可执行文件时，操作系统会负责为这些区域分配内存，并将它们初始化为零。</p>
<p>因此，在生成<code>ELF</code>可执行文件时，不需要将 <code>.data</code> 和 <code>.bss</code> 区域的实际数据写入文件中。相反，只需在文件中标记出这些区域的大小，并在加载时告知操作系统需要为它们分配多大的内存空间，并将其初始化为零。</p>
</li>
<li><p><code>p_memsz = p_filesz + 清零区域</code></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112105777.png" alt="image-20240511210512520"></p>
<h3 id="2、代码实现细节"><a href="#2、代码实现细节" class="headerlink" title="2、代码实现细节"></a>2、代码实现细节</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># bin文件生成，写入到image目录下</span><br><span class="line">add_custom_command(TARGET $&#123;PROJECT_NAME&#125;</span><br><span class="line">                   POST_BUILD</span><br><span class="line">                   # 修改前</span><br><span class="line">                   # COMMAND $&#123;OBJCOPY_TOOL&#125; -O binary $&#123;PROJECT_NAME&#125;.elf $&#123;CMAKE_SOURCE_DIR&#125;/../../image/$&#123;PROJECT_NAME&#125;.elf</span><br><span class="line">                   # 修改后：-O binary =&gt; -S</span><br><span class="line">                   COMMAND $&#123;OBJCOPY_TOOL&#125; -S $&#123;PROJECT_NAME&#125;.elf $&#123;CMAKE_SOURCE_DIR&#125;/../../image/$&#123;PROJECT_NAME&#125;.elf</span><br><span class="line">				   COMMAND $&#123;OBJDUMP_TOOL&#125; -x -d -S -m i386 $&#123;PROJECT_BINARY_DIR&#125;/$&#123;PROJECT_NAME&#125;.elf &gt; $&#123;PROJECT_NAME&#125;_dis.txt</span><br><span class="line">                   COMMAND $&#123;READELF_TOOL&#125; -a $&#123;PROJECT_BINARY_DIR&#125;/$&#123;PROJECT_NAME&#125;.elf &gt; $&#123;PROJECT_NAME&#125;_elf.txt</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>修改后，新的存储规划如下：</p>
<ul>
<li>将<code>kernel</code>，即内核工程放在<code>64KB/0x10000</code>的位置；</li>
<li>也就是说，<code>0x100000</code>处只是存放一个临时的<code>ELF</code>文件，实际的内容会被加载到<code>0x10000</code>处执行。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112030942.png" alt="image-20240511203046852"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">reload_elf_file</span><span class="params">(<span class="type">uint8_t</span> *file_buffer)</span> &#123;</span><br><span class="line">    Elf32_Ehdr *elf_hdr = (Elf32_Ehdr *)file_buffer;</span><br><span class="line">    <span class="comment">// 检查是否为有效文件（粗略检查）</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr-&gt;e_ident[<span class="number">0</span>] != <span class="number">0x7F</span>) || (elf_hdr-&gt;e_ident[<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">        || (elf_hdr-&gt;e_ident[<span class="number">2</span>] != <span class="string">&#x27;L&#x27;</span>) || (elf_hdr-&gt;e_ident[<span class="number">3</span>] != <span class="string">&#x27;F&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取相应的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elf_hdr-&gt;e_phnum; i++) &#123;</span><br><span class="line">        Elf32_Phdr *phdr = (Elf32_Phdr *)(file_buffer + elf_hdr-&gt;e_phoff) + i;  <span class="comment">// 偏移量：elf_hdr-&gt;e_phoff</span></span><br><span class="line">        <span class="comment">// 判断该段是需要被加载到内存中的可执行代码或数据段</span></span><br><span class="line">        <span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将可执行代码或数据段从文件中拷贝到内存中</span></span><br><span class="line">        <span class="type">uint8_t</span> *src = file_buffer + phdr-&gt;p_offset;</span><br><span class="line">        <span class="type">uint8_t</span> *dest = (<span class="type">uint8_t</span> *)phdr-&gt;p_paddr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; phdr-&gt;p_filesz; j++) &#123;</span><br><span class="line">            *dest++ = *src++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 针对.data和.bss做进一步处理</span></span><br><span class="line">        dest = (<span class="type">uint8_t</span> *)phdr-&gt;p_paddr + phdr-&gt;p_filesz;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; phdr-&gt;p_memsz - phdr-&gt;p_filesz; j++) &#123;</span><br><span class="line">            *dest++ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elf_hdr-&gt;e_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112120766.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112119587.png" width="300"/>    
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112121617.png" width="300"/>
</center>


<h1 id="四、中断与异常处理"><a href="#四、中断与异常处理" class="headerlink" title="四、中断与异常处理"></a>四、中断与异常处理</h1><h2 id="4-1-创建GDT表及其表项"><a href="#4-1-创建GDT表及其表项" class="headerlink" title="4.1 创建GDT表及其表项"></a>4.1 创建GDT表及其表项</h2><h3 id="1、理论基础-2"><a href="#1、理论基础-2" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p><code>x86</code>系统架构（<code>IA32</code>模式）</p>
<ul>
<li><p>分段存储</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121404633.png" alt="image-20240512140427535"></p>
</li>
<li><p>分页存储</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121404406.png" alt="image-20240512140446313"></p>
</li>
</ul>
<p>在进入保护模式以后，所有有关内存访问的操作都需要经过<code>GDT</code>表，表中的每项称为<strong>段描述符</strong>（<code>Segment descriptor</code>）。</p>
<p>每一项是一个结构体，<code>64</code>位结构，包含<code>base addr/基地址</code>、<code>limit/界限</code>以及<code>属性值</code></p>
<ul>
<li><code>limit</code>分为<code>2</code>块，<code>limit 15:00</code>和<code>limit 19:16</code></li>
<li><code>base addr</code>分为<code>3</code>块，<code>base 15:00</code>、<code>base 23:16</code>和<code>base 31:24</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121405202.png" alt="image-20240512140536089"></p>
<h3 id="2、代码细节"><a href="#2、代码细节" class="headerlink" title="2、代码细节"></a>2、代码细节</h3><ul>
<li><p><code>GDT</code>结构体的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">segment_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit15_0;</span><br><span class="line">    <span class="type">uint16_t</span> base15_0;</span><br><span class="line">    <span class="type">uint8_t</span> base23_16;</span><br><span class="line">    <span class="type">uint16_t</span> attr;</span><br><span class="line">    <span class="type">uint8_t</span> base31_24;</span><br><span class="line">&#125;<span class="type">segment_desc_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化<code>GDT</code>表项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">segment_desc_t</span> gdt_table[GDT_TABLE_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    selector：从gdt表中选择某个表项</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">segment_desc_set</span> <span class="params">(<span class="type">int</span> selector, <span class="type">uint32_t</span> base, <span class="type">uint32_t</span> limit, <span class="type">uint16_t</span> attr)</span> &#123;</span><br><span class="line">    <span class="type">segment_desc_t</span> *desc = gdt_table + selector / <span class="keyword">sizeof</span>(<span class="type">segment_desc_t</span>);</span><br><span class="line"></span><br><span class="line">    desc-&gt;limit15_0 = limit &amp; <span class="number">0xFFFF</span>;                   <span class="comment">// limit低16位</span></span><br><span class="line">    desc-&gt;base15_0 = base &amp; <span class="number">0xFFFF</span>;                     <span class="comment">// base低16位</span></span><br><span class="line">    desc-&gt;base23_16 = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;              <span class="comment">// base右移16位后取低8位</span></span><br><span class="line">    desc-&gt;attr = attr | (((limit &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xF</span>) &lt;&lt; <span class="number">8</span>);   <span class="comment">// 将limit的高4位存储到attr字段 </span></span><br><span class="line">    desc-&gt;base31_24 = (base &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;              <span class="comment">// base右移24位后取低8位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空gdt表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; GDT_TABLE_SIZE; ++i) &#123;</span><br><span class="line">        segment_desc_set(i * <span class="keyword">sizeof</span>(<span class="type">segment_desc_t</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cpu_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    init_gdt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-2-保护模式下的内存管理简介"><a href="#4-2-保护模式下的内存管理简介" class="headerlink" title="4.2 保护模式下的内存管理简介"></a>4.2 保护模式下的内存管理简介</h2><h3 id="1、理论基础-3"><a href="#1、理论基础-3" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p>参考<code>325384-sdm-vol-3abcd.pdf</code>的<code>Ch3 Protected-Mode Memory Management</code></p>
</blockquote>
<ul>
<li><p>分段存储和分页存储及其异同</p>
<ul>
<li>分页存储</li>
</ul>
<p>  将程序的逻辑地址空间划分为固定大小的页(<code>page</code>)，而物理内存划分为同样大小的页框(<code>page frame</code>)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。</p>
<ul>
<li>分段存储</li>
</ul>
<p>  在分段存储管理中，将程序的地址空间划分为若干个段(<code>segment</code>)，这样每个进程有一个二维的地址空间。每个段分配一个连续的分区，而进程中的各个段可以不连续地存放在内存的不同分区中。程序加载时，操作系统为所有段分配其所需内存，这些段不必连续。</p>
<ul>
<li><p>分页和分段的相同点</p>
<ul>
<li><p>分页机制和分段机制都是为了提高内存利用率，产生较少的内存碎片。</p>
</li>
<li><p>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是每个页和段中的内存是连续的。</p>
</li>
</ul>
</li>
<li><p>分页和分段的区别</p>
<ul>
<li><p>页的大小是固定的，由操作系统决定，而段的大小不固定，取决于我们当前运行的程序。</p>
</li>
<li><p>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，它含有一组其意义相对完整的信息，在程序中可以体现为代码段，数据段，是为了满足用户的需要。</p>
</li>
<li><p>分页的作业地址空间是维一的，即单一的线性空间，程序员只须利用一个记忆符，即可表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</p>
</li>
<li><p>段一般比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121550258.png" alt="image-20240512155014746"></p>
</li>
<li><p>下图是一种比较复杂的设计，一般不采用</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121551856.png" alt="image-20240512155154382"></p>
</li>
<li><p>为简单起见，可采用平坦模型，分为基础平坦模式和带保护的平坦模式。</p>
</li>
<li><p><strong>本项目采用基础平坦模式。</strong></p>
<ul>
<li><code>CS</code>指向代码段；剩余寄存器指向数据段；</li>
<li>两个段的起始地址均为<code>0</code>，大小为<code>4GB</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121555355.png" alt="image-20240512155513883"></p>
</li>
<li><p>从逻辑地址转换到线性地址</p>
<ul>
<li>举例，对于逻辑地址<code>0x8:0x1234</code>：<ul>
<li><code>0x8</code>对应<code>GDT</code>的表项<code>1</code>；</li>
<li><code>GDT</code>的表项<code>1</code>中基地址为<code>0x10000</code>，因此线性地址为<code>0x11234</code>。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121558156.png" alt="image-20240512155843842"></p>
</li>
<li><p>对于上文所述的<code>0x8</code>，观察选择子的结构可以得知，低<code>3</code>位用于其他用途，剩余位用于判断索引<code>index</code>。因此<code>0x8 = (b)00001000</code>，因此对应表项1。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121603986.png" alt="image-20240512160330889"></p>
</li>
</ul>
<h3 id="2、内存访问的整体流程"><a href="#2、内存访问的整体流程" class="headerlink" title="2、内存访问的整体流程"></a>2、内存访问的整体流程</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121603112.png" alt="image-20240512160353942"></p>
<h2 id="4-3-重新加载GDT表"><a href="#4-3-重新加载GDT表" class="headerlink" title="4.3 重新加载GDT表"></a>4.3 重新加载GDT表</h2><p>在<code>loader_16.c</code>中曾经自定义了一个简单的<code>GDT</code>表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GDT表（临时用，后面内容会替换成自己的）</span></span><br><span class="line"><span class="type">uint16_t</span> gdt_table[][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xFFFF</span>, <span class="number">0x0000</span>, <span class="number">0x9A00</span>, <span class="number">0x00CF</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xFFFF</span>, <span class="number">0x0000</span>, <span class="number">0x9200</span>, <span class="number">0x00CF</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>存在以下不足：</p>
<p>1）表项过小，在后期涉及到多进程以及中断管理时需要加入新的配置项；</p>
<p>2）当前这个表存储所在的内存区域为<code>loader</code>，即数据区，在后面可能会被覆盖。</p>
<p>因此，在<code>kernel</code>工程中设计了一个包含<code>256</code>个表项的新<code>GDT</code>表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_TABLE_SIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">segment_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit15_0;</span><br><span class="line">    <span class="type">uint16_t</span> base15_0;</span><br><span class="line">    <span class="type">uint8_t</span> base23_16;</span><br><span class="line">    <span class="type">uint16_t</span> attr;</span><br><span class="line">    <span class="type">uint8_t</span> base31_24;</span><br><span class="line">&#125;<span class="type">segment_desc_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、实现细节"><a href="#2、实现细节" class="headerlink" title="2、实现细节"></a>2、实现细节</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121656373.png" alt="image-20240512165607190"></p>
<p>重新加载<code>GDT</code>表后：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121657737.png" alt="image-20240512165730560"></p>
<p>对于<code>CS</code>项：</p>
<ul>
<li><code>0008</code>：选择子</li>
<li>后面的数字则是具体的表项，包括<code>limit</code>、<code>base</code>和<code>attr</code>等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121701389.png" alt="image-20240512170129300"></p>
<h2 id="4-4-触发异常与异常简介"><a href="#4-4-触发异常与异常简介" class="headerlink" title="4.4 触发异常与异常简介"></a>4.4 触发异常与异常简介</h2><h3 id="1、理论基础-4"><a href="#1、理论基础-4" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>在程序运行过程中，有可能会发生各种异常事件，CPU需要跳转到相应的程序对这些事件进行处理。</p>
<ul>
<li>异常<ul>
<li>由于CPU内部事件所引起的中断，如程序出错（非法指令、地址越界以及除0异常等）</li>
<li>通常由于执行了现行指令所引起</li>
</ul>
</li>
<li>中断<ul>
<li>由于外部设备事件所引起的中断，如通常的磁盘中断以及打印机中断等</li>
<li>通常与现行指令无关，由外部事件引起</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122031495.png" alt="image-20240512203148228"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122032412.png" alt="image-20240512203209841"></p>
<h2 id="4-5-添加中断门描述符"><a href="#4-5-添加中断门描述符" class="headerlink" title="4.5 添加中断门描述符"></a>4.5 添加中断门描述符</h2><h3 id="1、理论基础-5"><a href="#1、理论基础-5" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>进入保护模式后，中断向量表需要重新配置。</p>
<p><code>IA-32</code>中断向量表：<code>IDTR</code>寄存器指向的<code>IDT/Interrupt Descriptor Table</code>表。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122035869.png" alt="image-20240512203547782"></p>
<ul>
<li><code>IDTR</code>寄存器，由<code>Base Address</code>和<code>Limit</code>组成。<ul>
<li>基地址：保存<code>IDT</code>表的起始位置</li>
<li><code>Limit</code>：指定<code>IDT</code>表的大小</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122035976.png" alt="image-20240512203508876"></p>
<ul>
<li><p><code>IDT</code>表项的具体格式</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122039950.png" alt="image-20240512203943834"></p>
<ul>
<li><p><code>Interrupt Gate</code>：本项目主要采用该格式。</p>
<ul>
<li><p>包含选择子、偏移量以及一些其他的标志位。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122044231.png" alt="image-20240512204443158" style="zoom: 80%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IDT表项/Interrupt Gate中断门表项</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">gate_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> offset15_0;</span><br><span class="line">    <span class="type">uint16_t</span> selector;</span><br><span class="line">    <span class="type">uint16_t</span> attr;</span><br><span class="line">    <span class="type">uint16_t</span> offset31_16;</span><br><span class="line">&#125;<span class="type">gate_desc_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置IDT表项/中断门表项 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gate_desc_set</span> <span class="params">(<span class="type">gate_desc_t</span> *desc, <span class="type">uint16_t</span> selector, <span class="type">uint32_t</span> offset, <span class="type">uint16_t</span> attr)</span> &#123;</span><br><span class="line">    desc-&gt;offset15_0 = offset &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    desc-&gt;selector = selector;</span><br><span class="line">    desc-&gt;attr = attr;</span><br><span class="line">    desc-&gt;offset31_16 = (offset &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行初始化后可以看到<code>IDT</code>的值被设置为<code>idt_table</code>的首地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">irq_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空IDT表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IDT_TABLE_NR; i++) &#123;</span><br><span class="line">        gate_desc_set(idt_table + i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将IDTR寄存器指向IDT表</span></span><br><span class="line">    lidt((<span class="type">uint32_t</span>)idt_table, <span class="keyword">sizeof</span>(idt_table));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122109920.png" alt="image-20240512210927867"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122109701.png" alt="image-20240512210916635"></p>
<h2 id="4-6-捕获除0异常"><a href="#4-6-捕获除0异常" class="headerlink" title="4.6 捕获除0异常"></a>4.6 捕获除0异常</h2><h3 id="1、为所有异常配置缺省的处理程序"><a href="#1、为所有异常配置缺省的处理程序" class="headerlink" title="1、为所有异常配置缺省的处理程序"></a>1、为所有异常配置缺省的处理程序</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122113907.png" alt="image-20240512211301703"></p>
<p>设置缺省处理程序时，由于基地址为<code>0</code>，只需将处理程序的起始地址赋值给<code>offset</code>，然后将<code>IDT</code>的选择子设置为代码段的选择子即可。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122124096.png" alt="image-20240512212443637"></p>
<p>注意：中断处理程序只能用汇编来写，而不能用C语言来写！</p>
<blockquote>
<p>中断处理程序需要使用 <code>iret</code> 指令来正确地恢复被中断的程序的执行状态。<code>iret</code> 指令用于从中断处理程序返回到被中断的程序，并恢复被中断程序的执行现场，包括栈指针、标志寄存器和程序计数器等。</p>
<p>在 x86 架构中，<code>iret</code> 指令不能在 C 函数中直接使用，因为 C 函数的结尾通常是 <code>ret</code> 指令，这个指令只能用于从函数返回，而不能正确地恢复中断处理程序的执行状态。</p>
<p>因此，为了正确处理中断，特别是在中断处理程序中使用 <code>iret</code> 指令，需要使用汇编语言编写中断处理程序。只有在汇编语言中，可以直接使用 <code>iret</code> 指令来正确地返回到被中断的程序。</p>
</blockquote>
<h3 id="2、除0异常发生"><a href="#2、除0异常发生" class="headerlink" title="2、除0异常发生"></a>2、除0异常发生</h3><p>当发生除<code>0</code>异常时，首先会跳转到<code>iret</code>指令，</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122152287.png" alt="image-20240512215244219"></p>
<p>接下按<code>F11</code>单步调试，然后又会回到除<code>0</code>指令（<code>int a = 3 / 0</code>）上，</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122149517.png" alt="image-20240512214929396"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122150962.png" alt="image-20240512215020824"></p>
<p>再次处理发现仍旧无法解决，因此又会回到<code>iret</code>指令，</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122152287.png" alt="image-20240512215244219"></p>
<p>这样就会陷入死循环。因此在用户端程序遇到异常时一般需要将程序杀掉，但在操作系统中则无法处理，因此一般采用死机的处理。</p>
<p>详述“死机”的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exception_handle_unkown:</span><br><span class="line">    call do_handler_unkown</span><br><span class="line">    iret </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_default_handle</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_unkown</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    do_default_handle(<span class="string">&quot;unkown exception&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发现除<code>0</code>异常时：</p>
<p>-&gt; <code>exception_handle_unkown</code></p>
<p>-&gt; <code>do_handler_unkown</code></p>
<p>-&gt; <code>do_default_handle</code></p>
<p>-&gt; 进入死循环，即死机</p>
<h3 id="3、预先保存寄存器状态"><a href="#3、预先保存寄存器状态" class="headerlink" title="3、预先保存寄存器状态"></a>3、预先保存寄存器状态</h3><p>此外，在跳转到中断处理程序开始处理中断之前，需要先保存当前寄存器的状态，以防止后续对寄存器进行修改。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122236298.png" alt="image-20240512223603745"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">exception_handle_unkown:</span><br><span class="line">    # 寄存器压栈</span><br><span class="line">    pusha</span><br><span class="line">    push %ds</span><br><span class="line">    push %es</span><br><span class="line">    push %fs</span><br><span class="line">    push %gs</span><br><span class="line"></span><br><span class="line">    call do_handler_unkown</span><br><span class="line"></span><br><span class="line">    # 寄存器出栈</span><br><span class="line">    pop %gs</span><br><span class="line">    pop %fs</span><br><span class="line">    pop %es</span><br><span class="line">    pop %ds</span><br><span class="line">    popa</span><br><span class="line"></span><br><span class="line">    iret </span><br></pre></td></tr></table></figure>

<h2 id="4-7-解析异常栈信息"><a href="#4-7-解析异常栈信息" class="headerlink" title="4.7 解析异常栈信息"></a>4.7 解析异常栈信息</h2><h3 id="1、理论基础-6"><a href="#1、理论基础-6" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p>在发生异常而跳转到异常处理程序时，希望能够知道究竟是哪里触发了异常。此时就需要查看异常栈的相关信息。</p>
</blockquote>
<p>对于下图：当异常发生后，会将<code>EFLAGS/CS/EIP/Error Code</code>压入栈中</p>
<ul>
<li><code>EFLAGS</code>保存了状态一些相关状态</li>
<li><code>EIP</code>指示了异常发生时是哪条指令触发了异常，会将对应的地址压入<code>EIP</code>中</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131022114.png" alt="image-20240513102222754"></p>
<p>在调试控制台查看<code>esp:0x12e28</code>开始栈的相关信息，但这样做比较繁琐。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131026877.png" alt="image-20240513102619780"></p>
<p>在进入异常处理时，用<code>pusha</code>指令主动保存了一部分：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131032907.png" alt="image-20240513103220789"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131033545.png" alt="image-20240513103300450"></p>
<p>此外，通过<code>push</code>指令压入其他寄存器：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131034526.png" alt="image-20240513103415308"></p>
<p><strong>因此，这些要获取的栈中的寄存器信息则类似于向缺省处理函数传递的参数。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131036123.png" alt="image-20240513103626832"></p>
<p>但如果按上图中那样去写，会显得过于繁琐。因此可以将其封装为结构体，从而转换为压入这个结构体的地址（作为一个指针）。</p>
<p>根据上图，当前<code>ESP</code>指向<code>GS</code>寄存器，在将<code>ES</code>到<code>EFLAGS</code>包装为结构体后，将结构体的指针压入栈中，此时这个指针指向<code>GS</code>的地址；而执行压栈操作后，<code>ESP</code>指向该指针。</p>
<ul>
<li><p>即——<code>ESP-&gt;指针-&gt;GS</code></p>
</li>
<li><p>语法为：<code>push %esp</code></p>
<blockquote>
<p>在x86汇编语言中，<code>push %esp</code> 指令用于将栈指针 <code>%esp</code> 的当前值压入栈顶。</p>
<p>1）将 <code>%esp</code> 寄存器中的当前值（即栈指针指向的地址）减去 4；</p>
<p>2）将其指向的内存位置（即原栈顶）的值复制到减去 4 后的新栈顶地址中；</p>
<p>3）然后更新 <code>%esp</code> 寄存器的值，使其指向新的栈顶地址。</p>
</blockquote>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131039358.png" alt="image-20240513103940064"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exception_handle_unkown:</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    push %esp  </span><br><span class="line">    # 由于将GS到EFLAGS这个整体作为一个结构体，此时当前esp指向GS寄存器的下一位，因此在压入栈时只需要将GS的地址压入</span><br><span class="line">    call do_handler_unkown</span><br><span class="line">    add $(1*4), %esp  # 出栈</span><br><span class="line">	</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131104164.png" alt="image-20240513110407067"></p>
<p>对比下图，可以看到获取到的栈信息和<code>Segs</code>中的相关寄存器（左）相同，且<code>eip</code>寄存器保存的即为除<code>0</code>指令（右）所对应的地址。</p>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131104668.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131105155.png" width="300"/>    
</center>
## 4.8 利用宏重用异常处理代码

<h3 id="1、宏重用相关"><a href="#1、宏重用相关" class="headerlink" title="1、宏重用相关"></a>1、宏重用相关</h3><p>下表展示了22种异常&#x2F;中断的类型。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131125038.png" alt="image-20240513112516959"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131125775.png" alt="image-20240513112528641"></p>
<p>如果要对这22种异常&#x2F;中断各自编写一段汇编代码，就会使得代码过于冗杂，因为仅仅只有函数名称和内部调用C函数的区别，处理的逻辑是一致的。因此考虑采用<strong>宏重用</strong>的方式。</p>
<p>注意此处</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exception_handler_\name:</span><br><span class="line">    # 错误码入栈</span><br><span class="line">    .if \with_err_code == 0</span><br><span class="line">        push $0  # 压入0表示没有错误码</span><br><span class="line">    .endif</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    # 类型编号和错误码出栈</span><br><span class="line">    add $(2*4), %esp</span><br><span class="line"></span><br><span class="line">    iret </span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<blockquote>
<p>错误想法：对于有错误码的异常类型，会自动将错误码入栈，因此最后出栈时不需要考虑它，只需要<code>add $(1*4), %esp</code>；只有对于需要手动压入错误码的异常，才需要<code>add $(2*4), %esp</code>进行手动出栈。</p>
<p>这种想法的错误在于：<code>iret</code>指令在执行时会忽略<code>Error Code</code>，也就是说不管这个异常有没有自动入栈错误码，都需要我们手动去出栈。</p>
</blockquote>
<p>设定好宏后，测试并查看对应的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exception_handler unknown, -1, 0</span><br><span class="line">exception_handler divider, 0, 0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">exception_handler unknown, -1, 0</span><br><span class="line">   1002b:	6a 00                	push   $0x0</span><br><span class="line">   1002d:	6a ff                	push   $0xffffffff</span><br><span class="line">   1002f:	60                   	pusha  </span><br><span class="line">   10030:	1e                   	push   %ds</span><br><span class="line">   10031:	06                   	push   %es</span><br><span class="line">   10032:	0f a0                	push   %fs</span><br><span class="line">   10034:	0f a8                	push   %gs</span><br><span class="line">   10036:	54                   	push   %esp</span><br><span class="line">   10037:	e8 c4 01 00 00       	call   10200 &lt;do_handler_unknown&gt;</span><br><span class="line">   1003c:	83 c4 04             	add    $0x4,%esp</span><br><span class="line">   1003f:	0f a9                	pop    %gs</span><br><span class="line">   10041:	0f a1                	pop    %fs</span><br><span class="line">   10043:	07                   	pop    %es</span><br><span class="line">   10044:	1f                   	pop    %ds</span><br><span class="line">   10045:	61                   	popa   </span><br><span class="line">   10046:	83 c4 08             	add    $0x8,%esp</span><br><span class="line">   10049:	cf                   	iret   </span><br><span class="line">  </span><br><span class="line">0001004a &lt;exception_handler_divider&gt;:</span><br><span class="line">   1004a:	6a 00                	push   $0x0</span><br><span class="line">   1004c:	6a 00                	push   $0x0</span><br><span class="line">   1004e:	60                   	pusha  </span><br><span class="line">   1004f:	1e                   	push   %ds</span><br><span class="line">   10050:	06                   	push   %es</span><br><span class="line">   10051:	0f a0                	push   %fs</span><br><span class="line">   10053:	0f a8                	push   %gs</span><br><span class="line">   10055:	54                   	push   %esp</span><br><span class="line">   10056:	e8 bb 01 00 00       	call   10216 &lt;do_handler_divider&gt;</span><br><span class="line">   1005b:	83 c4 04             	add    $0x4,%esp</span><br><span class="line">   1005e:	0f a9                	pop    %gs</span><br><span class="line">   10060:	0f a1                	pop    %fs</span><br><span class="line">   10062:	07                   	pop    %es</span><br><span class="line">   10063:	1f                   	pop    %ds</span><br><span class="line">   10064:	61                   	popa   </span><br><span class="line">   10065:	83 c4 08             	add    $0x8,%esp</span><br><span class="line">   10068:	cf                   	iret   </span><br></pre></td></tr></table></figure>

<h3 id="2、向IDT表项中安装中断处理程序"><a href="#2、向IDT表项中安装中断处理程序" class="headerlink" title="2、向IDT表项中安装中断处理程序"></a>2、向IDT表项中安装中断处理程序</h3><p>接下来编写<strong>安装中断处理程序</strong>的函数，它接受两个参数：<code>irq_num</code> 表示中断号，<code>handler</code> 是一个指向中断处理函数的指针。</p>
<ul>
<li>函数首先检查给定的中断号是否超过了 IDT 表项的范围。如果超过了，就返回 <code>-1</code> 表示失败；</li>
<li>然后，函数调用 <code>gate_desc_set</code> 函数来设置 IDT 表中的表项。<code>gate_desc_set</code> 函数的目的是将中断处理函数与指定的中断号关联起来，并将相应的中断处理函数的地址写入到 IDT 表中。这样，当相应的中断发生时，CPU 就会根据 IDT 表中的设置跳转到相应的中断处理函数；</li>
<li>最后，函数返回 <code>0</code> 表示成功安装中断处理程序。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">irq_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空IDT表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IDT_TABLE_NR; i++) &#123;</span><br><span class="line">        gate_desc_set(</span><br><span class="line">            idt_table + i, </span><br><span class="line">            KERNEL_SELECTOR_CS,</span><br><span class="line">            (<span class="type">uint32_t</span>)exception_handler_unknown, </span><br><span class="line">            GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安装中断处理程序到 IDT（中断描述符表）中</span></span><br><span class="line">    irq_install(IRQ0_DE, (<span class="type">irq_handler_t</span>)exception_handler_divider);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将IDTR寄存器指向IDT表</span></span><br><span class="line">    lidt((<span class="type">uint32_t</span>)idt_table, <span class="keyword">sizeof</span>(idt_table));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">irq_install</span> <span class="params">(<span class="type">int</span> irq_num, <span class="type">irq_handler_t</span> handler)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断异常编号是否超过IDT表项的范围</span></span><br><span class="line">    <span class="keyword">if</span> (irq_num &gt;= IDT_TABLE_NR) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置IDT表项</span></span><br><span class="line">    gate_desc_set(idt_table + irq_num, KERNEL_SELECTOR_CS, </span><br><span class="line">                (<span class="type">uint32_t</span>)handler, GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131532647.png" alt="image-20240513153252414"></p>
<p>按照前述方式，可对其他类型的异常进行类似的处理。</p>
<h2 id="4-9-初始化中断控制器"><a href="#4-9-初始化中断控制器" class="headerlink" title="4.9 初始化中断控制器"></a>4.9 初始化中断控制器</h2><blockquote>
<p> CPU如何管理系统中的中断？</p>
</blockquote>
<p>一个<code>8259</code>芯片可以接收<code>IRQ0-IRQ7</code>共<code>8</code>个信号，当接收到相应的中断信号时，在内部进行处理，并通过<code>INT</code>信号连接到<code>CPU</code>，并向<code>CPU</code>发出中断请求。</p>
<p>由于个数限制，早期的<code>x86</code>处理器级联两片<code>8259</code>，接收共<code>15</code>个中断信号，其中一块芯片的<code>IR2</code>用于和另一块芯片连接。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131707991.png" alt="image-20240513170754592"></p>
<p>随着多核处理器的发展，<code>8259</code>被<code>APIC</code>替代。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131857119.png" alt="image-20240513185732842"></p>
<p><code>8259A</code>的内部结构图</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131859253.png" alt="image-20240513185944144"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131901488.png" alt="image-20240513190140086"></p>
<p><code>8259A</code>的初始化流程</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131902640.png" alt="image-20240513190216562"></p>
<blockquote>
<p><strong>8259的相关参考资料</strong></p>
<ul>
<li>《8259.pdf》</li>
<li><a target="_blank" rel="noopener" href="https://wiki.osdev.org/PIC">osdev关于8259的文档</a></li>
<li>《LINUX内核完全剖析:基于0.12内核》第180页</li>
</ul>
</blockquote>
<h3 id="2、实现细节-1"><a href="#2、实现细节-1" class="headerlink" title="2、实现细节"></a>2、实现细节</h3><p>初始化两个<code>8259</code>芯片。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// irq.h</span></span><br><span class="line"><span class="comment">// Interrupt Controller</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW1           0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW2           0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW3           0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW4           0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_IMR            0x21</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW1           0xA0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW2           0xA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW3           0xA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW4           0xA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_IMR            0xA1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_ICW1_ALWAYS_1   (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_ICW1_ICW4       (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_ICW4_8086       (1 &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_PIC_START       0x20</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// irq.c</span></span><br><span class="line"><span class="comment">/* Interrupt Controller Initialization */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_pic</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 对两个8259芯片进行初始化</span></span><br><span class="line">    outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);</span><br><span class="line">    outb(PIC0_ICW2, IRQ_PIC_START);</span><br><span class="line">    outb(PIC0_ICW3, <span class="number">1</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    outb(PIC0_ICW4, PIC_ICW4_8086);</span><br><span class="line"></span><br><span class="line">    outb(PIC1_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);</span><br><span class="line">    outb(PIC1_ICW2, IRQ_PIC_START + <span class="number">8</span>);</span><br><span class="line">    outb(PIC1_ICW3, <span class="number">2</span>);</span><br><span class="line">    outb(PIC1_ICW4, PIC_ICW4_8086);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断屏蔽寄存器初始化</span></span><br><span class="line">    outb(PIC0_IMR, <span class="number">0xFF</span> &amp; ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>));  <span class="comment">// 不禁止来自IRQ2的中断信号，因为其用于连接从片</span></span><br><span class="line">    outb(PIC1_IMR, <span class="number">0xFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131920596.png" alt="image-20240513192023489"></p>
<p>该寄存器的相应位为1时，会屏蔽对应的中断，使得CPU不予相应。当对芯片刚完成初始化时，还未配置相应的中断处理程序，因此需要将这个寄存器先设置为全1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断屏蔽寄存器初始化</span></span><br><span class="line">outb(PIC0_IMR, <span class="number">0xFF</span> &amp; ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>));  <span class="comment">// 不禁止来自IRQ2的中断信号，因为其用于连接从片</span></span><br><span class="line">outb(PIC1_IMR, <span class="number">0xFF</span>);</span><br></pre></td></tr></table></figure>

<h2 id="4-10-中断的打开与关闭"><a href="#4-10-中断的打开与关闭" class="headerlink" title="4.10 中断的打开与关闭"></a>4.10 中断的打开与关闭</h2><p>中断的打开与关闭受制于两个配置：</p>
<ol>
<li><code>EFLAGS</code>的<code>IF</code>标志位；</li>
<li><code>8259</code>的<code>IMR</code>寄存器。</li>
</ol>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131933225.png" width="400"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131920596.png" width="400"/>    
</center>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> mask = inb(PIC0_IMR) &amp; ~(<span class="number">1</span> &lt;&lt; irq_num);</span><br><span class="line"><span class="type">uint8_t</span> mask = inb(PIC0_IMR) | (<span class="number">1</span> &lt;&lt; irq_num);</span><br></pre></td></tr></table></figure>

<p><strong>分别做了什么操作？</strong></p>
<p>这两行代码分别对 PIC0 的中断屏蔽寄存器（PIC0_IMR）进行了修改操作：</p>
<ol>
<li><code>uint8_t mask = inb(PIC0_IMR) &amp; ~(1 &lt;&lt; irq_num);</code><ul>
<li>这行代码首先读取了 PIC0_IMR 寄存器的当前值，使用 <code>inb</code> 函数。</li>
<li>然后，它通过 <code>(1 &lt;&lt; irq_num)</code> 生成了一个只有第 <code>irq_num</code> 位为 0，其它位为 1 的屏蔽码。</li>
<li>最后，通过 <code>&amp;</code> 操作符，将读取的值与生成的屏蔽码进行按位与操作，将指定的中断号 <code>irq_num</code> 对应的位清零。</li>
<li>最终结果存储在 <code>mask</code> 变量中。</li>
</ul>
</li>
<li><code>uint8_t mask = inb(PIC0_IMR) | (1 &lt;&lt; irq_num);</code><ul>
<li>这行代码也是首先读取了 PIC0_IMR 寄存器的当前值，使用 <code>inb</code> 函数。</li>
<li>然后，它通过 <code>(1 &lt;&lt; irq_num)</code> 生成了一个只有第 <code>irq_num</code> 位为 1，其它位为 0 的屏蔽码。</li>
<li>最后，通过 <code>|</code> 操作符，将读取的值与生成的屏蔽码进行按位或操作，将指定的中断号 <code>irq_num</code> 对应的位设置为 1。</li>
<li>最终结果存储在 <code>mask</code> 变量中。</li>
</ul>
</li>
</ol>
<p>这两行代码的目的是对指定的中断号 <code>irq_num</code> 进行屏蔽或解除屏蔽操作，以控制该中断是否被响应。</p>
<h2 id="4-11-启动定时器并打开中断"><a href="#4-11-启动定时器并打开中断" class="headerlink" title="4.11 启动定时器并打开中断"></a>4.11 启动定时器并打开中断</h2><p>示例：外部中断的产生，以及如何跳转到对应的中断处理程序中。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405132011988.png" alt="image-20240513201126601"></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/06/Computer/C++/C++%20Allocator/" rel="prev" title="C++ Allocator">
      <i class="fa fa-chevron-left"></i> C++ Allocator
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%BA%90%E7%A0%81%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E6%8A%A5%E9%94%99"><span class="nav-text">一、源码测试过程报错</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F%EF%BC%9A%E6%8E%A5%E7%AE%A1%E6%8E%A7%E5%88%B6%E6%9D%83"><span class="nav-text">二、引导程序：接管控制权</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="nav-text">2.1 计算机启动流程简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E6%8E%A5%E7%AE%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%8E%A7%E5%88%B6%E6%9D%83"><span class="nav-text">2.2 接管计算机运行控制权</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%88%9B%E5%BB%BA%E5%8F%AF%E5%BC%95%E5%AF%BC%E7%9A%84%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">2.3 创建可引导的启动程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B4%E4%BD%93%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%80%BB%E8%BE%91"><span class="nav-text">1. 整体的项目逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%95%B4%E4%BD%93%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-text">2. 整体的开发工作流程：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F"><span class="nav-text">2.4 初始化引导程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F%EF%BC%9F"><span class="nav-text">1. 什么是引导程序？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%BA%E4%BA%86%E5%85%BC%E5%AE%B9%E6%97%A9%E6%9C%9F%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%8Cx86%E5%9C%A8%E4%B8%8A%E7%94%B5%E5%90%AF%E5%8A%A8%E5%90%8E%EF%BC%8C%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%A8%A1%E5%BC%8F%E3%80%82"><span class="nav-text">2. 为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-x86%E4%B8%8E%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%BB%E8%A6%81%E5%86%85%E6%A0%B8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">3. x86与编程相关的主要内核寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%EF%BC%888086%EF%BC%89"><span class="nav-text">4. 实模式下的内存映射（8086）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E4%BD%BF%E7%94%A8BIOS%E4%B8%AD%E6%96%AD%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6"><span class="nav-text">2.5 使用BIOS中断显示字符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%EF%BC%9F"><span class="nav-text">1. 如何显示字符？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-%E4%BD%BF%E7%94%A8BIOS%E4%B8%AD%E6%96%AD%E8%AF%BB%E5%8F%96%E7%A3%81%E7%9B%98"><span class="nav-text">2.6 使用BIOS中断读取磁盘</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%80%8E%E6%A0%B7%E5%AE%8C%E6%88%90%E4%BB%8EBoot%E5%8A%A0%E8%BD%BDloader%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-text">1. 怎样完成从Boot加载loader的过程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-INT-13%E7%A3%81%E7%9B%98%E8%AF%BB%E5%8F%96"><span class="nav-text">2. INT 13磁盘读取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F"><span class="nav-text">2.7 初始化引导程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90loader%E5%B9%B6%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98%E6%98%A0%E5%83%8F%EF%BC%9F"><span class="nav-text">1、如何生成loader并写入磁盘映像？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%80%8E%E6%A0%B7%E4%BB%8Eboot%E8%B7%B3%E8%BD%AC%E5%88%B0loader%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="nav-text">2、怎样从boot跳转到loader执行？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%8A%A0%E8%BD%BD%E5%99%A8loader%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">三、加载器loader的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%88%A9%E7%94%A8%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">3.1 利用内联汇编显示字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E7%90%86%E8%AE%BA"><span class="nav-text">1、内联汇编理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">2、示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E5%AE%B9%E9%87%8F"><span class="nav-text">3.2 检测内存容量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E7%90%86%E8%AE%BA"><span class="nav-text">1、内存检测方法理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%A4%BA%E4%BE%8B-1"><span class="nav-text">2、示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E5%88%87%E6%8D%A2%E8%87%B3%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="nav-text">3.3 切换至保护模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%BC%96%E7%A8%8B%E7%BB%86%E8%8A%82"><span class="nav-text">2、编程细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E4%BD%BF%E7%94%A8LBA%E8%AF%BB%E5%8F%96%E7%A3%81%E7%9B%98"><span class="nav-text">3.4 使用LBA读取磁盘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E5%88%9B%E5%BB%BA%E5%86%85%E6%A0%B8%E5%B7%A5%E7%A8%8B"><span class="nav-text">3.5 创建内核工程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E5%90%91%E5%86%85%E6%A0%B8%E4%BC%A0%E9%80%92%E5%90%AF%E5%8A%A8%E4%BF%A1%E6%81%AF"><span class="nav-text">3.6 向内核传递启动信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%8Eloader%E5%88%B0kernel%E7%9A%84%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93%EF%BC%9F"><span class="nav-text">1、如何实现从loader到kernel的信息传输？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81x86%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-text">2、x86栈的基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-text">3、实现细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-%E4%BB%A3%E7%A0%81-%E6%95%B0%E6%8D%AE%E6%AE%B5%E4%B8%8E%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC"><span class="nav-text">3.7 代码&#x2F;数据段与链接脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-text">1、链接的理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC"><span class="nav-text">2、自定义链接脚本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E6%98%A0%E5%83%8F%E6%96%87%E4%BB%B6"><span class="nav-text">3.8 加载内核映像文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-1"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-text">2、代码实现细节</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">四、中断与异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E5%88%9B%E5%BB%BAGDT%E8%A1%A8%E5%8F%8A%E5%85%B6%E8%A1%A8%E9%A1%B9"><span class="nav-text">4.1 创建GDT表及其表项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-2"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E7%BB%86%E8%8A%82"><span class="nav-text">2、代码细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AE%80%E4%BB%8B"><span class="nav-text">4.2 保护模式下的内存管理简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-3"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-text">2、内存访问的整体流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BDGDT%E8%A1%A8"><span class="nav-text">4.3 重新加载GDT表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-text">2、实现细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E8%A7%A6%E5%8F%91%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%BC%82%E5%B8%B8%E7%AE%80%E4%BB%8B"><span class="nav-text">4.4 触发异常与异常简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-4"><span class="nav-text">1、理论基础</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-text">4.5 添加中断门描述符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-5"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">2、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-%E6%8D%95%E8%8E%B7%E9%99%A40%E5%BC%82%E5%B8%B8"><span class="nav-text">4.6 捕获除0异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%B8%BA%E6%89%80%E6%9C%89%E5%BC%82%E5%B8%B8%E9%85%8D%E7%BD%AE%E7%BC%BA%E7%9C%81%E7%9A%84%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-text">1、为所有异常配置缺省的处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%99%A40%E5%BC%82%E5%B8%B8%E5%8F%91%E7%94%9F"><span class="nav-text">2、除0异常发生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E9%A2%84%E5%85%88%E4%BF%9D%E5%AD%98%E5%AF%84%E5%AD%98%E5%99%A8%E7%8A%B6%E6%80%81"><span class="nav-text">3、预先保存寄存器状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-%E8%A7%A3%E6%9E%90%E5%BC%82%E5%B8%B8%E6%A0%88%E4%BF%A1%E6%81%AF"><span class="nav-text">4.7 解析异常栈信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-6"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%8F%E9%87%8D%E7%94%A8%E7%9B%B8%E5%85%B3"><span class="nav-text">1、宏重用相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%90%91IDT%E8%A1%A8%E9%A1%B9%E4%B8%AD%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-text">2、向IDT表项中安装中断处理程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-9-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-text">4.9 初始化中断控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82-1"><span class="nav-text">2、实现细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-10-%E4%B8%AD%E6%96%AD%E7%9A%84%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="nav-text">4.10 中断的打开与关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-11-%E5%90%AF%E5%8A%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%B9%B6%E6%89%93%E5%BC%80%E4%B8%AD%E6%96%AD"><span class="nav-text">4.11 启动定时器并打开中断</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="midorii"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">midorii</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">midorii</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">151k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:08</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
