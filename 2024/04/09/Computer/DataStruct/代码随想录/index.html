<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch_cat_logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/site_cat-32%C3%9732.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/site_cat-16%C3%9716.png">
  <link rel="mask-icon" href="/images/cat_logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、数组">
<meta property="og:type" content="article">
<meta property="og:title" content="代码随想录">
<meta property="og:url" content="http://example.com/2024/04/09/Computer/DataStruct/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/index.html">
<meta property="og:site_name" content="MIDORII&#39;S JOURNEY">
<meta property="og:description" content="一、数组">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404102110076.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404120946983.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404111457295.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121316807.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131611.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131372.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131501.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131120.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131021.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404222114861.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404222114609.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242023050.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242023207.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242029774.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404252121420.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404252121802.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261554153.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261557720.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261557691.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035207.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035385.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035643.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035200.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271036601.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271036512.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271039957.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292106760.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292104737.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292105474.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292105156.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404301959840.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405071213847.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124092543662.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163554.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163709.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081211988.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302000083.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081210471.png">
<meta property="article:published_time" content="2024-04-09T12:29:30.782Z">
<meta property="article:modified_time" content="2024-05-08T12:21:25.770Z">
<meta property="article:author" content="midorii">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404102110076.png">

<link rel="canonical" href="http://example.com/2024/04/09/Computer/DataStruct/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>代码随想录 | MIDORII'S JOURNEY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MIDORII'S JOURNEY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">a little bit sweet</p>
      <a>
        <img class="custom-logo-image" src="/images/cat.jpeg" alt="MIDORII'S JOURNEY">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/09/Computer/DataStruct/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          代码随想录
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-09 20:29:30" itemprop="dateCreated datePublished" datetime="2024-04-09T20:29:30+08:00">2024-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-08 20:21:25" itemprop="dateModified" datetime="2024-05-08T20:21:25+08:00">2024-05-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/DataStruct/" itemprop="url" rel="index"><span itemprop="name">DataStruct</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>44 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><span id="more"></span>

<h2 id="1、二分法"><a href="#1、二分法" class="headerlink" title="1、二分法"></a>1、二分法</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></p>
<ol>
<li><p>本题我采用左闭右开的取法，因此：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// &amp;&amp;</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br></pre></td></tr></table></figure>

<p>当<code>nums[mid]</code>和<code>target</code>不相等需要更新<code>left/right</code>时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = mid + <span class="number">1</span>;  <span class="comment">// left是取得到的</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">right = mid;	 <span class="comment">// right是取不到的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新<code>mid</code>时采用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/submissions/521863494/">35. 搜索插入位置</a></p>
<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<p>这道题做的时候卡了很久，最开始采用前闭后开的区间，但结果是错的，改成前闭后闭的区间就正确了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">searchLeftRange</span>(nums, target);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">searchRightRange</span>(nums, target);</span><br><span class="line">        <span class="comment">// 情况一</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">-2</span> || r == <span class="number">-2</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="comment">// 情况三</span></span><br><span class="line">        <span class="keyword">if</span> (r - l &gt; <span class="number">1</span>) <span class="keyword">return</span> &#123;l + <span class="number">1</span>, r - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 情况二</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchLeftRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">-2</span>;</span><br><span class="line">        <span class="comment">// 寻找左边界</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                l = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchRightRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">-2</span>;</span><br><span class="line">        <span class="comment">// 寻找右边界</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                r = left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69. x的平方根"></a>69. x的平方根</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/">69. x的平方根</a></p>
<p>1、由于y&#x3D;√x的图像是单调递增的，符合二分查找的条件，因此本题可采用二分查找的方式解决。</p>
<p>2、题目所述x为非负整数，因此left应该初始化为1而非0。</p>
<p>3、<strong>最后结束循环，返回右边界，主要是因为平方根是向下取整，例如 8 的平方跟是 2，而循环结束的条件又是 l &gt; r，因此最后返回右边界 r</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int left = 0;</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = x;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// int tmp = mid * mid;</span></span><br><span class="line">            <span class="comment">// if (mid == x / mid) &#123;</span></span><br><span class="line">            <span class="comment">//     return mid;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">if</span> (mid &lt; x / mid) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; x / mid)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return -1;</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、双指针法"><a href="#2、双指针法" class="headerlink" title="2、双指针法"></a>2、双指针法</h2><p>双指针法：通过一个快指针和一个慢指针在一个for循环下完成两个for循环的工作</p>
<ol>
<li><p><strong>快慢指针</strong>：<strong>快慢指针通常都从下标为0的地方开始走</strong>，当快指针达到末尾时，慢指针通常还在中间位置。</p>
</li>
<li><p><strong>左右指针</strong>：<strong>左右指针分别从数组的两端出发</strong>，根据问题的要求移动指针，并通过调整指针位置来实现问题的解决。</p>
</li>
<li><p><strong>滑动窗口</strong>：常用于解决数组或字符串中的子数组或子串问题，如最小覆盖子串、最长无重复字符的子串等。滑动窗口由左右指针定义，<strong>左指针指向窗口的起始位置，右指针指向窗口的结束位置，通过移动两个指针来扩大或缩小窗口</strong>，从而找到满足特定条件的子数组或子串。</p>
<p>在采用滑动窗口解决问题时，主要确定以下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
</li>
</ol>
<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></p>
<ul>
<li><p>解题思路</p>
<p>本题要求：<em>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组</em>，看到这样的要求时，就要很快地联想到<strong>双指针法（快慢指针法）</strong>。</p>
<ol>
<li><code>fast</code>和<code>slow</code>同时指向数组开始；</li>
<li>判断是否<code>nums[fast]==val</code>，若相等，<code>fast</code>前移一位，继续判断，直到<code>nums[fast]!=val</code>；</li>
<li>此时，将<code>nums[fast]</code>赋值给<code>nums[slow]</code>，<code>slow</code>前移一位；</li>
<li>循环执行步骤<strong>2&amp;3</strong>，直到<code>fast</code>遍历到数组末尾。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[fast] == val) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">                <span class="keyword">if</span> (fast == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> slow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></p>
<ul>
<li><p>解题思路</p>
<p>由于题目中已经说了“整数数组<code>nums</code>是非递减的”，那么在包含负数的情况下，平方后最大值就只能位于数组的两端。因此可以采用<strong>双指针法</strong>，用两个指针分别指向最左边和最右边，依次向中间移动。</p>
<ol>
<li>用两个指针<code>l</code>和<code>r</code>分别指向最左边和最右边，同时定义一个新的数组作为结果数组返回；</li>
<li>判断左右两边谁平方后的值更大，将大的那个放入结果数组的最右边；</li>
<li>更新指针；</li>
<li>重复步骤2&amp;3，直到原数组遍历完毕。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> index = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> tmpl = nums[l] * nums[l];</span><br><span class="line">            <span class="type">int</span> tmpr = nums[r] * nums[r];</span><br><span class="line">            <span class="keyword">if</span> (tmpl &lt; tmpr) &#123;</span><br><span class="line">                res[index] = tmpr;</span><br><span class="line">                index--;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[index] = tmpl;</span><br><span class="line">                index--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></p>
<ul>
<li><p>解题思路</p>
<p><strong>当看到题目中出现“子数组”、“子序列”等时，一般就要想到采用滑动窗口来解决。</strong>但这里我最开始想的是下面这种解法，这样实际上就是一种暴力的思想，而非双指针的思想。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样写会超时</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="type">int</span> sum = nums[i];</span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        sum += nums[j];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = j-i+<span class="number">1</span>;</span><br><span class="line">            len = tmp &lt; len ? tmp : len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，在本题中窗口就是满足其<code>和&gt;=target</code>的长度最小的连续子数组。移动窗口的起始位置是为了在满足条件的情况下缩小窗口，移动窗口的结束位置是为了遍历数组的所有元素。</p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                <span class="type">int</span> sublen = j-i+<span class="number">1</span>;</span><br><span class="line">                len = sublen &lt; len ? sublen : len;</span><br><span class="line">                sum -= nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == INT32_MAX) len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、循环不变原则"><a href="#3、循环不变原则" class="headerlink" title="3、循环不变原则"></a>3、循环不变原则</h2><h3 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59. 螺旋矩阵II"></a>59. 螺旋矩阵II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵II</a></p>
<ul>
<li><p>解题思路</p>
<p>本题实际上就是考察了<strong>循环不变量原则</strong>，要注意选择好了遍历<strong>区间的开闭</strong>后就一定要贯彻其开闭原则。</p>
<p>将整个过程分为从外到内“画”每一圈的过程。在此基础上，每一圈又包含4步：</p>
<ol>
<li>从左至右</li>
<li>从上至下</li>
<li>从右至左</li>
<li>从下至上</li>
</ol>
<p>这样经过一圈之后，就会回到这一圈的起点，接下来遍历下一圈，直到结束为止。</p>
<p>要注意几个地方：</p>
<ol>
<li><p>每一圈的起始坐标依次为<code>(1, 1)</code>，<code>(2, 2)</code>，….，因此每一圈结束后，<code>x</code>和<code>y</code>的起始位置都要分别加1才能进入下一圈；</p>
</li>
<li><p>循环的结束条件就是遍历到了最后一圈，其中要循环的圈数是<code>n/2</code>，这个可以举几个例子推导；另外一个要注意的就是当<code>n</code>为奇数时，最内圈是一个单独的值<code>n^2</code>，需要单独填充；</p>
</li>
<li><p>在遍历每一圈的4条边时，坚持左闭右开的原则：也就是说，每一条边的最后<code>n</code>个值属于下一条边。如下图所示，这是第一圈的情况。一定要记得设置一个<code>offset</code>，<strong>因为每遍历一圈，每条边的右边界就要收缩一位。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404102110076.png" alt="image-20240410211008731" style="zoom:33%;" /></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>;     <span class="comment">// 定义每一圈的起始坐标位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>;               <span class="comment">// 定义循环几圈</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>;                 <span class="comment">// 定义每一条边遍历的长度 </span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;                  <span class="comment">// 用来给矩阵赋值</span></span><br><span class="line">        <span class="keyword">while</span> (loop--) &#123;</span><br><span class="line">            <span class="type">int</span> i = startx;</span><br><span class="line">            <span class="type">int</span> j = starty;</span><br><span class="line">            <span class="comment">// 从左至右</span></span><br><span class="line">            <span class="keyword">for</span> (j; j&lt;n-offset; ++j) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="comment">// 从上至下</span></span><br><span class="line">            <span class="keyword">for</span> (i; i&lt;n-offset; ++i) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从右至左</span></span><br><span class="line">            <span class="keyword">for</span> (j; j&gt;starty; --j) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从下至上</span></span><br><span class="line">            <span class="keyword">for</span> (i; i&gt;startx; --i) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset++;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            res[n/<span class="number">2</span>][n/<span class="number">2</span>] = n*n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h1><p>实际上感觉链表的题都可以用快慢指针来解决。</p>
<h2 id="1、链表的定义"><a href="#1、链表的定义" class="headerlink" title="1、链表的定义"></a>1、链表的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	ListNode *next;</span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、删除链表元素"><a href="#2、删除链表元素" class="headerlink" title="2、删除链表元素"></a>2、删除链表元素</h2><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><p>举例来说，从<code>2-&gt;6-&gt;3</code>中删除节点6，需要完成以下几步：</p>
<p>（1）保存节点6，便于后续释放；</p>
<p>（2）将2的next改完3；</p>
<p>（3）释放原节点6。</p>
</li>
<li><p>注意要引入一个虚拟头结点，这样就可以避免在操作时还要区分头节点和非头节点两种情况。并且注意在最后返回真正的头节点时，返回的是<code>dummyhead-&gt;next</code>。</p>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *dummynode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummynode-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode *cur = dummynode;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode *tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummynode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummynode;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a>707. 设计链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></p>
<ul>
<li><p>解题思路</p>
<p>这里有一个要注意的点，那就是对于这个<code>index</code>，在访问操作和增删操作时，遍历停止的位置是不同的：</p>
<ol>
<li>对于访问操作，需要<code>cur</code>正好停在<strong>下标为<code>index</code>的节点</strong>上，这样才能正确取到值；</li>
<li>对于增删操作，需要<code>cur</code>停在<strong>下标为<code>index</code>的前一个节点</strong>上，这样才方便进行增删操作。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (index-- &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        tmp-&gt;next = _dummyhead-&gt;next;</span><br><span class="line">        _dummyhead-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListNode *_dummyhead;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="19-删除链表的倒数第N个结点"><a href="#19-删除链表的倒数第N个结点" class="headerlink" title="19. 删除链表的倒数第N个结点"></a>19. 删除链表的倒数第N个结点</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第N个结点</a></p>
<ul>
<li><p>解题思路</p>
<p>本题我采用了两趟扫描的方式进行解答。第一趟扫描确定了链表的长度，第二趟扫描则定位到了<strong>要删除结点的前一个结点</strong>。</p>
<ol>
<li><p>由于涉及到对头节点<code>head</code>的操作，因此定义一个<code>dummyhead</code>，避免需要对头结点单独操作；</p>
</li>
<li><p>如何定位到要删除结点的前一个结点，实际上需要分析<code>n</code>和<code>sz</code>之间的关系，如下图所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404120946983.png" alt="image-20240412094658218" style="zoom: 33%;" /></li>
</ol>
<blockquote>
<p>然而这道题我看了代码随想录提供的题解，实际上也是快慢指针法的一种变体，并且使用快慢指针法就可以无需先遍历一遍链表来求出链表的总长度。</p>
<p>只需要定义<code>fast</code>和<code>slow</code>两个指针</p>
<ul>
<li><code>fast</code>先走<code>n+1</code>步。之后<code>fast</code>和<code>slow</code>同时向前走；</li>
<li>当<code>fast</code>指向<code>nullptr</code>时，<code>slow</code>就正好指向要删除结点的前一个结点。</li>
</ul>
</blockquote>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *cur1 = head;</span><br><span class="line">        <span class="type">int</span> sz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            sz++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line">        ListNode *cur = dummyhead;</span><br><span class="line">        <span class="type">int</span> m = sz-n;</span><br><span class="line">        <span class="keyword">while</span> (m &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        head = dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyhead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、反转链表"><a href="#3、反转链表" class="headerlink" title="3、反转链表"></a>3、反转链表</h2><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><p>这道题实际上也相当于是双指针法中的快慢指针，通过定义两个指针<code>pre</code>和<code>cur</code>来依次遍历链表中的所有元素，并在遍历的过程中修改指针的指向。</p>
</li>
<li><p>有一个要注意的点在于：<code>while</code>循环的终止条件是<code>cur != nullptr</code>，若采用<code>cur-&gt;next != nullptr</code>，则最后一个节点不会被遍历到。</p>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p>
<ul>
<li><p>解题思路</p>
<p>实际上这道题只要能够画图模拟出交换的过程，就没有问题了。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404111457295.png" alt="image-20240411145728810"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode *cur = dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode *tmp1 = cur-&gt;next;</span><br><span class="line">            ListNode *tmp2 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next = tmp1;</span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = tmp2;</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next;  <span class="comment">// cur要往后跳两步</span></span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyhead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、链表相交"><a href="#4、链表相交" class="headerlink" title="4、链表相交"></a>4、链表相交</h2><h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></p>
<ul>
<li><p>解题思路</p>
<p>主要有以下几个点要注意：</p>
<ol>
<li><p>最开始我额外定义了<code>a</code>和<code>b</code>用于去遍历两个链表来长度，实际上可以直接定义<code>curA</code>和<code>curB</code>，在遍历结束上让其重新指向头结点即可；</p>
</li>
<li><p>该题交点不是数值相等，而是指针相等！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curA-&gt;val == curB-&gt;val)  <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">if</span> (curA == curB)			 <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size_a = <span class="number">0</span>, size_b = <span class="number">0</span>;</span><br><span class="line">        ListNode *curA = headA;</span><br><span class="line">        ListNode *curB = headB;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            size_a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">            size_b++;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">abs</span>(size_a - size_b);</span><br><span class="line">        <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// if (curA-&gt;val == curB-&gt;val) &#123;</span></span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></p>
<ul>
<li><p>解题思路</p>
<p>定义快慢指针<code>fast</code>和<code>slow</code>，其中<code>fast</code>每次走两个结点，<code>slow</code>每次走一个结点。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121316807.png" alt="image-20240412131623148"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *index1 = fast;</span><br><span class="line">                ListNode *index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三、哈希表"><a href="#三、哈希表" class="headerlink" title="三、哈希表"></a>三、哈希表</h1><h2 id="1、理论基础"><a href="#1、理论基础" class="headerlink" title="1、理论基础"></a>1、理论基础</h2><p>哈希表即为散列表，一般用于判断一个元素是否出现在集合里。</p>
<p>（1）常见的三种哈希函数：</p>
<ul>
<li><p>数组</p>
</li>
<li><p>集合（<code>set</code>）</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<ul>
<li><code>std::unordered_set</code>底层实现为哈希表；</li>
<li><code>std::set</code>和<code>std::multiset</code>的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以<code>key</code>值是有序的，但<code>key</code>不可以修改，改动<code>key</code>值会导致整棵树的错乱，所以只能删除和增加。</li>
</ul>
</li>
<li><p>映射（<code>map</code>）</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<ul>
<li><code>std::unordered_map</code>底层实现为哈希表；</li>
<li><code>std::map</code>和<code>std::multimap</code>的底层实现是红黑树。同理，<code>std::map</code>和<code>std::multimap</code>的<code>key</code>也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</li>
</ul>
</li>
</ul>
<p>（2）<code>std::unordered_set</code>提供了一系列方法来管理集合中的元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">插入元素：</span><br><span class="line">    <span class="built_in">insert</span>(): 向集合中插入元素。</span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">    <span class="built_in">erase</span>(): 删除集合中的元素。</span><br><span class="line">    <span class="built_in">clear</span>(): 清空集合中的所有元素。</span><br><span class="line"></span><br><span class="line">查找元素：</span><br><span class="line">    <span class="built_in">find</span>(): 查找集合中是否存在指定元素。</span><br><span class="line">    <span class="built_in">count</span>(): 统计集合中指定元素的个数。</span><br><span class="line"></span><br><span class="line">迭代器：</span><br><span class="line">    <span class="built_in">begin</span>(): 返回指向集合起始元素的迭代器。</span><br><span class="line">    <span class="built_in">end</span>(): 返回指向集合末尾元素的迭代器。</span><br><span class="line"></span><br><span class="line">大小和容量：</span><br><span class="line">    <span class="built_in">size</span>(): 返回集合中元素的个数。</span><br><span class="line">    <span class="built_in">empty</span>(): 检查集合是否为空。</span><br><span class="line"></span><br><span class="line">其他操作：</span><br><span class="line">    <span class="built_in">bucket_count</span>(): 返回集合中桶的数量。</span><br><span class="line">    <span class="built_in">load_factor</span>(): 返回集合的负载因子。</span><br><span class="line">    <span class="built_in">max_load_factor</span>(): 设置或返回集合的最大负载因子。</span><br></pre></td></tr></table></figure>

<p>（3）<code>std::set</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">插入元素：</span><br><span class="line">    <span class="built_in">insert</span>(): 向集合中插入元素。</span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">    <span class="built_in">erase</span>(): 删除集合中的元素。</span><br><span class="line">    <span class="built_in">clear</span>(): 清空集合中的所有元素。</span><br><span class="line"></span><br><span class="line">查找元素：</span><br><span class="line">    <span class="built_in">find</span>(): 查找集合中是否存在指定元素。</span><br><span class="line">    <span class="built_in">count</span>(): 统计集合中指定元素的个数。</span><br><span class="line"></span><br><span class="line">迭代器：</span><br><span class="line">    <span class="built_in">begin</span>(): 返回指向集合起始元素的迭代器。</span><br><span class="line">    <span class="built_in">end</span>(): 返回指向集合末尾元素的迭代器。</span><br><span class="line"></span><br><span class="line">大小和容量：</span><br><span class="line">    <span class="built_in">size</span>(): 返回集合中元素的个数。</span><br><span class="line">    <span class="built_in">empty</span>(): 检查集合是否为空。</span><br><span class="line"></span><br><span class="line">其他操作：</span><br><span class="line">    <span class="built_in">lower_bound</span>(): 返回指向大于或等于给定值的第一个元素的迭代器。</span><br><span class="line">    <span class="built_in">upper_bound</span>(): 返回指向大于给定值的第一个元素的迭代器。</span><br><span class="line">    <span class="built_in">equal_range</span>(): 返回集合中与给定值相等的元素范围。</span><br></pre></td></tr></table></figure>

<p>（3）<code>std::map</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">相关操作：</span><br><span class="line">    <span class="built_in">insert</span>()：用于将元素插入到map中。</span><br><span class="line">    <span class="built_in">erase</span>()：用于从map中删除指定的元素。</span><br><span class="line">    <span class="built_in">find</span>()：用于查找指定键对应的元素。</span><br><span class="line">    <span class="built_in">size</span>()：返回map中元素的数量。</span><br><span class="line">    <span class="built_in">clear</span>()：清空map中的所有元素。</span><br><span class="line">    <span class="built_in">begin</span>()：返回指向map起始元素的迭代器。</span><br><span class="line">    <span class="built_in">end</span>()：返回指向map末尾元素的迭代器。</span><br><span class="line">    <span class="built_in">count</span>()：返回指定键在map中出现的次数。</span><br></pre></td></tr></table></figure>

<h2 id="2、数组、set和map该如何选择？"><a href="#2、数组、set和map该如何选择？" class="headerlink" title="2、数组、set和map该如何选择？"></a>2、数组、set和map该如何选择？</h2><h3 id="什么时候选择用哈希表？"><a href="#什么时候选择用哈希表？" class="headerlink" title="什么时候选择用哈希表？"></a>什么时候选择用哈希表？</h3><p>当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候。</p>
<h3 id="什么时候选择用数组？"><a href="#什么时候选择用数组？" class="headerlink" title="什么时候选择用数组？"></a>什么时候选择用数组？</h3><p>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</p>
<p>如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费，此时不应使用数组。</p>
<h3 id="什么时候选择用set？"><a href="#什么时候选择用set？" class="headerlink" title="什么时候选择用set？"></a>什么时候选择用set？</h3><h3 id="什么时候选择用map？"><a href="#什么时候选择用map？" class="headerlink" title="什么时候选择用map？"></a>什么时候选择用map？</h3><h2 id="3、采用数组作为哈希函数"><a href="#3、采用数组作为哈希函数" class="headerlink" title="3、采用数组作为哈希函数"></a>3、采用数组作为哈希函数</h2><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></p>
<ul>
<li><p>解题思路</p>
<p>由于“字母异位词”的定义是：两个词中每个字符出现的数组相同，而本题假设词中仅包含小写字母。因此直观的想法就是定义一个数组，先遍历<code>s</code>，将每个字符在数组中对应的位置加1，再遍历<code>t</code>，将每个字符在数组中对应的位置减1，这样若最终数组为全0，则这两个词是字母异位词。</p>
<p>但我陷入的思维瓶颈在于，我想的是按照<code>s</code>中每个字符出现的顺序定义数组<code>a</code>，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s = &quot;anagram&quot;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">// 其中下标1代表字符a</span></span><br></pre></td></tr></table></figure>

<p>但这样实际上就相当于是一个<code>map</code>了，操作变得格外复杂。</p>
<p>实际上，由于小写字母是有顺序的26个，因此只需要定义一个<code>int a[26]</code>，对于<code>s</code>中遍历到的每个字符，通过<code>s[i] - &#39;a&#39;</code>就可以定位到对应的下标。</p>
</li>
<li><p>易混知识点：</p>
<ol>
<li><p><code>a - &#39;a&#39;</code>:</p>
<ul>
<li><strong>用于将字母字符转换成一个从0开始的索引</strong>（例如，’a’变成0, ‘b’变成1, 等等）。</li>
</ul>
<ul>
<li>这里 <code>&#39;a&#39;</code> 是一个字符，其ASCII值是 97。</li>
<li>所以 <code>a - &#39;a&#39;</code> 实际上是计算 <code>97 - 97</code>，结果是 0。</li>
</ul>
</li>
<li><p><code>&#39;1&#39; - &#39;0&#39;</code> </p>
<ul>
<li><strong>计算两个字符的ASCII值之差，用于将字符表示的数字转换成其对应的整数值。</strong></li>
</ul>
<ul>
<li><code>&#39;1&#39;</code> 的 ASCII 值是 49，<code>&#39;0&#39;</code>是 48。所以，<code>&#39;1&#39;-&#39;0&#39;</code> 的计算过程是 <code>49-48</code>，结果是 1。</li>
</ul>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;t.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            record[t[j] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m=<span class="number">0</span>; m&lt;<span class="number">26</span>; ++m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[m] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></p>
<ul>
<li><p>解题思路</p>
<p>和242完全一致。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131611.png" alt="image-20240420113156470"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;magazine.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            record[magazine[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ransomNote.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            record[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m=<span class="number">0</span>; m&lt;<span class="number">26</span>; ++m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[m] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、采用set解题"><a href="#4、采用set解题" class="headerlink" title="4、采用set解题"></a>4、采用set解题</h2><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></p>
<ul>
<li><p>解题思路</p>
<p>由于本题的哈希值较少、较分散且跨度非常大，因此不能采用数组来实现。由于最终的结果无需排序，无重复，且只需要返回元素本身，不需要返回对应的下标，因此采用set即可。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131372.png" alt="image-20240420113120142"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; nums_set;</span><br><span class="line">        nums_set.<span class="built_in">insert</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> nums : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums_set.<span class="built_in">find</span>(nums) != nums_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></p>
<ul>
<li><p>解题思路</p>
<p>可以发现</p>
<ul>
<li>1）哈希值较分散，且跨度较大（不采用数组，应采用set或map）；</li>
<li>2）不需要同时保存元素和下标等成对出现，有对应关系的元素（不采用map）；</li>
<li>3）就是要找是否有重复的元素出现，因此采用set实现。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131501.png" alt="image-20240420113130345"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            sum += (n%<span class="number">10</span>) * (n%<span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; compare_set = &#123;n&#125;;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">        <span class="keyword">while</span> (sum != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compare_set.<span class="built_in">find</span>(sum) != compare_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// sum = getSum(sum);</span></span><br><span class="line">                compare_set.<span class="built_in">insert</span>(sum);</span><br><span class="line">                sum = <span class="built_in">getSum</span>(sum);  <span class="comment">// 这里一定要先把上一步计算得到的sum加入compare_set后，再计算新的sum</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、采用map解题"><a href="#5、采用map解题" class="headerlink" title="5、采用map解题"></a>5、采用map解题</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p>
<ul>
<li><p>解题思路</p>
<p>本题不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，<strong>需要使用key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p>
<p><strong>这道题目中并不需要key有序，选择std::unordered_map 效率更高</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131120.png" alt="image-20240420113138973"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; compare_map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = compare_map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (iter != compare_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second, i&#125;;           </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// compare_map.insert(nums[i], i);</span></span><br><span class="line">                compare_map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(nums[i], i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454. 四数相加II"></a>454. 四数相加II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加II</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131021.png" alt="image-20240420113148798"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; res1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num1 : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num2 : nums2) &#123;</span><br><span class="line">                <span class="type">int</span> sum = num1 + num2;</span><br><span class="line">                res1[sum]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num3 : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num4 : nums4) &#123;</span><br><span class="line">                <span class="type">int</span> sum = num3 + num4;</span><br><span class="line">                cnt += res1[-sum];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h1><h2 id="1、反转字符串"><a href="#1、反转字符串" class="headerlink" title="1、反转字符串"></a>1、反转字符串</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h3><ul>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> il = s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">auto</span> ir = s.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (il &lt;= ir) &#123;</span><br><span class="line">            <span class="comment">// char tmp;</span></span><br><span class="line">            <span class="comment">// tmp = *il;</span></span><br><span class="line">            <span class="comment">// *il = *ir;</span></span><br><span class="line">            <span class="comment">// *ir = tmp;</span></span><br><span class="line">            <span class="built_in">swap</span>(*il, *ir)</span><br><span class="line">            il++;</span><br><span class="line">            ir--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404222114861.png" alt="image-20240422211359195"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i+=<span class="number">2</span>*k) &#123;</span><br><span class="line">            <span class="type">int</span> start = i;</span><br><span class="line">            <span class="type">int</span> end = std::<span class="built_in">min</span>(start+k, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>()));</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+start, s.<span class="built_in">begin</span>()+end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a>151. 反转字符串中的单词</h3><ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404222114609.png" alt="image-20240422211419481"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string &amp;s, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=begin, j=end; i&lt;=j; ++i, --j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeSpace</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slow) &#123;</span><br><span class="line">                    s[slow++] = <span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">                    <span class="comment">// 当slow不在开头时，如果此时遇到了s[i]不为空格，则说明接下来需要从slow开始写新的单词了</span></span><br><span class="line">                    <span class="comment">// 因此手动控制添加一个空格</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow);  <span class="comment">// important</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeSpace</span>(s);</span><br><span class="line">        <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// for (int i=0; i&lt;s.size(); ++i) &#123;</span></span><br><span class="line">            <span class="comment">// if (s[i] == &#x27; &#x27;) &#123;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() || s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s, start, i<span class="number">-1</span>);  <span class="comment">// 翻转当前单词</span></span><br><span class="line">                <span class="comment">// start = i;</span></span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2、KMP算法"><a href="#2、KMP算法" class="headerlink" title="2、KMP算法"></a>2、KMP算法</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242023050.png" alt="image-20240424202306816"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> *next, <span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// i -&gt; 待匹配的后缀的末尾</span></span><br><span class="line">   <span class="comment">// j -&gt; 待匹配的前缀的末尾</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1. 初始化</span></span><br><span class="line">   <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">   next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">       <span class="comment">// 2. 处理前后缀不相同的情况</span></span><br><span class="line">       <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">           j = next[j<span class="number">-1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 3. 处理前后缀不相同的情况</span></span><br><span class="line">       <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">           j++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4. 更新next数组</span></span><br><span class="line">       next[i] = j;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 实现 strStr()</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li>求解字符串<code>s</code>的<code>next</code>数组；</li>
<li>定义<code>i</code>和<code>j</code>分别用来遍历<code>haystack</code>和<code>needle</code>，根据<code>next</code>数组调整对比的位置；</li>
<li>当<code>j</code>等于<code>needle</code>字符串的长度时，说明此时在<code>haystack</code>中找到了对应的匹配子串，因此返回该子串的开始下标。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line">        <span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;haystack.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> (i-needle.<span class="built_in">size</span>()+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a>459. 重复的子字符串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242023207.png" alt="image-20240424202348060"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> *next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; s[i]!=s[j]) &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(s.size())</span></span>;</span><br><span class="line">        <span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], s);</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(next[len<span class="number">-1</span>]!=<span class="number">0</span> &amp;&amp; (len%(len-next[len<span class="number">-1</span>])==<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="五、栈和队列"><a href="#五、栈和队列" class="headerlink" title="五、栈和队列"></a>五、栈和队列</h1><h2 id="1、栈和队列的理论基础"><a href="#1、栈和队列的理论基础" class="headerlink" title="1、栈和队列的理论基础"></a>1、栈和队列的理论基础</h2><ol>
<li><p>C++中stack 是容器么？</p>
<p>STL中stack往往不被归类为容器，而被归类为容器适配器（container adapter）。因为<strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p>
</li>
<li><p>我们使用的stack是属于哪个版本的STL？</p>
<p>SGI STL。</p>
</li>
<li><p>我们使用的STL中stack是如何实现的？</p>
<p>栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。<strong>常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。</strong></p>
<p>此外，<strong>SGI STL中队列一样是以deque为缺省情况下的底部结构。</strong></p>
<p>可以指定vector为栈的底层实现，初始化语句如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br></pre></td></tr></table></figure>

<p>也可以指定list 为起底层实现，初始化queue的语句如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242029774.png" alt="栈与队列理论3" style="zoom:50%;" />
</li>
<li><p>stack 提供迭代器来遍历stack空间么？</p>
<p>不提供。</p>
</li>
</ol>
<blockquote>
<p>三个最为普遍的STL版本：</p>
<ol>
<li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li>
<li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li>
<li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li>
</ol>
</blockquote>
<h2 id="2、栈的基本操作"><a href="#2、栈的基本操作" class="headerlink" title="2、栈的基本操作"></a>2、栈的基本操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">empty</span>();		<span class="comment">// 栈为空时返回1，非空返回0</span></span><br><span class="line">st.<span class="built_in">size</span>();		<span class="comment">// 返回栈中元素数量，size_type size() const;</span></span><br><span class="line">st.<span class="built_in">top</span>();		<span class="comment">// 返回栈顶元素，value_type&amp; top();</span></span><br><span class="line">st.<span class="built_in">push</span>(value);	<span class="comment">// 在栈顶插入一个元素，void push( const value_tyoe&amp; val );</span></span><br><span class="line">st.<span class="built_in">emplace</span>(value);	<span class="comment">// 在栈顶增加一个元素，void emplace( args&amp;&amp; args );</span></span><br><span class="line">st.<span class="built_in">pop</span>();			<span class="comment">// 栈顶元素出栈，即删除栈顶元素，void pop(); </span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st2;</span><br><span class="line">st1.<span class="built_in">swap</span>( st2 );	<span class="comment">// 交换两个栈中的内容，void swap( stack&amp; x );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与vector一样，重载了运算符：== != &lt; &lt;= &gt; &gt;=</span></span><br></pre></td></tr></table></figure>

<h2 id="3、队列的基本操作"><a href="#3、队列的基本操作" class="headerlink" title="3、队列的基本操作"></a>3、队列的基本操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">queue&lt;<span class="type">double</span>&gt; d;</span><br><span class="line">queue&lt;node&gt; n;  <span class="comment">// node是一个结构体</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">size</span>();	<span class="comment">// 返回q里元素个数</span></span><br><span class="line">q.<span class="built_in">empty</span>();	<span class="comment">// 返回q是否为空，空则返回1，否则返回0</span></span><br><span class="line">q.<span class="built_in">push</span>(k);	<span class="comment">// 在q的末尾插入k</span></span><br><span class="line">q.<span class="built_in">pop</span>();	<span class="comment">// 删掉q的第一个元素</span></span><br><span class="line">q.<span class="built_in">front</span>();	<span class="comment">// 返回q的第一个元素</span></span><br><span class="line">q.<span class="built_in">back</span>();	<span class="comment">// 返回q的末尾元素</span></span><br></pre></td></tr></table></figure>

<h2 id="4、对称匹配问题"><a href="#4、对称匹配问题" class="headerlink" title="4、对称匹配问题"></a>4、对称匹配问题</h2><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404252121420.png" alt="image-20240425212136199"></p>
<p>这里有两个要注意的地方：</p>
<ol>
<li><p>在遍历到左括号时，可以直接向栈中放入对应的右括号，这样遍历到右括号时可以直接比较是否相等；</p>
</li>
<li><p>注意在遍历到右括号时需要先判断此时栈是否为空。</p>
<p>对于<code>s = &quot;)&#123;&quot;</code>的情况，由于遍历到左括号时才会入栈，遍历到右括号时只执行比较操作，因此此时<code>st</code>为空，若直接执行<code>st.top()</code>会造成错误！</p>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">&#x27;)&#x27;</span> || i == <span class="string">&#x27;]&#x27;</span> || i == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == i) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404252121802.png" alt="image-20240425212128346"></p>
<p>注意输出的时候要进行一个reverse操作，因为栈是先进先出，和需要的结果次序是相反的。</p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == i) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res += st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261554153.png" alt="image-20240426155453665"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isDigit</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> token : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isDigit</span>(token)) &#123;</span><br><span class="line">                    <span class="comment">// 操作符</span></span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> tmp1 = res.<span class="built_in">top</span>();</span><br><span class="line">                    res.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> tmp2 = res.<span class="built_in">top</span>();</span><br><span class="line">                    res.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 + tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 - tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 * tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 / tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res.<span class="built_in">push</span>(tmp);   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push</span>(<span class="built_in">stoi</span>(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、队列解决相关问题"><a href="#5、队列解决相关问题" class="headerlink" title="5、队列解决相关问题"></a>5、队列解决相关问题</h2><blockquote>
<p>可用于以下题目：</p>
<ol>
<li>单调队列解决“<strong>区间内的最大值</strong>”问题；</li>
<li>优先级队列解决“<strong>统计元素出现频率</strong>”问题</li>
</ol>
</blockquote>
<h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261557720.png" alt="image-20240426155748508"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            <span class="comment">// 如果val == que.front()</span></span><br><span class="line">            <span class="comment">// 说明队列要pop()的元素为此时滑动窗口的最大值，需要执行实际的pop()操作</span></span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          que.<span class="built_in">push_back</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getMaxValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">      MyQueue que;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">      <span class="comment">// 先将前k个元素放进单调队列</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; ++i) &#123;</span><br><span class="line">        que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// res先记录这前k个元素的最大值</span></span><br><span class="line">      res.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=k; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        que.<span class="built_in">pop</span>(nums[i-k]);</span><br><span class="line">        que.<span class="built_in">push</span>((nums[i]));</span><br><span class="line">        res.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">347.前 K 个高频元素</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261557691.png" alt="image-20240426155759481"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// step1</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            map[num]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step2</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pri_que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it=map.<span class="built_in">begin</span>(); it!=map.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            pri_que.<span class="built_in">push</span>(*it);</span><br><span class="line">            <span class="comment">// step3</span></span><br><span class="line">            <span class="keyword">if</span> (pri_que.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                pri_que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step4</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=k<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">            res[i] = pri_que.<span class="built_in">top</span>().first;</span><br><span class="line">            pri_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="六、二叉树"><a href="#六、二叉树" class="headerlink" title="六、二叉树"></a>六、二叉树</h1><h2 id="1、理论基础-1"><a href="#1、理论基础-1" class="headerlink" title="1、理论基础"></a>1、理论基础</h2><h3 id="（1）分类"><a href="#（1）分类" class="headerlink" title="（1）分类"></a>（1）分类</h3><blockquote>
<p>度：二叉树中某个结点的子结点或直接后继结点的个数。叶子节点的度为0。</p>
</blockquote>
<ul>
<li><p>满二叉树：一课二叉树上只有度为0的结点和度为2的结点，且度为0的结点在同一层上，则为满二叉树。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035207.png" alt="img"></p>
</li>
<li><p>完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035385.png" alt="img"></p>
</li>
<li><p>二叉搜索树：有序树。1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；3）左、右子树也分别为二叉排序树。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035643.png" alt="img"></p>
</li>
<li><p>平衡二叉搜索树：又称AVL（Adelson-Velsky and Landis）树。它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035200.png" alt="img"></p>
</li>
</ul>
<h3 id="（2）存储方式"><a href="#（2）存储方式" class="headerlink" title="（2）存储方式"></a>（2）存储方式</h3><ul>
<li><p>链式存储：指针。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271036601.png" alt="img"></p>
</li>
<li><p>顺序存储：数组。此时若父结点下标为<code>i</code>，则左孩子下标为<code>i*2+1</code>，右孩子下标为<code>i*2+2</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271036512.png" alt="img"></p>
</li>
</ul>
<h3 id="（3）遍历方式"><a href="#（3）遍历方式" class="headerlink" title="（3）遍历方式"></a>（3）遍历方式</h3><ul>
<li><p>深度优先遍历</p>
<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271039957.png" alt="img"></p>
</li>
<li><p>广度优先遍历</p>
<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ul>
<p>栈其实就是递归的一种实现结构，<strong>深度优先遍历可以借助栈来使用递归的方式实现。而广度优先遍历一般使用队列来实现</strong>。</p>
<h3 id="（4）定义方式"><a href="#（4）定义方式" class="headerlink" title="（4）定义方式"></a>（4）定义方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	TreeNode *left;</span><br><span class="line">	TreeNode *right;</span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、深度优先遍历"><a href="#2、深度优先遍历" class="headerlink" title="2、深度优先遍历"></a>2、深度优先遍历</h2><p>递归三要素：</p>
<ul>
<li>确定递归函数的参数和返回值：如果在递归过程中需要处理某些参数，就在递归函数中加上这个参数；</li>
<li>确定终止条件</li>
<li>确定单层递归的逻辑</li>
</ul>
<h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h3><ul>
<li><p>AC代码（递归遍历）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, v);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">traversal</span>(root, v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代遍历的思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292106760.png" alt="image-20240429210650617"></p>
</li>
<li><p>AC代码（迭代遍历）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> v; &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *node = st.<span class="built_in">top</span>();                  <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            v.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) &#123; st.<span class="built_in">push</span>(node-&gt;right); &#125;  <span class="comment">// 右（入栈时先入右，出栈时才能先出左）</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) &#123; st.<span class="built_in">push</span>(node-&gt;left); &#125;    <span class="comment">// 左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h3><ul>
<li><p>AC代码（递归遍历）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, v);</span><br><span class="line">        v.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">traversal</span>(root, v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AC代码（迭代遍历）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历到最左侧的左孩子</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;        <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将左孩子加入完毕，开始从栈中弹出元素</span></span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                v.<span class="built_in">push_back</span>(cur-&gt;val);  <span class="comment">// 中</span></span><br><span class="line">                cur = cur-&gt;right;       <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h3><ul>
<li><p>AC代码（递归遍历）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;int&gt; v;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        while (cur != nullptr || !st.empty()) &#123;</span><br><span class="line">            if (cur != nullptr) &#123;</span><br><span class="line">                // 遍历到最左侧的左孩子</span><br><span class="line">                st.push(cur);</span><br><span class="line">                cur = cur-&gt;left;        // 左</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 将左孩子加入完毕，开始从栈中弹出元素</span><br><span class="line">                cur = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                v.push_back(cur-&gt;val);  // 中</span><br><span class="line">                cur = cur-&gt;right;       // 右</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AC代码（迭代遍历）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> v; &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            v.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123; st.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123; st.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、广度优先遍历"><a href="#3、广度优先遍历" class="headerlink" title="3、广度优先遍历"></a>3、广度优先遍历</h2><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292104737.png" alt="image-20240429210415502"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                v.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292105474.png" alt="image-20240429210504161"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                v.<span class="built_in">push_back</span>(node-&gt;val);  <span class="comment">// 方法1</span></span><br><span class="line">                <span class="comment">// if (i == (size - 1)) result.push_back(node-&gt;val);  // 方法2</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(*(v.<span class="built_in">end</span>()<span class="number">-1</span>));  <span class="comment">// 方法1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429. N叉树的层序遍历"></a>429. N叉树的层序遍历</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N叉树的层序遍历</a></p>
<ul>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Node* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;children.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 将节点孩子加入队列</span></span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;children[i]) que.<span class="built_in">push</span>(node-&gt;children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292105156.png" alt="image-20240429210553988"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node *node;</span><br><span class="line">            Node *nodePre;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    nodePre = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    node = nodePre;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    nodePre-&gt;next = node;  <span class="comment">// 本层前一个节点(nodePre)的next指向本节点(node)</span></span><br><span class="line">                    nodePre = nodePre-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nodePre-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 本层最后一个节点指向NULL</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、二叉树的属性"><a href="#4、二叉树的属性" class="headerlink" title="4、二叉树的属性"></a>4、二叉树的属性</h2><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404301959840.png" alt="image-20240430195926626"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode *left, TreeNode *right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);</span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> outside &amp;&amp; inside;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p>
<ul>
<li><p>解题思路</p>
<blockquote>
<ul>
<li>二叉树节点的<strong>深度</strong>：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）– <strong>前序遍历</strong></li>
<li>二叉树节点的<strong>高度</strong>：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）– <strong>后序遍历</strong></li>
</ul>
</blockquote>
<p>本题牢记一点，<strong>根节点的高度就是二叉树的最大深度</strong>。因此采用后序遍历。</p>
</li>
<li><p>AC代码（解法1：层序遍历）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="type">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
<li><p>AC代码（解法2：递归法）</p>
<p>利用<strong>根节点的高度就是二叉树的最大深度</strong>这一理论。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getdepth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftdepth = <span class="built_in">getdepth</span>(node-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightdepth = <span class="built_in">getdepth</span>(node-&gt;right);     <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth); <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getdepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="559-n叉树的最大深度"><a href="#559-n叉树的最大深度" class="headerlink" title="559. n叉树的最大深度"></a>559. n叉树的最大深度</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. n叉树的最大深度</a></p>
<ul>
<li><p>AC代码（迭代法）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;node-&gt;children.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[i]) &#123;</span><br><span class="line">                depth = <span class="built_in">max</span>(depth, <span class="built_in">getDepth</span>(node-&gt;children[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getDepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405071213847.png" alt="image-20240507121354366"></p>
</li>
<li><p>AC代码（迭代法）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">getDepth</span>(node-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">getDepth</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;left &amp;&amp; node-&gt;right) &#123; <span class="keyword">return</span> <span class="number">1</span> + rightDepth; &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left &amp;&amp; !node-&gt;right) &#123; <span class="keyword">return</span> <span class="number">1</span> + leftDepth; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> depth = <span class="built_in">getDepth</span>(root);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>精简版</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a>222. 完全二叉树的节点个数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><strong>完全二叉树</strong>只有两种情况：</li>
</ol>
<ul>
<li>满二叉树；<strong>（此时假设树深度为N，节点数为2^N-1）</strong></li>
<li>最后一层叶子节点没有满。<strong>（分别递归左右孩子，地轨道某一深度一定会有左孩子或右孩子为满二叉树）</strong></li>
</ul>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124092543662.png" alt="222.完全二叉树的节点个数" style="zoom:50%;" />

<ol start="2">
<li><p>如何判断<strong>完全二叉树是否是满二叉树</strong>？</p>
<p>在一棵完全二叉树中，如果递归向左遍历的深度等于递归向右遍历的深度，那就说明是满二叉树。</p>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163554.png" alt="img" style="zoom:50%;" />

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163709.png" alt="img" style="zoom:50%;" /></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="comment">// 开始根据左深度和右深度是否相同来判断该子树是不是满二叉树</span></span><br><span class="line">        TreeNode *left = root-&gt;left;</span><br><span class="line">        TreeNode *right = root-&gt;right;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="number">0</span>, rightDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left) &#123;</span><br><span class="line">            left = left-&gt;left;  <span class="comment">// 向左遍历</span></span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right) &#123;</span><br><span class="line">            right = right-&gt;right;  <span class="comment">// 向右遍历</span></span><br><span class="line">            rightDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></p>
<ul>
<li><p>解题思路</p>
<p>首先，<strong>求高度还是用到了后序遍历。</strong></p>
<p>递归三部曲分析：</p>
<ol>
<li><p>明确递归参数和返回值</p>
<ul>
<li>参数：当前传入节点</li>
<li>返回值：以当前传入节点为根节点的树的高度。但如果已经不是二叉平衡树了，则直接返回-1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode *node)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>明确终止条件</p>
<p>遇到了空节点即返回</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>明确单层递归的逻辑</p>
<p>分别求出其左右子树的高度：</p>
<ul>
<li>若差值小于等于1，则返回当前二叉树的高度</li>
<li>否则返回-1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line"><span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"><span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line"><span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;   <span class="comment">// 中</span></span><br><span class="line">    height =  <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    height = <span class="number">1</span> + <span class="built_in">max</span>(leftHeight, rightHeight);  <span class="comment">// 以当前节点为根节点的树的最大高度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> height;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">        <span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>+<span class="built_in">max</span>(leftHeight, rightHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHeight</span>(root) != <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><p>递归函数参数及返回值</p>
<ul>
<li>传入根节点、记录每一条路径的path、存放结果集的result</li>
<li>无需返回值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;string&gt; &amp;result)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归终止条件</p>
<p>本题不能写<code>if(cur == nullptr)</code>，因为这样写就直接跳过了叶子节点，而本题需要找到叶子节点所在处并进行相应的处理逻辑，因此终止条件如下，且此处无需判断cur是否为空，将在单层递归逻辑中进行判断。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 终止处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于终止处理逻辑，这里使用vector 结构path来记录路径，所以要把vector 结构的path转为string格式，再把这个string 放进 result里。<strong>那么为什么使用了vector 结构来记录路径呢？</strong>  因为在下面处理单层递归逻辑的时候，要做回溯，使用vector方便来做回溯。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123; <span class="comment">// 遇到叶子节点</span></span><br><span class="line">    string sPath;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123; <span class="comment">// 将path里记录的路径转为string格式</span></span><br><span class="line">        sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">        sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>() - <span class="number">1</span>]); <span class="comment">// 记录最后一个节点（叶子节点）</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(sPath); <span class="comment">// 收集一个路径</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单层递归逻辑</p>
<p>因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中，<code>path.push_back(cur-&gt;val);</code>。</p>
<ul>
<li><p>递归与回溯</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归和回溯一一对应，写到一个大括号里</span></span><br><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>AC代码（迭代法）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;string&gt; &amp;result)</span> </span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(cur-&gt;val);  <span class="comment">// 中（写在最前面是为了把这条路径的所有节点都加进path中）</span></span><br><span class="line">        <span class="comment">// 现在开始处理叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            string sPath;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;path.<span class="built_in">size</span>()<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">                sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">                sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(sPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;left, path, result);  <span class="comment">// 左</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;right, path, result); <span class="comment">// 右</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">        <span class="built_in">traversal</span>(root, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a>404. 左叶子之和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081211988.png" alt="image-20240508121115767"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123;  <span class="comment">// 左子树就是一个左叶子的情况</span></span><br><span class="line">            leftValue = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> sum = leftValue + rightValue;               <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a>513. 找树左下角的值</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></p>
<ul>
<li><p>解题思路</p>
<p>本题采用层序遍历的方式即可，只需要求最后一层的第一个元素。</p>
</li>
<li><p>AC代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                v.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = res[res.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></p>
<ul>
<li><p>AC代码（版本1，参考257的解法）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;path, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历到叶子节点了，开始计算和</span></span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> i : path) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == targetSum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> fleft = <span class="literal">false</span>, fright = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">            fleft = <span class="built_in">traversal</span>(cur-&gt;left, path, targetSum);  <span class="comment">// 左</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">            fright = <span class="built_in">traversal</span>(cur-&gt;right, path, targetSum); <span class="comment">// 右</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fleft || fright;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">traversal</span>(root, path, targetSum);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AC代码2（在遍历节点时就跟着计算和）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遇到叶子节点，并且计数为0</span></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遇到叶子节点直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            count -= cur-&gt;left-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;left-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            count -= cur-&gt;right-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;right-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、二叉树的修改与构造"><a href="#5、二叉树的修改与构造" class="headerlink" title="5、二叉树的修改与构造"></a>5、二叉树的修改与构造</h2><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></p>
<ul>
<li><p>解题思路</p>
<p>这道题只需要在遍历的过程中将每个节点的左右孩子翻转一遍，最终就可以达到整体翻转的效果。<strong>注意本题不能使用中序遍历，因为会把某些节点的左右孩子翻转两次。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302000083.png" alt="image-20240430200020967" style="zoom:67%;" />
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversel</span><span class="params">(TreeNode *cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left || cur-&gt;right) &#123;</span><br><span class="line">            TreeNode *tmp;</span><br><span class="line">            tmp = cur-&gt;left;</span><br><span class="line">            cur-&gt;left = cur-&gt;right;</span><br><span class="line">            cur-&gt;right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traversel</span>(cur-&gt;left);</span><br><span class="line">        <span class="built_in">traversel</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversel</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a>106. 从中序与后序遍历序列构造二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081210471.png" alt="image-20240508121021941"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;inorder, vector&lt;<span class="type">int</span>&gt; &amp;postorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s1. 如果数组大小为零的话，说明是空节点</span></span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s2. 后序数组的最后一个元素就是当前的root</span></span><br><span class="line">        <span class="type">int</span> rootValue = postorder[postorder.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s3. 找到后序数组最后一个元素在中序数组的位置，作为切割点</span></span><br><span class="line">        <span class="type">int</span> cut1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootValue) &#123;</span><br><span class="line">                cut1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s4. 切割中序数组，切成中序左数组和中序右数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_inorder</span><span class="params">(inorder.begin(), inorder.begin()+cut1)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_inorder</span><span class="params">(inorder.begin()+cut1+<span class="number">1</span>, inorder.end())</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// s5. 切割后序数组，切成后序左数组和后序右数组</span></span><br><span class="line">        postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>() - <span class="number">1</span>);  <span class="comment">// [important]postorder 舍弃末尾元素</span></span><br><span class="line">        <span class="type">int</span> cut2 = left_inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_postorder</span><span class="params">(postorder.begin(), postorder.begin()+cut2)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_postorder</span><span class="params">(postorder.begin()+cut2, postorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s6. 递归处理左区间和右区间</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(left_inorder, left_postorder);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(right_inorder, right_postorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>)  &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p>
<ul>
<li><p>解题思路</p>
<p>步骤如下：</p>
<ol>
<li>若数组为空，则说明是空树；</li>
<li>若数组非空，则取前序数组的第一个元素作为root；</li>
<li>找到前序数组的第一个元素在中序数组的位置，作为切割点；</li>
<li>切割中序数组，切成中序左数组和中序右数组；</li>
<li>切割前序数组，切成前序左树组和前序右数组；</li>
<li>递归处理左区间和右区间。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s1. </span></span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s2. </span></span><br><span class="line">        <span class="type">int</span> rootValue = preorder[<span class="number">0</span>];</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">size</span>() == <span class="number">1</span>) &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s3. </span></span><br><span class="line">        <span class="type">int</span> cut1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootValue) &#123;</span><br><span class="line">                cut1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s4. </span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_inorder</span><span class="params">(inorder.begin(), inorder.begin()+cut1)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_inorder</span><span class="params">(inorder.begin()+cut1+<span class="number">1</span>, inorder.end())</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// s5. </span></span><br><span class="line">        preorder.<span class="built_in">erase</span>(preorder.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="type">int</span> cut2 = left_inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_preorder</span><span class="params">(preorder.begin(), preorder.begin()+cut2)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_preorder</span><span class="params">(preorder.begin()+cut2, preorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s6. </span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(left_preorder, left_inorder);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(right_preorder, right_inorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || preorder.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(preorder, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6、求二叉搜索树的属性"><a href="#6、求二叉搜索树的属性" class="headerlink" title="6、求二叉搜索树的属性"></a>6、求二叉搜索树的属性</h2><h2 id="7、二叉树公共祖先问题"><a href="#7、二叉树公共祖先问题" class="headerlink" title="7、二叉树公共祖先问题"></a>7、二叉树公共祖先问题</h2><h2 id="8、二叉搜索数的修改与构造"><a href="#8、二叉搜索数的修改与构造" class="headerlink" title="8、二叉搜索数的修改与构造"></a>8、二叉搜索数的修改与构造</h2>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/04/08/Computer/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="prev" title="计算机网络">
      <i class="fa fa-chevron-left"></i> 计算机网络
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/04/13/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95/" rel="next" title="手撕算法">
      手撕算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E7%BB%84"><span class="nav-text">一、数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%BA%8C%E5%88%86%E6%B3%95"><span class="nav-text">1、二分法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-text">704. 二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="nav-text">35. 搜索插入位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-text">34. 在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="nav-text">69. x的平方根</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="nav-text">2、双指针法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-text">27. 移除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="nav-text">977.有序数组的平方</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">209. 长度最小的子数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E5%8E%9F%E5%88%99"><span class="nav-text">3、循环不变原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II"><span class="nav-text">59. 螺旋矩阵II</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8"><span class="nav-text">二、链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">1、链表的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="nav-text">2、删除链表元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="nav-text">203. 移除链表元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="nav-text">707. 设计链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-text">19. 删除链表的倒数第N个结点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text">3、反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text">206. 反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-text">24. 两两交换链表中的节点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="nav-text">4、链表相交</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="nav-text">面试题 02.07. 链表相交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="nav-text">142. 环形链表 II</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">三、哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81set%E5%92%8Cmap%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="nav-text">2、数组、set和map该如何选择？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89%E6%8B%A9%E7%94%A8%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%9F"><span class="nav-text">什么时候选择用哈希表？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89%E6%8B%A9%E7%94%A8%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="nav-text">什么时候选择用数组？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89%E6%8B%A9%E7%94%A8set%EF%BC%9F"><span class="nav-text">什么时候选择用set？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89%E6%8B%A9%E7%94%A8map%EF%BC%9F"><span class="nav-text">什么时候选择用map？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E9%87%87%E7%94%A8%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="nav-text">3、采用数组作为哈希函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-text">242. 有效的字母异位词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#383-%E8%B5%8E%E9%87%91%E4%BF%A1"><span class="nav-text">383. 赎金信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E9%87%87%E7%94%A8set%E8%A7%A3%E9%A2%98"><span class="nav-text">4、采用set解题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="nav-text">349. 两个数组的交集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#202-%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="nav-text">202. 快乐数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E9%87%87%E7%94%A8map%E8%A7%A3%E9%A2%98"><span class="nav-text">5、采用map解题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-text">1. 两数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II"><span class="nav-text">454. 四数相加II</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">四、字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">1、反转字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">344. 反转字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II"><span class="nav-text">541. 反转字符串II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="nav-text">151. 反转字符串中的单词</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81KMP%E7%AE%97%E6%B3%95"><span class="nav-text">2、KMP算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#28-%E5%AE%9E%E7%8E%B0-strStr"><span class="nav-text">28. 实现 strStr()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">459. 重复的子字符串</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-text">五、栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-text">1、栈和队列的理论基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">2、栈的基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">3、队列的基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%AF%B9%E7%A7%B0%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="nav-text">4、对称匹配问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-text">20. 有效的括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="nav-text">1047. 删除字符串中的所有相邻重复项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-text">150. 逆波兰表达式求值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E9%98%9F%E5%88%97%E8%A7%A3%E5%86%B3%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="nav-text">5、队列解决相关问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-text">239. 滑动窗口最大值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="nav-text">347.前 K 个高频元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">六、二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-1"><span class="nav-text">1、理论基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%88%86%E7%B1%BB"><span class="nav-text">（1）分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">（2）存储方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="nav-text">（3）遍历方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="nav-text">（4）定义方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">2、深度优先遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">144. 二叉树的前序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">94. 二叉树的中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">145. 二叉树的后序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">3、广度优先遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">102. 二叉树的层序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-text">199. 二叉树的右视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">429. N叉树的层序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="nav-text">116. 填充每个节点的下一个右侧节点指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-text">4、二叉树的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">101. 对称二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-text">104. 二叉树的最大深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#559-n%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-text">559. n叉树的最大深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="nav-text">111. 二叉树的最小深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="nav-text">222. 完全二叉树的节点个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">110. 平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="nav-text">257. 二叉树的所有路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="nav-text">404. 左叶子之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="nav-text">513. 找树左下角的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="nav-text">112. 路径总和</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%9E%84%E9%80%A0"><span class="nav-text">5、二叉树的修改与构造</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">226. 翻转二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">106. 从中序与后序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">105. 从前序与中序遍历序列构造二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E6%B1%82%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-text">6、求二叉搜索树的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98"><span class="nav-text">7、二叉树公共祖先问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%95%B0%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%9E%84%E9%80%A0"><span class="nav-text">8、二叉搜索数的修改与构造</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="midorii"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">midorii</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">midorii</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">162k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:47</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
