<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch_cat_logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/site_cat-32%C3%9732.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/site_cat-16%C3%9716.png">
  <link rel="mask-icon" href="/images/cat_logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1、GCC安装（1）GCC相关知识点GCC（GNU Compiler Collection， GNU编译器套件）是由GNU开发的编程语言译器。 gcc和g++都是GNU（组织）的一个编译器  误区一：gcc只能编译C程序，g++只能编译C++代码： 后缀为.c时，gcc认为其是C程序，g++认为其是C++程序； 后缀为.cpp时，gcc和g++均认为其是C++程序。   误区二：编译只能用gcc，">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux基础相关">
<meta property="og:url" content="http://example.com/2024/04/17/Computer/Linux%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="MIDORII&#39;S JOURNEY">
<meta property="og:description" content="1、GCC安装（1）GCC相关知识点GCC（GNU Compiler Collection， GNU编译器套件）是由GNU开发的编程语言译器。 gcc和g++都是GNU（组织）的一个编译器  误区一：gcc只能编译C程序，g++只能编译C++代码： 后缀为.c时，gcc认为其是C程序，g++认为其是C++程序； 后缀为.cpp时，gcc和g++均认为其是C++程序。   误区二：编译只能用gcc，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171012036.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171012580.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013866.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013529.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013337.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013840.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013622.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013961.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013076.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014770.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014481.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014264.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014308.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014605.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014917.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015389.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015553.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171018439.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019513.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015837.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171018316.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015549.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015818.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019153.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404170953727.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019600.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019149.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020236.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020344.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020768.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020543.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020502.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171021405.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171022599.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171024144.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171024552.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171024495.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025257.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025204.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025341.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025019.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171026474.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171026332.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171026839.png">
<meta property="article:published_time" content="2024-04-17T02:06:59.783Z">
<meta property="article:modified_time" content="2024-04-17T02:36:05.518Z">
<meta property="article:author" content="midorii">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171012036.png">

<link rel="canonical" href="http://example.com/2024/04/17/Computer/Linux%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux基础相关 | MIDORII'S JOURNEY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MIDORII'S JOURNEY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">a little bit sweet</p>
      <a>
        <img class="custom-logo-image" src="/images/cat.jpeg" alt="MIDORII'S JOURNEY">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/17/Computer/Linux%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux基础相关
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-17 10:06:59 / 修改时间：10:36:05" itemprop="dateCreated datePublished" datetime="2024-04-17T10:06:59+08:00">2024-04-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>39 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1、GCC安装"><a href="#1、GCC安装" class="headerlink" title="1、GCC安装"></a>1、GCC安装</h2><h3 id="（1）GCC相关知识点"><a href="#（1）GCC相关知识点" class="headerlink" title="（1）GCC相关知识点"></a>（1）GCC相关知识点</h3><p>GCC（GNU Compiler Collection， GNU编译器套件）是由GNU开发的编程语言译器。</p>
<p>gcc和g++都是GNU（组织）的一个编译器</p>
<ul>
<li>误区一：gcc只能编译C程序，g++只能编译C++代码：<ul>
<li>后缀为.c时，gcc认为其是C程序，g++认为其是C++程序；</li>
<li>后缀为.cpp时，gcc和g++均认为其是C++程序。</li>
</ul>
</li>
<li>误区二：编译只能用gcc，链接只能用g++：<ul>
<li>严格来说不算错误，但混淆了概念，应该说：编译可以用gcc&#x2F;g++，而链接可以用g++或者gcc -lstdc++;</li>
<li>gcc命令不能自动和C++程序使用的库链接，所以通常使用g++来完成链接。但在编译阶段，g++会自动调用gcc，二者等价。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171012036.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171012580.png" alt="2"></p>
<h3 id="（2）GCC工作流程"><a href="#（2）GCC工作流程" class="headerlink" title="（2）GCC工作流程"></a>（2）GCC工作流程</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013866.png" alt="3"></p>
<ul>
<li><p>预处理：对头文件展开\删除代码中的注释\宏替换</p>
</li>
<li><p><strong>程序编译成可执行程序的过程：</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013529.png" alt="4"></p>
</li>
</ul>
<h2 id="2、静态库和动态库"><a href="#2、静态库和动态库" class="headerlink" title="2、静态库和动态库"></a>2、静态库和动态库</h2><h3 id="（1）静态库"><a href="#（1）静态库" class="headerlink" title="（1）静态库"></a>（1）静态库</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013337.png" alt="5"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013840.png" alt="6"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson/library<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">├── add.c</span><br><span class="line">├── div.c</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br><span class="line">root@iisayhi:~/lesson/library<span class="comment"># gcc main.c -o app -I ./include/ -l calc -L ./lib/</span></span><br><span class="line">root@iisayhi:~/lesson/library<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── app</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">		├── add.c</span><br><span class="line">		├── div.c</span><br><span class="line">		├── mult.c</span><br><span class="line">		└── sub.c</span><br></pre></td></tr></table></figure>

<h3 id="（2）动态库"><a href="#（2）动态库" class="headerlink" title="（2）动态库"></a>（2）动态库</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013622.png" alt="7"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013961.png" alt="8"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013076.png" alt="9"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/calc# **gcc -c -fpic add.c mult.c sub.c div.c** </span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# ls</span><br><span class="line">add.c  add.o  div.c  div.o  head.h  main.c  mult.c  mult.o  sub.c  sub.o</span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# **gcc -shared *.o -o libcalc.so**</span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# ll</span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x 2 root root  4096 Apr  6 22:49 ./</span><br><span class="line">drwxr-xr-x 4 root root  4096 Apr  6 22:47 ../</span><br><span class="line">-rw-r--r-- 1 root root    80 Apr  6 22:47 add.c</span><br><span class="line">-rw-r--r-- 1 root root  1376 Apr  6 22:48 add.o</span><br><span class="line">-rw-r--r-- 1 root root    94 Apr  6 22:47 div.c</span><br><span class="line">-rw-r--r-- 1 root root  1384 Apr  6 22:48 div.o</span><br><span class="line">-rw-r--r-- 1 root root   189 Apr  6 22:47 head.h</span><br><span class="line">-rwxr-xr-x 1 root root 15824 Apr  6 22:49 libcalc.so*</span><br><span class="line">-rw-r--r-- 1 root root   306 Apr  6 22:47 main.c</span><br><span class="line">-rw-r--r-- 1 root root    85 Apr  6 22:47 mult.c</span><br><span class="line">-rw-r--r-- 1 root root  1384 Apr  6 22:48 mult.o</span><br><span class="line">-rw-r--r-- 1 root root    85 Apr  6 22:47 sub.c</span><br><span class="line">-rw-r--r-- 1 root root  1376 Apr  6 22:48 sub.o</span><br></pre></td></tr></table></figure>

<ul>
<li>运行main可执行文件报错：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># gcc main.c -o main -I include/ -L lib/ -l calc</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ls</span></span><br><span class="line">include  lib  main  main.c  src</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">**./main: error <span class="keyword">while</span> loading shared libraries: [libcalc.so](&lt;http://libcalc.so/&gt;): cannot open shared object file: No such file or directory**</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffda29fd000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; not found</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbe8fa25000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007fbe8fc31000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>原因即是由于动态库是在程序启动后才被加载到内存中，而我们自己写的动态库libcalc.so并没有给出对应的路径去查找它，所以会报错。</p>
<p>解决方法：</p>
<blockquote>
<p>对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的 <strong>DT_RPATH段</strong> ——&gt; <strong>环境变量LD_LIBRARY_PATH</strong> ——&gt; <strong>&#x2F;etc&#x2F;ld.so.cache</strong>文件列表 ——&gt; <strong>&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib</strong>目录找到库文件后将其载入内存</p>
</blockquote>
<p><strong>1）DT_RPATH段 无法修改，系统本身固定值</strong></p>
<p><strong>2）环境变量LD_LIBRARY_PATH</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># echo $LD_LIBRARY_PATH </span></span><br><span class="line">:/root/lesson/lesson01/library/lib</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffff57e5000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; /root/lesson/lesson01/library/lib/libcalc.so (0x00007f06515af000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f06513aa000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f06515bb000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">a = 20, b = 12</span><br><span class="line">a + b = 32</span><br><span class="line">a - b = 8</span><br><span class="line">a * b = 240</span><br><span class="line">a / b = 1.666667</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>直接在终端中配置，当终端被关闭后该环境变量就会消失了，属于临时性配置。</p>
<p>永久性配置：</p>
<ul>
<li><p>用户级别</p>
<ul>
<li><p>根目录下，<code>vim .bashrc</code></p>
</li>
<li><p>在最后一行加上要添加的路径</p>
<p><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</code></p>
</li>
<li><p><code>source ~/.bashrc</code></p>
</li>
</ul>
</li>
<li><p>系统级别</p>
<ul>
<li><p><code>sudo vim /etc/profile</code></p>
</li>
<li><p>在最后一行加上要添加的路径</p>
<p><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</code></p>
</li>
<li><p><code>source /etc/profile</code></p>
</li>
</ul>
</li>
</ul>
<p><strong>3）&#x2F;etc&#x2F;ld.so.cache文件列表</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson<span class="comment"># ll /etc/ld.so.cache</span></span><br><span class="line">-rw-r--r-- 1 root root 74025 Jan 12 21:15 /etc/ld.so.cache</span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># **sudo vim /etc/ld.so.conf**</span></span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># **sudo ldconfig**</span></span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># cd lesson01/library/</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffd633f6000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; /root/lesson/lesson01/library/lib/libcalc.so (0x00007f7b8a4e1000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7b8a2ef000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f7b8a500000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">a = 20, b = 12</span><br><span class="line">a + b = 32</span><br><span class="line">a - b = 8</span><br><span class="line">a * b = 240</span><br><span class="line">a / b = 1.666667</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p><code>/etc/ld.so.cache</code>是一个二进制文件，无法直接用vim进行修改；</p>
<p>因此要借助<code>/etc/ld.so.conf</code>的帮助：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014770.png" alt="10"></p>
<p><strong>4）&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib目录</strong></p>
<p>不推荐使用，因为在上述目录下已经包含很多系统自带的库文件，因此可能存在重名导致被替换的问题存在。</p>
<h3 id="（3）静态库和动态库的对比"><a href="#（3）静态库和动态库的对比" class="headerlink" title="（3）静态库和动态库的对比"></a>（3）静态库和动态库的对比</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014481.png" alt="11"></p>
<ul>
<li>消耗系统资源、浪费内存：<ul>
<li>每个程序在运行时都会将静态库复制一份到内存中，多个程序同时运行时浪费内存；</li>
</ul>
</li>
<li>更新、部署、发布麻烦：<ul>
<li>每次更新、部署或发布时都需要重新编译</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014264.png" alt="12"></p>
<h2 id="3、Makefile"><a href="#3、Makefile" class="headerlink" title="3、Makefile"></a>3、Makefile</h2><ul>
<li>定义<ul>
<li>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 <code>Makefile 文件就像一个 Shell 脚本一样，也可以执行操作系统的命令</code>。</li>
<li><strong>Makefile 带来的好处就是“自动化编译”</strong> ，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如 Delphi 的 <code>make</code>，Visual C++ 的 <code>nmake</code>，Linux 下 GNU 的 <code>make</code>。</li>
</ul>
</li>
<li>命名规则</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014308.png" alt="13"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014605.png" alt="14"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014917.png" alt="15"></p>
<ul>
<li>工作原理</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015389.png" alt="16"></p>
<ul>
<li>变量</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015553.png" alt="17"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171018439.png" alt="Untitled"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019513.png" alt="Untitled"></p>
<p><strong>对原始写法进行简写：</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015837.png" alt="20"></p>
<p>改进1：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171018316.png" alt="Untitled"></p>
<p>改进2：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015549.png" alt="22"></p>
<p>改进3：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015818.png" alt="23"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY:clean  # 定义clean为伪目标</span><br></pre></td></tr></table></figure>

<p>改进4：<code>Makefile</code>中写了<code>clean</code>之后，在命令行要用<code>make clean</code>来调用</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019153.png" alt="24"></p>
<h2 id="4、GDB调试"><a href="#4、GDB调试" class="headerlink" title="4、GDB调试"></a>4、GDB调试</h2><span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man gdb</span><br></pre></td></tr></table></figure>

<p>要进入gdb调试模式需要加上-g参数，<code>gcc -g filename</code></p>
<blockquote>
<p>gdb基本命令</p>
</blockquote>
<p><code>list</code> 查看当前源代码</p>
<p><code>run</code> 运行程序</p>
<p><code>break(b)</code> 打断点，有两种打断点方式：</p>
<ol>
<li><code>break function</code></li>
<li><code>break 可执行文件:行号</code></li>
</ol>
<p><code>info b</code> 查看已经打的断点</p>
<p><code>next(n)</code> 执行下一步</p>
<p><code>step(s)</code> 执行函数内部</p>
<p><code>print(p)</code> 打印当前变量内容</p>
<blockquote>
<p>gdb小技巧</p>
</blockquote>
<ol>
<li>gdb中可以通过<code>shell</code>调取终端命令，如：</li>
</ol>
<ul>
<li>shell ls</li>
<li>shell cat filename</li>
</ul>
<ol>
<li>设置日志功能，<code>set logging on</code></li>
<li>断点的相关设置：</li>
</ol>
<ul>
<li>breakpoints</li>
<li>watchpoints：观察变量是否变化</li>
<li>catchpoints</li>
</ul>
<blockquote>
<p>调试core文件</p>
</blockquote>
<p>系统不会默认生成core文件，需要进行手动设置</p>
<p>man ulimit</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404170953727.png" alt="1"></p>
<p>注意其中一行：<code>open file 65535</code>，能打开的最大文件数是65535</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br></pre></td></tr></table></figure>

<p>这样设置之后，运行可执行文件后出现(core dump)即为生成了对应的core文件。若仍为生成core文件，调用命令：<code>echo &quot;core&quot; &gt; /proc/sys/kernel/core_pattern</code></p>
<p>此时的gdb调试命令为：<code>gdb 可执行文件名（二进制文件） 可执行文件生成的core文件名</code></p>
<blockquote>
<p>调试正在运行的文件</p>
</blockquote>
<p>后台运行一个程序并返回其pid号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./a.out &amp;</span><br><span class="line">[1] 96929</span><br></pre></td></tr></table></figure>

<p>gdb调试该后台程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">gdb -p 96929</span><br><span class="line">root@iisayhi:~/Documents/useless# vim test_for.c </span><br><span class="line">root@iisayhi:~/Documents/useless# **gcc test_for.c -g**</span><br><span class="line">root@iisayhi:~/Documents/useless# **./a.out &amp;**</span><br><span class="line">**[1] 96929**</span><br><span class="line">root@iisayhi:~/Documents/useless# **gdb -p 96929**</span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br><span class="line">Attaching to process 96929</span><br><span class="line">Reading symbols from /root/Documents/useless/a.out...</span><br><span class="line">Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...</span><br><span class="line">Reading symbols from /usr/lib/debug/.build-id/ee/be5d5f4b608b8a53ec446b63981bba373ca0ca.debug...</span><br><span class="line">Reading symbols from /lib64/ld-linux-x86-64.so.2...</span><br><span class="line">Reading symbols from /usr/lib/debug/.build-id/7a/e2aaae1a0e5b262df913ee0885582d2e327982.debug...</span><br><span class="line">test1 () at test_for.c:14</span><br><span class="line">14	&#125;</span><br><span class="line">(gdb) n</span><br><span class="line">main () at test_for.c:18</span><br><span class="line">18			test();</span><br><span class="line">(gdb) n</span><br><span class="line">19			test1();</span><br><span class="line">(gdb) s</span><br><span class="line">test1 () at test_for.c:11</span><br><span class="line">11	void test1() &#123;</span><br><span class="line">(gdb) n</span><br><span class="line">12		int i = 0;</span><br><span class="line">(gdb) n</span><br><span class="line">13		i++;</span><br><span class="line">(gdb) p i</span><br><span class="line">$1 = 0</span><br><span class="line">(gdb) n</span><br><span class="line">14	&#125;</span><br><span class="line">(gdb) p i</span><br><span class="line">$2 = 1</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// test test1</span><br><span class="line">// i i++</span><br><span class="line">// call test test1</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test1() &#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	for(;;) &#123;</span><br><span class="line">		test();</span><br><span class="line">		test1();</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、文件I-O"><a href="#5、文件I-O" class="headerlink" title="5、文件I&#x2F;O"></a>5、文件I&#x2F;O</h2><h3 id="（1）标准C库IO函数"><a href="#（1）标准C库IO函数" class="headerlink" title="（1）标准C库IO函数"></a>（1）标准C库IO函数</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019600.png" alt="25"></p>
<p>标准C库IO函数可以跨平台（win\linux等）。</p>
<p><strong>在不同平台上调用不同的系统API，从而实现跨平台。</strong></p>
<p>写数据时首先有一个缓冲区，内容首先写到缓冲区（内存，默认<em><strong>8k</strong></em>）中，当<strong>缓冲区内容满后&#x2F;强行刷新缓冲区&#x2F;正常关闭文件后</strong>，再将当前缓冲区的内容传递到磁盘中。</p>
<ul>
<li>标准C库IO和Linux系统IO的关系：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019149.png" alt="26"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020236.png" alt="27"></p>
<h3 id="（2）虚拟地址空间"><a href="#（2）虚拟地址空间" class="headerlink" title="（2）虚拟地址空间"></a>（2）虚拟地址空间</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020344.png" alt="28"></p>
<p>虚拟地址空间会通过MMU映射到真实物理空间上。</p>
<p>NULL\NULL pointer — 受保护的地址</p>
<p>new\malloc              — 堆空间</p>
<p>局部变量                  — 栈空间</p>
<h3 id="（3）文件描述符"><a href="#（3）文件描述符" class="headerlink" title="（3）文件描述符"></a>（3）文件描述符</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020768.png" alt="29"></p>
<ul>
<li><p>程序和进程间的区别</p>
<ul>
<li>程序（test.c)\可执行程序(test) — 不占用内存空间，只占用磁盘空间，是伪文件；</li>
<li>进程 — 运行一个程序时，操作系统创建一个进程为其分配资源，会占用内存空间。</li>
</ul>
</li>
<li><pre><code>PCB进程控制块
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">是一个复杂的结构体，位于Linux kernel的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
内存管理
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  。中封装了各类信息，如文件描述符表</span><br><span class="line"></span><br><span class="line">  - 文件描述符表，是一个数组</span><br><span class="line"></span><br><span class="line">    ，存储多个文件描述符 — 使得一个进程可以打开多个文件（产生多个文件描述符）</span><br><span class="line"></span><br><span class="line">    - 默认的大小是**1024（默认能打开的文件数）；**</span><br><span class="line">    - 数组前3位被默认占用，为**标准输入、标准输出、标准错误，且默认是打开状态**（此三个文件描述符和**当前终端**绑定，联系linux系统一切皆文件的思想来理解）；</span><br><span class="line">    - 占用文件描述符时内核会自动寻找最小的没有被占用的文件描述符来使用。</span><br><span class="line"></span><br><span class="line">### （4）Linux系统IO函数</span><br><span class="line"></span><br><span class="line">![30](https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020793.png)</span><br><span class="line"></span><br><span class="line">1）open函数</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">// 打开一个已经存在的文件</span><br><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">    参数：</span><br><span class="line">        - pathname  要打开的文件路径</span><br><span class="line">        - flags     对文件的操作权限设置还有其他的设置</span><br><span class="line">                    O_RDONLY, O_WRONLY, or O_RDWR 这三个操作互斥</span><br><span class="line">    返回值：</span><br><span class="line">        返回一个新的文件描述符；若失败则返回-1</span><br><span class="line"></span><br><span class="line">errno：属于Linux系统函数库里面的一个全局变量，记录的是最近的错误号</span><br><span class="line">    #include &lt;stdio.h&gt;</span><br><span class="line">    void perror(const char *s);</span><br><span class="line">        作用：打印errno对应的错误描述</span><br><span class="line">        参数：</span><br><span class="line">            - s     用户描述</span><br><span class="line">// 创建一个新的文件</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line">    参数：</span><br><span class="line">        - pathname  要打开的文件路径</span><br><span class="line"></span><br><span class="line">        - flags     对文件的操作权限设置还有其他的设置</span><br><span class="line">                    - 必选项：O_RDONLY, O_WRONLY, O_RDWR 这三个操作互斥</span><br><span class="line">                    - 可选项：O_CREAT 文件不存在，创建新文件</span><br><span class="line">                    flags参数是一个int类型的数据，占4个字节，32位</span><br><span class="line">                    flags32位，每一位就是一个标志位</span><br><span class="line"></span><br><span class="line">        - mode      八进制数，表述用户对创建出的新的文件的操作权限</span><br><span class="line">                    - 0777</span><br><span class="line">                        0：     0开头，八进制数</span><br><span class="line">                        777：   并非就是777，涉及到掩码，最终的权限是 mode &amp; ~umask</span><br><span class="line">                                    umask = 0022  ~umask = 0755</span><br><span class="line">                                        0777 -&gt; 111111111</span><br><span class="line">                                    &amp;   0755 -&gt; 111101101</span><br><span class="line">                                        0755 -&gt; 111101101</span><br><span class="line">                    umask的作用就是抹去某些权限</span><br><span class="line"></span><br><span class="line">                                </span><br><span class="line">    返回值：</span><br><span class="line">    返回一个新的文件描述符；若失败则返回-1</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code>flags
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">和</span><br><span class="line"></span><br></pre></td></tr></table></figure>
mode_t
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  的区别：</span><br><span class="line"></span><br><span class="line">  - `flags`是程序在运行时，能以什么权限对文件进行操作；</span><br><span class="line">  - `mode_t`是指这个文件本身的权限。</span><br><span class="line"></span><br><span class="line">- 关于rwx权限：</span><br><span class="line"></span><br><span class="line">  - r   - 读，对文件而言，具有读取文件内容的权限；对目录来说，具有浏览该目录信息的权限</span><br><span class="line"></span><br><span class="line">  - w  - 写，对文件而言，具有修改文件内容的权限；对目录来说具有删除移动目录内文件的权限</span><br><span class="line"></span><br><span class="line">  - x   - 可执行，对文件而言，具有执行文件的权限；对目录来说，具有进入目录的权限</span><br><span class="line"></span><br><span class="line">    | 第一位  | 用户   | 组用户 | 其他用户 |</span><br><span class="line">    | ------- | ------ | ------ | -------- |</span><br><span class="line">    | -  文件 | d 目录 | rwx    | r-x      |</span><br><span class="line"></span><br><span class="line">2）read &amp; write函数</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">        参数：</span><br><span class="line">            - fd        文件描述符，open得到</span><br><span class="line">            - *buf      缓冲区，读取数据存放的地方，数组的地址</span><br><span class="line">            - count     指定的数组的大小</span><br><span class="line">        返回值</span><br><span class="line">            - 成功：</span><br><span class="line">                &gt;0      返回实际读取到的字节数</span><br><span class="line">                =0      文件已经读取完毕</span><br><span class="line">            - 失败</span><br><span class="line">                -1      并设置errno</span><br><span class="line"></span><br><span class="line">ssize_t  write(int  fd,  const void *buf, size_t count);</span><br><span class="line">        参数：</span><br><span class="line">		        - fd        文件描述符，open得到</span><br><span class="line">		        - *buf      要往磁盘写入的数据，数据</span><br><span class="line">		        - count     实际写入数据大小</span><br><span class="line">        返回值</span><br><span class="line">            - 成功：</span><br><span class="line">                &gt;0      返回实际读取到的字节数</span><br><span class="line">                =0      无任何数据写到文件中</span><br><span class="line">            - 失败</span><br><span class="line">                -1      并设置errno</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>对于write函数来说，如果count的大小（实际写入数据的大小）大于缓冲区实际大小时，那么会把缓冲区后面的内存中的数据写进去，只不过这些数据我们是不确定的，是野内存，操作野内存有可能会产生问题，所以一般不会这么去做。缓冲区中有多少数据，我们就写多少数据即可。</p>
</li>
</ul>
<p>3）lseek函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">标准C库：</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"></span><br><span class="line">Linux系统函数：</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line">    <span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line">        对文件指针进行操作</span><br><span class="line">        参数：</span><br><span class="line">            - fd        文件描述符</span><br><span class="line">            - offset    偏移量  </span><br><span class="line">            - whence    </span><br><span class="line">                SEEK_SET</span><br><span class="line">                    设置文件指针的偏移量</span><br><span class="line"></span><br><span class="line">                SEEK_CUR</span><br><span class="line">                    设置偏移量：当前位置 + 第二个参数offset的值</span><br><span class="line"></span><br><span class="line">                SEEK_END</span><br><span class="line">                    设置偏移量：文件大小 + 第二个参数offset的值</span><br><span class="line">        返回值：返回文件指针的位置</span><br><span class="line">        作用：</span><br><span class="line">            <span class="number">1</span>、移动文件指针到头文件</span><br><span class="line">                lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">            <span class="number">2</span>、获取当前文件指针的位置</span><br><span class="line">                lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line">            <span class="number">3</span>、获取文件长度</span><br><span class="line">                lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">            <span class="number">4</span>、拓展文件长度 ex. <span class="number">10b</span> =&gt; <span class="number">110b</span></span><br><span class="line">                lseek(fd, <span class="number">100</span>, SEEK_END);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>利用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek</span><br></pre></td></tr></table></figure>

<p>函数拓展文件长度时需要写入一次数据才能起作用：</p>
<ul>
<li>拓展时，<code>lseek</code>只是逻辑上移动文件指针的位置，并没有为文件分配存储空间，为了让这些空间实际得到分配，可以使用<code>write</code>在最后补充一个字符，这样拓展的存储空间应该就分配了。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓展文件长度</span></span><br><span class="line">    <span class="type">int</span> ret = lseek(fd, <span class="number">100</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入空数据，被写入到第112b的位置上</span></span><br><span class="line">    <span class="comment">// 不执行这一步之前一般ll是看不到hello.txt的文件大小变化的</span></span><br><span class="line">    <span class="comment">// hello.txt : 11b ==&gt; 112b</span></span><br><span class="line">    write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br></pre></td></tr></table></figure>

<p>4）stat\lstat函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line">    作用：获取一个文件相关的一些信息</span><br><span class="line">    参数:</span><br><span class="line">        - pathname：    操作的文件的路径</span><br><span class="line">        - statbuf：     结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="line">    返回值：</span><br><span class="line">        成功：返回<span class="number">0</span></span><br><span class="line">        失败：返回<span class="number">-1</span> 设置errno</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line">    参数:</span><br><span class="line">        - pathname：    操作的文件的路径</span><br><span class="line">        - statbuf：     结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="line">    返回值：</span><br><span class="line">        成功：返回<span class="number">0</span></span><br><span class="line">        失败：返回<span class="number">-1</span> 设置errno</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020543.png" alt="31"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020502.png" alt="32"></p>
<p>5）文件属性操作函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>;</span><br><span class="line">    作用：判断某个文件是否有某个权限，或者判断文件是否存在</span><br><span class="line">    参数：</span><br><span class="line">        - pathname: 判断的文件路径</span><br><span class="line">        - mode:</span><br><span class="line">            R_OK: 判断是否有读权限</span><br><span class="line">            W_OK: 判断是否有写权限</span><br><span class="line">            X_OK: 判断是否有执行权限</span><br><span class="line">            F_OK: 判断文件是否存在</span><br><span class="line">    返回值：成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">    修改文件的权限</span><br><span class="line">    参数：</span><br><span class="line">        - pathname: 需要修改的文件的路径</span><br><span class="line">        - mode:需要修改的权限值，八进制的数</span><br><span class="line">    返回值：成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line">    作用：缩减或者扩展文件的尺寸至指定的大小</span><br><span class="line">    参数：</span><br><span class="line">        - path: 需要修改的文件的路径</span><br><span class="line">        - length: 需要最终文件变成的大小</span><br><span class="line">    返回值：</span><br><span class="line">        成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前用户id和组id：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/passwd <span class="comment">// 用户</span></span><br><span class="line">vim /etc/group   <span class="comment">// 组</span></span><br></pre></td></tr></table></figure>

<p>6）目录操作函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">    作用：创建一个目录</span><br><span class="line">    参数：</span><br><span class="line">        pathname: 创建的目录的路径</span><br><span class="line">        mode: 权限，八进制的数</span><br><span class="line">    返回值：</span><br><span class="line">        成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"><span class="type">int</span> ret = mkdir(<span class="string">&quot;aaa&quot;</span>, <span class="number">0777</span>);</span><br><span class="line"><span class="comment">// 最终的权限结果是 mode &amp; ~umask &amp; 0777</span></span><br><span class="line"><span class="comment">// 给的是0777 ==&gt; 最终得到 drwxr-xr-x</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line">    作用：修改进程的工作目录</span><br><span class="line">        比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder</span><br><span class="line">    参数：</span><br><span class="line">        path : 需要修改的工作目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br><span class="line">    作用：获取当前工作目录</span><br><span class="line">    参数：</span><br><span class="line">        - buf : 存储的路径，指向的是一个数组（传出参数）</span><br><span class="line">        - size: 数组的大小</span><br><span class="line">    返回值：</span><br><span class="line">        返回的指向的一块内存，这个数据就是第一个参数</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure>

<p>7）目录遍历函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开一个目录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - name: 需要打开的目录的名称</span><br><span class="line">    返回值：</span><br><span class="line">        DIR * 类型，理解为目录流</span><br><span class="line">        错误返回<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取目录中的数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line">    - 参数：dirp是opendir返回的结果</span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>，代表读取到的文件的信息</span></span><br><span class="line"><span class="class">        读取到了末尾或者失败了，返回<span class="title">NULL</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 关闭目录</span></span><br><span class="line"><span class="class">#<span class="title">include</span> &lt;</span>sys/types.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171021405.png" alt="33"></p>
<p>8）dup\dup2函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line">	  作用：复制一个新的文件描述符</span><br><span class="line">	  fd=<span class="number">3</span>, <span class="type">int</span> fd1 = dup(fd),</span><br><span class="line">	  fd指向的是a.txt, fd1也是指向a.txt</span><br><span class="line">		从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> dup2(<span class="type">int</span> oldfd, <span class="type">int</span> newfd);</span><br><span class="line">    作用：重定向文件描述符</span><br><span class="line">    oldfd 指向 a.txt, newfd 指向 b.txt</span><br><span class="line">    调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt</span><br><span class="line">    oldfd 必须是一个有效的文件描述符</span><br><span class="line">    oldfd和newfd值相同，相当于什么都没有做</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd1 = open(<span class="string">&quot;2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line"><span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d\\n&quot;</span>, fd, fd1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做了dup2之后 fd1就和2.txt没有关系了  </span></span><br><span class="line"><span class="comment">// 返回值fd2其实没必要再做任何操作了</span></span><br><span class="line"><span class="type">int</span> fd2 = dup2(fd, fd1);</span><br><span class="line"><span class="keyword">if</span>(fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样重定向之后2.txt就没有任何文件描述符了</span></span><br><span class="line"><span class="comment">// 如果还需要访问2.txt，则需要重新open一下，赋值一个新的文件描述符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过fd1去写数据，实际操作的是1.txt，而不是2.txt</span></span><br><span class="line"><span class="type">char</span> * str = <span class="string">&quot;hello, dup2&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9）fcntl函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span>;</span><br><span class="line">参数：</span><br><span class="line">    fd : 表示需要操作的文件描述符</span><br><span class="line">    cmd: 表示对文件描述符进行如何操作</span><br><span class="line">        - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）</span><br><span class="line">            <span class="type">int</span> ret = fcntl(fd, F_DUPFD);</span><br><span class="line"></span><br><span class="line">        - F_GETFL : 获取指定的文件描述符文件状态flag</span><br><span class="line">          获取的flag和我们通过open函数传递的flag是一个东西。</span><br><span class="line"></span><br><span class="line">        - F_SETFL : 设置文件描述符文件状态flag</span><br><span class="line">          必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改</span><br><span class="line">          可选性：O_APPEND, O_NONBLOCK</span><br><span class="line">            O_APPEND 表示追加数据</span><br><span class="line">            O_NONBLOCK 设置成非阻塞</span><br><span class="line">    </span><br><span class="line">    阻塞和非阻塞：描述的是函数调用的行为。</span><br></pre></td></tr></table></figure>

<h1 id="6、进程"><a href="#6、进程" class="headerlink" title="6、进程"></a>6、进程</h1><h2 id="（1）进程概述"><a href="#（1）进程概述" class="headerlink" title="（1）进程概述"></a>（1）进程概述</h2><ul>
<li>进程要占用内存和CPU资源，而程序不占用</li>
<li>从内核角度看：进程 &#x3D; 用户内存空间 + 内核数据结构</li>
<li><code>时间片(timeslice)</code>是操作系统分配给每个正在运行的进程微观上的一段CPU时间。由于timeslice的存在，让进程“看起来像”是同时运行的。<strong>Linux一般为5ms-800ms</strong></li>
<li>并行和并发<ul>
<li><code>并行(parallel)</code>：指在同一时刻，有多条指令在多个处理器上同时执行。</li>
<li><code>并发(concurrency)</code>：指在同一时刻只能有一条指令执行，但多个进程指令被快速的 轮换执行，本质上是把时间分成若干段，使多个进程快速交替的执行。</li>
</ul>
</li>
<li>内核为每个进程分配一个PCB(Processing Control Block)进程控制块</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171022599.png" alt="34"></p>
<h2 id="（2）进程状态转换"><a href="#（2）进程状态转换" class="headerlink" title="（2）进程状态转换"></a>（2）进程状态转换</h2><p>1）进程状态</p>
<ul>
<li><p>三态模型</p>
<ul>
<li>就绪态：进程具备运行条件，已分配到除CPU以外的所有必要资源；处于就绪态的多个进程排成就绪队列</li>
<li>运行态：进程占有处理器正在运行</li>
<li>阻塞态：进程不具备运行条件，又称wait或sleep态，需要与用户进行交互时也将阻塞</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171024144.png" alt="35"></p>
</li>
<li><p>五态模型</p>
<ul>
<li>新建态：进程刚被创建，尚未进入就绪队列</li>
<li>就绪态</li>
<li>运行态</li>
<li>阻塞态</li>
<li>终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统以及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171024552.png" alt="36"></p>
</li>
</ul>
<p>2）进程相关命令</p>
<ul>
<li>查看进程 <code>ps aux / ajx</code> a：显示终端上的所有进程，包括其他用户的进程 u：显示进程的详细信息 x：显示没有控制终端的进程 j：列出与作业控制相关的信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson<span class="meta"># ps aux</span></span><br><span class="line">USER  PID  %CPU  %MEM  VSZ  RSS  TTY  STAT  START  TIME  COMMAND</span><br><span class="line"></span><br><span class="line">root@iisayhi:~/lesson<span class="meta"># ps ajx</span></span><br><span class="line">PPID  PID  PGID  SID  TTY  TPGID  STAT  UID  TIME  COMMAND</span><br><span class="line">PPID - 父进程ID  </span><br><span class="line">PID  - 进程ID  </span><br><span class="line">PGID - 进程组的ID</span><br><span class="line">SID  - 会话的ID</span><br><span class="line">TTY  - 终端  </span><br></pre></td></tr></table></figure>

<ul>
<li>实时显示进程动态 <code>top</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171024495.png" alt="37"></p>
<ul>
<li>杀死进程<ul>
<li><code>kill [-signal] pid</code></li>
<li><code>kill –l</code> 列出所有信号</li>
<li><code>kill –SIGKILL</code> 进程ID</li>
<li><code>kill -9</code> 进程ID</li>
<li><code>killall name</code> 根据进程名杀死进程</li>
</ul>
</li>
</ul>
<p>3）进程相关</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025257.png" alt="38"></p>
<ul>
<li>父子进程虚拟地址空间情况</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid : %d\\n&quot;</span>, pid);</span><br><span class="line">        <span class="comment">// 若大于0，当前为父进程，并返回子进程的进程号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent procress, pid : %d, ppid : %d\\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 若等于0，当前为子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child procress, pid : %d, ppid : %d\\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d, pid : %d\\n&quot;</span>, i, getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。</span></span><br><span class="line"><span class="comment">写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</span></span><br><span class="line"><span class="comment">内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</span></span><br><span class="line"><span class="comment">只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</span></span><br><span class="line"><span class="comment">也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</span></span><br><span class="line"><span class="comment">注意：fork之后父子进程共享文件，</span></span><br><span class="line"><span class="comment">fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">root@iisayhi:~/lesson/lesson07<span class="meta"># gcc fork.c -o fork</span></span><br><span class="line">root@iisayhi:~/lesson/lesson07# ./fork</span><br><span class="line">pid : <span class="number">265418</span></span><br><span class="line">I am parent procress, pid : <span class="number">265417</span>, ppid : <span class="number">264856</span></span><br><span class="line">i : <span class="number">0</span>, pid : <span class="number">265417</span></span><br><span class="line">I am child procress, pid : <span class="number">265418</span>, ppid : <span class="number">265417</span></span><br><span class="line">i : <span class="number">0</span>, pid : <span class="number">265418</span></span><br><span class="line">i : <span class="number">1</span>, pid : <span class="number">265417</span></span><br><span class="line">i : <span class="number">1</span>, pid : <span class="number">265418</span></span><br><span class="line">i : <span class="number">2</span>, pid : <span class="number">265417</span></span><br><span class="line">i : <span class="number">2</span>, pid : <span class="number">265418</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025204.png" alt="39"></p>
<blockquote>
<p>Linux父子进程中变量地址相同——虚拟内存</p>
<p>csdn参考网址：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45636061/article/details/124610215?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124610215-blog-124260634.235%5Ev28%5Epc_relevant_t0_download&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124610215-blog-124260634.235%5Ev28%5Epc_relevant_t0_download&utm_relevant_index=2">虚拟内存</a></p>
<p><strong>物理内存和虚拟内存被分成了页框与页之后，其存储单元原来的地址都被自然地分成了两段，并且这两段各自代表着不同的意义：高位段分别叫做页框码和页码，它们是识别页框和页的编码；低位段分别叫做页框偏移量和页内偏移量，它们是存储单元在页框和页内的地址编码。</strong></p>
<p><strong>处理器遇到的地址都是虚拟地址。虚拟地址和物理地址都分成页码（页框码）和偏移值两部分。在由虚拟地址转化成物理地址的过程中，偏移值不变。而页码和页框码之间的映射就在一个映射记录表——页表中。</strong></p>
<p><strong>当程序执行fork()并创建子进程时，子进程会完全复制父进程的栈空间，包括页表，但没有复制物理页面，所以这时父子进程的变量地址相同，也即虚拟地址和物理地址相同。</strong></p>
<p>但是此时父子共享的页面仅标记为“只读”，在父子进程都没有访问内存时，二者共享一个页面。</p>
<p>当发生内存访问操作时，内核会复制一个物理页面给该进程，并修改其页表。同时把原来的只读页面标记为“可写”，留给另一个进程。以上即为所谓的“<strong>写时复制</strong>”或“<strong>写时拷贝</strong>”。</p>
</blockquote>
<ul>
<li><p>父子进程关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">父子进程之间的关系：</span><br><span class="line">    区别：</span><br><span class="line">        <span class="number">1.f</span>ork()函数的返回值不同</span><br><span class="line">            父进程中: &gt;<span class="number">0</span> 返回的子进程的ID</span><br><span class="line">            子进程中: =<span class="number">0</span></span><br><span class="line">        <span class="number">2.</span>pcb（进程控制块）中的一些数据</span><br><span class="line">            当前的进程的id pid</span><br><span class="line">            当前的进程的父进程的id ppid</span><br><span class="line">            信号集</span><br><span class="line"></span><br><span class="line">    共同点：</span><br><span class="line">        某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</span><br><span class="line">            - 用户区的数据</span><br><span class="line">            - 文件描述符表</span><br><span class="line">    </span><br><span class="line">    父子进程对变量是不是共享的？</span><br><span class="line">        - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。</span><br><span class="line">        - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。</span><br></pre></td></tr></table></figure>
</li>
<li><p>GDB多进程调试</p>
<ul>
<li><p>GDB默认只能跟踪一个进程，<strong>默认跟踪父进程</strong>。所以需要指令设置GDB跟踪的是父进程还是子进程</p>
</li>
<li><p>设置调试父进程或子进程：</p>
<ul>
<li><code>set follow-fork-mode [parent(默认) | child]</code></li>
</ul>
</li>
<li><p>设置调试模式</p>
<ul>
<li><pre><code>set detach-on-fork [on | off]
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      - `on`：调试当前进程时，其它进程继续运行；</span><br><span class="line">      - `off`：调试当前进程时，其它进程被GDB挂起。</span><br><span class="line"></span><br><span class="line">  - 查看调试的进程：</span><br><span class="line"></span><br><span class="line">    - `info inderiors`</span><br><span class="line"></span><br><span class="line">  - 切换当前调试的进程：</span><br><span class="line"></span><br><span class="line">    - `inferior id`</span><br><span class="line"></span><br><span class="line">  - 使进程脱离GDB调试：</span><br><span class="line"></span><br><span class="line">    - `detach inferiors id`</span><br><span class="line"></span><br><span class="line">## （3）exec函数族</span><br><span class="line"></span><br><span class="line">- **exec函数族**的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件</span><br><span class="line"></span><br><span class="line">- **exec函数族**的函数执行成功后不会返回，因为**调用进程的实体，包括代码段，数据段和堆栈等（即即将执行的可执行文件的用户区内容）都已经被新的内容取代**，只留下进程 ID 等一些表面上的信息仍保持原样；**只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行**</span><br><span class="line"></span><br><span class="line">- 函数原型：</span><br><span class="line"></span><br><span class="line">  ![40](https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025390.png)</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  #include &lt;unistd.h&gt;</span><br><span class="line">  int execl(const char *path, const char *arg, ...);</span><br><span class="line">      - 参数：</span><br><span class="line">          - path:需要指定的执行的文件的路径或者名称</span><br><span class="line">              a.out /home/nowcoder/a.out 推荐使用绝对路径</span><br><span class="line">              ./a.out hello world</span><br><span class="line">  </span><br><span class="line">          - arg:是执行可执行文件所需要的参数列表</span><br><span class="line">              第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="line">              从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="line">              参数最后需要以NULL结束（哨兵）</span><br><span class="line">  </span><br><span class="line">      - 返回值：</span><br><span class="line">          只有当调用失败，才会有返回值，返回-1，并且设置errno</span><br><span class="line">          如果调用成功，没有返回值。</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="（4）进程控制"><a href="#（4）进程控制" class="headerlink" title="（4）进程控制"></a>（4）进程控制</h2><p>1）进程退出</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025341.png" alt="41"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">    void exit(int status);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    void _exit(int status);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\\n&quot;</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exit(0); // 可打印hello world</span></span><br><span class="line">    _exit(<span class="number">0</span>);   <span class="comment">// 仅打印hello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分析：</span></span><br><span class="line">    <span class="comment">// 对于标准c库函数printf，首先会把其中的内容放入缓冲区</span></span><br><span class="line">    <span class="comment">// 当有\\n时，会对缓冲区进行刷新，从而就可以获取到hello这一内容</span></span><br><span class="line">    <span class="comment">// 而没有\\n时，world会首先被放到缓冲区，_exit也不会对缓冲区进行刷新，从而无法打印</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）孤儿进程</p>
<ul>
<li>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程<strong>（Orphan Process）</strong></li>
<li>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为<code>init</code>，而<code>init</code>进程会循环地 <code>wait()</code>已经退出的子进程。这样，当一个孤儿进程结束了其生命周期的时候，<code>init</code>进程就会处理它的一切善后工作</li>
<li>孤儿进程实际上无危害</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d, ppid : %d\\n&quot;</span>, getpid(), getppid());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 当前是子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d, ppid : %d\\n&quot;</span>, getpid(),getppid());</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d , pid : %d\\n&quot;</span>, i , getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">root@iisayhi:~/lesson/lesson08# ./orphan</span><br><span class="line">i am parent process, pid : <span class="number">275127</span>, ppid : <span class="number">272697</span></span><br><span class="line">i : <span class="number">0</span> , pid : <span class="number">275127</span></span><br><span class="line">i : <span class="number">1</span> , pid : <span class="number">275127</span></span><br><span class="line">i : <span class="number">2</span> , pid : <span class="number">275127</span></span><br><span class="line">root@iisayhi:~/lesson/lesson08<span class="meta"># i am child process, pid : 275128, **ppid : 1**</span></span><br><span class="line">i : <span class="number">0</span> , pid : <span class="number">275128</span></span><br><span class="line">i : <span class="number">1</span> , pid : <span class="number">275128</span></span><br><span class="line">i : <span class="number">2</span> , pid : <span class="number">275128</span></span><br></pre></td></tr></table></figure>

<p>3）僵尸进程</p>
<ul>
<li>每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。<strong>进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程</strong></li>
<li><strong>僵尸进程不能被</strong><code>kill -9</code><strong>杀死</strong>，因此如果父进程不调用<code>wait()</code>或<code>waitpid()</code>的话，那么保留的那段信息就不会释放，<strong>其进程号就会一直被占用</strong>，但是系统所能使用的进程号是有限的，<strong>如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免</strong></li>
</ul>
<p>4）wait &amp; waitpid</p>
<ul>
<li><p><strong>注意：一次<code>wait</code>或<code>waitpid</code>调用只能清理一个子进程，清理多个子进程应使用循环</strong></p>
</li>
<li><p><code>wait()</code></p>
<ul>
<li><code>wait()</code>函数会阻塞<strong>（阻塞的意思就是说，在子进程结束前，会一直阻塞在<code>wait()</code>函数处，等到子进程结束后才会继续向下执行）</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025019.png" alt="42"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *wstatus)</span>;</span><br><span class="line">    功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源。</span><br><span class="line">    参数：<span class="type">int</span> *wstatus</span><br><span class="line">        进程退出时的状态信息，传入的是一个<span class="type">int</span>类型的地址，传出参数。</span><br><span class="line">    返回值：</span><br><span class="line">        - 成功：返回被回收的子进程的id</span><br><span class="line">        - 失败：<span class="number">-1</span> (所有的子进程都结束，调用函数失败)</span><br><span class="line"></span><br><span class="line">调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span><br><span class="line">如果没有子进程了，函数立刻返回，返回<span class="number">-1</span>；如果子进程都已经结束了，也会立即返回，返回<span class="number">-1.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>waitpid()</code></p>
<ul>
<li><code>waitpid()</code>可以设置不阻塞<strong>（不阻塞的意思就是说，即使子进程还未结束，<code>waitpid()</code>也会立刻返回，程序可以接着往下执行）</strong>，<code>waitpid()</code>还可以指定等待哪个子进程结束</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line">    功能：回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="line">    参数：</span><br><span class="line">        - pid:</span><br><span class="line">            pid &gt; <span class="number">0</span> : 某个子进程的pid</span><br><span class="line">            pid = <span class="number">0</span> : 回收当前进程组的所有子进程    </span><br><span class="line">            pid = <span class="number">-1</span> : 回收所有的子进程，相当于 wait()  （最常用）</span><br><span class="line">            pid &lt; <span class="number">-1</span> : 某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="line">        - options：设置阻塞或者非阻塞</span><br><span class="line">            <span class="number">0</span> : 阻塞</span><br><span class="line">            WNOHANG : 非阻塞</span><br><span class="line">     返回值：</span><br><span class="line">        &gt; <span class="number">0</span> : 返回子进程的id</span><br><span class="line">        = <span class="number">0</span> : options=WNOHANG, 表示还有子进程或者</span><br><span class="line">        = <span class="number">-1</span> ：错误，或者没有子进程了</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="（5）进程间通信"><a href="#（5）进程间通信" class="headerlink" title="（5）进程间通信"></a>（5）进程间通信</h2><h3 id="1）匿名管道"><a href="#1）匿名管道" class="headerlink" title="1）匿名管道"></a>1）匿名管道</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">管道的读写特点：</span><br><span class="line">使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I/O操作）</span><br><span class="line">	<span class="number">1.</span>所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为<span class="number">0</span>），有进程从管道的读端</span><br><span class="line">	读数据，那么管道中剩余的数据被读取以后，再次read会返回<span class="number">0</span>，就像读到文件末尾一样。</span><br><span class="line">	</span><br><span class="line">	<span class="number">2.</span>如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于<span class="number">0</span>），而持有管道写端的进程</span><br><span class="line">	也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，</span><br><span class="line">	再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。</span><br><span class="line">	</span><br><span class="line">	<span class="number">3.</span>如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为<span class="number">0</span>），这个时候有进程</span><br><span class="line">	向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。</span><br><span class="line">	</span><br><span class="line">	<span class="number">4.</span>如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于<span class="number">0</span>），而持有管道读端的进程</span><br><span class="line">	也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，</span><br><span class="line">	直到管道中有空位置才能再次写入数据并返回。</span><br><span class="line">总结：</span><br><span class="line">	读管道：</span><br><span class="line">		管道中有数据，read返回实际读到的字节数。</span><br><span class="line">		管道中无数据：</span><br><span class="line">			写端被全部关闭，read返回<span class="number">0</span>（相当于读到文件的末尾）</span><br><span class="line">			写端没有完全关闭，read阻塞等待</span><br><span class="line">	</span><br><span class="line">	写管道：</span><br><span class="line">    管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）</span><br><span class="line">    管道读端没有全部关闭：</span><br><span class="line">        管道已满，write阻塞</span><br><span class="line">        管道没有满，write将数据写入，并返回实际写入的字节数</span><br></pre></td></tr></table></figure>

<h3 id="2）有名管道"><a href="#2）有名管道" class="headerlink" title="2）有名管道"></a>2）有名管道</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">有名管道的注意事项：</span><br><span class="line">	<span class="number">1.</span>一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</span><br><span class="line">	<span class="number">2.</span>一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</span><br><span class="line"></span><br><span class="line">读管道：</span><br><span class="line">    管道中有数据，read返回实际读到的字节数</span><br><span class="line">    管道中无数据：</span><br><span class="line">        写端被全部关闭，read返回<span class="number">0</span>（相当于读到文件末尾）</span><br><span class="line">        写端没有完全关闭，read阻塞等待</span><br><span class="line"></span><br><span class="line">写管道：</span><br><span class="line">    管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）</span><br><span class="line">    管道读端没有全部关闭：</span><br><span class="line">        管道已满，write阻塞</span><br><span class="line">        管道没有满，write将数据写入，并返回实际写入的字节数。</span><br></pre></td></tr></table></figure>

<ul>
<li>有名管道实现简单版聊天功能</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171026474.png" alt="43"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读数据</span></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">  ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">  <span class="comment">// ret = read(fdr, buf, strlen(buf)); 错误写法</span></span><br><span class="line">  <span class="keyword">if</span>(ret &lt;= <span class="number">0</span> )&#123;perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>read</code>函数的原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>fd</code>为文件描述符；<code>buf</code>表示读出数据缓冲区地址；<code>count</code>表示读出的字节数。</p>
<p>因此，若写成<code>ret = read(fdr, buf, strlen(buf))</code>，在当时所写程序中，最开始并未写入数据，因此读到的数据为空，则将报错</p>
<h2 id="（6）内存映射"><a href="#（6）内存映射" class="headerlink" title="（6）内存映射"></a>（6）内存映射</h2><p>内存映射（Memory-mapped I&#x2F;O）是将磁盘文件的数据映射到内存，用户通过修改 内存就能修改磁盘文件。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171026332.png" alt="44"></p>
<h1 id="7、阻塞-非阻塞-同步-异步"><a href="#7、阻塞-非阻塞-同步-异步" class="headerlink" title="7、阻塞&#x2F;非阻塞 &amp;&amp; 同步&#x2F;异步"></a>7、阻塞&#x2F;非阻塞 &amp;&amp; 同步&#x2F;异步</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lengxiao1993/article/details/78154467?ops_request_misc=%7B%22request_id%22:%22168319803316800182190279%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168319803316800182190279&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-78154467-null-null.142%5Ev86%5Ekoosearch_v1,239%5Ev2%5Einsert_chatgpt&utm_term=%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E&spm=1018.2226.3001.4187">阻塞与非阻塞_csdn</a></p>
<ul>
<li><p>阻塞（Blocking）与非阻塞（Nonblocking）是在数据就绪阶段进行判断</p>
<ul>
<li><p>阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。</p>
</li>
<li><p>非阻塞指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。当前线程可以去干别的事情。</p>
</li>
<li><p>sockfd对应操作系统中一个tcp缓冲区，阻塞与非阻塞都在该缓冲区中进行考虑。</p>
<blockquote>
<p><strong>阻塞IO和非阻塞IO的区别就在于</strong>： 应用程序的调用是否立即返回</p>
</blockquote>
</li>
</ul>
</li>
<li><p>同步（Synchronous）与非同步（Asynchronous）在数据读写阶段进行判断</p>
<ul>
<li><p>同步即应用程序自己从内核缓冲区中获取数据送入自己定义的buf中，只有数据获取结束之后应用程序才能进行其他的操作。</p>
</li>
<li><p>异步中有一个非常重要的“通知方式”，异步即为操作系统将数据从内核中送入自己定义的buf中，不需要我们自己操作，数据放好后通过“通知方式”告诉我们</p>
<blockquote>
<p><strong>同步IO</strong>：应用程序主动向内核查询是否有可用数据，如果有,当前进程自己负责把数据从内核copy到用户空间，拷贝的过程中进程阻塞。 <strong>异步IO</strong>：应用程序向内核发起读数据请求时需要：（1）告诉内核数据存放位置（2）注册回调函数，当内核完成数据copy后调用回调通知应用程序取数据。因为数据copy由内核完成的，所以拷贝的时候进程不阻塞。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="8、用户空间和内核空间"><a href="#8、用户空间和内核空间" class="headerlink" title="8、用户空间和内核空间"></a>8、用户空间和内核空间</h1><ul>
<li>内存空间的划分<ul>
<li>内核空间</li>
<li>用户空间</li>
</ul>
</li>
<li><strong>操作系统内核需要拥有高于普通进程的权限</strong>， 以此来调度和管理用户的应用程序，不同进程间相对独立。</li>
<li>硬件层面的内存访问权限控制细节：DPL&#x2F;CPL</li>
</ul>
<h1 id="9、进程切换与进程阻塞"><a href="#9、进程切换与进程阻塞" class="headerlink" title="9、进程切换与进程阻塞"></a>9、进程切换与进程阻塞</h1><ul>
<li>进程切换中几个最重要的步骤：</li>
</ul>
<p>1）当一个程序正在执行的过程中， 中断（interrupt） 或 系统调用（system call） 发生可以使得CPU的控制权会从当前进程转移到操作系统内核。</p>
<p>2）操作系统内核负责保存<code>进程i</code>在CPU中的上下文（程序计数器， 寄存器）到<code>PCBi</code>（操作系统分配给进程的一个内存块）中。</p>
<p>3）从<code>PCBj</code>取出<code>进程j</code>的CPU 上下文， 将 CPU 控制权转移给<code>进程j</code> ， 开始执行<code>进程j</code>的指令。</p>
<ul>
<li>中断<ul>
<li>在每个时钟周期末尾查询当前CPU中断位是否有中断信号送入，若有，判断当前正在执行的指令和中断信号的指令的优先级，决定执行哪个指令</li>
</ul>
</li>
<li>时钟中断<ul>
<li>一个硬件时钟会每隔一段（很短）的时间就产生一个中断信号发送给 CPU，CPU 在响应这个中断时， 就会去执行操作系统内核的指令， 继而将 CPU 的控制权转移给了操作系统内核， 可以由操作系统内核决定下一个要被执行的指令</li>
</ul>
</li>
<li>系统调用<ul>
<li>system call 是操作系统提供给应用程序的接口。 用户通过调用 system call 来完成那些需要操作系统内核进行的操作， 例如硬盘， 网络接口设备的读写等</li>
</ul>
</li>
<li><strong>对于一个运行着 UNIX 系统的现代 PC 来说， 进程切换至少需要花费 300 us 的时间</strong></li>
<li>进程阻塞<ul>
<li>我们所说的 “阻塞”是指进程在<strong>发起了一个系统调用</strong>（System Call） 后， 由于该系统调用的操作不能立即完成，需要等待一段时间，于是内核将进程挂起为等待 （waiting）状态， 以确保它不会被调度执行， 占用 CPU 资源。</li>
</ul>
</li>
</ul>
<h1 id="10、Unix-Linux上的五种IO模型"><a href="#10、Unix-Linux上的五种IO模型" class="headerlink" title="10、Unix&#x2F;Linux上的五种IO模型"></a>10、Unix&#x2F;Linux上的五种IO模型</h1><p>（1）<strong>（同步）阻塞 blocking</strong></p>
<p>阻塞即为：调用某函数后，必须等到该函数返回之后才能进行下一步动作。</p>
<p>（2）<strong>（同步）非阻塞 non-blocking</strong></p>
<p>非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。一旦内核中的数据准备好了，并且又再次收到了用户进程的请求，那么<strong>进程就会将内核中的数据拷贝到用户内存</strong>，然后返回。</p>
<p>非阻塞I&#x2F;O执行系统调用总是立即返回，不管事件是否已经发生。</p>
<p>（3）<strong>IO复用 IO multiplexing</strong></p>
<p>Linux 用 <code>select/poll/epoll</code> 函数实现 IO 复用模型。</p>
<p>这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。</p>
<p>（4）<strong>信号驱动 signal-driven</strong></p>
<p>Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到<code>SIGIO</code>信号，然后处理 IO 事件。</p>
<blockquote>
<p>多路复用和信号驱动的区别与联系：</p>
<ul>
<li>多路复用：内核们监听多个文件描述符，阻塞在监听的函数处（如<code>select/poll/epoll</code>），同时也阻塞在数据拷贝阶段。多路复用只是<strong>防止进程在某个io阻塞后，不能及时处理其他io的事件。</strong></li>
<li>信号驱动：先登记信号处理函数，当数据准备完毕后由内核发送信号给进程，让进程处理。信号驱动<strong>不阻塞在数据准备过程，但阻塞在数据拷贝</strong>。</li>
</ul>
</blockquote>
<p>💡 <strong>前四种方式都属于同步IO。</strong></p>
<p>（5）<strong>异步 asynchronous</strong></p>
<p>Linux中，可以调用 <code>aio_read</code> 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及<strong>通知的方式</strong>，然后<strong>立即返回</strong>，当内核将数据拷贝到缓冲区后，再通知应用程序。</p>
<h1 id="11、Web-Server（网页服务器）"><a href="#11、Web-Server（网页服务器）" class="headerlink" title="11、Web Server（网页服务器）"></a>11、<strong>Web Server（网页服务器）</strong></h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171026839.png" alt="45"></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/04/13/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95/" rel="prev" title="手撕算法">
      <i class="fa fa-chevron-left"></i> 手撕算法
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/04/24/Computer/C++/new%E4%B8%8Eoperator%20new/" rel="next" title="new与operator new">
      new与operator new <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81GCC%E5%AE%89%E8%A3%85"><span class="nav-text">1、GCC安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89GCC%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-text">（1）GCC相关知识点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89GCC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">（2）GCC工作流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-text">2、静态库和动态库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E9%9D%99%E6%80%81%E5%BA%93"><span class="nav-text">（1）静态库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-text">（2）动态库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">（3）静态库和动态库的对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81Makefile"><span class="nav-text">3、Makefile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81GDB%E8%B0%83%E8%AF%95"><span class="nav-text">4、GDB调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E6%96%87%E4%BB%B6I-O"><span class="nav-text">5、文件I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%A0%87%E5%87%86C%E5%BA%93IO%E5%87%BD%E6%95%B0"><span class="nav-text">（1）标准C库IO函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-text">（2）虚拟地址空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-text">（3）文件描述符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E3%80%81%E8%BF%9B%E7%A8%8B"><span class="nav-text">6、进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-text">（1）进程概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-text">（2）进程状态转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">（4）进程控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-text">（5）进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-text">1）匿名管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-text">2）有名管道</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-text">（6）内存映射</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7%E3%80%81%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5"><span class="nav-text">7、阻塞&#x2F;非阻塞 &amp;&amp; 同步&#x2F;异步</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8%E3%80%81%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="nav-text">8、用户空间和内核空间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9%E3%80%81%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E"><span class="nav-text">9、进程切换与进程阻塞</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10%E3%80%81Unix-Linux%E4%B8%8A%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="nav-text">10、Unix&#x2F;Linux上的五种IO模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11%E3%80%81Web-Server%EF%BC%88%E7%BD%91%E9%A1%B5%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89"><span class="nav-text">11、Web Server（网页服务器）</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="midorii"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">midorii</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">midorii</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">137k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:17</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
