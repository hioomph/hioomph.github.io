<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch_cat_logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/site_cat-32%C3%9732.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/site_cat-16%C3%9716.png">
  <link rel="mask-icon" href="/images/cat_logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="PPT Project Date    1-5 P0 &amp; P1 2.26-3.24   6-9 P2 3.24-   10-14 P3    15-21 P4    DBMS的磁盘管理模块主要解决两个问题：  如何使用磁盘文件来表示数据库的数据（元数据、索引、数据表等）； （Buffer Pool）如何管理数据在内存与磁盘之间的移动 空间控制（Spatio Control）：决定将p">
<meta property="og:type" content="article">
<meta property="og:title" content="cmu15-445 Course Related (Spring 2023)">
<meta property="og:url" content="http://example.com/2024/03/02/6%20%E9%A1%B9%E7%9B%AE/cmu15-445/cmu15-445%20Course%20Related%20(Spring%202023)/index.html">
<meta property="og:site_name" content="MIDORII&#39;S JOURNEY">
<meta property="og:description" content="PPT Project Date    1-5 P0 &amp; P1 2.26-3.24   6-9 P2 3.24-   10-14 P3    15-21 P4    DBMS的磁盘管理模块主要解决两个问题：  如何使用磁盘文件来表示数据库的数据（元数据、索引、数据表等）； （Buffer Pool）如何管理数据在内存与磁盘之间的移动 空间控制（Spatio Control）：决定将p">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-LZUa28zEosfmp4uFA77%2F-LZUJRryGLyHUdcOnhD0%2FScreen%20Shot%202019-02-24%20at%207.43.51%20PM.jpg?alt=media&token=5ca91d06-1e09-43be-afd2-5a52918ad9c9">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242055708.png">
<meta property="og:image" content="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-LZUa28zEosfmp4uFA77%2F-LZUP5rlT7qWNo8qYSuD%2FScreen%20Shot%202019-02-24%20at%208.08.44%20PM.jpg?alt=media&token=f492f425-12b9-47bc-af9a-b4e2430e12bf">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403021705443.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271651204.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242120365.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242120828.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242123712.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242123232.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242129786.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242134200.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242134195.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242134845.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242135620.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242135275.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242151303.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242154259.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251235897.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251235251.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251240293.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251241456.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251241413.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251242426.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251246471.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251249774.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251251222.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251253634.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251255541.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271610143.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271611923.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271629958.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271638410.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271648356.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271703469.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271947535.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271949041.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271953093.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403272000471.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403272000726.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403272001082.png">
<meta property="article:published_time" content="2024-03-02T08:47:42.312Z">
<meta property="article:modified_time" content="2024-07-16T03:14:12.774Z">
<meta property="article:author" content="midorii">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-LZUa28zEosfmp4uFA77%2F-LZUJRryGLyHUdcOnhD0%2FScreen%20Shot%202019-02-24%20at%207.43.51%20PM.jpg?alt=media&token=5ca91d06-1e09-43be-afd2-5a52918ad9c9">

<link rel="canonical" href="http://example.com/2024/03/02/6%20%E9%A1%B9%E7%9B%AE/cmu15-445/cmu15-445%20Course%20Related%20(Spring%202023)/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>cmu15-445 Course Related (Spring 2023) | MIDORII'S JOURNEY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MIDORII'S JOURNEY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">a little bit sweet</p>
      <a>
        <img class="custom-logo-image" src="/images/cat.jpeg" alt="MIDORII'S JOURNEY">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/02/6%20%E9%A1%B9%E7%9B%AE/cmu15-445/cmu15-445%20Course%20Related%20(Spring%202023)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          cmu15-445 Course Related (Spring 2023)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-02 16:47:42" itemprop="dateCreated datePublished" datetime="2024-03-02T16:47:42+08:00">2024-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-16 11:14:12" itemprop="dateModified" datetime="2024-07-16T11:14:12+08:00">2024-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE/cmu15-445/" itemprop="url" rel="index"><span itemprop="name">cmu15-445</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <table>
<thead>
<tr>
<th>PPT</th>
<th>Project</th>
<th>Date</th>
</tr>
</thead>
<tbody><tr>
<td>1-5</td>
<td>P0 &amp; P1</td>
<td>2.26-3.24</td>
</tr>
<tr>
<td>6-9</td>
<td>P2</td>
<td>3.24-</td>
</tr>
<tr>
<td>10-14</td>
<td>P3</td>
<td></td>
</tr>
<tr>
<td>15-21</td>
<td>P4</td>
<td></td>
</tr>
</tbody></table>
<p><code>DBMS</code>的磁盘管理模块主要解决两个问题：</p>
<ul>
<li>如何使用磁盘文件来表示数据库的数据（元数据、索引、数据表等）；</li>
<li>（<code>Buffer Pool</code>）如何管理数据在内存与磁盘之间的移动<ul>
<li>空间控制（<code>Spatio Control</code>）：决定将<code>pages</code>写入磁盘的哪个位置，使得尝尝一起使用的<code>pages</code>能离得更近，提高<code>I/O</code>效率；</li>
<li>时间控制（<code>Temporal Control</code>）：决定何时将<code>pages</code>读入内存，写回磁盘，使得读写的次数最小，从而提高<code>I/O</code>效率。</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p>整体图片：</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-LZUa28zEosfmp4uFA77%2F-LZUJRryGLyHUdcOnhD0%2FScreen%20Shot%202019-02-24%20at%207.43.51%20PM.jpg?alt=media&token=5ca91d06-1e09-43be-afd2-5a52918ad9c9" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242055708.png" alt="image-20240324205507545"></p>
<h1 id="1-Buffer-Pool"><a href="#1-Buffer-Pool" class="headerlink" title="1 Buffer Pool"></a>1 Buffer Pool</h1><h2 id="1-1-Buffer-Pool-Manager"><a href="#1-1-Buffer-Pool-Manager" class="headerlink" title="1.1 Buffer Pool Manager"></a>1.1 Buffer Pool Manager</h2><p><code>DBMS</code>启动时，从<code>OS</code>申请一片<strong>内存区域</strong>，即<code>Buffer Pool</code>，并把这块区域划分成大小相同的<code>pages</code>，通常称为 <code>frames</code>，当<code>DBMS</code>请求一个<code>disk page</code>时，它首先需要被复制到<code>Buffer Pool</code>的一个<code>frame</code>中。</p>
<p><code>Page Table</code>中存储的<code>meta-data</code>包括：</p>
<ul>
<li><p><code>page_table</code>：内存中的哈希表，跟踪当前在内存中的页面；</p>
</li>
<li><p><code>dirty flag</code>：当线程修改页面时设置（需要回写）；</p>
</li>
<li><p><code>pin count</code>：在有线程<strong>读页面</strong>时加<code>1</code>。</p>
</li>
</ul>
<p>当有线程需要**写<code>Page Table</code>**时，需要加一个<code>latch</code>。</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-LZUa28zEosfmp4uFA77%2F-LZUP5rlT7qWNo8qYSuD%2FScreen%20Shot%202019-02-24%20at%208.08.44%20PM.jpg?alt=media&token=f492f425-12b9-47bc-af9a-b4e2430e12bf" alt="img"></p>
<h3 id="locks和latches"><a href="#locks和latches" class="headerlink" title="locks和latches"></a>locks和latches</h3><p><code>Locks</code>（逻辑上的）</p>
<ul>
<li>保护<strong>数据库逻辑内容</strong>免受其他事务的影响</li>
<li>持有直到事务结束</li>
<li><strong>需要支持回滚</strong>（回滚即回到之前的版本状态）</li>
<li>保护元组（行），表，索引</li>
</ul>
<p><code>Latches/Mutex</code>（偏底层的）</p>
<ul>
<li>保护**<code>DBMS</code>内部数据结构**的关键部分不受其他线程的影响</li>
<li>持有直到一个操作结束</li>
<li><strong>不需要支持回滚</strong></li>
</ul>
<h3 id="scan-sharing"><a href="#scan-sharing" class="headerlink" title="scan sharing"></a>scan sharing</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403021705443.png" alt="image-20240302170551246" style="zoom:33%;" />

<p>图中的查询语句可能会导致<code>Q2</code>得不到自己真实想要的结果，需要加上<code>ORDER BY</code>限制才行。</p>
<p>假如有<code>Page0-Page199</code>，<code>scan sharing</code>可能导致：</p>
<ul>
<li><code>Q1</code>-&gt;<code>Page0-Page99</code></li>
<li><code>Q2</code>-&gt;<code>Page40-Page139</code></li>
</ul>
<h3 id="buffer-pool-bypass"><a href="#buffer-pool-bypass" class="headerlink" title="buffer pool bypass"></a>buffer pool bypass</h3><p>只需要调用一次的<code>page</code>，用完后直接丢弃，则可以不放入<code>buffer pool</code>。</p>
<h2 id="1-2-Buffer-Replacement-Policies"><a href="#1-2-Buffer-Replacement-Policies" class="headerlink" title="1.2 Buffer Replacement Policies"></a>1.2 Buffer Replacement Policies</h2><p>当<code>Buffer Pool</code>空间不足时，选择移除其中的哪些<code>pages</code>的问题。</p>
<h3 id="Least-Recently-Used-LRU"><a href="#Least-Recently-Used-LRU" class="headerlink" title="Least-Recently Used(LRU)"></a>Least-Recently Used(LRU)</h3><p><code>LRU</code>维护每个<code>page</code>上一次被访问的时间戳，每次移除时间戳最早的<code>page</code>。</p>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p><code>LRU</code>的近似实现。快速的<code>LRU</code>实现。</p>
<blockquote>
<p>但<code>LRU</code>和<code>Clock</code>容易被<code>sequential flooding</code>现象影响，从而导致最近被访问的<code>page</code>实际上却是最不可能需要的<code>page</code>。<strong>比如在全表扫描时，刚被访问的<code>page</code>实际上再访问完成后就不再需要了，因此反而成为了最不需要的<code>page</code>。</strong></p>
<p>为了解决这个问题，提出了<code>LRU-K</code>策略。</p>
</blockquote>
<h3 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h3><p><code>LRU-K</code>保存每个<code>page</code>的最后<code>K</code>次访问时间戳，利用这些时间戳来估计它们下次被访问的时间，通常<code>K</code>取<code>1</code>就能获得很好的效果。</p>
<p><strong>时间局部性原理：程序最近访问的地址在不久的将来很可能再次被访问。</strong></p>
<p><code>K</code>指的是最后第<code>K</code>次访问的距离，也就是倒数第<code>K</code>次访问时和最近一次访问的时间差。<code>LRU-K</code>算法主要是对比最后第<code>K</code>次的访问距离，访问距离越大则代表每次的访问间隔越长，因此更容易被替换出<code>cahce</code>。</p>
<ul>
<li><code>Correlated References Period</code>：指的是块首次访问后的一段时间。在这段时间以内的多次访问不会被记录，只有这段时间过后再次访问才会被记录。</li>
<li><code>Reference Retained Information Period</code>：指的是块被替换出<code>cache</code>后的一段时间。为了避免块被替换出<code>cache</code>后短时间内被反复重新访问、替换，因此对于替换出<code>cache</code>后的块会继续保留访问信息一段时间。</li>
</ul>
<h3 id="Dirty-Page"><a href="#Dirty-Page" class="headerlink" title="Dirty Page"></a>Dirty Page</h3><p><code>Dirty</code>：内存中的<code>page</code>和磁盘中的<code>page</code>有差别。</p>
<ul>
<li><p><code>FAST</code>：如果缓冲池中的页面不脏，那么<code>DBMS</code>可以简单地“删除”它；</p>
</li>
<li><p><code>SLOW</code>：如果页面是脏的，则<code>DBMS</code>必须写回磁盘以确保其更改是持久的。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f242bc1e95ff">MySQL的WAL（Write-Ahead Logging）机制</a></p>
<h2 id="1-3-Other-Memory-Pools"><a href="#1-3-Other-Memory-Pools" class="headerlink" title="1.3 Other Memory Pools"></a>1.3 Other Memory Pools</h2><p>除了存储<code>tuples</code>和<code>indexes</code>，<code>DBMS</code>还需要<code>Memory Pools</code>来存储其它数据：</p>
<ul>
<li><code>Sorting + Join Buffers</code></li>
<li><code>Query Caches</code></li>
<li><code>Maintenance Buffers</code></li>
<li><code>Log Buffers</code></li>
<li><code>Dictionary Caches</code></li>
</ul>
<h1 id="2-B-Tree-Index"><a href="#2-B-Tree-Index" class="headerlink" title="2 B+Tree Index"></a>2 B+Tree Index</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271651204.png" alt="image-20240327165111130"></p>
<h2 id="2-1-Hash-Tables"><a href="#2-1-Hash-Tables" class="headerlink" title="2.1 Hash Tables"></a>2.1 Hash Tables</h2><h3 id="2-1-1-Hash-Functions"><a href="#2-1-1-Hash-Functions" class="headerlink" title="2.1.1 Hash Functions"></a>2.1.1 Hash Functions</h3><p>由于<code>DBMS</code>内使用的<code>Hash Function</code>并不会暴露在外，因此<strong>没必要使用加密（<code>cryptographic</code>）哈希函数</strong>，我们希望它速度越快，<code>collision rate</code>越低越好。</p>
<p>目前各 DBMS 主要在用的 Hash Functions 包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/aappleby/smhasher">MurmurHash (2008)</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/cityhash">Google CityHash (2011)</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/farmhash">Google FarmHash (2014)</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lemire/clhash">CLHash (2016)</a></li>
</ul>
<h4 id="SHA256算法"><a href="#SHA256算法" class="headerlink" title="SHA256算法"></a>SHA256算法</h4><h3 id="2-1-2-Static-Hashing-Scheme"><a href="#2-1-2-Static-Hashing-Scheme" class="headerlink" title="2.1.2 Static Hashing Scheme"></a>2.1.2 Static Hashing Scheme</h3><p>（1）Linear Probe Hashing 开放地址哈希</p>
<p>“开放”的意思就是说：对于所有的key来说地址是开放的。碰撞时则往下一个地址存。</p>
<p>在删除时可能会因为前项被删除导致的空白，造成找不到当前项，这时有两个解决思路：</p>
<ul>
<li>Tombstone；</li>
<li>Movement</li>
</ul>
<p>重复key出现时的解决思路：</p>
<ul>
<li>Separate Linked List，把当前key作为指针指向一个新的区域：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242120365.png" alt="image-20240324212003301"></p>
<ul>
<li>Redundant Keys，把key和value拼在一起作为新的key：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242120828.png" alt="image-20240324212049757"></p>
<p>（2）Robin Hood Hashing，是开放地址哈希的变种，其基本思想是“劫富济贫”。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242123712.png" alt="image-20240324212329536"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242123232.png" alt="image-20240324212342001"></p>
<p>简单来说就是，当E和A碰撞时，正常E偏移3位，但为了不让自己比D“惨”太多，它就把D推到后面去，自己占了D的位置。此时D和E均为2。</p>
<p>（3）Cuckoo Hashing</p>
<blockquote>
<p>静态的哈希结构的问题在于需要DBMS能够预判所存数据的总量，否则每次数量超过范围时都需要重建 Hash Table。这显然是很困难的。</p>
</blockquote>
<h3 id="2-1-3-Dynamic-Hash-Tables"><a href="#2-1-3-Dynamic-Hash-Tables" class="headerlink" title="2.1.3 Dynamic Hash Tables"></a>2.1.3 Dynamic Hash Tables</h3><p>（1）Chained Hashing（※）</p>
<p>每个 key 对应一个链表，每个节点是一个 bucket，装满了就再往后挂一个 bucket。需要写操作时，需要请求 latch。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242129786.png" alt="image-20240324212955629"></p>
<ul>
<li>好处：简单；</li>
<li>坏处：最坏的情况下Hash Table可能降级为链表，操作的时间复杂度降格为 O(n)。</li>
</ul>
<p>（2）Extendible Hashing</p>
<p>Extendible Hashing 的基本思路是一边扩容，一边 rehash。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242134200.png" alt="image-20240324213443953"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242134195.png" alt="image-20240324213451869"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242134845.png" alt="image-20240324213459513"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242135620.png" alt="image-20240324213509210"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242135275.png" alt="image-20240324213516681"></p>
<p>（3）Linear Hashing</p>
<p>基本思想：维护一个指针，指向下一个将被拆分的 bucket，每当任意一个 bucket 溢出（标准自定，如利用率到达阈值等）时，将指针指向的 bucket 拆分。</p>
<h3 id="2-1-4-总结"><a href="#2-1-4-总结" class="headerlink" title="2.1.4 总结"></a>2.1.4 总结</h3><p>Hash Tables 提供 O(1)O(1) 的访问效率，因此它被大量地应用于 DBMS 的内部实现中。即便如此，它并不适合作为 table index 的数据结构，而 table index 的首选就是下节将介绍的 B+ Tree。</p>
<p><strong>哈希表对于范围索引是效率极低的。</strong></p>
<h2 id="2-2-Tree-Indexes（B-索引）"><a href="#2-2-Tree-Indexes（B-索引）" class="headerlink" title="2.2 Tree Indexes（B+索引）"></a>2.2 Tree Indexes（B+索引）</h2><blockquote>
<p>table index 为提供 DBMS 数据查询的快速索引，它本身存储着某表某列排序后的数据，并包含指向相应 tuple 的指针。DBMS 需要保证表信息与索引信息在逻辑上保持同步。用户可以在 DBMS 中为任意表建立多个索引，DBMS 负责选择最优的索引提升查询效率。但索引自身需要占用存储空间，因此在索引数量与索引存储、维护成本之间存在权衡。</p>
</blockquote>
<p>索引本质上就是一种小表，是把大表中的某些列抽取出来。</p>
<h3 id="2-2-1-B-Tree"><a href="#2-2-1-B-Tree" class="headerlink" title="2.2.1 B+ Tree"></a>2.2.1 B+ Tree</h3><p>B+ Tree 是一种自平衡树，它将数据有序地存储，且在 search、sequential access、insertions 以及 deletions 操作的复杂度上都满足 O(logn)，其中 sequential access 的最终复杂度还与所需数据总量有关。</p>
<blockquote>
<p>这里的O(logn)的意义在于，随着数据的增长，操作的复杂度增长是要慢于数据的增长速度的。比如数据增长到原来的2倍，但搜索时间不会变成原来的2倍。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242151303.png" alt="image-20240324215134042"></p>
<h4 id="B-Tree-Nodes"><a href="#B-Tree-Nodes" class="headerlink" title="B+ Tree Nodes"></a>B+ Tree Nodes</h4><p>B+ Tree 中的每个 node 都包含一列按 key 排好序的 key&#x2F;value pairs，key 就是 table index 对应的 column，value 的取值与 node 类型相关，在 inner nodes 和 leaf nodes 中存的内容不同。</p>
<p>values主要有两种存法：</p>
<ul>
<li>Record IDs，存储指向最终 tuple 的指针。</li>
<li>Tuple Data，直接将 tuple data 存在 leaf node 中。key为ID，v为整个行数据。如主键索引，其key为主键，value即为这张表的全部内容。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242154259.png" alt="image-20240324215455186"></p>
<h4 id="B-Tree-Operations"><a href="#B-Tree-Operations" class="headerlink" title="B+ Tree Operations"></a>B+ Tree Operations</h4><p><em>Insert</em></p>
<ol>
<li>找到对应的 leaf node，L</li>
<li>将 key&#x2F;value pair 按顺序插入到 L 中</li>
<li>如果 L 还有足够的空间，操作结束；如果空间不足，则需要将 L 分裂成两个节点，同时在 parent node 上新增 entry，若 parent node 也空间不足，则递归地分裂，直到 root node 为止。</li>
</ol>
<p><em>Delete</em></p>
<ol>
<li>从 root 开始，找到目标 entry 所处的 leaf node, L</li>
<li>删除该 entry</li>
<li>如果 L 仍然至少处于半满状态，则操作结束；否则先尝试从 siblings 那里拆借 entries，如果失败，则将 L 与相应的 sibling 合并</li>
<li>如果合并发生了，则可能需要递归地删除 parent node 中的 entry</li>
</ol>
<h4 id="Clustered-Indexes-聚簇索引"><a href="#Clustered-Indexes-聚簇索引" class="headerlink" title="Clustered Indexes 聚簇索引"></a>Clustered Indexes 聚簇索引</h4><h3 id="2-2-2-B-Tree-Design-Choices"><a href="#2-2-2-B-Tree-Design-Choices" class="headerlink" title="2.2.2 B+ Tree Design Choices"></a>2.2.2 B+ Tree Design Choices</h3><h4 id="Node-Size"><a href="#Node-Size" class="headerlink" title="Node Size"></a>Node Size</h4><p>通常来说，disk 的数据读取速度越慢，node size 就越大：</p>
<table>
<thead>
<tr>
<th>Disk Type</th>
<th>Node Size</th>
</tr>
</thead>
<tbody><tr>
<td>HDD</td>
<td>~1MB</td>
</tr>
<tr>
<td>SSD</td>
<td>~10KB</td>
</tr>
<tr>
<td>In-Memory</td>
<td>~512B</td>
</tr>
</tbody></table>
<p>具体情境下的最优大小由 workload 决定。</p>
<h4 id="Merge-Threshold"><a href="#Merge-Threshold" class="headerlink" title="Merge Threshold"></a>Merge Threshold</h4><p>由于 merge 操作引起的修改较大，有些 DBMS 选择延迟 merge 操作的发生时间，甚至可以利用其它进程来负责周期性地重建 table index。</p>
<h4 id="Variable-Length-Keys"><a href="#Variable-Length-Keys" class="headerlink" title="Variable Length Keys"></a>Variable Length Keys</h4><p>B+ Tree 中存储的 key 经常是变长的，通常有三种手段来应对：</p>
<ul>
<li>Pointers：存储指向 key 的指针；</li>
<li>Variable Length Nodes：需要精细的内存管理操作，不推荐；</li>
<li>Padding：给每个变长的key都强制转成一致的长度；</li>
<li>key Map：内嵌一个指针数组，指向 node 中的 key&#x2F;val list</li>
</ul>
<h4 id="Non-unique-Indexes-变长字段"><a href="#Non-unique-Indexes-变长字段" class="headerlink" title="Non-unique Indexes 变长字段"></a>Non-unique Indexes 变长字段</h4><p>索引针对的 key 可能是非唯一的，通常有两种手段来应对：</p>
<ul>
<li><p>Duplicate Keys：存储多次相同的 key；</p>
</li>
<li><p>Value Lists：每个 key 只出现一次，但同时维护另一个链表，存储 key 对应的多个 values，类似 chained hashing</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251235897.png" alt="image-20240325123534595"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251235251.png" alt="image-20240325123553069"></p>
<h4 id="Intra-node-Search-结点的内部搜素"><a href="#Intra-node-Search-结点的内部搜素" class="headerlink" title="Intra-node Search 结点的内部搜素"></a>Intra-node Search 结点的内部搜素</h4><p>在节点内部搜索，就是在排好序的序列中检索元素，手段通常有：</p>
<ul>
<li>Linear Scan，这种线性扫描虽然似乎很费时，但相比把page从磁盘读到内存的时间来看几乎已经不算什么了；</li>
<li>Binary Search，用二分来优化线性搜索；</li>
<li>Interpolation：通过 keys 的分布统计信息来估计大概位置进行检索</li>
</ul>
<h3 id="2-2-3-Optimizations"><a href="#2-2-3-Optimizations" class="headerlink" title="2.2.3 Optimizations"></a>2.2.3 Optimizations</h3><h4 id="Prefix-Compression"><a href="#Prefix-Compression" class="headerlink" title="Prefix Compression"></a>Prefix Compression</h4><p>同一个 leaf node 中的 keys 通常有相同的 prefix，如下图所示。为了节省空间，可以只存所有 keys 的不同的 suffix。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251240293.png" alt="image-20240325124020194"></p>
<h4 id="Suffix-Truncation"><a href="#Suffix-Truncation" class="headerlink" title="Suffix Truncation"></a>Suffix Truncation</h4><p>由于 inner nodes 只用于引导搜索，因此没有必要在 inner nodes 中储存完整的 key，我们可以<strong>只存储足够的 prefix 即可</strong>，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251241456.png" alt="image-20240325124132291"></p>
<h4 id="Bulk-Insert"><a href="#Bulk-Insert" class="headerlink" title="Bulk Insert"></a>Bulk Insert</h4><p>建 B+ Tree 的最快方式是先将 keys 排好序后，再从下往上建树，如下图所示。因此如果有<strong>大量插入操作</strong>，可以利用这种方式提高效率。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251241413.png" alt="image-20240325124150282"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251242426.png" alt="image-20240325124207283"></p>
<h4 id="Pointer-Swizzling"><a href="#Pointer-Swizzling" class="headerlink" title="Pointer Swizzling"></a>Pointer Swizzling</h4><p>Nodes 使用 page id 来存储其它 nodes 的引用，DBMS 每次需要首先从 page table 中获取对应的内存地址，然后才能获取相应的 nodes 本身，如果 page 已经在 buffer pool 中，我们可以直接存储其它 page 在 buffer pool 中的内存地址作为引用，从而提高访问效率。</p>
<h2 id="2-3-Index-Concurrency-Control"><a href="#2-3-Index-Concurrency-Control" class="headerlink" title="2.3 Index Concurrency Control"></a>2.3 Index Concurrency Control</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251246471.png" alt="image-20240325124646316"></p>
<h3 id="2-3-1-Latch-Modes"><a href="#2-3-1-Latch-Modes" class="headerlink" title="2.3.1 Latch Modes"></a>2.3.1 Latch Modes</h3><h4 id="Read-Mode"><a href="#Read-Mode" class="headerlink" title="Read Mode"></a>Read Mode</h4><ul>
<li>多个线程可以同时读取相同的数据</li>
<li>针对相同的数据，当别的线程已经获得处于 read mode 的 latch，新的线程也可以继续获取 read mode 的 latch</li>
</ul>
<h4 id="Write-Mode"><a href="#Write-Mode" class="headerlink" title="Write Mode"></a>Write Mode</h4><ul>
<li>同一时间只有单个线程可以访问</li>
<li>针对相同的数据，如果获取前已经有别的线程获得任何 mode 的 latch，新的线程就无法获取 write mode  的 latch</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251249774.png" alt="image-20240325124932586"></p>
<p><strong>锁的实现：</strong></p>
<ul>
<li><p>Blocking OS Mutex：如std::mutex，好处是竞争的线程会陷入sleep，但坏处是需要OS去进行唤醒，极度浪费资源；</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251251222.png" alt="image-20240325125111105"></p>
</li>
<li><p>Test-ans-Set Spin Latch(TAS)：自旋锁，如std::atomic<T>，不需要OS操作，自己在死循环内不断旋转，直到可以获取到该锁；</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251253634.png" alt="image-20240325125323436"></p>
</li>
<li><p>Reader-Writer Latches：自旋锁的基础上实现。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251255541.png" alt="image-20240325125549330"></p>
<p>这里注意：若有线程需要加写锁，那么此时如果再有线程希望加读锁也会被阻塞。只有等之前的读锁都释放，写锁成功加上后，后续的读锁才能正常上锁。（这样做是为了避免写锁被无止境地锁住）</p>
</li>
</ul>
<h4 id="hash-table-latching"><a href="#hash-table-latching" class="headerlink" title="hash table latching"></a><strong>hash table latching</strong></h4><p>相较于B+ Tree，Hash Table不容易遇到死锁，尤其是开放地址哈希，因为大家都是朝着一个方向去进行的。一般在扩容（resize）操作时，加一个全局的写锁，因为此时哈希表内部的数据需要进行一个整理。</p>
<ul>
<li>page latches：块与块之间的锁独立。线程会给所有块加分段锁。例如下图，块1的写锁和块2的读锁独立。这样的优势是：1）锁的粒度不会太细；2）支持一定的并发操作。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271610143.png" alt="image-20240327161025853"></p>
<ul>
<li><p>slot latches：以槽为单位进行加锁。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271611923.png" alt="image-20240327161157762"></p>
</li>
<li><p>compare-and-swap，CAS，使得hash table实现无锁插入。例如下图：让os先0判断是否为20，若是再加到30，属于原子操作。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271629958.png" alt="image-20240327162902774"></p>
</li>
</ul>
<h3 id="2-3-2-Index-Crabbing-Coupling"><a href="#2-3-2-Index-Crabbing-Coupling" class="headerlink" title="2.3.2 Index Crabbing&#x2F;Coupling"></a>2.3.2 Index Crabbing&#x2F;Coupling</h3><p>B+Tree考虑两方面的并发问题：</p>
<ul>
<li>1）结点内部的数据，即多个线程同时修改一个node；</li>
<li>2）结点间的合并和分裂操作，即一个线程正在遍历 B+ Tree 的同时，另一个线程正在 splits&#x2F;merges nodes。</li>
</ul>
<p><strong>Latch Crabbing 的基本思想如下：</strong></p>
<ul>
<li>获取 parent 的 latch</li>
<li>获取 child 的 latch</li>
<li>如果<strong>安全</strong>，可以释放 parent 的 latch</li>
</ul>
<p><strong>这里的“安全”指的是，当发生更新操作时，该节点不会发生 split 或 merge 的操作，即：</strong></p>
<ul>
<li>在插入元素时，节点未满</li>
<li>在删除元素时，节点超过半满</li>
</ul>
<p>按照上述方法，无论对叶子结点执行何种操作，第一步都是先锁住根节点，这是一种“悲观”的做法。“乐观”的做法是：一路加读锁，最后加写锁。当然也有可能出现到了最后一步，发现会改动前面的parent，因此需要放弃当前的操作，重新从root开始加写锁。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271638410.png" alt="image-20240327163836210"></p>
<h3 id="2-3-3-Leaf-Scans"><a href="#2-3-3-Leaf-Scans" class="headerlink" title="2.3.3 Leaf Scans"></a>2.3.3 Leaf Scans</h3><p>之前的分析中我们仅仅关注了从上到下的访问模式，而没有考虑到左右方向的访问模式，在 range query 中，常常需要横向访问相邻的 nodes。</p>
<p>当遇到横向扫描无法获取下一个节点的 latch 时，该线程将释放 latch 后自杀。这种策略逻辑简单，尽管有理论上的优化空间，但在实践中是常见的避免死锁的方式。</p>
<h3 id="2-3-4-Delayed-Parent-Updates"><a href="#2-3-4-Delayed-Parent-Updates" class="headerlink" title="2.3.4 Delayed Parent Updates"></a>2.3.4 Delayed Parent Updates</h3><p>从上文中，我们可以观察到：每当 leaf node 溢出时，我们都需要更新至少 3 个节点：</p>
<ul>
<li>即将被拆分的 leaf node</li>
<li>新的 leaf node</li>
<li>parent node</li>
</ul>
<p>修改的成本较高，因此 B-link Tree 提出了一种优化策略：<strong>每当 leaf node 溢出时，只是标记一下而暂时不更新 parent node，等下一次有别的线程获取 parnet node 的 write latch 时，一并修改。</strong></p>
<h2 id="2-4-Sorting-and-Aggregations"><a href="#2-4-Sorting-and-Aggregations" class="headerlink" title="2.4 Sorting and Aggregations"></a>2.4 Sorting and Aggregations</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271648356.png" alt="image-20240327164819130"></p>
<p>一个disk-oriented DBMS不能假定query results和内存大小完全适配。有可能筛选出来的query results也需要存到磁盘中，和buffer pool互相配合来实现操作。需要最大化利用sequential I&#x2F;O。</p>
<p><strong>为什么需要排序：关系型数据库是unsorted的。</strong></p>
<h3 id="2-4-1-Sorting-Algorithm"><a href="#2-4-1-Sorting-Algorithm" class="headerlink" title="2.4.1 Sorting Algorithm"></a>2.4.1 Sorting Algorithm</h3><ul>
<li>early materialization：排序时value直接存储当前key那一行的剩余数据；</li>
<li>later materialization：排序时value存储ID值。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271703469.png" alt="image-20240327170300327"></p>
<h4 id="External-Merge-Sort"><a href="#External-Merge-Sort" class="headerlink" title="External Merge Sort"></a>External Merge Sort</h4><p>外部排序通常有两个步骤：</p>
<p>1、Sorting Phase：将数据分成多个 chunks，每个 chunk 可以完全读入到 memory 中，在 memory 中排好序后再写回到 disk 中</p>
<p>2、Merge Phase：将多个子文件合并成一个大文件</p>
<ul>
<li><p>2-Way External Merge Sort：这里的“2-way”即是指每次读入两页。</p>
</li>
<li><p>General External Merge Sort：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271947535.png" alt="image-20240327194734264"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271949041.png" alt="image-20240327194933847"></p>
</li>
</ul>
<h4 id="Using-B-Tree-for-Sorting"><a href="#Using-B-Tree-for-Sorting" class="headerlink" title="Using B+Tree for Sorting"></a>Using B+Tree for Sorting</h4><p>注意包含聚簇和非聚簇两种情况。</p>
<h3 id="2-4-2-Aggregations"><a href="#2-4-2-Aggregations" class="headerlink" title="2.4.2 Aggregations"></a>2.4.2 Aggregations</h3><h4 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271953093.png" alt="image-20240327195346706"></p>
<p>但很多时候我们并不需要排好序的数据，如：</p>
<ul>
<li>Forming groups in GROUP BY</li>
<li>Removing duplicates in DISTINCT</li>
</ul>
<p>在这样的场景下 hashing 是更好的选择，它能有效减少排序所需的额外工作。</p>
<h4 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h4><p>利用一个临时 (ephemeral) 的 hash table 来记录必要的信息，即检查 hash table 中是否存在已经记录过的元素并作出相应操作：</p>
<ul>
<li>DISTINCT: Discard duplicate</li>
<li>GROUP BY: Perform aggregate computation</li>
</ul>
<p>如果所有信息都能一次性读入内存，那事情就很简单了，但如若不然，我们就得变得更聪明。</p>
<p>hashing aggregation 同样分成两步：</p>
<ul>
<li>Partition Phase: 将 tuples 根据 hash key 放入不同的 buckets<ul>
<li>use a hash function h1 to split tuples into partitions on disk<ul>
<li>all matches live in the same partition</li>
<li>partitions are “spilled” to disk via output buffers</li>
</ul>
</li>
<li>这里有个额外的假设，即每个 partition 能够被放到 memory 中</li>
</ul>
</li>
<li>ReHash Phase: 在内存中针对每个 partition 利用 hash table 计算 aggregation 的结果</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403272000471.png" alt="image-20240327200043163"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403272000726.png" alt="image-20240327200052468"></p>
<p>在 ReHash phase 中，存着 (GroupKey→RunningVal)(GroupKey→RunningVal) 的键值对，当我们需要向 hash table 中插入新的 tuple 时：</p>
<ul>
<li>如果我们发现相应的 GroupKey 已经在内存中，只需要更新 RunningVal 就可以</li>
<li>反之，则插入新的 GroupKey 到 RunningVal 的键值对</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403272001082.png" alt="image-20240327200117774"></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/03/02/6%20%E9%A1%B9%E7%9B%AE/cmu15-445/cmu15-445%20Project%201%20(Spring%202023)/" rel="prev" title="cmu15-445 Project 1 (Spring 2023)">
      <i class="fa fa-chevron-left"></i> cmu15-445 Project 1 (Spring 2023)
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/03/27/6%20%E9%A1%B9%E7%9B%AE/cmu15-445/cmu15-445%20Project%202%20(Spring%202023)/" rel="next" title="cmu15-445 Project 2 (Spring 2023)">
      cmu15-445 Project 2 (Spring 2023) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Buffer-Pool"><span class="nav-text">1 Buffer Pool</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Buffer-Pool-Manager"><span class="nav-text">1.1 Buffer Pool Manager</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#locks%E5%92%8Clatches"><span class="nav-text">locks和latches</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scan-sharing"><span class="nav-text">scan sharing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buffer-pool-bypass"><span class="nav-text">buffer pool bypass</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Buffer-Replacement-Policies"><span class="nav-text">1.2 Buffer Replacement Policies</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Least-Recently-Used-LRU"><span class="nav-text">Least-Recently Used(LRU)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Clock"><span class="nav-text">Clock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LRU-K"><span class="nav-text">LRU-K</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dirty-Page"><span class="nav-text">Dirty Page</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Other-Memory-Pools"><span class="nav-text">1.3 Other Memory Pools</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-B-Tree-Index"><span class="nav-text">2 B+Tree Index</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Hash-Tables"><span class="nav-text">2.1 Hash Tables</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-Hash-Functions"><span class="nav-text">2.1.1 Hash Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SHA256%E7%AE%97%E6%B3%95"><span class="nav-text">SHA256算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-Static-Hashing-Scheme"><span class="nav-text">2.1.2 Static Hashing Scheme</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-Dynamic-Hash-Tables"><span class="nav-text">2.1.3 Dynamic Hash Tables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4-%E6%80%BB%E7%BB%93"><span class="nav-text">2.1.4 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-Tree-Indexes%EF%BC%88B-%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="nav-text">2.2 Tree Indexes（B+索引）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-B-Tree"><span class="nav-text">2.2.1 B+ Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B-Tree-Nodes"><span class="nav-text">B+ Tree Nodes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-Tree-Operations"><span class="nav-text">B+ Tree Operations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Clustered-Indexes-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-text">Clustered Indexes 聚簇索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-B-Tree-Design-Choices"><span class="nav-text">2.2.2 B+ Tree Design Choices</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-Size"><span class="nav-text">Node Size</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Merge-Threshold"><span class="nav-text">Merge Threshold</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Variable-Length-Keys"><span class="nav-text">Variable Length Keys</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Non-unique-Indexes-%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5"><span class="nav-text">Non-unique Indexes 变长字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Intra-node-Search-%E7%BB%93%E7%82%B9%E7%9A%84%E5%86%85%E9%83%A8%E6%90%9C%E7%B4%A0"><span class="nav-text">Intra-node Search 结点的内部搜素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-Optimizations"><span class="nav-text">2.2.3 Optimizations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Prefix-Compression"><span class="nav-text">Prefix Compression</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Suffix-Truncation"><span class="nav-text">Suffix Truncation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bulk-Insert"><span class="nav-text">Bulk Insert</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pointer-Swizzling"><span class="nav-text">Pointer Swizzling</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-Index-Concurrency-Control"><span class="nav-text">2.3 Index Concurrency Control</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-Latch-Modes"><span class="nav-text">2.3.1 Latch Modes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Read-Mode"><span class="nav-text">Read Mode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Write-Mode"><span class="nav-text">Write Mode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hash-table-latching"><span class="nav-text">hash table latching</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-Index-Crabbing-Coupling"><span class="nav-text">2.3.2 Index Crabbing&#x2F;Coupling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-Leaf-Scans"><span class="nav-text">2.3.3 Leaf Scans</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-Delayed-Parent-Updates"><span class="nav-text">2.3.4 Delayed Parent Updates</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-Sorting-and-Aggregations"><span class="nav-text">2.4 Sorting and Aggregations</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-Sorting-Algorithm"><span class="nav-text">2.4.1 Sorting Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#External-Merge-Sort"><span class="nav-text">External Merge Sort</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-B-Tree-for-Sorting"><span class="nav-text">Using B+Tree for Sorting</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-Aggregations"><span class="nav-text">2.4.2 Aggregations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Sorting"><span class="nav-text">Sorting</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hashing"><span class="nav-text">Hashing</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="midorii"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">midorii</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">midorii</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">162k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:49</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
