<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch_cat_logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/site_cat-32%C3%9732.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/site_cat-16%C3%9716.png">
  <link rel="mask-icon" href="/images/cat_logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、线程与进程1、进程和线程以及并发和并行的概念是什么？进程：  进程是系统资源分配的最小单位； 进程在 Linux 中通过 fork 系统调用创建，子进程拥有独立的内存空间。每个进程有独立的进程控制块 PCB，包含进程状态、寄存器、内存管理信息等。  线程：  线程是操作系统中的最小执行单元； 线程在 Linux 中通过 pthread_create 创建，每个线程都有独立的线程控制块 TC">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://example.com/2024/06/12/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="MIDORII&#39;S JOURNEY">
<meta property="og:description" content="一、线程与进程1、进程和线程以及并发和并行的概念是什么？进程：  进程是系统资源分配的最小单位； 进程在 Linux 中通过 fork 系统调用创建，子进程拥有独立的内存空间。每个进程有独立的进程控制块 PCB，包含进程状态、寄存器、内存管理信息等。  线程：  线程是操作系统中的最小执行单元； 线程在 Linux 中通过 pthread_create 创建，每个线程都有独立的线程控制块 TC">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407032203672.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406131948229.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301943905.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/ffb6e1727e2289f142f6a2a6291cd68c.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/532e6cdf4899588f8b873b6435cba2d8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301519980.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406302002710.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301556491.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301556054.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301606610.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301607955.png">
<meta property="article:published_time" content="2024-06-12T09:03:47.949Z">
<meta property="article:modified_time" content="2024-07-06T08:17:51.136Z">
<meta property="article:author" content="midorii">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407032203672.png">

<link rel="canonical" href="http://example.com/2024/06/12/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统 | MIDORII'S JOURNEY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MIDORII'S JOURNEY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">a little bit sweet</p>
      <a>
        <img class="custom-logo-image" src="/images/cat.jpeg" alt="MIDORII'S JOURNEY">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/12/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-12 17:03:47" itemprop="dateCreated datePublished" datetime="2024-06-12T17:03:47+08:00">2024-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-06 16:17:51" itemprop="dateModified" datetime="2024-07-06T16:17:51+08:00">2024-07-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>35k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2:08</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <span id="more"></span>

<h2 id="一、线程与进程"><a href="#一、线程与进程" class="headerlink" title="一、线程与进程"></a>一、线程与进程</h2><h3 id="1、进程和线程以及并发和并行的概念是什么？"><a href="#1、进程和线程以及并发和并行的概念是什么？" class="headerlink" title="1、进程和线程以及并发和并行的概念是什么？"></a>1、进程和线程以及并发和并行的概念是什么？</h3><p><strong>进程</strong>：</p>
<ul>
<li>进程是系统资源分配的最小单位；</li>
<li>进程在 Linux 中通过 <code>fork</code> 系统调用创建，子进程拥有独立的内存空间。每个进程有独立的进程控制块 PCB，包含进程状态、寄存器、内存管理信息等。</li>
</ul>
<p><strong>线程</strong>：</p>
<ul>
<li>线程是操作系统中的最小执行单元；</li>
<li>线程在 Linux 中通过 <code>pthread_create</code> 创建，每个线程都有独立的线程控制块 TCB，但共享进程的资源。</li>
</ul>
<p><strong>并发和并行</strong>：并发是在单个处理器上多个任务交替执行，实现多个线程同时执行的假象；而并行是在多个处理器上实现多个线程同时执行。</p>
<blockquote>
<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，<strong>一个进程崩溃后，在保护模式下不会对其它进程产生影响</strong>，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，<strong>一个线程死掉就等于整个进程死掉</strong>，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<p>在 Linux 中，<strong>线程不会拥有独立的内存空间。所有线程共享进程的虚拟地址空间，但每个线程拥有自己独立的栈空间和寄存器集合。</strong>共享内存空间使得线程之间的通信比进程间通信更加高效，但也意味着需要通过同步机制（如互斥锁）来保护共享资源，防止竞态条件。</p>
</blockquote>
<h3 id="【-】2、线程比进程具有哪些优势？"><a href="#【-】2、线程比进程具有哪些优势？" class="headerlink" title="【*】2、线程比进程具有哪些优势？"></a>【*】2、线程比进程具有哪些优势？</h3><ol>
<li>线程在程序中是独立的，并发的执行流，只是同一进程中的多个线程间的隔离程度较小；</li>
<li>当操作系统创建⼀个进程时，必须为进程分配独立的内存空间，并分配大量相关资源；但对于同一进程中的多个线程来说，它们共享进程的虚拟地址空间，每个线程只拥有自己独立的栈空间和寄存器集合。</li>
</ol>
<h3 id="【-】3、什么时候用多进程？什么时候用多线程？"><a href="#【-】3、什么时候用多进程？什么时候用多线程？" class="headerlink" title="【*】3、什么时候用多进程？什么时候用多线程？"></a>【*】3、什么时候用多进程？什么时候用多线程？</h3><ol>
<li><p>需要<strong>频繁创建销毁</strong>的优先用线程；</p>
<p>线程的创建和销毁相对于进程来说更为轻量级，开销更小。线程共享同一个进程的地址空间，可以快速创建和销毁，而进程创建时需要分配独立的地址空间，并且系统调用的开销较大。</p>
</li>
<li><p>需要<strong>进行大量计算</strong>的优先使用线程；</p>
<p>大量计算任务通常需要频繁访问和操作内存。线程共享同一个进程的地址空间，可以快速访问共享数据，避免了进程间通信的开销。另外，线程之间的上下文切换速度较快，更适合 CPU 密集型的计算任务。</p>
</li>
<li><p><strong>强相关的处理</strong>用线程，<strong>弱相关的处理</strong>用进程；</p>
<p>强相关的处理通常需要频繁访问和操作相同的数据。由于线程共享同一地址空间，数据共享和同步相对简单，适合处理强相关的任务。弱相关的处理任务之间相对独立，进程之间互不干扰，独立的地址空间增加了隔离性和安全性，因此弱相关的处理任务使用进程更加合适。</p>
</li>
<li><p>可能要扩展到<strong>多机分布</strong>的用进程，<strong>多核分布</strong>的用线程。</p>
<p><strong>多机分布要求任务能够在不同的物理机器上独立运行</strong>。进程具有独立的地址空间和资源，可以在不同机器之间通过网络进行通信，适合分布式系统。而<strong>多核分布则是指在同一台多核机器上进行并行处理</strong>。线程共享同一进程的地址空间，能够在多核 CPU 上高效运行，利用多核的并行计算能力。</p>
</li>
</ol>
<h3 id="【-】4、线程内存存储在哪里？"><a href="#【-】4、线程内存存储在哪里？" class="headerlink" title="【*】4、线程内存存储在哪里？"></a>【*】4、线程内存存储在哪里？</h3><ol>
<li><strong>线程栈</strong>（Thread Stack）：每个线程都有自己的栈空间，这是线程存储本地变量、函数参数和返回地址的地方。线程栈通常有固定的大小，这个大小可以在创建线程时指定，也可能由操作系统预设。这部分内存通常位于用户空间的栈内存中。</li>
<li><strong>寄存器集</strong>：包括程序计数器、堆栈指针和其他必要的硬件寄存器。这些通常是在处理器内部维护的，并且每个线程都有自己的寄存器状态。</li>
<li><strong>线程局部存储（TLS）</strong>：这是一种允许数据在多个线程之间被隔离的机制。每个线程可以访问自己的专用数据副本，对其他线程不可见。这在编程中用于保持数据的线程安全性。</li>
<li><strong>线程控制块（TCB）</strong>：这是一个内核数据结构，包含了管理线程所需的所有信息，如线程的状态、优先级、调度信息等。线程控制块通常存储在操作系统内核的内存中。</li>
</ol>
<p>这些部分合在一起定义了一个线程的运行环境。每个线程的栈是独立的，但它们共享进程的堆和其他全局资源。</p>
<h3 id="5、线程中的锁包含哪些？"><a href="#5、线程中的锁包含哪些？" class="headerlink" title="5、线程中的锁包含哪些？"></a>5、线程中的锁包含哪些？</h3><ol>
<li><strong>互斥锁</strong>：用于对共享资源的互斥访问。当有线程对该资源加了互斥锁后，其他线程尝试加锁时会被阻塞，直至锁被释放。</li>
<li><strong>递归锁</strong>：是一种特殊的互斥锁，当有同一个线程尝试对同一个线程不断加锁时，不会被阻塞。</li>
<li><strong>读写锁</strong>：允许多个线程同时进行读操作，但仅允许一个线程进行写操作，使用在读多于写的场景。</li>
<li><strong>自旋锁</strong>：当有线程对资源加了自旋锁后，其他线程尝试加锁时将忙等待，而非被阻塞。</li>
</ol>
<h3 id="6、什么是死锁？"><a href="#6、什么是死锁？" class="headerlink" title="6、什么是死锁？"></a>6、什么是死锁？</h3><p><strong>死锁</strong>（Deadlock）是指在多线程或多进程的环境中，两个或多个执行单元因为争夺资源而造成的一种相互等待的现象，如果没有外力干涉，这些进程将无法向前推进。</p>
<h3 id="【-】7、死锁产生的原因"><a href="#【-】7、死锁产生的原因" class="headerlink" title="【*】7、死锁产生的原因"></a>【*】7、死锁产生的原因</h3><p>死锁产生主要有以下几个条件，这些条件<strong>同时满足</strong>时，就可能发生死锁：</p>
<ol>
<li><strong>互斥条件</strong>：资源不能被多个线程（或进程）共享，只能被一个线程（或进程）所占用。</li>
<li><strong>请求与保持条件</strong>：线程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他线程占有。</li>
<li><strong>不剥夺条件</strong>：线程所获得的资源在未使用完之前，不能被其他线程强行剥夺。</li>
<li><strong>循环等待条件</strong>：存在一种线程资源循环等待链，每个线程占有一种资源并等待另一种被下一个线程占有的资源。</li>
</ol>
<h3 id="8、如何避免死锁？"><a href="#8、如何避免死锁？" class="headerlink" title="8、如何避免死锁？"></a>8、如何避免死锁？</h3><ol>
<li>系统对进程发出每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源。如果分配后系统可能发生死锁，则不予分配，否则予以分配。保证系统不进入死锁状态的动态策略。</li>
<li>在系统设计、进程调度等方面注意如何让这四个必要条件不成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</li>
</ol>
<h3 id="9、如果有两个线程-1、2-去访问同一个资源-C-，并且二者必须同时获取锁-A-和-B-才可以访问-C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？"><a href="#9、如果有两个线程-1、2-去访问同一个资源-C-，并且二者必须同时获取锁-A-和-B-才可以访问-C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？" class="headerlink" title="9、如果有两个线程 1、2 去访问同一个资源 C ，并且二者必须同时获取锁 A 和 B 才可以访问 C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？"></a>9、如果有两个线程 1、2 去访问同一个资源 C ，并且二者必须同时获取锁 A 和 B 才可以访问 C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？</h3><pre><code>  1. 如果两个线程同时去分别获取不同的锁时，会出现死锁，比如线程 1 先获得锁 A 而线程 2 先获得锁 B，然后二者都会等待；
  2. 正确的获取和释放顺序是：
        1. **按照固定顺序获取锁**：所有线程都按照相同的顺序获取锁，例如，先获取锁 `A`，然后获取锁 `B`；
        2. **使用 try-lock 方法**：尝试获取锁，如果获取不到，就放弃所有已持有的锁，稍后重试。
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex lockA;</span><br><span class="line">std::mutex lockB;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guardA</span><span class="params">(lockA)</span></span>; <span class="comment">// 获取锁A</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>)); <span class="comment">// 模拟一些工作</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guardB</span><span class="params">(lockB)</span></span>; <span class="comment">// 获取锁B</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 1 has acquired both locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guardA</span><span class="params">(lockA)</span></span>; <span class="comment">// 获取锁A</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>)); <span class="comment">// 模拟一些工作</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guardB</span><span class="params">(lockB)</span></span>; <span class="comment">// 获取锁B</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 2 has acquired both locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10、从锁的粒度来说，有哪些？"><a href="#10、从锁的粒度来说，有哪些？" class="headerlink" title="10、从锁的粒度来说，有哪些？"></a>10、从锁的粒度来说，有哪些？</h3><p>（1）<strong>粗粒度锁</strong>：</p>
<ul>
<li><strong>全局锁</strong>：对整个应用程序或系统加锁，通常用于单个进程或单个应用实例中；</li>
<li><strong>模块级锁</strong>：对某个模块或组件加锁，通常用于大型系统中。</li>
</ul>
<p>（2）<strong>细粒度锁</strong>：</p>
<ul>
<li><strong>对象锁</strong>：对单个对象加锁。</li>
<li><strong>方法锁</strong>：对单个方法加锁；</li>
<li><strong>变量锁</strong>：对单个变量或数据结构加锁。</li>
</ul>
<h3 id="11、悲观锁和乐观锁？"><a href="#11、悲观锁和乐观锁？" class="headerlink" title="11、悲观锁和乐观锁？"></a>11、悲观锁和乐观锁？</h3><p>悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。互斥锁、自旋锁、读写锁都属于悲观锁。</p>
<p>相反的，如果并发操作之间的冲突很少，就可以使用乐观锁，它的工作方式是：在读取数据时不加锁，而是在更新数据时检查数据是否发生变化。如果数据没有变化，则进行更新；如果数据发生变化，则放弃更新并重新尝试。</p>
<h3 id="12、忙等待和阻塞的区别是什么？"><a href="#12、忙等待和阻塞的区别是什么？" class="headerlink" title="12、忙等待和阻塞的区别是什么？"></a>12、忙等待和阻塞的区别是什么？</h3><p><strong>（1）忙等待（Busy Waiting）</strong>：忙等待指线程在等待锁或资源可用期间<strong>不断地检查锁的状态，而不进行任何上下文切换</strong>，这种等待方式会使线程保持活跃状态，具有低延迟的特点，但占用 CPU 时间。适用于高并发、低延迟需求的实时系统；如果锁等待时间较长，忙等待会导致大量的 CPU 资源浪费。</p>
<p><strong>（2）阻塞（Blocking）</strong>：阻塞指线程在等待锁或资源可用期间会<strong>被挂起，进入睡眠状态，直到条件满足或锁可用时被唤醒</strong>。这种机制需要操作系统的线程调度和上下文切换支持，但释放了 CPU 资源，以便被其他线程使用。适用于长时间等待或锁持有时间较长的情况，避免了 CPU 资源的浪费。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忙等待</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 忙等待，直到 ready 变为 true</span></span><br><span class="line">    <span class="keyword">while</span> (!ready) &#123;  </span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));  <span class="comment">// 忙等待期间可以加入适当的休眠，减少 CPU 资源浪费</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker is running!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(worker)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));  <span class="comment">// 模拟一些工作</span></span><br><span class="line">    ready = <span class="literal">true</span>;  <span class="comment">// 设置ready为true，此时worker线程会自动检测到这一情况并执行</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞等待，直到ready变为true</span></span><br><span class="line">    <span class="comment">// 此处ready为共享变量，因此用lock来保护</span></span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> ready; &#125;);  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker is running!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(worker)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));      <span class="comment">// 模拟一些工作</span></span><br><span class="line">    <span class="comment">// 唤醒worker线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();  </span><br><span class="line">    <span class="comment">// worker线程会在ready变为true之前阻塞等待，而不会浪费CPU资源进行忙等待</span></span><br><span class="line">    <span class="comment">// 一旦ready变为true，worker线程就会被唤醒并继续执行</span></span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>t.join();</code> 是用于等待线程完成执行的一种方法。<code>std::thread</code> 类的 <code>join</code> 成员函数可以确保主线程（或其他调用 <code>join</code> 的线程）等待一个线程完成其执行，并在其完成后继续执行。</p>
<p>具体作用如下：</p>
<ol>
<li><strong>等待线程完成：</strong> <code>t.join();</code> 会阻塞调用线程，直到线程 <code>t</code> 完成其执行。</li>
<li><strong>清理资源：</strong> <code>join</code> 还会清理与线程相关的资源。如果不调用 <code>join</code> 或 <code>detach</code>，在线程对象生命周期结束时会导致程序异常。</li>
</ol>
</blockquote>
<h3 id="13、一个进程可以创建多少线程？和什么有关？"><a href="#13、一个进程可以创建多少线程？和什么有关？" class="headerlink" title="13、一个进程可以创建多少线程？和什么有关？"></a>13、一个进程可以创建多少线程？和什么有关？</h3><p>分不同系统去看。</p>
<ul>
<li>如果是 <code>32</code> 位系统，用户态的虚拟空间只有 <code>3G</code>，如果创建线程时分配的栈空间是 <code>10M</code>，那么一个进程最多只能创建 <code> 300 (3G/10M)</code> 个左右的线程。</li>
<li>如果是 <code>64</code> 位系统，用户态的虚拟空间大到有 <code>128T</code>，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制，比如以下三个内核参数：<ul>
<li><code>/proc/sys/kernel/threads-max</code>，表示系统支持的最大线程数，默认值是 <code>14553</code>；</li>
<li><code>/proc/sys/kernel/pid_max</code>，表示系统全局的 PID 号数值的限制，每一个进程或线程都有 ID，ID 的值超过这个数，进程或线程就会创建失败，默认值是 <code>32768</code>；</li>
<li><code>/proc/sys/vm/max_map_count</code>，表示限制一个进程可以拥有的 VMA (虚拟内存区域)的数量，默认值是 <code>65530</code>。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407032203672.png" alt="image-20240703220333465" style="zoom:80%;" />

<h3 id="14、多线程如何保证线程安全？"><a href="#14、多线程如何保证线程安全？" class="headerlink" title="14、多线程如何保证线程安全？"></a>14、多线程如何保证线程安全？</h3><ol>
<li>使用<strong>互斥锁（Mutex）</strong>保护共享资源。</li>
<li>使用<strong>自旋锁（Spinlock）</strong>在短时间锁定的场景。</li>
<li>使用<strong>条件变量（Condition Variable）</strong>进行线程间通信。</li>
<li>使用<strong>原子操作（Atomic Operations）</strong>进行无锁编程。</li>
<li>使用<strong>读写锁（Reader-Writer Lock）</strong>优化读多写少的场景。</li>
<li>使用<strong>线程局部存储（Thread-Local Storage）</strong>确保每个线程独立的数据。</li>
</ol>
<h3 id="15、多线程环境下对变量的读写操作是否是原子的？"><a href="#15、多线程环境下对变量的读写操作是否是原子的？" class="headerlink" title="15、多线程环境下对变量的读写操作是否是原子的？"></a>15、多线程环境下对变量的读写操作是否是原子的？</h3><p>不一定是原子性的。（1）对基本数据类型的赋值操作通常被认为是原子性的，因为它们在单个指令周期内完成；（2）而对于那些被总线带宽、cache line 以及 page 大小给分隔开的内存地址的访问则不是原子性的。</p>
<p>以下是举例说明：</p>
<p>1）对于 <code>x=1</code> 来说，因为 x 是 int 类型，在 x86 上由硬件直接提供了原子性支持。在进行这样的赋值操作时，CPU 会将整个 32 位的值一次性写入到内存中，而不是分开写入。因此，即使有多个线程同时执行类似 <code>x=1</code> 的赋值语句，也不会出现损坏 x 值的情况。</p>
<p>2）对于 <code>x++</code> 和 <code>++x</code> 来说，这样的操作在多线程环境下是需要同步的。因为 x86 会按三条指令的形式来处理这种语句：A. 从内存中读 x 的值到寄存器中；B. 对寄存器加 1；C. 再把新值写回 x 所处的内存地址。</p>
<blockquote>
<p>（1）一些基本的内存读写操作本身已经被硬件提供了原子性保证（例如读写单个字节的操作）；</p>
<p>（2）一些需要保证原子性但是没有被第（1）条机制提供支持的操作（例如read-modify-write）可以通过使用”LOCK#”来锁定总线，从而保证操作的原子性；</p>
<p>（3）因为很多内存数据是已经存放在L1&#x2F;L2 cache中了，对这些数据的原子操作只需要与本地的cache打交道，而不需要与总线打交道，所以CPU就提供了cache  coherency机制来保证其它的那些也cache了这些数据的processor能读到最新的值（关于cache coherency可以参加我的<a target="_blank" rel="noopener" href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/">一篇博文</a>）。</p>
</blockquote>
<blockquote>
<p>从Intel486 processor开始，<strong>以下的基本内存操作是原子的</strong>：<br>• Reading or writing a byte（<strong>一个字节的读写</strong>）<br>• Reading or writing a word aligned on a 16-bit boundary（<strong>对齐到16位边界的字的读写</strong>）<br>• Reading or writing a doubleword aligned on a 32-bit boundary（<strong>对齐到32位边界的双字的读写</strong>）</p>
<p>从Pentium processor开始，除了之前支持的原子操作外又新增了以下原子操作：<br>• Reading or writing a quadword aligned on a 64-bit boundary（<strong>对齐到64位边界的四字的读写</strong>）<br>• 16-bit accesses to uncached memory locations that fit within a 32-bit data bus（<strong>未缓存且在32位数据总线范围之内的内存地址的访问</strong>）</p>
<p>从P6 family processors开始，除了之前支持的原子操作又新增了以下原子操作：<br>• Unaligned 16-, 32-, and 64-bit accesses to cached memory that fit within a cache line（<strong>对单个cache line中缓存地址的未对齐的16&#x2F;32&#x2F;64位访问</strong>）</p>
<p><strong>那么哪些操作是非原子的呢？</strong><br>Accesses to cacheable memory that are split across bus widths, cache lines, and page boundaries are not guaranteed to be atomic by the Intel Core 2 Duo, Intel® Atom™, Intel Core Duo, Pentium M, Pentium 4, Intel Xeon, P6 family, Pentium, and Intel486 processors.（说点简单点，<strong>那些被总线带宽、cache line以及page大小给分隔开了的内存地址的访问不是原子的</strong>，你如果想保证这些操作是原子的，你就得求助于机制（2），对总线发出相应的控制信号才行）。</p>
</blockquote>
<h3 id="16、为什么线程的开销要小于进程的开销？"><a href="#16、为什么线程的开销要小于进程的开销？" class="headerlink" title="16、为什么线程的开销要小于进程的开销？"></a>16、为什么线程的开销要小于进程的开销？</h3><p>首先，任务调度的开销主要包含以下两个方面：</p>
<ol>
<li><p>CPU执行任务调度的开销，主要是<strong>上下文切换</strong>的开销；</p>
</li>
<li><p>任务调度后，CPU Cache&#x2F;TLB 不命中，导致<strong>缺页中断</strong>的开销。</p>
</li>
</ol>
<p>针对第 1 点，无论是进程调度还是线程调度都是必须的，因此两者的差异体现在第 2 点。</p>
<p>进程切换会导致页表、cache、TLB 中的内容发生变化，原进程保存的内容无效，新的进程必须重新加载，导致缺页中断增多，cache，TLB 也命中率下降。而线程切换会保留页表、cache、TLB 中的内容，因为多个线程之间共享进程的这部分资源。因此线程调度的开销要小于进程调度的开销。</p>
<h3 id="17、线程池中的线程数如何确定？"><a href="#17、线程池中的线程数如何确定？" class="headerlink" title="17、线程池中的线程数如何确定？"></a>17、线程池中的线程数如何确定？</h3><p>一般的经验法则是<strong>根据系统的硬件资源，特别是 CPU 的核心数</strong>来确定线程数。</p>
<ul>
<li><p>对于<strong>计算密集型任务</strong>，线程数通常设置为等于或稍大于 CPU 核心数。这样可以最大化CPU利用率，避免上下文切换的开销。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numThreads = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line"><span class="comment">// 返回可用的并发线程数（通常等于CPU核心数）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于<strong>I&#x2F;O 密集型任务</strong>，由于任务在执行过程中需要等待 I&#x2F;O 操作完成，因此线程数可设置为高于 CPU 核心数以隐藏 I&#x2F;O 等待时间，提高整体吞吐量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numThreads = std::thread::<span class="built_in">hardware_concurrency</span>() * <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 这个倍数可以根据实际情况调整，通常在2到4之间。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="18、为什么线程池可以提高吞吐量？"><a href="#18、为什么线程池可以提高吞吐量？" class="headerlink" title="18、为什么线程池可以提高吞吐量？"></a>18、为什么线程池可以提高吞吐量？</h3><ul>
<li><strong>减少线程创建和销毁的开销</strong>，线程池在初始化时会创建一定数量的线程，并将它们保存在池中。当任务到达时，线程池会分配一个空闲线程来执行任务，而不是每次都创建新线程。这样可以减少线程创建和销毁的开销，提高了任务处理的效率。</li>
<li><strong>复用线程资源</strong>，执行完一个任务后线程不会立即销毁，而是继续等待新的任务。这样可以避免频繁地创建和销毁线程，减少系统资源的消耗。</li>
<li><strong>控制并发线程数量</strong>，防止因过多线程竞争资源导致系统性能下降的情况发生。</li>
</ul>
<h3 id="【-】19、现在让你来设计一个支持最大并发数的线程池你可能会怎么设计呢？"><a href="#【-】19、现在让你来设计一个支持最大并发数的线程池你可能会怎么设计呢？" class="headerlink" title="【*】19、现在让你来设计一个支持最大并发数的线程池你可能会怎么设计呢？"></a>【*】19、现在让你来设计一个支持最大并发数的线程池你可能会怎么设计呢？</h3><p>可以考虑以下两方面：</p>
<ol>
<li><p><strong>任务管理</strong></p>
<ul>
<li><p><strong>任务队列</strong>：使用一个线程安全的队列存储待执行的任务。任务按照提交的顺序执行。</p>
</li>
<li><p><strong>调度机制</strong>：当线程池有空闲线程时，从任务队列中取出任务执行。如果任务队列为空，线程可以进入等待状态。</p>
</li>
</ul>
</li>
<li><p><strong>线程池管理</strong></p>
</li>
</ol>
<ul>
<li><p><strong>固定数量线程池</strong>：初始化时创建固定数量的线程（如3个），每个线程从任务队列中获取任务并执行。线程池的线程数量保持不变。</p>
</li>
<li><p><strong>动态管理</strong>：如果采用动态管理策略，可以根据负载调整线程数量，但在最大并发数内。</p>
</li>
<li><p><strong>同步机制</strong>：使用信号量或条件变量控制最大并发数。线程执行任务时减少计数，完成后增加计数，确保同时运行的线程不超过最大并发数。</p>
</li>
<li><p><strong>停止和清理</strong>：提供接口用于优雅地停止线程池，并确保所有任务完成后释放资源。</p>
</li>
</ul>
<blockquote>
<p>假设队列里边的任务是按时间顺序管理的，那么如果有个高优先级的事件你怎么处理，比如说我移动了一下鼠标它不可能等待所有线程执行完去执行，那怎么处理这样的事件？</p>
<p>如果任务队列的任务之间有依赖关系要怎么处理呢？如果采用同步是不是就死锁了？</p>
</blockquote>
<h3 id="20、C-多线程编程时要链接什么库，怎么找到对应的动态库？"><a href="#20、C-多线程编程时要链接什么库，怎么找到对应的动态库？" class="headerlink" title="20、C++ 多线程编程时要链接什么库，怎么找到对应的动态库？"></a>20、C++ 多线程编程时要链接什么库，怎么找到对应的动态库？</h3><p>链接 <code>pthread(POSIX threads)</code> 库或 C++11 标准库提供的线程支持库。</p>
<blockquote>
<ol>
<li><p>使用<code>pthread</code>库</p>
</li>
<li><p>链接<code>pthread</code>库</p>
<p>在Linux系统中，使用<code>pthread</code>库时需要在编译时加上<code>-pthread</code>选项。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o my_program my_program.cpp -pthread</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找和链接动态库</p>
<p>动态库一般位于系统的标准库路径中，如<code>/usr/lib</code>或<code>/usr/local/lib</code>。在运行时，操作系统会自动从这些路径中查找所需的动态库。如果动态库位于非标准路径，可以通过设置<code>LD_LIBRARY_PATH</code>环境变量来指定动态库路径。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/path/to/your/library:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>pthread</code>库进行多线程编程</p>
</li>
<li><p>使用 C++11 标准库：不需要额外链接任何库，编译器会自动处理。</p>
</li>
</ol>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o my_program my_program.cpp -std=c++11</span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="21、多线程切换，CPU-和内存会做一些什么处理？"><a href="#21、多线程切换，CPU-和内存会做一些什么处理？" class="headerlink" title="21、多线程切换，CPU 和内存会做一些什么处理？"></a>21、多线程切换，CPU 和内存会做一些什么处理？</h3><ol>
<li><strong>保存当前线程的上下文：</strong> 包括程序计数器（PC）、寄存器状态、栈指针（SP）等，便于在之后恢复线程时能够继续执行。</li>
<li><strong>加载下一个线程的上下文：</strong> CPU 根据调度算法选择下一个需要执行的线程，然后加载其上下文信息到寄存器和其他硬件状态中。</li>
<li><strong>切换内存空间：</strong> 不同进程的线程可能涉及页表（Page Table）等内存映射表的切换，以确保能访问到正确的内存空间。</li>
<li><strong>处理器流水线的清空和填充：</strong> 在进行线程切换时，可能存在流水线（Pipeline）中的指令未执行完毕。因此可能需要将流水线清空，以避免对新线程执行的指令产生影响。</li>
<li><strong>更新调度器信息：</strong>包括线程的状态（就绪、运行、阻塞等），以及相关的时间片（Time Slice）等调度参数。</li>
</ol>
<h3 id="22、如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？"><a href="#22、如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？" class="headerlink" title="22、如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？"></a>22、如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？</h3><p>首先判断这个请求数量远远多于线程是否是常态：</p>
<ul>
<li>如果是常态则先要考虑是不是线程数量设置有问题，其次判断机器是否能力不足以处理这些数据；</li>
<li>假如说硬件和软件都没有问题，那么考虑这个问题为什么会产生，是不是<strong>高计算密集型任务</strong>太多了。如果说当前请求任务比较复杂，那么考虑进行分类，将处理的特别慢的请求作为一个特定类，将一些线程固定给他们使用，而不是所有线程都用来处理这种任务，因为既然很慢，那么慢1个和慢10个点区别就没有那么大了，然后将其他线程用来处理能够快速处理完的请求。</li>
</ul>
<h3 id="【-】23、线程间的通信包括哪些方式？"><a href="#【-】23、线程间的通信包括哪些方式？" class="headerlink" title="【*】23、线程间的通信包括哪些方式？"></a>【*】23、线程间的通信包括哪些方式？</h3><ol>
<li><p><strong>互斥锁（Mutex）</strong>：用于控制多个线程对共享资源的访问，保证同一时间只有一个线程可以访问资源。</p>
</li>
<li><p><strong>条件变量</strong>：利用线程间共享全局变量进行同步的一种机制。允许一个或多个线程在某些条件下暂停执行并等待，直到另一个线程通知它们条件已经满足，从而避免了线程不断轮询检查该条件是否成立而降低效率的情况。</p>
<ol>
<li><p>包含两种等待方式，无条件等待<code>pthread_cond_wait()</code>和计时等待<code>pthread_cond_timewait()</code>两种。注意无论哪种等待方式，都必须和一个互斥锁配合，以防止多个线程同时请求竞争条件；</p>
<blockquote>
<p><strong>条件变量为什么要和互斥锁一起使用？</strong></p>
<p>这是为了应对线程<code>1</code>在调用<code>pthread_cond_wait()</code>但线程<code>1</code>还没有进入<code>wait cond</code>的状态时，线程<code>2</code>调用了<code>cond_singal</code>的情况。 </p>
<p>如果不用互斥锁的话，这个<code>cond_singal</code>就丢失了。加了锁的情况下，线程<code>2</code>必须等到<code>mutex</code>被释放（也就是<code>pthread_cond_wait()</code>释放锁并进入<code>wait_cond</code>状态 ，此时线程<code>2</code>上锁） 的时候才能调用<code>cond_singal</code>。</p>
</blockquote>
</li>
<li><p>互斥锁必须是普通锁或者适应锁；</p>
</li>
<li><p>在调用<code>pthread_cond_wait()</code>前必须由本线程加锁，而在更新条件等待队列以前，<code>mutex</code>保持锁定状态，并<strong>在线程挂起进入等待前解锁</strong>；</p>
<blockquote>
<p><strong>为什么必须由本线程加锁，而不在函数内部定义？</strong></p>
<p>无法确定会有多少用户使用条件变量，所以每个互斥锁都须要动态定义，而且管理大量互斥锁的开销太大，使用用户定义的锁会更加灵活又方便。</p>
</blockquote>
</li>
<li><p>在条件满足从而离开<code>pthread_cond_wait()</code>之前，<code>mutex</code>将被重新加锁，以与进入<code>pthread_cond_wait()</code>前的加锁动作对应。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">thread2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);  <span class="comment">// 调用前由本线程加锁</span></span><br><span class="line">        pthread_cond_wait(&amp;cond,&amp;mutex);  <span class="comment">// 无条件等待（经历了解锁-&gt;加锁的过程）</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>信号量（Semaphores）</strong>：如同进程一样，线程也可以通过信号量来实现通信，虽然是轻量级的。 </p>
<ol>
<li><p>初始化信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span> <span class="params">(<span class="type">sem_t</span> *sem , <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// sem 		- 指定要初始化的信号量； </span></span><br><span class="line"><span class="comment">// pshared 	- 信号量 sem 的共享选项，linux只支持0，表示它是当前进程的局部信号量； </span></span><br><span class="line"><span class="comment">// value 	- 信号量 sem 的初始值。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>信号量值加<code>1 </code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>信号量值减<code>1 </code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>

<p>如果<code>sem</code>所指的信号量的数值为<code>0</code>，函数将会等待直到有其它线程使它不再是<code>0</code>为止，此时相当于获取到该信号。</p>
</li>
<li><p>销毁信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>事件（Event）</strong>：类似于条件变量，用于通知一个或多个正在等待的线程某个事件已经发生。</p>
</li>
<li><p><strong>屏障（Barriers）</strong>：用于多个线程同步到某一点，当所有线程都达到屏障点后，它们再同时开始执行后续操作。常用于并行计算，确保所有线程在进行下一步操作前已完成当前操作。</p>
</li>
</ol>
<h3 id="【-】24、线程同步是什么？从底层原理分析一下为什么会出现线程同步？"><a href="#【-】24、线程同步是什么？从底层原理分析一下为什么会出现线程同步？" class="headerlink" title="【*】24、线程同步是什么？从底层原理分析一下为什么会出现线程同步？"></a>【*】24、线程同步是什么？从底层原理分析一下为什么会出现线程同步？</h3><ol>
<li><p><strong>线程同步</strong>是多线程编程中保证多个线程安全访问共享资源或协调工作的一种机制。它确保在任何给定时刻，只有一个线程可以访问特定的数据或代码块，以防止数据损坏或不一致性。</p>
</li>
<li><p>底层原理上，线程同步问题主要是由于<strong>并发性、不确定性和原子性</strong>导致的：</p>
<ol>
<li><strong>并发性</strong>：多个线程同时执行，导致对共享资源的访问不可控；</li>
<li><strong>不确定性</strong>：线程的执行顺序和执行时间不确定，可能导致对共享资源的交叉访问</li>
<li><strong>原子性</strong>：对共享资源的操作可能不是原子操作，而是由多条指令组成，这会导致中间状态的出现，从而引发问题。</li>
</ol>
</li>
</ol>
<h3 id="25、处理多线程同步问题有哪些机制？如果想等待线程-a-执行完任务后再去执行-b，这种情况要怎么处理？"><a href="#25、处理多线程同步问题有哪些机制？如果想等待线程-a-执行完任务后再去执行-b，这种情况要怎么处理？" class="headerlink" title="25、处理多线程同步问题有哪些机制？如果想等待线程 a 执行完任务后再去执行 b，这种情况要怎么处理？"></a>25、处理多线程同步问题有哪些机制？如果想等待线程 a 执行完任务后再去执行 b，这种情况要怎么处理？</h3><p>在处理多线程同步问题时，常用的机制包括<strong>互斥锁、条件变量、信号量</strong>等。</p>
<p><strong>等待线程A执行完任务后再执行线程B的处理方式</strong></p>
<ol>
<li><p><strong>使用信号量：</strong></p>
<ul>
<li><p>通过 sem_init() 初始化信号量为 0。</p>
</li>
<li><p>线程 A 执行完任务后调用 sem_post() 释放信号量，通知线程 B 可以继续执行。</p>
</li>
<li><p>线程 B 调用 sem_wait() 等待信号量被释放，然后继续执行。</p>
</li>
</ul>
</li>
<li><p><strong>使用条件变量和互斥锁结合的方式：</strong></p>
<ul>
<li>创建互斥锁和条件变量，互斥锁用于保护共享数据的访问；条件变量作为共享状态变量，用于阻塞一个或多个线程，直到接收到其他线程的通知。</li>
<li>线程 A 执行完其任务后，修改共享状态变量，通知等待线程任务已完成。</li>
<li>线程 B 等待线程 A 完成任务，收到通知后继续执行。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">// For sleep function</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem;  <span class="comment">// 信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task A is running.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>); <span class="comment">// 模拟任务A执行时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task A is finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sem);  <span class="comment">// 释放信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sem);  <span class="comment">// 等待信号量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task B is running.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// 模拟任务B执行时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task B is finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 初始化信号量，初始值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">threadA</span><span class="params">(taskA)</span></span>;  <span class="comment">// 创建并启动线程A</span></span><br><span class="line">    <span class="function">std::thread <span class="title">threadB</span><span class="params">(taskB)</span></span>;  <span class="comment">// 创建并启动线程B</span></span><br><span class="line"></span><br><span class="line">    threadA.<span class="built_in">join</span>();  <span class="comment">// 等待线程A完成</span></span><br><span class="line">    threadB.<span class="built_in">join</span>();  <span class="comment">// 等待线程B完成</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;sem);  <span class="comment">// 销毁信号量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;  <span class="comment">// 互斥锁</span></span><br><span class="line">std::condition_variable cv;  <span class="comment">// 条件变量</span></span><br><span class="line"><span class="type">bool</span> taskA_completed = <span class="literal">false</span>;  <span class="comment">// 任务A是否完成的标志</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task A is running.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟任务A执行时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task A is finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        taskA_completed = <span class="literal">true</span>;  <span class="comment">// 设置任务A完成的标志</span></span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();  <span class="comment">// cv.notify_one()/cv.notify_all() 通知等待线程任务A已完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> taskA_completed; &#125;); <span class="comment">// cv.wait() 等待任务A完成</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task B is running.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// 模拟任务B执行时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task B is finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">threadA</span><span class="params">(taskA)</span></span>;  <span class="comment">// 创建并启动线程A</span></span><br><span class="line">    <span class="function">std::thread <span class="title">threadB</span><span class="params">(taskB)</span></span>;  <span class="comment">// 创建并启动线程B</span></span><br><span class="line"></span><br><span class="line">    threadA.<span class="built_in">join</span>();  <span class="comment">// 等待线程A完成</span></span><br><span class="line">    threadB.<span class="built_in">join</span>();  <span class="comment">// 等待线程B完成</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="26、进程的五种状态分别是？"><a href="#26、进程的五种状态分别是？" class="headerlink" title="26、进程的五种状态分别是？"></a>26、进程的五种状态分别是？</h3><p>进程一共有 5 种状态，分别是<strong>创建、就绪、运行、阻塞、终止</strong>。</p>
<ul>
<li>运行状态就是进程正在 CPU 上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。</li>
<li>就绪状态就是说进程已处于准备运行的状态，即进程获得了除 CPU 之外的一切所需资源，一旦得到 CPU 即可运行。</li>
<li>阻塞状态就是进程正在等待某一事件而暂停运行，比如等待某资源为可用或等待 I&#x2F;O 完成。即使 CPU 空闲，该进程也不能运行。</li>
</ul>
<h3 id="27、进程不同状态转换的关系？"><a href="#27、进程不同状态转换的关系？" class="headerlink" title="27、进程不同状态转换的关系？"></a>27、进程不同状态转换的关系？</h3><p>进程在不同状态之间的转换过程如下：</p>
<ul>
<li><strong>创建态到就绪态</strong>：当进程创建完成并且准备好执行时，进程从创建态转换到就绪态，等待被调度执行。</li>
<li><strong>就绪态到运行态</strong>：当操作系统调度到了进程并且为其分配了CPU资源时，进程从就绪态转换到运行态，开始执行。</li>
<li><strong>运行态到阻塞态</strong>：当进程等待某些事件发生时，比如等待I&#x2F;O操作完成或者等待信号量的通知，进程从运行态转换到阻塞态。</li>
<li><strong>阻塞态到就绪态</strong>：当等待的事件发生并且进程重新具备执行条件时，进程从阻塞态转换到就绪态，等待被重新调度执行。</li>
<li><strong>运行态到终止态</strong>：当进程执行完成或者被操作系统终止时，进程从运行态转换到终止态，等待被清理和回收。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406131948229.png" alt="在这里插入图片描述"></p>
<h3 id="28、孤儿进程和僵尸进程是什么，怎么处理？"><a href="#28、孤儿进程和僵尸进程是什么，怎么处理？" class="headerlink" title="28、孤儿进程和僵尸进程是什么，怎么处理？"></a>28、孤儿进程和僵尸进程是什么，怎么处理？</h3><p>（1）<strong>孤儿进程</strong>：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被<code>init</code>进程（进程号为<code>1</code>）所收养，并由 <code>init</code> 进程对它们完成状态收集工作。</p>
<p>（2）<strong>僵尸进程</strong>：一个进程使用<code>fork</code>创建子进程，如果子进程退出，而父进程并没有调用<code>wait</code>或<code>waitpid</code>获取子进程的状态信息，那么<strong>子进程的进程描述符</strong>仍然保存在系统中。这种进程称之为僵尸进程。</p>
<p>（3）<strong>解决方案</strong>：</p>
<ul>
<li><p><strong>1）kill 杀死元凶父进程（一般不用）</strong></p>
</li>
<li><p><strong>2）通过信号机制，在处理函数中调用 wait，回收资源</strong></p>
<p>通过信号机制，子进程退出时向父进程发送 <code>SIGCHLD</code> 信号，父进程调用 <code>signal(SIGCHLD, sig_child)</code> 去处理 <code>SIGCHLD</code> 信号，在信号处理函数 <code>sig_child()</code> 中调用 <code>wait</code> 进行处理僵尸进程。什么时候得到子进程信号，什么时候进行信号处理，过程中父进程可以继续做其他工作，不用去阻塞等待。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_child</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> stat;</span><br><span class="line">    <span class="comment">// 使用循环回收所有已经结束的子进程</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Child &quot;</span> &lt;&lt; pid &lt;&lt; <span class="string">&quot; terminated&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGCHLD, sig_child); <span class="comment">// 设置信号处理程序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Child process &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; started&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">2</span>); <span class="comment">// 模拟子进程工作</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">// 子进程结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程可以继续做其他工作，不会被阻塞</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parent process doing work...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="29、两个进程的内核空间是共享的吗？"><a href="#29、两个进程的内核空间是共享的吗？" class="headerlink" title="29、两个进程的内核空间是共享的吗？"></a>29、两个进程的内核空间是共享的吗？</h3><p>在大多数现代操作系统中，包括 Linux 和 Windows，内核空间是在所有进程之间共享的。这意味着内核空间中的代码和数据结构对所有进程来说都是相同的，并且在任何时候都位于相同的物理内存位置。</p>
<h3 id="30、进程间的通信包括哪些方式？"><a href="#30、进程间的通信包括哪些方式？" class="headerlink" title="30、进程间的通信包括哪些方式？"></a>30、进程间的通信包括哪些方式？</h3><ol>
<li><p><strong>管道</strong>，半双工的通信方式，通常用于具有亲缘关系的进程之间的通信。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建管道</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>命名管道</strong>，与普通管道类似，但可以在无亲缘关系的进程之间使用。命名管道通过文件系统进行通信。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FILE <span class="string">&quot;/tmp/my_fifo&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;&#x27;hi midori&#x27; from writer(fifo)&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    fd = open(FIFO_FILE, O_WRONLY);  <span class="comment">// 打开命名管道</span></span><br><span class="line">    write(fd, message, <span class="built_in">strlen</span>(message) + <span class="number">1</span>);      <span class="comment">// 向命名管道写入数据</span></span><br><span class="line">    close(fd);      <span class="comment">// 关闭命名管道</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>消息队列</strong>，允许一个或多个进程向队列中发送消息，并从队列中接收消息。消息队列通常用于在不同进程之间传递结构化的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_buffer</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> msg_type;</span><br><span class="line">    <span class="type">char</span> msg_text[MSG_SIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建消息队列或获取现有消息队列的标识符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向消息队列发送消息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从消息队列接收消息</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对消息队列进行控制操作，如获取信息、修改权限、删除消息队列等</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>信号量</strong>，控制进程间访问共享资源的机制，可以用来解决进程同步和互斥的问题，防止竞态条件的发生。</p>
</li>
<li><p><strong>共享内存</strong>：</p>
<ul>
<li><p><strong>效率</strong>最高，允许多个进程共享同一块内存区域，没有数据复制的开销，进程可以直接读写共享内存中的数据。</p>
</li>
<li><p>不过，1）需要额外的同步机制（如信号量或互斥锁）来防止并发访问问题；2）同时，共享内存的数据一旦被破坏，所有依赖于该数据的进程都会受到影响，容错性较差；3）需要注意临界变量的保护。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建共享内存段或获取现有共享内存段的标识符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将共享内存连接到当前进程的地址空间，返回共享内存段的首地址</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将共享内存段从当前进程的地址空间中分离，即解除映射</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对共享内存段进行控制操作，如获取信息、修改权限、删除共享内存段等</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>套接字</strong>，适用于在不同主机和不同进程之间进行通信，通常用于网络编程。</p>
</li>
</ol>
<h3 id="【-】31、进程调度算法"><a href="#【-】31、进程调度算法" class="headerlink" title="【*】31、进程调度算法"></a>【*】31、进程调度算法</h3><ol>
<li><p><strong>先来先服务 first-come first-serverd(FCFS)</strong></p>
<p><strong>非抢占式的调度算法，</strong>按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
</li>
<li><p><strong>短作业优先 shortest job first(SJF)</strong></p>
<p><strong>非抢占式的调度算法，</strong>按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
</li>
<li><p><strong>最短剩余时间优先 shortest remaining time next(SRTN)</strong></p>
<p><strong>最短作业优先的抢占式版本</strong>，按剩余运行时间的顺序进行调度。 </p>
<p>当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
</li>
<li><p><strong>时间片轮转</strong></p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li><p>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间；</p>
</li>
<li><p>而如果时间片过长，那么实时性就不能得到保证。</p>
</li>
</ul>
</li>
<li><p><strong>优先级调度</strong></p>
<p>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
</li>
<li><p><strong>多级反馈队列</strong></p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8..。进程在第一个队列没执行完，就会被移到下一个队列。</p>
<p>这种方式下，之前的进程只需要交换7次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队烈上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
</li>
</ol>
<h3 id="32、进程同步的方式？"><a href="#32、进程同步的方式？" class="headerlink" title="32、进程同步的方式？"></a>32、进程同步的方式？</h3><ul>
<li><strong>互斥锁</strong>，一种用于保护共享资源的同步机制，确保同一时间只有一个进程可以访问共享资源。</li>
<li><strong>信号量</strong>，用于控制对共享资源的访问。</li>
<li><strong>条件变量</strong>，允许进程在某个条件不满足的情况下阻塞自己，直到有其他进程通知条件满足。</li>
<li><strong>共享内存</strong>，允许多个进程共享一块内存区域，以便快速交换数据。</li>
<li><strong>消息队列</strong>，允许进程通过发送和接收消息进行通信。</li>
</ul>
<h3 id="33、信号量和互斥锁解决父子线程同时阻塞的区别？"><a href="#33、信号量和互斥锁解决父子线程同时阻塞的区别？" class="headerlink" title="33、信号量和互斥锁解决父子线程同时阻塞的区别？"></a>33、信号量和互斥锁解决父子线程同时阻塞的区别？</h3><p>假设有一个场景，其中父线程和子线程需要按特定顺序访问某个资源（例如，父线程需要等待子线程完成某个任务后才能继续执行）。</p>
<ul>
<li><strong>使用互斥锁</strong>：如果使用互斥锁，需要<strong>配合条件变量</strong>来实现这种顺序控制。<strong>互斥锁本身只能保证互斥，不能控制线程之间的执行顺序</strong>。父线程需要在条件变量上等待一个特定条件（通常由子线程设置）。</li>
<li><strong>使用信号量</strong>：信号量可以更直接地控制执行顺序。父线程等待子线程释放某个信号后才能继续执行，这样就控制了对资源的访问顺序。</li>
</ul>
<h3 id="34、windows-下-thread-create-会有什么问题？"><a href="#34、windows-下-thread-create-会有什么问题？" class="headerlink" title="34、windows 下 thread_create 会有什么问题？"></a>34、windows 下 thread_create 会有什么问题？</h3><p>？</p>
<h3 id="35、知道哪些信号的含义？SIGALRM-SIGSEGV-SIGINT"><a href="#35、知道哪些信号的含义？SIGALRM-SIGSEGV-SIGINT" class="headerlink" title="35、知道哪些信号的含义？SIGALRM, SIGSEGV, SIGINT?"></a>35、知道哪些信号的含义？SIGALRM, SIGSEGV, SIGINT?</h3><p><strong>SIGALRM</strong>：时钟定时器超时信号，通常用于定时操作。</p>
<p><strong>SIGSEGV</strong>：非法内存访问信号，通常由无效的指针或越界访问引发。</p>
<p><strong>SIGINT</strong>：中断信号，通常由用户通过 Ctrl+C 发出，用于中断程序执行。</p>
<h3 id="36、Ctrl-C-后发生了什么？"><a href="#36、Ctrl-C-后发生了什么？" class="headerlink" title="36、Ctrl+C 后发生了什么？"></a>36、Ctrl+C 后发生了什么？</h3><p>按下 Ctrl+C 后，会向前台运行的进程发送 SIGINT 信号。这个信号通常用于中断和终止正在运行的程序。如果程序捕获并处理了 SIGINT 信号，它可以执行清理操作或选择忽略信号；否则，默认行为是终止程序。</p>
<h3 id="【-】37、sigaction-可以干哪些事情？解释一下屏蔽集？"><a href="#【-】37、sigaction-可以干哪些事情？解释一下屏蔽集？" class="headerlink" title="【*】37、sigaction 可以干哪些事情？解释一下屏蔽集？"></a>【*】37、sigaction 可以干哪些事情？解释一下屏蔽集？</h3><p><code>sigaction</code> 是一个用于设置和检测信号处理方式的系统调用，主要有以下功能：</p>
<ol>
<li><strong>设置信号处理函数</strong>：可以用于指定一个函数，用来处理特定信号发生时的行为。</li>
<li><strong>指定信号的处理方式</strong>：可以指定信号的处理方式，比如忽略信号、执行默认操作、或者调用指定的处理函数。</li>
<li><strong>检查和修改信号的屏蔽集</strong>：可以检查当前对信号的屏蔽状态，也可以修改进程对信号的屏蔽集。</li>
</ol>
<p><strong>屏蔽集</strong> 是一个用来管理信号处理的机制，它决定了<strong>在特定时间点一个进程可以接收哪些信号</strong>。当信号被屏蔽时，进程在收到该信号时不会立即处理，而是被加入到<strong>未决信号集</strong>中，直到信号被解除屏蔽后才会处理。屏蔽集可以通过 <code>sigprocmask</code> 系统调用来设置和修改。</p>
<h3 id="38、线程崩溃，进程一定会崩溃吗？"><a href="#38、线程崩溃，进程一定会崩溃吗？" class="headerlink" title="38、线程崩溃，进程一定会崩溃吗？"></a>38、线程崩溃，进程一定会崩溃吗？</h3><p>一般来说，如果线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃。因为在进程中，<strong>各个线程的地址空间是共享的</strong>，既然是共享，那么某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程，这种操作是危险的，操作系统会认为这很可能导致一系列严重的后果，于是干脆让整个进程崩溃。</p>
<h2 id="二、内存模型-虚拟内存"><a href="#二、内存模型-虚拟内存" class="headerlink" title="二、内存模型&#x2F;虚拟内存"></a>二、内存模型&#x2F;虚拟内存</h2><h3 id="39、什么是虚拟内存？"><a href="#39、什么是虚拟内存？" class="headerlink" title="39、什么是虚拟内存？"></a>39、什么是虚拟内存？</h3><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301943905.png" alt="img" style="zoom: 67%;" />

<h3 id="【-】40、为什么操作系统要使用虚拟内存？"><a href="#【-】40、为什么操作系统要使用虚拟内存？" class="headerlink" title="【*】40、为什么操作系统要使用虚拟内存？"></a>【*】40、为什么操作系统要使用虚拟内存？</h3><ol>
<li>第一，虚拟内存可以<strong>使得进程的运行内存超过物理内存大小</strong>，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li>
<li>第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就<strong>解决了多进程之间地址冲突的问题</strong>。</li>
<li>第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统<strong>提供了更好的安全性</strong>。</li>
</ol>
<h3 id="41、虚拟内存有没有大小的限制？"><a href="#41、虚拟内存有没有大小的限制？" class="headerlink" title="41、虚拟内存有没有大小的限制？"></a>41、虚拟内存有没有大小的限制？</h3><ol>
<li><p>虚拟内存的大小<strong>受到地址线的限制</strong>：</p>
<ul>
<li><p><code>32</code>位系统下虚拟内存空间的大小为2^32^字节（约4GB）；</p>
</li>
<li><p><code>64</code>位系统下虚拟内存空间的大小为2^64^字节。</p>
</li>
</ul>
</li>
<li><p>另外，操作系统还可以通过配置来限制每个进程能够使用的虚拟内存大小。</p>
</li>
</ol>
<h3 id="【-】42、虚拟内存中分页算法是为了解决什么样的问题？"><a href="#【-】42、虚拟内存中分页算法是为了解决什么样的问题？" class="headerlink" title="【*】42、虚拟内存中分页算法是为了解决什么样的问题？"></a>【*】42、虚拟内存中分页算法是为了解决什么样的问题？</h3><p>虚拟内存中的分页算法是为了解决<strong>连续长内存分配时物理内存不足</strong>的问题。它通过<strong>将内存分成固定大小的页面（page），并将页面映射到物理内存或者存储在磁盘上的页面文件</strong>中，来提供更大的地址空间。</p>
<h3 id="43、虚拟内存的内存模型如何？"><a href="#43、虚拟内存的内存模型如何？" class="headerlink" title="43、虚拟内存的内存模型如何？"></a>43、虚拟内存的内存模型如何？</h3><p>其内存分布或内存模型实际上就是虚拟内存。主要分为以下几个部分，分别是：<code>.text</code>段，<code>.rodata</code>段，<code>.data</code>段，<code>.bss</code>段，堆，内存映射区，栈，内核空间。其中，各项主要内容如下：</p>
<p>（1）**.text段** ：主要存在程序编译后的机器指令；</p>
<p>（2）**.rodata段 **：主要存放程序中的各种只读变量；</p>
<p>（3）**.data段**：主要存放指定了初始值的全局变量和静态变量；</p>
<p>（4）**.bss段**：主要存放没有指定初始值的全局变量和静态变量，这些未初始化的全局变量被加载进内存之后会被初始化为 0 值；</p>
<p>（5）<strong>堆</strong>：由程序员进行动态分配，如调用 malloc 或 new；</p>
<p>（6）<strong>文件映射与匿名映射区</strong>：存放动态链接库中的代码段，数据段，BSS 段，以及通过 mmap 系统调用映射的共享内存区；</p>
<p>（7）<strong>栈</strong>：由编译器自动分配释放，存放调用函数过程中使用到的局部变量和函数参数等；</p>
<p>（8）<strong>内核空间</strong>：存放操作系统的一些内核数据和代码。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/ffb6e1727e2289f142f6a2a6291cd68c.png" alt="image.png" style="zoom: 50%;" />

<img src="https://cdn.xiaolincoding.com//mysql/other/532e6cdf4899588f8b873b6435cba2d8.png" alt="image.png" style="zoom: 33%;" />

<h3 id="44、为什么要区分代码段和数据段？"><a href="#44、为什么要区分代码段和数据段？" class="headerlink" title="44、为什么要区分代码段和数据段？"></a>44、为什么要区分代码段和数据段？</h3><ul>
<li><strong>访问权限控制</strong>：<strong>代码段通常设置为只读</strong>，以防止程序代码被意外或恶意修改，这可能导致程序行为不正确或系统安全受到威胁。<strong>数据段则通常需要读写权限</strong>，因为程序在运行时需要修改数据。</li>
<li><strong>分页策略</strong>：代码段和数据段可能会<strong>采用不同的分页和交换策略</strong>。例如，代码页可能较少交换出内存，因为它们被频繁访问；而数据段的某些部分<strong>如果使用不频繁可以被交换出去</strong>以节约资源。</li>
</ul>
<h3 id="45、堆和栈有什么样的区别？"><a href="#45、堆和栈有什么样的区别？" class="headerlink" title="45、堆和栈有什么样的区别？"></a>45、堆和栈有什么样的区别？</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301519980.png" alt="image-20240630151957779"></p>
<h3 id="46、什么时候用栈，什么时候用堆？"><a href="#46、什么时候用栈，什么时候用堆？" class="headerlink" title="46、什么时候用栈，什么时候用堆？"></a>46、什么时候用栈，什么时候用堆？</h3><ol>
<li><p>与堆相比，栈不会导致内存碎片，分配效率高。<strong>函数返回地址，函数的局部变量，调用参数以及使用的寄存器</strong>等信息都采取栈的形式存放，如果<strong>少量数据需要频繁的操作</strong>，那么在程序中动态申请少量栈内存会获得很好的性能提升。</p>
</li>
<li><p>堆可以申请的内存大很多，与堆相比，栈的使用没那么灵活，如果<strong>分配大量的内存空间</strong>，推荐使用堆内存，保存着程序运行时使用 new 和 malloc 等动态分配的内存。</p>
</li>
</ol>
<h3 id="47、不同段上的对象的生命周期是怎样的？"><a href="#47、不同段上的对象的生命周期是怎样的？" class="headerlink" title="47、不同段上的对象的生命周期是怎样的？"></a>47、不同段上的对象的生命周期是怎样的？</h3><ol>
<li><p><code>.data/.bss</code> 段的生命周期<strong>和程序的生命周期一致</strong>，在程序加载到内存时被分配，程序结束时被销毁；</p>
</li>
<li><p><code>堆</code>上的对象<strong>由程序员进行动态分配</strong>；</p>
</li>
<li><p><code>栈</code>上的对象由编译器进行分配，当<strong>离开作用域范围时被编译器销毁</strong>。</p>
</li>
</ol>
<h3 id="48、如何让对象只能存在于栈-堆中？"><a href="#48、如何让对象只能存在于栈-堆中？" class="headerlink" title="48、如何让对象只能存在于栈&#x2F;堆中？"></a>48、如何让对象只能存在于栈&#x2F;堆中？</h3><ol>
<li>如果<strong>将<code>operator new</code>设置为私有的</strong>，此时尝试在堆上分配内存失败，对象就会<strong>存在于栈中</strong>。</li>
<li>由于编译器在栈上分配内存时会自动调用其构造函数和析构函数，因此如果<strong>将析构函数设置为私有的</strong>，在栈上分配内存失败，对象就会<strong>存在于堆中</strong>。</li>
</ol>
<h3 id="49、栈的速度为什么比堆上的要快？"><a href="#49、栈的速度为什么比堆上的要快？" class="headerlink" title="49、栈的速度为什么比堆上的要快？"></a>49、<strong>栈的速度为什么比堆上的要快？</strong></h3><p>栈的读取速度比堆上的要快，主要是由于以下几个原因：</p>
<ol>
<li><strong>数据结构的特点</strong>：栈是一种线性数据结构，其操作是基于栈顶的，因此可以通过简单的指针操作来读取栈上的数据。相比之下，堆是一种树形数据结构，要读取堆上的数据可能需要进行指针的跳转和内存的查找操作，因此相对更为复杂和耗时。</li>
<li><strong>内存布局的连续性</strong>：栈上的内存分配是连续的，数据项之间存储的地址是相邻的，这使得栈上的数据读取更为高效，因为可以通过栈指针进行连续的内存读取操作。而堆上的内存分配是动态的，可能是分散的，需要通过指针跳转来访问不同的内存块，导致读取速度较慢。 </li>
<li><strong>硬件优化</strong>：由于栈的读取操作频繁且简单，因此处理器和编译器通常会对栈上的操作进行优化，例如采用特定的指令集或硬件机制来提高栈操作的执行效率。相比之下，堆上的内存操作较为复杂，难以进行同样程度的优化。</li>
</ol>
<h3 id="50、栈何时会溢出？"><a href="#50、栈何时会溢出？" class="headerlink" title="50、栈何时会溢出？"></a>50、<strong>栈何时会溢出</strong>？</h3><ol>
<li><p>递归调用层次过深：如果一个程序中存在递归调用，而递归调用的层次过深，会导致栈空间不足，从而发生栈溢出。</p>
</li>
<li><p>局部变量占用过多空间：当一个函数中声明了过多的局部变量，或者某个局部变量占用的内存空间过大时，会导致栈空间快速耗尽，从而发生栈溢出。</p>
</li>
<li><p>大量函数调用嵌套：如果程序中存在大量的函数调用嵌套，而栈空间不足以容纳所有的函数调用信息，也会导致栈溢出。</p>
</li>
</ol>
<blockquote>
<p>在 C&#x2F;C++ 中，可以使用编译器选项 <code>-Wl,--stack,&lt;size&gt;</code> 来设置栈的大小。</p>
</blockquote>
<h3 id="51、new-和-malloc-的区别？"><a href="#51、new-和-malloc-的区别？" class="headerlink" title="51、new 和 malloc 的区别？"></a>51、new 和 malloc 的区别？</h3><p>主要包含以下区别：</p>
<ol>
<li>malloc 是 C 中的函数，但可以同时在 C&#x2F;C++ 中使用；new 是 C++ 特有的操作符，只能在 C++ 中使用；</li>
<li>malloc 在使用时需要指定分配内存的大小，如 <code>malloc(sizeof(int))</code>，但 new 的使用则比较简洁，如 <code>new int</code>；</li>
<li>malloc 分配的内存是未定义的，而 new 在分配内存时还会调用构造函数进行初始化；</li>
<li>malloc 返回的是 void * 类型的指针，需要进行强制类型转换以得到需要的指针类型，而 new 会自动转换为响应的指针类型；</li>
<li>malloc 调用 free 进行释放， new 调用 delete 进行释放。</li>
<li>若内存分配失败，malloc 调用会返回 nullptr，而 new 调用会返回 <code>std::bad_alloc</code>。</li>
</ol>
<h3 id="52、既然有了-malloc-free，为什么还需要-new-delete-呢？"><a href="#52、既然有了-malloc-free，为什么还需要-new-delete-呢？" class="headerlink" title="52、既然有了 malloc&#x2F;free，为什么还需要 new&#x2F;delete 呢？"></a>52、既然有了 malloc&#x2F;free，为什么还需要 new&#x2F;delete 呢？</h3><ul>
<li>malloc&#x2F;free 和 new&#x2F;delete 都是用来申请内存和回收内存的。</li>
<li>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而 malloc&#x2F;free 是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给 malloc&#x2F;free，所以 new&#x2F;delete 是必不可少的。</li>
</ul>
<h3 id="53、malloc-函数的底层实现是什么？"><a href="#53、malloc-函数的底层实现是什么？" class="headerlink" title="53、malloc() 函数的底层实现是什么？"></a>53、malloc() 函数的底层实现是什么？</h3><ol>
<li>当开辟的空间<strong>小于 128kb</strong> 时，调用 <code>brk()</code> 函数，先遍历空闲内存链表，如果有已释放且空间足够的内存块就拿来用。如果找不到就移动指针 <code>_enddata</code>，即堆区的末尾地址，将「堆顶」指针往高地址推。</li>
<li>当开辟的空间<strong>大于 128kb</strong>  时，系统调用 <code>mmap()</code> 在堆和栈之间找一块空闲内存分配.</li>
<li><code>malloc()</code> 在分配用户传入大小的内存时，还<strong>额外分配一个用于管理的内存</strong>，大小为 8 字节。因此，free() 函数只传入一个内存地址却能知道要释放多大的内存。而由于堆中的内存是成块分配的，与内存对齐有关，在 64 位系统中，内存对齐为 16 字节，因此<strong>实际分配的内存大小还要考虑 8 字节的管理内存和内存对齐</strong>。</li>
</ol>
<blockquote>
<p>brk() 是将「堆顶」指针向高地址移动，获得新的内存空间；mmap() 是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</p>
<p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mem_control_block</span> &#123;</span><br><span class="line">    <span class="type">int</span> is_available;      <span class="comment">// 1表可用，0表不可用</span></span><br><span class="line">    <span class="type">int</span> size;                 <span class="comment">// 总大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="54、mmap-的原理"><a href="#54、mmap-的原理" class="headerlink" title="54、mmap() 的原理"></a>54、mmap() 的原理</h3><p><code>mmap()</code> 是一个系统调用，用于在进程的地址空间中创建一个新的映射区域（mapping）。</p>
<ol>
<li><strong>创建映射区域</strong>：<ul>
<li><code>mmap()</code> 可以将一个文件或者其它对象（如设备内存）映射到调用进程的地址空间中。这个映射区域可以是文件的一部分或者整个文件，也可以是一个设备的内存区域。</li>
<li>映射的区域可以是只读的、可读写的、或者私有的（写时复制）。</li>
</ul>
</li>
<li><strong>映射对象类型</strong>：<ul>
<li>文件映射：<code>mmap()</code> 可以将一个文件映射到进程的地址空间中，这样可以通过内存操作来读写文件，而不需要使用标准的文件 I&#x2F;O 操作函数（如 <code>read()</code> 和 <code>write()</code>）。</li>
<li>匿名映射：<code>mmap()</code> 还可以用于创建一个不与文件关联的映射区域，通常用于进程间通信或者动态内存分配。</li>
</ul>
</li>
<li><strong>映射区域的使用</strong>：<ul>
<li>映射区域创建后，进程可以像访问普通内存一样访问这些区域。读写映射区域的内容会直接影响到原始文件或者设备。</li>
</ul>
</li>
</ol>
<h3 id="55、假设分配一块内存-int-p-int-malloc-100-那么-free-p-50-可不可以，为什么；如果想把这块内存扩充到200字节，应该怎么做？"><a href="#55、假设分配一块内存-int-p-int-malloc-100-那么-free-p-50-可不可以，为什么；如果想把这块内存扩充到200字节，应该怎么做？" class="headerlink" title="55、假设分配一块内存 int* p &#x3D; (int*)malloc(100); 那么 free(p+50) 可不可以，为什么；如果想把这块内存扩充到200字节，应该怎么做？"></a>55、假设分配一块内存 int* p &#x3D; (int*)malloc(100); 那么 free(p+50) 可不可以，为什么；如果想把这块内存扩充到200字节，应该怎么做？</h3><p>（1）<strong>free(p+50) 是否有效？</strong></p>
<ul>
<li><code>malloc(100)</code> 分配了一个可以容纳 100 个字节的内存块，并返回一个指向该内存块起始位置的指针 <code>p</code>。</li>
<li>表达式 <code>p + 50</code> 实际上是将指针 <code>p</code> 向后移动了 50 个 <code>int</code> 类型大小的位置，因为 <code>p</code> 是指向 <code>int</code> 的指针。</li>
<li>因此，<code>free(p + 50)</code> 将会尝试释放 <code>p</code> 指向的内存块的中间部分，这不符合内存分配和释放的规范，可能会导致未定义的行为或者程序崩溃。</li>
<li>正确的做法是只能通过 <code>free(p)</code> 来释放整个内存块，因为 <code>malloc</code> 返回的指针必须是 <code>free</code> 所接受的完整块的起始地址。</li>
</ul>
<p>（2）<strong>将内存扩充到 200 字节应该如何操作？</strong></p>
<ul>
<li><p>在 C 语言中，<code>malloc</code> 分配的内存是固定大小的，一旦分配完成后，大小不能直接更改。要将内存扩充到 200 字节，可以使用 <code>realloc</code> 函数。</p>
</li>
<li><p><code>realloc</code> 函数可以重新分配先前通过 <code>malloc</code> 或 <code>calloc</code> 分配的内存块，将其大小调整为新的字节数。</p>
</li>
<li><p>例如，要将 <code>p</code> 指向的内存块扩充到 200 字节，可以使用以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* q = (<span class="type">int</span>*)<span class="built_in">realloc</span>(p, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">if</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    p = q; <span class="comment">// 更新 p，因为 realloc 可能会返回新的地址</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>realloc(p, 200)</code> 将尝试将原始分配的内存块大小调整为 200 字节。如果内存块成功扩展，<code>realloc</code> 返回一个指向新分配区域的指针，并且原来的 <code>p</code> 指针仍然有效（或者更新为新的地址）。如果失败，返回 <code>NULL</code>，并且原来的 <code>p</code> 指针仍然有效。</p>
</li>
</ul>
<h3 id="56、malloc、realloc、calloc的区别"><a href="#56、malloc、realloc、calloc的区别" class="headerlink" title="56、malloc、realloc、calloc的区别"></a>56、malloc、realloc、calloc的区别</h3><ol>
<li>malloc函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_size)</span></span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">20</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));申请<span class="number">20</span>个<span class="type">int</span>类型的空间；</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>calloc函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">calloc</span><span class="params">(<span class="type">size_t</span> n,<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">calloc</span>(<span class="number">20</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</p>
<ol start="3">
<li>realloc函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">realloc</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></table></figure>

<p>给动态分配的空间分配额外的空间，用于扩充容量。</p>
<h3 id="57、对于-malloc-分配的内存，调用-free-后立即释放吗？"><a href="#57、对于-malloc-分配的内存，调用-free-后立即释放吗？" class="headerlink" title="57、对于 malloc() 分配的内存，调用 free() 后立即释放吗？"></a>57、对于 malloc() 分配的内存，调用 free() 后立即释放吗？</h3><p>在使用 <code>brk()</code> 或 <code>sbrk()</code> 分配的情况下，这块内存并不会立即返还给操作系统，而是标记为<strong>可再利用状态</strong>，并被 <code>ptmalloc</code> 使用双链表保存起来。当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时 <code>ptmalloc</code> 也会尝试对小块内存进行合并，避免过多的内存碎片。如果释放的是堆末端的内存，程序的断点可能会被回退，从而实际上将内存返还给操作系统。</p>
<p>而对于使用 <code>mmap()</code> 分配的较大内存块，在调用 <code>free()</code> 后通常会通过 <code>munmap()</code> 立即返还给操作系统。</p>
<h3 id="58、既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么-malloc-不全部使用-mmap-来实现，而是仅仅对于大于-128k-的大块内存才使用-mmap-？"><a href="#58、既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么-malloc-不全部使用-mmap-来实现，而是仅仅对于大于-128k-的大块内存才使用-mmap-？" class="headerlink" title="58、既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么 malloc() 不全部使用 mmap() 来实现，而是仅仅对于大于 128k 的大块内存才使用 mmap()？"></a>58、既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么 malloc() 不全部使用 mmap() 来实现，而是仅仅对于大于 128k 的大块内存才使用 mmap()？</h3><p>因为向操作系统申请内存，是要通过系统调用的，执行系统调用是要进入内核态的，然后在回到用户态，运行态的切换会耗费不少时间。所以，申请内存的操作应该避免频繁的系统调用，如果都用 mmap 来分配内存，等于每次都要执行系统调用。</p>
<p>另外，因为 mmap 分配的内存每次释放的时候，都会归还给操作系统，于是每次  mmap 分配的虚拟地址都是缺页状态的，然后在第一次访问该虚拟地址的时候，就会触发缺页中断。也就是说，<strong>频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大</strong>。</p>
<p>为了改进这两个问题，malloc 通过 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。等下次在申请内存的时候，就直接从内存池取出对应的内存块就行了，而且可能这个内存块的虚拟地址与物理地址的映射关系还存在，这样不仅减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低 CPU 的消耗。</p>
<h3 id="59、kmalloc-和用户态的-malloc-有什么区别。"><a href="#59、kmalloc-和用户态的-malloc-有什么区别。" class="headerlink" title="59、kmalloc() 和用户态的 malloc() 有什么区别。"></a>59、kmalloc() 和用户态的 malloc() 有什么区别。</h3><ul>
<li><code>kmalloc()</code> 是在<strong>内核空间</strong>中使用的内存分配函数，主要用于为内核模块或驱动程序分配内存，直接从操作系统的内核内存池中分配内存，这部分内存通常是预先保留给内核的，不会被用户空间的应用程序直接访问。</li>
<li><code>malloc()</code> 是在<strong>用户空间</strong>中使用的内存分配函数，用于应用程序分配内存，分配的内存来自于用户空间的堆区，这部分内存是由操作系统管理，供所有用户程序共享使用。</li>
</ul>
<h3 id="60、在已申请的内存中构造对象如何实现？"><a href="#60、在已申请的内存中构造对象如何实现？" class="headerlink" title="60、在已申请的内存中构造对象如何实现？"></a>60、在已申请的内存中构造对象如何实现？</h3><p>使用<code>placement new</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="built_in">sizeof</span>(MyClass)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在buffer指定的地址上构造MyClass对象</span></span><br><span class="line">MyClass* pMyClass = <span class="built_in">new</span> (buffer) <span class="built_in">MyClass</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动调用析构函数</span></span><br><span class="line">pMyClass-&gt;~<span class="built_in">MyClass</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>构造和析构</strong>：使用 placement new 构造对象后，必须手动调用该对象的析构函数来确保正确的资源释放。因为普通的 delete 操作符会尝试释放内存，这在使用 placement new 时是不适用的。</li>
<li><strong>对齐要求</strong>：需要确保传递给 placement new 的内存地址满足对象的对齐要求。</li>
<li><strong>内存管理</strong>：使用 placement new 的代码需要格外注意内存的管理，以避免内存泄露或重复析构等问题。</li>
</ul>
<h3 id="61、new-、operator-new-和-placement-new-区别"><a href="#61、new-、operator-new-和-placement-new-区别" class="headerlink" title="61、new 、operator new 和 placement new 区别"></a>61、new 、operator new 和 placement new 区别</h3><p>（1）<code>new</code>：不能被重载，其行为总是一致的。它先调用 operator new 分配内存，然后调用构造函数初始化那段内存。</p>
<p>（2）<code>operator new</code>：要实现不同的内存分配行为，应该重载 operator new，而不是 new。</p>
<ul>
<li>operator new 就像 operator + 一样，是可以重载的。<strong>如果类中没有重载 operator new，那么调用的就是全局的 ::operator  new 来完成堆的分配。</strong>同理，operator new[]、operator delete、operator delete[] 也是可以重载的。</li>
<li>重载时，返回类型必须声明为 void*，第一个参数类型必须为表达要求分配空间的大小（字节），类型为 size_t，可以带其它参数。</li>
</ul>
<p>（3）<code>placement new</code>：<strong>只是 operator new 重载的一个标准、全局的版本</strong>。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。因此不能删除它，但需要调用对象的析构函数。placement new 允许在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。原型中 void* p 实际上就是指向一个已经分配好的内存缓冲区的的首地址。</p>
<h3 id="62、对于-delete-parray，编译器怎么知道-parray-这个指针实际指向的是数组还是单个元素？"><a href="#62、对于-delete-parray，编译器怎么知道-parray-这个指针实际指向的是数组还是单个元素？" class="headerlink" title="62、对于 delete[] parray，编译器怎么知道 parray 这个指针实际指向的是数组还是单个元素？"></a>62、对于 delete[] parray，编译器怎么知道 parray 这个指针实际指向的是数组还是单个元素？</h3><p>对象在分配时分配器会自动写一个日志（即在分配的内存之前有一个结构），用于记录分配的大小，分配内容的 <code>sizeof</code> 等等。直观来说，<code>delete</code>和<code>delete[]</code>都是传入一个<code>void*</code>，因此如果不保存日志就无法知道分配时到底是分配了一个还是多个单元。所以虽然<code>delete</code>和<code>delete[]</code>不同，但是分配器在执行释放过程中都会读取这个日志，从而了解到底应该释放多少内存。</p>
<p>但是有个前提：对象类型（或其基类）有显式析构函数。换句话说，析构函数是<code>non-virtual</code>的。否则的话，数组前面是没有这个日志的。对于析构函数是<code>virtual</code>的情况，<code>delete[]</code>时无需调用其析构函数，因此此时<code>VC</code>把<code>delete[]</code>当做<code>delete</code>同样处理。</p>
<h3 id="63、比如有一个-1G-的数据，频繁调用-new-malloc-以及-delete-free，如何优化性能？"><a href="#63、比如有一个-1G-的数据，频繁调用-new-malloc-以及-delete-free，如何优化性能？" class="headerlink" title="63、比如有一个 1G 的数据，频繁调用 new&#x2F;malloc 以及 delete&#x2F;free，如何优化性能？"></a>63、比如有一个 1G 的数据，频繁调用 new&#x2F;malloc 以及 delete&#x2F;free，如何优化性能？</h3><p>频繁调用 <code>new</code>&#x2F;<code>malloc</code> 和 <code>delete</code>&#x2F;<code>free</code> 可能导致内存分配和释放的开销增加，从而影响系统性能。针对这种情况，可以考虑以下优化策略：</p>
<ol>
<li><strong>内存池管理</strong>：<ul>
<li>实现自定义的内存池，预先分配一定大小的内存块，而不是每次调用 <code>new</code>&#x2F;<code>malloc</code> 时都向系统请求内存。这样可以减少系统调用次数和内存碎片化。内存池可以是固定大小的块，也可以是根据需要动态增长或缩减的块。它们可以通过链表或者数组来管理。</li>
</ul>
</li>
<li><strong>对象池技术</strong>：<ul>
<li>如果频繁创建和销毁对象，可以使用对象池技术。对象池在程序启动时预先创建一定数量的对象，并在需要时从池中获取对象，使用完毕后再放回池中。这样可以避免对象的重复创建和销毁，减少内存分配和释放的开销。</li>
</ul>
</li>
<li><strong>重用机制</strong>：<ul>
<li>尽可能重用已分配的内存块。在需要释放内存时，不立即释放，而是放入一个空闲链表或者空闲对象池中，以便下次分配时能够快速重用。</li>
<li>对于频繁分配相同大小的内存，可以采用内存池的方式进行管理，避免反复请求和释放系统内存。</li>
</ul>
</li>
<li><strong>内存分配策略优化</strong>：<ul>
<li>对于需要频繁分配和释放的小对象，可以考虑使用更高效的分配策略，如 <code>std::allocator</code> 或者专门优化的内存分配器（如 tcmalloc 或 jemalloc）。</li>
<li>这些分配器通常比标准库的 <code>malloc</code> 和 <code>free</code> 实现更加高效，能够降低内存碎片化和系统调用次数。</li>
</ul>
</li>
<li><strong>避免内存泄漏和悬空指针</strong>：<ul>
<li>确保每次分配的内存均能在适当的时候释放，避免内存泄漏。</li>
<li>使用智能指针（如 <code>std::shared_ptr</code>、<code>std::unique_ptr</code>）等 RAII 技术管理资源，可以有效避免悬空指针和内存泄漏问题。</li>
</ul>
</li>
<li><strong>内存分配的时机和位置</strong>：<ul>
<li>在程序设计阶段，合理规划和设计内存的分配和释放时机，尽量避免频繁的动态内存分配和释放。可以考虑在初始化阶段预分配一部分内存，减少后续的动态内存操作频率。</li>
</ul>
</li>
</ol>
<h3 id="64、内存分配的过程是怎样的？"><a href="#64、内存分配的过程是怎样的？" class="headerlink" title="64、内存分配的过程是怎样的？"></a>64、内存分配的过程是怎样的？</h3><p>应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。</p>
<p>当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存， 这时会发现这个虚拟内存没有映射到物理内存， CPU 就会产生<strong>缺页中断</strong>，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler （缺页中断函数）处理。缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。</p>
<h3 id="65、内存紧张-没有空闲物理内存时有哪些操作？"><a href="#65、内存紧张-没有空闲物理内存时有哪些操作？" class="headerlink" title="65、内存紧张&#x2F;没有空闲物理内存时有哪些操作？"></a>65、内存紧张&#x2F;没有空闲物理内存时有哪些操作？</h3><p>如果没有空闲的物理内存，那么内核就会开始进行<strong>回收内存</strong>的工作，回收的方式主要是两种：直接内存回收和后台内存回收。</p>
<ul>
<li><strong>后台内存回收</strong>（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程<strong>异步</strong>的，不会阻塞进程的执行。</li>
<li><strong>直接内存回收</strong>（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是<strong>同步</strong>的，会阻塞进程的执行。</li>
</ul>
<p>如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，内核触发 <strong>OOM （Out of Memory）机制</strong>。OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406302002710.png" alt="img"></p>
<h3 id="66、哪些内存可以被回收？"><a href="#66、哪些内存可以被回收？" class="headerlink" title="66、哪些内存可以被回收？"></a>66、哪些内存可以被回收？</h3><p>主要有两类内存可以被回收，而且它们的回收方式也不同。</p>
<ul>
<li><strong>文件页</strong>（File-backed  Page）：内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）都叫作文件页。大部分文件页，都可以直接释放内存，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。所以，<strong>回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存</strong>。</li>
<li><strong>匿名页</strong>（Anonymous Page）：这部分内存没有实际载体，不像文件缓存有硬盘文件这样一个载体，比如堆、栈数据等。这部分内存很可能还要再次被访问，所以不能直接释放内存，它们<strong>回收的方式是通过 Linux 的 Swap 机制</strong>，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。</li>
</ul>
<p>文件页和匿名页的回收都是基于 LRU 算法，也就是优先回收不常访问的内存。LRU 回收算法，实际上维护着 active 和 inactive 两个双向链表，其中：</p>
<ul>
<li><strong>active_list</strong> 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；</li>
<li><strong>inactive_list</strong> 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</li>
</ul>
<p>越接近链表尾部，就表示内存页越不常访问。这样，在回收内存时，系统就可以根据活跃程度，优先回收不活跃的内存。</p>
<h3 id="67、针对回收内存页导致的性能影响，有哪些解决方式？"><a href="#67、针对回收内存页导致的性能影响，有哪些解决方式？" class="headerlink" title="67、针对回收内存页导致的性能影响，有哪些解决方式？"></a>67、针对回收内存页导致的性能影响，有哪些解决方式？</h3><ol>
<li><p><strong>设置 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness，调整文件页和匿名页的回收倾向，尽量倾向于回收文件页；</strong></p>
<p>从文件页和匿名页的回收操作来看，文件页的回收操作对系统的影响相比匿名页的回收操作会少一点，因为文件页对于干净页回收是不会发生磁盘 I&#x2F;O 的，而匿名页的 Swap 换入换出这两个操作都会发生磁盘 I&#x2F;O。</p>
<p>Linux 提供了一个 <code>/proc/sys/vm/swappiness</code> 选项，用来调整文件页和匿名页的回收倾向。</p>
<p>swappiness 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaolin ~]# cat /proc/sys/vm/swappiness</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>一般建议 swappiness 设置为 0（默认值是 60），这样在回收内存的时候，会更倾向于文件页的回收，但是并不代表不会回收匿名页。</p>
</li>
<li><p><strong>设置 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;min_free_kbytes，调整 kswapd 内核线程异步回收内存的时机；</strong></p>
<p>如果系统时不时发生抖动，并且在抖动的时间段里如果通过 sar -B 观察到 pgscand 数值很大，那大概率是因为「直接内存回收」导致的。针对这个问题，解决的办法就是，可以通过尽早的触发「后台内存回收」来避免应用程序进行直接内存回收。</p>
<p>kswapd 会定期扫描内存的使用情况，根据剩余内存（pages_free）的情况来进行内存回收的工作。如果剩余内存（pages_free）在页低阈值（pages_low）和页最小阈值（pages_min）之间，说明内存压力比较大，剩余内存不多了。<strong>这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值（pages_high）为止</strong>。虽然会触发内存回收，但是不会阻塞应用程序，因为两者关系是异步的。</p>
</li>
<li><p><strong>设置  &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;zone_reclaim_mode，调整 NUMA 架构下内存回收策略，建议设置为  0，这样在回收本地内存之前，会在其他 Node 寻找空闲内存，从而避免在系统还有很多空闲内存的情况下，因本地 Node  的本地内存不足，发生频繁直接内存回收导致性能下降的问题。</strong></p>
</li>
</ol>
<h3 id="68、在-4GB-物理内存的机器上，申请-8GB-内存，会怎么样？"><a href="#68、在-4GB-物理内存的机器上，申请-8GB-内存，会怎么样？" class="headerlink" title="68、在 4GB 物理内存的机器上，申请 8GB 内存，会怎么样？"></a>68、在 4GB 物理内存的机器上，申请 8GB 内存，会怎么样？</h3><ul>
<li>在 32 位操作系统，因为进程理论上最大能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。</li>
<li>在 64位 位操作系统，因为进程理论上最大能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：<ul>
<li>如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；</li>
<li>如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；</li>
</ul>
</li>
</ul>
<h3 id="69、函数进栈退栈原理，esp、ebp、实参怎么传递？怎么退栈之类的过程？"><a href="#69、函数进栈退栈原理，esp、ebp、实参怎么传递？怎么退栈之类的过程？" class="headerlink" title="69、函数进栈退栈原理，esp、ebp、实参怎么传递？怎么退栈之类的过程？"></a>69、函数进栈退栈原理，esp、ebp、实参怎么传递？怎么退栈之类的过程？</h3><p>在一个函数中，调用另外一个函数，往往有以下几个步骤：</p>
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>指令归属函数</th>
<th>SP 变化</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>push arg2</td>
<td>主函数</td>
<td>sp-4</td>
<td></td>
</tr>
<tr>
<td>push arg1</td>
<td>主函数</td>
<td>sp-4</td>
<td></td>
</tr>
<tr>
<td>call function</td>
<td>主函数</td>
<td>sp-4</td>
<td>开始调用子程序，同时保存返回地址</td>
</tr>
<tr>
<td>push ebp</td>
<td>子函数</td>
<td>sp-4</td>
<td></td>
</tr>
<tr>
<td>push ebp, esp</td>
<td>子函数</td>
<td>sp-4</td>
<td>将当前 sp 存入 bp，目的是定位函数参数</td>
</tr>
<tr>
<td>sub sp, #num</td>
<td>子函数</td>
<td>sp-num</td>
<td>为子程序分配栈空间</td>
</tr>
<tr>
<td>…</td>
<td>子函数</td>
<td>…</td>
<td>函数的具体实现逻辑</td>
</tr>
<tr>
<td>pop ebp</td>
<td>子函数</td>
<td>sp+4</td>
<td></td>
</tr>
<tr>
<td>ret</td>
<td>子函数</td>
<td>sp+4</td>
<td></td>
</tr>
</tbody></table>
<p>说明：</p>
<ul>
<li><code>push arg</code> 在调用一个函数之前，通过 push 把传递的参数压栈。每次 push 之后，栈多了一个字长（32 位系统 –&gt; 4 字节），因此栈顶需要往上移动 4 字节，该指令暗含 sub sp, #4</li>
<li><code>call</code> call 指令用来调用某个函数，该指令有两个操作（1）将返回地址压入栈；（2）同时 sp &#x3D; sp - 4</li>
<li><code>push ebp</code> <code>push ebp, esp</code> 用于保存上一个函数栈的基址，并更新本函数的基址</li>
<li><code>ret</code>，即 return，此时 sp 指向 call 指令刚刚压入的返回地址；执行 ret 其实就是（1）将此时栈中的数据弹出，存至 eip 寄存器，eip 存放的是下一条即将执行的指令的地址；（2）同时 sp &#x3D; sp + 4</li>
<li><code>ret</code> 指令相当于 <code>pop eip; esp = esp + 4</code></li>
<li><code>call</code> 指令相当于 <code>push eip; esp = esp - 4</code></li>
</ul>
<blockquote>
<p>主函数调用子函数</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301556491.png" alt="在这里插入图片描述"></p>
<p>子函数返回主函数</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301556054.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="70、分段为什么会产生内存碎片的问题？"><a href="#70、分段为什么会产生内存碎片的问题？" class="headerlink" title="70、分段为什么会产生内存碎片的问题？"></a>70、分段为什么会产生内存碎片的问题？</h3><ol>
<li>当程序动态分配内存时，如果请求的内存大小比当前空闲块大，但分配的内存不是连续的，就会在已有的空闲块中留下未被利用的空间。</li>
<li>当程序释放内存时，如果释放的内存顺序不是按照申请的顺序释放，会导致内存空闲块的分布变得不连续。这样在后续再次分配内存时，可能无法利用之前释放的碎片空间，从而导致更多的碎片产生。</li>
<li>某些内存分配算法（如首次适应、最佳适应）会根据当前的空闲内存块选择最合适的块分配给请求的内存大小。如果空闲块的分布不合理或者已分配的内存块大小和释放的大小不匹配，就容易产生碎片。</li>
</ol>
<h3 id="71、分段为什么会导致内存交换效率低的问题？"><a href="#71、分段为什么会导致内存交换效率低的问题？" class="headerlink" title="71、分段为什么会导致内存交换效率低的问题？"></a>71、分段为什么会导致内存交换效率低的问题？</h3><p>对于多进程的系统来说，用分段的方式，外部内存碎片是很容易产生的，产生了外部内存碎片时就不得不重新 <code>Swap</code> 内存区域，这个过程会产生性能瓶颈。</p>
<p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong>为了解决内存分段的「外部内存碎片和内存交换效率低」的问题，就出现了内存分页（<code>Paging</code>）。</p>
<h3 id="72、Swap-分区"><a href="#72、Swap-分区" class="headerlink" title="72、Swap 分区"></a>72、Swap 分区</h3><p>Swap 就是把一块磁盘空间或者本地文件，当成内存来使用，它包含换出和换入两个过程：</p>
<ul>
<li><strong>换出（Swap Out）</strong> ，是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存；</li>
<li><strong>换入（Swap In）</strong>，是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来。</li>
</ul>
<p>Linux 中的 Swap 机制会在内存不足和内存闲置的场景下触发：</p>
<ul>
<li><strong>内存不足</strong>：当系统需要的内存超过了可用的物理内存时，内核会将内存中不常使用的内存页交换到磁盘上为当前进程让出内存，保证正在执行的进程的可用性，这个内存回收的过程是强制的直接内存回收（Direct Page Reclaim）。直接内存回收是同步的过程，会阻塞当前申请内存的进程。</li>
<li><strong>内存闲置</strong>：应用程序在启动阶段使用的大量内存在启动后往往都不会使用，通过后台运行的守护进程（kSwapd），我们可以将这部分只使用一次的内存交换到磁盘上为其他内存的申请预留空间。kSwapd 是 Linux 负责页面置换（Page replacement）的守护进程，它也是负责交换闲置内存的主要进程，它会在空闲内存低于一定水位时，回收内存页中的空闲内存保证系统中的其他进程可以尽快获得申请的内存。kSwapd 是后台进程，所以回收内存的过程是异步的，不会阻塞当前申请内存的进程。</li>
</ul>
<h3 id="73、分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？"><a href="#73、分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？" class="headerlink" title="73、分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？"></a>73、分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？</h3><p>内存分页由于内存空间都是预先划分好的，也就不会像内存分段一样，在段与段之间会产生间隙非常小的内存，这正是分段会产生外部内存碎片的原因。而<strong>采用了分页，页与页之间是紧密排列的，所以不会有外部碎片。</strong></p>
<p>但是，因为内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以针对<strong>内存分页机制会有内部内存碎片</strong>的现象。</p>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<strong>内存交换的效率就相对比较高。</strong></p>
<p>更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是<strong>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</strong></p>
<h3 id="74、页表是什么，页多大，为什么是-4KB？"><a href="#74、页表是什么，页多大，为什么是-4KB？" class="headerlink" title="74、页表是什么，页多大，为什么是 4KB？"></a>74、页表是什么，页多大，为什么是 4KB？</h3><p>页表是操作系统中用于实现虚拟内存管理的一种数据结构，它用于将虚拟地址映射到物理地址。这种机制允许计算机的操作系统为每个运行的程序提供一种看似连续的内存地址空间，即使物理内存是分散存储的。</p>
<p>每个页表条目存储着虚拟页面到物理页面的映射信息，通常包括物理页帧的基地址和一些状态位（如访问权限、是否已加载到物理内存中等）。由于地址空间的扩大，单级页表的大小会非常庞大，因此现代操作系统通常使用多级页表结构来减少内存占用，如x86架构常用的二级或三级页表。</p>
<p>在多数现代操作系统中，标准的页面大小是4KB（4096字节）。linux 会以页面为单位对内存进行管理。不论是将磁盘中的数据加载到内存中，还是将内存中的数据写回磁盘中，操作系统都会以页面为单位进行操作，这也意味着如果我们只向磁盘中写入一个字节的数据，操作系统也需要将整个页面中的全部数据刷入磁盘中。过小的页面大小会带来较大的页表项增加寻址时 TLB（Translation lookaside buffer）的查找速度和额外开销；过大的页面大小会浪费内存空间，造成内存碎片，降低内存的利用率；上个世纪在设计内存页大小时充分考虑了上述的两个因素，最终选择了 4KB 的内存页作为操作系统最常见的页大小，这个大小也就沿用至今。</p>
<h3 id="75、分页机制下，虚拟地址和物理地址是如何映射的？"><a href="#75、分页机制下，虚拟地址和物理地址是如何映射的？" class="headerlink" title="75、分页机制下，虚拟地址和物理地址是如何映射的？"></a>75、分页机制下，虚拟地址和物理地址是如何映射的？</h3><p>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，页表是存储在内存里的，<strong>内存管理单元</strong> （MMU）就做将虚拟内存地址转换成物理地址的工作。而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>
<p>在分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址。</p>
<p>对于一个内存地址转换，其实就是这样三个步骤：</p>
<ul>
<li>把虚拟内存地址，切分成页号和偏移量；</li>
<li>根据页号，从页表里面，查询对应的物理页号；</li>
<li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li>
</ul>
<blockquote>
<p>64 位虚拟地址的格式为：全局页目录项（9位）+ 上层页目录项（9位）+ 中间页目录项（9位）+ 页表项（9位）+ 页内偏移（12位）。共 48 位组成的虚拟内存地址。</p>
<p>32 位虚拟地址的格式为：页目录项（10位）+ 页表项（10位） + 页内偏移（12位）。共 32 位组成的虚拟内存地址。</p>
</blockquote>
<h3 id="76、为什么会产生多级页表？"><a href="#76、为什么会产生多级页表？" class="headerlink" title="76、为什么会产生多级页表？"></a>76、为什么会产生多级页表？</h3><p>对于单页表的实现方式，在 32 位和页大小 <code>4KB</code> 的环境下，一个进程的页表需要装下 100 多万个「页表项」，并且每个页表项是占用 4 字节大小的，于是相当于每个页表需占用 4MB 大小的空间。</p>
<p>我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 <code>1024</code> 个页表（二级页表），每个表（二级页表）中包含 <code>1024</code> 个「页表项」，形成<strong>二级分页</strong>。</p>
<p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。</p>
<p>利用这一特性，可以把最常访问的几个页表项存储到访问速度更快的硬件，于是在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（Translation Lookaside Buffer） ，通常称为页表缓存、转址旁路缓存、快表等。</p>
<h3 id="77、缺页中断什么时候发生？"><a href="#77、缺页中断什么时候发生？" class="headerlink" title="77、缺页中断什么时候发生？"></a>77、缺页中断什么时候发生？</h3><p>（1）当程序要访问的页面不在物理内存中时，会触发缺页中断。这通常发生在虚拟内存中，即当前只有部分的页面写入了物理内存。</p>
<p>（2）当程序尝试进行一个违反内存规则的操作时，也会触发缺页中断。比如，当程序试图对一个只读页面进行写操作，或是访问一个不允许被访问的页面。</p>
<h3 id="78、常见的缺页中断算法-页面置换算法有哪些？"><a href="#78、常见的缺页中断算法-页面置换算法有哪些？" class="headerlink" title="78、常见的缺页中断算法&#x2F;页面置换算法有哪些？"></a>78、常见的缺页中断算法&#x2F;页面置换算法有哪些？</h3><ul>
<li><p>最佳页面置换算法（<em>OPT</em>）</p>
<p>最佳页面置换算法基本思路是，<strong>置换在「未来」最长时间不访问的页面</strong>。</p>
</li>
<li><p>先进先出置换算法（<em>FIFO</em>）</p>
<p><strong>选择在内存驻留时间很长的页面进行中置换</strong>，这个就是「先进先出置换」算法的思想。</p>
</li>
<li><p>最近最久未使用的置换算法（<em>LRU</em>）</p>
<p>发生缺页时，<strong>选择最长时间没有被访问的页面进行置换</strong>，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。</p>
</li>
<li><p>时钟页面置换算法（<em>Lock</em>）</p>
<p>该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。</p>
<p>当发生缺页中断时，算法首先检查表针指向的页面：</p>
<ul>
<li>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li>
<li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止。</li>
</ul>
</li>
<li><p>最不常用置换算法（<em>LFU</em>）</p>
<p><strong>当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰</strong>。</p>
</li>
</ul>
<h3 id="79、写时拷贝在操作系统中有哪些应用？"><a href="#79、写时拷贝在操作系统中有哪些应用？" class="headerlink" title="79、写时拷贝在操作系统中有哪些应用？"></a>79、写时拷贝在操作系统中有哪些应用？</h3><ol>
<li><strong>内存管理</strong>：<ul>
<li><strong>分页系统</strong>：在许多操作系统中，写时拷贝技术常用于内存管理。当进程执行 fork 操作创建子进程时，操作系统并不立即为子进程复制父进程的整个地址空间。相反，它让父子进程共享同一物理内存页面，只有当其中一个进程尝试修改这些共享页面时，操作系统才会复制这些页面（COW），从而实现了资源的有效利用和快速的进程创建。</li>
<li><strong>虚拟内存系统</strong>：在虚拟内存系统中，写时拷贝技术可以减少不必要的数据复制，提高内存使用效率，只有在需要写入时才进行物理内存的分配和数据复制。</li>
</ul>
</li>
<li><strong>文件系统</strong>：<ul>
<li><strong>快照功能</strong>：在支持快照的文件系统（如 ZFS 或 Btrfs ）中，写时拷贝用于实现文件系统的版本控制。当文件系统状态需要保存为历史快照时，原始数据保持不变，任何对数据的修改都通过复制修改前的数据块来实现，从而快速创建快照并节省空间。</li>
</ul>
</li>
</ol>
<h2 id="三、编译程序相关"><a href="#三、编译程序相关" class="headerlink" title="三、编译程序相关"></a>三、编译程序相关</h2><h3 id="80、从-C-文件到可执行文件经过了哪几个阶段？具体描述。"><a href="#80、从-C-文件到可执行文件经过了哪几个阶段？具体描述。" class="headerlink" title="80、从 C++ 文件到可执行文件经过了哪几个阶段？具体描述。"></a>80、从 C++ 文件到可执行文件经过了哪几个阶段？具体描述。</h3><blockquote>
<p>预处理、编译、汇编、链接，最后生成可执行文件。</p>
</blockquote>
<ol>
<li><p><strong>预处理阶段</strong>：对伪指令和特殊符号进行处理，将<code>.c</code>文件转为<code>.i</code>文件；</p>
<ol>
<li>处理包含指令 <code>#include</code></li>
<li>进行宏展开；</li>
<li>进行条件编译，如 <code>#if</code>、<code>#endif</code>、<code>#ifdef</code> 等；</li>
<li>处理 <code>#include</code> 预编译指令；</li>
<li>删除所有的注释 <code>//</code> 和 <code>/**/</code>；</li>
<li>保留所有的 <code>#pragma</code> 编译器指令，编译器需要使用它们；</li>
<li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息。</li>
</ol>
</li>
<li><p><strong>编译阶段</strong>：将编译文件转换成汇编代码，生成相应的汇编代码<code>.s</code>文件；</p>
</li>
<li><p><strong>汇编阶段</strong>：将汇编文件转化成机器码，将 <code>.s</code> 文件转为 <code>.o</code> 文件，即可重定位目标文件</p>
</li>
<li><p><strong>链接阶段</strong>：将多个目标文件及所需要的库连接成最终的可执行目标文件。链接分为<strong>静态链接</strong>和<strong>动态链接</strong>，静态链接和动态链接的最大区别就是链接的时机不一样，静态链接是在形成可执行文件之前，动态链接是在程序执行时。</p>
<ol>
<li><strong>主要工作</strong>：<ul>
<li>符号解析。在目标文件和库中存在许多符号（如函数名或变量名等），需要在其他的目标文件或库中找到相应的定义，并将它们连接起来，使得程序在运行时可以找到正确的内存地址。</li>
<li>地址分配。给目标文件和库分配内存地址，并确定其在程序中的内存布局。同时需要完成重定位的工作，用实际的内存地址去替换其中的地址引用。</li>
<li>库依赖管理。链接器处理程序和库之间的依赖关系，确保所有库都被正确地包含在目标文件中。同时要处理库与库之间的依赖关系。</li>
</ul>
</li>
<li><strong>静态链接</strong><ul>
<li>源文件中的函数和数据预处理、编译、汇编形成目标文件，而静态链接库就是多个目标文件的集合。使用静态链接库时，链接器直接从库中复制这些函数和数据，并将它们和应用程序的其他模块组合起来，创建最终的可执行文件；链接是以目标文件为单位的，若多个函数都放在了一个目标文件中，可能很多没有的函数也会被一起链接进入了输出结果中。</li>
<li>缺点：<ul>
<li>每一个可执行文件中对所有需要的目标文件都需要一份副本，如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本</li>
<li>更新困难，每当库函数的代码发生改动，需要重新进行编译、连接形成可执行程序</li>
</ul>
</li>
<li>优点：可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度更快</li>
</ul>
</li>
<li><strong>动态链接</strong><ul>
<li>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接那样运行前就把所有程序模块都链接成一个单独的可执行文件。</li>
<li>动态链接的过程：假定程序 p1.o 和 p2.o 都依赖于库 lib.o，并且假定先运行 p1.o，系统首先会加载 p1.o，发现p1.o 用到了 lib.o，于是将 lib.o 加载到内存；当运行 p2.o 时，发现 p2.o 依赖于 lib.o，而此时 lib.o 已经加载到内存中了，因此不需要重新加载，此时会将已经存在的 lib.o 映射到 p2.o 的虚拟地址空间中，从而进行链接，形成可执行文件。</li>
<li>优点：<ul>
<li>即使多个程序依赖于同一个库，在执行时也共享同一份副本；</li>
<li>更新时只需要替换原来的目标文件，而无需将所有程序都重新链接一遍，当程序下次运行时，新版本的目标文件会自动被加载到内存中并连接起来，完成了程序的更新。</li>
</ul>
</li>
<li>缺点：由于链接过程从编译阶段推迟到了程序运行时，所以运行速度相对于静态链接更慢。</li>
<li><strong>动态链接如何实现重定位的：</strong>在形成可执行文件时，发现引用了一个外部的函数，此时会检查动态链接库，发现函数名时一个动态链接符号，此时在可执行程序就不对这个符号进行重定位，就把这个过程留到装载时在进行</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="81、在-terminal-输入-main-out-是怎么运行起来的？"><a href="#81、在-terminal-输入-main-out-是怎么运行起来的？" class="headerlink" title="81、在 terminal 输入 .&#x2F;main.out 是怎么运行起来的？"></a>81、在 terminal 输入 .&#x2F;main.out 是怎么运行起来的？</h3><p>在终端输入 <code>./main.out</code> 实际上是在运行名为 <code>main.out</code> 的可执行文件。这个过程涉及了操作系统的执行文件路径解析和进程创建：</p>
<ol>
<li><strong>路径解析</strong>: 终端会根据当前工作目录（或者通过绝对路径指定的位置）找到 <code>main.out</code> 可执行文件的位置。</li>
<li><strong>权限检查</strong>: 操作系统会检查当前用户是否有权限执行这个文件。如果没有权限，会提示权限不足的错误。</li>
<li><strong>进程创建</strong>: 如果权限允许，操作系统会为 <code>main.out</code> 创建一个新的进程，并加载到内存中执行。这个过程包括但不限于：<ul>
<li>将程序代码和静态数据加载到内存。</li>
<li>为程序分配堆空间和栈空间。</li>
<li>设置程序的初始状态，如传递命令行参数、环境变量等。</li>
<li>开始执行程序的 <code>main</code> 函数或者入口函数。</li>
</ul>
</li>
<li><strong>程序执行</strong>: <code>main.out</code> 开始执行，根据程序中的逻辑进行各种操作，直至程序结束或者被终止。</li>
<li><strong>退出</strong>: 程序执行完毕后，操作系统会回收分配给该程序的资源，并返回到终端或者调用者。</li>
</ol>
<h3 id="82、为什么需要有链接的过程？"><a href="#82、为什么需要有链接的过程？" class="headerlink" title="82、为什么需要有链接的过程？"></a>82、为什么需要有链接的过程？</h3><p>因为软件开发的规模很大，不可能将它们都放在同一个模块中。因此按照层次化以及模块化的视线方法，将代码分成多个部分，每个部分分别开发。因此就需要在最后将它们组装起来，这就是链接的过程。通过链接，实现符号解析、地址分配和库依赖管理等工作。</p>
<h3 id="83、假设有一个-A-dll-和-B-dll，A-dll-调用了-B-dll-的方法，A-dll-是如何找到-B-dll-中的方法的？"><a href="#83、假设有一个-A-dll-和-B-dll，A-dll-调用了-B-dll-的方法，A-dll-是如何找到-B-dll-中的方法的？" class="headerlink" title="83、假设有一个 A.dll 和 B.dll，A.dll 调用了 B.dll 的方法，A.dll 是如何找到 B.dll 中的方法的？"></a>83、假设有一个 A.dll 和 B.dll，A.dll 调用了 B.dll 的方法，A.dll 是如何找到 B.dll 中的方法的？</h3><p>在使用动态库时，链接器会将动态库的相关信息，包括动态库的名字、符号表以及可重定位信息存储到相应的可执行文件中。在可执行文件运行时，链接器会根据这些信息找到动态库是否存在、在哪里、符号引用的内存地址是哪里，也就是说找到 A.dll 引用的 B.dll 的相关方法，并通过重定位找到其物理内存地址。</p>
<h3 id="84、假设有一个-A-cpp-和-B-cpp，A-cpp-调用了-B-cpp-的方法，A-cpp-是如何找到-B-cpp-中的方法的？"><a href="#84、假设有一个-A-cpp-和-B-cpp，A-cpp-调用了-B-cpp-的方法，A-cpp-是如何找到-B-cpp-中的方法的？" class="headerlink" title="84、假设有一个 A.cpp 和 B.cpp，A.cpp 调用了 B.cpp 的方法，A.cpp 是如何找到 B.cpp 中的方法的？"></a>84、假设有一个 A.cpp 和 B.cpp，A.cpp 调用了 B.cpp 的方法，A.cpp 是如何找到 B.cpp 中的方法的？</h3><p>在汇编后，A.cpp 生成了 A.o 文件，B.cpp 生成了 B.o 的文件，A.o 和 B.o 文件都有着自己的符号表。在链接的过程，链接器会根据两者的符号表来做符号决议，判断是否能够找到引用的外部的符号，如果找到外部唯一的符号，就会进行重定位操作，来修正这一符号的地址，从而完成调用。</p>
<h3 id="85、函数调用中堆和栈的变化情况是怎样的？"><a href="#85、函数调用中堆和栈的变化情况是怎样的？" class="headerlink" title="85、函数调用中堆和栈的变化情况是怎样的？"></a>85、函数调用中堆和栈的变化情况是怎样的？</h3><p>函数调用时主要影响的是<strong>栈（stack）</strong>的变化，而不直接影响<strong>堆（heap）</strong>的变化。</p>
<ul>
<li><strong>函数进栈</strong>：<ul>
<li>调用函数时，会先将函数的参数压入栈中，参数的顺序通常是从右向左依次压入。</li>
<li>接着将当前函数的返回地址压入栈中，这个返回地址指向了调用该函数的下一条指令，用于函数执行结束后返回到调用处继续执行。</li>
<li>如果函数中有局部变量，则会在栈上为这些变量分配空间，并进行初始化。</li>
<li>最后，将当前栈指针（ESP）的值赋给基址指针（EBP），建立当前函数的栈帧。</li>
</ul>
</li>
<li><strong>函数退栈</strong>：<ul>
<li>当函数执行结束时，首先会将局部变量的值从栈中弹出，释放局部变量所占用的空间。</li>
<li>接着会将基址指针（EBP）的值赋给栈指针（ESP），恢复到函数调用之前的栈状态。</li>
</ul>
</li>
</ul>
<p>在这个过程中，函数的参数传递通常是通过栈来完成的。对于一般的函数调用，在调用函数前，调用者会将参数压入栈中；而在函数内部，被调用函数通过栈指针（ESP）来访问这些参数。在 x86 架构中，通常采用栈来传递函数参数，参数从右向左依次入栈。</p>
<h3 id="86、代码崩溃怎么解决，常见的原因是什么？"><a href="#86、代码崩溃怎么解决，常见的原因是什么？" class="headerlink" title="86、代码崩溃怎么解决，常见的原因是什么？"></a>86、代码崩溃怎么解决，常见的原因是什么？</h3><p><strong>（1）常见的崩溃原因</strong></p>
<ol>
<li><strong>访问非法内存</strong>，如已释放的内存（悬挂指针）、未初始化的指针或越界访问数组或字符串</li>
<li><strong>资源管理错误</strong>，如内存泄露，或文件或网络句柄未正确关闭</li>
<li><strong>并发错误</strong>：1）竞态条件：多个线程或进程争用数据，未正确同步；2）死锁：多个线程或进程相互等待对方持有的资源</li>
<li><strong>栈溢出</strong>：递归调用过深，或大量局部变量分配</li>
<li><strong>除零错误</strong>：整数或浮点数除以零</li>
</ol>
<p><strong>（2）解决方法</strong></p>
<ol>
<li><strong>调试工具</strong>：使用调试器（如 GDB）检查崩溃时的栈跟踪（stack trace）</li>
<li><strong>代码审查</strong></li>
<li><strong>增加日志记录</strong>：在关键操作前后添加日志记录，以追踪崩溃前的程序状态和行为；使用断言检查程序运行时的预期状态</li>
<li><strong>单元测试</strong>：编写和维护单元测试</li>
<li><strong>优化设计</strong>，避免过深的递归调用，考虑使用循环或其他算法策略；为并发操作设计合理的锁策略和线程同步机制</li>
</ol>
<h3 id="87、什么时候会发生段错误？"><a href="#87、什么时候会发生段错误？" class="headerlink" title="87、什么时候会发生段错误？"></a>87、<strong>什么时候会发生段错误？</strong></h3><p>段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况： </p>
<p>（1）使用野指针</p>
<p>（2）试图修改字符串常量的内容</p>
<h3 id="88、程序崩溃产生-core-dump一般怎么处理？"><a href="#88、程序崩溃产生-core-dump一般怎么处理？" class="headerlink" title="88、程序崩溃产生 core dump一般怎么处理？"></a>88、程序崩溃产生 core dump一般怎么处理？</h3><p>core dump 是程序由于异常在运行时异常退出或者终止，在一定的条件下生成的一个叫做 core 的文件，这个 core 文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对其进行分析可以定位到程序异常发生时对应的堆栈调用信息。</p>
<p>一般采用使用 gdb 命令对 core 文件进行调试。</p>
<h3 id="89、当程序运行时，如何将其加载到进程地址空间？"><a href="#89、当程序运行时，如何将其加载到进程地址空间？" class="headerlink" title="89、当程序运行时，如何将其加载到进程地址空间？"></a>89、当程序运行时，如何将其加载到进程地址空间？</h3><p>首先 cpu 找到程序的入口地址，入口地址在 exe 中代码段中保存，接着操作系统将进程的虚拟地址转换成物理地址，然后在内存中运行。运行完后执行代码段的下一条代码，执行过程类似，直至程序结束。</p>
<h3 id="90、-执行一个系统调用时，OS-发生的过程，越详细越好"><a href="#90、-执行一个系统调用时，OS-发生的过程，越详细越好" class="headerlink" title="90、**执行一个系统调用时，OS **发生的过程，越详细越好"></a>90、**执行一个系统调用时，OS **发生的过程，越详细越好</h3><ol>
<li><p>执行用户程序(如: fork)</p>
</li>
<li><p>根据 glibc 中的函数实现，取得系统调用号并执行<code>int $0x80</code>产生中断。</p>
</li>
<li><p>进行地址空间的转换和堆栈的切换，执行 SAVE_ALL。（进行内核模式）</p>
</li>
<li><p>进行中断处理，根据系统调用表调用内核函数。</p>
</li>
<li><p>执行内核函数。</p>
</li>
<li><p>执行 RESTORE_ALL 并返回用户模式</p>
</li>
</ol>
<h3 id="91、动态链接和静态链接的区别？"><a href="#91、动态链接和静态链接的区别？" class="headerlink" title="91、动态链接和静态链接的区别？"></a>91、动态链接和静态链接的区别？</h3><p>（1）静态链接</p>
<p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库 中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p>
<p>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个 目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p>
<p>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
<p>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西， 在执行的时候运行速度快。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301606610.png" alt="image-20240630160655511"></p>
<p>（2）动态链接</p>
<p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形 成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副 本，而是这多个程序在执行时共享同一份副本；</p>
<p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运 行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
<p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损 失。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301607955.png" alt="image-20240630160706843"></p>
<h2 id="四、Linux相关"><a href="#四、Linux相关" class="headerlink" title="四、Linux相关"></a>四、Linux相关</h2><h3 id="92、Linux-常用命令"><a href="#92、Linux-常用命令" class="headerlink" title="92、Linux 常用命令"></a>92、Linux 常用命令</h3><ol>
<li><p>切换目录：<code>cd</code></p>
</li>
<li><p>查看端口绑定情况：<code>lsof -i : [端口号]</code>或<code>netstat -tuln</code>（列出所有监听端口）</p>
</li>
<li><p>查看CPU利用率：<code>top</code>或<code>htop</code></p>
</li>
<li><p>查看进程状态：<code>ps</code>，其中进程的状态码如下：</p>
</li>
</ol>
<ul>
<li>**R (Running)**：进程正在运行或在运行队列中等待</li>
<li>**S (Sleeping)**：进程处于睡眠状态，等待某个事件或资源。</li>
<li>**D (Uninterruptible Sleep)**：进程处于不可中断的睡眠状态，通常是在等待I&#x2F;O操作</li>
<li>**T (Stopped)**：进程已停止运行，通常是因为它正在被调试或已经收到停止信号</li>
<li>**Z (Zombie)**：进程已完成执行，但仍在进程表中等待父进程读取其退出状态</li>
<li>**I (Idle)**：这是一个空闲的内核线程，这个状态在某些版本的ps输出中可能不会显示</li>
</ul>
<ol start="5">
<li>查询网络状态：<code>ifconfig</code>、<code>netstat -r # 显示路由表</code></li>
<li>查看磁盘：<code>df -h</code>、<code>lsblk</code></li>
<li>查看是哪个进程的内存占用最大：<code>top</code>+<code>M</code>键、<code>ps aux --sort=-%mem | head -10</code></li>
<li>查找文件：<code>find</code>、<code>locate</code></li>
<li>查找文件内容：<code>grep -r &quot;hello&quot; /path/to/directory</code></li>
<li>查找系统命令的位置：<code>which ls</code></li>
</ol>
<h3 id="93、0、1、2-的文件描述符是什么含义？指向什么类型的文件？"><a href="#93、0、1、2-的文件描述符是什么含义？指向什么类型的文件？" class="headerlink" title="93、0、1、2 的文件描述符是什么含义？指向什么类型的文件？"></a>93、0、1、2 的文件描述符是什么含义？指向什么类型的文件？</h3><ol>
<li>文件描述符0（标准输入）：指向标准输入设备，通常是终端（键盘）。</li>
<li>文件描述符1（标准输出）：指向标准输出设备，通常是终端（屏幕）。</li>
<li>文件描述符2（标准错误）：指向标准错误设备，通常也是终端（屏幕）。</li>
</ol>
<h3 id="94、Linux-系统中的中断为什么分为上下两个部分？"><a href="#94、Linux-系统中的中断为什么分为上下两个部分？" class="headerlink" title="94、Linux 系统中的中断为什么分为上下两个部分？"></a>94、Linux 系统中的中断为什么分为上下两个部分？</h3><p>在 Linux 系统中，中断处理通常被分为上半部（Top Half）和下半部（Bottom Half）：</p>
<ol>
<li><strong>上半部</strong>：<ul>
<li>上半部是中断处理的第一阶段，它在 CPU 接收到中断信号后立即执行。</li>
<li>在这一阶段中，中断和调度器通常被禁用，以避免在处理中断时发生新的中断，从而保证处理的原子性。</li>
<li>上半部的代码通常包含处理中断的关键代码，这部分代码的执行时间应尽可能短，以快速释放CPU资源，处理更多的中断或其他任务。</li>
</ul>
</li>
<li><strong>下半部</strong>：<ul>
<li>下半部处理的是中断处理的后续部分，通常在上半部完成后，通过添加工作项到工作队列中来延后执行。</li>
<li>在下半部执行时，中断通常是被允许的，这样可以在处理较长时间的任务时不阻塞其他中断的处理。</li>
<li>下半部负责完成数据处理、复制等操作，这些操作不需要立即完成，可以稍后处理。</li>
</ul>
</li>
</ol>
<p>这种分割方法的主要优点是能够快速响应中断，同时又不会因为长时间的数据处理而阻塞 CPU，影响系统的整体性能。通过这种方式，Linux 系统能够在保证响应速度的同时，也能有效地处理大量的数据。</p>
<h3 id="95、Linux-用户态如何进入内核态？"><a href="#95、Linux-用户态如何进入内核态？" class="headerlink" title="95、Linux 用户态如何进入内核态？"></a>95、Linux 用户态如何进入内核态？</h3><ol>
<li><strong>系统调用（System Call）</strong>:<ul>
<li>系统调用是最常见的从用户态切换到内核态的方式。</li>
<li>程序在需要执行诸如文件操作、网络通信、进程控制等操作时，会通过系统调用请求操作系统提供服务。</li>
<li>Linux 提供了大量的系统调用，例如<code>read()</code>, <code>write()</code>, <code>open()</code>, <code>fork()</code>等。</li>
<li>系统调用通过软件中断（通常是中断指令<code>int 0x80</code>或<code>syscall</code>指令）来实现，这导致处理器从用户态切换到内核态，并跳转到预定义的内核入口点执行相应的内核代码。</li>
</ul>
</li>
<li><strong>异常（Exception）</strong>:<ul>
<li>当程序执行出现错误时（如除零、访问非法内存等），会触发异常。</li>
<li>处理器会自动从用户态切换到内核态，并调用相应的异常处理程序。</li>
<li>异常处理程序在内核中定义，负责处理这些错误并决定如何恢复程序执行或终止出错的程序。</li>
</ul>
</li>
<li><strong>中断（Interrupt）</strong>:<ul>
<li>当外部设备（如键盘、鼠标、网络接口等）需要处理时，它们会向处理器发送中断信号。</li>
<li>中断信号会导致当前正在执行的用户态程序被挂起，处理器切换到内核态处理这些外部事件。</li>
<li>中断处理程序在内核中定义，用于响应和处理这些外部事件。</li>
</ul>
</li>
</ol>
<h3 id="96、如何用-gbd-调试发现线程阻塞？"><a href="#96、如何用-gbd-调试发现线程阻塞？" class="headerlink" title="96、如何用 gbd 调试发现线程阻塞？"></a>96、如何用 gbd 调试发现线程阻塞？</h3><ol>
<li><strong>启动GDB并附加到进程</strong></li>
</ol>
<p>从 GDB 启动程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb ./your_program</span><br><span class="line">run [arguments]</span><br></pre></td></tr></table></figure>

<p>附加到已经运行的程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -p [pid]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>列出所有线程</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info threads</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>切换线程</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread [thread-id]</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>检查线程的栈帧</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backtrace</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>检查锁的状态。如果怀疑是死锁或资源竞争引起的阻塞，你可以检查锁的状态。这通常需要一些对应用程序逻辑的理解，以及可能需要查看源码来确定哪些锁可能涉及阻塞。</strong></li>
</ol>
<h3 id="97、gdb-查看所有线程线程栈的命令是什么？"><a href="#97、gdb-查看所有线程线程栈的命令是什么？" class="headerlink" title="97、gdb 查看所有线程线程栈的命令是什么？"></a>97、gdb 查看所有线程线程栈的命令是什么？</h3><ol>
<li>查看所有线程： <code>info threads</code></li>
<li>查看所有线程的栈信息： <code>thread apply all bt</code></li>
</ol>
<h3 id="98、gdb-查看内存地址的命令是什么？"><a href="#98、gdb-查看内存地址的命令是什么？" class="headerlink" title="98、gdb 查看内存地址的命令是什么？"></a>98、gdb 查看内存地址的命令是什么？</h3><p><code>x/NFU address</code></p>
<ul>
<li><code>N</code> 表示要检查的单元格的数量。</li>
<li><code>F</code> 表示显示格式，例如 <code>x</code>（十六进制）、<code>d</code>（十进制）、<code>u</code>（无符号十进制）、<code>t</code>（二进制）、<code>a</code>（地址）、<code>i</code>（机器指令）、<code>c</code>（字符）等。</li>
<li><code>U</code> 表示单位大小，例如 <code>b</code>（字节）、<code>h</code>（半字，2字节）、<code>w</code>（字，4字节）、<code>g</code>（双字，8字节）。</li>
</ul>
<h2 id="处理器相关"><a href="#处理器相关" class="headerlink" title="处理器相关"></a>处理器相关</h2><h3 id="99、浮点数在计算机中怎么存储？"><a href="#99、浮点数在计算机中怎么存储？" class="headerlink" title="99、浮点数在计算机中怎么存储？"></a>99、浮点数在计算机中怎么存储？</h3><p>浮点数在计算机中的存储通常采用IEEE 754标准，这是一种广泛使用的浮点数表示方法，具体如下：</p>
<ol>
<li><strong>符号位（Sign）</strong>：用一个位来表示数值的正负，0表示正数，1表示负数。</li>
<li><strong>指数位（Exponent）</strong>：用来表示数值的指数部分，以二进制补码表示。指数部分确定了浮点数的大小范围。</li>
<li><strong>尾数位（Fraction&#x2F;Mantissa）</strong>：也称为尾数或者系数，用来表示浮点数的小数部分。通常为带有隐含的整数1的小数分数。</li>
</ol>
<p>根据IEEE 754标准，浮点数可以分为单精度（32位）和双精度（64位）两种格式：</p>
<ul>
<li><strong>单精度浮点数（float）</strong>：由32位组成，其中1位符号位，8位指数位，23位尾数位。</li>
<li><strong>双精度浮点数（double）</strong>：由64位组成，其中1位符号位，11位指数位，52位尾数位。</li>
</ul>
<p>浮点数的存储过程如下：</p>
<ul>
<li><strong>规格化（Normalization）</strong>：尾数部分总是以某个基数（通常为2）的形式表示，例如1.xxxxxx形式。尾数的最高位总是1，且不存储在浮点数中，称为隐含位。</li>
<li><strong>指数偏移（Exponent Biasing）</strong>：指数部分采用偏移值来表示，这个偏移值是为了能够表示负数指数和正数指数，避免使用纯粹的补码表示。</li>
<li><strong>特殊值和溢出（Special Values and Overflow）</strong>：IEEE 754定义了一些特殊的浮点数值，如正无穷大、负无穷大、NaN（Not a Number）等，以及处理溢出情况。</li>
</ul>
<p>浮点数的存储和计算是通过这些位字段来实现的，具体的运算和精度受到硬件支持和IEEE 754标准的限制。</p>
<h3 id="100、怎么判断两个浮点数是否相等？"><a href="#100、怎么判断两个浮点数是否相等？" class="headerlink" title="100、怎么判断两个浮点数是否相等？"></a>100、怎么判断两个浮点数是否相等？</h3><p>相减，并与预先设定的精度进行比较。不能采用 <code>==</code> 来判断。</p>
<h3 id="101、什么是大小端？如何区分？有几种方法？网络通信一般是什么字节序？"><a href="#101、什么是大小端？如何区分？有几种方法？网络通信一般是什么字节序？" class="headerlink" title="101、什么是大小端？如何区分？有几种方法？网络通信一般是什么字节序？"></a>101、什么是大小端？如何区分？有几种方法？网络通信一般是什么字节序？</h3><ol>
<li><p>大端字节序是指高位字节存储在内存的低地址端，低位字节存储在内存的高地址端；小端字节序则与之相反。</p>
</li>
<li><p>区分的方法如下：</p>
<p>（1）通过检查整数的首个字节来确定字节序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">char</span> *c = (<span class="type">char</span>*)&amp;x;</span><br><span class="line">    <span class="keyword">if</span> (*c == <span class="number">0x78</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Little Endian\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big Endian\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）<code>htons()</code>和<code>ntohs()</code></p>
<ul>
<li><code>htons(host_port)</code>：将端口号从主机字节序转换为网络字节序</li>
<li><code>ntohs(net_port)</code>：将端口号从网络字节序转换回主机字节序</li>
</ul>
</li>
<li><p>网络通信一般是大端字节序，即无论发送和接收的系统是大端还是小端，数据在通过网络传输时都必须转换为网络字节序。</p>
</li>
</ol>
<h3 id="102、什么是-qps-和-tps-，如何计算？"><a href="#102、什么是-qps-和-tps-，如何计算？" class="headerlink" title="102、什么是 qps 和 tps ，如何计算？"></a>102、什么是 qps 和 tps ，如何计算？</h3><p>（1）<strong>QPS（Queries Per Second）</strong>：每秒查询率，是衡量每秒能处理多少个查询请求的指标。它通常用于评估搜索引擎、数据库服务器和 Web 服务器的性能。QPS 可以通过将总查询数除以时间（秒）来计算。</p>
<p>（2）<strong>TPS（Transactions Per Second）</strong>：每秒事务数，是衡量系统每秒能处理多少个事务的指标。一个事务是指一个完整的业务操作，可能包含多个查询和更新。TPS 是数据库操作和商业应用（如在线支付平台）的常用性能指标。TPS 的计算方法与 QPS 类似，将总事务数除以时间（秒）。</p>
<h3 id="103、CPU-利用率拉满的时候在线程池中增加线程是否能提高-qps？"><a href="#103、CPU-利用率拉满的时候在线程池中增加线程是否能提高-qps？" class="headerlink" title="103、CPU 利用率拉满的时候在线程池中增加线程是否能提高 qps？"></a>103、CPU 利用率拉满的时候在线程池中增加线程是否能提高 qps？</h3><p>（1）对于 CPU 密集型应用，CPU 是性能瓶颈。如果 CPU 利用率已经达到 100%，这意味着 CPU 资源已经被完全使用。在这种情况下，增加更多的线程实际上会导致线程之间的竞争更加激烈，因为更多的线程需要共享有限的 CPU 资源。这可能导致上下文切换增加，反而降低了程序的效率和 QPS。</p>
<p>（2）对于 IO 密集型应用，主要的瓶颈在于 IO 操作，如磁盘读写或网络通信等。即使 CPU 利用率很高，增加线程数仍然可能提高 QPS，因为当一部分线程在等待 IO 操作完成时，其他线程可以继续执行，从而提高整体的吞吐量。在这种情况下，增加线程数可以有效利用 CPU 在等待 IO 时的空闲周期，提高 QPS。</p>
<p>（3）混合型应用同时包含 CPU 密集型和 IO 密集型的操作。在这种情况下，是否增加线程以提高 QPS 取决于应用中 CPU 密集型和 IO 密集型操作的比例。如果 IO 操作占主导，增加线程可能有助于提高 QPS；但如果 CPU 密集型操作占主导，增加线程可能不会带来预期的效果，甚至可能因为线程竞争导致性能下降。</p>
<h3 id="104、什么是-CPU-密集型应用和-I-O-密集型应用？"><a href="#104、什么是-CPU-密集型应用和-I-O-密集型应用？" class="headerlink" title="104、什么是 CPU 密集型应用和 I&#x2F;O 密集型应用？"></a>104、什么是 CPU 密集型应用和 I&#x2F;O 密集型应用？</h3><p>（1）CPU 密集型应用是指那些需要进行大量计算，消耗大量 CPU 资源的应用。这类应用的特点是 CPU 使用率很高，因为它们主要进行数学计算、逻辑判断或者数据处理等操作，这些操作需要大量的 CPU 周期来完成。CPU 密集型应用的性能很大程度上依赖于 CPU 的处理能力。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>科学计算软件</li>
<li>图像处理和视频编码</li>
<li>大数据处理应用</li>
<li>游戏服务器的游戏逻辑处理</li>
<li>加密和解密操作</li>
</ul>
<p>（2）IO 密集型应用是指那些主要时间花费在输入输出操作上，而不是 CPU 计算上的应用。这类应用的特点是频繁地进行磁盘操作或网络通信，CPU 使用率不高，但是需要等待 IO 操作的完成，因此对 IO 性能的依赖很高。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>Web 服务器</li>
<li>数据库服务器</li>
<li>文件服务器</li>
<li>客户端&#x2F;服务器应用</li>
<li>大规模日志处理系统</li>
</ul>
<h3 id="105、I-O-密集型任务把-I-O-和业务逻辑分离有什么好处？"><a href="#105、I-O-密集型任务把-I-O-和业务逻辑分离有什么好处？" class="headerlink" title="105、I&#x2F;O 密集型任务把 I&#x2F;O 和业务逻辑分离有什么好处？"></a>105、I&#x2F;O 密集型任务把 I&#x2F;O 和业务逻辑分离有什么好处？</h3><p>（1）在 IO 密集型应用中，IO 操作（如文件读写、网络数据传输等）往往是性能瓶颈。通过异步 IO 或使用专门的线程&#x2F;进程处理 IO 操作，主业务逻辑不需要等待 IO 操作的完成，从而减少等待时间，提高整体应用的响应速度和吞吐量。</p>
<p>（2）分离 IO 和业务逻辑可以使系统更有效地使用 CPU 和 IO 资源。当 IO 操作在执行时，通常涉及等待外部设备响应，这段时间CPU可以处理其他任务，从而提高资源的利用率。</p>
<p>（3）当 IO 操作与业务逻辑分开后，更易于对系统进行扩展。例如，可以根据需要增加处理 IO 的线程或进程，或者改用更高效的 IO 处理模式（如使用更高级的异步 IO 库），而不需要重大修改应用的业务逻辑部分。</p>
<p>（4）分离 IO 和业务逻辑可以使测试变得更加简单。可以独立地对 IO 部分和业务逻辑部分进行测试，例如使用模拟的 IO 操作来测试业务逻辑，确保业务逻辑的正确性而不受 IO 影响。</p>
<h3 id="106、CPU-流水线技术是什么？"><a href="#106、CPU-流水线技术是什么？" class="headerlink" title="106、CPU 流水线技术是什么？"></a>106、CPU 流水线技术是什么？</h3><p>CPU 流水线技术是一种将指令分解为多步骤并让这些步骤并行执行的技术，从而提高 CPU 的执行效率。<strong>流水线技术通过将指令执行过程分解为取指令、译码、执行、访存和写回等阶段</strong>，每个阶段由不同的硬件单元处理，使得<strong>多条指令能够重叠执行</strong>，提高了处理速度。</p>
<h3 id="107、流水线技术中的分支预测的实现和意义？"><a href="#107、流水线技术中的分支预测的实现和意义？" class="headerlink" title="107、流水线技术中的分支预测的实现和意义？"></a>107、流水线技术中的分支预测的实现和意义？</h3><p>（1） 分支预测是流水线技术中用来<strong>处理指令跳转（如条件分支）带来的中断问题</strong>。现代 CPU 使用复杂的算法来预测程序中的分支跳转是否会发生，以及跳转到哪里。常见的分支预测技术包括静态分支预测（如始终预测跳转或不跳转）和动态分支预测（如基于历史信息的预测）。</p>
<p>（2）分支预测的主要目的是减少由于分支指令导致的流水线中断，从而提高程序执行的效率。正确的分支预测可以使 CPU 继续填充流水线而不必等待分支决定，错误的预测则会导致已经进入流水线的指令被撤销，降低效率。</p>
<h3 id="108、内核和应用进行数据交互的方法有哪些？"><a href="#108、内核和应用进行数据交互的方法有哪些？" class="headerlink" title="108、内核和应用进行数据交互的方法有哪些？"></a>108、内核和应用进行数据交互的方法有哪些？</h3><ol>
<li><strong>系统调用</strong> (System Calls):<ul>
<li>系统调用是应用程序与操作系统内核之间进行交互的主要方式。应用程序通过系统调用请求内核提供服务，如文件操作、进程控制、网络通信等。系统调用提供了一种安全的机制来执行硬件操作或访问内核级资源。</li>
</ul>
</li>
<li><strong>中断和异常</strong> (Interrupts and Exceptions):<ul>
<li>中断是外部设备或条件触发的，用于通知内核需要处理某些事件。异常则是程序执行错误时的一种特殊类型的中断，如除零错误或访问违规。</li>
<li>应用程序可以通过处理这些中断和异常来与内核交互，响应外部事件或错误。</li>
</ul>
</li>
<li><strong>共享内存</strong> (Shared Memory):<ul>
<li>共享内存是一种高效的数据交换方式，允许内核和一个或多个进程之间共享一段内存区域。这种方法可以避免复制数据，提高性能。</li>
</ul>
</li>
<li><strong>信号</strong> (Signals):<ul>
<li>信号是一种通知机制，用于通知进程发生了某些事件。内核可以向进程发送信号，以响应外部事件或内部错误，进程也可以发送信号给其他进程。</li>
</ul>
</li>
<li><strong>管道和套接字</strong> (Pipes and Sockets):<ul>
<li>管道提供了一种进程间通信的方法，允许数据在进程之间单向流动。套接字则支持更复杂的网络通信，包括进程间和网络间的数据交换。</li>
</ul>
</li>
<li><strong>文件系统操作</strong>:<ul>
<li>文件系统提供了一种存储和检索数据的方法，应用程序可以通过文件操作API与内核交互，进行数据的读写、查询和管理。</li>
</ul>
</li>
</ol>
<h3 id="109、系统调用从用户到内核的底层实现是什么？"><a href="#109、系统调用从用户到内核的底层实现是什么？" class="headerlink" title="109、系统调用从用户到内核的底层实现是什么？"></a>109、系统调用从用户到内核的底层实现是什么？</h3><ol>
<li><strong>系统调用接口</strong>：用户程序通常通过一个库（如 C 标准库）提供的封装函数来发起系统调用。这些库函数会设置好所有必要的参数供系统调用使用。</li>
<li><strong>陷入指令（Trap）</strong>：库函数内部会执行一个特殊的指令，通常是<code>syscall</code>（在 x86-64 架构中）或<code>int 0x80</code>（在较老的 x86 架构中）。这个指令会生成一个软件中断，将处理器从用户模式切换到内核模式。</li>
<li><strong>系统调用编号</strong>：每个系统调用都有一个唯一的编号。这个编号由用户程序设置在一个特定的寄存器（如 x86 中的 EAX）中，内核通过这个编号来识别具体执行哪一个系统调用。</li>
<li><strong>上下文切换</strong>：执行系统调用指令后，CPU 进入内核模式，操作系统接管控制权。此时，操作系统会保存用户程序的状态（如寄存器等），并准备执行相应的内核函数。</li>
<li><strong>执行系统调用</strong>：内核根据寄存器中的系统调用编号，通过查找系统调用表来找到对应的处理函数，并执行之。</li>
<li><strong>返回用户态</strong>：系统调用完成后，操作系统将结果返回给用户程序，恢复用户程序的上下文，并将CPU控制权返回给用户程序。</li>
<li><strong>结果传递</strong>：系统调用的结果通常通过寄存器或用户空间的内存位置返回给用户程序。</li>
</ol>
<h3 id="110、内核的调度方式是什么？"><a href="#110、内核的调度方式是什么？" class="headerlink" title="110、内核的调度方式是什么？"></a>110、内核的调度方式是什么？</h3><p>在 Linux 操作系统中，内核的调度方式是指如何管理和调度系统中的进程和线程，以优化性能和响应时间。Linux 内核使用多种调度策略和算法，主要包括以下几种：</p>
<ol>
<li><strong>完全公平调度器（Completely Fair Scheduler, CFS）</strong></li>
<li><strong>实时调度器</strong>，Linux 提供了两种实时调度策略：<code>SCHED_FIFO</code>（先进先出）和 <code>SCHED_RR</code>（时间片轮转）。</li>
<li><strong>Deadline 调度器（SCHED_DEADLINE）</strong>，这是一种较新的调度策略，用于确保任务在指定的截止时间之前完成。</li>
<li><strong>Cgroups 和任务组</strong>，Linux 还支持通过控制组（cgroups）对进程进行分组管理，这允许系统管理员根据需要对不同组的资源使用进行限制和监控。</li>
</ol>
<h3 id="111、为什么要设计用户态和内核态两种状态？"><a href="#111、为什么要设计用户态和内核态两种状态？" class="headerlink" title="111、为什么要设计用户态和内核态两种状态？"></a>111、为什么要设计用户态和内核态两种状态？</h3><p>这样做是为了保护操作系统的核心部分不被用户程序直接访问和修改，从而增加系统的稳定性和安全性。</p>
<p>（1）内核态主要允许操作系统访问受保护的硬件资源和内存区域，而用户态的控制程序则限制执行一些会影响系统稳定性和安全性的操作。</p>
<p>（2）如果用户态程序崩溃，它通常不会影响运行在内核态的系统核心部分，因此整个操作系统可以继续稳定运行。</p>
<p>（3）同时用户态程序也可能因为一些错误而尝试执行非法操作，此时操作系统可以拦截这些操作，避免对核心部分造成影响。</p>
<h3 id="112、单片机启动程序，在执行-main-之前的是什么"><a href="#112、单片机启动程序，在执行-main-之前的是什么" class="headerlink" title="112、单片机启动程序，在执行 main 之前的是什么"></a>112、单片机启动程序，在执行 main 之前的是什么</h3><p>在单片机启动程序中，执行main函数之前的过程主要包括以下几个步骤：</p>
<ol>
<li><strong>硬件设置</strong>：单片机上电后，首先进行的是硬件的初始化，包括设置堆栈指针（SP）和程序计数器（PC）。</li>
<li><strong>启动文件执行</strong>：接下来，单片机会执行启动文件，通常是名为 <code>startup_xxxxx.s</code> 的汇编语言文件。这个文件负责设置单片机的初始环境和配置，为 main 函数的执行做准备。</li>
<li><strong>初始化代码</strong>：在启动文件执行后，可能还会有一些初始化代码，这些代码用于初始化单片机的硬件和软件环境，比如设置时钟、配置中断等。</li>
<li><strong>跳转到main函数</strong>：所有的初始化和设置完成后，单片机最终会跳转到 main 函数开始执行用户的程序。</li>
</ol>
<p>这个过程确保了单片机在执行用户代码之前，硬件和系统环境已经被正确地设置和初始化，从而可以正确地运行用户程序。</p>
<h3 id="113、怎么在-main-函数执行之前打印字符串？"><a href="#113、怎么在-main-函数执行之前打印字符串？" class="headerlink" title="113、怎么在 main 函数执行之前打印字符串？"></a>113、怎么在 main 函数执行之前打印字符串？</h3><p>使用全局对象的构造函数。全局对象的构造函数在程序开始执行之前被调用，因此可以在这里进行一些初始化操作，包括打印字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GlobalPrinter</span> &#123;</span><br><span class="line">    <span class="comment">// 在构造函数中打印字符串</span></span><br><span class="line">    <span class="built_in">GlobalPrinter</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Printed before main starts!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局对象，其构造函数会在 main 函数之前执行</span></span><br><span class="line">GlobalPrinter printer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside main function.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>GlobalPrinter</code> 结构体是一个全局对象，其构造函数在程序启动时执行，因此会在 <code>main</code> 函数执行之前打印 <code>&quot;Printed before main starts!&quot;</code>。</p>
<h3 id="114、cpu-怎么从内存中获取数据的，要经过哪些模块（比如执行-load-指令时）？"><a href="#114、cpu-怎么从内存中获取数据的，要经过哪些模块（比如执行-load-指令时）？" class="headerlink" title="114、cpu 怎么从内存中获取数据的，要经过哪些模块（比如执行 load 指令时）？"></a>114、cpu 怎么从内存中获取数据的，要经过哪些模块（比如执行 load 指令时）？</h3><p>当 CPU 执行 load 指令从内存中获取数据时，通常会经过以下几个主要阶段和模块：</p>
<ol>
<li><strong>地址计算</strong>：CPU 根据 load 指令中的内存地址计算要访问的物理地址。这个地址通常是通过将逻辑地址（由程序中指定的地址）转换为物理地址来完成的。</li>
<li><strong>地址总线传输</strong>：CPU 使用地址总线将计算得到的物理地址发送到内存控制器（Memory Controller）。</li>
<li><strong>内存寻址</strong>：内存控制器接收到地址后，根据地址在物理内存中定位要访问的数据块。</li>
<li><strong>数据传输</strong>：内存控制器根据地址访问内存中的数据，并通过数据总线将数据传输回 CPU。</li>
<li><strong>数据接收</strong>：CPU 接收到数据，并将其存储到指定的寄存器或者目的地。</li>
</ol>
<h3 id="115、arm-和-x86-比较明显的区别是什么？"><a href="#115、arm-和-x86-比较明显的区别是什么？" class="headerlink" title="115、arm 和 x86 比较明显的区别是什么？"></a>115、arm 和 x86 比较明显的区别是什么？</h3><p><strong>指令集架构：</strong></p>
<ul>
<li><strong>x86 架构</strong>：主要用于个人电脑和服务器，采用复杂的指令集（CISC），例如 Intel 的 x86 和 x86-64（即64位扩展）架构。x86 架构的特点是指令集较为复杂，包含大量的指令和寄存器，能够执行复杂的操作，但功耗较高。</li>
<li><strong>ARM 架构</strong>：最初设计用于低功耗和嵌入式系统，采用精简指令集（RISC）。ARM 架构的特点是指令集简洁高效，适合于低功耗和嵌入式设备，如智能手机、平板电脑、嵌入式系统等。</li>
</ul>
<h3 id="116、如果发现系统变慢，linux-会怎么考虑怎么排查这个问题？"><a href="#116、如果发现系统变慢，linux-会怎么考虑怎么排查这个问题？" class="headerlink" title="116、如果发现系统变慢，linux 会怎么考虑怎么排查这个问题？"></a>116、如果发现系统变慢，linux 会怎么考虑怎么排查这个问题？</h3><ol>
<li><p><strong>观察系统资源使用情况</strong>：</p>
<p>使用命令 <code>top</code> 或 <code>htop</code> 查看当前系统的 CPU 使用率、内存使用情况、进程状态以及各个进程的资源消耗情况。特别关注是否有某个进程消耗过多的 CPU 或内存。</p>
</li>
<li><p><strong>检查系统负载情况</strong>：使用 <code>uptime</code> 命令或者查看 <code>/proc/loadavg</code> 文件，检查系统的负载情况。如果负载过高（load average 高于 CPU 核心数），说明系统可能存在过多的并发任务或者进程阻塞。</p>
</li>
<li><p><strong>查看日志文件</strong>：检查系统日志文件（如 <code>/var/log/messages</code>、<code>/var/log/syslog</code>）以及特定服务的日志（如 Apache、MySQL 等），寻找异常或者错误信息。日志文件通常会记录系统的各种事件和错误情况。</p>
</li>
<li><p><strong>检测磁盘使用情况</strong>：使用 <code>df</code> 命令查看磁盘分区的使用情况，尤其是是否出现磁盘空间不足或者磁盘 I&#x2F;O 瓶颈的情况。</p>
</li>
<li><p><strong>网络流量分析</strong>：使用 <code>netstat</code> 或者 <code>iftop</code> 查看网络连接和流量情况，检查是否有异常的网络活动或者网络流量过高。</p>
</li>
<li><p><strong>检查系统进程</strong>：使用 <code>ps</code> 命令查看当前运行的进程，并检查是否有异常或者不必要的进程占用资源。</p>
</li>
<li><p><strong>性能分析工具</strong>：使用工具如 <code>sar</code>、<code>vmstat</code>、<code>iostat</code> 等进行系统性能分析，查看 CPU、内存、磁盘和网络的详细使用情况，帮助定位性能瓶颈。</p>
</li>
<li><p><strong>检查硬件问题</strong>：如果排查软件问题后仍未找到原因，可能需要考虑硬件问题。通过检查硬件状态和日志（如 <code>/var/log/dmesg</code>）来排除硬件故障的可能性。</p>
</li>
</ol>
<h2 id="六、Linux-命令相关"><a href="#六、Linux-命令相关" class="headerlink" title="六、Linux 命令相关"></a>六、Linux 命令相关</h2><h3 id="117、哪些状态的进程无法被-kill？"><a href="#117、哪些状态的进程无法被-kill？" class="headerlink" title="117、哪些状态的进程无法被 kill？"></a>117、哪些状态的进程无法被 kill？</h3><p><strong>内核线程（Kernel Threads）</strong>：内核线程是在内核空间中执行的线程，通常由操作系统内核创建和管理。这些线程通常处于内核态，而不是用户态，因此无法通过kill命令来终止。</p>
<p><strong>僵尸进程（Zombie Processes）</strong>：僵尸进程是已经结束但是父进程尚未对其进行处理的子进程，这种进程处于僵尸状态。虽然它们已经结束了执行，但是它们的进程描述符仍然存在于系统中，直到父进程调用 wait 或 waitpid 等系统调用来获取它们的退出状态。在僵尸状态下，进程通常是无法通过kill命令来终止的。</p>
<p><strong>被内核保护的进程</strong>：一些特殊的进程可能受到内核的保护，例如一些关键的系统服务或者核心进程。这些进程通常由操作系统内核管理，并且可能受到权限限制，无法被普通用户通过kill命令终止。</p>
<h3 id="118、kill-是怎么实现终止进程的？"><a href="#118、kill-是怎么实现终止进程的？" class="headerlink" title="118、kill 是怎么实现终止进程的？"></a>118、kill 是怎么实现终止进程的？</h3><p>在 Linux 系统中，kill 命令用于向指定进程发送信号，其中包括终止进程的 SIGKILL 信号（信号编号为 9）和其他各种信号。终止进程的实现涉及操作系统内核的功能和进程管理机制。</p>
<p>当用户使用 kill 命令向某个进程发送 SIGKILL 信号时，操作系统内核会首先验证当前用户是否具有足够的权限来发送信号给目标进程。如果具有足够的权限，则内核会查找目标进程的进程描述符，并向其发送指定的信号。</p>
<p>接收到信号的进程会根据信号的类型采取不同的行动。对于 SIGKILL 信号，目标进程会被立即终止，无法进行信号处理或者捕获。此外，进程终止时，内核会对其进行一系列清理工作，包括释放该进程所占用的资源、解除与其他进程的关联等。</p>
<h3 id="119、常见命令合集"><a href="#119、常见命令合集" class="headerlink" title="119、常见命令合集"></a>119、常见命令合集</h3><h4 id="（1）查看哪个进程的内存占用最大？"><a href="#（1）查看哪个进程的内存占用最大？" class="headerlink" title="（1）查看哪个进程的内存占用最大？"></a>（1）查看哪个进程的内存占用最大？</h4><ol>
<li><p><code>top</code>+<code>M</code>键</p>
</li>
<li><p><code>ps</code>结合<code>sort</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux --<span class="built_in">sort</span>=-%mem | <span class="built_in">head</span> -n 10</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>htop</code></p>
</li>
</ol>
<h4 id="（2）查看进程打开了什么端口？"><a href="#（2）查看进程打开了什么端口？" class="headerlink" title="（2）查看进程打开了什么端口？"></a>（2）查看进程打开了什么端口？</h4><p> <code>netstat -tulnp</code> ，列出当前系统中所有正在监听的 TCP 和 UDP 端口以及对应的进程信息。</p>
<h4 id="（3）查看进程是否存活？"><a href="#（3）查看进程是否存活？" class="headerlink" title="（3）查看进程是否存活？"></a>（3）查看进程是否存活？</h4><p><code>ps -p &lt;PID&gt;</code>，查看指定 PID 的进程信息，如果返回了进程信息，则表示该进程存活。</p>
<h4 id="（4）查看进程-id-？"><a href="#（4）查看进程-id-？" class="headerlink" title="（4）查看进程 id ？"></a>（4）查看进程 id ？</h4><p> <code>ps aux | grep &lt;进程名&gt;</code> ，查看指定进程名的所有进程，并显示它们的进程 ID。</p>
<h4 id="（5）查看进程状态？"><a href="#（5）查看进程状态？" class="headerlink" title="（5）查看进程状态？"></a>（5）查看进程状态？</h4><p><code>ps</code> ，查看进程的状态。</p>
<p><code>ps aux</code> 命令可以列出系统中所有进程的详细信息，包括状态、PID、CPU 利用率等。</p>
<h4 id="（6）lsof-指令主要是干什么的？"><a href="#（6）lsof-指令主要是干什么的？" class="headerlink" title="（6）lsof 指令主要是干什么的？"></a>（6）lsof 指令主要是干什么的？</h4><p><code>lsof（list open files）</code>主要用于显示当前系统中打开的文件列表，包括文件、目录、网络套接字等。通过 lsof 命令可以查看某个进程打开了哪些文件、网络连接等信息，用于定位进程问题、分析系统资源利用等。</p>
<h4 id="（7）-如何让进程后台运行？"><a href="#（7）-如何让进程后台运行？" class="headerlink" title="（7） 如何让进程后台运行？"></a>（7） 如何让进程后台运行？</h4><ol>
<li><p><strong>使用 &amp; 符号</strong>：</p>
<ul>
<li><p>在命令行中，在命令的末尾加上 <code>&amp;</code> 符号，可以让该命令在后台执行。</p>
</li>
<li><p>例如，要让 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python script.py</span><br></pre></td></tr></table></figure>

<p> 在后台运行，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python script.py &amp;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用 nohup 命令</strong>：</p>
<ul>
<li><p><code>nohup</code> 命令用于将程序以忽略挂断信号的方式运行，这样即使终端关闭，程序也会继续在后台运行。</p>
</li>
<li><p>使用方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> python script.py &amp;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="（8）查看一个进程可以打开多少文件描述符？"><a href="#（8）查看一个进程可以打开多少文件描述符？" class="headerlink" title="（8）查看一个进程可以打开多少文件描述符？"></a>（8）查看一个进程可以打开多少文件描述符？</h4><p>在大多数 Linux 系统中，一个进程最多可以同时打开 1024 个文件。</p>
<p>不过，可以通过修改系统配置来增加： </p>
<ul>
<li><code>ulimit -n</code>：查看当前进程的文件描述符限制；</li>
<li><code>ulimit -n 4096</code>：将文件描述符限制增加到 4096。注意的是，文件描述符限制是系统范围的，而不是针对单个进程的。因此，对文件描述符限制的修改将影响到所有正在运行的进程。</li>
</ul>
<h4 id="（9）查看-CPU-核心数？"><a href="#（9）查看-CPU-核心数？" class="headerlink" title="（9）查看 CPU 核心数？"></a>（9）查看 CPU 核心数？</h4><p><strong>方法一</strong>：<code>lscpu</code> 命令，在输出中查找 <code>CPU(s):</code> 字段。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong>：读取 <code>/proc/cpuinfo</code> 文件可以，统计 <code>processor</code> 字段的行数，等于逻辑 CPU 核心的数量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep <span class="string">&quot;processor&quot;</span> | <span class="built_in">wc</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /proc/cpuinfo：这个命令用于打印 CPU 信息到标准输出。</span></span><br><span class="line"><span class="comment"># grep &quot;processor&quot;：通过管道 | 将 cat 命令的输出传递给 grep 命令，</span></span><br><span class="line"><span class="comment">#				    然后使用 grep 进行筛选，只保留包含 &quot;processor&quot; 字符串的行，</span></span><br><span class="line"><span class="comment">#					这些行包含了每个 CPU 核心的信息。</span></span><br><span class="line"><span class="comment"># wc -l：</span></span><br><span class="line"><span class="comment">#	wc 命令用于统计文件的行数，参数 -l 表示只统计行数。</span></span><br><span class="line"><span class="comment">#   通过 | 管道将 grep 命令的输出传递给 wc 命令，然后 wc 统计行数。</span></span><br><span class="line"><span class="comment">#	因为每个 CPU 核心的信息占据一行，所以统计出来的行数就是 CPU 的核心数。</span></span><br></pre></td></tr></table></figure>

<p><strong>方法三</strong>：<code>nproc</code> 命令，直接显示可用的处理器数量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nproc</span></span><br></pre></td></tr></table></figure>

<p><strong>方法四</strong>：<code>top</code> 和 <code>htop</code> 命令也可以显示 CPU 信息。在 <code>htop</code> 中，可以在界面顶部看到 CPU 核心的数量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">htop</span><br></pre></td></tr></table></figure>

<p><strong>方法五</strong>：<code>dmesg</code> 命令，查看启动日志，可以找到 CPU 信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i cpu</span><br></pre></td></tr></table></figure>

<h4 id="（10）如何按照内存使用情况对进程排序查看？"><a href="#（10）如何按照内存使用情况对进程排序查看？" class="headerlink" title="（10）如何按照内存使用情况对进程排序查看？"></a>（10）如何按照内存使用情况对进程排序查看？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -o %MEM</span><br></pre></td></tr></table></figure>

<h4 id="（11）查看磁盘状态？"><a href="#（11）查看磁盘状态？" class="headerlink" title="（11）查看磁盘状态？"></a>（11）查看磁盘状态？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">df</span> -sh &lt;目录名&gt;</span><br></pre></td></tr></table></figure>

<h4 id="（12）查看日志文件的前一百行？"><a href="#（12）查看日志文件的前一百行？" class="headerlink" title="（12）查看日志文件的前一百行？"></a>（12）查看日志文件的前一百行？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 100 &lt;日志文件&gt;</span><br></pre></td></tr></table></figure>

<h4 id="（13）-ps-aux-，-aux-是干什么的？"><a href="#（13）-ps-aux-，-aux-是干什么的？" class="headerlink" title="（13） ps -aux ， aux 是干什么的？"></a>（13） ps -aux ， aux 是干什么的？</h4><p>在 <code>ps -aux</code> 命令中，<code>aux</code> 是选项，用于指定显示所有进程的详细信息。其中：</p>
<ul>
<li><code>a</code> 选项表示显示所有进程，包括与终端无关的进程。</li>
<li><code>u</code> 选项表示显示用户及与进程相关的详细信息，如用户 ID、CPU 占用率、内存占用等。</li>
<li><code>x</code> 选项表示显示与终端无关的进程。</li>
</ul>
<p>因此，<code>ps -aux</code> 命令用于显示系统中所有进程的详细信息，包括与终端无关的进程。</p>
<h4 id="（14）本地和远程服务器之间传输文件的是什么？"><a href="#（14）本地和远程服务器之间传输文件的是什么？" class="headerlink" title="（14）本地和远程服务器之间传输文件的是什么？"></a>（14）本地和远程服务器之间传输文件的是什么？</h4><p><code>scp</code></p>
<h4 id="（15）查找文件名包含某个关键字的文件"><a href="#（15）查找文件名包含某个关键字的文件" class="headerlink" title="（15）查找文件名包含某个关键字的文件"></a>（15）查找文件名包含某个关键字的文件</h4><p><code>find 目录 -name &quot;特定字符串&quot;</code></p>
<h3 id="120、Linux-包含哪些部分？"><a href="#120、Linux-包含哪些部分？" class="headerlink" title="120、Linux 包含哪些部分？"></a>120、Linux 包含哪些部分？</h3><ol>
<li>内核，操作系统的核心部分，负责管理计算机的硬件资源，包括处理器、内存、设备驱动程序等。它提供了系统调用接口，允许用户程序与硬件交互；</li>
<li>Shell，用户与操作系统交互的界面，它可以解释用户输入的命令并将其转换为操作系统能够理解的形式，常见的 Shell 包括 Bash、Zsh、Korn 等；</li>
<li>文件系统，指文件和目录在存储设备上的组织方式，它提供了对文件和目录的创建、读取、写入和删除等操作。常见的文件系统包括 ext4、NTFS、FAT32 等；</li>
<li>GNU 工具，一组用于开发和管理 Linux 系统的软件工具，包括编译器、调试器、文本编辑器等。常见的 GNU 工具包括 GCC、GDB、Emacs 等；</li>
<li>图形用户界面 GUI</li>
<li>应用程序。</li>
</ol>
<h3 id="121、操作系统包含哪些部分？"><a href="#121、操作系统包含哪些部分？" class="headerlink" title="121、操作系统包含哪些部分？"></a>121、操作系统包含哪些部分？</h3><ol>
<li><strong>内核（Kernel）</strong>：操作系统的核心部分，负责管理计算机的硬件资源，包括处理器、内存、设备驱动程序等。内核提供了系统调用接口，允许用户程序与硬件交互；</li>
<li><strong>文件系统（File System）</strong>：用于组织和管理计算机存储设备上的文件和目录。文件系统提供了文件的创建、读取、写入、删除等操作，以及对文件和目录的权限管理；</li>
<li><strong>进程管理（Process Management）</strong>：负责创建、调度和管理进程。进程是程序的执行实例，进程管理器控制着进程的创建、调度、终止等操作，并提供了进程间通信的机制；</li>
<li><strong>内存管理（Memory Management）</strong>：管理计算机的内存资源，包括内存的分配、释放、页面交换等操作。内存管理器负责为进程分配内存空间，并确保不同进程之间的内存地址空间互相隔离；</li>
<li><strong>文件系统（File System）</strong>：用于组织和管理计算机存储设备上的文件和目录。文件系统提供了文件的创建、读取、写入、删除等操作，以及对文件和目录的权限管理；</li>
<li><strong>设备驱动程序（Device Drivers）</strong>：负责与计算机的硬件设备进行通信，控制设备的操作和数据传输。设备驱动程序允许操作系统与硬件设备之间进行交互，以实现对硬件的控制和管理；</li>
<li><strong>用户界面（User Interface）</strong>：提供用户与操作系统交互的界面，包括命令行界面（CLI）和图形用户界面（GUI）。用户界面使用户能够通过输入命令或使用图形化界面来操作计算机；</li>
<li><strong>网络管理（Networking）</strong>：管理计算机与网络之间的通信和连接。网络管理器负责配置网络参数、管理网络接口、处理数据传输等操作，以确保计算机能够与其他设备进行通信。</li>
</ol>
<h2 id="七、文件系统"><a href="#七、文件系统" class="headerlink" title="七、文件系统"></a>七、文件系统</h2><h3 id="122、文件系统的基本组成"><a href="#122、文件系统的基本组成" class="headerlink" title="122、文件系统的基本组成"></a>122、文件系统的基本组成</h3><h3 id="123、虚拟文件系统"><a href="#123、虚拟文件系统" class="headerlink" title="123、虚拟文件系统"></a>123、虚拟文件系统</h3><h3 id="124、文件的存储"><a href="#124、文件的存储" class="headerlink" title="124、文件的存储"></a>124、文件的存储</h3><h3 id="125、空闲空间管理"><a href="#125、空闲空间管理" class="headerlink" title="125、空闲空间管理"></a>125、空闲空间管理</h3><h3 id="126、文件系统的结构"><a href="#126、文件系统的结构" class="headerlink" title="126、文件系统的结构"></a>126、文件系统的结构</h3><h3 id="127、目录的存储"><a href="#127、目录的存储" class="headerlink" title="127、目录的存储"></a>127、目录的存储</h3><h3 id="128、软链接和硬链接"><a href="#128、软链接和硬链接" class="headerlink" title="128、软链接和硬链接"></a>128、软链接和硬链接</h3><h3 id="129、文件I-O"><a href="#129、文件I-O" class="headerlink" title="129、文件I&#x2F;O"></a>129、文件I&#x2F;O</h3><h3 id="130、进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？"><a href="#130、进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？" class="headerlink" title="130、进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？"></a>130、进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？</h3><h2 id="八、设备管理"><a href="#八、设备管理" class="headerlink" title="八、设备管理"></a>八、设备管理</h2><h3 id="131、键盘敲入-A-字母时，操作系统期间发生了什么？"><a href="#131、键盘敲入-A-字母时，操作系统期间发生了什么？" class="headerlink" title="131、键盘敲入 A 字母时，操作系统期间发生了什么？"></a>131、键盘敲入 A 字母时，操作系统期间发生了什么？</h3><h2 id="九、网络系统"><a href="#九、网络系统" class="headerlink" title="九、网络系统"></a>九、网络系统</h2><h3 id="132、什么是零拷贝？"><a href="#132、什么是零拷贝？" class="headerlink" title="132、什么是零拷贝？"></a>132、什么是零拷贝？</h3><h3 id="133、I-O-多路复用：select-poll-epoll"><a href="#133、I-O-多路复用：select-poll-epoll" class="headerlink" title="133、I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll"></a>133、I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll</h3><h3 id="134、高性能网络模式：Reactor-和-Proactor"><a href="#134、高性能网络模式：Reactor-和-Proactor" class="headerlink" title="134、高性能网络模式：Reactor 和 Proactor"></a>134、高性能网络模式：Reactor 和 Proactor</h3><h3 id="135、什么是一致性哈希？"><a href="#135、什么是一致性哈希？" class="headerlink" title="135、什么是一致性哈希？"></a>135、什么是一致性哈希？</h3>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/06/12/Computer/C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" rel="prev" title="智能指针">
      <i class="fa fa-chevron-left"></i> 智能指针
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/06/13/Computer/C++/%E5%AF%B9%E5%90%AB%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E8%BF%9B%E8%A1%8Csizeof/" rel="next" title="对含有虚函数的类进行sizeof">
      对含有虚函数的类进行sizeof <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="nav-text">一、线程与进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E6%A6%82%E5%BF%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1、进程和线程以及并发和并行的概念是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90-%E3%80%912%E3%80%81%E7%BA%BF%E7%A8%8B%E6%AF%94%E8%BF%9B%E7%A8%8B%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="nav-text">【*】2、线程比进程具有哪些优势？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90-%E3%80%913%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">【*】3、什么时候用多进程？什么时候用多线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90-%E3%80%914%E3%80%81%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="nav-text">【*】4、线程内存存储在哪里？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%94%81%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">5、线程中的锁包含哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-text">6、什么是死锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90-%E3%80%917%E3%80%81%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-text">【*】7、死锁产生的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-text">8、如何避免死锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B-1%E3%80%812-%E5%8E%BB%E8%AE%BF%E9%97%AE%E5%90%8C%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90-C-%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BA%8C%E8%80%85%E5%BF%85%E9%A1%BB%E5%90%8C%E6%97%B6%E8%8E%B7%E5%8F%96%E9%94%81-A-%E5%92%8C-B-%E6%89%8D%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE-C%E3%80%82%E9%97%AE%E4%BB%80%E4%B9%88%E9%A1%BA%E5%BA%8F%E8%8E%B7%E5%8F%96%E9%94%81%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%EF%BC%8C%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E9%87%8A%E6%94%BE%E9%A1%BA%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="nav-text">9、如果有两个线程 1、2 去访问同一个资源 C ，并且二者必须同时获取锁 A 和 B 才可以访问 C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81%E4%BB%8E%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6%E6%9D%A5%E8%AF%B4%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">10、从锁的粒度来说，有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9F"><span class="nav-text">11、悲观锁和乐观锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12%E3%80%81%E5%BF%99%E7%AD%89%E5%BE%85%E5%92%8C%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">12、忙等待和阻塞的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13%E3%80%81%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%92%8C%E4%BB%80%E4%B9%88%E6%9C%89%E5%85%B3%EF%BC%9F"><span class="nav-text">13、一个进程可以创建多少线程？和什么有关？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-text">14、多线程如何保证线程安全？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E6%98%AF%E5%90%A6%E6%98%AF%E5%8E%9F%E5%AD%90%E7%9A%84%EF%BC%9F"><span class="nav-text">15、多线程环境下对变量的读写操作是否是原子的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%80%E9%94%80%E8%A6%81%E5%B0%8F%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BC%80%E9%94%80%EF%BC%9F"><span class="nav-text">16、为什么线程的开销要小于进程的开销？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%EF%BC%9F"><span class="nav-text">17、线程池中的线程数如何确定？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%AF%E4%BB%A5%E6%8F%90%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F%EF%BC%9F"><span class="nav-text">18、为什么线程池可以提高吞吐量？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90-%E3%80%9119%E3%80%81%E7%8E%B0%E5%9C%A8%E8%AE%A9%E4%BD%A0%E6%9D%A5%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E6%9C%80%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%95%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%BC%9A%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E5%91%A2%EF%BC%9F"><span class="nav-text">【*】19、现在让你来设计一个支持最大并发数的线程池你可能会怎么设计呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20%E3%80%81C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%97%B6%E8%A6%81%E9%93%BE%E6%8E%A5%E4%BB%80%E4%B9%88%E5%BA%93%EF%BC%8C%E6%80%8E%E4%B9%88%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93%EF%BC%9F"><span class="nav-text">20、C++ 多线程编程时要链接什么库，怎么找到对应的动态库？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%EF%BC%8CCPU-%E5%92%8C%E5%86%85%E5%AD%98%E4%BC%9A%E5%81%9A%E4%B8%80%E4%BA%9B%E4%BB%80%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-text">21、多线程切换，CPU 和内存会做一些什么处理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22%E3%80%81%E5%A6%82%E6%9E%9C%E7%8E%B0%E5%9C%A8%E6%9C%89%E8%BF%9C%E8%BF%9C%E5%A4%9A%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%9C%A8%E7%AD%89%E5%BE%85%E5%A4%84%E7%90%86%EF%BC%8C%E8%A6%81%E6%80%8E%E4%B9%88%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">22、如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90-%E3%80%9123%E3%80%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">【*】23、线程间的通信包括哪些方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90-%E3%80%9124%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%8E%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="nav-text">【*】24、线程同步是什么？从底层原理分析一下为什么会出现线程同步？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25%E3%80%81%E5%A4%84%E7%90%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9C%BA%E5%88%B6%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%83%B3%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B-a-%E6%89%A7%E8%A1%8C%E5%AE%8C%E4%BB%BB%E5%8A%A1%E5%90%8E%E5%86%8D%E5%8E%BB%E6%89%A7%E8%A1%8C-b%EF%BC%8C%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E8%A6%81%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-text">25、处理多线程同步问题有哪些机制？如果想等待线程 a 执行完任务后再去执行 b，这种情况要怎么处理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81%E5%88%86%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="nav-text">26、进程的五种状态分别是？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8D%E5%90%8C%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-text">27、进程不同状态转换的关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28%E3%80%81%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-text">28、孤儿进程和僵尸进程是什么，怎么处理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29%E3%80%81%E4%B8%A4%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E6%98%AF%E5%85%B1%E4%BA%AB%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-text">29、两个进程的内核空间是共享的吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">30、进程间的通信包括哪些方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90-%E3%80%9131%E3%80%81%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">【*】31、进程调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32%E3%80%81%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">32、进程同步的方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3%E7%88%B6%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">33、信号量和互斥锁解决父子线程同时阻塞的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34%E3%80%81windows-%E4%B8%8B-thread-create-%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">34、windows 下 thread_create 会有什么问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35%E3%80%81%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%9FSIGALRM-SIGSEGV-SIGINT"><span class="nav-text">35、知道哪些信号的含义？SIGALRM, SIGSEGV, SIGINT?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36%E3%80%81Ctrl-C-%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">36、Ctrl+C 后发生了什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90-%E3%80%9137%E3%80%81sigaction-%E5%8F%AF%E4%BB%A5%E5%B9%B2%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85%EF%BC%9F%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E5%B1%8F%E8%94%BD%E9%9B%86%EF%BC%9F"><span class="nav-text">【*】37、sigaction 可以干哪些事情？解释一下屏蔽集？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38%E3%80%81%E7%BA%BF%E7%A8%8B%E5%B4%A9%E6%BA%83%EF%BC%8C%E8%BF%9B%E7%A8%8B%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%B4%A9%E6%BA%83%E5%90%97%EF%BC%9F"><span class="nav-text">38、线程崩溃，进程一定会崩溃吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-text">二、内存模型&#x2F;虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#39%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-text">39、什么是虚拟内存？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90-%E3%80%9140%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%A6%81%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-text">【*】40、为什么操作系统要使用虚拟内存？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%9C%89%E6%B2%A1%E6%9C%89%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%99%90%E5%88%B6%EF%BC%9F"><span class="nav-text">41、虚拟内存有没有大小的限制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90-%E3%80%9142%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%AD%E5%88%86%E9%A1%B5%E7%AE%97%E6%B3%95%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">【*】42、虚拟内存中分页算法是为了解决什么样的问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="nav-text">43、虚拟内存的内存模型如何？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8C%BA%E5%88%86%E4%BB%A3%E7%A0%81%E6%AE%B5%E5%92%8C%E6%95%B0%E6%8D%AE%E6%AE%B5%EF%BC%9F"><span class="nav-text">44、为什么要区分代码段和数据段？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#45%E3%80%81%E5%A0%86%E5%92%8C%E6%A0%88%E6%9C%89%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">45、堆和栈有什么样的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E6%A0%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%A0%86%EF%BC%9F"><span class="nav-text">46、什么时候用栈，什么时候用堆？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47%E3%80%81%E4%B8%8D%E5%90%8C%E6%AE%B5%E4%B8%8A%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-text">47、不同段上的对象的生命周期是怎样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%A9%E5%AF%B9%E8%B1%A1%E5%8F%AA%E8%83%BD%E5%AD%98%E5%9C%A8%E4%BA%8E%E6%A0%88-%E5%A0%86%E4%B8%AD%EF%BC%9F"><span class="nav-text">48、如何让对象只能存在于栈&#x2F;堆中？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#49%E3%80%81%E6%A0%88%E7%9A%84%E9%80%9F%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94%E5%A0%86%E4%B8%8A%E7%9A%84%E8%A6%81%E5%BF%AB%EF%BC%9F"><span class="nav-text">49、栈的速度为什么比堆上的要快？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#50%E3%80%81%E6%A0%88%E4%BD%95%E6%97%B6%E4%BC%9A%E6%BA%A2%E5%87%BA%EF%BC%9F"><span class="nav-text">50、栈何时会溢出？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#51%E3%80%81new-%E5%92%8C-malloc-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">51、new 和 malloc 的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#52%E3%80%81%E6%97%A2%E7%84%B6%E6%9C%89%E4%BA%86-malloc-free%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81-new-delete-%E5%91%A2%EF%BC%9F"><span class="nav-text">52、既然有了 malloc&#x2F;free，为什么还需要 new&#x2F;delete 呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53%E3%80%81malloc-%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">53、malloc() 函数的底层实现是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#54%E3%80%81mmap-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-text">54、mmap() 的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55%E3%80%81%E5%81%87%E8%AE%BE%E5%88%86%E9%85%8D%E4%B8%80%E5%9D%97%E5%86%85%E5%AD%98-int-p-int-malloc-100-%E9%82%A3%E4%B9%88-free-p-50-%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9B%E5%A6%82%E6%9E%9C%E6%83%B3%E6%8A%8A%E8%BF%99%E5%9D%97%E5%86%85%E5%AD%98%E6%89%A9%E5%85%85%E5%88%B0200%E5%AD%97%E8%8A%82%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="nav-text">55、假设分配一块内存 int* p &#x3D; (int*)malloc(100); 那么 free(p+50) 可不可以，为什么；如果想把这块内存扩充到200字节，应该怎么做？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56%E3%80%81malloc%E3%80%81realloc%E3%80%81calloc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">56、malloc、realloc、calloc的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#57%E3%80%81%E5%AF%B9%E4%BA%8E-malloc-%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%8C%E8%B0%83%E7%94%A8-free-%E5%90%8E%E7%AB%8B%E5%8D%B3%E9%87%8A%E6%94%BE%E5%90%97%EF%BC%9F"><span class="nav-text">57、对于 malloc() 分配的内存，调用 free() 后立即释放吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#58%E3%80%81%E6%97%A2%E7%84%B6%E5%A0%86%E5%86%85%E7%A2%8E%E7%89%87%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E9%87%8A%E6%94%BE%EF%BC%8C%E5%AF%BC%E8%87%B4%E7%96%91%E4%BC%BC%E2%80%9C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E2%80%9D%E9%97%AE%E9%A2%98%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88-malloc-%E4%B8%8D%E5%85%A8%E9%83%A8%E4%BD%BF%E7%94%A8-mmap-%E6%9D%A5%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%80%8C%E6%98%AF%E4%BB%85%E4%BB%85%E5%AF%B9%E4%BA%8E%E5%A4%A7%E4%BA%8E-128k-%E7%9A%84%E5%A4%A7%E5%9D%97%E5%86%85%E5%AD%98%E6%89%8D%E4%BD%BF%E7%94%A8-mmap-%EF%BC%9F"><span class="nav-text">58、既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么 malloc() 不全部使用 mmap() 来实现，而是仅仅对于大于 128k 的大块内存才使用 mmap()？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#59%E3%80%81kmalloc-%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84-malloc-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-text">59、kmalloc() 和用户态的 malloc() 有什么区别。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#60%E3%80%81%E5%9C%A8%E5%B7%B2%E7%94%B3%E8%AF%B7%E7%9A%84%E5%86%85%E5%AD%98%E4%B8%AD%E6%9E%84%E9%80%A0%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-text">60、在已申请的内存中构造对象如何实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#61%E3%80%81new-%E3%80%81operator-new-%E5%92%8C-placement-new-%E5%8C%BA%E5%88%AB"><span class="nav-text">61、new 、operator new 和 placement new 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62%E3%80%81%E5%AF%B9%E4%BA%8E-delete-parray%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93-parray-%E8%BF%99%E4%B8%AA%E6%8C%87%E9%92%88%E5%AE%9E%E9%99%85%E6%8C%87%E5%90%91%E7%9A%84%E6%98%AF%E6%95%B0%E7%BB%84%E8%BF%98%E6%98%AF%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="nav-text">62、对于 delete[] parray，编译器怎么知道 parray 这个指针实际指向的是数组还是单个元素？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63%E3%80%81%E6%AF%94%E5%A6%82%E6%9C%89%E4%B8%80%E4%B8%AA-1G-%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%A2%91%E7%B9%81%E8%B0%83%E7%94%A8-new-malloc-%E4%BB%A5%E5%8F%8A-delete-free%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="nav-text">63、比如有一个 1G 的数据，频繁调用 new&#x2F;malloc 以及 delete&#x2F;free，如何优化性能？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64%E3%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-text">64、内存分配的过程是怎样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#65%E3%80%81%E5%86%85%E5%AD%98%E7%B4%A7%E5%BC%A0-%E6%B2%A1%E6%9C%89%E7%A9%BA%E9%97%B2%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E6%97%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-text">65、内存紧张&#x2F;没有空闲物理内存时有哪些操作？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#66%E3%80%81%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="nav-text">66、哪些内存可以被回收？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#67%E3%80%81%E9%92%88%E5%AF%B9%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98%E9%A1%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">67、针对回收内存页导致的性能影响，有哪些解决方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#68%E3%80%81%E5%9C%A8-4GB-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%EF%BC%8C%E7%94%B3%E8%AF%B7-8GB-%E5%86%85%E5%AD%98%EF%BC%8C%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="nav-text">68、在 4GB 物理内存的机器上，申请 8GB 内存，会怎么样？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#69%E3%80%81%E5%87%BD%E6%95%B0%E8%BF%9B%E6%A0%88%E9%80%80%E6%A0%88%E5%8E%9F%E7%90%86%EF%BC%8Cesp%E3%80%81ebp%E3%80%81%E5%AE%9E%E5%8F%82%E6%80%8E%E4%B9%88%E4%BC%A0%E9%80%92%EF%BC%9F%E6%80%8E%E4%B9%88%E9%80%80%E6%A0%88%E4%B9%8B%E7%B1%BB%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-text">69、函数进栈退栈原理，esp、ebp、实参怎么传递？怎么退栈之类的过程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#70%E3%80%81%E5%88%86%E6%AE%B5%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BA%A7%E7%94%9F%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">70、分段为什么会产生内存碎片的问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#71%E3%80%81%E5%88%86%E6%AE%B5%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E6%95%88%E7%8E%87%E4%BD%8E%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">71、分段为什么会导致内存交换效率低的问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#72%E3%80%81Swap-%E5%88%86%E5%8C%BA"><span class="nav-text">72、Swap 分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#73%E3%80%81%E5%88%86%E9%A1%B5%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%88%86%E6%AE%B5%E7%9A%84%E3%80%8C%E5%A4%96%E9%83%A8%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E5%92%8C%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E6%95%88%E7%8E%87%E4%BD%8E%E3%80%8D%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">73、分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#74%E3%80%81%E9%A1%B5%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E9%A1%B5%E5%A4%9A%E5%A4%A7%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-4KB%EF%BC%9F"><span class="nav-text">74、页表是什么，页多大，为什么是 4KB？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#75%E3%80%81%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E4%B8%8B%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%98%AF%E5%A6%82%E4%BD%95%E6%98%A0%E5%B0%84%E7%9A%84%EF%BC%9F"><span class="nav-text">75、分页机制下，虚拟地址和物理地址是如何映射的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#76%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BA%A7%E7%94%9F%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%EF%BC%9F"><span class="nav-text">76、为什么会产生多级页表？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#77%E3%80%81%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9F%EF%BC%9F"><span class="nav-text">77、缺页中断什么时候发生？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#78%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E7%AE%97%E6%B3%95-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">78、常见的缺页中断算法&#x2F;页面置换算法有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#79%E3%80%81%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="nav-text">79、写时拷贝在操作系统中有哪些应用？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F%E7%9B%B8%E5%85%B3"><span class="nav-text">三、编译程序相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#80%E3%80%81%E4%BB%8E-C-%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%BB%8F%E8%BF%87%E4%BA%86%E5%93%AA%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%9F%E5%85%B7%E4%BD%93%E6%8F%8F%E8%BF%B0%E3%80%82"><span class="nav-text">80、从 C++ 文件到可执行文件经过了哪几个阶段？具体描述。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#81%E3%80%81%E5%9C%A8-terminal-%E8%BE%93%E5%85%A5-main-out-%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E7%9A%84%EF%BC%9F"><span class="nav-text">81、在 terminal 输入 .&#x2F;main.out 是怎么运行起来的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#82%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%9C%89%E9%93%BE%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-text">82、为什么需要有链接的过程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#83%E3%80%81%E5%81%87%E8%AE%BE%E6%9C%89%E4%B8%80%E4%B8%AA-A-dll-%E5%92%8C-B-dll%EF%BC%8CA-dll-%E8%B0%83%E7%94%A8%E4%BA%86-B-dll-%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8CA-dll-%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0-B-dll-%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%EF%BC%9F"><span class="nav-text">83、假设有一个 A.dll 和 B.dll，A.dll 调用了 B.dll 的方法，A.dll 是如何找到 B.dll 中的方法的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#84%E3%80%81%E5%81%87%E8%AE%BE%E6%9C%89%E4%B8%80%E4%B8%AA-A-cpp-%E5%92%8C-B-cpp%EF%BC%8CA-cpp-%E8%B0%83%E7%94%A8%E4%BA%86-B-cpp-%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8CA-cpp-%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0-B-cpp-%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%EF%BC%9F"><span class="nav-text">84、假设有一个 A.cpp 和 B.cpp，A.cpp 调用了 B.cpp 的方法，A.cpp 是如何找到 B.cpp 中的方法的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#85%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B8%AD%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-text">85、函数调用中堆和栈的变化情况是怎样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#86%E3%80%81%E4%BB%A3%E7%A0%81%E5%B4%A9%E6%BA%83%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%8C%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">86、代码崩溃怎么解决，常见的原因是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#87%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AE%B5%E9%94%99%E8%AF%AF%EF%BC%9F"><span class="nav-text">87、什么时候会发生段错误？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#88%E3%80%81%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E4%BA%A7%E7%94%9F-core-dump%E4%B8%80%E8%88%AC%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-text">88、程序崩溃产生 core dump一般怎么处理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#89%E3%80%81%E5%BD%93%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E5%B0%86%E5%85%B6%E5%8A%A0%E8%BD%BD%E5%88%B0%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%EF%BC%9F"><span class="nav-text">89、当程序运行时，如何将其加载到进程地址空间？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#90%E3%80%81-%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%97%B6%EF%BC%8COS-%E5%8F%91%E7%94%9F%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E8%B6%8A%E8%AF%A6%E7%BB%86%E8%B6%8A%E5%A5%BD"><span class="nav-text">90、**执行一个系统调用时，OS **发生的过程，越详细越好</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#91%E3%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">91、动态链接和静态链接的区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Linux%E7%9B%B8%E5%85%B3"><span class="nav-text">四、Linux相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#92%E3%80%81Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">92、Linux 常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#93%E3%80%810%E3%80%811%E3%80%812-%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89%EF%BC%9F%E6%8C%87%E5%90%91%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="nav-text">93、0、1、2 的文件描述符是什么含义？指向什么类型的文件？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#94%E3%80%81Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E4%B8%BA%E4%B8%8A%E4%B8%8B%E4%B8%A4%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F"><span class="nav-text">94、Linux 系统中的中断为什么分为上下两个部分？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#95%E3%80%81Linux-%E7%94%A8%E6%88%B7%E6%80%81%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9F"><span class="nav-text">95、Linux 用户态如何进入内核态？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#96%E3%80%81%E5%A6%82%E4%BD%95%E7%94%A8-gbd-%E8%B0%83%E8%AF%95%E5%8F%91%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="nav-text">96、如何用 gbd 调试发现线程阻塞？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#97%E3%80%81gdb-%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%A0%88%E7%9A%84%E5%91%BD%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">97、gdb 查看所有线程线程栈的命令是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#98%E3%80%81gdb-%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E5%91%BD%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">98、gdb 查看内存地址的命令是什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="nav-text">处理器相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#99%E3%80%81%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="nav-text">99、浮点数在计算机中怎么存储？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#100%E3%80%81%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="nav-text">100、怎么判断两个浮点数是否相等？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#101%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7%E5%B0%8F%E7%AB%AF%EF%BC%9F%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%EF%BC%9F%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%80%E8%88%AC%E6%98%AF%E4%BB%80%E4%B9%88%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%9F"><span class="nav-text">101、什么是大小端？如何区分？有几种方法？网络通信一般是什么字节序？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#102%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-qps-%E5%92%8C-tps-%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%EF%BC%9F"><span class="nav-text">102、什么是 qps 和 tps ，如何计算？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#103%E3%80%81CPU-%E5%88%A9%E7%94%A8%E7%8E%87%E6%8B%89%E6%BB%A1%E7%9A%84%E6%97%B6%E5%80%99%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E5%A2%9E%E5%8A%A0%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E8%83%BD%E6%8F%90%E9%AB%98-qps%EF%BC%9F"><span class="nav-text">103、CPU 利用率拉满的时候在线程池中增加线程是否能提高 qps？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-CPU-%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E5%92%8C-I-O-%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="nav-text">104、什么是 CPU 密集型应用和 I&#x2F;O 密集型应用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#105%E3%80%81I-O-%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E6%8A%8A-I-O-%E5%92%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%88%86%E7%A6%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-text">105、I&#x2F;O 密集型任务把 I&#x2F;O 和业务逻辑分离有什么好处？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#106%E3%80%81CPU-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">106、CPU 流水线技术是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#107%E3%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF%E4%B8%AD%E7%9A%84%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="nav-text">107、流水线技术中的分支预测的实现和意义？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#108%E3%80%81%E5%86%85%E6%A0%B8%E5%92%8C%E5%BA%94%E7%94%A8%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">108、内核和应用进行数据交互的方法有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#109%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%BB%8E%E7%94%A8%E6%88%B7%E5%88%B0%E5%86%85%E6%A0%B8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">109、系统调用从用户到内核的底层实现是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#110%E3%80%81%E5%86%85%E6%A0%B8%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">110、内核的调度方式是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#111%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-text">111、为什么要设计用户态和内核态两种状态？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#112%E3%80%81%E5%8D%95%E7%89%87%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%9C%A8%E6%89%A7%E8%A1%8C-main-%E4%B9%8B%E5%89%8D%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">112、单片机启动程序，在执行 main 之前的是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#113%E3%80%81%E6%80%8E%E4%B9%88%E5%9C%A8-main-%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F"><span class="nav-text">113、怎么在 main 函数执行之前打印字符串？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#114%E3%80%81cpu-%E6%80%8E%E4%B9%88%E4%BB%8E%E5%86%85%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%EF%BC%8C%E8%A6%81%E7%BB%8F%E8%BF%87%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%9D%97%EF%BC%88%E6%AF%94%E5%A6%82%E6%89%A7%E8%A1%8C-load-%E6%8C%87%E4%BB%A4%E6%97%B6%EF%BC%89%EF%BC%9F"><span class="nav-text">114、cpu 怎么从内存中获取数据的，要经过哪些模块（比如执行 load 指令时）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#115%E3%80%81arm-%E5%92%8C-x86-%E6%AF%94%E8%BE%83%E6%98%8E%E6%98%BE%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">115、arm 和 x86 比较明显的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#116%E3%80%81%E5%A6%82%E6%9E%9C%E5%8F%91%E7%8E%B0%E7%B3%BB%E7%BB%9F%E5%8F%98%E6%85%A2%EF%BC%8Clinux-%E4%BC%9A%E6%80%8E%E4%B9%88%E8%80%83%E8%99%91%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">116、如果发现系统变慢，linux 会怎么考虑怎么排查这个问题？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81Linux-%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3"><span class="nav-text">六、Linux 命令相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#117%E3%80%81%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%97%A0%E6%B3%95%E8%A2%AB-kill%EF%BC%9F"><span class="nav-text">117、哪些状态的进程无法被 kill？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#118%E3%80%81kill-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B%E7%9A%84%EF%BC%9F"><span class="nav-text">118、kill 是怎么实现终止进程的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#119%E3%80%81%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86"><span class="nav-text">119、常见命令合集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%9F%A5%E7%9C%8B%E5%93%AA%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%9C%80%E5%A4%A7%EF%BC%9F"><span class="nav-text">（1）查看哪个进程的内存占用最大？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E6%89%93%E5%BC%80%E4%BA%86%E4%BB%80%E4%B9%88%E7%AB%AF%E5%8F%A3%EF%BC%9F"><span class="nav-text">（2）查看进程打开了什么端口？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%EF%BC%9F"><span class="nav-text">（3）查看进程是否存活？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B-id-%EF%BC%9F"><span class="nav-text">（4）查看进程 id ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-text">（5）查看进程状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%886%EF%BC%89lsof-%E6%8C%87%E4%BB%A4%E4%B8%BB%E8%A6%81%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="nav-text">（6）lsof 指令主要是干什么的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%887%EF%BC%89-%E5%A6%82%E4%BD%95%E8%AE%A9%E8%BF%9B%E7%A8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%EF%BC%9F"><span class="nav-text">（7） 如何让进程后台运行？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%888%EF%BC%89%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E6%89%93%E5%BC%80%E5%A4%9A%E5%B0%91%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%9F"><span class="nav-text">（8）查看一个进程可以打开多少文件描述符？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%889%EF%BC%89%E6%9F%A5%E7%9C%8B-CPU-%E6%A0%B8%E5%BF%83%E6%95%B0%EF%BC%9F"><span class="nav-text">（9）查看 CPU 核心数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8810%EF%BC%89%E5%A6%82%E4%BD%95%E6%8C%89%E7%85%A7%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E5%AF%B9%E8%BF%9B%E7%A8%8B%E6%8E%92%E5%BA%8F%E6%9F%A5%E7%9C%8B%EF%BC%9F"><span class="nav-text">（10）如何按照内存使用情况对进程排序查看？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8811%EF%BC%89%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-text">（11）查看磁盘状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8812%EF%BC%89%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9A%84%E5%89%8D%E4%B8%80%E7%99%BE%E8%A1%8C%EF%BC%9F"><span class="nav-text">（12）查看日志文件的前一百行？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8813%EF%BC%89-ps-aux-%EF%BC%8C-aux-%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="nav-text">（13） ps -aux ， aux 是干什么的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8814%EF%BC%89%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">（14）本地和远程服务器之间传输文件的是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8815%EF%BC%89%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E5%90%8D%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-text">（15）查找文件名包含某个关键字的文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#120%E3%80%81Linux-%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%EF%BC%9F"><span class="nav-text">120、Linux 包含哪些部分？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#121%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%EF%BC%9F"><span class="nav-text">121、操作系统包含哪些部分？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">七、文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#122%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="nav-text">122、文件系统的基本组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#123%E3%80%81%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">123、虚拟文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#124%E3%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-text">124、文件的存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#125%E3%80%81%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-text">125、空闲空间管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#126%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">126、文件系统的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#127%E3%80%81%E7%9B%AE%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-text">127、目录的存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#128%E3%80%81%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="nav-text">128、软链接和硬链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#129%E3%80%81%E6%96%87%E4%BB%B6I-O"><span class="nav-text">129、文件I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#130%E3%80%81%E8%BF%9B%E7%A8%8B%E5%86%99%E6%96%87%E4%BB%B6%E6%97%B6%EF%BC%8C%E8%BF%9B%E7%A8%8B%E5%8F%91%E7%94%9F%E4%BA%86%E5%B4%A9%E6%BA%83%EF%BC%8C%E5%B7%B2%E5%86%99%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%A2%E5%A4%B1%E5%90%97%EF%BC%9F"><span class="nav-text">130、进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="nav-text">八、设备管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#131%E3%80%81%E9%94%AE%E7%9B%98%E6%95%B2%E5%85%A5-A-%E5%AD%97%E6%AF%8D%E6%97%B6%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">131、键盘敲入 A 字母时，操作系统期间发生了什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">九、网络系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#132%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="nav-text">132、什么是零拷贝？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#133%E3%80%81I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9Aselect-poll-epoll"><span class="nav-text">133、I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#134%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%EF%BC%9AReactor-%E5%92%8C-Proactor"><span class="nav-text">134、高性能网络模式：Reactor 和 Proactor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#135%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%EF%BC%9F"><span class="nav-text">135、什么是一致性哈希？</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="midorii"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">midorii</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">midorii</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">285k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:15</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
