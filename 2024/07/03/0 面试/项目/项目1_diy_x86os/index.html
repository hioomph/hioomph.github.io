<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch_cat_logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/site_cat-32%C3%9732.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/site_cat-16%C3%9716.png">
  <link rel="mask-icon" href="/images/cat_logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、源码测试过程报错1、出现报错 1[build] x86_64-elf-objdump: Dwarf Error: found dwarf version &amp;#x27;7424&amp;#x27;, this reader only handles version 2, 3 and 4 information.  工具链相关错误，可忽略。 2、测试过程中的编译时遇到错误： 1DiskPart 遇到错">
<meta property="og:type" content="article">
<meta property="og:title" content="项目1_diyx86os">
<meta property="og:url" content="http://example.com/2024/07/03/0%20%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1_diy_x86os/index.html">
<meta property="og:site_name" content="MIDORII&#39;S JOURNEY">
<meta property="og:description" content="一、源码测试过程报错1、出现报错 1[build] x86_64-elf-objdump: Dwarf Error: found dwarf version &amp;#x27;7424&amp;#x27;, this reader only handles version 2, 3 and 4 information.  工具链相关错误，可忽略。 2、测试过程中的编译时遇到错误： 1DiskPart 遇到错">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081530696.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081641135.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081654966.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081957449.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081959718.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082011134.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082008662.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082009410.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082034893.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082059875.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082102910.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082107803.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082110449.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082112921.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090906770.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090908623.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090926726.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090931367.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091016385.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091022007.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091941355.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092034455.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092042975.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092111828.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092111423.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405100950973.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405100954581.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101016115.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101452241.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101453798.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101455214.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101500881.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101510647.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101622446.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101952279.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101954937.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102027415.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102027751.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102049124.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102050925.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102052194.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102054365.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102057812.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102108837.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102108978.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102114815.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102116737.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102111597.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102138372.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112014421.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112021480.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112105777.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112030942.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112120766.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112119587.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112121617.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121404633.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121404406.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121405202.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121550258.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121551856.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121555355.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121558156.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121603986.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121603112.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121656373.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121657737.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121701389.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122031495.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122032412.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122035869.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122035976.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122039950.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122044231.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122109920.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122109701.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122113907.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122124096.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122152287.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122149517.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122150962.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122152287.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122236298.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131022114.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131026877.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131032907.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131033545.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131034526.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131036123.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131039358.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131104164.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131104668.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131105155.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131125038.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131125775.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131532647.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131707991.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131857119.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131859253.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131901488.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131902640.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131920596.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131933225.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131920596.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405132011988.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405140922412.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405141437793.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405141441877.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142022102.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142023040.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142039947.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142038829.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142050761.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142057431.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142115267.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142117502.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142118228.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405150949978.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405150958664.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151000598.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151054801.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151058922.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151454378.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151550561.png">
<meta property="og:image" content="c:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240515155549617.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151634229.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151730245.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151731170.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151731210.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152028459.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152033989.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152102022.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152123227.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161022580.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161024659.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161046155.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161536876.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161540957.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161541337.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161544397.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161548492.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161550138.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161610637.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161656774.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161945180.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162010349.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162022801.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162035492.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162047328.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162048307.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162101361.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162110080.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162120111.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162121845.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162128904.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162134988.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405170816844.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405170959500.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171004646.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171006887.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171007176.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171009559.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171011883.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171101073.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171448019.png">
<meta property="og:image" content="c:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240517145000377.png">
<meta property="og:image" content="c:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240517144742533.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171451064.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171451285.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171455366.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171531929.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171535529.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171534282.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171532892.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171545775.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171548139.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171630549.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171650837.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171655736.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171703932.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171736358.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171717275.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171718785.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171722017.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171741544.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171805215.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171807804.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171807062.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171650837.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182044761.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182052909.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182058011.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182102316.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182107831.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182124084.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182125920.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182149317.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182200116.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182202640.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182208681.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191451190.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191451670.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191512628.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191559496.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191556008.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191611562.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191611577.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191615645.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191616105.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191621670.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191631851.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191648559.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191651929.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171455366.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191655562.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191657728.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191729446.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191729964.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191730041.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191731972.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191731182.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191916522.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191919839.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191920132.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191920272.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191931168.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191934137.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191936035.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191938454.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191940126.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191940436.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191955719.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192010866.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192018702.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192048487.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192103797.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192104590.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192114720.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192115446.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192125386.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192128843.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192135719.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192142734.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192208389.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192210217.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192210492.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192213396.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201002440.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201004667.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201005983.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201008417.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201008739.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201010501.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201032921.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201046034.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201109576.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201059277.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201100500.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201210574.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201216326.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201221626.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201224360.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201251661.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201607868.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201512535.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201511396.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201647344.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201647127.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201950719.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202030623.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202057353.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202146108.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202148647.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211017716.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211019558.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211223596.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211449653.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211451843.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211557399.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211620385.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211649751.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211641068.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211941992.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221254675.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405220934175.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405220952365.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405220958926.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221000006.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221007171.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221022455.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221023403.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221057186.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221059676.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221251345.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221944469.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230918110.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230920616.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230925271.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230926563.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231017216.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231024410.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231031828.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231527961.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231600337.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231601872.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231618145.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231934732.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231936141.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231936997.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231949301.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231950402.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232005483.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232032635.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232037597.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232051032.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232118966.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232120477.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232122435.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232144307.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405240932371.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405240932986.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405240933690.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405241450969.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242032828.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242035079.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242040884.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242158605.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242232682.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405251645958.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252002902.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252000979.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252046871.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252013293.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252018279.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252020223.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405261156858.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252025262.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252050216.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262044874.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262111920.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262205497.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262212616.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262245138.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270914097.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270914740.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270936751.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270948328.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271025353.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271027930.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271028998.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271034500.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271036205.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271038250.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271051879.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271559579.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271559465.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271834662.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271856539.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271857558.png">
<meta property="article:published_time" content="2024-07-03T03:16:42.307Z">
<meta property="article:modified_time" content="2024-07-04T08:09:38.369Z">
<meta property="article:author" content="midorii">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081530696.png">

<link rel="canonical" href="http://example.com/2024/07/03/0%20%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1_diy_x86os/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>项目1_diyx86os | MIDORII'S JOURNEY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MIDORII'S JOURNEY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">a little bit sweet</p>
      <a>
        <img class="custom-logo-image" src="/images/cat.jpeg" alt="MIDORII'S JOURNEY">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/03/0%20%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1_diy_x86os/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          项目1_diyx86os
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-03 11:16:42" itemprop="dateCreated datePublished" datetime="2024-07-03T11:16:42+08:00">2024-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-04 16:09:38" itemprop="dateModified" datetime="2024-07-04T16:09:38+08:00">2024-07-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>56k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3:24</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <span id="more"></span>

<h1 id="一、源码测试过程报错"><a href="#一、源码测试过程报错" class="headerlink" title="一、源码测试过程报错"></a>一、源码测试过程报错</h1><p>1、出现报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[build] x86_64-elf-objdump: Dwarf Error: found dwarf version <span class="string">&#x27;7424&#x27;</span>, this reader only handles version 2, 3 and 4 information.</span><br></pre></td></tr></table></figure>

<p>工具链相关错误，可忽略。</p>
<p>2、测试过程中的编译时遇到错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DiskPart 遇到错误: 由于虚拟磁盘系统限制，无法完成请求的操作。虚拟硬盘文件必须是未压缩和未加密的文件，并且不能是稀疏文件。</span><br></pre></td></tr></table></figure>

<p>解决：取消勾选“压缩或加密属性”</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081530696.png" alt="image-20240508153049493" style="zoom: 67%;" />

<p>3、dd命令不存在：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;dd if=kernel.elf of=disk1.vhd bs=512 conv=notrunc seek=100 &#x27;dd&#x27; 不是内部或外部命令，也不是可运行的程序 或批处理文件。</span><br></pre></td></tr></table></figure>

<p>在Git的安装路径下找到dd.exe文件，并将对应的bin目录添加到系统变量中：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081641135.png" alt="image-20240508164113684"></p>
<p>4、调试成功时，终端显示如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> not exist <span class="string">&quot;disk1.vhd&quot;</span> (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;disk1.vhd not found in image directory&quot;</span></span><br><span class="line"> notepad win_error.txt</span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> not exist <span class="string">&quot;disk2.vhd&quot;</span> (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;disk2.vhd not found in image directory&quot;</span></span><br><span class="line"> notepad win_error.txt</span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">set</span> DISK1_NAME=disk1.vhd</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">dd</span> <span class="keyword">if</span>=boot.bin of=disk1.vhd bs=512 conv=notrunc count=1 </span><br><span class="line">1+0 records <span class="keyword">in</span></span><br><span class="line">1+0 records out</span><br><span class="line">512 bytes copied, 0.009362 s, 54.7 kB/s</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">dd</span> <span class="keyword">if</span>=loader.bin of=disk1.vhd bs=512 conv=notrunc seek=1 </span><br><span class="line">24+0 records <span class="keyword">in</span></span><br><span class="line">24+0 records out</span><br><span class="line">12288 bytes (12 kB, 12 KiB) copied, 0.0077902 s, 1.6 MB/s</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">dd</span> <span class="keyword">if</span>=kernel.elf of=disk1.vhd bs=512 conv=notrunc seek=100 </span><br><span class="line">98+1 records <span class="keyword">in</span></span><br><span class="line">98+1 records out</span><br><span class="line">50452 bytes (50 kB, 49 KiB) copied, 0.0353497 s, 1.4 MB/s</span><br><span class="line">83+1 records <span class="keyword">in</span></span><br><span class="line">83+1 records out</span><br><span class="line">42968 bytes (43 kB, 42 KiB) copied, 0.0838259 s, 513 kB/s</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">set</span> DISK2_NAME=disk2.vhd</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">set</span> TARGET_PATH=k</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> <span class="keyword">select</span> vdisk file=<span class="string">&quot;D:\PostGraduate\cppex\diyx86os\image\disk2.vhd&quot;</span>  1&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> attach vdisk  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> <span class="keyword">select</span> partition 1  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> assign letter=k  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;diskpart /s a.txt</span><br><span class="line"></span><br><span class="line">Microsoft DiskPart 版本 10.0.19041.3636</span><br><span class="line"></span><br><span class="line">Copyright (C) Microsoft Corporation.</span><br><span class="line">在计算机上: DESKTOP-TVGU2EA</span><br><span class="line"></span><br><span class="line">DiskPart 已成功选择虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">  100 百分比已完成</span><br><span class="line"></span><br><span class="line">DiskPart 已成功连接虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">分区 1 现在是所选分区。</span><br><span class="line"></span><br><span class="line">DiskPart 成功地分配了驱动器号或装载点。</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> 0 NEQ 0 (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;attach disk2.vhd failed&quot;</span></span><br><span class="line"> notepad win_error.txt</span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;del a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;copy /Y *.elf k:\</span><br><span class="line">init.elf</span><br><span class="line">kernel.elf</span><br><span class="line">loop.elf</span><br><span class="line">shell.elf</span><br><span class="line">snake.elf</span><br><span class="line">已复制         5 个文件。</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> <span class="keyword">select</span> vdisk file=<span class="string">&quot;D:\PostGraduate\cppex\diyx86os\image\disk2.vhd&quot;</span>  1&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> detach vdisk  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;diskpart /s a.txt</span><br><span class="line"></span><br><span class="line">Microsoft DiskPart 版本 10.0.19041.3636</span><br><span class="line"></span><br><span class="line">Copyright (C) Microsoft Corporation.</span><br><span class="line">在计算机上: DESKTOP-TVGU2EA</span><br><span class="line"></span><br><span class="line">DiskPart 已成功选择虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">DiskPart 已成功分离虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> 0 NEQ 0 (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;detach disk2.vhd failed&quot;</span></span><br><span class="line"> notepad win_error.txt  </span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;del a.txt</span><br><span class="line"> *  终端将被任务重用，按任意键关闭。 </span><br><span class="line"></span><br><span class="line"> *  正在执行任务: D:\PostGraduate\cppex\diyx86os\start\<span class="built_in">test</span>/script/qemu-debug-win.bat </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;start qemu-system-i386  -m 128M -s -S -serial stdio -drive file=disk1.vhd,index=0,media=disk,format=raw -drive file=disk2.vhd,index=1,media=disk,format=raw -d pcall,page,mmu,cpu_reset,guest_errors,page,trace:ps2_keyboard_set_translation</span><br><span class="line"> *  终端将被任务重用，按任意键关闭。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二、引导程序：接管控制权"><a href="#二、引导程序：接管控制权" class="headerlink" title="二、引导程序：接管控制权"></a>二、引导程序：接管控制权</h1><h2 id="2-1-计算机启动流程简介"><a href="#2-1-计算机启动流程简介" class="headerlink" title="2.1 计算机启动流程简介"></a>2.1 计算机启动流程简介</h2><p>从上电到运行计算机经历了什么？</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081654966.png" alt="image-20240508165407603"></p>
<p><code>BIOS</code>：基本输入输出系统。固化在flash芯片上。</p>
<p><strong>BIOS程序由硬件自己控制，本项目编写自己的引导代码和操作系统代码。</strong></p>
<p><code>disk1</code>是<code>qemu</code>的启动硬盘，<code>qemu</code>启动时会从磁盘最开始取<code>512</code>字节。</p>
<p><code>BIOS</code>在加载引导代码时，会根据用户的配置选择从磁盘加载还是从软盘加载，整个课程处理从磁盘加载的情况。</p>
<h2 id="2-2-接管计算机运行控制权"><a href="#2-2-接管计算机运行控制权" class="headerlink" title="2.2 接管计算机运行控制权"></a>2.2 接管计算机运行控制权</h2><p>硬盘的分类：</p>
<ul>
<li><p>机械硬盘：包含电机。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081957449.png" alt="image-20240508195742085"></p>
</li>
<li><p>固态硬盘：容量小但速度快。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081959718.png" alt="image-20240508195937467"></p>
</li>
</ul>
<p>启动时，<code>BIOS</code>会将磁盘的第<code>0</code>个扇区加载到<code>0x7c00</code>处开始运行。即只需要将程序放在第<code>0</code>号扇区，就会自动被加载到内存中运行。完成从<code>BIOS</code>程序到引导程序的跳转过程。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082011134.png" alt="image-20240508201149042"></p>
<p>在<code>vscode</code>中以十六进制编辑器模式打开<code>disk1.vhd</code>，在<code>000001F0</code>处（即第<code>0</code>号扇区的最后两个字节）可看到<code>1FE:0x55</code>, <code>1FF:0xAA</code>，即为上图所示的两个引导标志所在位置。只有这两个引导标志正确时，<code>BIOS</code>才会将磁盘的第<code>0</code>个扇区加载到<code>0x7c00</code>处开始运行。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082008662.png" alt="image-20240508200825616"></p>
<p>此时，若将<code>55/AA</code>进行改动，并重新启动<code>qemu</code>，操作系统将无法被正常启动，会显示如下结果：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082009410.png" alt="image-20240508200958280" style="zoom:67%;" />

<p><strong>为简化，本项目不考虑引导过程中一个磁盘包含多个分区的情况。</strong></p>
<h2 id="2-3-创建可引导的启动程序"><a href="#2-3-创建可引导的启动程序" class="headerlink" title="2.3 创建可引导的启动程序"></a>2.3 创建可引导的启动程序</h2><h3 id="1-整体的项目逻辑"><a href="#1-整体的项目逻辑" class="headerlink" title="1. 整体的项目逻辑"></a>1. 整体的项目逻辑</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-.vscode</span><br><span class="line">	- launch.json	// GDB调试相关信息</span><br><span class="line">	- settings.json</span><br><span class="line">	- tasks.json	// 定义[终端-运行任务]中的相关任务</span><br><span class="line">	</span><br><span class="line">// 定义了[终端-运行任务]中相关任务的命令脚本</span><br><span class="line">- script	</span><br><span class="line"></span><br><span class="line">// 包含若干个子工程</span><br><span class="line">- <span class="built_in">source</span>			</span><br><span class="line">    - applib		// 系统调用库</span><br><span class="line">    - boot			// 引导程序</span><br><span class="line">    - <span class="built_in">comm</span></span><br><span class="line">    - init			// 初始进程</span><br><span class="line">    - kernel		// 操作系统内核</span><br><span class="line">    	- cpu			// 存放cpu相关</span><br><span class="line">    	- include		// 存放头文件</span><br><span class="line">    	- init			// 相关初始化</span><br><span class="line">    - loader		// 加载程序</span><br><span class="line">    - loop			// 应用程序</span><br><span class="line">    - shell			// 命令行应用</span><br><span class="line">    </span><br><span class="line">- CMakeLists.txt</span><br></pre></td></tr></table></figure>

<h3 id="2-整体的开发工作流程："><a href="#2-整体的开发工作流程：" class="headerlink" title="2. 整体的开发工作流程："></a>2. 整体的开发工作流程：</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082034893.png" alt="image-20240508203408507" style="zoom:150%;" />

<h2 id="2-4-初始化引导程序"><a href="#2-4-初始化引导程序" class="headerlink" title="2.4 初始化引导程序"></a>2.4 初始化引导程序</h2><p><strong>主要任务：对boot程序进行简单初始化。</strong></p>
<h3 id="1-什么是引导程序？"><a href="#1-什么是引导程序？" class="headerlink" title="1. 什么是引导程序？"></a>1. 什么是引导程序？</h3><ul>
<li><p>主要用于为操作系统运行初始化运行环境，并加载操作系统运行。</p>
</li>
<li><p><strong>本项目中的引导程序涉及以下三个工作</strong>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082059875.png" alt="image-20240508205916747"></p>
</li>
</ul>
<p>由于BIOS只加载磁盘的第0扇区（512字节）到内存中，对于上述功能来说这个代码大小是不够的，因此需要考虑采用扩展程序的办法。</p>
<p>有以下两种方式，<strong>本项目采用方式二</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082102910.png" alt="image-20240508210246804"></p>
<h3 id="2-为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。"><a href="#2-为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。" class="headerlink" title="2. 为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。"></a>2. 为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。</h3><p>实模式包含以下特点：</p>
<ul>
<li>16位代码</li>
<li>无保护机制</li>
<li>无分页机制</li>
<li>仅使用1MB内存</li>
</ul>
<h3 id="3-x86与编程相关的主要内核寄存器"><a href="#3-x86与编程相关的主要内核寄存器" class="headerlink" title="3. x86与编程相关的主要内核寄存器"></a>3. x86与编程相关的主要内核寄存器</h3><p>   <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082107803.png" alt="image-20240508210729628"></p>
<ul>
<li><p>CS&#x2F;DS&#x2F;SS&#x2F;ES&#x2F;FS&#x2F;GS为段寄存器</p>
<ul>
<li><p>当访问特定内存地址时，需要采用<code>段:偏移</code>的形式，即实际地址为<code>段值&lt;&lt;4+偏移</code>。</p>
</li>
<li><p>例如：访问<code>0x7c00</code>，需要使用<code>0x7c0:0</code>，或<code>0:0x7c00</code></p>
</li>
<li><p>注意：初始化段寄存器时无需显示初始化<code>CS</code>。</p>
<blockquote>
<p>在 x86 架构中，CS（Code Segment）寄存器是用于存放代码段的选择子，在实模式下，CS 寄存器的初始化通常由处理器自动完成。</p>
<p>在启动阶段，处理器会将 CS 寄存器设置为默认值，通常为 0xFFFF，这意味着 CS 段选择子为 0xFFFF，代码段的起始地址是 0xFFFF0。这个默认的值使得处理器能够正常从 BIOS 的 ROM 中加载启动代码，并执行第一条指令。因此，在启动阶段，通常不需要显式地设置 CS 寄存器。</p>
<p>相反，通过设置 DS、SS、ES、FS、GS 等段寄存器为 0，可以将默认的段地址 0 应用于数据段、栈段和其他段。这样，CPU 将能够正确访问位于物理地址 0 处的引导程序代码，并且在实模式下，所有的段都共享同一个地址空间，因此 CS 寄存器的设置可以由 CPU 自动处理。</p>
</blockquote>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082110449.png" alt="image-20240508211028354"></p>
</li>
</ul>
<h3 id="4-实模式下的内存映射（8086）"><a href="#4-实模式下的内存映射（8086）" class="headerlink" title="4. 实模式下的内存映射（8086）"></a>4. 实模式下的内存映射（8086）</h3><ul>
<li><p>其中灰色为可用区域。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082112921.png" alt="image-20240508211243702" style="zoom:50%;" /></li>
</ul>
<h2 id="2-5-使用BIOS中断显示字符"><a href="#2-5-使用BIOS中断显示字符" class="headerlink" title="2.5 使用BIOS中断显示字符"></a>2.5 使用BIOS中断显示字符</h2><h3 id="1-如何显示字符？"><a href="#1-如何显示字符？" class="headerlink" title="1. 如何显示字符？"></a>1. 如何显示字符？</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090906770.png" alt="image-20240509090652672" style="zoom: 80%;" />

<p>BIOS提供了一组服务，可以方便地帮助我们操纵硬件，避免与硬件细节打交道。</p>
<ul>
<li>当调用<code>INT</code>软中断时，<code>CPU</code>会转到中断向量表处（<code>0x00000000~0x000003FF</code>），从中取出相应的地址位置，取出<code>BIOS</code>程序的入口地址，从而转到<code>BIOS</code>程序中运行。</li>
<li>参数通过寄存器传递。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090908623.png" alt="image-20240509090809536" />

<ul>
<li>本项目采用<code>INT 10, AH=0xE</code>显示字符<ul>
<li>该<code>BIOS</code>中断的作用是：显示字符，同时光标前移，其中（寄存器）<code>AL=字符</code>、<code>BL=前景色</code>、<code>BH=页码</code>。</li>
<li>具体来说<ul>
<li><code>BH</code>为目前的显示页。若在图形模式，<code>BH</code>需设置为0；</li>
<li>假如在图形模式下，也可设定<code>BL</code>来表示文字的颜色，文字模式下的<code>BL</code>则无此功能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2、BIOS-INT-10中断功能"><a href="#2、BIOS-INT-10中断功能" class="headerlink" title="2、BIOS INT 10中断功能"></a>2、BIOS INT 10中断功能</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_28256699/article/details/121103977">BIOS INT 10中断功能详解</a></p>
<h2 id="2-6-使用BIOS中断读取磁盘"><a href="#2-6-使用BIOS中断读取磁盘" class="headerlink" title="2.6 使用BIOS中断读取磁盘"></a>2.6 使用BIOS中断读取磁盘</h2><h3 id="1-怎样完成从Boot加载loader的过程？"><a href="#1-怎样完成从Boot加载loader的过程？" class="headerlink" title="1. 怎样完成从Boot加载loader的过程？"></a>1. 怎样完成从Boot加载loader的过程？</h3><p><code>BIOS</code>提供了磁盘读取的接口，便于从磁盘上读取<code>loader</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090926726.png" alt="image-20240509092600575"></p>
<p><strong>本项目的设计是在磁盘的第<code>0</code>号扇区（即<code>Boot</code>程序后）紧挨着放置<code>loader</code>程序。在加载时，考虑将其加载到<code>0x8000</code>处。</strong></p>
<ul>
<li>从磁盘上的第<code>1</code>号扇区开始，读取指定数量的扇区；</li>
<li>将其加载到内存中的指定地址处（<code>0x8000</code>）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090931367.png" alt="image-20240509093110267"></p>
<h3 id="2-INT-13磁盘读取"><a href="#2-INT-13磁盘读取" class="headerlink" title="2. INT 13磁盘读取"></a>2. INT 13磁盘读取</h3><p>（1）BIOS提供了磁盘操作的服务中断，其具体使用方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口参数								</span></span><br><span class="line">    AH = <span class="number">02</span>H							   						</span><br><span class="line">    AL = 扇区数								 </span><br><span class="line">    CH = 柱面									  </span><br><span class="line">    CL = 扇区								     </span><br><span class="line">    DH = 磁头								 </span><br><span class="line">    DL = 驱动器</span><br><span class="line">      - <span class="number">00</span>H~<span class="number">7F</span>H  ：软盘</span><br><span class="line">      - <span class="number">80</span>H~<span class="number">0F</span>FH ：硬盘</span><br><span class="line">    ES:BX = 缓冲区地址（即要加载到的内存中的地址）</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 出口参数</span></span><br><span class="line">- 若传输成功，	</span><br><span class="line">	CF = <span class="number">0</span></span><br><span class="line">	AH = <span class="number">00</span>H</span><br><span class="line">	AL = 传输的扇区数</span><br><span class="line">- 若传输失败，AH = 状态码</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cx=ch:cl</code>（<code>ch</code>占高<code>8</code>位，<code>cl</code>占低<code>8</code>位）。<ul>
<li>因此<code>mov $0x2, %cx</code>相当于直接一步到位，将<code>ch</code>设置为<code>0</code>，<code>cl</code>设置为<code>2</code>。</li>
<li>注意<code>cl</code>为<code>2</code>是因为：<strong>在本项目采用的读取方法下，BIOS认为磁盘的编号是从1开始的。</strong></li>
</ul>
</li>
<li><code>mov $64, %al</code><ul>
<li><code>al</code>为读取的扇区数量，必须小于<code>128</code>，暂设置成<code>32KB</code></li>
<li>因为一个扇区大小是<code>512B</code>，即<code>0.5KB</code>。因此若要暂设成<code>32KB</code>，即相当于<code>64</code>个扇区。</li>
</ul>
</li>
</ul>
<p>（2）运行完成后，将会把磁盘<code>1</code>中的相关内容加载到内存的<code>0x8000</code>处：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091016385.png" alt="image-20240509101626325"></p>
<h2 id="2-7-初始化引导程序"><a href="#2-7-初始化引导程序" class="headerlink" title="2.7 初始化引导程序"></a>2.7 初始化引导程序</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091022007.png" alt="image-20240509102201895"></p>
<h3 id="1、如何生成loader并写入磁盘映像？"><a href="#1、如何生成loader并写入磁盘映像？" class="headerlink" title="1、如何生成loader并写入磁盘映像？"></a>1、如何生成loader并写入磁盘映像？</h3><h3 id="2、怎样从boot跳转到loader执行？"><a href="#2、怎样从boot跳转到loader执行？" class="headerlink" title="2、怎样从boot跳转到loader执行？"></a>2、怎样从boot跳转到loader执行？</h3><h1 id="三、加载器loader的实现"><a href="#三、加载器loader的实现" class="headerlink" title="三、加载器loader的实现"></a>三、加载器loader的实现</h1><h2 id="3-1-利用内联汇编显示字符串"><a href="#3-1-利用内联汇编显示字符串" class="headerlink" title="3.1 利用内联汇编显示字符串"></a>3.1 利用内联汇编显示字符串</h2><p>用于显示loader加载过程，从而提示加载到哪一步时出现问题。</p>
<h3 id="1、内联汇编理论"><a href="#1、内联汇编理论" class="headerlink" title="1、内联汇编理论"></a>1、内联汇编理论</h3><ul>
<li><p><strong>概述</strong></p>
<p>在开发操作系统过程中，有时必须使用某些特殊的指令（如<code>int/outb/hlt</code>等），而<code>C</code>编译器无法自动使用这些指令。因此，如果要使用这些指令，有两种方式：</p>
<ul>
<li>在汇编文件中为该指令的使用<strong>创建汇编函数（子程序）</strong>，然后在C代码中以函数调用的方式去使用；</li>
<li>使用<strong>内联汇编</strong>，即在C代码中嵌入汇编程序。</li>
</ul>
<p>在大多数情况下，使用内联汇编会更加简单、易用。因此，以下将简要介绍本项目中所用的相关的GCC内联汇编的写法。</p>
</li>
<li><p><strong>基本格式</strong></p>
<p>基本格式如下，以<code>asm</code>关键字开头，包含<code>3</code>个可选的配置项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(汇编语句</span><br><span class="line"> :输出操作数(可选)</span><br><span class="line"> :输入操作数(可选)</span><br><span class="line"> :被破坏的寄存器列表(可选)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>下面举个例子，其功能为将<code>a</code>的值赋值给<code>b</code>，具体代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>, b;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;movl %1,%%eax; movl %%eax, %0;&quot;</span></span><br><span class="line">	:<span class="string">&quot;=r&quot;</span>(b)	<span class="comment">/* 输出 */</span></span><br><span class="line">	:<span class="string">&quot;r&quot;</span>(a)		<span class="comment">/* 输入 */</span></span><br><span class="line">	:<span class="string">&quot;%eax&quot;</span>		<span class="comment">/* 破坏寄存器 */</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其效果等价于<code>movl a, %%eax; movl %%eax, b</code>，即：将<code>a</code>的值先给<code>eax</code>寄存器，再将<code>eax</code>寄存器的值给到<code>b</code>，最终实现<code>b=a</code>的效果。</p>
</li>
<li><p><strong>具体格式说明</strong></p>
<ul>
<li><p>只有一条汇编语句</p>
<p>在内联汇编中，可以只有汇编语句，即没有输出、输入操作数，没有被破坏的寄存器列表。例如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;hlt&quot;</span>);  <span class="comment">// 让CPU暂停运行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有多条汇编语句</p>
<p>当有多条汇编语句时，需要写在同一字符串中，不同语句之间用<code>;</code>或者<code>\n\t</code>分隔。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;sti; hlt&quot;</span>);	<span class="comment">// 开启中断，然后让CPU暂停运行</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;sti\n\thlt&quot;</span>);	<span class="comment">// 开启中断，然后让CPU暂停运行</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;sti\n\t&quot;</span>		<span class="comment">// 同上。C语言中多个连续的字符串，会被认为是同一字符串</span></span><br><span class="line">    <span class="string">&quot;hlt&quot;</span>);			<span class="comment">// 开启中断，然后让CPU暂停运行</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>有输出操作数</strong></p>
<p>当汇编语句中有些数据需要存储到<code>C</code>语言中的某些变量中时，则可以使用输出操作数。例如，下面的代码是将<code>c</code>变量的值通过<code>mov $3, c</code>设置成<code>3</code>。其中<code>%[out]</code>为定义的一个输出约束，其名称应与<code>:</code>后的<code>out</code>相同，<code>&quot;=r&quot;(c)</code>指定了<code>c</code>变量映射到某个寄存器中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;mov $3, %[out]&quot;</span>:[out]<span class="string">&quot;=r&quot;</span>(c));</span><br></pre></td></tr></table></figure>

<p>通过上述方式，即实现了类似<code>mov $3,c</code>的效果。</p>
<p>其中<code>=r</code>还可以设置成其它，如下表所示</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">寄存器</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="center">任意寄存器</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">%eax,%ax,%al</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">%ebx,%bx,%bl</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">%ecx,%cx,%cl</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">%edx,%dx,%d</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">%esi,%si</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">%edi,%di</td>
</tr>
</tbody></table>
</li>
<li><p><strong>有输入操作数</strong></p>
<p>当需要从<code>C</code>语言中读取变量的值到汇编语句中时，则需要使用输入操作数。例如，下面的代码中，<code>mov%[ch], %%al</code>用于将<code>c</code>变量中的字符写到<code>al</code>中。因此，在输入操作数中使用了<code>[ch]&quot;r&quot;(c)</code>，即<code>c</code>变量映射到某个寄存器上（见上文中输出操作数的类似设置）。最终的效果为：<code>mov$0xe,%%ah、mov%[c],%%al</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line">    <span class="string">&quot;mov $0xe, %%ah\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;mov %[ch], %%al\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;int $Ox10&quot;</span>::[ch]<span class="string">&quot;r&quot;</span>(c)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免优化</p>
<p>在某些情况下，<code>GCC</code>编译器会对内联汇编中的汇编语句进行优化处理，最终导致生成语句和预期的不同，影响程序的执行结果。为了避免这些问题，可以强制要求<code>GCC</code>不对其进行优化，即原样的生成。要达到这点，可以使用<code>__asm__ __volatile_</code>替代原来的<code>asm</code>。</p>
</li>
<li><p>参考资料</p>
<p>GCC内联汇编介绍：<a target="_blank" rel="noopener" href="https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a><br>GCC内联汇编介绍：<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Inline_Assembly">https://wiki.osdev.org/Inline_Assembly</a><br>内联汇编示例：<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Inline_Assembly/Examples">https://wiki.osdev.org/Inline_Assembly/Examples</a></p>
</li>
</ul>
<h3 id="2、示例"><a href="#2、示例" class="headerlink" title="2、示例"></a>2、示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_msg</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> * msg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = *msg++) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 利用内联汇编显示字符串</span></span><br><span class="line">        <span class="keyword">asm</span>(</span><br><span class="line">            <span class="string">&quot;mov $0xe, %%ah\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;mov %[ch], %%al\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;int $0x10&quot;</span></span><br><span class="line">            ::[ch]<span class="string">&quot;r&quot;</span>(c)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loader_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    show_msg(<span class="string">&quot;....loading....\n\r&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091941355.png" alt="image-20240509194129987"></p>
<h2 id="3-2-检测内存容量"><a href="#3-2-检测内存容量" class="headerlink" title="3.2 检测内存容量"></a>3.2 检测内存容量</h2><p>对<code>loader</code>做一些功能扩展。</p>
<h3 id="1、内存检测方法理论"><a href="#1、内存检测方法理论" class="headerlink" title="1、内存检测方法理论"></a>1、内存检测方法理论</h3><p>内存检测方法：<code>INT 0x15, EAX = 0xE820</code></p>
<p>没有找到专门介绍内存检测方法的官方文档，只在<code>osdev</code>网站上（见下文参考资料）中找到相关的检测方法。具体来看，其中有简单也有复杂的方法，有的只在某些机器上可用。最推荐的一种方法如下（摘自osdev）：</p>
<blockquote>
<p><strong>第一次调用时，ES: DI存储保存读取的信息的存储位置：</strong><br>清除<code>EBX</code>，设置为<code>0</code><br><code>EDX</code>设置成	<code>0x534D4150</code><br><code>EAX</code>设置成	<code>0xE820</code><br><code>ECX</code>设置成	<code>24</code><br>执行		   	 <code>INT 0x15</code><br>返回结果      <code>EAX=0x534D4150</code>，<code>CF</code>标志清<code>0</code>，<code>EBX</code>被设置成某个数值用于下次调用，<code>CL</code>&#x3D;实际读取的字节数</p>
<p><strong>后续调用：</strong><br><code>EDX</code>设置成	<code>0x534D4150</code><br><code>EAX</code>重设为	<code>0xE820</code><br><code>ECX</code>重设为	<code>24</code><br>执行				  <code>INT 0x15</code><br>返回结果	   <code>EAX=0x534D4150</code>，<code>CF</code>标志清<code>0</code>。如果<code>EBX=0</code>，则表明读取完毕，否则当前条目有效。</p>
</blockquote>
<p>参考资料——内存检测方法：<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Detecting_Memory_(x86)">https://wiki.osdev.org/Detecting_Memory_(x86)</a></p>
<h3 id="2、示例-1"><a href="#2、示例-1" class="headerlink" title="2、示例"></a>2、示例</h3><p>首先需要自定义一个结构体来保存boot获取到的硬件信息，以便后期传递给操作系统使用。定义在comm中</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092034455.png" alt="image-20240509203459102"></p>
<p>当<code>for</code>循环执行完毕后，<code>boot_info</code>内部的信息如下，共分配两块内存区域：</p>
<ul>
<li>第1块，<code>0-640KB</code>左右，在<code>1MB</code>以内；</li>
<li>第2块，<code>1MB-128MB</code>左右。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092042975.png" alt="image-20240509204234901"></p>
<p>可以结合<code>qemu</code>的配置脚本来看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@REM 适用于windows</span><br><span class="line">start qemu-system-i386  -m 128M -s -S  -drive file=disk1.vhd,index=0,media=disk,format=raw -drive file=disk2.vhd,index=1,media=disk,format=raw -d pcall,page,mmu,cpu_reset,guest_errors,page,trace:ps2_keyboard_set_translation</span><br></pre></td></tr></table></figure>

<p><code>qemu</code>启动时内存大小分配即为<code>128M</code>，即<code>-m 128M</code>。</p>
<h2 id="3-3-切换至保护模式"><a href="#3-3-切换至保护模式" class="headerlink" title="3.3 切换至保护模式"></a>3.3 切换至保护模式</h2><h3 id="1、理论基础"><a href="#1、理论基础" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092111828.png" alt="image-20240509211140943"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092111423.png" alt="image-20240509211151568"></p>
<h3 id="2、编程细节"><a href="#2、编程细节" class="headerlink" title="2、编程细节"></a>2、编程细节</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdt.start31_16 = start &gt;&gt; <span class="number">16</span>;</span><br><span class="line">gdt.start15_0 = start &amp; <span class="number">0xffff</span>;</span><br></pre></td></tr></table></figure>

<p><strong>（1）关闭中断</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关中断</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">cli</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;cli&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 禁用中断</span></span><br><span class="line">cli();</span><br></pre></td></tr></table></figure>

<p><code>cli()</code>会影响<code>eflags</code>寄存器：</p>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405100950973.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405100954581.png" width="300"/>
</center>

<p><strong>（2）打开<code>A20</code>地址线</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinolover/article/details/93877845">一步步编写操作系统 26 打开A20地址线</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 打开A20地址线</span></span><br><span class="line"><span class="type">uint8_t</span> v = inb(<span class="number">0x92</span>);</span><br><span class="line">outb(<span class="number">0x92</span>, v | <span class="number">0x2</span>);  <span class="comment">// 0x00000010</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）加载<code>GDT</code>表</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> gdt_table[][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xffff</span>, <span class="number">0x0000</span>, <span class="number">0x9a00</span>, <span class="number">0x00cf</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xffff</span>, <span class="number">0x0000</span>, <span class="number">0x9200</span>, <span class="number">0x00cf</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 加载GDT表</span></span><br><span class="line">lgdt((<span class="type">uint32_t</span>)gdt_table, <span class="keyword">sizeof</span>(gdt_table));</span><br></pre></td></tr></table></figure>

<p>在<code>qemu</code>的<code>[view-&gt;compatmonitor()]</code>中输入<code>info registers</code>，可以看到<code>GDT</code>的信息变化：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101016115.png" alt="image-20240510101651071"></p>
<p><code>GDT</code>表写入后，<code>GDT=00009358 00000017</code>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101452241.png" alt="image-20240510145235174"></p>
<p>加载的<code>GDT</code>表项与所给出的表项一致：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101453798.png" alt="image-20240510145356743"></p>
<p><strong>（4）开启保护模式使能位</strong></p>
<p>开启保护位时，需设置<code>CR0</code>寄存器的<code>PE</code>位为<code>1</code>。由于<code>CR0</code>无法直接读写，必须先读取到某个中间寄存器，修改值后，再将值回写到<code>CR0</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 开启保护模式使能位</span></span><br><span class="line"><span class="type">uint32_t</span> cr0 = read_cr0();</span><br><span class="line">write_cr0(cr0 | (<span class="number">1</span> &lt;&lt; <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p><strong>（5）远跳转</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5. 远跳转，跳转到32位指令的入口处</span></span><br><span class="line">far_jump(<span class="number">8</span>, (<span class="type">uint32_t</span>)protect_mode_entry);  <span class="comment">// 这个8和保护模式的硬件细节，以及GDT表有关</span></span><br></pre></td></tr></table></figure>

<p>当跳转到<code>protect_mode_entry</code>后，可以看到段寄存器<code>CS</code>项变为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 00000000 0000ffff 00cf9a00 DPL=0 CS32</span><br></pre></td></tr></table></figure>

<p>即进入<code>32</code>位代码模式。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101455214.png" alt="image-20240510145523144"></p>
<p>将剩余的寄存器也修改到32位模式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protect_mode_entry:</span><br><span class="line">	mov $<span class="number">16</span>, %ax</span><br><span class="line">	mov %ax, %ds</span><br><span class="line">	mov %ax, %ss</span><br><span class="line">	mov %ax, %es</span><br><span class="line">	mov %ax, %fs</span><br><span class="line">	mov %ax, %gs</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101500881.png" alt="image-20240510150001767"></p>
<h2 id="3-4-使用LBA读取磁盘"><a href="#3-4-使用LBA读取磁盘" class="headerlink" title="3.4 使用LBA读取磁盘"></a>3.4 使用LBA读取磁盘</h2><p>参考资料：<a target="_blank" rel="noopener" href="https://wiki.osdev.org/ATA_PIO_Mode">硬盘访问模式及相关寄存器</a></p>
<p>虽然<code>BIOS</code>提供了磁盘读取的接口，方便从磁盘上读取<code>loader</code>，但在进入保护模式后，<code>BIOS</code>功能无法使用，<strong>读取磁盘需要使用到<code>LBA</code>模式</strong>。因此必须自己设计磁盘读取的代码。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101510647.png" alt="image-20240510151038444"></p>
<p>具体来讲，本项目采用<code>LBA48</code>模式。<code>LBA48</code>模式将硬盘上所有的扇区看成线性排列，没有磁盘、柱面等概念，因此访问起来更加简单，序号从<code>0</code>开始，其访问序列如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">outb(0x1F6,0x40|(slavebit&lt;&lt;4))  	// 选择硬盘:主盘或从盘</span><br><span class="line"></span><br><span class="line">outb(0x1F2,sectorcount high byte)	// 将扇区数量的高8位写入端口0x1F2</span><br><span class="line">// 分别将LBA(Logical Block Address)的第4、5、6个字节写入端口0x1F3、0x1F4、0x1F5</span><br><span class="line">outb(0x1F3,LBA4)							 </span><br><span class="line">outb(0x1F4,LBA5)</span><br><span class="line">outb(0x1F5,LBA6)</span><br><span class="line"></span><br><span class="line">outb (0x1F2,sectorcount low byte)	// 将扇区数量的低8位写入端口0x1F2</span><br><span class="line">// 分别将LBA(Logical Block Address)的第1、2、3个字节写入端口0x1F3、0x1F4、0x1F5</span><br><span class="line">outb(0x1F3,LBA1)</span><br><span class="line">outb(0x1F4,LBA2)</span><br><span class="line">outb(0x1F5,LBA3)</span><br><span class="line"></span><br><span class="line">Send the &quot;READ SECTORS EXT&quot; command (0x24) to port 0x1F7: </span><br><span class="line">outb(0x1F7,0x24)	// 告诉硬盘要读取扇区的数据</span><br></pre></td></tr></table></figure>

<p>各寄存器说明如下:</p>
<table>
<thead>
<tr>
<th>寄存器偏移</th>
<th>读写</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>R&#x2F;W</td>
<td>数据寄存器</td>
</tr>
<tr>
<td>1</td>
<td>R</td>
<td>错误寄存器</td>
</tr>
<tr>
<td>1</td>
<td>W</td>
<td>特性寄存器</td>
</tr>
<tr>
<td>2</td>
<td>R&#x2F;W</td>
<td>扇区数量寄存器</td>
</tr>
<tr>
<td>3</td>
<td>R&#x2F;W</td>
<td>Sector Number Register (LBAlo)</td>
</tr>
<tr>
<td>4</td>
<td>R&#x2F;W</td>
<td>Cylinder Low Register &#x2F;(LBAmid)</td>
</tr>
<tr>
<td>5</td>
<td>R&#x2F;W</td>
<td>Cylinder High Register &#x2F;(LBAhi)</td>
</tr>
<tr>
<td>6</td>
<td>R&#x2F;W</td>
<td>Drive &#x2F; Head Register</td>
</tr>
<tr>
<td>7</td>
<td>R</td>
<td>状态寄存器</td>
</tr>
<tr>
<td>7</td>
<td>W</td>
<td>命令寄存器</td>
</tr>
</tbody></table>
<ul>
<li>其中<code>0x1F6</code>寄存器（<code>Drive/Head</code>）对应的位如下：</li>
</ul>
<table>
<thead>
<tr>
<th>位</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0-3</td>
<td></td>
<td>在, bits 24 to 27 of the block number.</td>
</tr>
<tr>
<td>4</td>
<td>DRV</td>
<td>驱动器号（驱动器号：主盘和从盘。当只有一块硬盘时，默认第一块硬盘上放在主盘上。）</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>LBA</td>
<td>LBA模式下设置为1</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><code>Status Register(I/O base + 7)</code></li>
</ul>
<table>
<thead>
<tr>
<th>位</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>ERR</td>
<td>发生错误</td>
</tr>
<tr>
<td>1</td>
<td>IDX</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>CORR</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>DRQ</td>
<td>就绪，可以写数据或读取数据</td>
</tr>
<tr>
<td>4</td>
<td>SRV</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>DF</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>RDY</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>BSY</td>
<td>忙</td>
</tr>
</tbody></table>
<p>由于<code>loader</code>占用的大小较大，约几十<code>kb</code>的样子。由于不确定具体大小，因此尽量将内核往后放，放在第<code>100</code>个扇区的位置，并且将内核的大小为<code>500</code>，即<code>250kb</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static void read_disk (uint32_t sector, uint32_t sector_count, uint8_t *buf);</span></span><br><span class="line">read_disk(<span class="number">100</span>, <span class="number">500</span>, (<span class="type">uint8_t</span> *)SYS_KERNEL_LOAD_ADDR);</span><br></pre></td></tr></table></figure>

<h2 id="3-5-创建内核工程"><a href="#3-5-创建内核工程" class="headerlink" title="3.5 创建内核工程"></a>3.5 创建内核工程</h2><p>创建内核工程，并将工程写到磁盘上第<code>1MB</code>位置处，<code>loader</code>加载后将跳转过去。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101622446.png" alt="image-20240510162243231"></p>
<p>新建<code>kernel</code>文件夹，并在内部新建<code>CMakeLists.txt</code>如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">project(kernel LANGUAGES C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的链接器</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;-m elf_i386  -Ttext=0x100000&quot;</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_LINK_EXECUTABLE <span class="string">&quot;<span class="variable">$&#123;LINKER_TOOL&#125;</span> &lt;OBJECTS&gt; <span class="variable">$&#123;CMAKE_EXE_LINKER_FLAGS&#125;</span> -o <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有的汇编、C文件加入工程</span></span><br><span class="line"><span class="comment"># 注意保证start.asm在最前头，这样对应的程序会放在bin文件开头，从而在加载到0x8000时能在开头处</span></span><br><span class="line">file(GLOB_RECURSE C_LIST <span class="string">&quot;*.c&quot;</span> <span class="string">&quot;*.h&quot;</span>)</span><br><span class="line"><span class="comment"># 将GLOB改为GLOB_RECURSE，因为kernel目录下包含init等子目录，需要进行递归</span></span><br><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> init/start.S <span class="variable">$&#123;C_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bin文件生成，写入到image目录下</span></span><br><span class="line">add_custom_command(TARGET <span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">                   POST_BUILD</span><br><span class="line">                   COMMAND <span class="variable">$&#123;OBJCOPY_TOOL&#125;</span> -O binary <span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../../image/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.bin</span><br><span class="line">                   COMMAND <span class="variable">$&#123;OBJDUMP_TOOL&#125;</span> -x -d -S -m i386 <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf &gt; <span class="variable">$&#123;PROJECT_NAME&#125;</span>_dis.txt</span><br><span class="line">                   <span class="comment"># i8086改为i386，即从16位模式改为32位模式</span></span><br><span class="line">                   COMMAND <span class="variable">$&#123;READELF_TOOL&#125;</span> -a <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf &gt; <span class="variable">$&#123;PROJECT_NAME&#125;</span>_elf.txt</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="3-6-向内核传递启动信息"><a href="#3-6-向内核传递启动信息" class="headerlink" title="3.6 向内核传递启动信息"></a>3.6 向内核传递启动信息</h2><h3 id="1、如何实现从loader到kernel的信息传输？"><a href="#1、如何实现从loader到kernel的信息传输？" class="headerlink" title="1、如何实现从loader到kernel的信息传输？"></a>1、如何实现从loader到kernel的信息传输？</h3><p>信息的传递流程为：<code>boot_info-&gt;loader-&gt;kernel</code>。现在的问题就是如何实现从<code>loader</code>到<code>kernel</code>的传输？</p>
<ul>
<li><p>方式一：将<code>boot_info</code>写到某个固定的地址，再由<code>kernel</code>自行去取：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101952279.png" alt="image-20240510195254050"></p>
</li>
<li><p>方式二：将内核的入口地址处视为存放着一个接受启动信息参数的函数，使用函数调用：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101954937.png" alt="image-20240510195449809"></p>
<blockquote>
<p><code>(void(*)(boot_info_t *))(SYS_KERNEL_LOAD_ADDR)(&amp;boot_info)</code></p>
<p>这个表达式是一个函数指针的类型转换，用于将一个特定地址处的函数映射到一个特定类型的函数指针。调用这个函数指针，并将 <code>boot_info</code> 作为参数传递给该函数。</p>
<ol>
<li><code>(SYS_KERNEL_LOAD_ADDR)</code>：<ul>
<li>这部分表示一个地址，即内核加载的地址 <code>SYS_KERNEL_LOAD_ADDR</code>。</li>
</ul>
</li>
<li><code>(void (*)(boot_info_t *))</code>：<ul>
<li>这部分是一个函数指针类型的转换。</li>
<li><code>void (*)(boot_info_t *)</code> 表示一个函数指针，指向一个接受 <code>boot_info_t *</code> 类型参数并返回 <code>void</code> 类型的函数。</li>
</ul>
</li>
<li><code>(SYS_KERNEL_LOAD_ADDR)(&amp;boot_info)</code>：<ul>
<li>这部分将 <code>boot_info</code> 的地址作为参数传递给地址 <code>SYS_KERNEL_LOAD_ADDR</code> 处的函数，并且将返回的结果转换为 <code>(void (*)(boot_info_t *))</code> 类型的函数指针。</li>
</ul>
</li>
</ol>
<p>综合起来，整个表达式的作用是将位于地址 <code>SYS_KERNEL_LOAD_ADDR</code> 处的函数转换为一个接受 <code>boot_info_t *</code> 类型参数的函数指针，并且调用这个函数，将 <code>boot_info</code> 作为参数传递给它。</p>
</blockquote>
</li>
</ul>
<h3 id="2、x86栈的基本结构"><a href="#2、x86栈的基本结构" class="headerlink" title="2、x86栈的基本结构"></a>2、x86栈的基本结构</h3><p>保护模式下，栈单元大小为<code>32</code>位&#x2F;<code>4</code>字节。（在<code>32</code>位系统中）</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102027415.png" alt="image-20240510202728422"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102027751.png" alt="image-20240510202743173"></p>
<h3 id="3、实现细节"><a href="#3、实现细节" class="headerlink" title="3、实现细节"></a>3、实现细节</h3><p>（1）总体程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    .text</span><br><span class="line">    .extern kernel_init</span><br><span class="line">    .global _start</span><br><span class="line">    # void start (boot_info_t *boot_info)</span><br><span class="line">_start:</span><br><span class="line">    /*</span><br><span class="line">        将boot_info压入栈中，并传递给kernel_init</span><br><span class="line">        boot_info则来自_start被调用时，((void (*)(boot_info_t *))SYS_KERNEL_LOAD_ADDR)(&amp;boot_info);也会压栈</span><br><span class="line">            ((void (*)(boot_info_t *))SYS_KERNEL_LOAD_ADDR)(&amp;boot_info);</span><br><span class="line">            84d8:	83 ec 0c             	sub    $0xc,%sp</span><br><span class="line">            84db:	68 40 95             	push   $0x9540</span><br><span class="line">            84de:	00 00                	add    %al,(%bx,%si)</span><br><span class="line">            84e0:	b8 00 00             	mov    $0x0,%ax</span><br><span class="line">            84e3:	10 00                	adc    %al,(%bx,%si)</span><br><span class="line">            84e5:	ff d0                	call   *%ax</span><br><span class="line">            84e7:	83 c4 10             	add    $0x10,%sp</span><br><span class="line">        也即是说_start实际上是被调函数，参考讲义中的test函数的逻辑来操作</span><br><span class="line">    */</span><br><span class="line">    push %ebp</span><br><span class="line">    mov %esp, %ebp</span><br><span class="line">    mov 0x8(%ebp), %eax</span><br><span class="line">    /*</span><br><span class="line">        通过ebp+偏移来取得boot_info</span><br><span class="line">        由于_start仅1个参数，因此栈的局部结构为：</span><br><span class="line">            - 参数：boot_info</span><br><span class="line">            - 返回地址</span><br><span class="line">            - ebp当前指向位置（esp当前指向位置）</span><br><span class="line">        所以为0x8(%ebp)</span><br><span class="line">    */  </span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        由于最终是原地跳转，不会回到loader中，因此也可以不考虑ebp恢复的情况，此时上述三行可用一行来实现：</span><br><span class="line">            mov 4(%esp), %eax</span><br><span class="line"></span><br><span class="line">        当不考虑ebp时，esp+4即可取到boot_info</span><br><span class="line">        由于_start仅1个参数，因此栈的局部结构为：</span><br><span class="line">            - 参数：boot_info</span><br><span class="line">            - 返回地址（esp当前指向位置）</span><br><span class="line">        所以为4(%esp)</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    # kernel_init (boot_info)</span><br><span class="line">    push %eax  </span><br><span class="line">    call kernel_init  # 此时的kernel_init是被_start调用的函数</span><br><span class="line"></span><br><span class="line">    jmp .</span><br></pre></td></tr></table></figure>

<p>（2）具体执行</p>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push %ebp</span><br><span class="line">mov %esp, %ebp</span><br><span class="line">mov 0x8(%ebp), %eax</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102049124.png" alt="image-20240510204938049"></p>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov 0x8(%ebp), %eax</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102050925.png" alt="image-20240510205045871"></p>
<p>而在<code>./build/source/loader/loder_elf.txt</code>的符号表中，可以看到<code>boot_info</code>的地址即为<code>0x9540</code>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102052194.png" alt="image-20240510205246084"></p>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push %eax  </span><br><span class="line">call kernel_init  # 此时的kernel_init是被_start调用的函数</span><br><span class="line">jmp .</span><br></pre></td></tr></table></figure>

<p>当进入<code>kernel_init</code>函数后，可以看到传入的<code>boot_info</code>的地址也是<code>0x9540</code>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102054365.png" alt="image-20240510205443276"></p>
<h2 id="3-7-代码-数据段与链接脚本"><a href="#3-7-代码-数据段与链接脚本" class="headerlink" title="3.7 代码&#x2F;数据段与链接脚本"></a>3.7 代码&#x2F;数据段与链接脚本</h2><h3 id="1、链接的理论基础"><a href="#1、链接的理论基础" class="headerlink" title="1、链接的理论基础"></a>1、链接的理论基础</h3><blockquote>
<p>可参考【Computer-&gt;CSAPP-CSAPP_Ch7 链接】相关笔记。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102057812.png" alt="image-20240510205719578"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102108837.png" alt="image-20240510210839581"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102108978.png" alt="image-20240510210855757"></p>
<p>举例如下：</p>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102114815.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102116737.png" width="300"/>
</center>



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102111597.png" alt="image-20240510211122344"></p>
<h3 id="2、自定义链接脚本"><a href="#2、自定义链接脚本" class="headerlink" title="2、自定义链接脚本"></a>2、自定义链接脚本</h3><p>上述所讲为编译器默认配置。可自定义链接脚本，定义工程中相应的代码或数据放在哪些位置。</p>
<p>编写<code>kernel.lds</code>文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x20000;  // 控制.text section的起始地址，后续的section也可以进行相应的设置</span><br><span class="line"></span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text)  // 通配符： *</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		*(.rodata)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.data : &#123;</span><br><span class="line">		*(.data)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.bss : &#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并修改对应的<code>[kernel/CMakeLists.txt]</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_EXE_LINKER_FLAGS &quot;-m elf_i386  -T $&#123;PROJECT_SOURCE_DIR&#125;/kernel.lds&quot;)</span><br></pre></td></tr></table></figure>

<p>也就是说链接脚本控制了各个<code>section</code>具体的存放位置，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102138372.png" alt="image-20240510213841287"></p>
<blockquote>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html">GCC LD官方文档</a></p>
<p><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Linker_Scripts">linker脚本(较易阅读)</a></p>
<p><a target="_blank" rel="noopener" href="http://www.bravegnu.org/gnu-eprog/linker.html">ARM Linker链接脚本</a></p>
<p><a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/ld/">ld脚本编写</a></p>
</blockquote>
<h2 id="3-8-加载内核映像文件"><a href="#3-8-加载内核映像文件" class="headerlink" title="3.8 加载内核映像文件"></a>3.8 加载内核映像文件</h2><h3 id="1、理论基础-1"><a href="#1、理论基础-1" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112014421.png" alt="image-20240511201413000"></p>
<p>若在<code>#12</code>行设置<code>. = 200000</code>，则会导致在<code>.rodata</code>和<code>.data</code>中间出现较大的空闲空间，导致最终的文件大小大于<code>1MB</code>，这个大小过大了。且如果采用二进制映像文件，操作系统是无法得知各个<code>section</code>在内存中分布的具体位置的。</p>
<p>为了更好地组织程序和数据，一般需要专用的文件格式，如<code>PE</code>格式或者<code>ELF</code>格式。<code>ELF</code>用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件的文件格式。</p>
<blockquote>
<p>ELF文件的详细细节可参考【Computer-&gt;CSAPP-CSAPP_Ch7 链接】相关笔记。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112021480.png" alt="image-20240511202122375"></p>
<ul>
<li><p>可执行代码段和数据段从<code>p_offset</code>的位置拷贝到内存的<code>p_paddr</code>中，拷贝的大小为<code>p_filesz</code>。</p>
</li>
<li><p>在<code>ELF</code>文件格式中，<code>.data</code> 和 <code>.bss</code> 区域通常用来存储程序的已初始化和未初始化数据。在加载可执行文件时，操作系统会负责为这些区域分配内存，并将它们初始化为零。</p>
<p>因此，在生成<code>ELF</code>可执行文件时，不需要将 <code>.data</code> 和 <code>.bss</code> 区域的实际数据写入文件中。相反，只需在文件中标记出这些区域的大小，并在加载时告知操作系统需要为它们分配多大的内存空间，并将其初始化为零。</p>
</li>
<li><p><code>p_memsz = p_filesz + 清零区域</code></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112105777.png" alt="image-20240511210512520"></p>
<h3 id="2、代码实现细节"><a href="#2、代码实现细节" class="headerlink" title="2、代码实现细节"></a>2、代码实现细节</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># bin文件生成，写入到image目录下</span><br><span class="line">add_custom_command(TARGET $&#123;PROJECT_NAME&#125;</span><br><span class="line">                   POST_BUILD</span><br><span class="line">                   # 修改前</span><br><span class="line">                   # COMMAND $&#123;OBJCOPY_TOOL&#125; -O binary $&#123;PROJECT_NAME&#125;.elf $&#123;CMAKE_SOURCE_DIR&#125;/../../image/$&#123;PROJECT_NAME&#125;.elf</span><br><span class="line">                   # 修改后：-O binary =&gt; -S</span><br><span class="line">                   COMMAND $&#123;OBJCOPY_TOOL&#125; -S $&#123;PROJECT_NAME&#125;.elf $&#123;CMAKE_SOURCE_DIR&#125;/../../image/$&#123;PROJECT_NAME&#125;.elf</span><br><span class="line">				   COMMAND $&#123;OBJDUMP_TOOL&#125; -x -d -S -m i386 $&#123;PROJECT_BINARY_DIR&#125;/$&#123;PROJECT_NAME&#125;.elf &gt; $&#123;PROJECT_NAME&#125;_dis.txt</span><br><span class="line">                   COMMAND $&#123;READELF_TOOL&#125; -a $&#123;PROJECT_BINARY_DIR&#125;/$&#123;PROJECT_NAME&#125;.elf &gt; $&#123;PROJECT_NAME&#125;_elf.txt</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>修改后，新的存储规划如下：</p>
<ul>
<li>将<code>kernel</code>，即内核工程放在<code>64KB/0x10000</code>的位置；</li>
<li>也就是说，<code>0x100000</code>处只是存放一个临时的<code>ELF</code>文件，实际的内容会被加载到<code>0x10000</code>处执行。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112030942.png" alt="image-20240511203046852"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">reload_elf_file</span><span class="params">(<span class="type">uint8_t</span> *file_buffer)</span> &#123;</span><br><span class="line">    Elf32_Ehdr *elf_hdr = (Elf32_Ehdr *)file_buffer;</span><br><span class="line">    <span class="comment">// 检查是否为有效文件（粗略检查）</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr-&gt;e_ident[<span class="number">0</span>] != <span class="number">0x7F</span>) || (elf_hdr-&gt;e_ident[<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">        || (elf_hdr-&gt;e_ident[<span class="number">2</span>] != <span class="string">&#x27;L&#x27;</span>) || (elf_hdr-&gt;e_ident[<span class="number">3</span>] != <span class="string">&#x27;F&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取相应的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elf_hdr-&gt;e_phnum; i++) &#123;</span><br><span class="line">        Elf32_Phdr *phdr = (Elf32_Phdr *)(file_buffer + elf_hdr-&gt;e_phoff) + i;  <span class="comment">// 偏移量：elf_hdr-&gt;e_phoff</span></span><br><span class="line">        <span class="comment">// 判断该段是需要被加载到内存中的可执行代码或数据段</span></span><br><span class="line">        <span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将可执行代码或数据段从文件中拷贝到内存中</span></span><br><span class="line">        <span class="type">uint8_t</span> *src = file_buffer + phdr-&gt;p_offset;</span><br><span class="line">        <span class="type">uint8_t</span> *dest = (<span class="type">uint8_t</span> *)phdr-&gt;p_paddr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; phdr-&gt;p_filesz; j++) &#123;</span><br><span class="line">            *dest++ = *src++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 针对.data和.bss做进一步处理</span></span><br><span class="line">        dest = (<span class="type">uint8_t</span> *)phdr-&gt;p_paddr + phdr-&gt;p_filesz;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; phdr-&gt;p_memsz - phdr-&gt;p_filesz; j++) &#123;</span><br><span class="line">            *dest++ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elf_hdr-&gt;e_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112120766.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112119587.png" width="300"/>    
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112121617.png" width="300"/>
</center>



<h1 id="四、中断与异常处理"><a href="#四、中断与异常处理" class="headerlink" title="四、中断与异常处理"></a>四、中断与异常处理</h1><h2 id="4-1-创建GDT表及其表项"><a href="#4-1-创建GDT表及其表项" class="headerlink" title="4.1 创建GDT表及其表项"></a>4.1 创建GDT表及其表项</h2><h3 id="1、理论基础-2"><a href="#1、理论基础-2" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p><code>x86</code>系统架构（<code>IA32</code>模式）</p>
<ul>
<li><p>分段存储</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121404633.png" alt="image-20240512140427535"></p>
</li>
<li><p>分页存储</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121404406.png" alt="image-20240512140446313"></p>
</li>
</ul>
<p><strong>在进入保护模式以后，所有有关内存访问的操作都需要经过<code>GDT</code>表</strong>，表中的每项称为<strong>段描述符</strong>（<code>Segment descriptor</code>）。</p>
<p>每一项是一个结构体，<code>64</code>位结构，包含<code>base addr/基地址</code>、<code>limit/界限</code>以及<code>属性值</code></p>
<ul>
<li><code>limit</code>分为<code>2</code>块，<code>limit 15:00</code>和<code>limit 19:16</code></li>
<li><code>base addr</code>分为<code>3</code>块，<code>base 15:00</code>、<code>base 23:16</code>和<code>base 31:24</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121405202.png" alt="image-20240512140536089"></p>
<h3 id="2、代码细节"><a href="#2、代码细节" class="headerlink" title="2、代码细节"></a>2、代码细节</h3><ul>
<li><p><code>GDT</code>结构体的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">segment_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit15_0;</span><br><span class="line">    <span class="type">uint16_t</span> base15_0;</span><br><span class="line">    <span class="type">uint8_t</span> base23_16;</span><br><span class="line">    <span class="type">uint16_t</span> attr;</span><br><span class="line">    <span class="type">uint8_t</span> base31_24;</span><br><span class="line">&#125;<span class="type">segment_desc_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化<code>GDT</code>表项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">segment_desc_t</span> gdt_table[GDT_TABLE_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    selector：从gdt表中选择某个表项</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">segment_desc_set</span> <span class="params">(<span class="type">int</span> selector, <span class="type">uint32_t</span> base, <span class="type">uint32_t</span> limit, <span class="type">uint16_t</span> attr)</span> &#123;</span><br><span class="line">    <span class="type">segment_desc_t</span> *desc = gdt_table + selector / <span class="keyword">sizeof</span>(<span class="type">segment_desc_t</span>);</span><br><span class="line"></span><br><span class="line">    desc-&gt;limit15_0 = limit &amp; <span class="number">0xFFFF</span>;                   <span class="comment">// limit低16位</span></span><br><span class="line">    desc-&gt;base15_0 = base &amp; <span class="number">0xFFFF</span>;                     <span class="comment">// base低16位</span></span><br><span class="line">    desc-&gt;base23_16 = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;              <span class="comment">// base右移16位后取低8位</span></span><br><span class="line">    desc-&gt;attr = attr | (((limit &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xF</span>) &lt;&lt; <span class="number">8</span>);   <span class="comment">// 将limit的高4位存储到attr字段 </span></span><br><span class="line">    desc-&gt;base31_24 = (base &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;              <span class="comment">// base右移24位后取低8位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空gdt表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; GDT_TABLE_SIZE; ++i) &#123;</span><br><span class="line">        segment_desc_set(i * <span class="keyword">sizeof</span>(<span class="type">segment_desc_t</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cpu_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    init_gdt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>理论上，处理器可以访问寻址处理任意地址的字节，但实际上为了保证计算机读取数据的高效性，<code>CPU</code>通过地址总线来访问内存。以32位处理器为例，一般来说寻址步长为32位(4个字节)，也就是每次从内存读取4个字节。为了提高存取效率，一般来说编译器会自动将一个数据尽量放在一个步长之内，避免跨步长存储，称为内存对齐。<br>每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。可通过预编译命令<code>#pragma pack(n)</code>，<code>n=1,2,4,8,16</code>来改变这一系数，其中的n就是你要指定的“对齐系数”。</p>
</blockquote>
<h2 id="4-2-保护模式下的内存管理简介"><a href="#4-2-保护模式下的内存管理简介" class="headerlink" title="4.2 保护模式下的内存管理简介"></a>4.2 保护模式下的内存管理简介</h2><h3 id="1、理论基础-3"><a href="#1、理论基础-3" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p>参考<code>325384-sdm-vol-3abcd.pdf</code>的<code>Ch3 Protected-Mode Memory Management</code></p>
</blockquote>
<ul>
<li><p>分段存储和分页存储及其异同</p>
<ul>
<li>分页存储</li>
</ul>
<p>  将程序的逻辑地址空间划分为固定大小的页(<code>page</code>)，而物理内存划分为同样大小的页框(<code>page frame</code>)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。</p>
<ul>
<li>分段存储</li>
</ul>
<p>  在分段存储管理中，将程序的地址空间划分为若干个段(<code>segment</code>)，这样每个进程有一个二维的地址空间。每个段分配一个连续的分区，而进程中的各个段可以不连续地存放在内存的不同分区中。程序加载时，操作系统为所有段分配其所需内存，这些段不必连续。</p>
<ul>
<li><p>分页和分段的相同点</p>
<ul>
<li><p>分页机制和分段机制都是为了提高内存利用率，产生较少的内存碎片。</p>
</li>
<li><p>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是每个页和段中的内存是连续的。</p>
</li>
</ul>
</li>
<li><p>分页和分段的区别</p>
<ul>
<li><p>页的大小是固定的，由操作系统决定，而段的大小不固定，取决于我们当前运行的程序。</p>
</li>
<li><p>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，它含有一组其意义相对完整的信息，在程序中可以体现为代码段，数据段，是为了满足用户的需要。</p>
</li>
<li><p>分页的作业地址空间是维一的，即单一的线性空间，程序员只须利用一个记忆符，即可表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</p>
</li>
<li><p>段一般比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121550258.png" alt="image-20240512155014746"></p>
</li>
<li><p>下图是一种比较复杂的设计，一般不采用</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121551856.png" alt="image-20240512155154382"></p>
</li>
<li><p>为简单起见，可采用平坦模型，分为基础平坦模式和带保护的平坦模式。</p>
</li>
<li><p><strong>本项目采用基础平坦模式。</strong></p>
<ul>
<li><code>CS</code>指向代码段；剩余寄存器指向数据段；</li>
<li>两个段的起始地址均为<code>0</code>，大小为<code>4GB</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121555355.png" alt="image-20240512155513883"></p>
</li>
<li><p>从逻辑地址转换到线性地址</p>
<ul>
<li>举例，对于逻辑地址<code>0x8:0x1234</code>：<ul>
<li><code>0x8</code>对应<code>GDT</code>的表项<code>1</code>；</li>
<li><code>GDT</code>的表项<code>1</code>中基地址为<code>0x10000</code>，因此线性地址为<code>0x11234</code>。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121558156.png" alt="image-20240512155843842"></p>
</li>
<li><p>对于上文所述的<code>0x8</code>，观察选择子的结构可以得知，低<code>3</code>位用于其他用途，剩余位用于判断索引<code>index</code>。因此<code>0x8 = (b)00001000</code>，因此对应表项1。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121603986.png" alt="image-20240512160330889" style="zoom:50%;" /></li>
</ul>
<h3 id="2、内存访问的整体流程"><a href="#2、内存访问的整体流程" class="headerlink" title="2、内存访问的整体流程"></a>2、内存访问的整体流程</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121603112.png" alt="image-20240512160353942"></p>
<h2 id="4-3-重新加载GDT表"><a href="#4-3-重新加载GDT表" class="headerlink" title="4.3 重新加载GDT表"></a>4.3 重新加载GDT表</h2><p>在<code>loader_16.c</code>中曾经自定义了一个简单的<code>GDT</code>表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GDT表（临时用，后面内容会替换成自己的）</span></span><br><span class="line"><span class="type">uint16_t</span> gdt_table[][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xFFFF</span>, <span class="number">0x0000</span>, <span class="number">0x9A00</span>, <span class="number">0x00CF</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xFFFF</span>, <span class="number">0x0000</span>, <span class="number">0x9200</span>, <span class="number">0x00CF</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>存在以下不足：</p>
<p>1）表项过小，在后期涉及到多进程以及中断管理时需要加入新的配置项；</p>
<p>2）当前这个表存储所在的内存区域为<code>loader</code>，即数据区，在后面可能会被覆盖。</p>
<p>因此，在<code>kernel</code>工程中设计了一个包含<code>256</code>个表项的新<code>GDT</code>表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_TABLE_SIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">segment_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit15_0;</span><br><span class="line">    <span class="type">uint16_t</span> base15_0;</span><br><span class="line">    <span class="type">uint8_t</span> base23_16;</span><br><span class="line">    <span class="type">uint16_t</span> attr;</span><br><span class="line">    <span class="type">uint8_t</span> base31_24;</span><br><span class="line">&#125;<span class="type">segment_desc_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、实现细节"><a href="#2、实现细节" class="headerlink" title="2、实现细节"></a>2、实现细节</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121656373.png" alt="image-20240512165607190"></p>
<p>重新加载<code>GDT</code>表后：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121657737.png" alt="image-20240512165730560"></p>
<p>对于<code>CS</code>项：</p>
<ul>
<li><code>0008</code>：选择子</li>
<li>后面的数字则是具体的表项，包括<code>limit</code>、<code>base</code>和<code>attr</code>等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121701389.png" alt="image-20240512170129300"></p>
<h2 id="4-4-触发异常与异常简介"><a href="#4-4-触发异常与异常简介" class="headerlink" title="4.4 触发异常与异常简介"></a>4.4 触发异常与异常简介</h2><h3 id="1、理论基础-4"><a href="#1、理论基础-4" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>在程序运行过程中，有可能会发生各种异常事件，CPU需要跳转到相应的程序对这些事件进行处理。</p>
<ul>
<li>异常<ul>
<li>由于CPU内部事件所引起的中断，如程序出错（非法指令、地址越界以及除0异常等）</li>
<li>通常由于执行了现行指令所引起</li>
</ul>
</li>
<li>中断<ul>
<li>由于外部设备事件所引起的中断，如通常的磁盘中断以及打印机中断等</li>
<li>通常与现行指令无关，由外部事件引起</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122031495.png" alt="image-20240512203148228"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122032412.png" alt="image-20240512203209841"></p>
<h2 id="4-5-添加中断门描述符"><a href="#4-5-添加中断门描述符" class="headerlink" title="4.5 添加中断门描述符"></a>4.5 添加中断门描述符</h2><h3 id="1、理论基础-5"><a href="#1、理论基础-5" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>进入保护模式后，中断向量表需要重新配置。</p>
<p><code>IA-32</code>中断向量表：<code>IDTR</code>寄存器指向的<code>IDT/Interrupt Descriptor Table</code>表。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122035869.png" alt="image-20240512203547782"></p>
<ul>
<li><code>IDTR</code>寄存器，由<code>Base Address</code>和<code>Limit</code>组成。<ul>
<li>基地址：保存<code>IDT</code>表的起始位置</li>
<li><code>Limit</code>：指定<code>IDT</code>表的大小</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122035976.png" alt="image-20240512203508876"></p>
<ul>
<li><p><code>IDT</code>表项的具体格式</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122039950.png" alt="image-20240512203943834"></p>
<ul>
<li><p><code>Interrupt Gate</code>：本项目主要采用该格式。</p>
<ul>
<li><p>包含选择子、偏移量以及一些其他的标志位。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122044231.png" alt="image-20240512204443158" style="zoom: 80%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IDT表项/Interrupt Gate中断门表项</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">gate_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> offset15_0;</span><br><span class="line">    <span class="type">uint16_t</span> selector;</span><br><span class="line">    <span class="type">uint16_t</span> attr;</span><br><span class="line">    <span class="type">uint16_t</span> offset31_16;</span><br><span class="line">&#125;<span class="type">gate_desc_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置IDT表项/中断门表项 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gate_desc_set</span> <span class="params">(<span class="type">gate_desc_t</span> *desc, <span class="type">uint16_t</span> selector, <span class="type">uint32_t</span> offset, <span class="type">uint16_t</span> attr)</span> &#123;</span><br><span class="line">    desc-&gt;offset15_0 = offset &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    desc-&gt;selector = selector;</span><br><span class="line">    desc-&gt;attr = attr;</span><br><span class="line">    desc-&gt;offset31_16 = (offset &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行初始化后可以看到<code>IDT</code>的值被设置为<code>idt_table</code>的首地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">irq_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空IDT表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IDT_TABLE_NR; i++) &#123;</span><br><span class="line">        gate_desc_set(idt_table + i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将IDTR寄存器指向IDT表</span></span><br><span class="line">    lidt((<span class="type">uint32_t</span>)idt_table, <span class="keyword">sizeof</span>(idt_table));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122109920.png" alt="image-20240512210927867"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122109701.png" alt="image-20240512210916635"></p>
<h2 id="4-6-捕获除0异常"><a href="#4-6-捕获除0异常" class="headerlink" title="4.6 捕获除0异常"></a>4.6 捕获除0异常</h2><h3 id="1、为所有异常配置缺省的处理程序"><a href="#1、为所有异常配置缺省的处理程序" class="headerlink" title="1、为所有异常配置缺省的处理程序"></a>1、为所有异常配置缺省的处理程序</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122113907.png" alt="image-20240512211301703"></p>
<p>设置缺省处理程序时，由于基地址为<code>0</code>，只需将处理程序的起始地址赋值给<code>offset</code>，然后将<code>IDT</code>的选择子设置为代码段的选择子即可。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122124096.png" alt="image-20240512212443637"></p>
<p>注意：中断处理程序只能用汇编来写，而不能用C语言来写！</p>
<blockquote>
<p>中断处理程序需要使用 <code>iret</code> 指令来正确地恢复被中断的程序的执行状态。<code>iret</code> 指令用于从中断处理程序返回到被中断的程序，并恢复被中断程序的执行现场，包括栈指针、标志寄存器和程序计数器等。</p>
<p>在 x86 架构中，<code>iret</code> 指令不能在 C 函数中直接使用，因为 C 函数的结尾通常是 <code>ret</code> 指令，这个指令只能用于从函数返回，而不能正确地恢复中断处理程序的执行状态。</p>
<p>因此，为了正确处理中断，特别是在中断处理程序中使用 <code>iret</code> 指令，需要使用汇编语言编写中断处理程序。只有在汇编语言中，可以直接使用 <code>iret</code> 指令来正确地返回到被中断的程序。</p>
</blockquote>
<h3 id="2、除0异常发生"><a href="#2、除0异常发生" class="headerlink" title="2、除0异常发生"></a>2、除0异常发生</h3><p>当发生除<code>0</code>异常时，首先会跳转到<code>iret</code>指令，</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122152287.png" alt="image-20240512215244219"></p>
<p>接下按<code>F11</code>单步调试，然后又会回到除<code>0</code>指令（<code>int a = 3 / 0</code>）上，</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122149517.png" alt="image-20240512214929396"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122150962.png" alt="image-20240512215020824"></p>
<p>再次处理发现仍旧无法解决，因此又会回到<code>iret</code>指令，</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122152287.png" alt="image-20240512215244219"></p>
<p>这样就会陷入死循环。因此在用户端程序遇到异常时一般需要将程序杀掉，但在操作系统中则无法处理，因此一般采用死机的处理。</p>
<p>详述“死机”的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exception_handle_unkown:</span><br><span class="line">    call do_handler_unkown</span><br><span class="line">    iret </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_default_handle</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_unkown</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    do_default_handle(<span class="string">&quot;unkown exception&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发现除<code>0</code>异常时：</p>
<p>-&gt; <code>exception_handle_unkown</code></p>
<p>-&gt; <code>do_handler_unkown</code></p>
<p>-&gt; <code>do_default_handle</code></p>
<p>-&gt; 进入死循环，即死机</p>
<h3 id="3、预先保存寄存器状态"><a href="#3、预先保存寄存器状态" class="headerlink" title="3、预先保存寄存器状态"></a>3、预先保存寄存器状态</h3><p>此外，在跳转到中断处理程序开始处理中断之前，需要先保存当前寄存器的状态，以防止后续对寄存器进行修改。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122236298.png" alt="image-20240512223603745"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">exception_handle_unkown:</span><br><span class="line">    # 寄存器压栈</span><br><span class="line">    pusha</span><br><span class="line">    push %ds</span><br><span class="line">    push %es</span><br><span class="line">    push %fs</span><br><span class="line">    push %gs</span><br><span class="line"></span><br><span class="line">    call do_handler_unkown</span><br><span class="line"></span><br><span class="line">    # 寄存器出栈</span><br><span class="line">    pop %gs</span><br><span class="line">    pop %fs</span><br><span class="line">    pop %es</span><br><span class="line">    pop %ds</span><br><span class="line">    popa</span><br><span class="line"></span><br><span class="line">    iret </span><br></pre></td></tr></table></figure>

<p>注意：此处不必压栈<code>ss</code>和<code>esp</code>寄存器，原因如下：</p>
<blockquote>
<ol>
<li><strong>特权级不变</strong>： 在x86保护模式下，当从一个特权级（例如内核模式，特权级0）中断或异常到同一特权级时，不会自动保存 <code>ss</code> 和 <code>esp</code> 寄存器。仅当从低特权级（如用户模式，特权级3）切换到高特权级（如内核模式，特权级0）时，才会自动保存 <code>ss</code> 和 <code>esp</code> 寄存器。</li>
<li><strong>特权级切换</strong>： 如果特权级发生变化，例如从用户模式（特权级3）切换到内核模式（特权级0），CPU 会自动将 <code>ss</code> 和 <code>esp</code> 压入堆栈。为了处理这种情况，你需要一个包含 <code>ss</code> 的扩展结构体。</li>
</ol>
</blockquote>
<h2 id="4-7-解析异常栈信息"><a href="#4-7-解析异常栈信息" class="headerlink" title="4.7 解析异常栈信息"></a>4.7 解析异常栈信息</h2><h3 id="1、理论基础-6"><a href="#1、理论基础-6" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p>在发生异常而跳转到异常处理程序时，希望能够知道究竟是哪里触发了异常。此时就需要查看异常栈的相关信息。</p>
</blockquote>
<p>对于下图：当异常发生后，会将<code>EFLAGS/CS/EIP/Error Code</code>压入栈中</p>
<ul>
<li><code>EFLAGS</code>保存了状态一些相关状态</li>
<li><code>EIP</code>指示了异常发生时是哪条指令触发了异常，会将对应的地址压入<code>EIP</code>中</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131022114.png" alt="image-20240513102222754"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/650880105">x86—EFLAGS寄存器详解【转载】</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Reverse-xiaoyu/p/11397584.html">EFLAGS寄存器（标志寄存器）</a></p>
</blockquote>
<p>在调试控制台查看<code>esp:0x12e28</code>开始栈的相关信息，但这样做比较繁琐。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131026877.png" alt="image-20240513102619780"></p>
<p>在进入异常处理时，用<code>pusha</code>指令主动保存了一部分：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131032907.png" alt="image-20240513103220789"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131033545.png" alt="image-20240513103300450"></p>
<p>此外，通过<code>push</code>指令压入其他寄存器：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131034526.png" alt="image-20240513103415308"></p>
<p><strong>因此，这些要获取的栈中的寄存器信息则类似于向缺省处理函数传递的参数。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131036123.png" alt="image-20240513103626832"></p>
<p>但如果按上图中那样去写，会显得过于繁琐。因此可以将其封装为结构体，从而转换为压入这个结构体的地址（作为一个指针）。</p>
<p>根据上图，当前<code>ESP</code>指向<code>GS</code>寄存器，在将<code>ES</code>到<code>EFLAGS</code>包装为结构体后，将结构体的指针压入栈中，此时这个指针指向<code>GS</code>的地址；而执行压栈操作后，<code>ESP</code>指向该指针。</p>
<ul>
<li><p>即——<code>ESP-&gt;指针-&gt;GS</code></p>
</li>
<li><p>语法为：<code>push %esp</code></p>
<blockquote>
<p>在x86汇编语言中，<code>push %esp</code> 指令用于将栈指针 <code>%esp</code> 的当前值压入栈顶。</p>
<p>1）将 <code>%esp</code> 寄存器中的当前值（即栈指针指向的地址）减去 4；</p>
<p>2）将其指向的内存位置（即原栈顶）的值复制到减去 4 后的新栈顶地址中；</p>
<p>3）然后更新 <code>%esp</code> 寄存器的值，使其指向新的栈顶地址。</p>
</blockquote>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131039358.png" alt="image-20240513103940064"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exception_handle_unkown:</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    push %esp  </span><br><span class="line">    # 由于将GS到EFLAGS这个整体作为一个结构体，此时当前esp指向GS寄存器的下一位，因此在压入栈时只需要将GS的地址压入</span><br><span class="line">    call do_handler_unkown</span><br><span class="line">    add $(1*4), %esp  # 出栈</span><br><span class="line">	</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131104164.png" alt="image-20240513110407067"></p>
<p>对比下图，可以看到获取到的栈信息和<code>Segs</code>中的相关寄存器（左）相同，且<code>eip</code>寄存器保存的即为除<code>0</code>指令（右）所对应的地址。</p>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131104668.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131105155.png" width="300"/>    
</center>

<h2 id="4-8-利用宏重用异常处理代码"><a href="#4-8-利用宏重用异常处理代码" class="headerlink" title="4.8 利用宏重用异常处理代码"></a>4.8 利用宏重用异常处理代码</h2><h3 id="1、宏重用相关"><a href="#1、宏重用相关" class="headerlink" title="1、宏重用相关"></a>1、宏重用相关</h3><p>下表展示了22种异常&#x2F;中断的类型。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131125038.png" alt="image-20240513112516959"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131125775.png" alt="image-20240513112528641"></p>
<p>如果要对这22种异常&#x2F;中断各自编写一段汇编代码，就会使得代码过于冗杂，因为仅仅只有函数名称和内部调用C函数的区别，处理的逻辑是一致的。因此考虑采用<strong>宏重用</strong>的方式。</p>
<p>注意此处</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exception_handler_\name:</span><br><span class="line">    # 错误码入栈</span><br><span class="line">    .if \with_err_code == 0</span><br><span class="line">        push $0  # 压入0表示没有错误码</span><br><span class="line">    .endif</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    # 类型编号和错误码出栈</span><br><span class="line">    add $(2*4), %esp</span><br><span class="line"></span><br><span class="line">    iret </span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<blockquote>
<p>错误想法：对于有错误码的异常类型，会自动将错误码入栈，因此最后出栈时不需要考虑它，只需要<code>add $(1*4), %esp</code>；只有对于需要手动压入错误码的异常，才需要<code>add $(2*4), %esp</code>进行手动出栈。</p>
<p>这种想法的错误在于：<code>iret</code>指令在执行时会忽略<code>Error Code</code>，也就是说不管这个异常有没有自动入栈错误码，都需要我们手动去出栈。</p>
</blockquote>
<p>设定好宏后，测试并查看对应的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exception_handler unknown, -1, 0</span><br><span class="line">exception_handler divider, 0, 0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">exception_handler unknown, -1, 0</span><br><span class="line">   1002b:	6a 00                	push   $0x0</span><br><span class="line">   1002d:	6a ff                	push   $0xffffffff</span><br><span class="line">   1002f:	60                   	pusha  </span><br><span class="line">   10030:	1e                   	push   %ds</span><br><span class="line">   10031:	06                   	push   %es</span><br><span class="line">   10032:	0f a0                	push   %fs</span><br><span class="line">   10034:	0f a8                	push   %gs</span><br><span class="line">   10036:	54                   	push   %esp</span><br><span class="line">   10037:	e8 c4 01 00 00       	call   10200 &lt;do_handler_unknown&gt;</span><br><span class="line">   1003c:	83 c4 04             	add    $0x4,%esp</span><br><span class="line">   1003f:	0f a9                	pop    %gs</span><br><span class="line">   10041:	0f a1                	pop    %fs</span><br><span class="line">   10043:	07                   	pop    %es</span><br><span class="line">   10044:	1f                   	pop    %ds</span><br><span class="line">   10045:	61                   	popa   </span><br><span class="line">   10046:	83 c4 08             	add    $0x8,%esp</span><br><span class="line">   10049:	cf                   	iret   </span><br><span class="line">  </span><br><span class="line">0001004a &lt;exception_handler_divider&gt;:</span><br><span class="line">   1004a:	6a 00                	push   $0x0</span><br><span class="line">   1004c:	6a 00                	push   $0x0</span><br><span class="line">   1004e:	60                   	pusha  </span><br><span class="line">   1004f:	1e                   	push   %ds</span><br><span class="line">   10050:	06                   	push   %es</span><br><span class="line">   10051:	0f a0                	push   %fs</span><br><span class="line">   10053:	0f a8                	push   %gs</span><br><span class="line">   10055:	54                   	push   %esp</span><br><span class="line">   10056:	e8 bb 01 00 00       	call   10216 &lt;do_handler_divider&gt;</span><br><span class="line">   1005b:	83 c4 04             	add    $0x4,%esp</span><br><span class="line">   1005e:	0f a9                	pop    %gs</span><br><span class="line">   10060:	0f a1                	pop    %fs</span><br><span class="line">   10062:	07                   	pop    %es</span><br><span class="line">   10063:	1f                   	pop    %ds</span><br><span class="line">   10064:	61                   	popa   </span><br><span class="line">   10065:	83 c4 08             	add    $0x8,%esp</span><br><span class="line">   10068:	cf                   	iret   </span><br></pre></td></tr></table></figure>

<h3 id="2、向IDT表项中安装中断处理程序"><a href="#2、向IDT表项中安装中断处理程序" class="headerlink" title="2、向IDT表项中安装中断处理程序"></a>2、向IDT表项中安装中断处理程序</h3><p>接下来编写<strong>安装中断处理程序</strong>的函数，它接受两个参数：<code>irq_num</code> 表示中断号，<code>handler</code> 是一个指向中断处理函数的指针。</p>
<ul>
<li>函数首先检查给定的中断号是否超过了 IDT 表项的范围。如果超过了，就返回 <code>-1</code> 表示失败；</li>
<li>然后，函数调用 <code>gate_desc_set</code> 函数来设置 IDT 表中的表项。<code>gate_desc_set</code> 函数的目的是将中断处理函数与指定的中断号关联起来，并将相应的中断处理函数的地址写入到 IDT 表中。这样，当相应的中断发生时，CPU 就会根据 IDT 表中的设置跳转到相应的中断处理函数；</li>
<li>最后，函数返回 <code>0</code> 表示成功安装中断处理程序。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">irq_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空IDT表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IDT_TABLE_NR; i++) &#123;</span><br><span class="line">        gate_desc_set(</span><br><span class="line">            idt_table + i, </span><br><span class="line">            KERNEL_SELECTOR_CS,</span><br><span class="line">            (<span class="type">uint32_t</span>)exception_handler_unknown, </span><br><span class="line">            GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安装中断处理程序到 IDT（中断描述符表）中</span></span><br><span class="line">    irq_install(IRQ0_DE, (<span class="type">irq_handler_t</span>)exception_handler_divider);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将IDTR寄存器指向IDT表</span></span><br><span class="line">    lidt((<span class="type">uint32_t</span>)idt_table, <span class="keyword">sizeof</span>(idt_table));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">irq_install</span> <span class="params">(<span class="type">int</span> irq_num, <span class="type">irq_handler_t</span> handler)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断异常编号是否超过IDT表项的范围</span></span><br><span class="line">    <span class="keyword">if</span> (irq_num &gt;= IDT_TABLE_NR) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置IDT表项</span></span><br><span class="line">    gate_desc_set(idt_table + irq_num, KERNEL_SELECTOR_CS, </span><br><span class="line">                (<span class="type">uint32_t</span>)handler, GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131532647.png" alt="image-20240513153252414"></p>
<p>按照前述方式，可对其他类型的异常进行类似的处理。</p>
<h2 id="4-9-初始化中断控制器"><a href="#4-9-初始化中断控制器" class="headerlink" title="4.9 初始化中断控制器"></a>4.9 初始化中断控制器</h2><h3 id="1、理论基础-7"><a href="#1、理论基础-7" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p> CPU如何管理系统中的中断？</p>
</blockquote>
<p>一个<code>8259</code>芯片可以接收<code>IRQ0-IRQ7</code>共<code>8</code>个信号，当接收到相应的中断信号时，在内部进行处理，并通过<code>INT</code>信号连接到<code>CPU</code>，并向<code>CPU</code>发出中断请求。</p>
<p>由于个数限制，早期的<code>x86</code>处理器级联两片<code>8259</code>，接收共<code>15</code>个中断信号，其中一块芯片的<code>IR2</code>用于和另一块芯片连接。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131707991.png" alt="image-20240513170754592"></p>
<p>随着多核处理器的发展，<code>8259</code>被<code>APIC</code>替代。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131857119.png" alt="image-20240513185732842"></p>
<p><code>8259A</code>的内部结构图</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131859253.png" alt="image-20240513185944144"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131901488.png" alt="image-20240513190140086"></p>
<p><code>8259A</code>的初始化流程</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131902640.png" alt="image-20240513190216562"></p>
<blockquote>
<p><strong>8259的相关参考资料</strong></p>
<ul>
<li>《8259.pdf》</li>
<li><a target="_blank" rel="noopener" href="https://wiki.osdev.org/PIC">osdev关于8259的文档</a></li>
<li>《LINUX内核完全剖析:基于0.12内核》第180页</li>
</ul>
</blockquote>
<h3 id="2、实现细节-1"><a href="#2、实现细节-1" class="headerlink" title="2、实现细节"></a>2、实现细节</h3><p>初始化两个<code>8259</code>芯片。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// irq.h</span></span><br><span class="line"><span class="comment">// Interrupt Controller</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW1           0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW2           0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW3           0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW4           0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_IMR            0x21</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW1           0xA0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW2           0xA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW3           0xA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW4           0xA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_IMR            0xA1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_ICW1_ALWAYS_1   (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_ICW1_ICW4       (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_ICW4_8086       (1 &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_PIC_START       0x20</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// irq.c</span></span><br><span class="line"><span class="comment">/* Interrupt Controller Initialization */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_pic</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 对两个8259芯片进行初始化</span></span><br><span class="line">    outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);</span><br><span class="line">    outb(PIC0_ICW2, IRQ_PIC_START);</span><br><span class="line">    outb(PIC0_ICW3, <span class="number">1</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    outb(PIC0_ICW4, PIC_ICW4_8086);</span><br><span class="line"></span><br><span class="line">    outb(PIC1_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);</span><br><span class="line">    outb(PIC1_ICW2, IRQ_PIC_START + <span class="number">8</span>);</span><br><span class="line">    outb(PIC1_ICW3, <span class="number">2</span>);</span><br><span class="line">    outb(PIC1_ICW4, PIC_ICW4_8086);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断屏蔽寄存器初始化</span></span><br><span class="line">    outb(PIC0_IMR, <span class="number">0xFF</span> &amp; ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>));  <span class="comment">// 不禁止来自IRQ2的中断信号，因为其用于连接从片</span></span><br><span class="line">    outb(PIC1_IMR, <span class="number">0xFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131920596.png" alt="image-20240513192023489"></p>
<p>该寄存器的相应位为1时，会屏蔽对应的中断，使得CPU不予相应。当对芯片刚完成初始化时，还未配置相应的中断处理程序，因此需要将这个寄存器先设置为全1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断屏蔽寄存器初始化</span></span><br><span class="line">outb(PIC0_IMR, <span class="number">0xFF</span> &amp; ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>));  <span class="comment">// 不禁止来自IRQ2的中断信号，因为其用于连接从片</span></span><br><span class="line">outb(PIC1_IMR, <span class="number">0xFF</span>);</span><br></pre></td></tr></table></figure>

<h2 id="4-10-中断的打开与关闭"><a href="#4-10-中断的打开与关闭" class="headerlink" title="4.10 中断的打开与关闭"></a>4.10 中断的打开与关闭</h2><p>中断的打开与关闭受制于两个配置：</p>
<ol>
<li><code>EFLAGS</code>的<code>IF</code>标志位；</li>
<li><code>8259</code>的<code>IMR</code>寄存器。</li>
</ol>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131933225.png" width="400"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131920596.png" width="400"/>    
</center>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> mask = inb(PIC0_IMR) &amp; ~(<span class="number">1</span> &lt;&lt; irq_num);</span><br><span class="line"><span class="type">uint8_t</span> mask = inb(PIC0_IMR) | (<span class="number">1</span> &lt;&lt; irq_num);</span><br></pre></td></tr></table></figure>

<p><strong>分别做了什么操作？</strong></p>
<p>这两行代码分别对 PIC0 的中断屏蔽寄存器（PIC0_IMR）进行了修改操作：</p>
<ol>
<li><code>uint8_t mask = inb(PIC0_IMR) &amp; ~(1 &lt;&lt; irq_num);</code><ul>
<li>这行代码首先读取了 PIC0_IMR 寄存器的当前值，使用 <code>inb</code> 函数。</li>
<li>然后，它通过 <code>(1 &lt;&lt; irq_num)</code> 生成了一个只有第 <code>irq_num</code> 位为 0，其它位为 1 的屏蔽码。</li>
<li>最后，通过 <code>&amp;</code> 操作符，将读取的值与生成的屏蔽码进行按位与操作，将指定的中断号 <code>irq_num</code> 对应的位清零。</li>
<li>最终结果存储在 <code>mask</code> 变量中。</li>
</ul>
</li>
<li><code>uint8_t mask = inb(PIC0_IMR) | (1 &lt;&lt; irq_num);</code><ul>
<li>这行代码也是首先读取了 PIC0_IMR 寄存器的当前值，使用 <code>inb</code> 函数。</li>
<li>然后，它通过 <code>(1 &lt;&lt; irq_num)</code> 生成了一个只有第 <code>irq_num</code> 位为 1，其它位为 0 的屏蔽码。</li>
<li>最后，通过 <code>|</code> 操作符，将读取的值与生成的屏蔽码进行按位或操作，将指定的中断号 <code>irq_num</code> 对应的位设置为 1。</li>
<li>最终结果存储在 <code>mask</code> 变量中。</li>
</ul>
</li>
</ol>
<p>这两行代码的目的是对指定的中断号 <code>irq_num</code> 进行屏蔽或解除屏蔽操作，以控制该中断是否被响应。</p>
<h2 id="4-11-启动定时器并打开中断"><a href="#4-11-启动定时器并打开中断" class="headerlink" title="4.11 启动定时器并打开中断"></a>4.11 启动定时器并打开中断</h2><blockquote>
<p>参考资料</p>
<ul>
<li>《8259.pdf》</li>
<li><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Programmable_Interval_Timer">osdev关于8253的文档</a></li>
<li><a target="_blank" rel="noopener" href="http://www.osdever.net/bkerndev/Docs/pit.htm">关于8253配置的文档</a></li>
<li>《LINUX内核完全剖析:基于0.12内核》第316页</li>
</ul>
</blockquote>
<p>示例：外部中断的产生，以及如何跳转到对应的中断处理程序中。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405132011988.png" alt="image-20240513201126601"></p>
<ul>
<li><p>8253芯片是一个可编程的计时器&#x2F;计数器芯片，它有三个独立的计时器&#x2F;计数器通道（定时器0、定时器1和定时器2）。</p>
<ol>
<li><strong>定时器0</strong>：主要用于系统时钟中断，即产生系统时钟滴答，用于操作系统的时钟中断。这是确保操作系统能够定期执行任务调度和其他定时任务的关键。</li>
<li><strong>定时器1</strong>：通常用于动态内存刷新，但在现代系统中，这一功能已经被集成到内存控制器中，定时器1基本上已经不再使用。</li>
<li><strong>定时器2</strong>：常用于扬声器的声音发生。在大多数系统中，如果没有特别的需求，也不需要初始化定时器2。</li>
</ol>
</li>
<li><p>定时器0的初始化原因</p>
<ul>
<li><p>系统时钟中断：操作系统依赖于系统时钟中断来管理时间和任务调度。通过定时器0，操作系统可以产生定时中断（通常是每秒多次），以进行以下任务：</p>
<ul>
<li><p><strong>任务调度</strong>：定时中断使得操作系统能够在多任务环境中切换任务。</p>
</li>
<li><p><strong>系统时间更新</strong>：维护系统的时间和日期。</p>
</li>
<li><p><strong>超时处理</strong>：处理某些操作的超时功能。</p>
</li>
</ul>
</li>
<li><p>通常的配置方式：初始化定时器0时，设置它为重复模式（模式3，即方波模式），并指定合适的计数值，以产生所需频率的中断。例如，如果需要每秒产生100个中断（100Hz），则可以根据时钟频率和目标频率计算合适的计数值。</p>
</li>
</ul>
</li>
<li><p>初始化定时器0的步骤</p>
<p><strong>本项目中，只需要一个可以周期性产生中断的定时器，无需考虑各种硬件方面的东西。</strong>因此，只需要将定时器设置成自动周期性触发中断即可，而模式<code>3</code>可以方便的实现此功能，因此选用的模式<code>3</code>其它模式较为复杂，有的需要和硬件配合，有的需要在中断中重新配置定时器，所以没有使用这些模式。</p>
</li>
</ul>
<p><code>8253</code>端口地址与说明</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405140922412.png" alt="image-20240514092203861"></p>
<blockquote>
<p>（注：无论是手册上还是各种资料上关于工作模式都讲得过细，特别是有些资料还讲了一些<code>8253</code>硬件输出信号的问题。这些与我们的操作系统设计没什么关系，不用看，直接跳过即可。)</p>
</blockquote>
<ul>
<li><p>定时器工作原理</p>
<p>8253&#x2F;8254定时器芯片的工作原理是基于一个固定频率的晶体振荡器（例如1193182 Hz）。该芯片有三个独立的计数器，每个计数器都有一个初始计数值，从这个值开始<strong>倒计时</strong>。倒计时完成后，计数器会溢出，触发一个中断或者在输出引脚上产生一个信号。</p>
</li>
<li><p>初始计数值的作用</p>
<ul>
<li>控制中断频率</li>
</ul>
<ul>
<li><p>通过设置不同的初始计数值，可以控制定时器的中断频率。初始计数值越大，倒计时的时间越长，生成中断的频率就越低。反之，初始计数值越小，倒计时的时间越短，生成中断的频率就越高。</p>
</li>
<li><p>具体来说，计数器的倒计时周期是晶体振荡器周期和初始计数值的乘积。假设晶体振荡器频率为<code>1193182 Hz</code>，初始计数值为计数器倒计时的周期数，那么<code>中断频率（Hz） = 振荡器频率（Hz） / 初始计数值</code>。</p>
</li>
</ul>
</li>
<li><p>计算初始计数值</p>
<p>假设我们想设置定时器<code>0</code>生成每秒<code>100</code>次的中断（即中断频率为<code>100 Hz</code>），我们需要计算初始计数值如下：</p>
<p><code>初始计数值=振荡器频率/中断频率=1193182/100=11931</code></p>
<p>这意味着，我们将定时器<code>0</code>的初始计数值设置为<code>11931</code>，它将在每经过<code>11931</code>个时钟周期后触发一次中断，产生<code>100 Hz</code>的中断频率。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception_handler time, 0x20, 0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>0x20</code>：将<code>8253</code>芯片关联到<code>8259</code>的<code>IRQ0</code>端口，而<code>8259</code>的起始地址为<code>0x20</code>。</li>
</ul>
<h1 id="五、日志与printf格式化输出"><a href="#五、日志与printf格式化输出" class="headerlink" title="五、日志与printf格式化输出"></a>五、日志与printf格式化输出</h1><h2 id="5-1-创建日志打印接口"><a href="#5-1-创建日志打印接口" class="headerlink" title="5.1 创建日志打印接口"></a>5.1 创建日志打印接口</h2><p><strong>在操作系统内核中编写日志接口时，通常不使用C库自带的<code>printf</code>函数。</strong>这是由于以下几个关键原因：</p>
<ol>
<li><p><strong>依赖性和可移植性</strong></p>
<ul>
<li><p><strong>标准库依赖性</strong>：<code>printf</code>是标准C库的一部分，它依赖于操作系统提供的底层设施（如文件系统、IO设备、内存管理等）。在操作系统内核早期启动阶段，这些设施可能尚未初始化。</p>
</li>
<li><p><strong>可移植性问题</strong>：不同的标准库实现可能有所不同，在某些平台上，标准库可能并不适用于内核空间。</p>
</li>
</ul>
</li>
<li><p><strong>内核空间和用户空间的区别</strong></p>
<ul>
<li><p><strong>内核空间和用户空间</strong>：标准库函数如<code>printf</code>通常在用户空间中运行，而操作系统内核运行在特权的内核空间。内核代码需要直接访问硬件和内存管理，这些功能在用户空间的标准库中不可用。</p>
</li>
<li><p><strong>上下文切换</strong>：使用标准库函数可能会引起不必要的上下文切换和中断，这在内核模式下可能是不允许的或是效率低下的。</p>
</li>
</ul>
</li>
<li><p><strong>资源管理</strong></p>
<ul>
<li><p><strong>内存管理</strong>：内核必须处理自己的内存分配和管理，而标准C库中的<code>printf</code>会隐含地调用一些内存管理函数，这可能与内核的内存管理机制冲突。</p>
</li>
<li><p><strong>线程安全性</strong>：<code>printf</code>在多线程环境下的行为在内核中可能不可靠，因为内核需要处理并发性和同步问题。</p>
</li>
</ul>
</li>
<li><p><strong>性能和实时性要求</strong></p>
<ul>
<li><p><strong>性能</strong>：内核态代码通常需要高效和快速地执行，标准库的<code>printf</code>包含复杂的格式解析和输出操作，这可能带来不必要的性能开销。</p>
</li>
<li><p><strong>实时性</strong>：内核中某些操作需要实时响应，而<code>printf</code>的执行时间不可预测，这可能导致内核无法满足实时性要求。</p>
</li>
</ul>
</li>
<li><p><strong>调试和错误处理</strong></p>
<ul>
<li><p><strong>错误处理</strong>：内核需要处理低级错误，而<code>printf</code>可能引入新的故障点。例如，<code>printf</code>依赖的某些资源在内核执行时不可用或已被其他部分使用。</p>
</li>
<li><p><strong>调试支持</strong>：在内核开发过程中，使用自定义的日志函数可以提供更多控制和定制，便于内核态调试和问题追踪。</p>
</li>
</ul>
</li>
</ol>
<h2 id="5-2-实现基本的信息输出"><a href="#5-2-实现基本的信息输出" class="headerlink" title="5.2 实现基本的信息输出"></a>5.2 实现基本的信息输出</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405141437793.png" alt="image-20240514143659706"></p>
<p>在以前的计算机中有一个<code>9</code>针的串行接口<code>RS-232</code>，有两根数据线，双向通信，分别用于发送和接收数据。<strong>在本项目中会用到这个接口来实现数据的发送的接收。</strong></p>
<p>虽然现在的计算机上没有这种接口了，但是<code>QEMU</code>依然支持这种接口。选择<code>[view-&gt;serial0]</code>，则会连接到串行接口，并将串行接口发出的数据显示到此处，而不是显示在显示器上。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405141441877.png" alt="image-20240514144102736"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm/cpu_instr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM1_PORT 0x3F8     <span class="comment">// 串行接口初始地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 日志初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化串行接口，无需了解细节</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">1</span>, <span class="number">0x00</span>);  <span class="comment">// 关闭串行接口相关中断</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">3</span>, <span class="number">0x80</span>);  <span class="comment">// 数据发送速度</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">0</span>, <span class="number">0x3</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">1</span>, <span class="number">0x00</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">3</span>, <span class="number">0x03</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">2</span>, <span class="number">0xc7</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">4</span>, <span class="number">0x0F</span>);</span><br><span class="line">&#125;                  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数可变的打印模版函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = fmt;</span><br><span class="line">    <span class="comment">// 打印fmt相关内容</span></span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 串行接口忙检测</span></span><br><span class="line">        <span class="keyword">while</span> ((inb(COM1_PORT + <span class="number">5</span>) &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>)) == <span class="number">0</span>);        </span><br><span class="line">        outb(COM1_PORT, *p++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="5-3-实现字符串的格式化输出"><a href="#5-3-实现字符串的格式化输出" class="headerlink" title="5.3 实现字符串的格式化输出"></a>5.3 实现字符串的格式化输出</h2><h3 id="1、字符串的常规处理"><a href="#1、字符串的常规处理" class="headerlink" title="1、字符串的常规处理"></a>1、字符串的常规处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _KLIB_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _KLIB_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm/types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_strcopy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_strncopy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">void</span> *src, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_memset</span><span class="params">(<span class="type">void</span> *dest, <span class="type">uint8_t</span> v, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_memcmp</span><span class="params">(<span class="type">void</span> *d1, <span class="type">void</span> *d2, <span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _KLIB_H_</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2、字符串的格式化输出"><a href="#2、字符串的格式化输出" class="headerlink" title="2、字符串的格式化输出"></a>2、字符串的格式化输出</h3><ol>
<li><p><strong>枚举类型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>NORMAL, READ_FMT&#125; state = NORMAL;</span><br></pre></td></tr></table></figure>

<p>定义一个无名枚举类型，包含两个状态 <code>NORMAL</code> 和 <code>READ_FMT</code>，并将 <code>state</code> 变量初始化为 <code>NORMAL</code>。</p>
</li>
<li><p><strong>可变参数函数</strong><br>在 C 语言中，可以定义一个函数，使其接受可变数量的参数。这些函数通常使用 <code>&lt;stdarg.h&gt;</code> 中的宏来处理可变参数。下面是一些相关的宏：</p>
<ul>
<li><p><code>va_list</code>：声明一个变量，该变量用于访问可变参数列表。</p>
</li>
<li><p><code>va_start</code>：初始化一个 <code>va_list</code> 变量，使其指向第一个可变参数。</p>
</li>
<li><p><code>va_end</code>：清理 <code>va_list</code> 变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">va_list args;  <span class="comment">// 声明va_list变量</span></span><br><span class="line">va_start(args, fmt);  <span class="comment">// 指向第一个可变参数</span></span><br><span class="line">va_end(args);  <span class="comment">// 释放args</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>va_arg</code>：获取可变参数列表中的下一个参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *str = va_arg(args, <span class="type">char</span> *);</span><br><span class="line"><span class="comment">// 第一个参数是va_list变量</span></span><br><span class="line"><span class="comment">// 第二个参数是期望的参数类型</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    num = 12345 -&gt; 10</span></span><br><span class="line"><span class="comment">    1. 12345 % 10 = 5   12345 / 10 = 1234</span></span><br><span class="line"><span class="comment">    2. 1234  % 10 = 4   1234  / 10 = 123</span></span><br><span class="line"><span class="comment">    3. 123   % 10 = 3   123   / 10 = 12</span></span><br><span class="line"><span class="comment">    4. 12    % 10 = 2   12    / 10 = 1</span></span><br><span class="line"><span class="comment">    5. 1     % 10 = 1   1     / 10 = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_itoa</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> num, <span class="type">int</span> base)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *num2ch = &#123;<span class="string">&quot;0123456789ASBCDEF&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *p = buf;</span><br><span class="line">    <span class="type">int</span> is_negative = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅处理2/8/10/16进制</span></span><br><span class="line">    <span class="keyword">if</span> ((base != <span class="number">2</span>) &amp;&amp; (base != <span class="number">8</span>) &amp;&amp; (base != <span class="number">10</span>) &amp;&amp; (base != <span class="number">16</span>)) &#123;</span><br><span class="line">        *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若为负数，则添加负号</span></span><br><span class="line">    <span class="keyword">if</span> ((num &lt; <span class="number">0</span>) &amp;&amp; (base == <span class="number">10</span>)) &#123;</span><br><span class="line">        is_negative = <span class="number">1</span>;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// num to string</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">char</span> ch = num2ch[num % base];</span><br><span class="line">        *p++ = ch;</span><br><span class="line">        num /= base;       </span><br><span class="line">    &#125;<span class="keyword">while</span> (num);</span><br><span class="line">    <span class="keyword">if</span> (is_negative) &#123;</span><br><span class="line">        *p++ = <span class="string">&#x27;-&#x27;</span>;  <span class="comment">// 若为负数，添加负号，注意放到最后以便后续进行翻转</span></span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转字符串</span></span><br><span class="line">    <span class="type">char</span> *start = buf;</span><br><span class="line">    <span class="type">char</span> *end = p - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> ch = *start;</span><br><span class="line">        *start = *end;</span><br><span class="line">        *end = ch;</span><br><span class="line"></span><br><span class="line">        end--;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_printf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理可变字符串</span></span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);  </span><br><span class="line">    kernel_vsprintf(buf, fmt, args);</span><br><span class="line">    va_end(args);  <span class="comment">// 释放args</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;Version: %s&quot;, &quot;1.0.0&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span> &#123;</span><br><span class="line">    <span class="comment">// NORMAL：原样输出状态  READ_FMT：格式化输出状态</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>NORMAL, READ_FMT&#125; state = NORMAL;</span><br><span class="line">    <span class="type">char</span> *curr = buf;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = *fmt++)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (state)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> NORMAL:</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">                state = READ_FMT;  <span class="comment">// 当遇到&#x27;%&#x27;时需要切换到格式化输出状态</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *curr++ = ch;   <span class="comment">// 否则直接原样输出即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> READ_FMT:</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;d&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> num = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                kernel_itoa(curr, num, <span class="number">10</span>);  <span class="comment">// int型变量转换为ASCII码对应的字符串</span></span><br><span class="line">                curr += kernel_strlen(curr);  <span class="comment">// curr进行跳转</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> num = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                kernel_itoa(curr, num, <span class="number">16</span>);  <span class="comment">// int型变量转换为ASCII码对应的字符串</span></span><br><span class="line">                curr += kernel_strlen(curr);  <span class="comment">// curr进行跳转</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">char</span> c = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                *curr++ = c;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *str = va_arg(args, <span class="type">char</span> *);  <span class="comment">// 此时const char *str = &quot;1.0.0&quot;</span></span><br><span class="line">                <span class="type">int</span> len = kernel_strlen(str);</span><br><span class="line">                <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">                    *curr++ = *str++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state = NORMAL;  <span class="comment">// 处理完可变参数，切换回NORMAL状态</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-利用assert辅助调试"><a href="#5-4-利用assert辅助调试" class="headerlink" title="5.4 利用assert辅助调试"></a>5.4 利用assert辅助调试</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RELEASE  <span class="comment">// 若未定义RELEASE版本，说明在调试状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(expr)    \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!(expr)) pannic(__FILE__, __LINE__, __func__, #expr);</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pannic</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span> *func, <span class="type">const</span> <span class="type">char</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(expr)    ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="六、实现简单的进程切换"><a href="#六、实现简单的进程切换" class="headerlink" title="六、实现简单的进程切换"></a>六、实现简单的进程切换</h1><h2 id="6-1-添加任务状态段"><a href="#6-1-添加任务状态段" class="headerlink" title="6.1 添加任务状态段"></a>6.1 添加任务状态段</h2><p><strong>目前的代码中，中断处理程序处理中断相关的工作，主程序负责执行所有其它工作</strong>（仅考虑只有一个CPU内核的情况）。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142022102.png" alt="image-20240514202203665" style="zoom: 50%;" />

<p>借助于操作系统的进程切换机制，我们可以同时运行多个程序。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142023040.png" alt="image-20240514202342715" style="zoom:50%;" />

<p>现在考虑实现这样一个任务，即利用进程切换机制，同时实现以下两个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;init task: %d&quot;</span>, count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a = 3 / 0;</span></span><br><span class="line">    <span class="comment">// irq_enable_global();</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;init main: %d&quot;</span>, count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、理论基础-8"><a href="#1、理论基础-8" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>操作系统为了让CPU能够同时执行多个程序，在切换到另一个程序运行前需要<strong>记录当前程序的运行状态</strong>。<br>这样当程序再次运行时，才能够恢复到之前的运行状态。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142039947.png" alt="image-20240514203914718" style="zoom:50%;" />

<ul>
<li><code>TSS/Task-State Segment</code>：保存当前程序的运行状态。（用<code>Task</code>表示进程的运行状态）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142038829.png" alt="image-20240514203814450"></p>
<h3 id="2、TSS定义"><a href="#2、TSS定义" class="headerlink" title="2、TSS定义"></a>2、TSS定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TSS/Task-State Segment r 任务状态段</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tss_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> pre_link;      <span class="comment">// 上一个任务链接</span></span><br><span class="line">    <span class="type">uint32_t</span> esp0, ss0;     <span class="comment">// 内核模式下的栈指针和栈段选择子</span></span><br><span class="line">    <span class="type">uint32_t</span> esp1, ss1;     <span class="comment">// 备用栈指针和栈段选择子（通常不使用）</span></span><br><span class="line">    <span class="type">uint32_t</span> esp2, ss2;     <span class="comment">// 备用栈指针和栈段选择子（通常不使用）</span></span><br><span class="line">    <span class="type">uint32_t</span> cr3;           <span class="comment">// 页目录基地址寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> eip;           <span class="comment">// 指令指针寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> eflags;        <span class="comment">// 标志寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi; <span class="comment">// 通用寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> es, cs, ss, ds, fs, gs; <span class="comment">// 段寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> ldt;           <span class="comment">// 局部描述符表的段选择子</span></span><br><span class="line">    <span class="type">uint32_t</span> iomap;         <span class="comment">// I/O许可位图的基地址</span></span><br><span class="line">&#125;<span class="type">tss_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>TSS</code>如何描述任务状态？</p>
<ul>
<li><p><code>TSS</code>中各字段的分类</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142050761.png" alt="image-20240514205059174"></p>
</li>
<li><p>程序的运行状态，包含了诸多信息：</p>
<ul>
<li>当前正执行哪些代码、有哪些数据、使用了哪块区域做堆栈、当前执行指令的地址、前一指令的运行状态、运算所用的寄存器信息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142057431.png" alt="image-20240514205712046"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142115267.png" alt="image-20240514211539824"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142117502.png" alt="image-20240514211733961"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142118228.png" alt="image-20240514211833645"></p>
</li>
</ul>
<h2 id="6-2-任务的简单初始化"><a href="#6-2-任务的简单初始化" class="headerlink" title="6.2 任务的简单初始化"></a>6.2 任务的简单初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> *      TSS Initialization </span></span><br><span class="line"><span class="comment"> *      当有程序/进程第一次运行时会调用tss_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tss_init</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    kernel_memset(&amp;task-&gt;tss, <span class="number">0</span>, <span class="keyword">sizeof</span>(task-&gt;tss));</span><br><span class="line">    task-&gt;tss.eip = entry;  <span class="comment">// 调用tss_init的函数的入口地址（该函数第一次运行）</span></span><br><span class="line">    task-&gt;tss.esp = task-&gt;tss.esp0 = esp;  <span class="comment">// 指示调用tss_init的函数的栈顶的位置（此时栈为空）</span></span><br><span class="line">    task-&gt;tss.ss = task-&gt;tss.ss0 = KERNEL_SELECTOR_DS;  <span class="comment">// 由于第一次运行，因此寄存器设置为默认的选择子</span></span><br><span class="line">    task-&gt;tss.es = task-&gt;tss.ds = task-&gt;tss.fs = task-&gt;tss.gs = KERNEL_SELECTOR_DS;</span><br><span class="line">    task-&gt;tss.cs = KERNEL_SELECTOR_CS;</span><br><span class="line">    task-&gt;tss.eflags = EFLAGS_DEFAULT | EFLAGS_IF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task Initializtion */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ASSERT((task != (<span class="type">task_t</span> *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    tss_init(task, entry, esp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-简单双任务相互切换"><a href="#6-3-简单双任务相互切换" class="headerlink" title="6.3 简单双任务相互切换"></a>6.3 简单双任务相互切换</h2><h3 id="1、理论"><a href="#1、理论" class="headerlink" title="1、理论"></a>1、理论</h3><p><code>x86</code>硬件对于任务的管理包括：</p>
<ul>
<li><code>Task Register/TR寄存器</code>：保存了<code>Task</code>相关的选择子</li>
<li><code>TSS</code>描述符：<code>GDT</code>表中的<code>TSS Desc</code>表项，每个<code>TSS</code>有自己对应的描述符</li>
<li><code>TSS</code></li>
<li>任务的代码、数据和栈空间</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405150949978.png" alt="image-20240515094947839"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405150958664.png" alt="image-20240515095802569"></p>
<h3 id="2、采用JMP进行任务切换"><a href="#2、采用JMP进行任务切换" class="headerlink" title="2、采用JMP进行任务切换"></a>2、采用JMP进行任务切换</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151000598.png" alt="image-20240515100023458" style="zoom:50%;" />

<blockquote>
<p>解答一下<code>task init(&amp;first task,0,0)</code>两个参数为<code>0</code>的问题：由于<code>first task</code>在<code>kernel</code>跑起来后已经运行，因此并不需要从<code>tss</code>中加载初始化的值，所以里面的值无所谓，并且在后面切换到<code>init task</code>时会因保存状态而被改写。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">task_t</span> sub_task;</span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> first_task;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> init_task_stack[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;sub task: %d&quot;</span>, count++);</span><br><span class="line">        task_switch_from_to(&amp;sub_task, &amp;first_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a = 3 / 0;</span></span><br><span class="line">    <span class="comment">// irq_enable_global();</span></span><br><span class="line">    task_init(&amp;sub_task, (<span class="type">uint32_t</span>)init_task_entry, (<span class="type">uint32_t</span>)&amp;init_task_stack[<span class="number">1024</span>]);</span><br><span class="line">    task_init(&amp;first_task, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// ?-&gt;看上面的引用部分，有相关解释</span></span><br><span class="line">    write_tr(first_task.tss_sel);  <span class="comment">// 对TR寄存器初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;main task: %d&quot;</span>, count++);</span><br><span class="line">        task_switch_from_to(&amp;first_task, &amp;sub_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Task Switch */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_switch_from_to</span> <span class="params">(<span class="type">task_t</span> *from, <span class="type">task_t</span> *to)</span> &#123;</span><br><span class="line">    switch_to_tss(to-&gt;tss_sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 远跳转实现任务切换 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">switch_to_tss</span> <span class="params">(<span class="type">int</span> tss_sel)</span> &#123;</span><br><span class="line">    far_jump(tss_sel, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-4-另一种任务切换方式"><a href="#6-4-另一种任务切换方式" class="headerlink" title="6.4 另一种任务切换方式"></a>6.4 另一种任务切换方式</h2><h3 id="1、理论基础-9"><a href="#1、理论基础-9" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p>任务切换的本质是保存前一任务的运行状态，恢复下一任务的运行状态。</p>
</blockquote>
<p>硬件实际上会帮助我们去自动保存这些状态，但是如果采用手动保存的方式，切换会更快。</p>
<p>需要保存的状态如下。<strong>可以为这些状态单独设置空间保存，也可以直接将其保存在任务自己的栈中。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151054801.png" alt="image-20240515105445584" style="zoom:50%;" />

<p>当然，对于上述状态也可以进行选择性保存：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151058922.png" alt="image-20240515105836713"></p>
<p>因此，最终只需要保存少量的寄存器就可以实现任务切换：</p>
<ul>
<li>注意<code>esp</code>指示此处的栈顶位置，因此要在别处单独存放。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151454378.png" alt="image-20240515145411029" style="zoom:50%;" />

<h3 id="2、代码实现-1"><a href="#2、代码实现-1" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述程序/进程运行状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>    *<span class="built_in">stack</span>;     <span class="comment">// 当前Task的任务栈</span></span><br><span class="line">    <span class="type">tss_t</span>       tss;        <span class="comment">// TSS段</span></span><br><span class="line">    <span class="type">int</span>         tss_sel;    <span class="comment">// Task Selector</span></span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel-&gt;init-&gt;init.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> sub_task;</span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> first_task;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> init_task_stack[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;sub task: %d&quot;</span>, count++);</span><br><span class="line">        task_switch_from_to(&amp;sub_task, &amp;first_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a = 3 / 0;</span></span><br><span class="line">    <span class="comment">// irq_enable_global();</span></span><br><span class="line">    task_init(&amp;sub_task, (<span class="type">uint32_t</span>)init_task_entry, (<span class="type">uint32_t</span>)&amp;init_task_stack[<span class="number">1024</span>]);</span><br><span class="line">    task_init(&amp;first_task, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    write_tr(first_task.tss_sel);  <span class="comment">// 对TR寄存器初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;main task: %d&quot;</span>, count++);</span><br><span class="line">        task_switch_from_to(&amp;first_task, &amp;sub_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel-&gt;core-&gt;task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task Initializtion */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ASSERT((task != (<span class="type">task_t</span> *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tss_init(task, entry, esp);</span></span><br><span class="line">    <span class="type">uint32_t</span> *pesp = (<span class="type">uint32_t</span> *)esp;  <span class="comment">// 取出当前栈顶指针</span></span><br><span class="line">    <span class="keyword">if</span> (pesp) &#123;  </span><br><span class="line">        <span class="comment">// 将任务入口地址入栈</span></span><br><span class="line">        *(--pesp) = entry;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置edi, esi, ebx, ebp</span></span><br><span class="line">        *(--pesp) = <span class="number">0</span>;</span><br><span class="line">        *(--pesp) = <span class="number">0</span>;</span><br><span class="line">        *(--pesp) = <span class="number">0</span>;</span><br><span class="line">        *(--pesp) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前栈指针保存到任务结构体中</span></span><br><span class="line">        task-&gt;<span class="built_in">stack</span> = pesp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      **from      指向[当前任务的栈指针]的指针</span></span><br><span class="line"><span class="comment"> *      *to         指向[新任务]的栈指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">simple_switch</span> <span class="params">(<span class="type">uint32_t</span> **from, <span class="type">uint32_t</span> *to)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task Switch */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_switch_from_to</span> <span class="params">(<span class="type">task_t</span> *from, <span class="type">task_t</span> *to)</span> &#123;</span><br><span class="line">    <span class="comment">// switch_to_tss(to-&gt;tss_sel);</span></span><br><span class="line">    simple_switch(&amp;from-&gt;<span class="built_in">stack</span>, to-&gt;<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">simple_switch:</span><br><span class="line">    # 向当前Task对应的栈压栈</span><br><span class="line">    mov 4(%esp), %eax    # 将当前任务的栈指针地址（**from）传递给eax</span><br><span class="line">    mov 8(%esp), %edx    # 将下一个任务的栈指针地址（*to）传递给edx</span><br><span class="line"></span><br><span class="line">    push %ebp            # 保存当前任务的ebp寄存器</span><br><span class="line">    push %ebx            # 保存当前任务的ebx寄存器</span><br><span class="line">    push %esi            # 保存当前任务的esi寄存器</span><br><span class="line">    push %edi            # 保存当前任务的edi寄存器</span><br><span class="line"></span><br><span class="line">    # 从另一个任务的栈中出栈</span><br><span class="line">    mov %esp, (%eax)     # 保存当前任务的esp到eax指向的内存中（保存当前任务的栈指针）</span><br><span class="line">    mov %edx, %esp       # 切换到下一个任务的栈指针（esp指向新任务的栈顶）</span><br><span class="line">    pop %edi             # 恢复下一个任务的edi寄存器</span><br><span class="line">    pop %esi             # 恢复下一个任务的esi寄存器</span><br><span class="line">    pop %ebx             # 恢复下一个任务的ebx寄存器</span><br><span class="line">    pop %ebp             # 恢复下一个任务的ebp寄存器</span><br><span class="line"></span><br><span class="line">    ret                  # 返回，切换到下一个任务的执行</span><br></pre></td></tr></table></figure>

<h1 id="七、实现链表数据结构"><a href="#七、实现链表数据结构" class="headerlink" title="七、实现链表数据结构"></a>七、实现链表数据结构</h1><h2 id="7-1-定义结点和链表"><a href="#7-1-定义结点和链表" class="headerlink" title="7.1 定义结点和链表"></a>7.1 定义结点和链表</h2><p>在进程运行过程中，可能因为多种原因需要等待，从而加入相应的等待队列中。如下图共有三个队列，其中就绪队列中的进程已经准备好了，随时可以运行，只是在等待处理器空闲。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151550561.png" alt="image-20240515155011285" style="zoom:50%;" />

<p>考虑到系统中可能有很多进程，因此采用链表结构进行管理。</p>
<img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240515155549617.png" alt="image-20240515155549617" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list_node_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">list_node_t</span> *<span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">list_node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;<span class="type">list_node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_node_init</span> <span class="params">(<span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    node-&gt;pre = node-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">list_node_t</span> *<span class="title function_">list_node_pre</span> <span class="params">(<span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">list_node_t</span> *<span class="title function_">list_node_next</span> <span class="params">(<span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list_t</span> &#123;</span></span><br><span class="line">    <span class="type">list_node_t</span> *first;</span><br><span class="line">    <span class="type">list_node_t</span> *last;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;<span class="type">list_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_init</span> <span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-链表的两种插入"><a href="#7-2-链表的两种插入" class="headerlink" title="7.2 链表的两种插入"></a>7.2 链表的两种插入</h2><h3 id="1、头插"><a href="#1、头插" class="headerlink" title="1、头插"></a>1、头插</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151634229.png" alt="image-20240515163412939" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头插</span></span><br><span class="line"><span class="comment"> * @param list 待插入的链表</span></span><br><span class="line"><span class="comment"> * @param node 待插入的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_first</span><span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>, <span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置node</span></span><br><span class="line">    node-&gt;next = <span class="built_in">list</span>-&gt;first;</span><br><span class="line">    node-&gt;pre = (<span class="type">list_node_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list_is_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">        <span class="comment">// 若list为空，则first &amp; last均指向node</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;last = <span class="built_in">list</span>-&gt;first = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，仅调整first指向</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;first-&gt;pre = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;first = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、尾插"><a href="#2、尾插" class="headerlink" title="2、尾插"></a>2、尾插</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151730245.png" alt="image-20240515173058966" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾插</span></span><br><span class="line"><span class="comment"> * @param list 操作的链表</span></span><br><span class="line"><span class="comment"> * @param node 待插入的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_last</span><span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>, <span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置node</span></span><br><span class="line">    node-&gt;pre = <span class="built_in">list</span>-&gt;last;</span><br><span class="line">    node-&gt;next = (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list_is_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">        <span class="comment">// 若list为空，则first &amp; last均指向node</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;first = <span class="built_in">list</span>-&gt;last = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，仅调整last指向</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;last-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;last = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-链表的两种删除"><a href="#7-3-链表的两种删除" class="headerlink" title="7.3 链表的两种删除"></a>7.3 链表的两种删除</h2><h3 id="1、头删"><a href="#1、头删" class="headerlink" title="1、头删"></a>1、头删</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151731170.png" alt="image-20240515173113880" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头删</span></span><br><span class="line"><span class="comment"> * @param list 操作的链表</span></span><br><span class="line"><span class="comment"> * @return 链表的第一个结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">list_node_t</span>* <span class="title function_">list_remove_first</span><span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// list为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (list_is_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取要删除的结点</span></span><br><span class="line">    <span class="type">list_node_t</span> * remove_node = <span class="built_in">list</span>-&gt;first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改first指向</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;first = remove_node-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;first == (<span class="type">list_node_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 若list为空，修改last也指向空</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;last = (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若list非空，修改当前first的前驱为0</span></span><br><span class="line">        remove_node-&gt;next-&gt;pre = (<span class="type">list_node_t</span> *)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改node的pre和next为0</span></span><br><span class="line">    remove_node-&gt;next = remove_node-&gt;pre = (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;count--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> remove_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、删除任意结点"><a href="#2、删除任意结点" class="headerlink" title="2、删除任意结点"></a>2、删除任意结点</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151731210.png" alt="image-20240515173125900" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除任意结点，但不检查node是否在list中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">list_node_t</span> * <span class="title function_">list_remove</span><span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>, <span class="type">list_node_t</span> *remove_node)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是头，则头往前移</span></span><br><span class="line">    <span class="keyword">if</span> (remove_node == <span class="built_in">list</span>-&gt;first) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;first = remove_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是尾，则尾往回移</span></span><br><span class="line">    <span class="keyword">if</span> (remove_node == <span class="built_in">list</span>-&gt;last) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;last = remove_node-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有前，则调整前的后继</span></span><br><span class="line">    <span class="keyword">if</span> (remove_node-&gt;pre) &#123;</span><br><span class="line">        remove_node-&gt;pre-&gt;next = remove_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有后，则调整后的前驱</span></span><br><span class="line">    <span class="keyword">if</span> (remove_node-&gt;next) &#123;</span><br><span class="line">        remove_node-&gt;next-&gt;pre = remove_node-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空node指向</span></span><br><span class="line">    remove_node-&gt;pre = remove_node-&gt;next = (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line">    --<span class="built_in">list</span>-&gt;count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> remove_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-4-获取结点所在的结构"><a href="#7-4-获取结点所在的结构" class="headerlink" title="7.4 获取结点所在的结构"></a>7.4 获取结点所在的结构</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152028459.png" alt="image-20240515202836119"></p>
<p>对下图的解释：</p>
<p>比如说对于下图的<code>node</code>，要取其地址用到了<code>&amp;(a-&gt;node)</code>，这一行代码实际上是完成了<code>a的基地址+offset(node相对于基地址的offset)</code>这个操作。</p>
<p>因此，如果要求解这一段<code>offset</code>，就可以假定在最开始有一个和<code>node</code>同类型的数据，这样<code>a的基地址</code>这一项就为<code>0</code>，所以求解到的就是<code>offset</code>的值。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152033989.png" alt="image-20240515203321728"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offset_in_parent(parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    ((uint32_t)&amp;(((parent_type *)0)-&gt;node_name))</span></span><br><span class="line"><span class="comment">// parent_addr  --  parent的起始地址</span></span><br><span class="line"><span class="comment">// node         --  node的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> parent_addr(node, parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    (((uint32_t)node) -  offset_in_parent(parent_type, node_name))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_node_parent(node, parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    ((parent_type *)(node ? parent_addr(node, parent_type, node_name) : 0))</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>offset_in_parent</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offset_in_parent(parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    ((uint32_t)&amp;(((parent_type *)0)-&gt;node_name))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能</strong>：计算一个节点在其父结构体中的偏移量。</li>
<li>参数<ul>
<li><code>parent_type</code>：父结构体的类型。</li>
<li><code>node_name</code>：节点在父结构体中的成员变量名。</li>
</ul>
</li>
<li><strong>实现</strong>：通过将一个空指针类型转换为 <code>parent_type</code> 并访问 <code>node_name</code> 成员，然后取该成员的地址。由于起始地址为0，这样计算出的地址即为偏移量。</li>
</ul>
</li>
<li><p><strong>parent_addr</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> parent_addr(node, parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    (((uint32_t)node) - offset_in_parent(parent_type, node_name))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能</strong>：从节点地址推导出包含该节点的父结构体的地址。</li>
<li>参数<ul>
<li><code>node</code>：节点的地址。</li>
<li><code>parent_type</code>：父结构体的类型。</li>
<li><code>node_name</code>：节点在父结构体中的成员变量名。</li>
</ul>
</li>
<li><strong>实现</strong>：通过节点地址减去节点在父结构体中的偏移量来获取父结构体的地址。</li>
</ul>
</li>
<li><p><strong>list_node_parent</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_node_parent(node, parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    ((parent_type *)(node ? parent_addr(node, parent_type, node_name) : 0))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能</strong>：从节点地址安全地获取包含该节点的父结构体的地址。</li>
<li>参数<ul>
<li><code>node</code>：节点的地址。</li>
<li><code>parent_type</code>：父结构体的类型。</li>
<li><code>node_name</code>：节点在父结构体中的成员变量名。</li>
</ul>
</li>
<li><strong>实现</strong>：如果节点不为 <code>NULL</code>，则调用 <code>parent_addr</code> 宏；否则返回 <code>NULL</code>。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_test</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">list_t</span> <span class="built_in">list</span>;</span><br><span class="line">    <span class="type">list_node_t</span> nodes[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    list_init(&amp;<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">list_node_t</span> *node = nodes + i;</span><br><span class="line">        log_printf(<span class="string">&quot;insert first to list: %d, 0x%x&quot;</span>, i, (<span class="type">uint32_t</span>)node);</span><br><span class="line">        list_insert_first(&amp;<span class="built_in">list</span>, node);</span><br><span class="line">    &#125;</span><br><span class="line">    log_printf(<span class="string">&quot;list: first=0x%x, last=0x%x, count=%d&quot;</span>,</span><br><span class="line">        list_first(&amp;<span class="built_in">list</span>), list_last(&amp;<span class="built_in">list</span>), list_count(&amp;<span class="built_in">list</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type_t</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">list_node_t</span> node;</span><br><span class="line">    &#125;v = &#123;<span class="number">0x123456</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type_t</span> *<span class="title">a</span> =</span> (<span class="keyword">struct</span> <span class="type">type_t</span> *)<span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> addr = (<span class="type">uint32_t</span>)&amp;a-&gt;node;  <span class="comment">// 4                        </span></span><br><span class="line">    <span class="type">uint32_t</span> addr_p = offset_in_parent(<span class="keyword">struct</span> <span class="type">type_t</span>, node);  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已知node的起始地址，利用定义的宏求解v的起始地址</span></span><br><span class="line">    <span class="type">list_node_t</span> *v_node = &amp;v.node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type_t</span> *<span class="title">p</span> =</span> list_node_parent(v_node, <span class="keyword">struct</span> <span class="type">type_t</span>, node);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;i != <span class="number">0x123456</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、进程的管理与延时"><a href="#八、进程的管理与延时" class="headerlink" title="八、进程的管理与延时"></a>八、进程的管理与延时</h1><h2 id="8-1-添加任务管理器"><a href="#8-1-添加任务管理器" class="headerlink" title="8.1 添加任务管理器"></a>8.1 添加任务管理器</h2><p>截止目前，只支持两个任务，切需要进程自己主动切换，不支持延时等功能。因此需要对功能进行拓展。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152102022.png" alt="image-20240515210203823" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_manager_t</span> &#123;</span></span><br><span class="line">    <span class="type">list_t</span> ready_list;  <span class="comment">// 就绪队列</span></span><br><span class="line">    <span class="type">list_t</span> task_list;   <span class="comment">// 所有已创建队列</span></span><br><span class="line">    <span class="type">task_t</span> first_task;  <span class="comment">// 最先创建的任务</span></span><br><span class="line">    <span class="type">task_t</span> *curr_task;  <span class="comment">// 当前正在进行的任务</span></span><br><span class="line">&#125;<span class="type">task_manager_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 任务管理器初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span>;    <span class="comment">// 初始任务初始化</span></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_first_take</span> <span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 返回first task</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    list_init(&amp;task_manager.ready_list);  <span class="comment">// 初始化就绪队列</span></span><br><span class="line">    list_init(&amp;task_manager.task_list);   <span class="comment">// 初始化所有任务队列</span></span><br><span class="line">    task_manager.curr_task = (<span class="type">task_t</span> *)<span class="number">0</span>; <span class="comment">// 设置当前任务为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    task_init(&amp;task_manager.first_task, <span class="number">0</span>, <span class="number">0</span>);  		<span class="comment">// Task Initialization</span></span><br><span class="line">    write_tr(task_manager.first_task.tss_sel);          <span class="comment">// 对TR寄存器初始化</span></span><br><span class="line">    task_manager.curr_task = &amp;task_manager.first_task;  <span class="comment">// 设置当前任务为first task </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_first_take</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;task_manager.first_task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-2-将任务加入就绪队列"><a href="#8-2-将任务加入就绪队列" class="headerlink" title="8.2 将任务加入就绪队列"></a>8.2 将任务加入就绪队列</h2><p>当任务已经初始化完成时，进入<code>created</code>状态；当加入就绪队列时，进入<code>ready</code>状态。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152123227.png" alt="image-20240515212313112" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述程序/进程运行状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// uint32_t    *stack;      // 当前Task的任务栈（采用链表管理任务时不再采用stack，直接用硬件的TSS支持切换）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>                      <span class="comment">// 任务状态</span></span><br><span class="line">        TASK_CREATED,</span><br><span class="line">        TASK_RUNNING,</span><br><span class="line">        TASK_SLEEP,</span><br><span class="line">        TASK_READY,</span><br><span class="line">        TASK_WAITING,</span><br><span class="line">    &#125;state;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> name[TASK_NAME_SIZE];  <span class="comment">// 任务名称</span></span><br><span class="line"></span><br><span class="line">    <span class="type">list_node_t</span> run_node;       <span class="comment">// run_node插入ready_list中，而非将整个task_t加入</span></span><br><span class="line">    <span class="type">list_node_t</span> all_node;       <span class="comment">// all_node插入task_list中</span></span><br><span class="line"></span><br><span class="line">    <span class="type">tss_t</span>       tss;            <span class="comment">// TSS段</span></span><br><span class="line">    <span class="type">int</span>         tss_sel;        <span class="comment">// Task Selector</span></span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task Initializtion */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ASSERT((task != (<span class="type">task_t</span> *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化TSS</span></span><br><span class="line">    tss_init(task, entry, esp);</span><br><span class="line">    <span class="comment">// 初始化任务</span></span><br><span class="line">    kernel_strncpy(task-&gt;name, name, TASK_NAME_SIZE);</span><br><span class="line">    task-&gt;state = TASK_CREATED;</span><br><span class="line">    <span class="comment">// 初始化结点</span></span><br><span class="line">    list_node_init(&amp;task-&gt;all_node);</span><br><span class="line">    list_node_init(&amp;task-&gt;run_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务加入ready_list</span></span><br><span class="line">    task_set_ready(task);</span><br><span class="line">    <span class="comment">// 任务加入task_list</span></span><br><span class="line">    list_insert_last(&amp;task_manager.task_list, &amp;task-&gt;all_node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_ready</span><span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    list_insert_first(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">    task-&gt;state = TASK_READY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_block</span><span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    list_remove(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3-任务主动放弃CPU"><a href="#8-3-任务主动放弃CPU" class="headerlink" title="8.3 任务主动放弃CPU"></a>8.3 任务主动放弃CPU</h2><p>为了避免某个进程长时间占用CPU，可以让进程主动释放CPU的使用权，但不应当让进程指定切换到哪个进程运行。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161022580.png" alt="image-20240516102215352"></p>
<p><strong>简单起见，当进程需要让出CPU时，只需要将自己移到就绪队列的尾部即可。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161024659.png" alt="image-20240516102441540" style="zoom:50%;" />



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的实现用到了7.4所设计的宏</span></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_next_run</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">list_node_t</span> *task_node = list_first(&amp;task_manager.ready_list);</span><br><span class="line">    <span class="keyword">return</span> list_node_parent(task_node, <span class="type">task_t</span>, run_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_current</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> task_manager.curr_task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sched_yield</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前就绪队列是否还有其他任务</span></span><br><span class="line">    <span class="keyword">if</span> (list_count(&amp;task_manager.ready_list) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 取当前任务，并将其重新加入到就绪队列尾部</span></span><br><span class="line">        <span class="type">task_t</span> *curr_task = task_current();</span><br><span class="line">        task_set_block(curr_task);</span><br><span class="line">        task_set_ready(curr_task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放CPU使用权，将进程切换到当前就绪队列的第一个任务</span></span><br><span class="line">        task_dispatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_dispatch</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *to = task_next_run();</span><br><span class="line">    <span class="keyword">if</span> (to != task_manager.curr_task) &#123;</span><br><span class="line">        <span class="type">task_t</span> *from = task_current();  <span class="comment">// 定义[原来正在运行的任务]为[将要被切换掉的任务]</span></span><br><span class="line">        task_manager.curr_task = to;    <span class="comment">// 将task_manager中[当前正在运行的任务]修改为[将要切换过去的任务]</span></span><br><span class="line">        to-&gt;state = TASK_RUNNING;       <span class="comment">// 修改此任务的状态</span></span><br><span class="line"></span><br><span class="line">        task_switch_from_to(from, to);  <span class="comment">// 执行任务切换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init.c </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    sys_sched_yield();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    sys_sched_yield();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p> 解析上述代码</p>
</blockquote>
<p>根据<code>sys_sched_yield();</code>改写了整个任务切换的逻辑，不再由当前进程指定要切换到哪一个进程中，而是：</p>
<ol>
<li>当前进程放弃CPU使用权，重新移动到就绪队列的尾部；</li>
<li>从就绪队列中获取下一个要执【【行的任务<code>task_t *to = task_next_run()</code>；</li>
<li>定义[原来正在运行的任务]为[将要被切换掉的任务]<code>task_t *from = task_current()</code>；</li>
<li>将task_manager中[当前正在运行的任务]修改为[将要切换过去的任务]<code>task_manager.curr_task = to</code>；</li>
<li>修改此任务的状态为<code>TASK_RUNNING</code>；</li>
<li>执行任务切换<code>task_switch_from_to(from, to)</code>。</li>
</ol>
<h2 id="8-4-让进程按时间片运行"><a href="#8-4-让进程按时间片运行" class="headerlink" title="8.4 让进程按时间片运行"></a>8.4 让进程按时间片运行</h2><p><code>sys_sched_yield()</code>必须由进程主动调用才能放弃CPU，如果不主动调用，进程仍然长期占用CPU。为了避免进程长时间占用CPU，可以强制其运行一定时间后释放CPU。</p>
<p><strong>本项目中选择[一段时间]为<code>100ms</code>。</strong>通过<code>task_time_tick()</code>函数实现。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161046155.png" alt="image-20240516104613960" style="zoom:50%;" />

<p>注意：需要在<code>init.c</code>中开启全局中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    irq_enable_global();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// sys_sched_yield();  注意要注释掉这个函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来对<code>task_init</code>进行修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Task Initializtion */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ASSERT((task != (<span class="type">task_t</span> *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化TSS</span></span><br><span class="line">    tss_init(task, entry, esp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化任务结点</span></span><br><span class="line">    kernel_strncpy(task-&gt;name, name, TASK_NAME_SIZE);</span><br><span class="line">    task-&gt;state = TASK_CREATED;</span><br><span class="line">    <span class="comment">// =========================== 加入 ========================== //</span></span><br><span class="line">    task-&gt;time_ticks = TASK_TIME_SLICE_DEFAULT;</span><br><span class="line">    task-&gt;slice_ticks = task-&gt;time_ticks;</span><br><span class="line">    <span class="comment">// ========================================================== //</span></span><br><span class="line">    list_node_init(&amp;task-&gt;all_node);</span><br><span class="line">    list_node_init(&amp;task-&gt;run_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务加入ready_list</span></span><br><span class="line">    task_set_ready(task);</span><br><span class="line">    <span class="comment">// 任务加入task_list</span></span><br><span class="line">    list_insert_last(&amp;task_manager.task_list, &amp;task-&gt;all_node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在<code>time.c</code>中加入任务相关的中断处理<code>task_time_tick()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time.c </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_time</span> <span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">    sys_tick++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向8259通知对应的中断已完成</span></span><br><span class="line">    pic_send_eoi(IRQ0_TIMER);</span><br><span class="line">    <span class="comment">// =========================== 加入 ========================== //</span></span><br><span class="line">    task_time_tick();  <span class="comment">// 任务相关的处理</span></span><br><span class="line">    <span class="comment">// ========================================================== //</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里<code>pic_send_eoi(IRQ0_TIMER);</code>和<code>task_time_tick();</code>的顺序不能错。原因如下：、</p>
<blockquote>
<p>在中断处理程序 <code>do_handler_time</code> 中，<code>pic_send_eoi</code> 和 <code>task_time_tick</code> 的顺序不能交换，主要是为了保证中断的正确处理和系统的稳定运行。以下是详细解释：</p>
<ul>
<li><code>pic_send_eoi</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pic_send_eoi</span> <span class="params">(<span class="type">int</span> irq_num)</span> &#123;</span><br><span class="line">    irq_num -= IRQ_PIC_START;  <span class="comment">// 将irq_num变为内部序号</span></span><br><span class="line">    <span class="keyword">if</span> (irq_num &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">        outb(PIC1_OCW2, PIC_OCW2_EOI);  <span class="comment">// 向第二块8259发送eoi指令</span></span><br><span class="line">    &#125;</span><br><span class="line">    outb(PIC0_OCW2, PIC_OCW2_EOI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数向 8259 可编程中断控制器 (PIC) 发送中断结束信号 (EOI)，通知 PIC 当前中断已经处理完毕，可以接受新的中断请求。这个过程非常关键，因为它控制着中断的优先级和处理顺序。</p>
<ul>
<li><code>task_time_tick</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_time_tick</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *curr_task = task_current();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若当前任务的时间切片在运行后减少为0，说明需要对其进行任务切换</span></span><br><span class="line">    <span class="keyword">if</span> (--curr_task-&gt;slice_ticks == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 重新设置时间切片</span></span><br><span class="line">        curr_task-&gt;slice_ticks = curr_task-&gt;time_ticks;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行任务切换</span></span><br><span class="line">        task_set_block(curr_task);</span><br><span class="line">        task_set_ready(curr_task);</span><br><span class="line">        task_dispatch();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数处理与任务调度相关的逻辑，例如更新当前任务的时间片，并在需要时触发任务切换。</p>
<ul>
<li>不能交换顺序的原因</li>
</ul>
<ol>
<li><strong>中断优先级控制</strong>：<ul>
<li>在中断处理程序中，优先向 PIC 发送 EOI 信号，确保 PIC 能够继续处理其他中断。这可以防止中断嵌套过多，避免中断响应延迟。</li>
</ul>
</li>
<li><strong>任务切换时的安全性</strong>：<ul>
<li><code>task_time_tick</code> 可能会触发任务切换，这意味着当前任务的上下文（CPU 寄存器状态、栈指针等）可能会被保存，并切换到另一个任务的上下文。如果在 <code>task_time_tick</code> 中执行任务切换之前没有发送 EOI 信号，可能会导致中断处理未完全结束就切换到另一个任务，造成中断处理不完整或混乱。</li>
</ul>
</li>
<li><strong>系统稳定性</strong>：<ul>
<li>及时发送 EOI 信号可以确保系统中断处理机制的稳定性，避免中断嵌套层数过多，导致系统无法及时响应其他硬件中断请求。</li>
</ul>
</li>
</ol>
<p>因此，将 <code>task_time_tick</code> 放在 <code>pic_send_eoi</code> 之后，可以确保在进行任务切换等复杂操作前，已经通知 PIC 当前中断处理完毕。这种顺序确保了中断处理的及时性和系统的稳定性。因此，<code>pic_send_eoi</code> 和 <code>task_time_tick</code> 的调用顺序不能交换。</p>
</blockquote>
<p>最后的实现效果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161536876.png" alt="image-20240516153646690"></p>
<h2 id="8-5-临界资源与临界区"><a href="#8-5-临界资源与临界区" class="headerlink" title="8.5 临界资源与临界区"></a>8.5 临界资源与临界区</h2><p>上述任务存在一些问题，即：<strong>在两个任务进行切换的时刻输出的信息是乱的。</strong>因此需要对其进行修改。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161540957.png" alt="image-20240516154041859"></p>
<h3 id="1、理论基础-10"><a href="#1、理论基础-10" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><ul>
<li><p>并发与并行</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161541337.png" alt="image-20240516154127142"></p>
<p>因此，当多个进程或任务共同访问统一资源时，有可能产生冲突。</p>
<p>如下图所示，假设<code>first_task</code>此时运行到<code>log_printf</code>函数时，正在执行串口输出，且时间较长。由于任务间按时间片方式轮流执行，因此可能输出到一半时<code>first_task</code>的时间片用完了，正好定时器中断也到了，那么此时就会将任务切换到<code>init_task</code>，会接下来打印<code>init_task</code>的信息，从而造成输出信息混乱。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161544397.png" alt="image-20240516154434937"></p>
</li>
<li><p>临界资源和临界区</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161548492.png" alt="image-20240516154831083"></p>
</li>
</ul>
<h3 id="2、互斥实现"><a href="#2、互斥实现" class="headerlink" title="2、互斥实现"></a>2、互斥实现</h3><p>解决方法1：互斥。即一次只允许一个进程在临界区中。互斥的实现方法之一是：禁用中断。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161550138.png" alt="image-20240516155039989" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// irq.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">irq_state_t</span>;</span><br><span class="line"><span class="type">irq_state_t</span> <span class="title function_">irq_enter_protection</span> <span class="params">(<span class="type">void</span>)</span>;        <span class="comment">// 进入临界区保护状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_leave_protection</span> <span class="params">(<span class="type">irq_state_t</span> state)</span>;  <span class="comment">// 退出临界区保护状态</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数可变的打印模版函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界资源保护</span></span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = str_buf;</span><br><span class="line">    <span class="comment">// 打印fmt相关内容</span></span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 串行接口忙检测</span></span><br><span class="line">        <span class="keyword">while</span> ((inb(COM1_PORT + <span class="number">5</span>) &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>)) == <span class="number">0</span>);        </span><br><span class="line">        outb(COM1_PORT, *p++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 退出临界资源保护模式</span></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// irq.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通过关闭中断的方式实现互斥，主要需要保存进入临界区之前中断的开关状态，避免退出时意外开启中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">irq_state_t</span> <span class="title function_">irq_enter_protection</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 读取原中断状态</span></span><br><span class="line">    <span class="type">irq_state_t</span> state = read_eflags();</span><br><span class="line">    <span class="comment">// 关中断</span></span><br><span class="line">    irq_disable_global();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_leave_protection</span> <span class="params">(<span class="type">irq_state_t</span> state)</span> &#123;</span><br><span class="line">    <span class="comment">// 写回中断状态，若原中断为关闭状态，则保持；若原中断为开启状态，则恢复打开</span></span><br><span class="line">    write_eflags(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpu_instr.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读EFLAGS寄存器</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">read_eflags</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> eflags;</span><br><span class="line"></span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;pushf\n\tpop %%eax&quot;</span>:<span class="string">&quot;=a&quot;</span>(eflags));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> eflags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写EFLAGS寄存器</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">write_eflags</span> <span class="params">(<span class="type">uint32_t</span> eflags)</span> &#123;</span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;push %%eax\n\tpopf&quot;</span>::<span class="string">&quot;a&quot;</span>(eflags));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时切换点会执行完整输出</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161610637.png" alt="image-20240516160955146"></p>
<h2 id="8-6-让进程能够延时运行"><a href="#8-6-让进程能够延时运行" class="headerlink" title="8.6 让进程能够延时运行"></a>8.6 让进程能够延时运行</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;main task: %d&quot;</span>, count++);  <span class="comment">// 需求：每隔一秒输出一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当进程需要延时运行时，应当将其从就绪队列中移出，以免占用CPU；等延时时间到达后，再将其移回就绪队列。</strong>因此，专门设计一个队列，用于放置需要延时的进程。<strong>在每个时钟节拍中断发生时，扫描延时队列，发现延时时间到，则再将进程移回就绪队列尾部。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161656774.png" alt="image-20240516165606592" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_manager_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">list_t</span> sleep_list;  <span class="comment">// 睡眠队列</span></span><br><span class="line">&#125;<span class="type">task_manager_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述程序/进程运行状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> sleep_ticks;            <span class="comment">// 延时</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_sleep</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> ticks)</span>;  <span class="comment">// 任务加入睡眠队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_wakeup</span> <span class="params">(<span class="type">task_t</span> *task)</span>;                 <span class="comment">// 任务移除睡眠队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_sleep</span> <span class="params">(<span class="type">uint32_t</span> ms)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务加入睡眠队列的尾部</span></span><br><span class="line"><span class="comment"> * @param ticks 要睡眠的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_sleep</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> ticks)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ticks == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task-&gt;sleep_ticks = ticks;</span><br><span class="line">    task-&gt;state = TASK_SLEEP;</span><br><span class="line">    list_insert_last(&amp;task_manager.sleep_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务移除睡眠队列 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_wakeup</span> <span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    list_remove(&amp;task_manager.sleep_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 实现睡眠机制，使当前任务进入睡眠状态一段时间，并切换到其他任务继续执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_sleep</span> <span class="params">(<span class="type">uint32_t</span> ms)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将任务从就绪队列移动到睡眠队列</span></span><br><span class="line">    task_set_block(task_manager.curr_task);</span><br><span class="line">    task_set_sleep(task_manager.curr_task, ms + (OS_TICKS_MS - <span class="number">1</span>) / OS_TICKS_MS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到就绪队列的下一个任务执行</span></span><br><span class="line">    task_dispatch();</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现效果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161945180.png" alt="image-20240516194523931"></p>
<h2 id="8-7-让所有进程都能延时"><a href="#8-7-让所有进程都能延时" class="headerlink" title="8.7 让所有进程都能延时"></a>8.7 让所有进程都能延时</h2><p>当所有进程都进入睡眠状态时，就绪队列为空，也就是说在<code>task_dispatch()</code>中，<code>to</code>取出的下一个任务为空，造成操作系统崩溃。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通过任务队列实现任务切换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_dispatch</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line">    </span><br><span class="line">    <span class="type">task_t</span> *to = task_next_run();		<span class="comment">// !!!!!!!此处!!!!!!!</span></span><br><span class="line">    <span class="keyword">if</span> (to != task_manager.curr_task) &#123;</span><br><span class="line">        <span class="type">task_t</span> *from = task_current();  <span class="comment">// 定义[原来正在运行的任务]为[将要被切换掉的任务]</span></span><br><span class="line">        task_manager.curr_task = to;    <span class="comment">// 将task_manager中[当前正在运行的任务]修改为[将要切换过去的任务]</span></span><br><span class="line">        to-&gt;state = TASK_RUNNING;       <span class="comment">// 修改此任务的状态</span></span><br><span class="line"></span><br><span class="line">        task_switch_from_to(from, to);  <span class="comment">// 执行任务切换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：当就绪队列为空时，运行<strong>空闲进程</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_manager_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">task_t</span> idle_task;   <span class="comment">// 空闲进程</span></span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="type">task_manager_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 任务管理器初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    list_init(&amp;task_manager.ready_list);  <span class="comment">// 初始化就绪队列</span></span><br><span class="line">    list_init(&amp;task_manager.sleep_list);  <span class="comment">// 初始化睡眠队列</span></span><br><span class="line">    list_init(&amp;task_manager.task_list);   <span class="comment">// 初始化所有任务队列</span></span><br><span class="line">    task_manager.curr_task = (<span class="type">task_t</span> *)<span class="number">0</span>;  <span class="comment">// 设置当前任务为0</span></span><br><span class="line"></span><br><span class="line">    task_init(&amp;task_manager.idle_task,</span><br><span class="line">        <span class="string">&quot;idle_task&quot;</span>,</span><br><span class="line">        (<span class="type">uint32_t</span>)idle_task_entry,</span><br><span class="line">        (<span class="type">uint32_t</span>)(idle_task_stack + IDLE_TASK_SIZE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务加入就绪队列的尾部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_ready</span> <span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于空闲进程，不应加入时间片轮换中</span></span><br><span class="line">    <span class="keyword">if</span> (task == &amp;task_manager.idle_task) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list_insert_last(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">    task-&gt;state = TASK_READY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务移除就绪队列 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_block</span> <span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于空闲进程，不应加入时间片轮换中</span></span><br><span class="line">    <span class="keyword">if</span> (task == &amp;task_manager.idle_task) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list_remove(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  从就绪队列中选取下一个要运行的任务</span></span><br><span class="line"><span class="comment"> *         这里实际上需要根据run_node取到包含run_node的task的整个结构体的起始地址，</span></span><br><span class="line"><span class="comment"> *         因为对于要对task进行操作的函数来说，需要操作的是task这个整体</span></span><br><span class="line"><span class="comment"> * @return 指向该任务的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_next_run</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 若就绪队列为空，运行空闲进程</span></span><br><span class="line">    <span class="keyword">if</span> (list_count(&amp;task_manager.ready_list) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;task_manager.idle_task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">list_node_t</span> *task_node = list_first(&amp;task_manager.ready_list);</span><br><span class="line">    <span class="keyword">return</span> list_node_parent(task_node, <span class="type">task_t</span>, run_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现效果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162010349.png" alt="image-20240516201030225"></p>
<h1 id="九、进程间的同步与互斥"><a href="#九、进程间的同步与互斥" class="headerlink" title="九、进程间的同步与互斥"></a>九、进程间的同步与互斥</h1><h2 id="9-1-计数信号量及其初始化"><a href="#9-1-计数信号量及其初始化" class="headerlink" title="9.1 计数信号量及其初始化"></a>9.1 计数信号量及其初始化</h2><h3 id="1、理论基础-11"><a href="#1、理论基础-11" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>在多进程运行环境中，进程之间、进程与中断之间需要协作，也可以通过信号来同步行为。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162022801.png" alt="image-20240516202243580" style="zoom:50%;" />

<p>为实现这种行为上的同步，需要提供两种操作，等信号和发信号，且在某些情况下，可能连续发多次信号，因此可以将发送的信号数记录下来。</p>
<ul>
<li>等信号：如果信号计数&#x3D;0， 则进程等待；否则，计数减1，进程继续执行。</li>
<li>发信号：若有进程等待，则唤醒进程继续执行；否则，增加计数。</li>
</ul>
<blockquote>
<p><strong>可以类比停车场停车。</strong></p>
<p>等信号相当于车辆进入停车场，信号计数相当于空车位。</p>
<ul>
<li>信号计数为0相当于没有空车位，因此车辆需要等待（即进程等待）；</li>
<li>若信号计数不为0，则当前有空车位，车辆可以驶入（即进程执行），而空车位的数量要减1。</li>
</ul>
<p>发信号则相当于车辆离开停车场。</p>
<ul>
<li>若此时恰好有另一辆车要进入（待执行进程），那么这辆车可以直接进入（待执行进程被唤醒），空车位数不变（信号量不变）；</li>
<li>否则，空车位数加1（信号量加1）。</li>
</ul>
</blockquote>
<p>计数信号量：包含1）一个计数器，以及2）当计数为0时让进程排队等待的队列。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162035492.png" alt="image-20240516203555357" style="zoom:50%;" />

<h3 id="2、代码实现-2"><a href="#2、代码实现-2" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><p>新建<code>ipc</code>目录。</p>
<blockquote>
<p>IPC（Inter-Process Communication，进程间通信）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数信号量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">sem_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">list_t</span> wait_list;</span><br><span class="line">&#125;<span class="type">sem_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_init</span> <span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> init_count)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="9-2-发信号和等信号"><a href="#9-2-发信号和等信号" class="headerlink" title="9.2 发信号和等信号"></a>9.2 发信号和等信号</h2><ul>
<li><p>等信号：如果信号计数&#x3D;0， 则进程等待；否则，计数减1，进程继续执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 等信号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_wait</span> <span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 信号量不为0，进程可继续执行</span></span><br><span class="line">        sem-&gt;count--;  <span class="comment">// 信号量减1，表明当前进程获得一个信号</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 信号量为0，进程由就绪队列移动到等待队列</span></span><br><span class="line">        <span class="type">task_t</span> *curr =  task_current();</span><br><span class="line">        task_set_block(curr);</span><br><span class="line">        list_insert_last(&amp;sem-&gt;wait_list, &amp;curr-&gt;wait_node);</span><br><span class="line">        task_dispatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162047328.png" alt="image-20240516204721126" style="zoom: 50%;" />
</li>
<li><p>发信号：若有进程等待，则唤醒进程继续执行；否则，增加计数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 发信号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_notify</span> <span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list_count(&amp;sem-&gt;wait_list)) &#123;</span><br><span class="line">        <span class="comment">// 等待队列非空，有进程在等待执行</span></span><br><span class="line">        <span class="type">list_node_t</span> *node = list_remove_first(&amp;sem-&gt;wait_list);  <span class="comment">// 从等待队列中取第一个任务     </span></span><br><span class="line">        <span class="type">task_t</span> *task = list_node_parent(node, <span class="type">task_t</span>, wait_node);  <span class="comment">// 获取该任务对应的task_t地址</span></span><br><span class="line">        task_set_ready(task);   <span class="comment">// 设置该任务为就绪状态</span></span><br><span class="line"></span><br><span class="line">        task_dispatch();        <span class="comment">// 执行任务切换</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 等待队列为空，信号量加1</span></span><br><span class="line">        sem-&gt;count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162048307.png" alt="image-20240516204803152" style="zoom:50%;" /></li>
</ul>
<h2 id="9-3-使用计数信号量"><a href="#9-3-使用计数信号量" class="headerlink" title="9.3 使用计数信号量"></a>9.3 使用计数信号量</h2><p>实例：收到信号量打印信息。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162101361.png" alt="image-20240516210150112" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">task_t</span> sub_task;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> init_task_stack[<span class="number">1024</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        sem_wait(&amp;sem);</span><br><span class="line">        log_printf(<span class="string">&quot;sub task: %d&quot;</span>, count++);</span><br><span class="line">        <span class="comment">// task_switch_from_to(&amp;sub_task, task_first_take());</span></span><br><span class="line">        <span class="comment">// sys_sched_yield();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a = 3 / 0;</span></span><br><span class="line">    <span class="comment">// irq_enable_global();</span></span><br><span class="line">    task_init(&amp;sub_task, <span class="string">&quot;sub task&quot;</span>, (<span class="type">uint32_t</span>)init_task_entry, (<span class="type">uint32_t</span>)&amp;init_task_stack[<span class="number">1024</span>]);</span><br><span class="line">    task_first_init();</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;sem, <span class="number">0</span>);  <span class="comment">// 信号量初始化（放在开中断前，以避免定时中断切换至其它任务，而此时信号量还未初始化）</span></span><br><span class="line">    irq_enable_global();  <span class="comment">// 打开全局中断</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;main task: %d&quot;</span>, count++);</span><br><span class="line">        <span class="comment">// task_switch_from_to(task_first_take(), &amp;sub_task);</span></span><br><span class="line">        <span class="comment">// 修改上面这个函数，使得进程主动释放CPU的使用权，但不指定切换到哪个进程运行，实现如下</span></span><br><span class="line">        <span class="comment">// sys_sched_yield();</span></span><br><span class="line">        <span class="comment">// 注释掉上面这个函数，使得执行时间片切片运行的效果</span></span><br><span class="line">        sem_notify(&amp;sem);</span><br><span class="line">        sys_sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时和<code>8.7</code>相比就会先打印<code>main task</code>：<strong>因为此时<code>sub task</code>需要等到<code>main task</code>发信号，接收到信号时才会执行。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162110080.png" alt="image-20240516211037845"></p>
<h2 id="9-4-互斥锁及其初始化"><a href="#9-4-互斥锁及其初始化" class="headerlink" title="9.4 互斥锁及其初始化"></a>9.4 互斥锁及其初始化</h2><p>使用关闭中断的方式实现互斥，简单粗暴，容易造成中断和其它进程长时间得到运行或响应。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162120111.png" alt="image-20240516212005916" style="zoom:50%;" />

<p>类似地，可以为临界区加一把锁(互斥锁)，只有持有锁的进程才能进来，从而实现进程进入临界区的互斥。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162121845.png" alt="image-20240516212129597" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">smutex_t</span>&#123;</span> </span><br><span class="line">    <span class="type">task_t</span> *owner;      <span class="comment">// 当前持有锁的进程</span></span><br><span class="line">    <span class="type">int</span> locked_count;   <span class="comment">// 当前锁的上锁次数</span></span><br><span class="line">    <span class="type">list_t</span> wait_list;   <span class="comment">// 等待队列，存放进程</span></span><br><span class="line">&#125;<span class="type">mutex_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_init</span> <span class="params">(<span class="type">mutex_t</span> *mutex)</span>;  <span class="comment">// 互斥锁初始化</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 互斥锁初始化 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_init</span> <span class="params">(<span class="type">mutex_t</span> *mutex)</span> &#123;</span><br><span class="line">    mutex-&gt;owner = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line">    mutex-&gt;locked_count = <span class="number">0</span>;</span><br><span class="line">    list_init(&amp;mutex-&gt;wait_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-5-互斥锁的加解锁"><a href="#9-5-互斥锁的加解锁" class="headerlink" title="9.5 互斥锁的加解锁"></a>9.5 互斥锁的加解锁</h2><ul>
<li><p>上锁：如果已经上锁，则等待；否则，该进程自己上锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 上锁 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_lock</span> <span class="params">(<span class="type">mutex_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    <span class="comment">// 判断是否已上锁</span></span><br><span class="line">    <span class="keyword">if</span> (mutex-&gt;locked_count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前未上锁</span></span><br><span class="line">        mutex-&gt;locked_count++;  <span class="comment">// 上锁次数加1</span></span><br><span class="line">        mutex-&gt;owner = curr;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutex-&gt;owner == curr) &#123;</span><br><span class="line">        <span class="comment">// 若恰为本进程上锁，上锁次数加1</span></span><br><span class="line">        mutex-&gt;locked_count++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若非本进程上锁，加入等待队列</span></span><br><span class="line">        task_set_block(curr);</span><br><span class="line">        list_insert_last(&amp;mutex-&gt;wait_list, &amp;curr-&gt;wait_node);</span><br><span class="line">        task_dispatch();  <span class="comment">// 进程切换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162128904.png" alt="image-20240516212825736" style="zoom:50%;" />
</li>
<li><p>解锁：如果有进程等待，则唤醒进程继续执行；否则，直接解锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 解锁，注意只有锁的上锁者才能解锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_unlock</span> <span class="params">(<span class="type">mutex_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    <span class="keyword">if</span> (mutex-&gt;owner == curr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--mutex-&gt;locked_count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 若当前锁被上锁者解锁掉，首先释放掉这个锁</span></span><br><span class="line">            mutex-&gt;owner = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其次，若等待队列中仍然有进程等待，则等待队列中的下一个进程进行加锁操作</span></span><br><span class="line">            <span class="keyword">if</span> (list_count(&amp;mutex-&gt;wait_list)) &#123;</span><br><span class="line">                <span class="comment">// 该进程加入就绪队列</span></span><br><span class="line">                <span class="type">list_node_t</span> *node = list_remove_first(&amp;mutex-&gt;wait_list);</span><br><span class="line">                <span class="type">task_t</span> *task = list_node_parent(node, <span class="type">task_t</span>, wait_node);</span><br><span class="line">                task_set_ready(task);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重新加锁</span></span><br><span class="line">                mutex-&gt;locked_count = <span class="number">1</span>;</span><br><span class="line">                mutex-&gt;owner = task;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 任务切换</span></span><br><span class="line">                task_dispatch();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162134988.png" alt="image-20240516213438830" style="zoom:50%;" /></li>
</ul>
<h2 id="9-6-应用互斥锁"><a href="#9-6-应用互斥锁" class="headerlink" title="9.6 应用互斥锁"></a>9.6 应用互斥锁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpu.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配一个GDT空闲表项 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gdt_alloc_desc</span><span class="params">()</span> &#123;</span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过第0项（保留使用）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; GDT_TABLE_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">segment_desc_t</span> *desc = gdt_table + i;</span><br><span class="line">        <span class="keyword">if</span> (desc-&gt;attr == <span class="number">0</span>) &#123;</span><br><span class="line">            mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">return</span> i * <span class="keyword">sizeof</span>(<span class="type">gate_desc_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置中断门表项 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cpu_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    mutex_init(&amp;mutex);</span><br><span class="line">    init_gdt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 日志初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    mutex_init(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化串行接口，无需了解细节</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">1</span>, <span class="number">0x00</span>);  <span class="comment">// 关闭串行接口相关中断</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">3</span>, <span class="number">0x80</span>);  <span class="comment">// 数据发送速度</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">0</span>, <span class="number">0x3</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">1</span>, <span class="number">0x00</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">3</span>, <span class="number">0x03</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">2</span>, <span class="number">0xc7</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">4</span>, <span class="number">0x0F</span>);</span><br><span class="line">&#125;                  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数可变的打印模版函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理可变字符串</span></span><br><span class="line">    <span class="type">char</span> str_buf[<span class="number">128</span>];</span><br><span class="line">    va_list args;</span><br><span class="line"></span><br><span class="line">    kernel_memset(str_buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(str_buf));</span><br><span class="line">    va_start(args, fmt);  </span><br><span class="line">    kernel_vsprintf(str_buf, fmt, args);</span><br><span class="line">    va_end(args);  <span class="comment">// 释放args</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界资源保护</span></span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = str_buf;</span><br><span class="line">    <span class="comment">// 打印fmt相关内容</span></span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 串行接口忙检测</span></span><br><span class="line">        <span class="keyword">while</span> ((inb(COM1_PORT + <span class="number">5</span>) &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>)) == <span class="number">0</span>);        </span><br><span class="line">        outb(COM1_PORT, *p++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 退出临界资源保护模式</span></span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>实现效果：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405170816844.png" alt="image-20240517081626731"></p>
<p>可以看到，<code>main task</code>和<code>sub task</code>将轮流执行。</p>
<h1 id="十、虚拟内存管理和保护模式"><a href="#十、虚拟内存管理和保护模式" class="headerlink" title="十、虚拟内存管理和保护模式"></a>十、虚拟内存管理和保护模式</h1><h2 id="10-1-内存管理问题"><a href="#10-1-内存管理问题" class="headerlink" title="10.1 内存管理问题"></a>10.1 内存管理问题</h2><p>操作系统需要决定如何管理计算机中的整块内存。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405170959500.png" alt="image-20240517095902134" style="zoom: 33%;" />

<p>内存中存在多进程时，加载进程时存在一些问题：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171004646.png" alt="image-20240517100444945" style="zoom: 33%;" />

<p>为便于内存管理，<code>x86</code>的虚拟内存管理硬件将内存看做成相同大小的页。后续实际上不是按字节分配，而是按页分配的。 </p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171006887.png" alt="image-20240517100622430" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171007176.png" alt="image-20240517100745545" style="zoom: 33%;" />

<p>进程内部维护了一张表，用于实现这种进程和页之间的转换关系。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171009559.png" alt="image-20240517100935089" style="zoom: 33%;" />

<h2 id="10-2-位图数据结构与初始化"><a href="#10-2-位图数据结构与初始化" class="headerlink" title="10.2 位图数据结构与初始化"></a>10.2 位图数据结构与初始化</h2><ul>
<li><p><strong>问题：用什么样的方法管理内存页的分配与回收？</strong></p>
<ul>
<li><p>标记哪些页被使用了，哪些页没有被使用；</p>
</li>
<li><p>采用<strong>位图方式</strong>实现，如下图所示。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171011883.png" alt="image-20240517101143375" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">bitmap_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> bit_count;  <span class="comment">// 位图中的位总个数</span></span><br><span class="line">    <span class="type">uint8_t</span> *bits;  <span class="comment">// 位图字节数组</span></span><br><span class="line">&#125;<span class="type">bitmap_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools/bitmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools/klib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 计算位总个数所需字节数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_byte_count</span><span class="params">(<span class="type">int</span> bit_count)</span> &#123;</span><br><span class="line">    <span class="comment">// 考虑到6/8=0 &amp; 14/8=1这两种情况，需要进行向上取整</span></span><br><span class="line">    <span class="keyword">return</span> (bit_count + <span class="number">8</span> - <span class="number">1</span>) / <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 位图初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_init</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">uint8_t</span> *bits, <span class="type">int</span> count, <span class="type">int</span> init_bit)</span> &#123;</span><br><span class="line">    bitmap-&gt;bits = bits;</span><br><span class="line">    bitmap-&gt;bit_count = count;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bytes = bitmap_byte_count(bitmap-&gt;bit_count);</span><br><span class="line">    kernel_memset(bitmap-&gt;bits, init_bit ? <span class="number">0xFF</span> : <span class="number">0</span>, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="10-3-位图位的分配"><a href="#10-3-位图位的分配" class="headerlink" title="10.3 位图位的分配"></a>10.3 位图位的分配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取位图中某一位的状态 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_get_bit</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// index / 8                --&gt; 获取到该位处在哪个字节数组（每个字节数组是8位）</span></span><br><span class="line">    <span class="comment">// index % 8                --&gt; 获取到该位在字节数组内部对应的下标</span></span><br><span class="line">    <span class="comment">// &amp; (1 &lt;&lt; (index % 8))     --&gt; 左移下标位，并相与，即可取得该位的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 17 / 8 = 2  --&gt;  在第2个字节数组中</span></span><br><span class="line">    <span class="comment">// 17 % 8 = 1  --&gt;  第2个字节数组的第1位</span></span><br><span class="line">    <span class="keyword">return</span> bitmap-&gt;bits[index / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置位图中的某一位 </span></span><br><span class="line"><span class="comment"> * @param index 位的索引</span></span><br><span class="line"><span class="comment"> * @param count 要设置的位的总个数</span></span><br><span class="line"><span class="comment"> * @param bit   要设置的位的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_set_bit</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> index, <span class="type">int</span> count, <span class="type">int</span> bit)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; (i &lt; count) &amp;&amp; (index &lt; bitmap-&gt;bit_count); i++, index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bit) &#123;</span><br><span class="line">            <span class="comment">// 若bit为1，则进行置1</span></span><br><span class="line">            bitmap-&gt;bits[index / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，进行清0</span></span><br><span class="line">            bitmap-&gt;bits[index / <span class="number">8</span>] &amp;= (<span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 判断位图中某一位是否已设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_is_set</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bitmap_get_bit(bitmap, index) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在位图中寻找值匹配的连续N个位进行分配 </span></span><br><span class="line"><span class="comment"> * @param bit   要匹配的值</span></span><br><span class="line"><span class="comment"> * @param count 要匹配的位的总个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_alloc_nbits</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> bit, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">int</span> search_idx = <span class="number">0</span>;  <span class="comment">// 从第0位开始找</span></span><br><span class="line">    <span class="type">int</span> ok_idx = <span class="number">-1</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (search_idx &lt; bitmap-&gt;bit_count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bitmap_get_bit(bitmap, search_idx) != bit) &#123;</span><br><span class="line">            search_idx++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;  </span><br><span class="line">        <span class="comment">// 找到第一个值匹配的位</span></span><br><span class="line">        ok_idx = search_idx;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; (i &lt; count) &amp;&amp; (search_idx &lt; bitmap-&gt;bit_count); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bitmap_get_bit(bitmap, search_idx++) != bit) &#123;</span><br><span class="line">                <span class="comment">// 当前位值不匹配</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= count) &#123;</span><br><span class="line">            <span class="comment">// 找到了符合条件的多个位</span></span><br><span class="line">            bitmap_set_bit(bitmap, ok_idx, count, ~bit);  <span class="comment">// bit取反</span></span><br><span class="line">            <span class="keyword">return</span> ok_idx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-4-创建地址分配结构"><a href="#10-4-创建地址分配结构" class="headerlink" title="10.4 创建地址分配结构"></a>10.4 创建地址分配结构</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171101073.png" alt="image-20240517110120785" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">addr_alloc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> start;         <span class="comment">// 位图的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> size;          <span class="comment">// 分配的存储空间[位图]的大小</span></span><br><span class="line">    <span class="type">uint32_t</span> page_size;     <span class="comment">// 内存块大小（内存以页的方式分配，因此又称页大小）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bitmap_t</span> bitmap;    </span><br><span class="line"></span><br><span class="line">    <span class="type">mutex_t</span> mutex;          <span class="comment">// 内存分配时的互斥操作</span></span><br><span class="line">&#125;<span class="type">addr_alloc_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 地址分配器初始化</span></span><br><span class="line"><span class="comment"> * @param bits      位图的字节缓冲区</span></span><br><span class="line"><span class="comment"> * @param start     管理内存的起始地址</span></span><br><span class="line"><span class="comment"> * @param size      管理内存的大小</span></span><br><span class="line"><span class="comment"> * @param page_size 内存块大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">addr_alloc_init</span> <span class="params">(<span class="type">addr_alloc_t</span> *alloc, <span class="type">uint8_t</span> *bits,</span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> start, <span class="type">uint32_t</span> size, <span class="type">uint32_t</span> page_size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 内存分配，从位图中获取相应的位并分配，将对应的位由0-&gt;1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">addr_alloc_page</span> <span class="params">(<span class="type">addr_alloc_t</span> *alloc, <span class="type">int</span> page_count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 内存释放</span></span><br><span class="line"><span class="comment"> * @param addr 释放的内存块的起始地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">addr_free_page</span> <span class="params">(<span class="type">addr_alloc_t</span> *alloc, <span class="type">uint32_t</span> addr, <span class="type">int</span> page_count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 内存初始化 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_init</span> <span class="params">(<span class="type">boot_info_t</span> *boot_info)</span> &#123;</span><br><span class="line">    <span class="type">addr_alloc_t</span> addr_alloc;</span><br><span class="line">    <span class="type">uint8_t</span> bits[<span class="number">9</span>];  <span class="comment">// 支持最多64个内存页的分配和释放</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4096:1KB  0x1000:4KB</span></span><br><span class="line">    addr_alloc_init(&amp;addr_alloc, bits, <span class="number">0x1000</span>, <span class="number">64</span>*<span class="number">4096</span>, <span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> addr = addr_alloc_page(&amp;addr_alloc, <span class="number">2</span>);</span><br><span class="line">        log_printf(<span class="string">&quot;alloc addr: 0x%x&quot;</span>, addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> addr = <span class="number">0x1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> addr = addr_free_page(&amp;addr_alloc, addr, <span class="number">2</span>);</span><br><span class="line">        addr += <span class="number">8192</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171448019.png" alt="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171448019.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addr_alloc_init(&amp;addr_alloc, bits, <span class="number">0x1000</span>, <span class="number">64</span>*<span class="number">4096</span>, <span class="number">4096</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> addr = addr_alloc_page(&amp;addr_alloc, <span class="number">2</span>);  <span class="comment">// 单步调试此处后，00处的[00]-&gt;[03]</span></span><br><span class="line">    log_printf(<span class="string">&quot;alloc addr: 0x%x&quot;</span>, addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240517145000377.png" alt="image-20240517145000377"></p>
<p>64个内存块分配完毕后：</p>
<p><img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240517144742533.png" alt="image-20240517144742533"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171451064.png" alt="image-20240517145140955"></p>
<p>接下来对这64个内存块进行释放：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171451285.png" alt="image-20240517145130117"></p>
<h2 id="10-5-规划内存空间的分配"><a href="#10-5-规划内存空间的分配" class="headerlink" title="10.5 规划内存空间的分配"></a>10.5 规划内存空间的分配</h2><p>系统内存分两大块：</p>
<ul>
<li><code>1M以内</code>给<strong>操作系统</strong>使用；</li>
<li><code>1M以上</code>给<strong>进程</strong>使用。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171455366.png" alt="image-20240517145539043"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">show_mem_info</span><span class="params">(<span class="type">boot_info_t</span> *boot_info)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;mem region: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boot_info-&gt;ram_region_count; i++) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;[%d]: 0x%x - 0x%x&quot;</span>, i,</span><br><span class="line">            boot_info-&gt;ram_region_cfg[i].start,</span><br><span class="line">            boot_info-&gt;ram_region_cfg[i].size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">total_mem_size</span> <span class="params">(<span class="type">boot_info_t</span> *boot_info)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> mem_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boot_info-&gt;ram_region_count; i++) &#123;</span><br><span class="line">        mem_size += boot_info-&gt;ram_region_cfg[i].size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mem_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 内存初始化 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_init</span> <span class="params">(<span class="type">boot_info_t</span> *boot_info)</span> &#123;</span><br><span class="line">    <span class="comment">// 1MB内存空间起始，在链接脚本中定义</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> *mem_free_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印内存初始信息</span></span><br><span class="line">    log_printf(<span class="string">&quot;mem init&quot;</span>);</span><br><span class="line">    show_mem_info(boot_info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位图缓存的起始地址</span></span><br><span class="line">    <span class="type">uint8_t</span> *mem_free = (<span class="type">uint8_t</span> *)&amp;mem_free_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算1MB以上空间的空闲内存容量，并对齐页边界</span></span><br><span class="line">    <span class="type">uint32_t</span> mem_up1MB_free = total_mem_size(boot_info) - MEM_EXT_START;</span><br><span class="line">    mem_up1MB_free = down2(mem_up1MB_free, MEM_PAGE_SIZE);</span><br><span class="line">    log_printf(<span class="string">&quot;free memory: 0x%x, size: 0x%x&quot;</span>, MEM_EXT_START, mem_up1MB_free);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用地址分配机构对得到的内存进行管理</span></span><br><span class="line">    addr_alloc_init(&amp;paddr_alloc, mem_free, MEM_EXT_START, mem_up1MB_free, MEM_PAGE_SIZE);</span><br><span class="line">    mem_free += bitmap_byte_count(paddr_alloc.size / MEM_PAGE_SIZE);  <span class="comment">// 跳过位图缓存这一块内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，mem_free应该比EBDA地址要小</span></span><br><span class="line">    ASSERT(mem_free &lt; (<span class="type">uint8_t</span> *)MEM_EBDA_START);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>kernel.lds</code>中，取出位图缓存这一部分的起始地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x10000;</span><br><span class="line"></span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text)</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		*(.rodata)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.data : &#123;</span><br><span class="line">		*(.data)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.bss : &#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROVIDE(mem_free_start = . );     &lt;--  这一行就可以取取出.bss之后的内存起始地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存初始信息获取：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171531929.png" alt="image-20240517153147728"></p>
<p>位图缓存的起始地址：</p>
<blockquote>
<p> 0x000129c0 + 0x4f10 &#x3D; 0x17830</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171535529.png" alt="image-20240517153526379"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171534282.png" alt="image-20240517153424161"></p>
<p><code>1MB</code>以上空间的空闲内存容量（对齐页边界）：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171532892.png" alt="image-20240517153243765"></p>
<p>两个技巧函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 ** n</span></span><br><span class="line"><span class="comment">// size = 0x1010  bound = 0x1000(4KB)</span></span><br><span class="line"><span class="comment">// size &amp; ~(bound - 1) </span></span><br><span class="line"><span class="comment">//  = 0x1010 &amp; ~(0x0FFF) </span></span><br><span class="line"><span class="comment">//  = 0x1010 &amp; 0xFFFFF000    [0x0FFF在取反时会补足为32位]</span></span><br><span class="line"><span class="comment">//  = 0x1000</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">down2</span> <span class="params">(<span class="type">uint32_t</span> size, <span class="type">uint32_t</span> bound)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size &amp; ~(bound - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保留0x1010中最后的两位[10]，使其得到0x2000</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">up2</span> <span class="params">(<span class="type">uint32_t</span> size, <span class="type">uint32_t</span> bound)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (size + bound - <span class="number">1</span>) &amp; ~(bound - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-6-内存分页机制"><a href="#10-6-内存分页机制" class="headerlink" title="10.6 内存分页机制"></a>10.6 内存分页机制</h2><h3 id="1、分页机制理论基础"><a href="#1、分页机制理论基础" class="headerlink" title="1、分页机制理论基础"></a>1、分页机制理论基础</h3><p>对进程而言，它看到的是多段连续的内存空间；而实际上，其可能由不同的内存页组合而成。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171545775.png" alt="image-20240517154528056" style="zoom:50%;" />

<p>在访问特定的内存地址时，虚拟存储管理部件会自动地根据转换表将其转换到物理内存中的特定位置。</p>
<blockquote>
<p>也就是说，对于一个进程来说，它掌握的是属于自己的这套“线性地址”（逻辑地址），而实际上的内存是分布在对应的“物理地址”中。当该进程想访问自己的地址上编号为“0x1000”处的内容时，会经过一个转换表，将其映射到物理地址上的“0x20000”处。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171548139.png" alt="image-20240517154849803" style="zoom:50%;" />



<p>最简单的实现方法是使用一级转换表，表中存储了进程看到的内存页对应的实际物理内存页的起始地址转换关系。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171630549.png" alt="image-20240517163012208" style="zoom:50%;" />

<blockquote>
<p>在32位地址空间中，总共可以表示<code>2^32</code>个地址，即<code>4GB</code>的内存空间。**<code>4GB</code>的地址空间需要的页表大小是<code>4MB</code>**，分析如下：</p>
<ul>
<li><strong>32位地址空间的表示</strong></li>
</ul>
<ol>
<li>32位地址：一个<code>32</code>位的地址可以表示从 <code>0x00000000</code> 到 <code>0xFFFFFFFF</code>，即<code>2^32</code>个地址。</li>
<li>4GB内存：由于<code>2^32 = 4 * 2^30</code>，这就等于<code>4GB</code>的内存空间。</li>
</ol>
<ul>
<li><strong>分页机制</strong></li>
</ul>
<p>在分页机制中，内存被划分成固定大小的页。常见的页大小是<code>4KB</code>（<code>4096</code>字节）。<code>32</code>位地址分成两部分：页目录和页内偏移。</p>
<ul>
<li><strong>页表的结构</strong></li>
</ul>
<ol>
<li>页大小：<code>4KB = 2^12</code>字节。这意味着地址的低<code>12</code>位用于页内偏移。</li>
<li>页数：剩下的<code>20</code>位（32位 - 12位）用于表示页的索引。</li>
</ol>
<ul>
<li><strong>页表计算</strong></li>
</ul>
<ol>
<li>每个页表条目（PTE, Page Table Entry）通常占<code>4</code>字节（32位）</li>
<li>一个页表可以包含<code>2^10 = 1024</code>个条目（因为页大小为4KB，4KB &#x2F; 4Byte &#x3D; 1024条目）。</li>
</ol>
<ul>
<li><strong>一级页表大小</strong>：要映射整个4GB的内存空间，需要多少页表条目和页表呢？</li>
</ul>
<ol>
<li><p>页的数量：需要映射<code>4GB / 4KB = 2^20</code>个页。</p>
</li>
<li><p>页表的数量：</p>
</li>
</ol>
<ul>
<li>每个页表可以包含<code>1024</code>个页表条目（每个条目映射一个4KB的页）。</li>
<li>因此，需要的页表数量为<code>2^20(pages) / 1024(entries) = 1024(tables)</code>个。</li>
</ul>
<ol start="3">
<li>每个页表的大小：</li>
</ol>
<ul>
<li>每个页表有1024个条目，每个条目4字节：<code>1024(entries) * 4(bytes/entry) = 4KB</code>大小。</li>
</ul>
<ol start="4">
<li>总页表大小：</li>
</ol>
<ul>
<li><p>因此，1024个页表，每个4KB，总的页表空间需求为：</p>
<p><code>1024(tables) * 4KB(per table) = 4MB</code>。</p>
</li>
</ul>
<ul>
<li><strong>结论</strong>：为了存储4GB的内存地址空间所需的一级页表大小为 <strong>4MB</strong>。这包括了1024个页表，每个页表4KB。</li>
</ul>
</blockquote>
<p>因此，经过上述计算可以得知，一级转换表占用的4MB空间太大了，所以使用二级转换表。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171650837.png" alt="image-20240517165038676"></p>
<ul>
<li>第1级处理<code>4MB</code>的内存页的地址映射；</li>
<li>第2级处理<code>4KB</code>的内存页的地址映射。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171655736.png" alt="image-20240517165538461" style="zoom:50%;" />

<ul>
<li><strong>最高的10位</strong>保存对二级页表的索引；</li>
<li><strong>中间的10位</strong>保存相应物理内存页的起始地址；</li>
<li><strong>最低的12位</strong>指明在物理地址中的偏移。</li>
</ul>
<h3 id="2、在loader中开启分页机制"><a href="#2、在loader中开启分页机制" class="headerlink" title="2、在loader中开启分页机制"></a>2、在loader中开启分页机制</h3><p>接下来以一级页表为例进行测试，实现分页机制的打开：</p>
<p>直接进行<code>4MB</code>内存页的转换，以节省页表空间。<em>（注意采用该方式时需要打开<code>CR4</code>寄存器中的<code>PSE</code>位）</em></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171703932.png" alt="image-20240517170308820" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171736358.png" alt="image-20240517173645182" style="zoom: 80%;" />

<p>由于虚拟存储的分页机制存在，操作系统和进程不需要过多考虑实际物理内存的有效地址范围。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171717275.png" alt="image-20240517171749065" style="zoom:50%;" />

<p>在<code>loader</code>中开始分页机制时，需要保持<code>loader</code>中线性地址和物理地址相同，才能保证<code>loader</code>正常运行。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171718785.png" alt="image-20240517171857619" style="zoom:50%;" />

<p>具体涉及到<code>CR3</code>寄存，并将设计的表结构信息传给<code>CR3</code>寄存器。</p>
<ul>
<li>低12位无效。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171722017.png" alt="image-20240517172220845" style="zoom:80%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpu_instr.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取cr3</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">read_cr3</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> cr0;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %%cr3, %[v]&quot;</span>:[v]<span class="string">&quot;=r&quot;</span>(cr0));</span><br><span class="line">    <span class="keyword">return</span> cr0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入cr3</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">write_cr3</span> <span class="params">(<span class="type">uint32_t</span> v)</span> &#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %[v], %%cr3&quot;</span>::[v]<span class="string">&quot;r&quot;</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取cr4</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">read_cr4</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> cr0;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %%cr4, %[v]&quot;</span>:[v]<span class="string">&quot;=r&quot;</span>(cr0));</span><br><span class="line">    <span class="keyword">return</span> cr0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入cr4</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">write_cr4</span> <span class="params">(<span class="type">uint32_t</span> v)</span> &#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %[v], %%cr4&quot;</span>::[v]<span class="string">&quot;r&quot;</span>(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loader.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打开分页机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enable_page_mode</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 页目录表，共1024项，且需对齐到4KB处</span></span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> page_dir[<span class="number">1024</span>] __attribute__((aligned(<span class="number">4096</span>))) = &#123;</span><br><span class="line">        [<span class="number">0</span>] = PDE_P | PDE_W | PDE_PS</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	声明并初始化了一个对齐到4KB边界的页目录表，</span></span><br><span class="line"><span class="comment">        	并设置了第一个页目录项，指向一个4MB的大页，以便实现简单的分页机制。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置CR4 &amp; CR3寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> cr4 = read_cr4(); </span><br><span class="line">    write_cr4(cr4 | CR4_PSE);</span><br><span class="line">    write_cr3((<span class="type">uint32_t</span>)page_dir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置CR0的最高位开启分页机制</span></span><br><span class="line">    write_cr0(read_cr0() | CR0_PG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加载内核</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">load_kernel</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    enable_page_mode();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行调试，可以发现只有第<code>0</code>项当前被设置了。也就是说<code>0-4MB</code>范围的线性地址已经设置好了一个表项，映射到物理地址上的<code>0-4MB</code>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171741544.png" alt="image-20240517174108363" style="zoom:80%;" />

<h2 id="10-7-创建内核页表"><a href="#10-7-创建内核页表" class="headerlink" title="10.7 创建内核页表"></a>10.7 创建内核页表</h2><h3 id="1、代码实现"><a href="#1、代码实现" class="headerlink" title="1、代码实现"></a>1、代码实现</h3><p>分页机制除了能实现地址转换外，还可以实现对内存页的保护。借助这种保护机制，可以实现对操作系统的代码和数据进行保护。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171805215.png" alt="image-20240517180548963" style="zoom:50%;" />



<p>第一级页表的每个表项指向一个二级表，而二级页表的每个表项指向一个真实的物理页。</p>
<ul>
<li><p>二级页表中的第一级页表：</p>
<ul>
<li>注意第<code>1</code>位和第<code>2</code>位。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171807804.png" alt="image-20240517180726661" style="zoom:80%;" />
</li>
<li><p>二级页表中的第二级页表：</p>
<ul>
<li>同样注意第<code>1</code>位和第<code>2</code>位。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171807062.png" alt="image-20240517180747902" style="zoom:80%;" /></li>
</ul>
<p>以下区域设置为可读：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text : &#123;</span><br><span class="line">	*(.text)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">.rodata : &#123;</span><br><span class="line">	*(.rodata)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下区域设置为可读写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.data : &#123;</span><br><span class="line">	*(.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.bss : &#123;</span><br><span class="line">	*(.bss)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROVIDE(mem_free_start = . ); </span><br></pre></td></tr></table></figure>



<ul>
<li><strong>最高的10位</strong>保存对二级页表的索引，获取<code>Page Directory</code>中的对应表项；</li>
<li><strong>中间的10位</strong>保存相应物理内存页的起始地址；</li>
<li><strong>最低的12位</strong>指明在物理地址中的偏移。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171650837.png" alt="image-20240517165038676"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建内核页表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_kernel_table</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> s_text[], e_text[], s_data[];</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> kernel_base[];</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">        &#123;kernel_base, s_text, kernel_base, PTE_W&#125;,</span><br><span class="line">        &#123;s_text, e_text, s_text, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;s_data, (<span class="type">void</span> *)MEM_EBDA_START, s_data, PTE_W&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历kernel_map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(kernel_map) / <span class="keyword">sizeof</span>(<span class="type">memory_map_t</span>); i++) &#123;</span><br><span class="line">        <span class="type">memory_map_t</span> *<span class="built_in">map</span> = kernel_map + i;  <span class="comment">// 取出表项</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将map中的虚拟地址和物理地址进行4KB页边界对齐</span></span><br><span class="line">        <span class="type">uint32_t</span> vstart = down2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vstart, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">uint32_t</span> vend = up2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vend, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">uint32_t</span> pstart = down2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;pstart, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算这块虚拟空间包含的页的个数</span></span><br><span class="line">        <span class="type">int</span> page_count = (vend - vstart) / MEM_PAGE_SIZE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 建立vstart和pstart的映射</span></span><br><span class="line">        memory_create_map(kernel_page_dir, vstart, (<span class="type">uint32_t</span>)pstart, page_count, <span class="built_in">map</span>-&gt;perm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在page_dir中寻找vaddr对应的页表项/PTE</span></span><br><span class="line"><span class="comment"> * @param alloc 若PTE对应的Page Table不存在，是否需要进行分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pte_t</span> *<span class="title function_">find_pte</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取pde表项</span></span><br><span class="line">    <span class="type">pde_t</span> *pde = page_dir + pde_index(vaddr);  </span><br><span class="line">    <span class="type">pte_t</span> *page_table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断pde对应的Page Table是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (pde-&gt;present) &#123;</span><br><span class="line">        <span class="comment">// 若存在，直接获取page_table的物理地址</span></span><br><span class="line">        page_table = (<span class="type">pte_t</span> *)pde_paddr(pde);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，判断是否需要进行分配</span></span><br><span class="line">        <span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">pte_t</span> *)<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从物理页中分配一页内存</span></span><br><span class="line">        <span class="type">uint32_t</span> pg_paddr = addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pg_paddr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">pte_t</span> *)<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对新分配的表进行清空，以防止脏数据并保证安全性</span></span><br><span class="line">        page_table = (<span class="type">pte_t</span> *)pg_paddr;</span><br><span class="line">        kernel_memset(page_table, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        pde-&gt;v = pg_paddr | PDE_P | PDE_W | PDE_U;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page_table + pte_index(vaddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 建立虚拟地址和物理地址间的映射</span></span><br><span class="line"><span class="comment"> * @param page_dir  要建立映射的页表 </span></span><br><span class="line"><span class="comment"> * @param vaddr     虚拟空间起始地址 </span></span><br><span class="line"><span class="comment"> * @param paddr     物理空间起始地址</span></span><br><span class="line"><span class="comment"> * @param count     虚拟空间中包含的页个数 </span></span><br><span class="line"><span class="comment"> * @param perm      相关属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memory_create_map</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">uint32_t</span> paddr, <span class="type">int</span> count, <span class="type">uint32_t</span> perm)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历每一个页表项，建立其对应的映射关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;create map: v-0x%x p-0x%x, perm: 0x%x&quot;</span>, vaddr, paddr, perm);</span><br><span class="line"></span><br><span class="line">        <span class="type">pte_t</span> * pte = find_pte(page_dir, vaddr, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pte == (<span class="type">pte_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;create pte failed. pte == 0&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;             </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建映射的时候，这条pte应当是不存在的。</span></span><br><span class="line">        <span class="comment">// 如果存在，说明可能有问题</span></span><br><span class="line">        log_printf(<span class="string">&quot;\tpte addr: 0x%x&quot;</span>, (<span class="type">uint32_t</span>)pte);</span><br><span class="line">        <span class="comment">// 找到了对应的页表项/PTE</span></span><br><span class="line">        ASSERT(pte-&gt;present == <span class="number">0</span>);  <span class="comment">// 此时的present位应为0</span></span><br><span class="line">        pte-&gt;v = paddr | perm | PTE_P;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到下一个地址</span></span><br><span class="line">        vaddr += MEM_PAGE_SIZE;</span><br><span class="line">        paddr += MEM_PAGE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *<span class="title function_">find_pte</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    page_table = (<span class="type">pte_t</span> *)pg_paddr;</span><br><span class="line">    kernel_memset(page_table, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么要初始化?</li>
</ul>
<ol>
<li><strong>防止脏数据</strong>: 分配新的页表页后，该页表页中的内容可能包含先前分配但未清除的数据。初始化页表页（即清零）确保所有 PTE（页表项）都是空的，没有设置任何标志位或地址。</li>
<li><strong>安全性</strong>: 避免访问到未初始化的内存，防止潜在的安全漏洞。例如，未初始化的 PTE 可能指向随机地址，这会导致页错误或者其他意外行为。</li>
<li><strong>正确性</strong>: 页表页中的每个 PTE 都需要按照预期进行初始化。初始化保证了新分配的页表页在开始时不包含任何有效的映射，只有在后续显式设置时才包含有效映射。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182044761.png" alt="image-20240518204404435"></p>
<h3 id="2、代码调试"><a href="#2、代码调试" class="headerlink" title="2、代码调试"></a>2、代码调试</h3><p>在<code>qemu</code>中执行<code>info mem</code>为空，正确的话应该打印开启分页机制后的虚拟地址与物理地址的映射。此时为空说明分页机制已被打开，但所有的页表全为无效。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182052909.png" alt="image-20240518205244786"></p>
<p>原因分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在page_dir中寻找vaddr对应的页表项/PTE</span></span><br><span class="line"><span class="comment"> * @param alloc 若PTE对应的Page Table不存在，是否需要进行分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pte_t</span> *<span class="title function_">find_pte</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    	...</span><br><span class="line">        <span class="comment">// 对新分配的表进行清空，以防止脏数据并保证安全性</span></span><br><span class="line">        page_table = (<span class="type">pte_t</span> *)pg_paddr;</span><br><span class="line">        kernel_memset(page_table, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br><span class="line">    	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是对新分配的表进行清空，并没有建立pde表项，并没有建立<code>pde</code>与<code>page_table</code>之间的关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pde-&gt;v = pg_paddr | PDE_P;</span><br></pre></td></tr></table></figure>

<p>加上这一行后重新调试，发现最后两项存在问题。虚拟地址相同，但物理地址并没有实现页边界对齐。</p>
<p>因此需要对物理地址也进行页边界对齐。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182058011.png" alt="image-20240518205852888"></p>
<p>在以下函数中进行修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建内核页表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_kernel_table</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> s_text[], e_text[], s_data[];</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> kernel_base[];</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">        &#123;kernel_base, s_text, kernel_base, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;s_text, e_text, s_text, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;s_data, (<span class="type">void</span> *)MEM_EBDA_START, s_data, <span class="number">0</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历kernel_map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(kernel_map) / <span class="keyword">sizeof</span>(<span class="type">memory_map_t</span>); i++) &#123;</span><br><span class="line">        <span class="type">memory_map_t</span> *<span class="built_in">map</span> = kernel_map + i;  <span class="comment">// 取出表项</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将map中的虚拟地址和物理地址进行4KB页边界对齐</span></span><br><span class="line">        <span class="type">uint32_t</span> vstart = down2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vstart, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">uint32_t</span> vend = up2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vend, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">uint32_t</span> pstart = down2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;pstart, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算这块虚拟空间包含的页的个数</span></span><br><span class="line">        <span class="type">int</span> page_count = (vend - vstart) / MEM_PAGE_SIZE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 建立vstart和pstart的映射</span></span><br><span class="line">        <span class="comment">// memory_create_map(kernel_page_dir, vstart, (uint32_t)map-&gt;pstart, page_count, map-&gt;perm);</span></span><br><span class="line">        memory_create_map(kernel_page_dir, vstart, (<span class="type">uint32_t</span>)pstart, page_count, <span class="built_in">map</span>-&gt;perm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后出现以下结果，发现最后错误地出现了两个相同的项，导致在<code>memory_create_map()</code>中判断<code>ASSERT(pte-&gt;present == 0);</code> 时出错。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182102316.png" alt="image-20240518210246033"></p>
<p>经排查，这个错误和链接脚本的设置有关。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	PROVIDE(kernel_base = .);</span><br><span class="line">    . = <span class="number">0x10000</span>;</span><br><span class="line"></span><br><span class="line">	PROVIDE(s_text = .); </span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text)</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		*(.rodata)</span><br><span class="line">	&#125;</span><br><span class="line">	PROVIDE(e_text = .); </span><br><span class="line"></span><br><span class="line">	PROVIDE(s_data = .);   &lt;==== .data未页边界对齐</span><br><span class="line">	.data : &#123;</span><br><span class="line">		*(.data)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.bss : &#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROVIDE(mem_free_start = . ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在<code>kernel_elf.txt</code>文件中，<code>.data section</code>的起始地址并非是页边界对齐（<code>4KB</code>）的，因此会在后续产生页表项重复的情况。</p>
<p>详细来说，<code>.data</code>段的起始地址未对齐到页边界，会导致两个问题：</p>
<ol>
<li><strong>页表项重复</strong>： 当页表项映射未对齐的数据段时，一个页表项可能会覆盖两个不同的物理页。这会导致映射冲突，页表项出现重复或无效。</li>
<li><strong>访问异常</strong>： 未对齐的数据段会引起内存访问异常，因为在一个页中可能包含多个段的数据，导致不同的页表项映射到同一物理地址。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182107831.png" alt="image-20240518210723714"></p>
<p>因此，对链接脚本修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">. = ALIGN(<span class="number">4096</span>);   &lt;==== 加入这一行</span><br><span class="line">PROVIDE(s_data = .); </span><br><span class="line">.data : &#123;</span><br><span class="line">	*(.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时重新编译后，<code>.data section</code>的起始地址如下：<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182124084.png" alt="image-20240518212455979"></p>
<p>经过上述修改，<code>info mem</code>就有输出了：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182125920.png" alt="image-20240518212541791"></p>
<h3 id="3、权限设置"><a href="#3、权限设置" class="headerlink" title="3、权限设置"></a>3、权限设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">    &#123;kernel_base, s_text, kernel_base, PTE_W&#125;,</span><br><span class="line">    &#123;s_text, e_text, s_text, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;s_data, (<span class="type">void</span> *)MEM_EBDA_START, s_data, PTE_W&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码为操作系统访问的代码，因此第<code>2</code>位权限位设置为<code>0</code>，即<code>supervisor</code>；</p>
</li>
<li><p>此外，还要设置第<code>3</code>位，确定是只读还是可读写。由于采用的结构是二级表，因此每个表都有针对自己这个表的权限设置。对于<code>PTE</code>表项来说，在上述代码中设置<code>PTE_W</code>即可确定可读写；而对于<code>PDE</code>表项来说，在此处（<code>find_pte()</code>中）设置可读写以及用户可访问：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pde-&gt;v = pg_paddr | PDE_P | PDE_W | PDE_U;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>设置完权限后，<code>info mem</code>的信息更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182149317.png" alt="image-20240518214839313"></p>
<h2 id="10-8-为进程创建页表"><a href="#10-8-为进程创建页表" class="headerlink" title="10.8 为进程创建页表"></a>10.8 为进程创建页表</h2><h3 id="1、问题说明"><a href="#1、问题说明" class="headerlink" title="1、问题说明"></a>1、问题说明</h3><p>此时这个程序存在下列问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init.c </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    task_init(&amp;sub_task, <span class="string">&quot;sub task&quot;</span>, (<span class="type">uint32_t</span>)init_task_entry, (<span class="type">uint32_t</span>)&amp;init_task_stack[<span class="number">1024</span>]);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行到第<code>3</code>行的代码时，CPU会重启。进入这一行代码的内部进行调试，可以发现问题出在切换<code>TSS</code>的时刻。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Task Switch </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_switch_from_to</span> <span class="params">(<span class="type">task_t</span> *from, <span class="type">task_t</span> *to)</span> &#123;</span><br><span class="line">    switch_to_tss(to-&gt;tss_sel);</span><br><span class="line">    <span class="comment">// simple_switch(&amp;from-&gt;stack, to-&gt;stack);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远跳转</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">far_jump</span> <span class="params">(<span class="type">uint32_t</span> selector, <span class="type">uint32_t</span> offset)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> addr[] = &#123;offset, selector&#125;;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;ljmpl *(%[a])&quot;</span>::[a]<span class="string">&quot;r&quot;</span>(addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为每个进程的TSS结构中均有一个<code>CR3</code>字段，以允许每个进程拥有自己的页表。进程会从这个<code>CR3</code>字段中取出页表的起始地址并加载到实际的<code>CR3</code>寄存器中，也就是说切换到进程实际的页表。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182200116.png" alt="image-20240518220044967" style="zoom:80%;" />

<p>此外，需要借助保护机制来实现对操作系统的代码和数据的保护。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182202640.png" alt="image-20240518220254434" style="zoom:50%;" />

<p>两个进程运行起来之后，会共享<code>0x00000000~0x80000000</code>这部分的空间，也即操作系统代码。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182208681.png" alt="image-20240518220857411" style="zoom:50%;" />



<h3 id="2、代码实现-3"><a href="#2、代码实现-3" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpu.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放GDT表项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gdt_free_sel</span><span class="params">(<span class="type">int</span> sel)</span> &#123;</span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    gdt_table[sel/<span class="keyword">sizeof</span>(<span class="type">segment_desc_t</span>)].attr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建进程自己的页表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">memory_create_uvm</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 分配一页内存给Page Directory</span></span><br><span class="line">    <span class="type">pde_t</span> *page_dir = (<span class="type">pde_t</span> *)addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (page_dir == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对第一级页表进行清空</span></span><br><span class="line">    <span class="comment">// 不需要对第二级页表进行清空是因为loader_32.c中执行了清零操作</span></span><br><span class="line">    kernel_memset((<span class="type">void</span> *)page_dir, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户进程PDE的开始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> user_pde_start = pde_index(MEM_TASK_BASE);</span><br><span class="line">    <span class="comment">// 为了实现多个进程间共享操作进程代码，遍历从低1MB空间的所有页表（操作系统部分）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; user_pde_start; i++) &#123;</span><br><span class="line">        <span class="comment">// 由于多个进程间操作系统部分的映射关系是一致的，如果要为这一部分的每一项都分配一个PTE页表，会造成内存浪费</span></span><br><span class="line">        <span class="comment">// 因此此处直接使用操作系统在0x0-0x7FFFFFFF的空间内配置的PTE表即可，即实现了多个进程间的映射共享</span></span><br><span class="line">        page_dir[i].v = kernel_page_dir[i].v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)page_dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>此时进行调试，会在<code>memory_create_uvm()</code>的这一步出错：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel_memset((<span class="type">void</span> *)page_dir, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br></pre></td></tr></table></figure>

<p>通过查看此时<code>QEMU</code>的内存映射关系可以得知，此时仅配置了<code>1MB</code>以下的内存关系的映射，而没有配置<code>1MB</code>以上的内存关系映射，但分配的<code>page_dir</code>的地址为<code>0x101000</code>，也就是说<code>QEMU</code>不知道该写到哪里。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191451190.png" alt="image-20240519145138077"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191451670.png" alt="image-20240519145108455"></p>
<p>因此需要对物理地址<code>0x101000</code>也进行一个映射，以获取其线性地址。</p>
<p>因此，对<code>kernel_map[]</code>进行改写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_EXT_START       (1024 * 1024)           <span class="comment">// 扩展内存的起始地址，从1MB（实模式内存限制）开始</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_EXT_END         (128 * 1024 * 1024)     <span class="comment">// 扩展内存的结束地址，目前只给QEMU分配了128M内存</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.c </span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">    &#123;kernel_base, s_text, kernel_base, PTE_W&#125;,</span><br><span class="line">    &#123;s_text, e_text, s_text, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;s_data, (<span class="type">void</span> *)MEM_EBDA_START, s_data, PTE_W&#125;,</span><br><span class="line">    &#123;(<span class="type">void</span> *)MEM_EXT_START, (<span class="type">void</span> *)MEM_EXT_END, (<span class="type">void</span> *)MEM_EXT_START, PTE_W&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="十一、隔离操作系统与进程"><a href="#十一、隔离操作系统与进程" class="headerlink" title="十一、隔离操作系统与进程"></a>十一、隔离操作系统与进程</h1><h2 id="11-1-隔离操作系统与进程"><a href="#11-1-隔离操作系统与进程" class="headerlink" title="11.1 隔离操作系统与进程"></a>11.1 隔离操作系统与进程</h2><p>目前所以进程（共3个）的代码和数据全部位于操作系统中，可以适当进行分离。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191512628.png" alt="image-20240519151246404" style="zoom:50%;" />

<p>主要实现以下三步：</p>
<blockquote>
<ol>
<li>建立进程的运行空间；</li>
<li>代码拷贝至指定区域；</li>
<li>从操作系统跳转至进程运行。</li>
</ol>
</blockquote>
<h3 id="1、代码分离"><a href="#1、代码分离" class="headerlink" title="1、代码分离"></a>1、代码分离</h3><blockquote>
<p><strong>实现方式：</strong>只需要单独新建一个文件把代码放进去，就可以实现代码分离。</p>
</blockquote>
<p>（1）首先，删除前序测试使用的<code>sub_task()</code>，并且为<code>first_task()</code>新建一个单独的<code>.c</code>文件，使得其在编译时在<code>/kernel</code>中得到一个单独的文件，而不是在<code>init.c</code>中一起编译。这样在后续进行代码拷贝时就会方便很多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first_task.c</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;core/task.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;first task.&quot;</span>);</span><br><span class="line">        sys_sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// first_task_entry.S</span><br><span class="line"></span><br><span class="line">	.text</span><br><span class="line">	.global first_task_entry</span><br><span class="line">	.extern first_task_main</span><br><span class="line">first_task_entry:</span><br><span class="line">    // 进程运行前，操作系统会为其初始化SS寄存器和CS寄存器</span><br><span class="line">	mov %ss, %ax</span><br><span class="line">	mov %ax, %ds</span><br><span class="line">	mov %ax, %es</span><br><span class="line">	mov %ax, %fs</span><br><span class="line">	mov %ax, %gs</span><br><span class="line">    // 跳转至32位的C环境运行</span><br><span class="line">	jmp first_task_main</span><br></pre></td></tr></table></figure>

<p>（2）更新<code>kernel/CMakeLists.txt</code>文件，在末尾加上<code>*.S</code>，从而完成对<code>first_task_entry.S</code>的编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB_RECURSE C_LIST &quot;*.c&quot; &quot;*.h&quot; &quot;*.S&quot;)</span><br></pre></td></tr></table></figure>

<p>（3）更新<code>first_task</code>的页表为自己的页表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置好first_task执行的入口函数，并修改对应的task_init中的entry参数为first_start</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">first_task_entry</span> <span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 声明入口函数</span></span><br><span class="line">    <span class="type">uint32_t</span> first_start = (<span class="type">uint32_t</span>)first_task_entry;  <span class="comment">// 获取入口函数地址</span></span><br><span class="line"></span><br><span class="line">    task_init(&amp;task_manager.first_task, <span class="string">&quot;first task&quot;</span>, first_start, <span class="number">0</span>);  <span class="comment">// Task Initialization</span></span><br><span class="line">    write_tr(task_manager.first_task.tss_sel);  <span class="comment">// 对TR寄存器初始化</span></span><br><span class="line">    task_manager.curr_task = &amp;task_manager.first_task;  <span class="comment">// 设置当前任务为first task </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换页表为进程自己的页表</span></span><br><span class="line">    mmu_set_page_dir(task_manager.first_task.tss.cr3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）实现代码跳转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从操作进程跳转到用户进程代码 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_to_first_task</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    ASSERT(curr != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出当前任务的tss中的eip字段，获取入口地址</span></span><br><span class="line">    <span class="type">tss_t</span> *tss = &amp;(curr-&gt;tss);</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        <span class="string">&quot;jmp *%[ip]&quot;</span>::[ip]<span class="string">&quot;r&quot;</span>(tss-&gt;eip)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化first_task，并跳转到进程代码中运行</span></span><br><span class="line">    task_first_init();</span><br><span class="line">    move_to_first_task();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）运行结果：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191559496.png" alt="image-20240519155930343"></p>
<p>从上图可以看到此时<code>first_task</code>的入口地址在<code>0x11b09</code>，依旧在<code>1MB</code>以下。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191556008.png" alt="image-20240519155627657"></p>
<h3 id="2、地址分离"><a href="#2、地址分离" class="headerlink" title="2、地址分离"></a>2、地址分离</h3><blockquote>
<p><strong>目标：</strong></p>
<p>1）告诉<code>first_task</code>应该到<code>0x80000000</code>以上的地址去运行；</p>
<p>2）但在存储时是和操作系统一起存放在<code>0x0-0x7FFFFFFF</code>的地址空间内。</p>
<p><strong>实现方式：</strong>在链接脚本<code>kernel.lds</code>中进行修改。</p>
</blockquote>
<ul>
<li><strong>相关理论基础：</strong></li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191611562.png" alt="image-20240519161104805" style="zoom:50%;" />

<ul>
<li>物理地址为存储地址；</li>
<li>虚拟地址为运行地址。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191611577.png" alt="image-20240519161116895" style="zoom: 50%;" />

<p>而在<code>kernel.lds</code>文件中，<code>. = 0x100000</code>实际上设置的是虚拟地址，也就是运行地址。这样的结果就是<code>paddr</code>和<code>vaddr</code>设置为一样的，因此在加载时kernel也会从这个地址上去加载。</p>
<p><strong>现在要做的就是：</strong></p>
<p><strong>1）告诉<code>first_task</code>应该到<code>0x80000000</code>以上的地址去运行；</strong></p>
<p><strong>2）但在存储时是和操作系统一起存放在<code>0x0-0x7FFFFFFF</code>的地址空间内。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191615645.png" alt="image-20240519161519963"></p>
<p>因此，可在链接脚本中分别指定段的加载地址和运行地址。当仅指定运行地址时，加载地址与运行地址相同。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191616105.png" alt="image-20240519161650286"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.data 0x2000: AT(ADDR(.text) +SIZEOF(.text))</span><br></pre></td></tr></table></figure>

<p>这一行的意思就是说：<code>.data</code>的运行地址为<code>0x2000</code>，但其存储的物理地址在（<code>AT</code>）<code>.text</code>的相邻处。</p>
<ul>
<li><strong>代码实现：</strong></li>
</ul>
<p><code>kernel_elf.txt</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191621670.png" alt="image-20240519162150219"></p>
<p>上图中的<code>VirtualAddr</code>和<code>PhysAddr</code>一致，且分别对应<code>.text/.rodata</code>和<code>.data/.bss</code>两部分。</p>
<p>（1）告诉<code>first_task</code>应该到<code>0x80000000</code>以上的地址去运行；</p>
<p>修改链接脚本<code>kernel.lds</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	. = 0x80000000;</span><br><span class="line">	.first_task : &#123;</span><br><span class="line">		*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">		*first_task*(.text .rodata .bss .data)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROVIDE(mem_free_start = . ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，<code>ELF</code>文件的<code>Program Header Table</code>表项会更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191631851.png" alt="image-20240519163152388"></p>
<p>（2）但此时存在一个问题</p>
<p>在<code>loader</code>加载时会扫描上图这个表，并根据每个表项的具体内容进行加载。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Elf32_Phdr *phdr = (Elf32_Phdr *)(file_buffer + elf_hdr-&gt;e_phoff) + i;  <span class="comment">// 偏移量：elf_hdr-&gt;e_phoff</span></span><br></pre></td></tr></table></figure>

<p>也即上图中的<code>Offset</code>和<code>PhysAddr</code>两项。但由于<code>0x80000000</code>这个物理地址是不存在的，因此加载会失败。所以需要将<code>first_task</code>的物理地址修改为比<code>.data/.bss</code>的物理地址大一些的地址即可。</p>
<p>取<code>Segment 01</code>的虚拟地址即可（因为<code>00</code>和<code>01</code>段的虚拟地址与物理地址的映射是对应的）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">e_data = .;</span><br><span class="line"></span><br><span class="line">. = 0x80000000;</span><br><span class="line">.first_task : AT(e_data) &#123;</span><br><span class="line">	*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">	*first_task*(.text .rodata .bss .data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时就完成了物理地址的修改：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191648559.png" alt="image-20240519164849109"></p>
<p>（3）此外，对于<code>mem_free_start</code>也需要进行相应的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">. = 0x80000000;</span><br><span class="line">.first_task : AT(e_data) &#123;</span><br><span class="line">*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">*first_task*(.text .rodata .bss .data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROVIDE(mem_free_start = . ); </span><br></pre></td></tr></table></figure>

<p>此时它在<code>kernel_elf.txt</code>中显示的物理地址为：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191651929.png" alt="image-20240519165112540"></p>
<p>这是因为加入<code>(2)</code>中的系列修改后，会改变它的地址。但这个地址实际上应该指向位图缓存的起始地址，如下图所示，也就是说应该在<code>1MB以下</code>的范围内：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171455366.png" alt="image-20240517145539043"></p>
<p>所以，进行如下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">. = 0x80000000;</span><br><span class="line">.first_task : AT(e_data) &#123;</span><br><span class="line">	*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">	*first_task*(.text .rodata .bss .data)</span><br><span class="line">&#125;</span><br><span class="line">e_first_task = LOADADDR(.first_task) + SIZEOF(.first_task);</span><br><span class="line"></span><br><span class="line">PROVIDE(mem_free_start = e_first_task); </span><br></pre></td></tr></table></figure>

<p>这样位图缓存的地址就修改正确：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191655562.png" alt="image-20240519165543113"></p>
<h3 id="3、代码搬运"><a href="#3、代码搬运" class="headerlink" title="3、代码搬运"></a>3、代码搬运</h3><blockquote>
<p><strong>实现方式：</strong></p>
<p>1）找到first_task在物理空间的起始和结束地址；</p>
<p>2）在虚拟空间分配相应的内存空间；</p>
<p>3）进行代码搬运。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191657728.png" alt="image-20240519165724091" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">memory_alloc_page_for_page_dir</span> <span class="params">(<span class="type">uint32_t</span> page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">uint32_t</span> size, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录当前vaddr（运行地址，所以是虚拟地址）</span></span><br><span class="line">    <span class="type">uint32_t</span> curr_vaddr = vaddr;</span><br><span class="line">    <span class="comment">// 计算分配页的数量，注意页边界对齐</span></span><br><span class="line">    <span class="type">int</span> page_count = up2(size, MEM_PAGE_SIZE) / MEM_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐页分配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; page_count; i++) &#123;</span><br><span class="line">        <span class="comment">// 从物理内存中分配一页</span></span><br><span class="line">        <span class="type">uint32_t</span> paddr = addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (paddr == <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;mem alloc failed, no memory!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立物理内存和虚拟内存的映射关系</span></span><br><span class="line">        <span class="type">int</span> err = memory_create_map((<span class="type">pde_t</span> *)page_dir, curr_vaddr, paddr, <span class="number">1</span>, perm);</span><br><span class="line">        <span class="keyword">if</span> (paddr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 若建立当前映射失败，则释放当前已建立映射的页，因此addr_free_page传入vaddr</span></span><br><span class="line">            <span class="comment">// 这里不能传入paddr，因为这个paddr只是当前循环下分配的这一页的起始物理地址</span></span><br><span class="line">            log_printf(<span class="string">&quot;create memory failed, crr = %d.&quot;</span>, err);</span><br><span class="line">            addr_free_page(&amp;paddr_alloc, vaddr, i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 此外，可以实现虚拟和物理映射的断开，此处并未实现</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到下一个虚拟地址</span></span><br><span class="line">        curr_vaddr += MEM_PAGE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">memory_alloc_page_for</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> size, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> memory_alloc_page_for_page_dir(task_current()-&gt;tss.cr3, addr, size, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191729446.png" alt="image-20240519172917244"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191729964.png" alt="image-20240519172948838"></p>
<p>执行代码拷贝后，显示如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一页内存供代码存放使用，然后将代码复制过去</span></span><br><span class="line">memory_alloc_page_for(first_start, alloc_size, PTE_P | PTE_W);</span><br><span class="line">kernel_memcpy((<span class="type">void</span> *)first_start, (<span class="type">void</span> *)s_first_task, copy_size);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191730041.png" alt="image-20240519173019470"></p>
<p>查看对应的反汇编，和<code>first_task_entry.S</code>中的内容一致：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191731972.png" alt="image-20240519173119400"></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191731182.png" alt="image-20240519173158224" style="zoom: 80%;" />

<h2 id="11-2-调整应用的特权级"><a href="#11-2-调整应用的特权级" class="headerlink" title="11.2 调整应用的特权级"></a>11.2 调整应用的特权级</h2><h3 id="1、x86芯片的特权级定义"><a href="#1、x86芯片的特权级定义" class="headerlink" title="1、x86芯片的特权级定义"></a>1、x86芯片的特权级定义</h3><p>x86芯片支持四种特权级：</p>
<ul>
<li>第0级权限最高，用于运行操作系统；</li>
<li>第3级权限最低，用于运行应用程序；</li>
<li>其它两级用于运行操作系统服务(可选)。</li>
</ul>
<p>对于某个特权级来说：只允许访问相同或更低权限的代码或数据。通过这种特权分级的机制可以防止低特权级代码随意访问敏感数据或代码，如开关中断、写磁盘等。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191916522.png" alt="image-20240519191609991"></p>
<ol>
<li><p>数据段访问相关的3种与权限相关的配置位：</p>
<ul>
<li><p>段描述符<code>DPL</code>(Descriptor privilege level(DPL))，定义哪个特权级别的代码可以访问这个段。</p>
</li>
<li><p>选择子<code>RPL</code>(Requested privilege level(RPL))，表示请求访问段的特权级别。</p>
</li>
<li><p>段寄存器<code>CS</code>中的<code>CPL</code>(Current privilege level)，表示当前执行代码的特权级别。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>访问**数据段(<code>DS,ES,FS,GS</code>)**时，仅当<code>DPL&gt;= Max(CPL,RPL)</code>时才能访问。</p>
<p>当**访问<code>SS</code>**时，要求<code>CPL=DPL=RPL</code>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191919839.png" alt="image-20240519191939329"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191920132.png" alt="image-20240519192009659"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191920272.png" alt="image-20240519192046797"></p>
<p>对于访问权限，要求1）自身的权限要足够高；2）自己不能主动把权限放低。<strong>权限错误将产生段保护异常。</strong></p>
<p>如下图<code>CPL=0, RPL=3, DPL=2</code>这条线，就属于自己主动把权限放低了，因此也无法正确访问。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191931168.png" alt="image-20240519193151363"></p>
<ol start="2">
<li><p>代码段访问相关的3种与权限相关的配置位：</p>
<ul>
<li><p>段描述符<code>DPL</code>(Descriptor privilege level(DPL))和<code>C</code>位，定义哪个特权级别的代码可以访问这个段。</p>
</li>
<li><p>选择子<code>RPL</code>(Requested privilege level(RPL))，表示请求访问段的特权级别。</p>
</li>
<li><p>段寄存器<code>CS</code>中的<code>CPL</code>(Current privilege level)，表示当前执行代码的特权级别。</p>
</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191934137.png" alt="image-20240519193438668"></p>
<ul>
<li><p>访问非一致代码段时(<code>C=0</code>)，<code>CPL=DPL，且RPL&lt;=CPL</code>，即权限要一样。</p>
</li>
<li><p>访问一致性代码段时(<code>C=1</code>)到，要求<code>CPL&gt;=DPL，RPL不检查</code>，即访问者的权限要与被访问的代码权限相等或更低<strong>（但本项目未用到，因为不允许随便访问高权限的代码）</strong>。</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191936035.png" alt="image-20240519193654339" style="zoom: 50%;" />

<h3 id="2、平坦模型如何实现保护"><a href="#2、平坦模型如何实现保护" class="headerlink" title="2、平坦模型如何实现保护"></a>2、平坦模型如何实现保护</h3><p>对于本项目来说，由于采用了平坦模型，因此分段保护做不到真正的保护，实际上都写入了<code>0x0~0xFFFFFFFF</code>的空间。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191938454.png" alt="image-20240519193841332" style="zoom:50%;" />

<p>因此，结合分页机制进行保护。简化处理，操作系统运行于特权级<code>0</code>，应用进程运行于特权级<code>3</code>。全部使用非一致性代码段，<code>CPL=RPL</code>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191940126.png" alt="image-20240519194030428" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191940436.png" alt="image-20240519194056411" style="zoom:50%;" />

<h3 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_manager_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> app_code_sel;   <span class="comment">// 进程的代码段选择子</span></span><br><span class="line">    <span class="type">int</span> app_data_sel;   <span class="comment">// 进程的数据段选择子</span></span><br><span class="line">&#125;<span class="type">task_manager_t</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief TSS Initialization，当有程序/进程第一次运行时会调用tss_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tss_init</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 根据不同的权限选择不同的访问选择子</span></span><br><span class="line">    <span class="type">int</span> code_sel, data_sel;</span><br><span class="line">    code_sel = task_manager.app_code_sel | SEG_CPL3;</span><br><span class="line">    data_sel = task_manager.app_data_sel | SEG_CPL3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置TSS的相关字段</span></span><br><span class="line">    task-&gt;tss.eip = entry;  <span class="comment">// 调用tss_init的函数的入口地址（该函数第一次运行）</span></span><br><span class="line">    task-&gt;tss.esp = task-&gt;tss.esp0 = esp;  <span class="comment">// 指示调用tss_init的函数的栈顶的位置（此时栈为空）</span></span><br><span class="line">    task-&gt;tss.ss = task-&gt;tss.ss0 = data_sel;</span><br><span class="line">    task-&gt;tss.es = task-&gt;tss.ds = task-&gt;tss.fs = task-&gt;tss.gs = data_sel;</span><br><span class="line">    task-&gt;tss.cs = code_sel;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 任务管理器初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 设定任务数据段和代码段的特权级</span></span><br><span class="line">    <span class="type">int</span> sel = gdt_alloc_desc();</span><br><span class="line">    segment_desc_set(sel, <span class="number">0x00000000</span>, <span class="number">0xFFFFFFFF</span>,</span><br><span class="line">        SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D);</span><br><span class="line">    task_manager.app_data_sel = sel;</span><br><span class="line"></span><br><span class="line">    sel = gdt_alloc_desc();</span><br><span class="line">    segment_desc_set(sel, <span class="number">0x00000000</span>, <span class="number">0xFFFFFFFF</span>,</span><br><span class="line">        SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL | SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D);</span><br><span class="line">    task_manager.app_code_sel = sel;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时进行调试，可以看到相应的段寄存器的值：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191955719.png" alt="image-20240519195526886"></p>
<p>这些值实际上的内核初始化时在<code>cpu_init()</code>中通过下面的代码设置的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化GDT表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 设计平坦模式下的代码段与数据段</span></span><br><span class="line">    <span class="comment">// 注意第#0号表项需要保留，不能使用</span></span><br><span class="line">    segment_desc_set(KERNEL_SELECTOR_DS, <span class="number">0</span>, <span class="number">0xFFFFFFFF</span>, </span><br><span class="line">        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA</span><br><span class="line">        | SEG_TYPE_RW | SEG_D</span><br><span class="line">    );</span><br><span class="line">    segment_desc_set(KERNEL_SELECTOR_CS, <span class="number">0</span>, <span class="number">0xFFFFFFFF</span>, </span><br><span class="line">        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE</span><br><span class="line">        | SEG_TYPE_RW | SEG_D</span><br><span class="line">    );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此说明此时<code>first_task</code>依旧是运行在特权级<code>0</code>的状态下。这是因为整个系统从内核加载、解析，一直到运行<code>first_task</code>时并没有对<code>TSS</code>的相关设置，只是对<code>TSS</code>进行了相应的初始化。</p>
<p>当进行第一次任务切换，由于运行了<code>sys_sleep()</code>函数，因此切换到<code>idle_task</code>时，相应的寄存器值就发生了改变。可以看到<code>CS</code>的低<code>2</code>位变成了<code>特权级3</code>，也就是说空闲任务运行在<code>特权级3</code>上。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192010866.png" alt="image-20240519201046181"></p>
<p>此时若按下<code>F11</code>，会发生异常。这是因为<code>idle_task</code>相关的代码是和操作系统代码绑定在一起编译的，存储在<code>1MB以下</code>的内存区域，而根据映射关系可知，这部分的<code>U/S</code>位是设置为<code>0</code>的，也就是用户特权级无法访问，但<code>idle_task</code>又处在用户级特权，相当于这里按照权限3去执行权限0的代码，因此发生了权限错误。</p>
<blockquote>
<p>目前存在的问题：</p>
<p><code>first_task</code>运行在权限级<code>0</code>，而<code>idle_task</code>反而运行在了权限级<code>3</code>，在后续应该对其进行调换。</p>
</blockquote>
<h2 id="11-3-调整异常处理函数"><a href="#11-3-调整异常处理函数" class="headerlink" title="11.3 调整异常处理函数"></a>11.3 调整异常处理函数</h2><h3 id="1、修改TSS字段初始化"><a href="#1、修改TSS字段初始化" class="headerlink" title="1、修改TSS字段初始化"></a>1、修改TSS字段初始化</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192018702.png" alt="image-20240519201803678"></p>
<p>当存在特权级变化时，若特权级<code>3</code>的程序&#x2F;任务发生了异常，则异常处理程序（<code>DPL=0</code>）不应在发生异常的那个栈中压入，而应该单独压入另一个特级为<code>0</code>的栈中。</p>
<p>针对<code>11.2</code>中的最后提出的问题，需要对<code>tss</code>初始化中的相关字段设置进行更改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task-&gt;tss.ss = task-&gt;tss.ss0 = data_sel;</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task-&gt;tss.ss0 = KERNEL_SELECTOR_DS;</span><br><span class="line">task-&gt;tss.ss = data_selc;</span><br></pre></td></tr></table></figure>

<p>此时就可以成功的跳转到<code>Page Fault Exception</code>异常中：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192048487.png" alt="image-20240519204839152"></p>
<h3 id="2、修改异常处理函数"><a href="#2、修改异常处理函数" class="headerlink" title="2、修改异常处理函数"></a>2、修改异常处理函数</h3><ul>
<li><p><code>do_handler_page_fault()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_handler_page_fault</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	    log_printf(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;IRQ/Exception happend: Page fault.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_PAGE_P) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tpage-level protection violation: 0x%x.&quot;</span>, read_cr2());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tPage doesn&#x27;t present 0x%x&quot;</span>, read_cr2());</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_PAGE_WR) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tThe access causing the fault was a read.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tThe access causing the fault was a write.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_PAGE_US) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tA supervisor-mode access caused the fault.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tA user-mode access caused the fault.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dump_core_regs(frame);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        hlt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>do_handler_general_protection</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_handler_general_protection</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;IRQ/Exception happend: General Protection.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_EXT) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;the exception occurred during delivery of an &quot;</span></span><br><span class="line">                <span class="string">&quot;event external to the program, such as an interrupt&quot;</span></span><br><span class="line">                <span class="string">&quot;or an earlier exception.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;the exception occurred during delivery of a&quot;</span></span><br><span class="line">                    <span class="string">&quot;software interrupt (INT n, INT3, or INTO).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_IDT) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;the index portion of the error code refers &quot;</span></span><br><span class="line">                    <span class="string">&quot;to a gate descriptor in the IDT&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;the index refers to a descriptor in the GDT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    log_printf(<span class="string">&quot;segment index: %d&quot;</span>, frame-&gt;error_code &amp; <span class="number">0xFFF8</span>);</span><br><span class="line"></span><br><span class="line">    dump_core_regs(frame);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        hlt();</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>修改后打印的异常信息更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192103797.png" alt="image-20240519210348190"></p>
<h2 id="11-4-修改空闲任务的特权级"><a href="#11-4-修改空闲任务的特权级" class="headerlink" title="11.4 修改空闲任务的特权级"></a>11.4 修改空闲任务的特权级</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192104590.png" alt="image-20240519210438905"  />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief TSS Initialization，当有程序/进程第一次运行时会调用tss_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tss_init</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">int</span> flags, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 根据不同的权限选择不同的访问选择子</span></span><br><span class="line">    <span class="type">int</span> code_sel, data_sel;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; TASK_FLAGS_SYSTEM) &#123;</span><br><span class="line">        <span class="comment">// 系统权限</span></span><br><span class="line">        code_sel = KERNEL_SELECTOR_CS;</span><br><span class="line">        data_sel = KERNEL_SELECTOR_DS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用户权限</span></span><br><span class="line">        code_sel = task_manager.app_code_sel | SEG_CPL3;</span><br><span class="line">        data_sel = task_manager.app_data_sel | SEG_CPL3;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 任务管理器初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">// 空闲任务初始化</span></span><br><span class="line">    task_init(&amp;task_manager.idle_task,</span><br><span class="line">        <span class="string">&quot;idle_task&quot;</span>,</span><br><span class="line">        TASK_FLAGS_SYSTEM,</span><br><span class="line">        (<span class="type">uint32_t</span>)idle_task_entry,</span><br><span class="line">        (<span class="type">uint32_t</span>)(idle_task_stack + IDLE_TASK_SIZE));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-5-修改用户任务的特权级"><a href="#11-5-修改用户任务的特权级" class="headerlink" title="11.5 修改用户任务的特权级"></a>11.5 修改用户任务的特权级</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192114720.png" alt="image-20240519211415052"></p>
<p>要实现从高特权级向低特权级的转移，需要使用<code>IRET</code>指令。</p>
<p>可以参考中断切换的操作，在<code>first_task</code>的<code>TSS</code>初始化时，将相应的字段手动压入栈中；然后再执行<code>IRET</code>指令，就可以返回到特权级<code>3</code>的状态。从而实现一种从高到低的特权级切换，并将寄存器的值设置到<code>CPU</code>中。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192115446.png" alt="image-20240519211502898" style="zoom:50%;" />

<p>代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从操作进程跳转到用户进程代码 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_to_first_task</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    ASSERT(curr != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出当前任务的tss中的eip字段，获取入口地址</span></span><br><span class="line">    <span class="type">tss_t</span> *tss = &amp;(curr-&gt;tss);</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        <span class="comment">// 模拟IRET中断返回，切换入第1个可运行应用进程</span></span><br><span class="line">        <span class="comment">// 不过这里并不直接进入到进程的入口，而是先设置好段寄存器，再跳过去</span></span><br><span class="line">        <span class="string">&quot;push %[ss]\n\t&quot;</span>			<span class="comment">// SS</span></span><br><span class="line">        <span class="string">&quot;push %[esp]\n\t&quot;</span>			<span class="comment">// ESP</span></span><br><span class="line">        <span class="string">&quot;push %[eflags]\n\t&quot;</span>        <span class="comment">// EFLAGS</span></span><br><span class="line">        <span class="string">&quot;push %[cs]\n\t&quot;</span>			<span class="comment">// CS</span></span><br><span class="line">        <span class="string">&quot;push %[eip]\n\t&quot;</span>		    <span class="comment">// ip</span></span><br><span class="line">        <span class="string">&quot;iret\n\t&quot;</span></span><br><span class="line">        ::[ss]<span class="string">&quot;r&quot;</span>(tss-&gt;ss),</span><br><span class="line">          [esp]<span class="string">&quot;r&quot;</span>(tss-&gt;esp),</span><br><span class="line">          [eflags]<span class="string">&quot;r&quot;</span>(tss-&gt;eflags),</span><br><span class="line">          [cs]<span class="string">&quot;r&quot;</span>(tss-&gt;cs),</span><br><span class="line">          [eip]<span class="string">&quot;r&quot;</span>(tss-&gt;eip)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时调试得到的寄存器值如下。可以看到<code>ds/es/fs/gs</code>的值都变成了<code>0x0</code>，这是因为特权级<code>0</code>时这些寄存器存在一些值，而当切换到特权级<code>3</code>时，这些选择子会被清零。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192125386.png" alt="image-20240519212526869"></p>
<p>此时再单步调试<code>F11</code>，会发现<code>CPU</code>发生了复位。查看<code>info mem</code>可以看出，<code>0x800000000以上</code>的地址空间其权限状态，即<code>U/S</code>位依旧需要高特权级才能访问，但此时应该是低特权级程序去访问这段空间。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192128843.png" alt="image-20240519212808376"></p>
<p>因此，需要在内存分配的相关代码中进行修改。</p>
<ul>
<li>在<code>task_first_init</code>加入属性值<code>PTE_U</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 分配一页内存供代码存放使用，然后将代码复制过去</span></span><br><span class="line">    memory_alloc_page_for(first_start, alloc_size, PTE_P | PTE_W | PTE_U);</span><br><span class="line">    kernel_memcpy((<span class="type">void</span> *)first_start, (<span class="type">void</span> *)s_first_task, copy_size);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>find_pte</code>加入属性值<code>PDE_U</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在page_dir中寻找vaddr对应的页表项/PTE</span></span><br><span class="line"><span class="comment"> * @param alloc 若PTE对应的Page Table不存在，是否需要进行分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pte_t</span> *<span class="title function_">find_pte</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    pde-&gt;v = pg_paddr | PDE_P | PDE_W | PDE_U;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时寄存器值的设置更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192135719.png" alt="image-20240519213521035"></p>
<h2 id="11-6-为进程添加特权级0的栈空间"><a href="#11-6-为进程添加特权级0的栈空间" class="headerlink" title="11.6 为进程添加特权级0的栈空间"></a>11.6 为进程添加特权级0的栈空间</h2><p>目前进程<code>特权级0</code>和<code>特权级3</code>使用的是同一个栈，因此需要额外创建一个栈，以便进行不同特权级栈的分享。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192142734.png" alt="image-20240519214216716"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 任务初始化</span></span><br><span class="line">    <span class="comment">// task_init(&amp;task_manager.first_task, &quot;first task&quot;, 0, first_start, 0);  </span></span><br><span class="line">    <span class="comment">// 对first_task的esp进行修改如下：</span></span><br><span class="line">    task_init(&amp;task_manager.first_task, <span class="string">&quot;first task&quot;</span>, <span class="number">0</span>, first_start, first_start + alloc_size);  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief TSS Initialization，当有程序/进程第一次运行时会调用tss_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tss_init</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">int</span> flags, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内核栈，得到的是物理地址</span></span><br><span class="line">    <span class="type">uint32_t</span> kernel_stack = memory_alloc_page();</span><br><span class="line">    <span class="keyword">if</span> (kernel_stack == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> tss_init_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    task-&gt;tss.esp = esp;  <span class="comment">// 指示调用tss_init的函数的栈顶的位置（此时栈为空）</span></span><br><span class="line">    task-&gt;tss.esp0 = kernel_stack + MEM_PAGE_SIZE;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">tss_init_failed:</span><br><span class="line">    gdt_free_sel(tss_sel);</span><br><span class="line">    <span class="keyword">if</span> (kernel_stack) &#123;</span><br><span class="line">        memory_free_page(kernel_stack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取当前页表地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">pde_t</span> * <span class="title function_">current_page_dir</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">pde_t</span> *)task_current()-&gt;tss.cr3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 分配一页内存</span></span><br><span class="line"><span class="comment"> * 主要用于内核空间内存的分配，不用于进程内存空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">memory_alloc_page</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 内核空间虚拟地址与物理地址相同，因此可以直接调用</span></span><br><span class="line">    <span class="keyword">return</span> addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放一页内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_free_page</span> <span class="params">(<span class="type">uint32_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (addr &lt; MEM_TASK_BASE) &#123;</span><br><span class="line">        <span class="comment">// 若为内核空间，则直接释放</span></span><br><span class="line">        addr_free_page(&amp;paddr_alloc, addr, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若为进程空间，则还要释放页表</span></span><br><span class="line">        <span class="type">pte_t</span> * pte = find_pte(current_page_dir(), addr, <span class="number">0</span>);</span><br><span class="line">        ASSERT((pte == (<span class="type">pte_t</span> *)<span class="number">0</span>) &amp;&amp; pte-&gt;present);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放内存页</span></span><br><span class="line">        addr_free_page(&amp;paddr_alloc, pte_paddr(pte), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放页表</span></span><br><span class="line">        pte-&gt;v = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时进程就进入了特权级<code>3</code>的自己的栈：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192208389.png" alt="image-20240519220833546"></p>
<p>此时<code>info mem</code>的信息更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192210217.png" alt="image-20240519221009717"></p>
<p>此时继续运行会出现异常：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;first task.&quot;</span>);  <span class="comment">// F11单步调试此处出现异常</span></span><br><span class="line">        sys_sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192210492.png" alt="image-20240519221047950"></p>
<p>这是因为<code>log_printf</code>在操作系统进程（<code>0x00012bcd</code>）中，用户代码是没有权限访问的，因此需要在后续通过系统调用来解决。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192213396.png" alt="image-20240519221354822" style="zoom: 80%;" />

<h1 id="十二、建立系统调用"><a href="#十二、建立系统调用" class="headerlink" title="十二、建立系统调用"></a>十二、建立系统调用</h1><h2 id="12-1-实现系统调用的调用和返回"><a href="#12-1-实现系统调用的调用和返回" class="headerlink" title="12.1 实现系统调用的调用和返回"></a>12.1 实现系统调用的调用和返回</h2><h3 id="1、调用门"><a href="#1、调用门" class="headerlink" title="1、调用门"></a>1、调用门</h3><p>（1）调用门的作用</p>
<p>到目前为此，由于特权级的影响，特权级为<code>3</code>的应用进程无法直接访问特权级为<code>0</code>的操作进程的代码。</p>
<p>切换特权级的几种方法：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201002440.png" alt="image-20240520100207964" style="zoom:50%;" />

<p>应用程序可以通过<strong>调用门接口</strong>，实现在低特权级下对操作系统提供的接口函数进行调用。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201004667.png" alt="image-20240520100431449" style="zoom:50%;" />

<p>（2）调用门的描述符</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201005983.png" alt="image-20240520100512741" style="zoom:50%;" />

<p>（3）调用门的工作流程</p>
<p>调用门描述符实际上存放到<code>GDT</code>表中，应用调用门时需要传入对应的调用门选择子。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201008417.png" alt="image-20240520100843015" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201008739.png" alt="image-20240520100854431" style="zoom:50%;" />

<p>（4）权限检查，设置<code>CPL=3, RPL=0</code>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201010501.png" alt="image-20240520101031276" style="zoom:50%;" />

<h3 id="2、创建调用门"><a href="#2、创建调用门" class="headerlink" title="2、创建调用门"></a>2、创建调用门</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpu.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化GDT表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 添加调用门描述符</span></span><br><span class="line">    <span class="comment">// (SELECTOR_SYSCALL &gt;&gt; 3)  =&gt; 段选择子的低3位用作其他用途，高13为才用于索引index</span></span><br><span class="line">    <span class="comment">// selector                 =&gt; KERNEL_SELECTOR_CS，是因为被调函数是操作系统的代码</span></span><br><span class="line">    <span class="comment">// offset                   =&gt; 由于段基地址为0，因此被调函数的入口地址即为偏移量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当执行call指令时，会取选择子KERNEL_SELECTOR_CS找到代码段的起始地址，</span></span><br><span class="line">    <span class="comment">// 然后根据偏移量(uint32_t)exception_handler_syscall进入函数内部</span></span><br><span class="line">    gate_desc_set((<span class="type">gate_desc_t</span> *)(gdt_table + (SELECTOR_SYSCALL &gt;&gt; <span class="number">3</span>)), </span><br><span class="line">        KERNEL_SELECTOR_CS, </span><br><span class="line">        (<span class="type">uint32_t</span>)exception_handler_syscall, </span><br><span class="line">        GATE_P_PRESENT | GATE_DPL3 | GATE_TYPE_SYSCALL | SYSCALL_PARAM_COUNT</span><br><span class="line">    );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// init.c/start.S</span><br><span class="line"></span><br><span class="line">	.global exception_handler_syscall</span><br><span class="line">exception_handler_syscall:</span><br><span class="line">    retf $(5*4)</span><br></pre></td></tr></table></figure>

<h3 id="3、实现调用和返回"><a href="#3、实现调用和返回" class="headerlink" title="3、实现调用和返回"></a>3、实现调用和返回</h3><p>如果为每一个系统调用都提供一个对应的调用门，会占用较多的描述符表项。<strong>因此，可通过一个或少量几个调用门实现系统调用，从而节省资源。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201032921.png" alt="image-20240520103254777" style="zoom:50%;" />

<p>进入调用门：远跳转；</p>
<p>退出调用门：RET。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201046034.png" alt="image-20240520104642832" style="zoom:50%;" />

<p>代码实现：</p>
<p>通用系统调用结构<code>sys_call()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// applib/libsys.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用参数列表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">syscall_args_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;     <span class="comment">// 被调用函数的ID</span></span><br><span class="line">    <span class="type">int</span> arg0;</span><br><span class="line">    <span class="type">int</span> arg1;</span><br><span class="line">    <span class="type">int</span> arg2;</span><br><span class="line">    <span class="type">int</span> arg3;</span><br><span class="line">&#125;<span class="type">syscall_args_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep       0       <span class="comment">// sys_sleep()的ID</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">sys_call</span> <span class="params">(<span class="type">syscall_args_t</span> * args)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> addr[] = &#123;<span class="number">0</span>, SELECTOR_SYSCALL | <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// far jump</span></span><br><span class="line">    __asm__ __volatile__ (</span><br><span class="line">        <span class="string">&quot;push %[arg3]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg2]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg1]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg0]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[id]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;lcalll *(%[a])&quot;</span></span><br><span class="line">        ::[arg3]<span class="string">&quot;r&quot;</span>(args-&gt;arg3),</span><br><span class="line">          [arg2]<span class="string">&quot;r&quot;</span>(args-&gt;arg2),</span><br><span class="line">          [arg1]<span class="string">&quot;r&quot;</span>(args-&gt;arg1),</span><br><span class="line">          [arg0]<span class="string">&quot;r&quot;</span>(args-&gt;arg0),</span><br><span class="line">          [id]<span class="string">&quot;r&quot;</span>(args-&gt;id),</span><br><span class="line">          [a]<span class="string">&quot;r&quot;</span>(addr)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sys_sleep的系统调用</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">msleep</span> <span class="params">(<span class="type">int</span> ms)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ms &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_sleep;</span><br><span class="line">    args.arg0 = ms;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sys_call(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>lcalll</code>，即远跳转指令需要提供两个参数，段选择子和段内偏移，由<code>addr[]</code>提供。</p>
<ul>
<li><code>addr[0] = 0</code>，表示<strong>段内偏移</strong>，它指向系统调用处理函数的入口点。</li>
<li><code>addr[1] = SELECTOR_SYSCALL | 0</code>表示<strong>段选择子</strong>。<ul>
<li><code>SELECTOR_SYSCALL</code> 是被调用系统函数的段选择子；</li>
<li><code>| 0</code>是因为<code>RPL</code>设置为<code>0</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201109576.png" alt="image-20240520110945445" style="zoom:50%;" />

<ul>
<li><p>在保护模式下，x86架构使用段选择子和段内偏移配合进行内存寻址。例如，远调用指令<code>lcall</code>会使用段选择子和段内偏移来确定调用的目标地址：</p>
<ol>
<li><strong>段选择子</strong>：决定使用哪个段描述符，该描述符提供段的基地址和权限;</li>
<li><strong>段内偏移</strong>：在基地址的基础上加上偏移量，确定最终的内存地址。</li>
</ol>
</li>
<li><p>举例说明</p>
</li>
</ul>
<p>假设有一个段选择子<code>0x08</code>，它指向GDT中的一个代码段描述符，该描述符的基地址是<code>0x40000000</code>。如果段内偏移是<code>0x1000</code>，则最终的线性地址是：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线性地址 = 段基地址 + 段内偏移</span><br><span class="line"><span class="code">          = 0x40000000 + 0x1000</span></span><br><span class="line"><span class="code">          = 0x40001000</span></span><br></pre></td></tr></table></figure>

<p>这种机制使得程序可以通过改变段选择子访问不同的内存段，同时确保通过权限控制防止未经授权的访问。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201059277.png" alt="image-20240520105948178"></p>
<p><code>far jump</code>将跳转到下图的代码处：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201100500.png" alt="image-20240520110014325" style="zoom: 80%;" />



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201210574.png" alt="image-20240520121051430"></p>
<p><code>ESP</code>指向<code>0x122fdc</code>地址处（<code>1MB空间以下</code>），其内存存储的值如下图所示。也就是说，在用户进程中压入<code>特权级3</code>的对应栈的相关参数已经复制到了<code>特权级0</code>的对应栈中。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201216326.png" alt="image-20240520121643956"></p>
<p>此时存在一些问题，若调用<code>RET</code>指令，不会执行特权级切换，因此需要采用<code>RETF</code>指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exception_handler_syscall:</span><br><span class="line">    // ret</span><br><span class="line">    retf  // far return，即返回到不同的代码段中</span><br></pre></td></tr></table></figure>

<p>同时要注意，直接调用<code>REFT</code>时，在将<code>EIP/CS</code>弹出到对应的寄存器后，会直接从Parameter的位置开始弹出，这是系统“以为的”<code>ESP/SS</code>，如下图所示。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201221626.png" alt="image-20240520122108506" style="zoom: 50%;" />

<p>因此需要进行如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exception_handler_syscall:</span><br><span class="line">    retf $(5*4)</span><br></pre></td></tr></table></figure>

<h2 id="12-2-具体的调用实现"><a href="#12-2-具体的调用实现" class="headerlink" title="12.2 具体的调用实现"></a>12.2 具体的调用实现</h2><p>在进入系统调用处理程序之前，除了硬件<strong>自动压栈</strong>之外，还需要<strong>手动压栈</strong>一部分寄存器的值，以便后续使用。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201224360.png" alt="image-20240520122430073"></p>
<p>在系统调用内部，使用<strong>系统调用表</strong>来保存所有系统调用处理函数的入口地址。当发生系统调用时，通过查表来获取跳转点。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201251661.png" alt="image-20240520125101409"></p>
<h3 id="1、寄存器出入栈管理"><a href="#1、寄存器出入栈管理" class="headerlink" title="1、寄存器出入栈管理"></a>1、寄存器出入栈管理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    .global exception_handler_syscall</span><br><span class="line">exception_handler_syscall:</span><br><span class="line">    # 寄存器入栈（此处为手动入栈，有部分由硬件自动入栈）</span><br><span class="line">    pusha</span><br><span class="line">    push %ds</span><br><span class="line">    push %es</span><br><span class="line">    push %fs</span><br><span class="line">    push %gs</span><br><span class="line">    pushf                # 手动压入调用门</span><br><span class="line">        </span><br><span class="line">    mov %esp, %eax</span><br><span class="line">    push %eax</span><br><span class="line">    call do_handler_syscall</span><br><span class="line">    add $<span class="number">4</span>, %esp</span><br><span class="line">        </span><br><span class="line">    # 寄存器出栈</span><br><span class="line">    popf</span><br><span class="line">    pop %gs</span><br><span class="line">    pop %fs</span><br><span class="line">    pop %es</span><br><span class="line">    pop %ds</span><br><span class="line">    popa</span><br><span class="line"></span><br><span class="line">    retf $(<span class="number">5</span>*<span class="number">4</span>) </span><br></pre></td></tr></table></figure>

<blockquote>
<pre><code>    pusha：将所有通用寄存器（EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI）的值压入栈中。
           这样可以保存调用者的寄存器状态。
    pushf：将标志寄存器 EFLAGS 的值压入栈中。
</code></pre>
</blockquote>
<blockquote>
<pre><code>mov %esp, %eax：
    将当前栈指针ESP的值移动到EAX寄存器中。
    这一步保存了当前的栈指针。
push %eax：
    将EAX寄存器（即栈指针ESP的值）压入栈中，作为参数传递给do_handler_syscall。
call do_handler_syscall：
    调用系统调用处理函数do_handler_syscall。
    在调用之前，栈中的ESP值被传递给该函数。
add $4, %esp：
    调整栈指针，移除之前压入的参数。
    由于调用do_handler_syscall后栈中多了一个参数（即EAX的值），需要将ESP增加4字节。
</code></pre>
</blockquote>
<h3 id="2、系统调用结构体"><a href="#2、系统调用结构体" class="headerlink" title="2、系统调用结构体"></a>2、系统调用结构体</h3><p>用于保存系统调用时的处理器状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用结构体，用于保存系统调用时的处理器状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">syscall_frame_t</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> eflags;</span><br><span class="line">	<span class="type">int</span> gs, fs, es, ds;</span><br><span class="line">	<span class="type">int</span> edi, esi, ebp, dummy, ebx, edx, ecx, eax;</span><br><span class="line">	<span class="type">int</span> eip, cs;</span><br><span class="line">	<span class="type">int</span> func_id, arg0, arg1, arg2, arg3;</span><br><span class="line">	<span class="type">int</span> esp, ss;</span><br><span class="line">&#125; <span class="type">syscall_frame_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">sys_call</span> <span class="params">(<span class="type">syscall_args_t</span> * args)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> addr[] = &#123;<span class="number">0</span>, SELECTOR_SYSCALL | <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// far jump</span></span><br><span class="line">    __asm__ __volatile__ (</span><br><span class="line">        <span class="string">&quot;push %[arg3]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg2]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg1]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg0]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[id]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;lcalll *(%[a])&quot;</span></span><br><span class="line">        :<span class="string">&quot;=a&quot;</span>(ret)</span><br><span class="line">        :[arg3]<span class="string">&quot;r&quot;</span>(args-&gt;arg3),</span><br><span class="line">         [arg2]<span class="string">&quot;r&quot;</span>(args-&gt;arg2),</span><br><span class="line">         [arg1]<span class="string">&quot;r&quot;</span>(args-&gt;arg1),</span><br><span class="line">         [arg0]<span class="string">&quot;r&quot;</span>(args-&gt;arg0),</span><br><span class="line">         [id]<span class="string">&quot;r&quot;</span>(args-&gt;id),</span><br><span class="line">         [a]<span class="string">&quot;r&quot;</span>(addr)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、转发表实现系统调用"><a href="#3、转发表实现系统调用" class="headerlink" title="3、转发表实现系统调用"></a>3、转发表实现系统调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*<span class="type">syscall_handler_t</span>)</span><span class="params">(<span class="type">uint32_t</span> arg0, <span class="type">uint32_t</span> arg1, <span class="type">uint32_t</span> arg2, <span class="type">uint32_t</span> arg3)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用的转发表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">syscall_handler_t</span> sys_table[] = &#123;</span><br><span class="line">    [SYS_sleep] = (<span class="type">syscall_handler_t</span>)sys_sleep,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在调用该函数时，传递的frame参数所指向的内存地址处保存了相关的寄存器信息。在exception_handler_syscall函数中，</span></span><br><span class="line"><span class="comment"> *        相关的寄存器值被保存到栈上，然后ESP寄存器的值（即当前栈顶指针）被传递给do_handler_syscall函数。</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *        这个函数需要进行转发，找到需要调用的相应的系统函数。在frame中包含一个字段func_id，在对应的调用函数中是压入到</span></span><br><span class="line"><span class="comment"> *        syscall_args_t的id字段，并压入特权级3的栈中；在执行系统调用时，会被拷贝到特权级0的栈中（自动入栈），从而对</span></span><br><span class="line"><span class="comment"> *        应到相应的系统函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_syscall</span> <span class="params">(<span class="type">syscall_frame_t</span> *frame)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;func_id &lt; <span class="keyword">sizeof</span>(sys_table) / <span class="keyword">sizeof</span>(sys_table[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="comment">// 查表取得处理函数，然后调用处理</span></span><br><span class="line">        <span class="type">syscall_handler_t</span> handler  = sys_table[frame-&gt;func_id];</span><br><span class="line">        <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">            <span class="type">int</span> ret = handler(frame-&gt;arg0, frame-&gt;arg1, frame-&gt;arg2, frame-&gt;arg3);</span><br><span class="line">            frame-&gt;eax = ret;  <span class="comment">// eax用于存放函数的返回值，因此用ret赋值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数索引超出转发表</span></span><br><span class="line">    <span class="type">task_t</span> *task = task_current();</span><br><span class="line">    log_printf(<span class="string">&quot;task: %s, Unkown syscall: %d&quot;</span>, task-&gt;name, frame-&gt;func_id);</span><br><span class="line">    frame-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释<code>frame-&gt;eax = ret;</code>，从下图可以看出最终的返回值放到了<code>%eax</code>中：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201607868.png" alt="image-20240520160709366" style="zoom: 80%;" />

<blockquote>
<p>在执行<code>lcalll</code>指令时，进入<code>start.S</code>中执行<code>exception_handler_syscall</code>进行寄存器的出入栈操作。1）首先通过<code>pusha</code>将<code>eax</code>压栈；2）再通过<code>sys_getpid()</code>获取到<code>pid</code>作为返回值，并放入<code>frame-&gt;eax</code>中，此时就对<code>eax</code>的值进行了修改；3）最后通过<code>popa</code>将<code>eax</code>出栈，返回到上一层的调用函数<code>sys_call</code>中。</p>
<p>以<code>getpid()</code>为例，调用的函数堆栈顺序如下：</p>
<p><code>getpid()  -&gt;  sys_call()  -&gt;  do_handler_syscall()  -&gt; sys_getpid()</code></p>
<p>也就是说，<code>ret</code>的返回如上述逆序。</p>
</blockquote>
<p>调试运行时<code>frame</code>的相关参数：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201512535.png" alt="image-20240520151212263"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201511396.png" alt="image-20240520151158125"></p>
<h1 id="十三、新进程的加载与创建"><a href="#十三、新进程的加载与创建" class="headerlink" title="十三、新进程的加载与创建"></a>十三、新进程的加载与创建</h1><h2 id="13-1-实现fork系统调用"><a href="#13-1-实现fork系统调用" class="headerlink" title="13.1 实现fork系统调用"></a>13.1 实现fork系统调用</h2><h3 id="1、理论基础-12"><a href="#1、理论基础-12" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>（1）流程</p>
<p>系统调用的流程如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201647344.png" alt="image-20240520164706084"></p>
<p>（2）功能详述</p>
<p><code>fork()</code>系统调用的功能：创建一个进程的副本，并且<strong>继续从调用fork的地址往下运行</strong>。（这一点很重要！）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create child proc failed.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child: %d\n&quot;</span>, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child task id=%d\n&quot;</span>, pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent: %d\n&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201647127.png" alt="image-20240520164718779"></p>
<h3 id="2、任务块的分配和释放"><a href="#2、任务块的分配和释放" class="headerlink" title="2、任务块的分配和释放"></a>2、任务块的分配和释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述程序/进程运行状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> *<span class="title">parent</span>;</span>     <span class="comment">// 指明父进程    </span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure>

<p>将多个任务块存储在一个静态分配的进程表<code>task_table</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> task_table[TASK_NR];                  <span class="comment">// 进程表，静态分配</span></span><br><span class="line"><span class="type">static</span> <span class="type">mutex_t</span> task_table_mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Task Initializtion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> flags, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    task-&gt;parent = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在进程表中进行分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> *<span class="title function_">alloc_task</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *task = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;task_table_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历进程表，找到没有名字的表项</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TASK_NR; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">task_t</span> *curr = task_table + i;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            task = curr;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;task_table_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在进程表中进行释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> *<span class="title function_">free_task</span> <span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    mutex_lock(&amp;task_table_mutex);</span><br><span class="line"></span><br><span class="line">    task-&gt;name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;task_table_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、初始化任务块"><a href="#3、初始化任务块" class="headerlink" title="3、初始化任务块"></a>3、初始化任务块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建子进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *parent_task = task_current();</span><br><span class="line">    <span class="type">task_t</span> *child_task = alloc_task();</span><br><span class="line">    <span class="keyword">if</span> (child_task == (<span class="type">task_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取父进程执行系统调用时压栈的寄存器信息</span></span><br><span class="line">    <span class="type">syscall_frame_t</span> *frame = (<span class="type">syscall_frame_t</span> *)(parent_task-&gt;tss.esp0 - <span class="keyword">sizeof</span>(<span class="type">syscall_frame_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// frame-&gt;eip                                           ==&gt;  父进程执行系统调用的返回地址</span></span><br><span class="line">    <span class="comment">// frame-&gt;esp + sizeof(uint32_t) * SYSCALL_PARAM_COUNT  ==&gt;  恢复到对寄存器状态压栈之前的esp所指向的地址</span></span><br><span class="line">    <span class="type">int</span> err = task_init(child_task, parent_task-&gt;name, <span class="number">0</span>, </span><br><span class="line">                frame-&gt;eip, frame-&gt;esp + <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * SYSCALL_PARAM_COUNT</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">tss_t</span> *tss = &amp;child_task-&gt;tss;</span><br><span class="line">    tss-&gt;eax = <span class="number">0</span>;  <span class="comment">// 设置子进程的eax的返回值，使得调用fork()后子进程返回0</span></span><br><span class="line">    tss-&gt;ebx = frame-&gt;ebx;</span><br><span class="line">    tss-&gt;edx = frame-&gt;edx;</span><br><span class="line">    tss-&gt;ecx = frame-&gt;ecx;</span><br><span class="line">    tss-&gt;esi = frame-&gt;esi;</span><br><span class="line">    tss-&gt;edi = frame-&gt;edi;</span><br><span class="line">    tss-&gt;ebp = frame-&gt;ebp;</span><br><span class="line"></span><br><span class="line">    tss-&gt;cs = frame-&gt;cs;</span><br><span class="line">    tss-&gt;ds = frame-&gt;ds;</span><br><span class="line">    tss-&gt;es = frame-&gt;es;</span><br><span class="line">    tss-&gt;fs = frame-&gt;fs;</span><br><span class="line">    tss-&gt;fs = frame-&gt;gs;</span><br><span class="line">    tss-&gt;eflags = frame-&gt;eflags;</span><br><span class="line"></span><br><span class="line">    child_task-&gt;parent = parent_task;</span><br><span class="line"></span><br><span class="line">    tss-&gt;cr3 = parent_task-&gt;tss.cr3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child_task-&gt;pid;</span><br><span class="line"></span><br><span class="line">fork_failed:</span><br><span class="line">    <span class="keyword">if</span> (child_task) &#123;</span><br><span class="line">        task_uninit(child_task);</span><br><span class="line">        free_task(child_task);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在<code>sys_call()</code>中，当运行到<code>lcalll</code>指令时，会跳转到<code>start.S</code>的代码中执行压栈操作，也就是说此时保存了父进程相关的寄存器的所有信息。因此子进程只要能够也获取到<code>lcalll</code>指令调用时的内存信息，也即找到父进程的<code>syscall_frame_t</code>的指针，就可以获取到上述状态。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201950719.png" alt="image-20240520195025091"></p>
<p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">syscall_frame_t</span> *frame = (<span class="type">syscall_frame_t</span> *)(parent_task-&gt;tss.esp0 - <span class="keyword">sizeof</span>(<span class="type">syscall_frame_t</span>));</span><br></pre></td></tr></table></figure>



<p>父进程的执行完<code>fork()</code>后，是从特权级为<code>0</code>的代码返回到特权级为<code>3</code>的代码。</p>
<p>但对于子进程来说，只是通过<code>task_init</code>进行了初始化操作，包括对其<code>TSS</code>进行初始化。在父进程执行到<code>return</code>语句时它实际上并未运行，根据<code>first_task.c</code>的逻辑，会在父进程进入<code>msleep(1000);</code>睡眠时，通过任务切换<code>task_dispatch()</code>来切换到子进程中。此时子进程会从自己的<code>TSS</code>中进程对相关的寄存器进行状态恢复。</p>
<p>因此对于子进程来说，初始化子进程时传入的<code>esp</code>参数应该是和父进程的<code>esp</code>一致，但是区别在于子进程没有进行特权级切换，而是直接从特权级<code>3</code>的模式开始运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    pid = fork();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot;task id= %d&quot;</span>, pid);</span><br><span class="line">        <span class="comment">////======///</span></span><br><span class="line">        msleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">////======///</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、复制进程地址空间"><a href="#4、复制进程地址空间" class="headerlink" title="4、复制进程地址空间"></a>4、复制进程地址空间</h3><p>在为子进程创建用户地址空间时，若共用同一页表，实际所用的存储空间就完全处在一页，当涉及到可读写数据时就可能导致冲突。比如，当涉及到栈空间时，父进程可能在执行时对<code>ESP</code>进行修改，这样当切换到子进程运行时，只能得到被破坏的寄存器状态，可能会造成返回出错，导致<code>Page Fault</code>的发生。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202030623.png" alt="image-20240520203019242"></p>
<p>因此，在为子进程创建用户地址空间时，<strong>只需要扫描父进程中<code>0x800000000</code>以上存在映射的地址区域，进行类似的映射。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202057353.png" alt="image-20240520205735959" style="zoom:50%;" />

<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建子进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为子进程分配单独的页表</span></span><br><span class="line">    <span class="keyword">if</span> ((tss-&gt;cr3 = memory_copy_uvm(parent_task-&gt;tss.cr3)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 复制页表及其所有的内存空间 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">memory_copy_uvm</span> <span class="params">(<span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    <span class="comment">// 复制基础页表</span></span><br><span class="line">    <span class="type">uint32_t</span> to_page_dir = memory_create_uvm();</span><br><span class="line">    <span class="keyword">if</span> (to_page_dir == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> copy_uvm_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制页表中用户空间的各项</span></span><br><span class="line">    <span class="type">uint32_t</span> user_pde_start = pde_index(MEM_TASK_BASE);  <span class="comment">// PD表的索引</span></span><br><span class="line">    <span class="type">pde_t</span> *pde = (<span class="type">pde_t</span> *)page_dir + user_pde_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历用户空间页目录项</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = user_pde_start; i &lt; PDE_CNT; i++, pde++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pde-&gt;present) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历页表</span></span><br><span class="line">        <span class="type">pte_t</span> *pte = (<span class="type">pte_t</span> *)pde_paddr(pde);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; PTE_CNT; j++, pte++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pte-&gt;present) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 分配物理内存</span></span><br><span class="line">            <span class="type">uint32_t</span> page = addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (page == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> copy_uvm_failed;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立映射关系</span></span><br><span class="line">            <span class="type">uint32_t</span> vaddr = (i &lt;&lt; <span class="number">22</span>) | (j &lt;&lt; <span class="number">12</span>);</span><br><span class="line">            <span class="type">int</span> err = memory_create_map((<span class="type">pde_t</span> *)to_page_dir, vaddr, page, <span class="number">1</span>, get_pte_perm(pte));</span><br><span class="line">            <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> copy_uvm_failed;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 复制内容</span></span><br><span class="line">            kernel_memcpy((<span class="type">void</span> *)page, (<span class="type">void</span> *)vaddr, MEM_PAGE_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> to_page_dir;</span><br><span class="line"></span><br><span class="line">copy_uvm_failed:</span><br><span class="line">    <span class="keyword">if</span> (to_page_dir) &#123;</span><br><span class="line">        memory_destroy_uvm(to_page_dir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 销毁用户空间内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_destroy_uvm</span> <span class="params">(<span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> user_pde_start = pde_index(MEM_TASK_BASE);</span><br><span class="line">    <span class="type">pde_t</span> * pde = (<span class="type">pde_t</span> *)page_dir + user_pde_start;</span><br><span class="line"></span><br><span class="line">    ASSERT(page_dir != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放页表中对应的各项，不包含映射的内核页面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = user_pde_start; i &lt; PDE_CNT; i++, pde++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pde-&gt;present) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放页表对应的物理页 + 页表</span></span><br><span class="line">        <span class="type">pte_t</span> * pte = (<span class="type">pte_t</span> *)pde_paddr(pde);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; PTE_CNT; j++, pte++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pte-&gt;present) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            addr_free_page(&amp;paddr_alloc, pte_paddr(pte), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addr_free_page(&amp;paddr_alloc, (<span class="type">uint32_t</span>)pde_paddr(pde), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放页目录表</span></span><br><span class="line">    addr_free_page(&amp;paddr_alloc, page_dir, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-2-实现exec系统调用"><a href="#13-2-实现exec系统调用" class="headerlink" title="13.2 实现exec系统调用"></a>13.2 实现exec系统调用</h2><p>创建一个独立的应用程序文件，未来可<strong>单独放在磁盘上，并从磁盘上加载</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202146108.png" alt="image-20240520214639703" style="zoom:50%;" />

<p>对于一个<code>C</code>语言构建的应用程序，其入口地址并不是<code>main()</code>函数，如下图所示。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202148647.png" alt="image-20240520214815394" style="zoom:50%;" />

<h3 id="1、链接脚本设置"><a href="#1、链接脚本设置" class="headerlink" title="1、链接脚本设置"></a>1、链接脚本设置</h3><p>为了避免和<code>first_task</code>在调试时造成内存地址冲突，将起始地址设置为<code>0x81000000</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = 0x81000000; </span><br><span class="line"></span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ENTRY(_start)</code>这一句中的<code>_start</code>是<code>applib/crt0.S</code>文件的程序入口地址。这样做就是为了满足上图中<code>main</code>函数前还包含<code>crt0</code>和<code>clib</code>的框架结构。</p>
<h3 id="2、创建空exec调用"><a href="#2、创建空exec调用" class="headerlink" title="2、创建空exec调用"></a>2、创建空exec调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib_syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @name 指明进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">execve</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">char</span> * <span class="type">const</span> *argv, <span class="type">char</span> * <span class="type">const</span> *env)</span> &#123;</span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_execve;</span><br><span class="line">    args.arg0 = (<span class="type">int</span>)name;</span><br><span class="line">    args.arg1 = (<span class="type">int</span>)argv;</span><br><span class="line">    args.arg2 = (<span class="type">int</span>)env;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sys_call(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用的转发表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">syscall_handler_t</span> sys_table[] = &#123;</span><br><span class="line">	...</span><br><span class="line">    [SYS_execve] = (<span class="type">syscall_handler_t</span>)sys_execve,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用当前的进程去运行新的程序内容，即加载一个进程，并非创建一个新的进程 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_execve</span> <span class="params">(<span class="type">char</span> *name, <span class="type">char</span> **argv, <span class="type">char</span> **env)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *task = task_current();</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> old_page_dir = task-&gt;tss.cr3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为该进程创建新的页表</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载ELF文件到内存中。要放在开启新页表之后，这样才能对相应的内存区域写</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前进程的页表，并销毁原页表</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">exec_failed:</span><br><span class="line">    <span class="keyword">if</span> (new_page_dir) &#123;</span><br><span class="line">        task-&gt;tss.cr3 = old_page_dir;</span><br><span class="line">        mmu_set_page_dir(old_page_dir);</span><br><span class="line">        memory_destroy_uvm(new_page_dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解析1：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * conts * argv</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>char * const * argv</code> 表示一个指向常量字符指针数组的指针。</li>
<li>用于表示命令行参数的 <code>argv</code>，其中每个参数是一个字符串（<code>char *</code>）。</li>
<li>指针本身是常量（不能改变指向），但指向的内容（字符串）是可以修改的。</li>
</ul>
</blockquote>
<ul>
<li>解析2：为什么执行<code>sys_exec()</code>时，需要创建一个新页表？在<code>fork()</code>时子进程不是已经有了自己的新页表了吗？</li>
</ul>
<blockquote>
<ol>
<li><p>区别解释</p>
</li>
<li><p><code>fork</code> 函数：用于创建一个子进程，这个子进程是当前进程的副本。它会复制当前进程的页表，并在子进程的地址空间中共享同样的物理内存。这样做的目的是让子进程拥有与父进程相同的执行环境。</p>
</li>
</ol>
<ul>
<li><p><strong>页表复制</strong>：<code>fork</code> 时，通过<code>memory_copy_uvm</code>函数为子进程创建一个新的页表，该页表是父进程页表的副本。这使得父子进程各自独立，但初始时共享同样的物理内存。</p>
</li>
<li><p><strong>子进程的返回值</strong>：子进程的<code>eax</code>寄存器被设为0，以便<code>fork</code>系统调用在子进程中返回0，而在父进程中返回子进程的PID。</p>
</li>
</ul>
<ol start="2">
<li><p><code>execve</code> 函数：用于用一个新程序替换当前进程的内容。调用<code>execve</code>后，当前进程的地址空间会被新程序的地址空间替代。</p>
<ul>
<li><p><strong>新页表的创建</strong>：<code>execve</code>需要一个干净的、新的页表，用于加载和运行新的程序。这是因为 <code>execve</code> 的目的是清除当前进程的地址空间并加载新程序，所以必须分配一个新的页表。</p>
</li>
<li><p><strong>加载新程序</strong>：在新页表中加载新的程序，这样可以确保新程序有一个干净的内存环境，不受之前进程状态的影响。</p>
</li>
<li><p><strong>销毁旧页表</strong>：一旦新程序成功加载，旧的页表被销毁，以释放不再需要的资源。</p>
</li>
</ul>
</li>
<li><p>执行流程中的细节</p>
</li>
</ol>
<p> 在<code>sys_execve</code>函数中，以下步骤确保了这一点：</p>
<ol>
<li><p><strong>旧页表的保存</strong>；</p>
</li>
<li><p><strong>新页表的创建</strong>；</p>
</li>
<li><p><strong>加载新程序</strong>；</p>
</li>
<li><p><strong>切换到新页表</strong>。</p>
</li>
<li><p>总结：这种设计方式确保了每个系统调用的预期功能和行为：<code>fork</code> 保留现有执行环境，而 <code>execve</code> 则彻底替换执行环境。</p>
</li>
</ol>
<ul>
<li><p><code>fork</code> 通过复制当前进程的页表，为子进程创建了一个新的、但初始内容相同的地址空间。</p>
</li>
<li><p><code>execve</code> 通过创建一个全新的页表并加载新程序，确保新程序在一个干净的内存环境中运行。</p>
</li>
</ul>
</blockquote>
<h3 id="3、添加虚拟文件访问接口"><a href="#3、添加虚拟文件访问接口" class="headerlink" title="3、添加虚拟文件访问接口"></a>3、添加虚拟文件访问接口</h3><p>为实现应用程序的加载，需要完成两点工作：</p>
<ul>
<li>分配相应的存储空间；</li>
<li>从<code>ELF</code>文件中读取数据并写入内存页中。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211017716.png" alt="image-20240521101728080"></p>
<p>目前仍未实现文件系统，因此采用下图的方式进行简单实现，只针对<code>shell.elf</code>文件进行处理：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211019558.png" alt="image-20240521101905366"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/include/fs/fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FS_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FS_H_</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> flags, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_lseek</span><span class="params">(<span class="type">int</span> file, <span class="type">int</span> ptr, <span class="type">int</span> dir)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_close</span><span class="params">(<span class="type">int</span> file)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _FS_H_</span></span></span><br></pre></td></tr></table></figure>

<h3 id="4、解析并加载ELF文件"><a href="#4、解析并加载ELF文件" class="headerlink" title="4、解析并加载ELF文件"></a>4、解析并加载ELF文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加载一个Phdr的数据到内存中</span></span><br><span class="line"><span class="comment"> * @param phdr      要加载的程序头</span></span><br><span class="line"><span class="comment"> * @param page_dir  程序头加载到的页表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_phdr</span><span class="params">(<span class="type">int</span> file, Elf32_Phdr *phdr, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    <span class="comment">// 生成的ELF文件要求是页边界对齐的</span></span><br><span class="line">    ASSERT((phdr-&gt;p_vaddr &amp; (MEM_PAGE_SIZE - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    <span class="type">int</span> err = memory_alloc_page_for_page_dir(page_dir, phdr-&gt;p_vaddr, phdr-&gt;p_memsz, PTE_P | PTE_U | PTE_W);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;no memory&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整当前的读写位置</span></span><br><span class="line">    <span class="comment">// 具体来说，指针需要从Phdr的位置移动到该Phdr指向的代码/数据段的具体位置，也即p_offset参数</span></span><br><span class="line">    <span class="keyword">if</span> (sys_lseek(file, phdr-&gt;p_offset, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为段分配所有的内存空间，后续操作如果失败将在上层释放</span></span><br><span class="line">    <span class="type">uint32_t</span> vaddr = phdr-&gt;p_vaddr;     <span class="comment">// 内存中的起始地址，只针对传入的新创建的page_dir参数有效</span></span><br><span class="line">    <span class="type">uint32_t</span> size = phdr-&gt;p_filesz;     <span class="comment">// 要拷贝的文件大小</span></span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断当前需要被拷贝的大小，一次最多只能拷贝一页</span></span><br><span class="line">        <span class="type">int</span> curr_size = (size &gt; MEM_PAGE_SIZE) ? MEM_PAGE_SIZE : size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到当前vaddr在page_dir中对应的物理地址</span></span><br><span class="line">        <span class="type">uint32_t</span> paddr = memory_get_paddr(page_dir, vaddr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这里传入(char *)vaddr，会将新页表中对应的内存地址传给当前使用的旧页表中</span></span><br><span class="line">        <span class="keyword">if</span> (sys_read(file, (<span class="type">char</span> *)paddr, curr_size) &lt; curr_size) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size -= curr_size;</span><br><span class="line">        vaddr += curr_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加载elf文件到内存中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">load_elf_file</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    Elf32_Ehdr elf_hdr;</span><br><span class="line">    Elf32_Phdr elf_phdr;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> file = sys_open(name, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (file &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;open failed. %s&quot;</span>, name);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先，读取文件头（ELF Header）</span></span><br><span class="line">    <span class="type">int</span> cnt = sys_read(file, (<span class="type">char</span> *)&amp;elf_hdr, <span class="keyword">sizeof</span>(elf_hdr));</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; <span class="keyword">sizeof</span>(Elf32_Ehdr)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;elf hdr too small. size= %d&quot;</span>, cnt);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做必要性检查</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr.e_ident[<span class="number">0</span>] != <span class="number">0x7F</span>) || (elf_hdr.e_ident[<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">        || (elf_hdr.e_ident[<span class="number">2</span>] != <span class="string">&#x27;L&#x27;</span>) || (elf_hdr.e_ident[<span class="number">3</span>] != <span class="string">&#x27;F&#x27;</span>)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;check elf indent failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须是可执行文件和针对386处理器的类型，且有入口</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr.e_type != ET_EXEC) || (elf_hdr.e_machine != ET_386) || (elf_hdr.e_entry == <span class="number">0</span>)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;check elf type or entry failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须有程序头部</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr.e_phentsize == <span class="number">0</span>) || (elf_hdr.e_phoff == <span class="number">0</span>)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;none programe header&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次，读取程序头（Program Header），将内容拷贝到相应的位置</span></span><br><span class="line">    <span class="type">uint32_t</span> e_phoff = elf_hdr.e_phoff;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elf_hdr.e_phnum; i++, e_phoff += elf_hdr.e_phentsize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sys_lseek(file, e_phoff, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取程序头后解析，这里不用读取到新进程的页表中，因为只是临时使用下</span></span><br><span class="line">        cnt = sys_read(file, (<span class="type">char</span> *)&amp;elf_phdr, <span class="keyword">sizeof</span>(Elf32_Phdr));</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="keyword">sizeof</span>(Elf32_Phdr)) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单做一些检查，主要判断是否是可加载的类型，并且要求加载的地址必须是用户空间</span></span><br><span class="line">        <span class="keyword">if</span> ((elf_phdr.p_type != PT_LOAD) || (elf_phdr.p_vaddr &lt; MEM_TASK_BASE)) &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载当前程序头</span></span><br><span class="line">        <span class="type">int</span> err = load_phdr(file, &amp;elf_phdr, page_dir);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;load program hdr failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    sys_close(file);</span><br><span class="line">    <span class="keyword">return</span> elf_hdr.e_entry;</span><br><span class="line"></span><br><span class="line">load_failed:</span><br><span class="line">    <span class="keyword">if</span> (file &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sys_close(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>有一个要注意的点在于：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211223596.png" alt="image-20240521122318108"></p>
<p>绿色框中框出的这两部分看起来好像是连续的，实际在对其进行拷贝时会发现它并非是连续的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">load_elf_file</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载当前程序头</span></span><br><span class="line">    <span class="comment">// =============================================== //</span></span><br><span class="line">    <span class="type">int</span> err = load_phdr(file, &amp;elf_phdr, page_dir);</span><br><span class="line">    <span class="comment">// =============================================== //</span></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;load program hdr failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_phdr</span><span class="params">(<span class="type">int</span> file, Elf32_Phdr *phdr, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// =============================================== //</span></span><br><span class="line">    <span class="comment">// 为所有的段分配内存空间并复制</span></span><br><span class="line">    <span class="comment">// =============================================== //</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述程序，在<code>21</code>行调用<code>load_phdr()</code>时传入了新建进程时新创建的页表<code>page_dir</code>，但在<code>load_phdr()</code>内部执行到段分配空间并复制时，实际用到的并非是这个新创建的<code>page_dir</code>，而是<code>first_task</code>在运行时创建的那个页表。</p>
<p>由于在<code>page_dir</code>这个页表中包含的映射关系并未被启用，也就是说在这个新页表中连续的一段内存空间在原来的页表中实际上是不连续的。需要将原页表的内容不连续地拷贝到新页表中。</p>
<p>需要像下面这样操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到当前vaddr在page_dir中对应的物理地址</span></span><br><span class="line"><span class="type">uint32_t</span> paddr = memory_get_paddr(page_dir, vaddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这里传入(char *)vaddr，会将新页表中对应的内存地址传给当前使用的旧页表中</span></span><br><span class="line"><span class="keyword">if</span> (sys_read(file, (<span class="type">char</span> *)paddr, curr_size) &lt; curr_size) &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、分配栈并进入进程执行"><a href="#5、分配栈并进入进程执行" class="headerlink" title="5、分配栈并进入进程执行"></a>5、分配栈并进入进程执行</h3><p>新进程的栈分配空间与<code>first_task</code>可能不相同。</p>
<p><code>first_task</code>的栈是紧挨着<code>.bss</code>段放置的，整体的空间不够大，对于<code>shell</code>来说，当后期涉及到堆空间以及一些较大的栈空间需求时很会麻烦，因此需要重新建立。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_TASK_STACK_TOP  0xE0000000              <span class="comment">// shell进程的栈空间起始地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_TASK_STACK_SIZE     (MEM_PAGE_SIZE * 500)   <span class="comment">// shell进程的栈空间大小</span></span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211449653.png" alt="image-20240521144933288" style="zoom:50%;" />

<p>这个新分配的栈是需要返回给<code>shell</code>使用在特权级<code>3</code>的状态下的，但进程在使用时也会涉及到系统调用和中断等处理。因此，对于操作系统相关的代码可以<strong>继续使用原来建立的特权级<code>0</code>的栈</strong>，此处只需要对<strong>新分配属于自己的特权级<code>3</code>的栈</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211451843.png" alt="image-20240521145151527"></p>
<p>特权级<code>0</code>的栈保存了<code>frst_task</code>的相关信息，由于此处对于原来的页表进行了销毁，因此若不做相应的处理，返回到的内存地址处实际上是没有任何有效信息的，会造成错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新当前进程的页表</span></span><br><span class="line">task-&gt;tss.cr3 = new_page_dir;</span><br><span class="line">mmu_set_page_dir(new_page_dir);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁原来的旧页表</span></span><br><span class="line">memory_destroy_uvm(old_page_dir);</span><br></pre></td></tr></table></figure>

<p>因此<strong>在更新页表前（上述代码）</strong>，需要先找到特权级<code>0</code>的栈，并对其中的相关寄存器值进行修改，以便在系统调用返回时能够切换回到<code>shell</code>进程中。</p>
<p>对寄存器值的修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用当前的进程去运行新的程序内容，即加载一个进程，并非创建一个新的进程 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_execve</span> <span class="params">(<span class="type">char</span> *name, <span class="type">char</span> **argv, <span class="type">char</span> **env)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载完毕，为程序的执行做必要准备</span></span><br><span class="line">    <span class="comment">// 注意，exec的作用是替换掉当前进程，所以只要改变当前进程的执行流即可</span></span><br><span class="line">    <span class="comment">// 当该进程恢复运行时，像完全重新运行一样，所以用户栈要设置成初始模式</span></span><br><span class="line">    <span class="comment">// 运行地址要设备成整个程序的入口地址</span></span><br><span class="line">    <span class="type">syscall_frame_t</span> * frame = (<span class="type">syscall_frame_t</span> *)(task-&gt;tss.esp0 - <span class="keyword">sizeof</span>(<span class="type">syscall_frame_t</span>));</span><br><span class="line">    frame-&gt;eip = entry;  <span class="comment">// 修改为shell进程的入口地址</span></span><br><span class="line">    frame-&gt;eax = frame-&gt;ebx = frame-&gt;ecx = frame-&gt;edx = <span class="number">0</span>;</span><br><span class="line">    frame-&gt;esi = frame-&gt;edi = frame-&gt;ebp = <span class="number">0</span>;</span><br><span class="line">    frame-&gt;eflags = EFLAGS_DEFAULT| EFLAGS_IF;  <span class="comment">// 段寄存器无需修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内核栈不用设置，保持不变，后面调用memory_destroy_uvm并不会销毁内核栈的映射。</span></span><br><span class="line">    <span class="comment">// 但用户栈需要更改, 同样要加上调用门的参数压栈空间</span></span><br><span class="line">    frame-&gt;esp = stack_top - <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * SYSCALL_PARAM_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前进程的页表</span></span><br><span class="line">    task-&gt;tss.cr3 = new_page_dir;</span><br><span class="line">    mmu_set_page_dir(new_page_dir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁原来的旧页表</span></span><br><span class="line">    memory_destroy_uvm(old_page_dir);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、为进程传递参数"><a href="#6、为进程传递参数" class="headerlink" title="6、为进程传递参数"></a>6、为进程传递参数</h3><p><code>cstart.c</code>实际上是有参数的，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cstart</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    main(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// argc 存储参数的总个数，含应用程序的名字</span></span><br><span class="line"><span class="comment">// argv 参数的字符串指针数组</span></span><br></pre></td></tr></table></figure>

<p>在<code>C</code>语言中，如果需要传参的话，会将参数放入栈中。而此时的<code>esp = 0xE0000000</code>，对于当前进程来说，此时的参数保存在<code> 0xE0000000</code>以上的位置，但实际上此处是并未分配内存的，因此会造成异常。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211557399.png" alt="image-20240521155717841" style="zoom:50%;" />

<p>因此，在调用<code>main</code>函数之前，需要先往栈中压入<code>argc/argv</code>参数值：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211620385.png" alt="image-20240521162034894" style="zoom:50%;" />

<p>修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程参数结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_args_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> ret_addr;</span><br><span class="line">    <span class="type">uint32_t</span> argc;</span><br><span class="line">    <span class="type">char</span> **argv;</span><br><span class="line">&#125; <span class="type">task_args_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用当前的进程去运行新的程序内容，即加载一个进程，并非创建一个新的进程 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_execve</span> <span class="params">(<span class="type">char</span> *name, <span class="type">char</span> **argv, <span class="type">char</span> **env)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配用户栈空间，预留环境环境及参数的空间</span></span><br><span class="line">    <span class="type">uint32_t</span> stack_top = MEM_TASK_STACK_TOP - MEM_TASK_ARG_SIZE;</span><br><span class="line">    <span class="type">int</span> err = memory_alloc_page_for_page_dir(</span><br><span class="line">        new_page_dir, </span><br><span class="line">        MEM_TASK_STACK_TOP - MEM_TASK_STACK_SIZE,</span><br><span class="line">        MEM_TASK_STACK_SIZE,</span><br><span class="line">        PTE_P | PTE_U | PTE_W</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> exec_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制参数，写入到栈顶的后边</span></span><br><span class="line">    <span class="type">int</span> argc = string_count(argv);</span><br><span class="line">    err = copy_args((<span class="type">char</span> *)stack_top, new_page_dir, argc, argv);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> exec_failed;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）参数拷贝函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 参数拷贝</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param to        要拷贝到何处</span></span><br><span class="line"><span class="comment"> * @param page_dir  对应的页表</span></span><br><span class="line"><span class="comment"> * @param argc      要拷贝的参数个数</span></span><br><span class="line"><span class="comment"> * @param argv      要拷贝的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_args</span><span class="params">(<span class="type">char</span> *to, <span class="type">uint32_t</span> page_dir, <span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// 在stack_top中依次写入argc, argv指针，参数字符串</span></span><br><span class="line">    <span class="type">task_args_t</span> task_args;</span><br><span class="line">    task_args.argc = argc;</span><br><span class="line">    task_args.argv = (<span class="type">char</span> **)(to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制各项参数, 跳过task_args和参数表</span></span><br><span class="line">    <span class="comment">// 定义各argv参数写入的内存空间</span></span><br><span class="line">    <span class="type">char</span> * dest_arg = to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>) + <span class="keyword">sizeof</span>(<span class="type">char</span> *) * (argc);   <span class="comment">// 留出结束符</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// argv表</span></span><br><span class="line">    <span class="type">char</span> ** dest_argv_tb = (<span class="type">char</span> **)memory_get_paddr(page_dir, (<span class="type">uint32_t</span>)(to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>)));</span><br><span class="line">    ASSERT(dest_argv_tb != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="type">char</span> *from = argv[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能用kernel_strcpy，因为to和argv不在一个页表里</span></span><br><span class="line">        <span class="type">int</span> len = kernel_strlen(from) + <span class="number">1</span>;  <span class="comment">// +1是为了加上&#x27;\0&#x27;</span></span><br><span class="line">        <span class="type">int</span> err = memory_copy_uvm_data((<span class="type">uint32_t</span>)dest_arg, page_dir, (<span class="type">uint32_t</span>)from, len);</span><br><span class="line">        ASSERT(err &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关联字符串与对应的字符串指针</span></span><br><span class="line">        dest_argv_tb[i] = dest_arg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录下位置后，复制的位置前移</span></span><br><span class="line">        dest_arg += len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入task_args</span></span><br><span class="line">    <span class="keyword">return</span> memory_copy_uvm_data((<span class="type">uint32_t</span>)to, page_dir, (<span class="type">uint32_t</span>)&amp;task_args, <span class="keyword">sizeof</span>(task_args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task_args.argv = (<span class="type">char</span> **)(to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>));  <span class="comment">// 得到char **argv的起始地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *dest_arg = to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>) + <span class="keyword">sizeof</span>(<span class="type">char</span> *) * argc;  <span class="comment">// 获取argv中具体的每一个字符串的起始地址</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211649751.png" alt="image-20240521164949480" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task_args.argv = (<span class="type">char</span> **)(to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>));  <span class="comment">// 得到argv的起始地址</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211641068.png" alt="image-20240521164157766" style="zoom:50%;" />

<p>（2）重要函数：在不同的页表间拷贝数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在不同的页表间拷贝数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param to        要拷贝的目的地址</span></span><br><span class="line"><span class="comment"> * @param page_dir  地址所在的页表</span></span><br><span class="line"><span class="comment"> *                  注意传入的page_dir为新页表，而当前仍在使用旧页表，因此需要结合物理地址来操作</span></span><br><span class="line"><span class="comment"> * @param from      当前地址</span></span><br><span class="line"><span class="comment"> * @param size      拷贝的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memory_copy_uvm_data</span><span class="params">(<span class="type">uint32_t</span> to, <span class="type">uint32_t</span> page_dir, <span class="type">uint32_t</span> from, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取to对应的物理地址</span></span><br><span class="line">        <span class="type">uint32_t</span> to_paddr = memory_get_paddr(page_dir, to);</span><br><span class="line">        <span class="keyword">if</span> (to_paddr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// to_paddr在自己所在物理页的偏移量</span></span><br><span class="line">        <span class="type">uint32_t</span> offset_in_page = to_paddr &amp; (MEM_PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将from的数据拷贝到该偏移量处</span></span><br><span class="line">        <span class="type">uint32_t</span> curr_size = MEM_PAGE_SIZE - offset_in_page;</span><br><span class="line">        <span class="keyword">if</span> (curr_size &gt; size) &#123;</span><br><span class="line">            curr_size = size;</span><br><span class="line">        &#125;</span><br><span class="line">        kernel_memcpy((<span class="type">void</span> *)to_paddr, (<span class="type">void</span> *)from, curr_size);</span><br><span class="line"></span><br><span class="line">        size -= curr_size;</span><br><span class="line">        to += curr_size;</span><br><span class="line">        from += curr_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-3-实现sys-yiled系统调用"><a href="#13-3-实现sys-yiled系统调用" class="headerlink" title="13.3 实现sys_yiled系统调用"></a>13.3 实现sys_yiled系统调用</h2><h3 id="1、解决task-init遗留问题"><a href="#1、解决task-init遗留问题" class="headerlink" title="1、解决task_init遗留问题"></a>1、解决task_init遗留问题</h3><p>在<code>sys_fork()</code>中，创建子进程时会调用<code>task_init()</code>函数，在这个函数中会对进程进行初始化，然后就加入<code>ready_list</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务加入ready_list</span></span><br><span class="line">task_set_ready(task);</span><br></pre></td></tr></table></figure>

<p>但在<code>sys_fork()</code>中，执行的逻辑是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建子进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 对子进程进行初始化，并对必要的字段进行调整</span></span><br><span class="line">    <span class="type">int</span> err = task_init(child_task, parent_task-&gt;name, <span class="number">0</span>, </span><br><span class="line">                frame-&gt;eip, frame-&gt;esp + <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * SYSCALL_PARAM_COUNT</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从父进程的栈中取部分状态，然后写入子进程的tss</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为子进程分配单独的页表</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child_task-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，在<code>#8</code>行就将这个子进程加入<code>ready_list</code>中了，但此时的子进程仍未初始化完毕，包括对<code>TSS</code>以及对内存空间等的初始化，此时若发生了定时中断，就会发生<code>task_dispatch()</code>，切换到还未初始化完成的子进程中进行，造成错误。如下图所示，在执行完<code>first_task</code>的相关任务后，运行到<code>shell</code>进程的<code>fork()</code>操作时，会出现<code>CPU</code>重启：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shell/main.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot;arg: %s&quot;</span>, (<span class="type">int</span>)argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fork();</span><br><span class="line">    yield();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot;shell pid=%d&quot;</span>, getpid());</span><br><span class="line">        msleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211941992.png" alt="image-20240521194153623"></p>
<p>因此，需要对<code>task_init()</code>进行修改，删除加入就绪队列的部分，并新建一个函数专门用于启动进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 启动任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_start</span><span class="params">(<span class="type">task_t</span> * task)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line">    </span><br><span class="line">    task_set_ready(task);</span><br><span class="line">    </span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、测试sys-yield"><a href="#2、测试sys-yield" class="headerlink" title="2、测试sys_yield()"></a>2、测试sys_yield()</h3><p><code>fork()</code>会调用两次。</p>
<p>出现异常：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221254675.png" alt="image-20240522125434543"></p>
<p>调试结果如下：</p>
<blockquote>
<p>根据提供的信息，故障发生时的关键寄存器和状态如下：</p>
<ul>
<li><strong>CS</strong>: 8 (内核代码段)</li>
<li><strong>EIP</strong>: 0x13757</li>
<li><strong>EAX</strong>: 0x13E000 (发生Page fault时访问的地址)</li>
<li><strong>ESP</strong>: 0x12FF2C</li>
<li><strong>EFLAGS</strong>: 0x206</li>
<li><strong>Error code</strong>: 11 (0000 1011)</li>
</ul>
<ul>
<li>Page fault错误代码分析</li>
</ul>
<ol>
<li>错误代码<code>11</code>（0000 1011）解释如下：</li>
</ol>
<ul>
<li><p>第0位（P）：0，表示该页没有被加载到内存中。</p>
</li>
<li><p>第1位（W&#x2F;R）：1，表示是写操作引起的。</p>
</li>
<li><p>第2位（U&#x2F;S）：1，表示是用户模式访问引起的。</p>
</li>
<li><p>第3位（RSV）：0，保留位。</p>
</li>
</ul>
<ol start="2">
<li>错误原因分析</li>
</ol>
<p>根据错误代码和寄存器值，访问地址0x13E000没有被映射到内存中，导致Page fault。发生Page fault的地方在0x13757，表示发生错误的指令位于该地址。</p>
<ol start="3">
<li><p>可能原因及排查步骤</p>
</li>
<li><p><strong>检查页表和内存管理</strong>：</p>
<ul>
<li>确保在fork过程中，子进程正确地继承和复制了父进程的页表。</li>
<li>在<code>sys_execve</code>过程中，确保新的页表正确创建和切换。</li>
<li>确保<code>memory_copy_uvm</code>函数正确地复制了页表。</li>
</ul>
</li>
<li><p><strong>查看发生异常的代码段</strong>：</p>
<ul>
<li>确定<code>EIP</code>值0x13757处的代码在执行什么操作。可能需要反汇编或调试来了解具体指令。</li>
</ul>
</li>
<li><p><strong>检查栈和寄存器状态</strong>：</p>
<ul>
<li><p>确认栈指针（ESP）和基址指针（EBP）的值是否合理。</p>
</li>
<li><p>检查<code>sys_execve</code>和<code>sys_fork</code>过程中对栈的操作是否正确。</p>
</li>
</ul>
</li>
<li><p><strong>日志和调试信息</strong>：</p>
<ul>
<li>增加更多日志，特别是在切换页表和分配内存时，记录相关操作的详细信息。</li>
</ul>
</li>
</ol>
</blockquote>
<h1 id="十四、使用c标准库中的printf输出"><a href="#十四、使用c标准库中的printf输出" class="headerlink" title="十四、使用c标准库中的printf输出"></a>十四、使用c标准库中的printf输出</h1><p>本章节搭建了文件系统框架，引入了字符设备驱动程序，并引用<code>newlib</code>。</p>
<h2 id="14-1-增加文件系统调用"><a href="#14-1-增加文件系统调用" class="headerlink" title="14.1 增加文件系统调用"></a>14.1 增加文件系统调用</h2><p>整理<code>app</code>库下面的所有文件：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405220934175.png" alt="image-20240522093404627" style="zoom:50%;" />

<p>在<code>libapp.a</code>中包含了<code>lib_syscall.c</code>相关的代码。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405220952365.png" alt="image-20240522095247136"></p>
<p>因此在将<code>lib_syscall.h</code>中的内联函数修改到<code>lib_syscall.c</code>中后，需要将<code>shell</code>工程与<code>applib.a</code>这个库链接起来。</p>
<p>在<code>kernel/CMakeLists.txt</code>中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(LIBS_FLAGS &quot;-L $&#123;CMAKE_BINARY_DIR&#125;/source/applib/ -lapp&quot;)</span><br><span class="line">set(CMAKE_EXE_LINKER_FLAGS &quot;-m elf_i386  -T $&#123;PROJECT_SOURCE_DIR&#125;/kernel.lds $&#123;LIBS_FLAGS&#125;&quot;)</span><br></pre></td></tr></table></figure>



<p>此时调试，会发现进入<code>getpid()</code>内部时出现异常，其中	<code>EIP=0x13D77</code>，说明是在<code>1MB</code>空间内出现了异常。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">3</span>;  <span class="comment">// 父子进程各自拥有一份自己的count</span></span><br><span class="line">    <span class="type">int</span> pid = getpid();  <span class="comment">// here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405220958926.png" alt="image-20240522095820675"></p>
<p>在<code>kernel_dis.txt</code>文件中对<code>getpid()</code>进程搜索，发现其所处的位置即在<code>1MB</code>空间内。但它作为一个系统调用的接口函数，不应该放在操作系统空间内，而应该放在用户进程空间内，即<code>0x80000000</code>以上的位置。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221000006.png" alt="image-20240522100021888"></p>
<p>因此需要对<code>kernel/kernel.lds</code>进行修改，将<code>applib</code>相关的代码和数据放到<code>0x80000000</code>以上的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">. = 0x80000000;</span><br><span class="line">PROVIDE(s_first_task = LOADADDR(.first_task));</span><br><span class="line">.first_task : AT(e_data) &#123;</span><br><span class="line">	*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">	*first_task*(.text .rodata .bss .data)</span><br><span class="line">	*lib_syscall*(.text .rodata .bss .data)</span><br><span class="line">&#125;</span><br><span class="line">PROVIDE(e_first_task = LOADADDR(.first_task) + SIZEOF(.first_task));</span><br></pre></td></tr></table></figure>

<p>再次调试，<code>EIP</code>的地址正确：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221007171.png" alt="image-20240522100723076"></p>
<h2 id="14-2-导入newlib-c并引入printf"><a href="#14-2-导入newlib-c并引入printf" class="headerlink" title="14.2 导入newlib c并引入printf"></a>14.2 导入newlib c并引入printf</h2><p><code>newlib</code>库简介：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221022455.png" alt="image-20240522102216196"></p>
<p>引入<code>newlib</code>库之后的整体结构：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221023403.png" alt="image-20240522102346233" style="zoom:50%;" />

<p>在<code>shell</code>工程中引入<code>newlib</code>库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(LIBS_FLAGS &quot;-L $&#123;CMAKE_BINARY_DIR&#125;/source/applib/ -lapp -L $&#123;CMAKE_BINARY_DIR&#125;/../../newlib/i686-elf/lib -lm -lc&quot;)</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221057186.png" alt="image-20240522105741951"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221059676.png" alt="image-20240522105925398"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加载elf文件到内存中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">load_elf_file</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次，读取程序头（Program Header），将内容拷贝到相应的位置</span></span><br><span class="line">    <span class="type">uint32_t</span> e_phoff = elf_hdr.e_phoff;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elf_hdr.e_phnum; i++, e_phoff += elf_hdr.e_phentsize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sys_lseek(file, e_phoff, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取程序头后解析，这里不用读取到新进程的页表中，因为只是临时使用下</span></span><br><span class="line">        cnt = sys_read(file, (<span class="type">char</span> *)&amp;elf_phdr, <span class="keyword">sizeof</span>(Elf32_Phdr));</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="keyword">sizeof</span>(Elf32_Phdr)) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单做一些检查，主要判断是否是可加载的类型，并且要求加载的地址必须是用户空间</span></span><br><span class="line">        <span class="keyword">if</span> ((elf_phdr.p_type != PT_LOAD) || (elf_phdr.p_vaddr &lt; MEM_TASK_BASE)) &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载当前程序头</span></span><br><span class="line">        <span class="type">int</span> err = load_phdr(file, &amp;elf_phdr, page_dir);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;load program hdr failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ========================= 新增 ========================= //</span></span><br><span class="line">        <span class="comment">// 设置first_task的堆起始地址和结束地址</span></span><br><span class="line">        task-&gt;heap_start = elf_phdr.p_vaddr + elf_phdr.p_memsz;  </span><br><span class="line">        	<span class="comment">// 通过循环，最终指向进程地址空间中最后一个表项的末端地址</span></span><br><span class="line">        	<span class="comment">// 也就是指向.bss的末端地址</span></span><br><span class="line">        task-&gt;heap_end = task-&gt;heap_start;</span><br><span class="line">        <span class="comment">// ========================= 新增 ========================= //</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、sbrk"><a href="#1、sbrk" class="headerlink" title="1、sbrk()"></a>1、sbrk()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 调整堆的内存分配，返回堆之前的指针</span></span><br><span class="line"><span class="comment"> *        目前并不处理incr小于0的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">sys_sbrk</span><span class="params">(<span class="type">int</span> incr)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *task = task_current();</span><br><span class="line">    <span class="type">int</span> pre_incr = incr;</span><br><span class="line">    <span class="type">char</span> *pre_heap_end = (<span class="type">char</span> *)task-&gt;heap_end;  <span class="comment">// 获取当前堆的末端地址</span></span><br><span class="line"></span><br><span class="line">    ASSERT(incr &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (incr == <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;sbrk(0): end=0x%x&quot;</span>, pre_heap_end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre_heap_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增长空间的起始地址（即原末端地址），和末端地址</span></span><br><span class="line">    <span class="type">uint32_t</span> start = task-&gt;heap_end;</span><br><span class="line">    <span class="type">uint32_t</span> end = start + incr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x81001024 - 0x81001048      0x81001024并非页边界对齐 ： 0x81001000 </span></span><br><span class="line">    <span class="comment">// 0x81001000 - 0x81001FFF      假定这块内存已经存在</span></span><br><span class="line">    <span class="type">int</span> start_offset = start % MEM_PAGE_SIZE;  <span class="comment">// 0x24，start地址在页中的偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (start_offset) &#123;</span><br><span class="line">        <span class="comment">// 若起始地址并非页边界对齐</span></span><br><span class="line">        <span class="keyword">if</span> (start_offset + incr &lt;= MEM_PAGE_SIZE) &#123;</span><br><span class="line">            <span class="comment">// 0x24 + incr 若并未超过一页，直接在原内存中分配</span></span><br><span class="line">            task-&gt;heap_end = end;  <span class="comment">// 0x81001048</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> pre_heap_end;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若超过一页，则先分配掉一页</span></span><br><span class="line">            <span class="type">uint32_t</span> curr_size = MEM_PAGE_SIZE - start_offset;  <span class="comment">// 当前页可分配内存</span></span><br><span class="line">            start += curr_size;</span><br><span class="line">            incr -= curr_size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若incr还有剩余，则新分配页来处理</span></span><br><span class="line">    <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> curr_size = end - start;</span><br><span class="line">        <span class="type">int</span> err = memory_alloc_page_for(start, curr_size, PTE_P | PTE_U | PTE_W);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;sbrk: alloc mem failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">char</span> *)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_printf(<span class="string">&quot;sbrk(%d): end = 0x%x&quot;</span>, pre_incr, end);</span><br><span class="line">    task-&gt;heap_end = end;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span> * )pre_heap_end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib_syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    sbrk(<span class="number">0</span>);</span><br><span class="line">    sbrk(<span class="number">100</span>);</span><br><span class="line">    sbrk(<span class="number">200</span>);</span><br><span class="line">    sbrk(<span class="number">4096</span> * <span class="number">2</span> + <span class="number">200</span>);</span><br><span class="line">    sbrk(<span class="number">4096</span> * <span class="number">5</span> + <span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from shell\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot; -- arg: %s&quot;</span>, (<span class="type">int</span>)argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fork();</span><br><span class="line">    yield();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot;shell pid=%d&quot;</span>, getpid());</span><br><span class="line">        msleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221251345.png" alt="image-20240522125116933"></p>
<h3 id="2、printf"><a href="#2、printf" class="headerlink" title="2、printf()"></a>2、printf()</h3><p><code>printf()</code>最终会通过文件系统的接口，将格式化好的数据写入标准输出。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221944469.png" alt="image-20240522194431100" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 写文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    ptr[len] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 加入结束符</span></span><br><span class="line">    log_printf(<span class="string">&quot;%s&quot;</span>, ptr);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十五、使用控制台与键盘进行输入输出"><a href="#十五、使用控制台与键盘进行输入输出" class="headerlink" title="十五、使用控制台与键盘进行输入输出"></a>十五、使用控制台与键盘进行输入输出</h1><h2 id="15-1-控制台简介"><a href="#15-1-控制台简介" class="headerlink" title="15.1 控制台简介"></a>15.1 控制台简介</h2><p>操作系统启动后可以分为图形模式和文本模式。但图形界面并不是一个操作系统必须的组件。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230918110.png" alt="image-20240523091843752" style="zoom:50%;" />

<p><strong>每个</strong>显示的字符由<strong>两个</strong>配置字节数据控制：</p>
<ul>
<li>一个字节用于显示的字符；</li>
<li>一个字节用于配置显示属性。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230920616.png" alt="image-20240523092019270" style="zoom: 50%;" />

<p>计算机上电启动后，显示器默认设置成<code>80列x25行</code>的文本显示模式。一屏的显示需要<code>80*25*2=4000</code>字节的显存，因此<code>32KB</code>可以装下<code>8</code>屏幕的显示内容。</p>
<ul>
<li><p>可以同时在几个虚拟屏幕上显示，相当于打开多个命令行窗口并显示相应的内容；<strong>（本项目主要实现）</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230925271.png" alt="image-20240523092543957" style="zoom:50%;" />
</li>
<li><p>也可以将<code>32KB</code>显存分成<code>8</code>块，每块分别用于显示虚拟的控制台界面。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230926563.png" alt="image-20240523092610198" style="zoom:50%;" /></li>
</ul>
<h2 id="15-2-在控制台上显示字符串"><a href="#15-2-在控制台上显示字符串" class="headerlink" title="15.2 在控制台上显示字符串"></a>15.2 在控制台上显示字符串</h2><h3 id="1、控制台结构体定义"><a href="#1、控制台结构体定义" class="headerlink" title="1、控制台结构体定义"></a>1、控制台结构体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符颜色</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">color_t</span> &#123;</span></span><br><span class="line">    COLOR_Black			= <span class="number">0</span>,</span><br><span class="line">    COLOR_Blue			= <span class="number">1</span>,</span><br><span class="line">    COLOR_Green			= <span class="number">2</span>,</span><br><span class="line">    COLOR_Cyan			= <span class="number">3</span>,</span><br><span class="line">    COLOR_Red			= <span class="number">4</span>,</span><br><span class="line">    COLOR_Magenta		= <span class="number">5</span>,</span><br><span class="line">    COLOR_Brown			= <span class="number">6</span>,</span><br><span class="line">    COLOR_Gray			= <span class="number">7</span>,</span><br><span class="line">    COLOR_Dark_Gray 	= <span class="number">8</span>,</span><br><span class="line">    COLOR_Light_Blue	= <span class="number">9</span>,</span><br><span class="line">    COLOR_Light_Green	= <span class="number">10</span>,</span><br><span class="line">    COLOR_Light_Cyan	= <span class="number">11</span>,</span><br><span class="line">    COLOR_Light_Red		= <span class="number">12</span>,</span><br><span class="line">    COLOR_Light_Magenta	= <span class="number">13</span>,</span><br><span class="line">    COLOR_Yellow		= <span class="number">14</span>,</span><br><span class="line">    COLOR_White			= <span class="number">15</span></span><br><span class="line">&#125;<span class="type">color_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述显存字符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">disp_char_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">char</span> foreground : <span class="number">4</span>;</span><br><span class="line">        <span class="type">char</span> background : <span class="number">3</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint16_t</span> v;  <span class="comment">// 16位，一个字节表示字符；另一个字节表示属性</span></span><br><span class="line">&#125;<span class="type">disp_char_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">console_t</span> &#123;</span></span><br><span class="line">    <span class="type">disp_char_t</span> *disp_base;             <span class="comment">// 控制台基地址</span></span><br><span class="line">    <span class="type">int</span> disp_rows, disp_cols;           <span class="comment">// 总的行列数</span></span><br><span class="line">    <span class="type">int</span> cursor_row, cursor_col;         <span class="comment">// 当前光标所在的行列数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">color_t</span> foreground, background;     <span class="comment">// 字符颜色</span></span><br><span class="line">&#125;<span class="type">console_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、显示字符串"><a href="#2、显示字符串" class="headerlink" title="2、显示字符串"></a>2、显示字符串</h3><p>目前的所有写操作都定向到了<code>fs.c</code>部分，在<code>sys_write()</code>中采用<code>log_printf()</code>来输出，对其进行修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 写文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    console_write(<span class="number">0</span>, ptr, len);</span><br><span class="line">    <span class="comment">// ptr[len] = &#x27;\0&#x27;;</span></span><br><span class="line">    <span class="comment">// log_printf(&quot;%s&quot;, ptr);</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此时调试，进入页异常：<code>Page doesn&#39;t present 0xB80A0</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231017216.png" alt="image-20240523101700997"></p>
<p>这是因为在创建内核页表时，没有加入显存部分的映射：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建内核页表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_kernel_table</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 地址映射表, 用于建立内核级的地址映射</span></span><br><span class="line">    <span class="comment">// 地址不变，但是添加了属性</span></span><br><span class="line">    <span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">        &#123;kernel_base,   s_text,         <span class="number">0</span>,              PTE_W&#125;,                           <span class="comment">// 内核栈区</span></span><br><span class="line">        &#123;s_text,        e_text,         s_text,         <span class="number">0</span>&#125;,                               <span class="comment">// 内核代码区</span></span><br><span class="line">        &#123;s_data,        (<span class="type">void</span> *)(MEM_EBDA_START - <span class="number">1</span>),   s_data,        PTE_W&#125;,            <span class="comment">// 内核数据区</span></span><br><span class="line">        <span class="comment">// ========================================== 新增 ========================================== //</span></span><br><span class="line">        &#123;(<span class="type">void</span> *)CONSOLE_DISP_ADDR, (<span class="type">void</span> *)CONSOLE_DISP_END, (<span class="type">void</span> *)CONSOLE_DISP_ADDR, PTE_W&#125;,  <span class="comment">// 控制台</span></span><br><span class="line">        <span class="comment">// ========================================== 新增 ========================================== //</span></span><br><span class="line">        &#123;(<span class="type">void</span> *)MEM_EXT_START, (<span class="type">void</span> *)MEM_EXT_END,     (<span class="type">void</span> *)MEM_EXT_START, PTE_W&#125;,   <span class="comment">// 扩展存储空间一一映射，方便直接操作</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串显示函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 控制台写内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param console 要写第几块控制台，所以传入int</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 写入的字符数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">console_write</span> <span class="params">(<span class="type">int</span> console, <span class="type">char</span> *data, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> *c = console_buf + console;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; size; len++) &#123;</span><br><span class="line">        <span class="comment">// 依次取出要写入的字符</span></span><br><span class="line">        <span class="type">char</span> ch = *data++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行写入操作，显示字符串</span></span><br><span class="line">        show_char(c, ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的输出结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231024410.png" alt="image-20240523102431257"></p>
<p>对上述函数进行改进：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 控制台写内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param console 要写第几块控制台，所以传入int</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 写入的字符数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">console_write</span> <span class="params">(<span class="type">int</span> console, <span class="type">char</span> *data, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> *c = console_buf + console;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; size; len++) &#123;</span><br><span class="line">        <span class="comment">// 依次取出要写入的字符</span></span><br><span class="line">        <span class="type">char</span> ch = *data++;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">                move_to_col0(console);      <span class="comment">// 行号不变，列号变0</span></span><br><span class="line">                move_next_line(console);    <span class="comment">// 行号下移，列号不变</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:         </span><br><span class="line">            <span class="comment">// 执行写入操作，显示字符串</span></span><br><span class="line">            show_char(c, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、清屏"><a href="#3、清屏" class="headerlink" title="3、清屏"></a>3、清屏</h3><p>只需要将当前屏幕对应的显存显示内容全部用空格符清空，或者用前景色和后景色相同的字符清空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 清屏操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_diaplay</span><span class="params">(<span class="type">console_t</span> *console)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算整个屏幕的字符量</span></span><br><span class="line">    <span class="type">int</span> size = console-&gt;disp_cols * console-&gt;disp_rows;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从基地址开始依次遍历</span></span><br><span class="line">    <span class="type">disp_char_t</span> *start = console-&gt;disp_base;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++, start++) &#123;</span><br><span class="line">        start-&gt;c = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        start-&gt;foreground = console-&gt;foreground;</span><br><span class="line">        start-&gt;background = console-&gt;background;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、滚屏"><a href="#4、滚屏" class="headerlink" title="4、滚屏"></a>4、滚屏</h3><p>注意以下两种情况需要滚屏：</p>
<ul>
<li>1）当光标前移时，若到达行末尾处需要移动到下一行，此时就需要判断当前是否需要滚屏；</li>
<li>2）在控制台写入内容时，若遇到换行操作，也需要判断当前是否需要滚屏。</li>
</ul>
<p>将除最底部的行外全部上移一行，再将最下边一行清空。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231031828.png" alt="image-20240523103159602" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 擦除从start到end的行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">erase_rows</span> <span class="params">(<span class="type">console_t</span> * console, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">disp_char_t</span> * disp_start = console-&gt;disp_base + console-&gt;disp_cols * start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">disp_char_t</span> * disp_end = console-&gt;disp_base + console-&gt;disp_cols * (end + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (disp_start &lt; disp_end) &#123;</span><br><span class="line">        disp_start-&gt;c = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        disp_start-&gt;foreground = console-&gt;foreground;</span><br><span class="line">        disp_start-&gt;background = console-&gt;background;</span><br><span class="line"></span><br><span class="line">        disp_start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 整体屏幕上移若干行</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param lines 上移的行数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">scroll_up</span><span class="params">(<span class="type">console_t</span> * console, <span class="type">int</span> lines)</span> &#123;</span><br><span class="line">    <span class="comment">// 整体上移</span></span><br><span class="line">    <span class="type">disp_char_t</span> * dest = console-&gt;disp_base;</span><br><span class="line">    <span class="type">disp_char_t</span> * src = console-&gt;disp_base + console-&gt;disp_cols * lines;</span><br><span class="line">    <span class="comment">// console-&gt;disp_rows - lines    上移后剩余的行数A</span></span><br><span class="line">    <span class="comment">// A *console-&gt;disp_cols         整体剩余的字符数（也就是上移后需要显示字符数）</span></span><br><span class="line">    <span class="type">uint32_t</span> size = (console-&gt;disp_rows - lines) * console-&gt;disp_cols * <span class="keyword">sizeof</span>(<span class="type">disp_char_t</span>);</span><br><span class="line">    kernel_memcpy(dest, src, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 擦除最后一行</span></span><br><span class="line">    erase_rows(console, console-&gt;disp_rows - lines, console-&gt;disp_rows - <span class="number">1</span>);</span><br><span class="line">    console-&gt;cursor_row -= lines;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-3-设置光标并重定向日志输出到显示器"><a href="#15-3-设置光标并重定向日志输出到显示器" class="headerlink" title="15.3 设置光标并重定向日志输出到显示器"></a>15.3 设置光标并重定向日志输出到显示器</h2><p>光标的位置分<strong>高8位和低8位</strong>两部分来表示，由于当前显示为<code>80*25</code>，共<code>2000</code>个字符，所以位置取值为<code>0~1999</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 读取当前光标的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_cursor_pos</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line"></span><br><span class="line"> 	outb(<span class="number">0x3D4</span>, <span class="number">0x0F</span>);		<span class="comment">// 写低地址</span></span><br><span class="line">	pos = inb(<span class="number">0x3D5</span>);</span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0x0E</span>);		<span class="comment">// 写高地址</span></span><br><span class="line">	pos |= inb(<span class="number">0x3D5</span>) &lt;&lt; <span class="number">8</span>;   </span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 更新鼠标的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_cursor_pos</span> <span class="params">(<span class="type">console_t</span> * console)</span> &#123;</span><br><span class="line">	<span class="type">uint16_t</span> pos = console-&gt;cursor_row *  console-&gt;display_cols + console-&gt;cursor_col;</span><br><span class="line"></span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0x0F</span>);		<span class="comment">// 写低地址</span></span><br><span class="line">	outb(<span class="number">0x3D5</span>, (<span class="type">uint8_t</span>) (pos &amp; <span class="number">0xFF</span>));</span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0x0E</span>);		<span class="comment">// 写高地址</span></span><br><span class="line">	outb(<span class="number">0x3D5</span>, (<span class="type">uint8_t</span>) ((pos &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-4-保存并恢复光标位置"><a href="#15-4-保存并恢复光标位置" class="headerlink" title="15.4 保存并恢复光标位置"></a>15.4 保存并恢复光标位置</h2><p><code>ANSI</code>转义序列(<code>ANSI escape sequences</code>)，可用于控制视频终端上的光标位置、颜色和其他选项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\0337Hello, world!\0338123\n&quot;</span>);  <span class="comment">// 123lo,world!</span></span><br></pre></td></tr></table></figure>

<p><code>\0337</code>在<code>7</code>的位置保存光标位置，然后在<code>\0338</code>中<code>8</code>的位置用<code>123</code>进行替换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 普通状态下的字符的写入处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_normal</span> <span class="params">(<span class="type">console_t</span> * console, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> ASCII_ESC:</span><br><span class="line">            console-&gt;write_state = CONSOLE_WRITE_ESC;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 写入以ESC开头的序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_esc</span> <span class="params">(<span class="type">console_t</span> * console, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// https://blog.csdn.net/ScilogyHunter/article/details/106874395</span></span><br><span class="line">    <span class="comment">// ESC状态处理, 转义序列模式 ESC 0x20-0x27(0或多个) 0x30-0x7e</span></span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:		<span class="comment">// ESC 7 保存光标</span></span><br><span class="line">            save_cursor(console);</span><br><span class="line">            console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:		<span class="comment">// ESC 8 恢复光标</span></span><br><span class="line">            restore_cursor(console);</span><br><span class="line">            console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 控制台写内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param console 要写第几块控制台，所以传入int</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 写入的字符数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">console_write</span> <span class="params">(<span class="type">int</span> console, <span class="type">char</span> *data, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> *c = console_buf + console;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; size; len++) &#123;</span><br><span class="line">        <span class="comment">// 依次取出要写入的字符</span></span><br><span class="line">        <span class="type">char</span> ch = *data++;</span><br><span class="line">        <span class="keyword">switch</span> (c-&gt;write_state) &#123;</span><br><span class="line">            <span class="keyword">case</span> CONSOLE_WRITE_NORMAL: &#123;</span><br><span class="line">                write_normal(c, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CONSOLE_WRITE_ESC:</span><br><span class="line">                write_esc(c, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update_cursor_pos(c);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-5-更新显示字体的颜色"><a href="#15-5-更新显示字体的颜色" class="headerlink" title="15.5 更新显示字体的颜色"></a>15.5 更新显示字体的颜色</h2><blockquote>
<p>详见《LINUX内核完全剖析：基于0.12内核》附录部分。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231527961.png" alt="image-20240523152720901" style="zoom:50%;" />&#96;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理ESC [Pn;Pn 开头的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_esc_square</span> <span class="params">(<span class="type">console_t</span> * console, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 接收参数</span></span><br><span class="line">    <span class="keyword">if</span> ((c &gt;= <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (c &lt;= <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 解析当前参数</span></span><br><span class="line">        <span class="type">int</span> * param = &amp;console-&gt;esc_param[console-&gt;curr_param_index];</span><br><span class="line">        *param = *param * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c == <span class="string">&#x27;;&#x27;</span>) &amp;&amp; console-&gt;curr_param_index &lt; ESC_PARAM_MAX) &#123;</span><br><span class="line">        <span class="comment">// 参数结束，继续处理下一个参数</span></span><br><span class="line">        console-&gt;curr_param_index++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 结束上一字符的处理</span></span><br><span class="line">        console-&gt;curr_param_index++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已经接收到所有的字符，继续处理</span></span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: <span class="comment">// 设置字符属性</span></span><br><span class="line">            set_font_style(console);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:	<span class="comment">// 光标左移n个位置 ESC [Pn D</span></span><br><span class="line">            move_left(console, console-&gt;esc_param[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            move_right(console, console-&gt;esc_param[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">            move_cursor(console);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>:</span><br><span class="line">            erase_in_display(console);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-6-键盘初始化"><a href="#15-6-键盘初始化" class="headerlink" title="15.6 键盘初始化"></a>15.6 键盘初始化</h2><p>计算机中使用键盘控制器(<code>8042</code>)控制鼠标和键盘。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231600337.png" alt="image-20240523160008317" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231601872.png" alt="image-20240523160123502" style="zoom: 80%;" />

<p><strong>只需要对键盘的中断进行重写设置，而不需要自己去重新初始化键盘。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kbd_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    irq_install(IRQ1_KEYBOARD, (<span class="type">irq_handler_t</span>)exception_handler_kbd);</span><br><span class="line">    irq_enable(IRQ1_KEYBOARD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_kbd</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在<code>init/start.S</code>中进行增加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 硬件中断</span><br><span class="line">exception_handler kbd, 0x21, 0</span><br></pre></td></tr></table></figure>

<h2 id="15-7-借助按键映射表进行键值转换"><a href="#15-7-借助按键映射表进行键值转换" class="headerlink" title="15.7 借助按键映射表进行键值转换"></a>15.7 借助按键映射表进行键值转换</h2><p>当按键按下时和弹出时，都会产生一串扫描码，<strong>其数值并不与键盘上的字符ASCII相同</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231618145.png" alt="image-20240523161852835"></p>
<h1 id="十六、设备管理与文件系统"><a href="#十六、设备管理与文件系统" class="headerlink" title="十六、设备管理与文件系统"></a>十六、设备管理与文件系统</h1><h2 id="16-1-设备管理框架"><a href="#16-1-设备管理框架" class="headerlink" title="16.1 设备管理框架"></a>16.1 设备管理框架</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231934732.png" alt="image-20240523193407466" style="zoom:50%;" />

<p>在计算系统中，往往有很多种不同类型的设备，操作系统需要对这些设备进行统一管理。为每种类型设备都提供一套操作接口并不现实，且操作系统难以处理。因此，需要对设备进行“<strong>抽象</strong>”，得到所谓的“<strong>设备管理层</strong>”，负责对不同类型的设备进行抽象管理。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231936141.png" alt="image-20240523193634814" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231936997.png" alt="image-20240523193649716" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_NAME_SIZE       32</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DEV_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">dev_desc_t</span>;</span></span><br><span class="line"><span class="comment">// 特定设备结构（定义该类设备下特殊设备的特殊性质）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">device_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dev_desc_t</span> *<span class="title">desc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mode;       <span class="comment">// 特殊属性</span></span><br><span class="line">    <span class="type">int</span> minor;      <span class="comment">// 次设备号（主次设备号决定具体是哪个设备）</span></span><br><span class="line">    <span class="type">void</span> *data;     <span class="comment">// 设备相关参数</span></span><br><span class="line">    <span class="type">int</span> open_count; <span class="comment">// 设备打开次数</span></span><br><span class="line">&#125;<span class="type">device_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象设备结构（定义某类设备的一般特性）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">dev_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[DEV_NAME_SIZE];   <span class="comment">// 设备名称</span></span><br><span class="line">    <span class="type">int</span> major;                  <span class="comment">// 主设备号</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="type">device_t</span> *dev);</span><br><span class="line">    <span class="type">int</span> (*read)(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size);</span><br><span class="line">    <span class="type">int</span> (*write)(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size);</span><br><span class="line">    <span class="type">int</span> (*control)(<span class="type">device_t</span> *dev, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="type">device_t</span> *dev);</span><br><span class="line">&#125;<span class="type">dev_desc_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="16-2-增加tty设备"><a href="#16-2-增加tty设备" class="headerlink" title="16.2 增加tty设备"></a>16.2 增加tty设备</h2><h3 id="1、理论-1"><a href="#1、理论-1" class="headerlink" title="1、理论"></a>1、理论</h3><p>由于键盘和显示器密切相关，因此将二者抽象为一种硬件设备<code>tty</code>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231949301.png" alt="image-20240523194931067" style="zoom:50%;" />

<p>操作系统需要提供一套抽象机制，对所有设备进行抽象管理，以向上屏蔽复杂的硬件细节。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231950402.png" alt="image-20240523195038914"></p>
<p>上图中左边的<code>5</code>个函数最终会被注册到<code>_dev_desc_t</code>的<code>5</code>个函数指针中。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232005483.png" alt="image-20240523200517185"  />

<h3 id="2、增加tty设备的过程"><a href="#2、增加tty设备的过程" class="headerlink" title="2、增加tty设备的过程"></a>2、增加<code>tty</code>设备的过程</h3><ol>
<li><p>新增<code>tty.c</code>和<code>tty.h</code>；</p>
</li>
<li><p>在<code>tty.c</code>中实现<code>tty</code>相应的设备管理操作；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_open</span> <span class="params">(<span class="type">device_t</span> *dev)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_write</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_control</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1)</span>;</span><br></pre></td></tr></table></figure>

<p>并将上述操作注册到<code>dev_desc_t</code>中，定义一个<code>dev_tty_desc</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dev_desc_t</span> dev_tty_desc = &#123;</span><br><span class="line">    .name = <span class="string">&quot;tty&quot;</span>,</span><br><span class="line">    .major = DEV_TTY,</span><br><span class="line">    .open = tty_open,</span><br><span class="line">    .read = tty_read,</span><br><span class="line">    .write = tty_write,</span><br><span class="line">    .control = tty_control,</span><br><span class="line">    .close = tty_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>dev.c</code>中声明外部变量<code>dev_tty_desc</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">dev_desc_t</span> dev_tty_desc;</span><br></pre></td></tr></table></figure>

<p>接下来根据<code>tty</code>相关操作实现上层接口函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dev_open</span> <span class="params">(<span class="type">int</span> major, <span class="type">int</span> minor, <span class="type">void</span> *data)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_read</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_write</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_control</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_close</span> <span class="params">(<span class="type">int</span> dev_id)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为<code>tty</code>设备添加结构描述</p>
<p>根据<code>32KB</code>显存可显示<code>8</code>块屏幕，将键盘与<code>8</code>块（虚拟）屏幕共享：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232032635.png" alt="image-20240523203230358" style="zoom: 67%;" />

<p>因此，为所有设备定义一个<code>tty</code>数组，分别对应一部分显存。但是，由于操作系统的运行速度很快，因此向设备发送指令&#x2F;数据也很快；但设备的速度很慢，所以硬件写指令&#x2F;数据很慢，所以需要在设备驱动中配置缓存，用于解决这种速度不匹配的问题。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232037597.png" alt="image-20240523203716361"></p>
</li>
</ol>
<p>当前在<code>log.c</code>中采用<code>console_write()</code>进行打印操作，但未来也可能有其他的设备需要进行打印操作，因此需要进行修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> log_dev_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化日志输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    mutex_init(&amp;mutex);</span><br><span class="line">    log_dev_id = dev_open(DEV_TTY, <span class="number">0</span>, (<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 日志打印</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// console_write(0, str_buf, kernel_strlen(str_buf));</span></span><br><span class="line">    dev_write(log_dev_id, <span class="number">0</span>, str_buf, kernel_strlen(str_buf));</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">// console_write(0, &amp;c, 1);</span></span><br><span class="line">    dev_write(log_dev_id, <span class="number">0</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样后续修改设备时，只需要在初始化时对<code>dev_open</code>进行改动即可。</p>
<h3 id="3、定义tty设备"><a href="#3、定义tty设备" class="headerlink" title="3、定义tty设备"></a>3、定义tty设备</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_IBUF_SIZE				512		<span class="comment">// tty输入缓存大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_OBUF_SIZE				512		<span class="comment">// tty输出缓存大小</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的 FIFO（First In, First Out）缓冲区，</span></span><br><span class="line"><span class="comment"> * 用于在字符设备（例如终端）中管理数据流。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tty_fifo_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *buf;      <span class="comment">// 指向存储缓冲区数据的指针</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">// 缓冲区的最大字节数</span></span><br><span class="line">    <span class="type">int</span> read;       <span class="comment">// 当前读位置的索引</span></span><br><span class="line">    <span class="type">int</span> write;      <span class="comment">// 当前写位置的索引</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 缓冲区中已有的数据量</span></span><br><span class="line">&#125;<span class="type">tty_fifo_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tty_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> obuf[TTY_OBUF_SIZE];  <span class="comment">// 输出缓冲区</span></span><br><span class="line">    <span class="type">tty_fifo_t</span> ofifo;          <span class="comment">// 输出FIFO队列</span></span><br><span class="line">    <span class="type">char</span> ibuf[TTY_IBUF_SIZE];  <span class="comment">// 输入缓冲区</span></span><br><span class="line">    <span class="type">tty_fifo_t</span> ififo;          <span class="comment">// 输入处理后的FIFO队列</span></span><br><span class="line">&#125;<span class="type">tty_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4、打开tty设备"><a href="#4、打开tty设备" class="headerlink" title="4、打开tty设备"></a>4、打开tty设备</h3><p>当<code>write</code>指向队列尾部时，会重新移到队头的位置，直到整个队列中没有空闲位置。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232051032.png" alt="image-20240523205100776" style="zoom:50%;" />

<p>由于整个系统中存在多个<code>tty</code>设备，因此对于键盘的初始化应该仅设置为一次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kbd_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> inited = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!inited) &#123;</span><br><span class="line">        irq_install(IRQ1_KEYBOARD, (<span class="type">irq_handler_t</span>)exception_handler_kbd);</span><br><span class="line">        irq_enable(IRQ1_KEYBOARD);</span><br><span class="line"></span><br><span class="line">        inited = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于<code>console</code>的初始化，需要区别第<code>0</code>块还是其他块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 控制台初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">console_init</span> <span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> *console = console_buf + idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里类型转换为disp_char_t *，那么CONSOLE_COL_MAX * CONSOLE_ROW_MAX就不必再乘以2</span></span><br><span class="line">    <span class="comment">// uint16_t *v = 0x1234;</span></span><br><span class="line">    <span class="comment">// v++;  // v = 0x1236，会按照uint16_t的类型来自增</span></span><br><span class="line">    console-&gt;disp_base = (<span class="type">disp_char_t</span> *)(CONSOLE_DISP_ADDR + idx *(CONSOLE_COL_MAX * CONSOLE_ROW_MAX));</span><br><span class="line"></span><br><span class="line">    console-&gt;disp_cols = CONSOLE_COL_MAX;</span><br><span class="line">    console-&gt;disp_rows = CONSOLE_ROW_MAX;</span><br><span class="line">    console-&gt;foreground = COLOR_White;</span><br><span class="line">    console-&gt;background = COLOR_Black;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console-&gt;cursor_col = 0;  不这样写，避免清空Boot和Loader的信息</span></span><br><span class="line">    <span class="comment">// console-&gt;cursor_row = 0;</span></span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> cursor_pos = read_cursor_pos();</span><br><span class="line">        console-&gt;cursor_row = cursor_pos / console-&gt;disp_cols;</span><br><span class="line">        console-&gt;cursor_col = cursor_pos % console-&gt;disp_cols;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        console-&gt;cursor_row = <span class="number">0</span>;</span><br><span class="line">        console-&gt;cursor_col = <span class="number">0</span>;    </span><br><span class="line">        clear_display(console);</span><br><span class="line">        update_cursor_pos(console);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console-&gt;old_cursor_row = console-&gt;cursor_row;</span><br><span class="line">    console-&gt;old_cursor_col = console-&gt;cursor_col;</span><br><span class="line"></span><br><span class="line">    console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、通过tty设备写显示数据"><a href="#5、通过tty设备写显示数据" class="headerlink" title="5、通过tty设备写显示数据"></a>5、通过tty设备写显示数据</h3><p>下图所示的缓存按字节存储数据，其中<code>write</code>指向下一待写入数据的位置，<code>read</code>指向下一数据读取的位置。</p>
<p>注项目中实际并未涉及到中断部分。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232118966.png" alt="image-20240523211809752" style="zoom:50%;" />

<p>最简单的方式，进程向硬件写入数据，然后等待硬件发送完成，再写入数据，如此反复，直到所有数据发送完毕。整个过程效率很低。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232120477.png" alt="image-20240523212056141"  />

<p>当加入缓存后，整个实现机制就改变了。一般情况下，进程负责向缓存写入数据，然后启动硬件发送机制，之后由硬件自动完成所有数据的发送，从而完成高效率地数据发送机制。</p>
<p>相比查询来说，速度要更快，进程不必等待。也就是说，在要发送的数据量小于缓存区的大小时，进程只需要将数据丢入缓存区即可退出，不需要再去考虑硬件的后续处理。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232122435.png" alt="image-20240523212223213"></p>
<p>当调用到<code>console_write()</code>时的调用堆栈如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232144307.png" alt="image-20240523214408045"></p>
<h2 id="16-3-文件系统初始化"><a href="#16-3-文件系统初始化" class="headerlink" title="16.3 文件系统初始化"></a>16.3 文件系统初始化</h2><p>操作系统使用文件系统对磁盘上的存储进行管理，给应用程序提供以文件组织的视图。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405240932371.png" alt="image-20240524093221478"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405240932986.png" alt="image-20240524093256519"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405240933690.png" alt="image-20240524093348655"></p>
<p>定义相关结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_NAME_SIZE      32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_TABLE_SIZE     2048</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">file_type_t</span> &#123;</span></span><br><span class="line">    FILE_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">    FILE_TTY,</span><br><span class="line">&#125;<span class="type">file_type_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">file_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> file_name[FILE_NAME_SIZE];     <span class="comment">// 文件名称</span></span><br><span class="line">    <span class="type">file_type_t</span> type;                   <span class="comment">// 文件类型</span></span><br><span class="line">    <span class="type">uint32_t</span> size;                      <span class="comment">// 文件大小</span></span><br><span class="line">    <span class="type">int</span> ref;                            <span class="comment">// 文件打开次数</span></span><br><span class="line">    <span class="type">int</span> dev_id;                         <span class="comment">// 文件对应设备号</span></span><br><span class="line">    <span class="type">int</span> pos;                            <span class="comment">// 文件当前读取位置</span></span><br><span class="line">    <span class="type">int</span> mode;                           <span class="comment">// 文件读取模式，只读/读写</span></span><br><span class="line">&#125;<span class="type">file_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">file_table_init</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">file_t</span> *<span class="title function_">file_alloc</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">file_free</span> <span class="params">(<span class="type">file_t</span> *file)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="16-4-为进程添加文件打开表"><a href="#16-4-为进程添加文件打开表" class="headerlink" title="16.4 为进程添加文件打开表"></a>16.4 为进程添加文件打开表</h3><p>在实际应用场合中，往往同时运行着很多应用进程，每个应用进程都可能会进行文件的读写操作。因此，存在下列问题：</p>
<ul>
<li>每个进程需要记录自己打开了哪些文件；</li>
<li>同一件文件可能同时被多个进程同时打开。</li>
</ul>
<p>因此，为了实现文件打开的共享，每个进程只保存一个指针表，其中每项指向自己所打开的文件描述符。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405241450969.png" alt="image-20240524145013782" style="zoom:50%;" />



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_alloc_fd</span> <span class="params">(<span class="type">file_t</span> *file)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">task_remove_fd</span> <span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">file_t</span> *<span class="title function_">task_file</span> <span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="16-4-打开tty设备并向其写入数据"><a href="#16-4-打开tty设备并向其写入数据" class="headerlink" title="16.4 打开tty设备并向其写入数据"></a>16.4 打开tty设备并向其写入数据</h2><p>文件系统是处于设备管理层之上的。如果对文件进行相应的操作，不能直接调用tty相关的代码，因此文件系统调用设备管理相关的代码，其再调用tty相关的代码。</p>
<p>也就是说，调用层级从高到低依次如下：<code>sys-&gt;dev-&gt;tty</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> flags, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_lseek</span><span class="params">(<span class="type">int</span> file, <span class="type">int</span> ptr, <span class="type">int</span> dir)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_close</span><span class="params">(<span class="type">int</span> file)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_isatty</span><span class="params">(<span class="type">int</span> file)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_fstat</span><span class="params">(<span class="type">int</span> file, <span class="keyword">struct</span> stat *st)</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dev.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_open</span> <span class="params">(<span class="type">int</span> major, <span class="type">int</span> minor, <span class="type">void</span> *data)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_read</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_write</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_control</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_close</span> <span class="params">(<span class="type">int</span> dev_id)</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tty.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_open</span> <span class="params">(<span class="type">device_t</span> *dev)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_write</span> <span class="params">(<span class="type">device_t</span> * dev, <span class="type">int</span> addr, <span class="type">char</span> * buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_control</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_close</span> <span class="params">(<span class="type">device_t</span> *dev)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="16-5-从tty读取键值字符串并显示"><a href="#16-5-从tty读取键值字符串并显示" class="headerlink" title="16.5 从tty读取键值字符串并显示"></a>16.5 从tty读取键值字符串并显示</h2><p>原理图如下：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242032828.png" alt="image-20240524203218224" style="zoom:50%;" />

<h3 id="1、向缓冲区写入，并通知硬件数据已到达"><a href="#1、向缓冲区写入，并通知硬件数据已到达" class="headerlink" title="1、向缓冲区写入，并通知硬件数据已到达"></a>1、向缓冲区写入，并通知硬件数据已到达</h3><p>当有按键按下时，调用<code>tty_in()</code>，此时：</p>
<p>1）首先通过信号量判断缓冲区是否有空闲区域；</p>
<p>2）若有，则会将按下的字符<code>ch</code>放入<code>ififo</code>缓冲区，并通过<code>sem_notify()</code>通知硬件有数据到达；</p>
<p>3）否则，进入等待状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kbd.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理单字符的标准键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_normal_key</span> <span class="params">(<span class="type">uint8_t</span> raw_code)</span> &#123;</span><br><span class="line">    <span class="type">char</span> key = get_key(raw_code);		<span class="comment">// 去掉最高位</span></span><br><span class="line">    <span class="type">int</span> is_make = is_make_code(raw_code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂时只处理按键按下的状态</span></span><br><span class="line">	<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (is_make) &#123;</span><br><span class="line">            ...</span><br><span class="line">            tty_in(<span class="number">0</span>, key);  <span class="comment">// important</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tty.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 输入tty字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_in</span> <span class="params">(<span class="type">int</span> idx, <span class="type">char</span> ch)</span> &#123;</span><br><span class="line">	<span class="type">tty_t</span> *tty = tty_devs + idx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将ch放入ififo缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> (sem_count(&amp;tty-&gt;isem) &gt;= TTY_IBUF_SIZE) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写入辅助队列，通知数据到达</span></span><br><span class="line">	tty_fifo_put(&amp;tty-&gt;ififo, ch);</span><br><span class="line">	sem_notify(&amp;tty-&gt;isem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、从缓冲区读取数据"><a href="#2、从缓冲区读取数据" class="headerlink" title="2、从缓冲区读取数据"></a>2、从缓冲区读取数据</h3><p>通过缓存实现进程和中断之间的配合。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *pbuf = buf;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;  <span class="comment">// 当前读取长度</span></span><br><span class="line">	<span class="comment">// 遍历buf读数据</span></span><br><span class="line">	<span class="keyword">while</span> (len &lt; size) &#123;</span><br><span class="line">		sem_wait(&amp;tty-&gt;isem);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> ch;</span><br><span class="line">		<span class="comment">// 从缓冲区取数据</span></span><br><span class="line">		tty_fifo_get(&amp;tty-&gt;ififo, &amp;ch);</span><br><span class="line">       ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-6-打开标准输出及错误输出文件"><a href="#16-6-打开标准输出及错误输出文件" class="headerlink" title="16.6 打开标准输出及错误输出文件"></a>16.6 打开标准输出及错误输出文件</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242035079.png" alt="image-20240524203555183"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242040884.png" alt="image-20240524204007541"></p>
<blockquote>
<p>在操作系统中，TTY设备（终端设备）通常与标准输入输出文件（即 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code>）关联，以便用户能够通过终端设备与系统交互。具体的关联机制可能因操作系统的不同而有所差异，但大致可以分为以下几个步骤和组件：</p>
<ol>
<li><strong>设备驱动与设备文件的关联</strong></li>
</ol>
<p>TTY设备的驱动程序定义了如何与实际的终端硬件进行交互。设备文件（如 <code>/dev/tty</code>）是设备驱动的一个接口，使用户空间程序可以通过文件系统与设备驱动交互。设备文件通常在操作系统启动时由设备驱动创建并注册到文件系统中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// TTY设备驱动的初始化</span></span><br><span class="line">&gt;<span class="type">void</span> <span class="title function_">tty_init</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 注册TTY设备</span></span><br><span class="line">   <span class="type">dev_desc_t</span> dev_tty_desc = &#123;</span><br><span class="line">       .name = <span class="string">&quot;tty&quot;</span>,</span><br><span class="line">       .major = DEV_TTY,</span><br><span class="line">       .open = tty_open,</span><br><span class="line">       .read = tty_read,</span><br><span class="line">       .write = tty_write,</span><br><span class="line">       .control = tty_control,</span><br><span class="line">       .close = tty_close,</span><br><span class="line">   &#125;;</span><br><span class="line">   register_device(&amp;dev_tty_desc);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>设备文件与文件描述符的关联</strong></li>
</ol>
<p>当用户空间的程序打开一个TTY设备文件时，内核会为该设备文件分配一个文件描述符，并将该文件描述符与TTY设备驱动的操作函数（如 <code>open</code>、<code>read</code>、<code>write</code> 等）关联起来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 打开TTY设备文件</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">tty_open</span><span class="params">(<span class="type">device_t</span> *dev)</span> &#123;</span><br><span class="line">   <span class="comment">// 初始化TTY设备</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 读取TTY设备文件</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">tty_read</span><span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">   <span class="comment">// 从TTY设备读取数据</span></span><br><span class="line">   <span class="keyword">return</span> size;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 写入TTY设备文件</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">tty_write</span><span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">   <span class="comment">// 向TTY设备写入数据</span></span><br><span class="line">   <span class="keyword">return</span> size;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>标准输入输出与文件描述符的关联</strong></li>
</ol>
<p>在程序启动时，操作系统会为标准输入输出（<code>stdin</code>、<code>stdout</code>、<code>stderr</code>）分配文件描述符（通常是 <code>0</code>、<code>1</code> 和 <code>2</code>），并将这些文件描述符与TTY设备文件关联起来。这使得程序可以通过标准输入输出进行与终端设备的交互。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">void</span> <span class="title function_">setup_standard_io</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 打开标准输入</span></span><br><span class="line">   <span class="type">file_t</span> *stdin_file = sys_open(<span class="string">&quot;/dev/tty&quot;</span>, O_RDONLY);</span><br><span class="line">   curr_task-&gt;file_table[<span class="number">0</span>] = stdin_file;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 打开标准输出</span></span><br><span class="line">   <span class="type">file_t</span> *stdout_file = sys_open(<span class="string">&quot;/dev/tty&quot;</span>, O_WRONLY);</span><br><span class="line">   curr_task-&gt;file_table[<span class="number">1</span>] = stdout_file;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 打开标准错误输出</span></span><br><span class="line">   <span class="type">file_t</span> *stderr_file = sys_open(<span class="string">&quot;/dev/tty&quot;</span>, O_WRONLY);</span><br><span class="line">   curr_task-&gt;file_table[<span class="number">2</span>] = stderr_file;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>关联关系图</strong></li>
</ol>
<p>以下是TTY设备与标准输入输出文件关联关系的思维导图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;lua复制代码+----------------------+           +----------------------+</span><br><span class="line">&gt;| 用户空间程序        |           | 操作系统             |</span><br><span class="line">&gt;|                      |           |                      |</span><br><span class="line">&gt;| +------------------+ |           | +------------------+ |</span><br><span class="line">&gt;| | 标准输入（stdin）| |           | | TTY设备文件      | |</span><br><span class="line">&gt;| +------------------+ |           | +------------------+ |</span><br><span class="line">&gt;| | 标准输出（stdout）| |           | | 设备驱动        | |</span><br><span class="line">&gt;| +------------------+ |           | +------------------+ |</span><br><span class="line">&gt;| | 标准错误（stderr）| |           | | 设备文件系统    | |</span><br><span class="line">&gt;| +------------------+ |           | +------------------+ |</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">        | 关联                                  | 关联</span><br><span class="line">        v                                       v</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">&gt;| 文件描述符表        |           | 设备描述符表         |</span><br><span class="line">&gt;| (file_table)        |           | (device_table)       |</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">        | 关联                                  | 关联</span><br><span class="line">        v                                       v</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">&gt;| 设备文件            |           | TTY设备驱动         |</span><br><span class="line">&gt;| (/dev/tty)          |           | (tty_open, tty_read, |</span><br><span class="line">&gt;|                     |           |  tty_write, ...)     |</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">        | 关联</span><br><span class="line">        v</span><br><span class="line">&gt;+----------------------+</span><br><span class="line">&gt;| 硬件设备            |</span><br><span class="line">&gt;| (终端硬件)          |</span><br><span class="line">&gt;+----------------------+</span><br></pre></td></tr></table></figure>

<p>解释每一步的关联</p>
<ol>
<li><strong>用户空间程序</strong>通过标准输入（<code>stdin</code>）、标准输出（<code>stdout</code>）和标准错误（<code>stderr</code>）进行I&#x2F;O操作，这些操作实际上是对文件描述符表（<code>file_table</code>）中的文件描述符进行操作。</li>
<li><strong>文件描述符表</strong>中的文件描述符（如 <code>0</code>, <code>1</code>, <code>2</code>）对应TTY设备文件（如 <code>/dev/tty</code>）。</li>
<li><strong>设备文件</strong>（如 <code>/dev/tty</code>）通过设备描述符表（<code>device_table</code>）与TTY设备驱动（如 <code>tty_open</code>、<code>tty_read</code>、<code>tty_write</code> 等）关联。</li>
<li><strong>TTY设备驱动</strong>负责与实际的硬件设备（终端硬件）进行交互。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 复制文件描述符</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param file 当前文件的fd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_dup</span> <span class="params">(<span class="type">int</span> file)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((file &lt; <span class="number">0</span>) || (file &gt;= TASK_OFILE_NR)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;file(%d) is not valid.&quot;</span>, file);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">file_t</span> *p_file = task_file(file);</span><br><span class="line">    <span class="keyword">if</span> (!p_file) &#123;</span><br><span class="line">		log_printf(<span class="string">&quot;file not opened&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在打开文件表中分配新的表项，同样指向该任务</span></span><br><span class="line">    <span class="type">int</span> fd = task_alloc_fd(p_file);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        p_file-&gt;ref++;</span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log_printf(<span class="string">&quot;No task file avaliable&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-7-允许切换tty窗口"><a href="#16-7-允许切换tty窗口" class="headerlink" title="16.7 允许切换tty窗口"></a>16.7 允许切换tty窗口</h2><h3 id="1、通过快捷键方式切换"><a href="#1、通过快捷键方式切换" class="headerlink" title="1、通过快捷键方式切换"></a>1、通过快捷键方式切换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kbd.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_fx_key</span> <span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = key - KEY_F1;</span><br><span class="line">    <span class="keyword">if</span> (kbd_state.lctrl_press || kbd_state.rctrl_press) &#123;</span><br><span class="line">        tty_select(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理单字符的标准键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_normal_key</span> <span class="params">(<span class="type">uint8_t</span> raw_code)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 功能键：写入键盘缓冲区，由应用自行决定如何处理</span></span><br><span class="line">    <span class="keyword">case</span> KEY_F1:</span><br><span class="line">    <span class="keyword">case</span> KEY_F2:</span><br><span class="line">    <span class="keyword">case</span> KEY_F3:</span><br><span class="line">    <span class="keyword">case</span> KEY_F4:</span><br><span class="line">    <span class="keyword">case</span> KEY_F5:</span><br><span class="line">    <span class="keyword">case</span> KEY_F6:</span><br><span class="line">    <span class="keyword">case</span> KEY_F7:</span><br><span class="line">    <span class="keyword">case</span> KEY_F8:</span><br><span class="line">        do_fx_key(key);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tty.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 选择tty</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_select</span> <span class="params">(<span class="type">int</span> tty)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (tty != curr_tty) &#123;</span><br><span class="line">		console_select(tty);</span><br><span class="line">		curr_tty = tty;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_select</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> * console = console_buf + idx;</span><br><span class="line">    <span class="keyword">if</span> (console-&gt;disp_base == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 可能没有初始化，先初始化一下</span></span><br><span class="line">        console_init(idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint16_t</span> pos = idx * console-&gt;display_cols * console-&gt;display_rows;</span><br><span class="line"></span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0xC</span>);		<span class="comment">// 写高地址</span></span><br><span class="line">	outb(<span class="number">0x3D5</span>, (<span class="type">uint8_t</span>) ((pos &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0xD</span>);		<span class="comment">// 写低地址</span></span><br><span class="line">	outb(<span class="number">0x3D5</span>, (<span class="type">uint8_t</span>) (pos &amp; <span class="number">0xFF</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新光标到当前屏幕</span></span><br><span class="line">    update_cursor_pos(console);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试代码</span></span><br><span class="line">    <span class="type">char</span> num = idx + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    show_char(console, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、在first-task中初始化8个窗口"><a href="#2、在first-task中初始化8个窗口" class="headerlink" title="2、在first_task中初始化8个窗口"></a>2、在first_task中初始化8个窗口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/init/first_task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">    <span class="title function_">for</span> <span class="params">(<span class="type">int</span> i = <span class="number">0</span>; i &lt; TTY_NR; i++)</span> &#123;</span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            print_msg(<span class="string">&quot;create shell proc failed&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            <span class="type">char</span> tty_num[<span class="number">5</span>] = <span class="string">&quot;tty:?&quot;</span>;</span><br><span class="line">            tty_num[<span class="number">4</span>] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">char</span> * argv[] = &#123;tty_num, (<span class="type">char</span> *)<span class="number">0</span>&#125;;</span><br><span class="line">            execve(<span class="string">&quot;/shell.elf&quot;</span>, argv, (<span class="type">char</span> **)<span class="number">0</span>);</span><br><span class="line">            print_msg(<span class="string">&quot;create shell proc failed&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                msleep(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        msleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// open(&quot;tty:0&quot;, 0);            // fd = 0，标准输入</span></span><br><span class="line">    open(argv[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">    dup(<span class="number">0</span>);                   <span class="comment">// fd = 1，标准输出</span></span><br><span class="line">    dup(<span class="number">0</span>);                   <span class="comment">// fd = 2，标准错误输出</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from shell!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;os version: %s\n&quot;</span>, OS_VERSION);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        gets(cmd_buf);</span><br><span class="line">        <span class="built_in">puts</span>(cmd_buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf(&quot;shell pid= %d\n&quot;, getpid());</span></span><br><span class="line">        <span class="comment">// msleep(1000);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，还要在<code>conmsole.c</code>中进行相应的调整。</p>
<h1 id="十七、实现一个命令行解释器"><a href="#十七、实现一个命令行解释器" class="headerlink" title="十七、实现一个命令行解释器"></a>十七、实现一个命令行解释器</h1><h2 id="17-1-初始化命令行解释器"><a href="#17-1-初始化命令行解释器" class="headerlink" title="17.1 初始化命令行解释器"></a>17.1 初始化命令行解释器</h2><p><code>shell</code>俗称壳，即<strong>命令行解释器</strong>，它允许用户交互式的输入命令并解释执行，并且可以调用出相应的应用程序运行，从而让用户能够使用内核的 功能去操作计算机。<code>shell</code>也是一门程序语言，其定义了相应的语法规则，允许用户编写脚本。脚本编写后，由<code>shell</code>解释执行，不需要编译生成可执行程序。除非图形化的<code>shell</code>之外，还有图形化的<code>shell</code>，允许用户用鼠标等进行控制。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242158605.png" alt="image-20240524215849436"></p>
<p>本项目的目标是提供一个命令行的<code>shell</code>，支持执行内置的命令以及加载磁盘上的程序运行。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242232682.png" alt="image-20240524223243130"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// command line interface</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLI_INPUT_SIZE     1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置命令结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">cli_cmd_t</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;       <span class="comment">// 命令名称</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *usage;      <span class="comment">// 命令功能</span></span><br><span class="line">    <span class="type">int</span> (*do_func)(<span class="type">int</span> argc, <span class="type">char</span> **argv);</span><br><span class="line">&#125;<span class="type">cli_cmd_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行接口结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">cli_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> curr_input[CLI_INPUT_SIZE];  <span class="comment">// 输入缓冲区</span></span><br><span class="line">    <span class="type">const</span> <span class="type">cli_cmd_t</span> *cmd_start;</span><br><span class="line">    <span class="type">const</span> <span class="type">cli_cmd_t</span> *cmd_end;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *promot;               <span class="comment">// 每次按下回车时显示的提示信息</span></span><br><span class="line">&#125;<span class="type">cli_t</span>;</span><br></pre></td></tr></table></figure>



<h3 id="1、show-promot"><a href="#1、show-promot" class="headerlink" title="1、show_promot()"></a>1、show_promot()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 显示命令行提示符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_promot</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, cli.promot);  <span class="comment">// 注意此处不能使用puts函数</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、为什么不能用 <code>puts</code>？</strong></p>
<ul>
<li><p><code>puts</code> 和 <code>printf</code> 的区别：</p>
<blockquote>
<ul>
<li><strong><code>puts</code>：</strong><ul>
<li><code>puts</code> 函数用于输出字符串，并在末尾自动添加一个换行符 <code>\n</code>。</li>
<li>它的原型是：<code>int puts(const char *str);</code></li>
<li>当你调用 <code>puts(&quot;Hello&quot;);</code> 时，实际输出的是 <code>&quot;Hello\n&quot;</code>。</li>
<li><code>puts</code> 自动刷新输出缓冲区。</li>
</ul>
</li>
<li><strong><code>printf</code>：</strong><ul>
<li><code>printf</code> 函数用于格式化输出，可以输出字符串、整数、浮点数等多种类型的数据。</li>
<li>它的原型是：<code>int printf(const char *format, ...);</code></li>
<li><code>printf(&quot;Hello&quot;);</code> 仅输出 <code>&quot;Hello&quot;</code>，不会自动添加换行符。</li>
<li><code>printf</code> 默认情况下不自动刷新输出缓冲区，除非遇到换行符或手动调用 <code>fflush</code>。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>在 <code>show_promot</code> 函数中不能使用 <code>puts</code> 的原因：</p>
<p><code>show_promot</code> 函数的目的是显示命令行提示符。通常情况下，命令行提示符不需要在末尾自动添加换行符，因为这样会导致用户输入内容出现在下一行，而不是提示符之后。例如：</p>
<ul>
<li><p>使用 <code>printf</code> 和 <code>fflush</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, cli.promot);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>

<p>输出是：<code>cli.promot</code> 直接跟随用户输入。</p>
</li>
<li><p>使用 <code>puts</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(cli.promot);</span><br></pre></td></tr></table></figure>

<p>输出是：<code>cli.promot\n</code>，用户输入会在下一行开始，这不是希望的行为。</p>
</li>
</ul>
</li>
</ul>
<p><strong>2、为什么要加上 <code>fflush</code>？</strong></p>
<ul>
<li><p>缓冲区和 <code>fflush</code>：</p>
<ul>
<li><p><strong>缓冲区</strong>：</p>
<ul>
<li>在标准 I&#x2F;O 库中，输出通常是缓冲的。这意味着输出操作先将数据存储在缓冲区中，只有在缓冲区满、遇到换行符、程序正常结束或手动刷新缓冲区时，数据才会实际输出到终端或文件。</li>
</ul>
</li>
<li><p>**<code>fflush</code>**：</p>
<ul>
<li><code>fflush</code> 函数用于强制刷新输出缓冲区，将缓冲区中的数据立即输出到目标设备。<ul>
<li>它的原型是：<code>int fflush(FILE *stream);</code></li>
<li>当你调用 <code>fflush(stdout);</code> 时，它会刷新标准输出缓冲区，确保所有缓冲的数据立即输出。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在 <code>show_promot</code> 函数中使用 <code>fflush</code> 的原因：</p>
<p>当我们使用 <code>printf</code> 输出命令行提示符时，缓冲区中的数据可能不会立即输出到终端。这意味着用户可能不会立即看到提示符，从而无法开始输入。为了确保提示符立即显示出来，我们需要手动刷新标准输出缓冲区。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, cli.promot);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>

<p>这样可以确保提示符在 <code>printf</code> 调用后立即显示，用户可以看到提示符并开始输入。</p>
</li>
</ul>
<p><strong>3、总结</strong></p>
<p>在 <code>show_promot</code> 函数中：</p>
<ol>
<li>不能使用 <code>puts</code> 是因为 <code>puts</code> 会在字符串末尾自动添加换行符，这不符合命令行提示符的预期行为。</li>
<li>使用 <code>printf</code> 后调用 <code>fflush(stdout)</code> 是为了确保提示符立即显示在终端上，避免缓冲区未被及时刷新导致的显示延迟。</li>
</ol>
<h3 id="2、在shell中按下回退键，回退键也会被写入"><a href="#2、在shell中按下回退键，回退键也会被写入" class="headerlink" title="2、在shell中按下回退键，回退键也会被写入"></a>2、在shell中按下回退键，回退键也会被写入</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405251645958.png" alt="image-20240525164517703"></p>
<p>解决方法：在<code>tty.c/tty_read()</code>中加入相应的处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *pbuf = buf;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;  <span class="comment">// 当前读取长度</span></span><br><span class="line">	<span class="comment">// 遍历buf读数据</span></span><br><span class="line">	<span class="keyword">while</span> (len &lt; size) &#123;</span><br><span class="line">		sem_wait(&amp;tty-&gt;isem);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> ch;</span><br><span class="line">		<span class="comment">// 从缓冲区取数据</span></span><br><span class="line">		tty_fifo_get(&amp;tty-&gt;ififo, &amp;ch);</span><br><span class="line">		<span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">        <span class="comment">// ================ 新增 ================ //</span></span><br><span class="line">		<span class="keyword">case</span> ASCII_DEL:</span><br><span class="line">			<span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			len--;</span><br><span class="line">			pbuf--;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// ================ 新增 ================ //</span></span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-2-进程主动退出exit"><a href="#17-2-进程主动退出exit" class="headerlink" title="17.2 进程主动退出exit()"></a>17.2 进程主动退出exit()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 退出进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数有两个关键步骤：</p>
<h3 id="1、步骤一"><a href="#1、步骤一" class="headerlink" title="1、步骤一"></a>1、<strong>步骤一</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找当前进程（curr_task）所有的子进程，并将其转交给init进程（first_task）</span></span><br><span class="line"><span class="type">int</span> move_child = <span class="number">0</span>;  <span class="comment">// 标志是否需要唤醒first_task</span></span><br><span class="line">mutex_lock(&amp;task_table_mutex);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TASK_OFILE_NR; i++) &#123;</span><br><span class="line">    <span class="type">task_t</span> *task = task_table + i;</span><br><span class="line">    <span class="comment">// 判断当前进程（curr_task）是否有子进程</span></span><br><span class="line">    <span class="keyword">if</span> (task-&gt;parent == curr_task) &#123;</span><br><span class="line">        <span class="comment">// 若有，则转给first_task，由first_task进行处理</span></span><br><span class="line">        task-&gt;parent = &amp;task_manager.first_task;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果子进程中有僵尸进程，将其唤醒并回收资源</span></span><br><span class="line">        <span class="comment">// 但注意并不由当前进程（curr_task）自己回收，因为自己将要退出</span></span><br><span class="line">        <span class="keyword">if</span> (task-&gt;state == TASK_ZOMBIE) &#123;</span><br><span class="line">            move_child = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;task_table_mutex);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>寻找子进程并转交给 <code>first_task</code></strong>:<ul>
<li><strong>目的</strong>: 确保当前进程（<code>curr_task</code>）退出后，其所有的子进程不会成为孤儿进程。孤儿进程需要被重新指定为 <code>first_task</code>（通常是系统的守护进程）的子进程。</li>
<li>操作<ul>
<li>遍历 <code>task_table</code> 中的所有任务。</li>
<li>如果某任务的 <code>parent</code> 是 <code>curr_task</code>，则将该任务的 <code>parent</code> 改为 <code>first_task</code>。</li>
<li>如果该任务是僵尸进程（<code>TASK_ZOMBIE</code>），设置 <code>move_child</code> 标志为1，表示需要唤醒 <code>first_task</code> 来处理这些僵尸进程。</li>
</ul>
</li>
</ul>
</li>
<li><strong>加锁和解锁</strong>:<ul>
<li><strong>目的</strong>: 保证对 <code>task_table</code> 的操作是线程安全的。</li>
<li><strong>操作</strong>: 在遍历和修改 <code>task_table</code> 时，加锁 (<code>mutex_lock</code>) 和解锁 (<code>mutex_unlock</code>) 确保其他线程不能同时修改任务表。</li>
</ul>
</li>
</ol>
<h3 id="2、步骤二"><a href="#2、步骤二" class="headerlink" title="2、步骤二"></a>2、步骤二</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒first_task</span></span><br><span class="line"><span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"><span class="type">task_t</span> * parent = curr_task-&gt;parent;</span><br><span class="line"><span class="comment">// 若需要唤醒first_task，且当前进程（curr_task）的父进程不是first_task，唤醒first_task</span></span><br><span class="line"><span class="keyword">if</span> (move_child &amp;&amp; (parent != &amp;task_manager.first_task)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task_manager.first_task.state == TASK_WAITING) &#123;</span><br><span class="line">        task_set_ready(&amp;task_manager.first_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有父进程在wait，则唤醒父任务进行回收</span></span><br><span class="line"><span class="comment">// 如果父进程没有等待，则一直处理僵死状态？</span></span><br><span class="line"><span class="keyword">if</span> (parent-&gt;state == TASK_WAITING) &#123;</span><br><span class="line">    task_set_ready(curr_task-&gt;parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存返回值，当前进程（curr_task）进入僵尸状态</span></span><br><span class="line">curr_task-&gt;status = status;</span><br><span class="line">curr_task-&gt;state = TASK_ZOMBIE;</span><br><span class="line">task_set_block(curr_task);</span><br><span class="line">task_dispatch();</span><br><span class="line">irq_leave_protection(state);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>唤醒 <code>first_task</code></strong>:<ul>
<li><strong>目的</strong>: 如果有子进程转交给了 <code>first_task</code> 并且这些子进程中有僵尸进程，确保 <code>first_task</code> 可以及时处理这些僵尸进程。</li>
<li>操作<ul>
<li>如果 <code>move_child</code> 标志为<code>1</code>且 <code>curr_task</code> 的父进程不是 <code>first_task</code>，并且 <code>first_task</code> 当前处于等待状态（<code>TASK_WAITING</code>），则将 <code>first_task</code> 设置为就绪状态（<code>task_set_ready</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>唤醒父任务</strong>:<ul>
<li><strong>目的</strong>: 如果 <code>curr_task</code> 的父任务在等待（例如通过 <code>wait</code> 系统调用等待子进程结束），需要唤醒父任务来处理当前进程的退出。</li>
<li>操作<ul>
<li>如果 <code>curr_task</code> 的父任务处于等待状态（<code>TASK_WAITING</code>），将其设置为就绪状态（<code>task_set_ready</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>处理当前进程的退出</strong>:<ul>
<li><strong>目的</strong>: 将当前进程标记为僵尸状态，并阻塞当前任务以等待其父进程回收。</li>
<li>操作<ul>
<li>设置 <code>curr_task</code> 的返回状态（<code>status</code>）。</li>
<li>将 <code>curr_task</code> 的状态设置为僵尸状态（<code>TASK_ZOMBIE</code>）。</li>
<li>阻塞当前任务（<code>task_set_block</code>）。</li>
<li>调度其他任务运行（<code>task_dispatch</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>进入和离开中断保护</strong>:<ul>
<li><strong>目的</strong>: 确保在执行关键部分代码时不会被中断打断。</li>
<li><strong>操作</strong>: 进入中断保护（<code>irq_enter_protection</code>）和离开中断保护（<code>irq_leave_protection</code>）。</li>
</ul>
</li>
</ol>
<h3 id="3、两个步骤对比"><a href="#3、两个步骤对比" class="headerlink" title="3、两个步骤对比"></a>3、两个步骤对比</h3><ul>
<li><strong>第一步</strong>: 处理当前进程的子进程，将其重新分配给 <code>first_task</code>，并标记是否有僵尸进程需要处理。</li>
<li><strong>第二步</strong>: 唤醒 <code>first_task</code> 以处理重新分配的子进程和僵尸进程，同时处理当前进程的父任务和将当前进程设置为僵尸状态。</li>
</ul>
<h2 id="17-3-进程等待wait"><a href="#17-3-进程等待wait" class="headerlink" title="17.3 进程等待wait()"></a>17.3 进程等待wait()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 等待子进程退出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1、遍历任务表，寻找僵尸状态的子进程"><a href="#1、遍历任务表，寻找僵尸状态的子进程" class="headerlink" title="1、遍历任务表，寻找僵尸状态的子进程"></a>1、遍历任务表，寻找僵尸状态的子进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;task_table_mutex);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TASK_NR; i++) &#123;</span><br><span class="line">    <span class="type">task_t</span> * task = task_table + i;</span><br><span class="line">    <span class="keyword">if</span> (task-&gt;parent != curr_task) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task-&gt;state == TASK_ZOMBIE) &#123;</span><br><span class="line">        <span class="type">int</span> pid = task-&gt;pid;</span><br><span class="line"></span><br><span class="line">        *status = task-&gt;status;</span><br><span class="line"></span><br><span class="line">        memory_destroy_uvm(task-&gt;tss.cr3);</span><br><span class="line">        memory_free_page(task-&gt;tss.esp0 - MEM_PAGE_SIZE);</span><br><span class="line">        kernel_memset(task, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">task_t</span>));</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;task_table_mutex);</span><br><span class="line">        <span class="keyword">return</span> pid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;task_table_mutex);</span><br></pre></td></tr></table></figure>

<ul>
<li>加锁和解锁<ul>
<li>通过 <code>mutex_lock</code> 和 <code>mutex_unlock</code> 来保护对 <code>task_table</code> 的访问，防止并发修改。</li>
</ul>
</li>
<li>检查子进程<ul>
<li>遍历 <code>task_table</code>，检查每个任务的父进程是否是当前进程（<code>curr_task</code>）。</li>
<li>如果找到一个子进程处于 <code>TASK_ZOMBIE</code> 状态，则准备回收其资源。</li>
</ul>
</li>
</ul>
<h3 id="2、回收僵尸进程"><a href="#2、回收僵尸进程" class="headerlink" title="2、回收僵尸进程"></a>2、回收僵尸进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = task-&gt;pid;</span><br><span class="line">*status = task-&gt;status;</span><br><span class="line"></span><br><span class="line">memory_destroy_uvm(task-&gt;tss.cr3);</span><br><span class="line">memory_free_page(task-&gt;tss.esp0 - MEM_PAGE_SIZE);</span><br><span class="line">kernel_memset(task, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">task_t</span>));</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;task_table_mutex);</span><br><span class="line"><span class="keyword">return</span> pid;</span><br></pre></td></tr></table></figure>

<ul>
<li>保存退出状态<ul>
<li>将子进程的退出状态保存到 <code>status</code> 指向的变量中。</li>
</ul>
</li>
<li>回收资源<ul>
<li>销毁子进程的用户虚拟内存（<code>memory_destroy_uvm</code>）。</li>
<li>释放子进程的内核栈（<code>memory_free_page</code>）。</li>
<li>清空任务结构（<code>kernel_memset</code>）。</li>
</ul>
</li>
<li>解锁并返回<ul>
<li>解锁任务表互斥量，返回子进程的 <code>pid</code>。</li>
</ul>
</li>
</ul>
<h3 id="3、等待子进程退出"><a href="#3、等待子进程退出" class="headerlink" title="3、等待子进程退出"></a>3、等待子进程退出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line">task_set_block(curr_task);</span><br><span class="line">curr_task-&gt;state = TASK_WAITING;</span><br><span class="line">task_dispatch();</span><br><span class="line">irq_leave_protection(state);</span><br></pre></td></tr></table></figure>

<ul>
<li>进入中断保护<ul>
<li>进入中断保护状态，防止在关键操作期间被中断打断。</li>
</ul>
</li>
<li>设置当前进程为等待状态<ul>
<li>将当前进程的状态设置为 <code>TASK_WAITING</code>，并阻塞当前进程（<code>task_set_block</code>）。</li>
</ul>
</li>
<li>任务调度<ul>
<li>通过 <code>task_dispatch</code> 切换到其他任务运行。</li>
</ul>
</li>
<li>离开中断保护<ul>
<li>离开中断保护状态。</li>
</ul>
</li>
</ul>
<h3 id="4、关键步骤总结"><a href="#4、关键步骤总结" class="headerlink" title="4、关键步骤总结"></a>4、关键步骤总结</h3><ol>
<li><strong>遍历任务表，寻找僵尸状态的子进程</strong>。</li>
<li><strong>回收僵尸进程</strong><ul>
<li>保存退出状态。</li>
<li>销毁子进程资源。</li>
<li>清空任务结构。</li>
</ul>
</li>
<li><strong>等待子进程退出</strong><ul>
<li>进入中断保护。</li>
<li>设置当前进程为等待状态。</li>
<li>任务调度。</li>
<li>离开中断保护。</li>
</ul>
</li>
</ol>
<h2 id="17-4-让子进程继承父进程已打开的文件"><a href="#17-4-让子进程继承父进程已打开的文件" class="headerlink" title="17.4 让子进程继承父进程已打开的文件"></a>17.4 让子进程继承父进程已打开的文件</h2><h3 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252002902.png" alt="image-20240525200208616"></p>
<p>出现<code>file not opened</code>是因为在<code>fork()</code>操作的<code>task_init()</code>中，对于<code>file_table</code>进行了清零操作，因此就使得子进程并未继承父进程已打开的文件，无法调用标准输入输出文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel_memset(&amp;task-&gt;file_table, <span class="number">0</span>, <span class="keyword">sizeof</span>(task-&gt;file_table));</span><br></pre></td></tr></table></figure>

<h3 id="2、解决方法"><a href="#2、解决方法" class="headerlink" title="2、解决方法"></a>2、解决方法</h3><p>在<code>sys_fork()</code>中加入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝打开的文件</span></span><br><span class="line">copy_opened_files(child_task);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从当前进程中拷贝已经打开的文件列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">copy_opened_files</span><span class="params">(<span class="type">task_t</span> * child_task)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> * parent = task_current();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TASK_OFILE_NR; i++) &#123;</span><br><span class="line">        <span class="type">file_t</span> * file = parent-&gt;file_table[i];</span><br><span class="line">        <span class="keyword">if</span> (file) &#123;</span><br><span class="line">            file_inc_ref(file);</span><br><span class="line">            child_task-&gt;file_table[i] = parent-&gt;file_table[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252000979.png" alt="image-20240525200053427"></p>
<h1 id="十八、使用文件系统管理硬件设备"><a href="#十八、使用文件系统管理硬件设备" class="headerlink" title="十八、使用文件系统管理硬件设备"></a>十八、使用文件系统管理硬件设备</h1><h2 id="18-1-描述一个文件系统"><a href="#18-1-描述一个文件系统" class="headerlink" title="18.1 描述一个文件系统"></a>18.1 描述一个文件系统</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252046871.png" alt="image-20240525204658527" style="zoom:50%;" />

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252013293.png" alt="image-20240525201314917"></p>
<p> <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252018279.png" alt="image-20240525201853857"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252020223.png" alt="image-20240525202007781"></p>
<h3 id="1、问题1：如何通过路径区分不同的设备"><a href="#1、问题1：如何通过路径区分不同的设备" class="headerlink" title="1、问题1：如何通过路径区分不同的设备"></a>1、问题1：如何通过路径区分不同的设备</h3><p>针对问题一：借鉴设备管理层的方法，针对不同类型的设备，添加相应的文件系统层接口实现。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405261156858.png" alt="image-20240526115647584" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252025262.png" alt="image-20240525202527701" style="zoom:50%;" />

<h2 id="18-2-挂载设备文件系统"><a href="#18-2-挂载设备文件系统" class="headerlink" title="18.2 挂载设备文件系统"></a>18.2 挂载设备文件系统</h2><h3 id="1、挂载原理"><a href="#1、挂载原理" class="headerlink" title="1、挂载原理"></a>1、挂载原理</h3><p>对于不同类型的文件系统，使用统一的链接进行挂载和管理。</p>
<p>在<code>mount_list</code>中存放了所支持的所有类型的文件系统，存放每个文件系统的名称（如<code>/dev</code>）和对应的操作（以函数指针的方式保存）。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252050216.png" alt="image-20240525205036777"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fs_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fs_op_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*mount)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">int</span> major, <span class="type">int</span> minor);   <span class="comment">// mount 挂载</span></span><br><span class="line">    <span class="type">void</span> (*unmount)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs);                      <span class="comment">// unmount 取消挂载</span></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">file_t</span> *file);  <span class="comment">// fs的相关信息会放入file中</span></span><br><span class="line">    <span class="type">int</span> (*read)(<span class="type">char</span> *buf, <span class="type">int</span> size, <span class="type">file_t</span> *file);</span><br><span class="line">    <span class="type">int</span> (*write)(<span class="type">char</span> *buf, <span class="type">int</span> size, <span class="type">file_t</span> *file);</span><br><span class="line">    <span class="type">int</span> (*seek)(<span class="type">file_t</span> *file, <span class="type">uint32_t</span> offset, <span class="type">int</span> dir);</span><br><span class="line">    <span class="type">int</span> (*stat)(<span class="type">file_t</span> *file, <span class="keyword">struct</span> stat *st);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="type">file_t</span> *file);</span><br><span class="line">&#125;<span class="type">fs_op_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载文件系统类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">fs_type_t</span> &#123;</span></span><br><span class="line">    FS_DEVFS,</span><br><span class="line">&#125;<span class="type">fs_type_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象文件结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fs_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> mount_point[FS_MOUNTP_SIZE];   <span class="comment">// 挂载文件系统名称</span></span><br><span class="line">    <span class="type">fs_type_t</span> type;     <span class="comment">// 挂载文件系统类型</span></span><br><span class="line">    <span class="type">fs_op_t</span> *op;        <span class="comment">// 指明该结构对应的文件系统的相关操作</span></span><br><span class="line">    <span class="type">void</span> *data;         <span class="comment">// 底层调用时使用，上层调用不使用</span></span><br><span class="line">    <span class="type">int</span> dev_id;         <span class="comment">// 设备id</span></span><br><span class="line">    <span class="type">list_node_t</span> node;   <span class="comment">// 链表节点</span></span><br><span class="line">    <span class="type">mutex_t</span> *mutex;</span><br><span class="line">&#125;<span class="type">fs_t</span>;</span><br></pre></td></tr></table></figure>



<p>在函数调用方面，从高层到底层依次如下：</p>
<p><code>devfs_func =&gt; dev_func =&gt; tty_func</code></p>
<h3 id="2、具体挂载流程"><a href="#2、具体挂载流程" class="headerlink" title="2、具体挂载流程"></a>2、具体挂载流程</h3><p>在文件系统的挂载过程中，<code>mount</code> 函数调用另一个同名的 <code>mount</code> 函数可能会引起混淆。事实上，这里有两个不同的 <code>mount</code> 函数，分别属于不同的上下文。一个是高层次的文件系统管理函数，另一个是具体文件系统的操作函数。</p>
<p><strong>（1）高层次的 <code>mount</code> 函数</strong></p>
<p>负责管理挂载的总体流程，包括检查是否已经挂载、分配资源、调用具体文件系统的挂载操作等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">fs_t</span> *<span class="title function_">mount</span> <span class="params">(<span class="type">fs_type_t</span> type, <span class="type">char</span> *mount_point, <span class="type">int</span> dev_major, <span class="type">int</span> dev_minor)</span> &#123;</span><br><span class="line">    <span class="type">fs_t</span> *fs = (<span class="type">fs_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    log_printf(<span class="string">&quot;mount file system, name: &amp;s, dev: %x&quot;</span>, mount_point, dev_major);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前文件系统是否已被挂载</span></span><br><span class="line">    <span class="type">list_node_t</span> *curr = list_first(&amp;mounted_list);</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="type">fs_t</span> *fs = list_node_parent(curr, <span class="type">fs_t</span>, node);</span><br><span class="line">        <span class="keyword">if</span> (kernel_strncmp(fs-&gt;mount_point, mount_point, FS_MOUNTP_SIZE) == <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;fs is already mounted&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> mount_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr = list_node_next(curr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到一个free_node对应的文件系统fs</span></span><br><span class="line">    <span class="type">list_node_t</span> *free_node = list_remove_first(&amp;free_list);</span><br><span class="line">    <span class="keyword">if</span> (!free_node) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;no free, mounted failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> mount_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    fs = list_node_parent(free_node, <span class="type">fs_t</span>, node);</span><br><span class="line">    <span class="type">fs_op_t</span> *op = get_fs_op(type, dev_major);</span><br><span class="line">    <span class="keyword">if</span> (!op) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;unsupported fs type: %d&quot;</span>, type);</span><br><span class="line">        <span class="keyword">goto</span> mount_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件系统fs通用初始化</span></span><br><span class="line">    kernel_memset(fs, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">fs_t</span>));</span><br><span class="line">    kernel_strncpy(fs-&gt;mount_point, mount_point, FS_MOUNTP_SIZE);</span><br><span class="line">    fs-&gt;op = op;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂载文件系统</span></span><br><span class="line">    <span class="keyword">if</span> (op-&gt;mount(fs, dev_major, dev_minor) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;mount fs %s failed&quot;</span>, mount_point);</span><br><span class="line">        <span class="keyword">goto</span> mount_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    list_insert_last(&amp;mounted_list, &amp;fs-&gt;node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">mount_failed:</span><br><span class="line">    <span class="keyword">if</span> (fs) &#123;</span><br><span class="line">        <span class="comment">// 回收fs</span></span><br><span class="line">        list_insert_first(&amp;free_list, &amp;fs-&gt;node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">fs_t</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）具体文件系统的 <code>mount</code> 函数</strong></p>
<p>这个 <code>mount</code> 函数是每个具体文件系统实现的一个函数，它被注册到文件系统操作结构（<code>fs_op_t</code>）中。在高层次的 <code>mount</code> 函数中调用 <code>op-&gt;mount</code> 时，实际上是调用具体文件系统的挂载实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fs_op_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*mount)(<span class="type">fs_t</span> *fs, <span class="type">int</span> dev_major, <span class="type">int</span> dev_minor);</span><br><span class="line">    <span class="comment">// 其他操作函数...</span></span><br><span class="line">&#125; <span class="type">fs_op_t</span>;</span><br></pre></td></tr></table></figure>

<p>具体文件系统的挂载函数负责实际的挂载工作，比如初始化文件系统的内部结构、检查设备、加载超级块等。例如，假设我们有一个简单的 <code>devfs</code> 文件系统，它的挂载函数可能是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">devfs_mount</span><span class="params">(<span class="type">fs_t</span> *fs, <span class="type">int</span> dev_major, <span class="type">int</span> dev_minor)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化devfs文件系统的内部结构</span></span><br><span class="line">    <span class="comment">// 检查设备</span></span><br><span class="line">    <span class="comment">// 加载超级块等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0表示成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）挂载流程详解</strong></p>
<ol>
<li><strong>调用高层次的 <code>mount</code> 函数</strong>：在文件系统初始化过程中，调用 <code>mount</code> 函数，例如 <code>fs_t *fs = mount(FS_DEVFS, &quot;/dev&quot;, 0, 0);</code>。</li>
<li><strong>检查是否已经挂载</strong>：高层次的 <code>mount</code> 函数检查指定的挂载点是否已经挂载文件系统。</li>
<li><strong>分配文件系统结构</strong>：从空闲列表中获取一个 <code>fs_t</code> 结构，并初始化。</li>
<li><strong>获取文件系统操作结构</strong>：通过文件系统类型和主设备号找到对应的文件系统操作结构 <code>fs_op_t</code>。</li>
<li><strong>调用具体文件系统的挂载函数</strong>：通过 <code>op-&gt;mount</code> 调用具体文件系统的挂载函数，例如 <code>devfs_mount</code>。</li>
<li><strong>将挂载的文件系统添加到挂载列表</strong>：如果挂载成功，将文件系统结构 <code>fs_t</code> 添加到挂载列表中。</li>
</ol>
<p><strong>（4）思维导图</strong></p>
<p>以下是这个流程的思维导图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">yaml复制代码  高层次的 mount 函数</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  检查是否已经挂载</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  分配文件系统结构</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  获取文件系统操作结构 (fs_op_t)</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  调用具体文件系统的 mount 函数 (op-&gt;mount)</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  如果挂载成功，添加到挂载列表</span><br></pre></td></tr></table></figure>

<p>通过这个流程图，可以看到高层次的 <code>mount</code> 函数如何协调和管理整个挂载过程，而具体文件系统的 <code>mount</code> 函数则负责实际的挂载操作。</p>
<h2 id="18-3-打开dev-tty0设备"><a href="#18-3-打开dev-tty0设备" class="headerlink" title="18.3 打开dev&#x2F;tty0设备"></a>18.3 打开dev&#x2F;tty0设备</h2><p>设备文件系统并不对应于某个实际的硬件设备，而是抽象出来的用于管理所有硬件设备的一种文件系统。</p>
<p>修改<code>sys_open()</code>，使其变得比较通用，步骤如下：</p>
<ol>
<li><p>分配文件描述符链接</p>
</li>
<li><p>将分配的file结构和一个fd关联</p>
</li>
<li><p>根据传入的路径解析对应的fs结构</p>
<ul>
<li><p>检查名称是否以挂载点开头，如果没有，则认为name在根目录下</p>
</li>
<li><p>即只允许根目录下的遍历</p>
</li>
</ul>
</li>
<li><p>设置file内部相关字段</p>
</li>
<li><p>调用fs内部特定的open函数进行文件打开操作</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打开文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> flags, ...)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> err = fs-&gt;op-&gt;open(fs, name, file);  <span class="comment">// 就是这一句保证了其通用性</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>后续要增加其他设备时只需要修改此处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// devfs.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">devfs_open</span> <span class="params">(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">file_t</span> *file)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历所有支持的设备类型列表，根据path中的路径，找到相应的设备类型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(devfs_type_list) / <span class="keyword">sizeof</span>(devfs_type_list[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="type">devfs_type_t</span> *type = devfs_type_list + i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找相同的名称，然后从中提取后续部分，转换成字符串</span></span><br><span class="line">        <span class="type">int</span> type_name_len = kernel_strlen(type-&gt;name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 举例：path:tty0  |  type-&gt;name:tty</span></span><br><span class="line">        <span class="comment">// 如果存在挂载点路径，则跳过该路径，取下级子目录</span></span><br><span class="line">        <span class="keyword">if</span> (kernel_strncmp(path, type-&gt;name, type_name_len) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 转换得到设备子序号</span></span><br><span class="line">            <span class="type">int</span> minor;</span><br><span class="line">            <span class="keyword">if</span> ((kernel_strlen(path) &gt; type_name_len) &amp;&amp; (path_to_num(path + type_name_len, &amp;minor) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                log_printf(<span class="string">&quot;Get device num failed. %s&quot;</span>, path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开设备</span></span><br><span class="line">            <span class="type">int</span> dev_id = dev_open(type-&gt;dev_type, minor, (<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (dev_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                log_printf(<span class="string">&quot;Open device failed:%s&quot;</span>, path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 纪录所在的设备号</span></span><br><span class="line">            file-&gt;dev_id = dev_id;  <span class="comment">// file的设备号指向打开的特定的设备</span></span><br><span class="line">            file-&gt;fs = fs;          <span class="comment">// file所属的文件系统</span></span><br><span class="line">            file-&gt;pos = <span class="number">0</span>;</span><br><span class="line">            file-&gt;size = <span class="number">0</span>;</span><br><span class="line">            file-&gt;type = type-&gt;file_type;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十九、磁盘与fat16文件系统"><a href="#十九、磁盘与fat16文件系统" class="headerlink" title="十九、磁盘与fat16文件系统"></a>十九、磁盘与fat16文件系统</h1><h2 id="19-1-磁盘基本特性简介"><a href="#19-1-磁盘基本特性简介" class="headerlink" title="19.1 磁盘基本特性简介"></a>19.1 磁盘基本特性简介</h2><h3 id="1、MBR是什么"><a href="#1、MBR是什么" class="headerlink" title="1、MBR是什么"></a>1、MBR是什么</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262044874.png" alt="image-20240526204427543"></p>
<h3 id="2、磁盘的分区和扇区有什么区别"><a href="#2、磁盘的分区和扇区有什么区别" class="headerlink" title="2、磁盘的分区和扇区有什么区别"></a>2、磁盘的分区和扇区有什么区别</h3><p>磁盘分区和扇区是磁盘存储管理中的两个基本概念，但它们指的是不同层次的内容。</p>
<p><strong>1、扇区（<code>Sector</code>）</strong></p>
<p><strong>扇区</strong>是硬盘存储的最小单位。硬盘上的数据被划分为一个一个的扇区进行存储和读取。传统上，一个扇区的大小是512字节，但在一些现代硬盘中，这个大小可以是4096字节（4K扇区）。</p>
<ul>
<li><strong>扇区大小</strong>：通常为512字节或4096字节。</li>
<li><strong>位置</strong>：硬盘表面被划分成多个轨道，每个轨道再分成多个扇区。</li>
<li><strong>标识</strong>：每个扇区有一个唯一的地址，传统上使用柱面（Cylinder）、磁头（Head）、扇区（Sector，简称CHS）来标识，现在更多地使用逻辑块地址（LBA，Logical Block Addressing）来标识。</li>
</ul>
<p><strong>2、分区（<code>Partition</code>）</strong></p>
<p><strong>分区</strong>是硬盘上的一段连续的存储区域，可以被操作系统或用户作为一个独立的逻辑磁盘来使用。分区将一个物理硬盘划分为一个或多个独立的部分，每个部分可以包含文件系统、操作系统或其他数据。</p>
<ul>
<li><strong>分区类型</strong><ul>
<li><strong>主分区（Primary Partition）</strong>：硬盘上最多可以有四个主分区。</li>
<li><strong>扩展分区（Extended Partition）</strong>：扩展分区本身不能直接用于存储数据，但可以包含多个逻辑分区。</li>
<li><strong>逻辑分区（Logical Partition）</strong>：位于扩展分区内，可以用于存储数据。</li>
</ul>
</li>
<li><strong>用途</strong>：每个分区可以格式化为不同的文件系统，例如FAT32、NTFS、EXT4等，可以用于安装操作系统或存储数据。</li>
<li><strong>管理</strong>：分区信息存储在硬盘的分区表中，传统的MBR（Master Boot Record）分区表最多支持四个主分区或三个主分区加一个扩展分区，GPT（GUID Partition Table）分区表支持更多的分区和更大的磁盘。</li>
</ul>
<p><strong>3、区别和联系</strong></p>
<p>（1）区别</p>
<ol>
<li><strong>定义和作用</strong>：<ul>
<li><strong>扇区</strong>是硬盘的最小存储单元，具体指硬盘上物理的存储位置。</li>
<li><strong>分区</strong>是硬盘上的逻辑区域，包含多个扇区，可以被操作系统识别和使用。</li>
</ul>
</li>
<li><strong>大小和范围</strong>：<ul>
<li><strong>扇区</strong>的大小通常是固定的（512字节或4096字节）。</li>
<li><strong>分区</strong>的大小可以变化不定，取决于用户或系统的配置，可以包含许多扇区。</li>
</ul>
</li>
<li><strong>管理和用途</strong>：<ul>
<li><strong>扇区</strong>由硬盘控制器直接管理，硬件层面上的数据存储单位。</li>
<li><strong>分区</strong>由操作系统和分区表管理，逻辑层面上的数据管理单位。</li>
</ul>
</li>
</ol>
<p>（2）联系</p>
<ol>
<li><strong>分区包含扇区</strong>：<ul>
<li>一个分区由多个连续的扇区组成，分区的大小和位置通过扇区来确定。</li>
</ul>
</li>
<li><strong>共同作用</strong>：<ul>
<li>分区划分后，操作系统在分区上创建文件系统，文件系统管理扇区上的数据存储。</li>
<li>分区表记录每个分区的起始扇区和大小，操作系统通过分区表来访问和管理硬盘上的数据。</li>
</ul>
</li>
</ol>
<p><strong>4、示例</strong></p>
<p>假设有一个大小为<code>1TB</code>的硬盘，使用传统的<code>512</code>字节扇区：</p>
<ul>
<li><strong>扇区</strong>：整个硬盘包含约<code>2^40 / 2^9 = 2^31</code>个扇区，即大约<code>21亿</code>个扇区。</li>
<li>分区<ul>
<li>第一个分区：从第<code>2048</code>扇区开始，大小为<code>200GB</code>（约400,000,000个扇区）。</li>
<li>第二个分区：从第<code>400,002,048</code>扇区开始，大小为<code>300GB</code>（约600,000,000个扇区）。</li>
<li>其他部分可以划分为更多分区或留作未分区空间。</li>
</ul>
</li>
</ul>
<p>通过分区工具（如fdisk、parted等）可以查看和管理硬盘上的分区信息，每个分区都会有一个对应的起始和结束扇区。文件系统（如NTFS、EXT4等）则进一步管理分区内的数据，决定如何在扇区中存储和检索文件。</p>
<blockquote>
<p>总结来说，<strong>扇区是物理存储单位</strong>，<strong>分区是逻辑存储单位</strong>，分区包含多个扇区，分区表管理和记录分区信息。</p>
</blockquote>
<h3 id="3、初始化磁盘结构和分区结构"><a href="#3、初始化磁盘结构和分区结构" class="headerlink" title="3、初始化磁盘结构和分区结构"></a>3、初始化磁盘结构和分区结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分区结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">disk_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">partinfo_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[PART_NAME_SIZE];  <span class="comment">// 分区名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">disk_t</span> *<span class="title">disk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        FS_INVALID = <span class="number">0x00</span>,</span><br><span class="line">        FS_FAT16_0 = <span class="number">0x6</span>,</span><br><span class="line">        FS_FAT16_1 = <span class="number">0xE</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start_sector;   <span class="comment">// 起始扇区号</span></span><br><span class="line">    <span class="type">int</span> total_sector;   <span class="comment">// 占用的扇区数量</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">partinfo_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述特定磁盘结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">disk_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[DISK_NAME_SIZE];</span><br><span class="line">    <span class="type">int</span> sector_size;    <span class="comment">// 扇区大小</span></span><br><span class="line">    <span class="type">int</span> sector_count;   <span class="comment">// 扇区个数</span></span><br><span class="line">    <span class="type">partinfo_t</span> partinfo[DISK_PRIMARY_PART_CNT];  <span class="comment">// 分区信息</span></span><br><span class="line">&#125;<span class="type">disk_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="19-2-识别系统中已有的磁盘"><a href="#19-2-识别系统中已有的磁盘" class="headerlink" title="19.2 识别系统中已有的磁盘"></a>19.2 识别系统中已有的磁盘</h2><h3 id="1、系统中有多少块硬盘"><a href="#1、系统中有多少块硬盘" class="headerlink" title="1、系统中有多少块硬盘"></a>1、系统中有多少块硬盘</h3><p>两条总线，<code>primary bus</code>和<code>secondary bus</code>，每条总线分别对应两个硬盘。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262111920.png" alt="image-20240526211100606"></p>
<h3 id="2、磁盘检测"><a href="#2、磁盘检测" class="headerlink" title="2、磁盘检测"></a>2、磁盘检测</h3><p>可以通过识别命令来检测硬盘的存在，以及硬盘相关的信息。原始参考资料见:<a target="_blank" rel="noopener" href="https://wiki.osdev.org/ATA_PIO_Mode%E3%80%82%E4%BB%A5%E4%B8%8B%E4%BB%85%E5%88%97%E5%87%BA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9">https://wiki.osdev.org/ATA_PIO_Mode。以下仅列出项目中使用的部分内容</a><br>具体流程如下:</p>
<ul>
<li>写<code>Drive/HeadRegster</code>寄存器(地址<code>0x1F6</code>)：<code>0xA0</code>(master drive)或者<code>0xB0</code>(slave driver)</li>
<li>将扇区数量寄存器、<code>LBAlo,LBAmid,和LBAhi10</code>(地址<code>0x1F2-0x1F5</code>)全设置成0</li>
<li>向命令寄存器(地址<code>0x1F7</code>)发送<code>IDENTIFY</code>命令(<code>0xEC</code>)</li>
<li>读取状态寄存器(<code>0x1F7</code>)：如果值为0，则表明该硬盘不存在。如果其它值，等待DRQ置位或者ERR置位</li>
<li>如果<code>ERR</code>清令状态，从<code>0x1F0</code>读取<code>256</code>个<code>16</code>位的数据，其中保存了有关该磁盘相关的信息。</li>
</ul>
<p>返回的256个<code>16</code>位的数据内容：</p>
<ul>
<li>第<code>100-103</code>个数据，共<code>64</code>位：保存了该磁盘总的扇区数量</li>
</ul>
<h3 id="3、代码细节"><a href="#3、代码细节" class="headerlink" title="3、代码细节"></a>3、代码细节</h3><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#define DISK_NAME_SIZE              <span class="number">32</span></span><br><span class="line">#define PART_NAME_SIZE              <span class="number">32</span></span><br><span class="line">#define DISK_PRIMARY_PART_CNT       (<span class="number">4</span>+<span class="number">1</span>)</span><br><span class="line">#define DISK_CNT                    <span class="number">2</span></span><br><span class="line">#define DISK_PER_CHANNEL            <span class="number">2</span>           <span class="comment">// 每通道磁盘数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://wiki.osdev.org/ATA_PIO_Mode#IDENTIFY_command</span></span><br><span class="line"><span class="comment">// 只考虑支持主总线primary bus</span></span><br><span class="line">#define IOBASE_PRIMARY              <span class="number">0</span>x1F0</span><br><span class="line">#define	DISK_DATA(disk)				(disk-&gt;port_base + <span class="number">0</span>)		<span class="comment">// 数据寄存器</span></span><br><span class="line">#define	DISK_ERROR(disk)			(disk-&gt;port_base + <span class="number">1</span>)		<span class="comment">// 错误寄存器</span></span><br><span class="line">#define	DISK_SECTOR_COUNT(disk)		(disk-&gt;port_base + <span class="number">2</span>)		<span class="comment">// 扇区数量寄存器</span></span><br><span class="line">#define	DISK_LBA_LO(disk)			(disk-&gt;port_base + <span class="number">3</span>)		<span class="comment">// LBA寄存器</span></span><br><span class="line">#define	DISK_LBA_MID(disk)			(disk-&gt;port_base + <span class="number">4</span>)		<span class="comment">// LBA寄存器</span></span><br><span class="line">#define	DISK_LBA_HI(disk)			(disk-&gt;port_base + <span class="number">5</span>)		<span class="comment">// LBA寄存器</span></span><br><span class="line">#define	DISK_DRIVE(disk)			(disk-&gt;port_base + <span class="number">6</span>)		<span class="comment">// 磁盘或磁头</span></span><br><span class="line">#define	DISK_STATUS(disk)			(disk-&gt;port_base + <span class="number">7</span>)		<span class="comment">// 状态寄存器</span></span><br><span class="line">#define	DISK_CMD(disk)				(disk-&gt;port_base + <span class="number">7</span>)		<span class="comment">// 命令寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ATA命令</span></span><br><span class="line">#define	DISK_CMD_IDENTIFY			<span class="number">0</span>xEC	    <span class="comment">// IDENTIFY命令</span></span><br><span class="line">#define	DISK_CMD_READ				<span class="number">0</span>x24	    <span class="comment">// 读命令</span></span><br><span class="line">#define	DISK_CMD_WRITE				<span class="number">0</span>x34	    <span class="comment">// 写命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态寄存器</span></span><br><span class="line">#define DISK_STATUS_ERR             (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)    <span class="comment">// 发生错误</span></span><br><span class="line">#define DISK_STATUS_DRQ             (<span class="number">1</span> &lt;&lt; <span class="number">3</span>)    <span class="comment">// 准备好接受数据或者输出数据</span></span><br><span class="line">#define DISK_STATUS_DF              (<span class="number">1</span> &lt;&lt; <span class="number">5</span>)    <span class="comment">// 驱动错误</span></span><br><span class="line">#define DISK_STATUS_BUSY            (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)    <span class="comment">// 正忙</span></span><br><span class="line"></span><br><span class="line">#define	DISK_DRIVE_BASE		    <span class="number">0</span>xE0		<span class="comment">// 驱动器号基础值:0xA0 + LBA</span></span><br></pre></td></tr></table></figure>

<h3 id="4、结果"><a href="#4、结果" class="headerlink" title="4、结果"></a>4、结果</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262205497.png" alt="image-20240526220510242"></p>
<p>1、<code>sda</code>：放<code>boot/loader/kernel</code>；</p>
<p>2、<code>sdb</code>：放<code>FAT16</code>磁盘文件系统，放置相应的应用程序。</p>
<h2 id="19-3-解析磁盘分区表"><a href="#19-3-解析磁盘分区表" class="headerlink" title="19.3 解析磁盘分区表"></a>19.3 解析磁盘分区表</h2><p>分区表中共<code>4</code>个表项，每个表项包含了起始扇区、总扇区数、文件系统类型等关键性信息。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262212616.png" alt="image-20240526221201306"></p>
<blockquote>
<p><strong>MBR（主引导记录，Master Boot Record）</strong>是传统的磁盘分区表格式之一，用于在硬盘上划分不同的分区。它位于硬盘的第一个扇区（即0柱面、0磁头、1扇区），占用512字节。MBR不仅包含用于启动操作系统的引导代码，还包含分区表，用于描述磁盘上分区的布局。</p>
<p>（1）MBR由三个主要部分组成：</p>
<ol>
<li><strong>引导程序（Bootloader）</strong>：446字节</li>
</ol>
<p>  引导程序包含启动代码，用于引导操作系统。当计算机启动时，BIOS（或UEFI）会加载MBR中的引导代码，并执行它。这个引导代码通常用于查找活动分区，并加载该分区的引导扇区，以便进一步启动操作系统。</p>
<ol start="2">
<li><strong>分区表（Partition Table）</strong>：64字节</li>
</ol>
<p>  分区表包含四个分区项，每个分区项占用16字节。每个分区项描述一个分区的信息。</p>
<p>  一个分区项的格式如下：</p>
<ul>
<li><strong>引导标志（1字节）</strong>：表示该分区是否为活动分区（引导分区），值为0x80表示活动分区，0x00表示非活动分区。</li>
<li><strong>起始CHS地址（3字节）</strong>：分区起始地址，以CHS（柱面、磁头、扇区）格式表示。</li>
<li><strong>分区类型（1字节）</strong>：表示分区类型，例如0x83表示Linux分区，0x07表示NTFS分区。</li>
<li><strong>结束CHS地址（3字节）</strong>：分区结束地址，以CHS格式表示。</li>
<li><strong>起始LBA地址（4字节）</strong>：分区起始地址，以LBA（逻辑块地址）格式表示。</li>
<li><strong>分区大小（4字节）</strong>：分区的大小，以扇区为单位。</li>
</ul>
<ol start="3">
<li><strong>签名（Signature）</strong>：2字节</li>
</ol>
<p>  MBR的最后两个字节是签名，固定为0x55AA，用于标识这是一个有效的MBR。如果这两个字节不匹配，BIOS会认为硬盘上没有有效的MBR，不会继续引导。</p>
<p>（2）示例</p>
<p>假设我们有一个硬盘，其MBR如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&gt;0000: 33 C0 8E D0 BC 00 7C 8B F4 50 07 50 1F FB FC BE 00 7C ...</span></span><br><span class="line">&gt;...</span><br><span class="line"><span class="section">&gt;01BE: 00 01 01 00 07 FE FF FF 3F 00 00 00 BF 9E 0D 00</span></span><br><span class="line"><span class="section">&gt;01CE: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="section">&gt;01DE: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="section">&gt;01EE: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="section">&gt;01FE: 55 AA</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li><strong>引导程序</strong>：从偏移量<code>0x0000</code>到<code>0x01BD</code>，共<code>446</code>字节。</li>
<li><strong>分区表</strong></li>
<li>第一个分区项从<code>0x01BE</code>到<code>0x01CD</code>。<ul>
<li><strong>引导标志</strong>：0x00，表示非活动分区。</li>
<li><strong>起始CHS地址</strong>：0x010100，表示柱面1，磁头1，扇区1。</li>
<li><strong>分区类型</strong>：0x07，表示NTFS分区。</li>
<li><strong>结束CHS地址</strong>：0xFEFFFF，表示柱面1023，磁头254，扇区63。</li>
<li><strong>起始LBA地址</strong>：0x0000003F，表示LBA地址63。</li>
<li><strong>分区大小</strong>：0x0DBF9EBF，表示分区大小为22934559扇区（约11GB）。</li>
</ul>
</li>
<li>其他三个分区项从<code>0x01CE</code>到<code>0x01ED</code>，当前示例中这些分区项未使用，全为0。</li>
<li><strong>签名</strong>：最后两个字节<code>0x55AA</code>。</li>
</ul>
<p>（3）分区操作</p>
<p>操作系统和磁盘工具通过读写MBR中的分区表来管理硬盘分区。例如，创建、删除、调整分区大小等操作都涉及到修改MBR中的分区表信息。</p>
<p>（4）MBR的局限性</p>
<p>由于MBR使用32位地址来表示分区大小，因此单个分区的最大容量为2^32个扇区（每扇区512字节），即2TB。此外，MBR分区表最多只能有四个主分区或三个主分区和一个扩展分区（扩展分区内可以包含多个逻辑分区）。这些局限性促使了GPT（GUID Partition Table）等更现代的分区表格式的出现，支持更大的磁盘和更多的分区。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 检测分区表信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">detect_part_info</span><span class="params">(<span class="type">disk_t</span> *disk)</span> &#123;</span><br><span class="line">    <span class="type">mbr_t</span> mbr;</span><br><span class="line"></span><br><span class="line">    ata_send_cmd(disk, <span class="number">0</span>, <span class="number">1</span>, DISK_CMD_READ);</span><br><span class="line">    <span class="type">int</span> err = ata_wait_data(disk);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;read mbr failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ata_read_data(disk, &amp;mbr, <span class="keyword">sizeof</span>(mbr));</span><br><span class="line">    <span class="type">part_item_t</span> *item = mbr.part_item;  <span class="comment">// 指向分区表起始位置</span></span><br><span class="line">    <span class="type">partinfo_t</span> *part_info = disk-&gt;partinfo + <span class="number">1</span>;  <span class="comment">// 第0个表项已被使用，所以从第1个表项开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MBR_PRIMARY_PART_NR; i++, item++, part_info++) &#123;</span><br><span class="line">        part_info-&gt;type = item-&gt;system_id;</span><br><span class="line">        <span class="keyword">if</span> (part_info-&gt;type == FS_INVALID) &#123;</span><br><span class="line">            part_info-&gt;total_sector = <span class="number">0</span>;</span><br><span class="line">            part_info-&gt;start_sector = <span class="number">0</span>;</span><br><span class="line">            part_info-&gt;disk = (<span class="type">disk_t</span> *)<span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            kernel_sprintf(part_info-&gt;name, <span class="string">&quot;%s%d&quot;</span>, disk-&gt;name, i+<span class="number">1</span>);</span><br><span class="line">            part_info-&gt;total_sector = item-&gt;total_sectors;</span><br><span class="line">            part_info-&gt;start_sector = item-&gt;relative_sectors;</span><br><span class="line">            part_info-&gt;disk = disk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262245138.png" alt="image-20240526224546950"></p>
<h2 id="19-4-增加磁盘设备管理"><a href="#19-4-增加磁盘设备管理" class="headerlink" title="19.4 增加磁盘设备管理"></a>19.4 增加磁盘设备管理</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270914097.png" alt="image-20240527091359469"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270914740.png" alt="image-20240527091426820"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dev.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DEV_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">    DEV_TTY,</span><br><span class="line">    DEV_DISK,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dev.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">dev_desc_t</span> dev_tty_desc;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">dev_desc_t</span> dev_disk_desc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象设备表（静态注册）</span></span><br><span class="line"><span class="type">static</span> <span class="type">dev_desc_t</span> *dev_desc_tbl[] = &#123;</span><br><span class="line">    &amp;dev_tty_desc,</span><br><span class="line">    &amp;dev_disk_desc,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// disk.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">dev_desc_t</span> dev_disk_desc = &#123;</span><br><span class="line">    .name = <span class="string">&quot;disk&quot;</span>,</span><br><span class="line">    .major = DEV_DISK,</span><br><span class="line">    .open = disk_open,</span><br><span class="line">    .read = disk_read,</span><br><span class="line">    .write = disk_write,</span><br><span class="line">    .control = disk_control,</span><br><span class="line">    .close = disk_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>disk_open()</code></p>
<ol>
<li><p>根据次设备号取磁盘号和分区号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> disk_idx = (*dev*-&gt;minor &gt;&gt; <span class="number">4</span>) - <span class="number">0xa</span>;  *<span class="comment">// 取高4位*</span></span><br><span class="line"><span class="type">int</span> part_idx = *dev*-&gt;minor &amp; <span class="number">0xF</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据磁盘编号取对应磁盘</p>
</li>
<li><p>根据分区号取对应分区</p>
</li>
<li><p>将分区信息保存到data中</p>
</li>
<li><p>打开相应中断</p>
</li>
</ol>
<h2 id="19-5-实现磁盘的读取和写入"><a href="#19-5-实现磁盘的读取和写入" class="headerlink" title="19.5 实现磁盘的读取和写入"></a>19.5 实现磁盘的读取和写入</h2><p>由于每条总线上的<code>2</code>块磁盘<strong>共用相同的中断和IO端口</strong>，考虑到多进程可能同时对磁盘进行读写操作，因此最好是加上锁。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270936751.png" alt="image-20240527093651259"></p>
<p>在<code>identify_disk()</code>中调用了<code>ata_wait_data()</code>来等到数据到达磁盘：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = ata_wait_data(disk);  <span class="comment">// 在此过程中一直占用CPU，效率较低</span></span><br></pre></td></tr></table></figure>

<p>这个等待过程是一个<code>do-while</code>循环，在此过程中一直占用CPU，效率较低。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">// 等待数据或者有错误</span></span><br><span class="line">       status = inb(DISK_STATUS(disk));</span><br><span class="line">       <span class="keyword">if</span> ((status &amp; (DISK_STATUS_BUSY | DISK_STATUS_DRQ | DISK_STATUS_ERR)) != DISK_STATUS_BUSY) &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;<span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>因此考虑结合<strong>信号量和中断</strong>来进行处理。</p>
<p>当进程向磁盘发送读写请求后，在磁盘准备数据的期间，进程暂时主动放弃CPU，并进入等待队列；当磁盘的数据准备好后，向对应的进程发送中断信号，告知进程。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270948328.png" alt="image-20240527094819093" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">disk_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> start_sector, <span class="type">char</span> *buf, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">partinfo_t</span> *part_info = (<span class="type">partinfo_t</span> *)dev-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (!part_info) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;get part info failed, device: %d&quot;</span>, dev-&gt;minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">disk_t</span> *disk = part_info-&gt;disk;</span><br><span class="line">    <span class="keyword">if</span> (disk == (<span class="type">disk_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;no disk, device: %d&quot;</span>, dev-&gt;minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    task_on_op = <span class="number">1</span>;</span><br><span class="line">    ata_send_cmd(disk, part_info-&gt;start_sector + start_sector, count, DISK_CMD_READ);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; count; cnt++, buf+=disk-&gt;sector_size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task_current()) &#123;</span><br><span class="line">            sem_wait(disk-&gt;op_sem);  <span class="comment">// 避开系统初始化时在此处卡死</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> err = ata_wait_data(disk);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;disk(%s) read error: start sector: %d, count: %d&quot;</span>,</span><br><span class="line">                disk-&gt;name, start_sector, count</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ata_read_data(disk, buf, disk-&gt;sector_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;mutex);  </span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">disk_write</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> start_sector, <span class="type">char</span> *buf, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">partinfo_t</span> *part_info = (<span class="type">partinfo_t</span> *)dev-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (!part_info) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;get part info failed, device: %d&quot;</span>, dev-&gt;minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">disk_t</span> *disk = part_info-&gt;disk;</span><br><span class="line">    <span class="keyword">if</span> (disk == (<span class="type">disk_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;no disk, device: %d&quot;</span>, dev-&gt;minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    task_on_op = <span class="number">1</span>;</span><br><span class="line">    ata_send_cmd(disk, part_info-&gt;start_sector + start_sector, count, DISK_CMD_WRITE);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; count; cnt++, buf+=disk-&gt;sector_size) &#123;</span><br><span class="line">        ata_write_data(disk, buf, disk-&gt;sector_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (task_current()) &#123;</span><br><span class="line">            sem_wait(disk-&gt;op_sem);  <span class="comment">// 避开系统初始化时在此处卡死</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> err = ata_wait_data(disk);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;disk(%s) read error: start sector: %d, count: %d&quot;</span>,</span><br><span class="line">                disk-&gt;name, start_sector, count</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;mutex);  </span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-6-FAT16文件系统"><a href="#19-6-FAT16文件系统" class="headerlink" title="19.6 FAT16文件系统"></a>19.6 FAT16文件系统</h2><h3 id="1、FAT16"><a href="#1、FAT16" class="headerlink" title="1、FAT16"></a>1、FAT16</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271025353.png" alt="image-20240527102544023"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271027930.png" alt="image-20240527102751513"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271028998.png" alt="image-20240527102858618"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271034500.png" alt="image-20240527103442028"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271036205.png" alt="image-20240527103603679"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271038250.png" alt="image-20240527103821885"></p>
<h3 id="2、FAT表项配置"><a href="#2、FAT表项配置" class="headerlink" title="2、FAT表项配置"></a>2、FAT表项配置</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271051879.png" alt="image-20240527105122660"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// 解析DBR参数，解析出有用的参数</span></span><br><span class="line">    <span class="type">fat_t</span> *fat = &amp;fs-&gt;fat_data;</span><br><span class="line">    fat-&gt;fat_buffer = (<span class="type">uint8_t</span> *)dbr;</span><br><span class="line">    fat-&gt;bytes_per_sec = dbr-&gt;BPB_BytsPerSec;</span><br><span class="line">    fat-&gt;tbl_start = dbr-&gt;BPB_RsvdSecCnt;</span><br><span class="line">    fat-&gt;tbl_sectors = dbr-&gt;BPB_FATSz16;</span><br><span class="line">    fat-&gt;tbl_cnt = dbr-&gt;BPB_NumFATs;</span><br><span class="line">    fat-&gt;root_ent_cnt = dbr-&gt;BPB_RootEntCnt;</span><br><span class="line">    fat-&gt;sec_per_cluster = dbr-&gt;BPB_SecPerClus;</span><br><span class="line">    fat-&gt;cluster_byte_size = fat-&gt;sec_per_cluster * dbr-&gt;BPB_BytsPerSec;</span><br><span class="line">	fat-&gt;root_start = fat-&gt;tbl_start + fat-&gt;tbl_sectors * fat-&gt;tbl_cnt;</span><br><span class="line">    fat-&gt;data_start = fat-&gt;root_start + fat-&gt;root_ent_cnt * <span class="number">32</span> / SECTOR_SIZE;</span><br><span class="line">    fat-&gt;curr_sector = <span class="number">-1</span>;</span><br><span class="line">    fat-&gt;fs = fs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 简单检查是否是FAT16文件系统</span></span><br><span class="line">	<span class="keyword">if</span> (fat-&gt;tbl_cnt != <span class="number">2</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;fat table num error, major: %x, minor: %x&quot;</span>, major, minor);</span><br><span class="line">		<span class="keyword">goto</span> mount_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kernel_memcmp(dbr-&gt;BS_FileSysType, <span class="string">&quot;FAT16&quot;</span>, <span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;not a fat16 file system, major: %x, minor: %x&quot;</span>, major, minor);</span><br><span class="line">        <span class="keyword">goto</span> mount_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录相关的打开信息</span></span><br><span class="line">    fs-&gt;type = FS_FAT16;</span><br><span class="line">    fs-&gt;data = &amp;fs-&gt;fat_data;</span><br><span class="line">    fs-&gt;dev_id = dev_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">mount_failed:</span><br><span class="line">    <span class="keyword">if</span> (dbr) &#123;</span><br><span class="line">        memory_free_page((<span class="type">uint32_t</span>)dbr);</span><br><span class="line">    &#125;</span><br><span class="line">    dev_close(dev_id);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatfs_unmount</span> <span class="params">(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs)</span> &#123;</span><br><span class="line">    <span class="type">fat_t</span> * fat = (<span class="type">fat_t</span> *)fs-&gt;data;</span><br><span class="line"></span><br><span class="line">    dev_close(fs-&gt;dev_id);</span><br><span class="line">    memory_free_page((<span class="type">uint32_t</span>)fat-&gt;fat_buffer);  <span class="comment">// 释放FAT表项缓冲</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-7-遍历目录命令ls"><a href="#19-7-遍历目录命令ls" class="headerlink" title="19.7 遍历目录命令ls"></a>19.7 遍历目录命令ls</h2><p>目前的项目有一个问题：</p>
<p>在<code>first_task()</code>中有系统调用相关的工作，因此在<code>kernel.lds</code>中将系统调用相关的代码和数据放到了内核空间中，如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PROVIDE(s_text = .);</span><br><span class="line">.text : &#123;</span><br><span class="line">	*(EXCLUDE_FILE(*first_task* *lib_syscall*) .text)</span><br><span class="line">&#125;</span><br><span class="line">.rodata : &#123;</span><br><span class="line">	*(EXCLUDE_FILE(*first_task* *lib_syscall*) .rodata)</span><br><span class="line">&#125;</span><br><span class="line">PROVIDE(e_text = .);</span><br><span class="line"></span><br><span class="line">. = ALIGN(4096);</span><br><span class="line">PROVIDE(s_data = .);</span><br><span class="line">.data : &#123;</span><br><span class="line">	*(EXCLUDE_FILE(*first_task* *lib_syscall*) .data)</span><br><span class="line">&#125;</span><br><span class="line">.bss : &#123;</span><br><span class="line">	*(EXCLUDE_FILE(*first_task* *lib_syscall*) .bss)</span><br><span class="line">&#125;</span><br><span class="line">e_data = .;</span><br></pre></td></tr></table></figure>

<p>然而我们在<code>lib_syscall.c</code>的下述函数中调用了<code>newlib</code>库的<code>malloc()/free()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DIR *<span class="title function_">opendir</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span> <span class="params">(DIR *dir)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span> <span class="params">(DIR *dir)</span>;</span><br></pre></td></tr></table></figure>

<p>但是在链接脚本中并没有把内核空间和<code>newlib</code>库链接起来，因此在编译时就找不到<code>malloc()/free()</code>。</p>
<p>有两种解决方法：</p>
<ol>
<li>将<code>newlib</code>库也加入到内核空间中；——不推荐，会使得内核体积膨胀</li>
<li>将<code>lib_syscall.c</code>复制一份到<code>kernel/init</code>中，同时在<code>CMakeLists.txt</code>中去掉<code>-lapp</code>。</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// set(LIBS_FLAGS <span class="string">&quot;-L $&#123;CMAKE_BINARY_DIR&#125;/source/applib/ -lapp&quot;</span>)</span><br><span class="line">set(LIBS_FLAGS <span class="string">&quot;-L $&#123;CMAKE_BINARY_DIR&#125;/source/applib/&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>增加<code>ls</code>命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 显示目录</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_ls</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span> &#123;</span><br><span class="line">    DIR *p_dir = opendir(<span class="string">&quot;temp&quot;</span>);  <span class="comment">// 本项目暂只支持顶层目录访问</span></span><br><span class="line">    <span class="keyword">if</span> (p_dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open dir failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(p_dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c %s %d&quot;</span>,</span><br><span class="line">            entry-&gt;type = FILE_DIR ? <span class="string">&#x27;d&#x27;</span> : <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">            entry-&gt;name,</span><br><span class="line">            entry-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(p_dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">file_type_t</span> &#123;</span></span><br><span class="line">    FILE_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">    FILE_TTY,</span><br><span class="line">    FILE_DIR,</span><br><span class="line">    FILE_NORMAL,</span><br><span class="line">&#125;<span class="type">file_type_t</span>;</span><br></pre></td></tr></table></figure>

<p>由于对每个类型的文件的遍历方式不同，因此在<code>_fs_op_t</code>中增加相应的接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fs_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fs_op_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*mount)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">int</span> major, <span class="type">int</span> minor);   <span class="comment">// mount 挂载</span></span><br><span class="line">    <span class="type">void</span> (*unmount)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs);                      <span class="comment">// unmount 取消挂载</span></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">file_t</span> *file);  <span class="comment">// fs的相关信息会放入file中</span></span><br><span class="line">    <span class="type">int</span> (*read)(<span class="type">char</span> *buf, <span class="type">int</span> size, <span class="type">file_t</span> *file);</span><br><span class="line">    <span class="type">int</span> (*write)(<span class="type">char</span> *buf, <span class="type">int</span> size, <span class="type">file_t</span> *file);</span><br><span class="line">    <span class="type">int</span> (*seek)(<span class="type">file_t</span> *file, <span class="type">uint32_t</span> offset, <span class="type">int</span> dir);</span><br><span class="line">    <span class="type">int</span> (*stat)(<span class="type">file_t</span> *file, <span class="keyword">struct</span> stat *st);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="type">file_t</span> *file);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*opendir) (<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">const</span> <span class="type">char</span> *name, DIR *dir);</span><br><span class="line">    <span class="type">int</span> (*readdir) (<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, DIR *dir, <span class="keyword">struct</span> dirent *dirent);</span><br><span class="line">    <span class="type">int</span> (*closedir) (<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, DIR *dir);</span><br><span class="line">&#125;<span class="type">fs_op_t</span>;</span><br></pre></td></tr></table></figure>

<p>具体的调用实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name, DIR * dir)</span> &#123;</span><br><span class="line">	fs_protect(root_fs);</span><br><span class="line">	<span class="type">int</span> err = root_fs-&gt;op-&gt;opendir(root_fs, name, dir);</span><br><span class="line">	fs_unprotect(root_fs);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_readdir</span><span class="params">(DIR* dir, <span class="keyword">struct</span> dirent * dirent)</span> &#123;</span><br><span class="line">	fs_protect(root_fs);</span><br><span class="line">	<span class="type">int</span> err = root_fs-&gt;op-&gt;readdir(root_fs, dir, dirent);</span><br><span class="line">	fs_unprotect(root_fs);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_closedir</span><span class="params">(DIR *dir)</span> &#123;</span><br><span class="line">	fs_protect(root_fs);</span><br><span class="line">	<span class="type">int</span> err = root_fs-&gt;op-&gt;closedir(root_fs, dir);</span><br><span class="line">	fs_unprotect(root_fs);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">DIR *<span class="title function_">opendir</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    DIR *dir = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DIR));</span><br><span class="line">    <span class="keyword">if</span> (dir == (DIR *)<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (DIR *)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_opendir;</span><br><span class="line">    args.arg0 = (<span class="type">int</span>)path;</span><br><span class="line">    args.arg1 = (<span class="type">int</span>)dir;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err = sys_call(&amp;args);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(dir);</span><br><span class="line">        <span class="keyword">return</span> (DIR *)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span> <span class="params">(DIR *dir)</span> &#123;</span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_readdir;</span><br><span class="line">    args.arg0 = (<span class="type">int</span>)dir;</span><br><span class="line">    args.arg1 = (<span class="type">int</span>)&amp;dir-&gt;dirent;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err = sys_call(&amp;args);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// free(dir);  // 这里不应该free(dir)，否则就会和closedir()中的free重复</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">struct</span> dirent *)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;dir-&gt;dirent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span> <span class="params">(DIR *dir)</span> &#123;</span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_closedir;</span><br><span class="line">    args.arg0 = (<span class="type">int</span>)dir;</span><br><span class="line">    sys_call(&amp;args);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尤其注意<code>readdir()</code>这一行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free(dir);  // 这里不应该free(dir)，否则就会和closedir()中的free重复</span></span><br></pre></td></tr></table></figure>



<p>FAT16文件系统将顶层目录下的所有文件和目录的信息放在<strong>根目录区</strong>中，因此可以通过读取根目录区中的内容获取根目录下所有的文件和目录信息。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271559579.png" alt="image-20240527155922869"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271559465.png" alt="image-20240527155900689"></p>
<h2 id="19-8-文件查看命令less"><a href="#19-8-文件查看命令less" class="headerlink" title="19.8 文件查看命令less"></a>19.8 文件查看命令less</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271834662.png" alt="image-20240527183438134"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 列出文本文件内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_less</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271856539.png" alt="image-20240527185627202"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271857558.png" alt="image-20240527185722278"></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/06/13/1%20C++/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E5%AF%B9%E5%90%AB%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E8%BF%9B%E8%A1%8Csizeof/" rel="prev" title="对含有虚函数的类进行sizeof">
      <i class="fa fa-chevron-left"></i> 对含有虚函数的类进行sizeof
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/07/03/0%20%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE3_C++%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="next" title="项目2_C++高性能服务器">
      项目2_C++高性能服务器 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%BA%90%E7%A0%81%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E6%8A%A5%E9%94%99"><span class="nav-text">一、源码测试过程报错</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F%EF%BC%9A%E6%8E%A5%E7%AE%A1%E6%8E%A7%E5%88%B6%E6%9D%83"><span class="nav-text">二、引导程序：接管控制权</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="nav-text">2.1 计算机启动流程简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E6%8E%A5%E7%AE%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%8E%A7%E5%88%B6%E6%9D%83"><span class="nav-text">2.2 接管计算机运行控制权</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%88%9B%E5%BB%BA%E5%8F%AF%E5%BC%95%E5%AF%BC%E7%9A%84%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">2.3 创建可引导的启动程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B4%E4%BD%93%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%80%BB%E8%BE%91"><span class="nav-text">1. 整体的项目逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%95%B4%E4%BD%93%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-text">2. 整体的开发工作流程：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F"><span class="nav-text">2.4 初始化引导程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F%EF%BC%9F"><span class="nav-text">1. 什么是引导程序？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%BA%E4%BA%86%E5%85%BC%E5%AE%B9%E6%97%A9%E6%9C%9F%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%8Cx86%E5%9C%A8%E4%B8%8A%E7%94%B5%E5%90%AF%E5%8A%A8%E5%90%8E%EF%BC%8C%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%A8%A1%E5%BC%8F%E3%80%82"><span class="nav-text">2. 为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-x86%E4%B8%8E%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%BB%E8%A6%81%E5%86%85%E6%A0%B8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">3. x86与编程相关的主要内核寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%EF%BC%888086%EF%BC%89"><span class="nav-text">4. 实模式下的内存映射（8086）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E4%BD%BF%E7%94%A8BIOS%E4%B8%AD%E6%96%AD%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6"><span class="nav-text">2.5 使用BIOS中断显示字符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%EF%BC%9F"><span class="nav-text">1. 如何显示字符？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81BIOS-INT-10%E4%B8%AD%E6%96%AD%E5%8A%9F%E8%83%BD"><span class="nav-text">2、BIOS INT 10中断功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-%E4%BD%BF%E7%94%A8BIOS%E4%B8%AD%E6%96%AD%E8%AF%BB%E5%8F%96%E7%A3%81%E7%9B%98"><span class="nav-text">2.6 使用BIOS中断读取磁盘</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%80%8E%E6%A0%B7%E5%AE%8C%E6%88%90%E4%BB%8EBoot%E5%8A%A0%E8%BD%BDloader%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-text">1. 怎样完成从Boot加载loader的过程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-INT-13%E7%A3%81%E7%9B%98%E8%AF%BB%E5%8F%96"><span class="nav-text">2. INT 13磁盘读取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F"><span class="nav-text">2.7 初始化引导程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90loader%E5%B9%B6%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98%E6%98%A0%E5%83%8F%EF%BC%9F"><span class="nav-text">1、如何生成loader并写入磁盘映像？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%80%8E%E6%A0%B7%E4%BB%8Eboot%E8%B7%B3%E8%BD%AC%E5%88%B0loader%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="nav-text">2、怎样从boot跳转到loader执行？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%8A%A0%E8%BD%BD%E5%99%A8loader%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">三、加载器loader的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%88%A9%E7%94%A8%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">3.1 利用内联汇编显示字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E7%90%86%E8%AE%BA"><span class="nav-text">1、内联汇编理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">2、示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E5%AE%B9%E9%87%8F"><span class="nav-text">3.2 检测内存容量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E7%90%86%E8%AE%BA"><span class="nav-text">1、内存检测方法理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%A4%BA%E4%BE%8B-1"><span class="nav-text">2、示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E5%88%87%E6%8D%A2%E8%87%B3%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="nav-text">3.3 切换至保护模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%BC%96%E7%A8%8B%E7%BB%86%E8%8A%82"><span class="nav-text">2、编程细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E4%BD%BF%E7%94%A8LBA%E8%AF%BB%E5%8F%96%E7%A3%81%E7%9B%98"><span class="nav-text">3.4 使用LBA读取磁盘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E5%88%9B%E5%BB%BA%E5%86%85%E6%A0%B8%E5%B7%A5%E7%A8%8B"><span class="nav-text">3.5 创建内核工程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E5%90%91%E5%86%85%E6%A0%B8%E4%BC%A0%E9%80%92%E5%90%AF%E5%8A%A8%E4%BF%A1%E6%81%AF"><span class="nav-text">3.6 向内核传递启动信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%8Eloader%E5%88%B0kernel%E7%9A%84%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93%EF%BC%9F"><span class="nav-text">1、如何实现从loader到kernel的信息传输？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81x86%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-text">2、x86栈的基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-text">3、实现细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-%E4%BB%A3%E7%A0%81-%E6%95%B0%E6%8D%AE%E6%AE%B5%E4%B8%8E%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC"><span class="nav-text">3.7 代码&#x2F;数据段与链接脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-text">1、链接的理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC"><span class="nav-text">2、自定义链接脚本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E6%98%A0%E5%83%8F%E6%96%87%E4%BB%B6"><span class="nav-text">3.8 加载内核映像文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-1"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-text">2、代码实现细节</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">四、中断与异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E5%88%9B%E5%BB%BAGDT%E8%A1%A8%E5%8F%8A%E5%85%B6%E8%A1%A8%E9%A1%B9"><span class="nav-text">4.1 创建GDT表及其表项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-2"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E7%BB%86%E8%8A%82"><span class="nav-text">2、代码细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AE%80%E4%BB%8B"><span class="nav-text">4.2 保护模式下的内存管理简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-3"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-text">2、内存访问的整体流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BDGDT%E8%A1%A8"><span class="nav-text">4.3 重新加载GDT表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-text">2、实现细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E8%A7%A6%E5%8F%91%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%BC%82%E5%B8%B8%E7%AE%80%E4%BB%8B"><span class="nav-text">4.4 触发异常与异常简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-4"><span class="nav-text">1、理论基础</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-text">4.5 添加中断门描述符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-5"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">2、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-%E6%8D%95%E8%8E%B7%E9%99%A40%E5%BC%82%E5%B8%B8"><span class="nav-text">4.6 捕获除0异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%B8%BA%E6%89%80%E6%9C%89%E5%BC%82%E5%B8%B8%E9%85%8D%E7%BD%AE%E7%BC%BA%E7%9C%81%E7%9A%84%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-text">1、为所有异常配置缺省的处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%99%A40%E5%BC%82%E5%B8%B8%E5%8F%91%E7%94%9F"><span class="nav-text">2、除0异常发生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E9%A2%84%E5%85%88%E4%BF%9D%E5%AD%98%E5%AF%84%E5%AD%98%E5%99%A8%E7%8A%B6%E6%80%81"><span class="nav-text">3、预先保存寄存器状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-%E8%A7%A3%E6%9E%90%E5%BC%82%E5%B8%B8%E6%A0%88%E4%BF%A1%E6%81%AF"><span class="nav-text">4.7 解析异常栈信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-6"><span class="nav-text">1、理论基础</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-8-%E5%88%A9%E7%94%A8%E5%AE%8F%E9%87%8D%E7%94%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81"><span class="nav-text">4.8 利用宏重用异常处理代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%8F%E9%87%8D%E7%94%A8%E7%9B%B8%E5%85%B3"><span class="nav-text">1、宏重用相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%90%91IDT%E8%A1%A8%E9%A1%B9%E4%B8%AD%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-text">2、向IDT表项中安装中断处理程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-9-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-text">4.9 初始化中断控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-7"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82-1"><span class="nav-text">2、实现细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-10-%E4%B8%AD%E6%96%AD%E7%9A%84%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="nav-text">4.10 中断的打开与关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-11-%E5%90%AF%E5%8A%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%B9%B6%E6%89%93%E5%BC%80%E4%B8%AD%E6%96%AD"><span class="nav-text">4.11 启动定时器并打开中断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%97%A5%E5%BF%97%E4%B8%8Eprintf%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="nav-text">五、日志与printf格式化输出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E5%88%9B%E5%BB%BA%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E6%8E%A5%E5%8F%A3"><span class="nav-text">5.1 创建日志打印接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BF%A1%E6%81%AF%E8%BE%93%E5%87%BA"><span class="nav-text">5.2 实现基本的信息输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="nav-text">5.3 实现字符串的格式化输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E8%A7%84%E5%A4%84%E7%90%86"><span class="nav-text">1、字符串的常规处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="nav-text">2、字符串的格式化输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E5%88%A9%E7%94%A8assert%E8%BE%85%E5%8A%A9%E8%B0%83%E8%AF%95"><span class="nav-text">5.4 利用assert辅助调试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="nav-text">六、实现简单的进程切换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5"><span class="nav-text">6.1 添加任务状态段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-8"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81TSS%E5%AE%9A%E4%B9%89"><span class="nav-text">2、TSS定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">6.2 任务的简单初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E7%AE%80%E5%8D%95%E5%8F%8C%E4%BB%BB%E5%8A%A1%E7%9B%B8%E4%BA%92%E5%88%87%E6%8D%A2"><span class="nav-text">6.3 简单双任务相互切换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA"><span class="nav-text">1、理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%87%87%E7%94%A8JMP%E8%BF%9B%E8%A1%8C%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2"><span class="nav-text">2、采用JMP进行任务切换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E5%8F%A6%E4%B8%80%E7%A7%8D%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="nav-text">6.4 另一种任务切换方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-9"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">2、代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">七、实现链表数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E5%AE%9A%E4%B9%89%E7%BB%93%E7%82%B9%E5%92%8C%E9%93%BE%E8%A1%A8"><span class="nav-text">7.1 定义结点和链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%8F%92%E5%85%A5"><span class="nav-text">7.2 链表的两种插入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%A4%B4%E6%8F%92"><span class="nav-text">1、头插</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%B0%BE%E6%8F%92"><span class="nav-text">2、尾插</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%88%A0%E9%99%A4"><span class="nav-text">7.3 链表的两种删除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%A4%B4%E5%88%A0"><span class="nav-text">1、头删</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%88%A0%E9%99%A4%E4%BB%BB%E6%84%8F%E7%BB%93%E7%82%B9"><span class="nav-text">2、删除任意结点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E8%8E%B7%E5%8F%96%E7%BB%93%E7%82%B9%E6%89%80%E5%9C%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">7.4 获取结点所在的结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%A1%E7%90%86%E4%B8%8E%E5%BB%B6%E6%97%B6"><span class="nav-text">八、进程的管理与延时</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-text">8.1 添加任务管理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-%E5%B0%86%E4%BB%BB%E5%8A%A1%E5%8A%A0%E5%85%A5%E5%B0%B1%E7%BB%AA%E9%98%9F%E5%88%97"><span class="nav-text">8.2 将任务加入就绪队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-%E4%BB%BB%E5%8A%A1%E4%B8%BB%E5%8A%A8%E6%94%BE%E5%BC%83CPU"><span class="nav-text">8.3 任务主动放弃CPU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-%E8%AE%A9%E8%BF%9B%E7%A8%8B%E6%8C%89%E6%97%B6%E9%97%B4%E7%89%87%E8%BF%90%E8%A1%8C"><span class="nav-text">8.4 让进程按时间片运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-text">8.5 临界资源与临界区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-10"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BA%92%E6%96%A5%E5%AE%9E%E7%8E%B0"><span class="nav-text">2、互斥实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-%E8%AE%A9%E8%BF%9B%E7%A8%8B%E8%83%BD%E5%A4%9F%E5%BB%B6%E6%97%B6%E8%BF%90%E8%A1%8C"><span class="nav-text">8.6 让进程能够延时运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-7-%E8%AE%A9%E6%89%80%E6%9C%89%E8%BF%9B%E7%A8%8B%E9%83%BD%E8%83%BD%E5%BB%B6%E6%97%B6"><span class="nav-text">8.7 让所有进程都能延时</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="nav-text">九、进程间的同步与互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">9.1 计数信号量及其初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-11"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="nav-text">2、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-%E5%8F%91%E4%BF%A1%E5%8F%B7%E5%92%8C%E7%AD%89%E4%BF%A1%E5%8F%B7"><span class="nav-text">9.2 发信号和等信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-%E4%BD%BF%E7%94%A8%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">9.3 使用计数信号量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-%E4%BA%92%E6%96%A5%E9%94%81%E5%8F%8A%E5%85%B6%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">9.4 互斥锁及其初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5-%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%8A%A0%E8%A7%A3%E9%94%81"><span class="nav-text">9.5 互斥锁的加解锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-6-%E5%BA%94%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-text">9.6 应用互斥锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="nav-text">十、虚拟内存管理和保护模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98"><span class="nav-text">10.1 内存管理问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-%E4%BD%8D%E5%9B%BE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">10.2 位图数据结构与初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-3-%E4%BD%8D%E5%9B%BE%E4%BD%8D%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-text">10.3 位图位的分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-4-%E5%88%9B%E5%BB%BA%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E7%BB%93%E6%9E%84"><span class="nav-text">10.4 创建地址分配结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-5-%E8%A7%84%E5%88%92%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-text">10.5 规划内存空间的分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-6-%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="nav-text">10.6 内存分页机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-text">1、分页机制理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%9C%A8loader%E4%B8%AD%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="nav-text">2、在loader中开启分页机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-7-%E5%88%9B%E5%BB%BA%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8"><span class="nav-text">10.7 创建内核页表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">1、代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95"><span class="nav-text">2、代码调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE"><span class="nav-text">3、权限设置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-8-%E4%B8%BA%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E9%A1%B5%E8%A1%A8"><span class="nav-text">10.8 为进程创建页表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E"><span class="nav-text">1、问题说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="nav-text">2、代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E9%9A%94%E7%A6%BB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="nav-text">十一、隔离操作系统与进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-%E9%9A%94%E7%A6%BB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="nav-text">11.1 隔离操作系统与进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E7%A6%BB"><span class="nav-text">1、代码分离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%9C%B0%E5%9D%80%E5%88%86%E7%A6%BB"><span class="nav-text">2、地址分离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E6%90%AC%E8%BF%90"><span class="nav-text">3、代码搬运</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-%E8%B0%83%E6%95%B4%E5%BA%94%E7%94%A8%E7%9A%84%E7%89%B9%E6%9D%83%E7%BA%A7"><span class="nav-text">11.2 调整应用的特权级</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81x86%E8%8A%AF%E7%89%87%E7%9A%84%E7%89%B9%E6%9D%83%E7%BA%A7%E5%AE%9A%E4%B9%89"><span class="nav-text">1、x86芯片的特权级定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BF%9D%E6%8A%A4"><span class="nav-text">2、平坦模型如何实现保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">3、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-%E8%B0%83%E6%95%B4%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">11.3 调整异常处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BF%AE%E6%94%B9TSS%E5%AD%97%E6%AE%B5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">1、修改TSS字段初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">2、修改异常处理函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-4-%E4%BF%AE%E6%94%B9%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%89%B9%E6%9D%83%E7%BA%A7"><span class="nav-text">11.4 修改空闲任务的特权级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-5-%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%89%B9%E6%9D%83%E7%BA%A7"><span class="nav-text">11.5 修改用户任务的特权级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-6-%E4%B8%BA%E8%BF%9B%E7%A8%8B%E6%B7%BB%E5%8A%A0%E7%89%B9%E6%9D%83%E7%BA%A70%E7%9A%84%E6%A0%88%E7%A9%BA%E9%97%B4"><span class="nav-text">11.6 为进程添加特权级0的栈空间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E5%BB%BA%E7%AB%8B%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">十二、建立系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E8%BF%94%E5%9B%9E"><span class="nav-text">12.1 实现系统调用的调用和返回</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%B0%83%E7%94%A8%E9%97%A8"><span class="nav-text">1、调用门</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%88%9B%E5%BB%BA%E8%B0%83%E7%94%A8%E9%97%A8"><span class="nav-text">2、创建调用门</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%AE%9E%E7%8E%B0%E8%B0%83%E7%94%A8%E5%92%8C%E8%BF%94%E5%9B%9E"><span class="nav-text">3、实现调用和返回</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-%E5%85%B7%E4%BD%93%E7%9A%84%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0"><span class="nav-text">12.2 具体的调用实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E5%87%BA%E5%85%A5%E6%A0%88%E7%AE%A1%E7%90%86"><span class="nav-text">1、寄存器出入栈管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">2、系统调用结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E8%BD%AC%E5%8F%91%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">3、转发表实现系统调用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%9B%E5%BB%BA"><span class="nav-text">十三、新进程的加载与创建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#13-1-%E5%AE%9E%E7%8E%B0fork%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">13.1 实现fork系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-12"><span class="nav-text">1、理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BB%BB%E5%8A%A1%E5%9D%97%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E9%87%8A%E6%94%BE"><span class="nav-text">2、任务块的分配和释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%BB%E5%8A%A1%E5%9D%97"><span class="nav-text">3、初始化任务块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%A4%8D%E5%88%B6%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-text">4、复制进程地址空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-2-%E5%AE%9E%E7%8E%B0exec%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">13.2 实现exec系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE"><span class="nav-text">1、链接脚本设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%88%9B%E5%BB%BA%E7%A9%BAexec%E8%B0%83%E7%94%A8"><span class="nav-text">2、创建空exec调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%B7%BB%E5%8A%A0%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3"><span class="nav-text">3、添加虚拟文件访问接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%8A%A0%E8%BD%BDELF%E6%96%87%E4%BB%B6"><span class="nav-text">4、解析并加载ELF文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E5%88%86%E9%85%8D%E6%A0%88%E5%B9%B6%E8%BF%9B%E5%85%A5%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C"><span class="nav-text">5、分配栈并进入进程执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E4%B8%BA%E8%BF%9B%E7%A8%8B%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="nav-text">6、为进程传递参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-3-%E5%AE%9E%E7%8E%B0sys-yiled%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">13.3 实现sys_yiled系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%A7%A3%E5%86%B3task-init%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98"><span class="nav-text">1、解决task_init遗留问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%B5%8B%E8%AF%95sys-yield"><span class="nav-text">2、测试sys_yield()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8c%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84printf%E8%BE%93%E5%87%BA"><span class="nav-text">十四、使用c标准库中的printf输出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-%E5%A2%9E%E5%8A%A0%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">14.1 增加文件系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-%E5%AF%BC%E5%85%A5newlib-c%E5%B9%B6%E5%BC%95%E5%85%A5printf"><span class="nav-text">14.2 导入newlib c并引入printf</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81sbrk"><span class="nav-text">1、sbrk()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81printf"><span class="nav-text">2、printf()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%BA%94%E3%80%81%E4%BD%BF%E7%94%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%8E%E9%94%AE%E7%9B%98%E8%BF%9B%E8%A1%8C%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-text">十五、使用控制台与键盘进行输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-1-%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%AE%80%E4%BB%8B"><span class="nav-text">15.1 控制台简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-2-%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%8A%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">15.2 在控制台上显示字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="nav-text">1、控制台结构体定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">2、显示字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%B8%85%E5%B1%8F"><span class="nav-text">3、清屏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E6%BB%9A%E5%B1%8F"><span class="nav-text">4、滚屏</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-3-%E8%AE%BE%E7%BD%AE%E5%85%89%E6%A0%87%E5%B9%B6%E9%87%8D%E5%AE%9A%E5%90%91%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E5%88%B0%E6%98%BE%E7%A4%BA%E5%99%A8"><span class="nav-text">15.3 设置光标并重定向日志输出到显示器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-4-%E4%BF%9D%E5%AD%98%E5%B9%B6%E6%81%A2%E5%A4%8D%E5%85%89%E6%A0%87%E4%BD%8D%E7%BD%AE"><span class="nav-text">15.4 保存并恢复光标位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-5-%E6%9B%B4%E6%96%B0%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E7%9A%84%E9%A2%9C%E8%89%B2"><span class="nav-text">15.5 更新显示字体的颜色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-6-%E9%94%AE%E7%9B%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">15.6 键盘初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-7-%E5%80%9F%E5%8A%A9%E6%8C%89%E9%94%AE%E6%98%A0%E5%B0%84%E8%A1%A8%E8%BF%9B%E8%A1%8C%E9%94%AE%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="nav-text">15.7 借助按键映射表进行键值转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E5%85%AD%E3%80%81%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">十六、设备管理与文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#16-1-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6"><span class="nav-text">16.1 设备管理框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-2-%E5%A2%9E%E5%8A%A0tty%E8%AE%BE%E5%A4%87"><span class="nav-text">16.2 增加tty设备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA-1"><span class="nav-text">1、理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%A2%9E%E5%8A%A0tty%E8%AE%BE%E5%A4%87%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">2、增加tty设备的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%AE%9A%E4%B9%89tty%E8%AE%BE%E5%A4%87"><span class="nav-text">3、定义tty设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E6%89%93%E5%BC%80tty%E8%AE%BE%E5%A4%87"><span class="nav-text">4、打开tty设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E9%80%9A%E8%BF%87tty%E8%AE%BE%E5%A4%87%E5%86%99%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE"><span class="nav-text">5、通过tty设备写显示数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">16.3 文件系统初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#16-4-%E4%B8%BA%E8%BF%9B%E7%A8%8B%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E8%A1%A8"><span class="nav-text">16.4 为进程添加文件打开表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-4-%E6%89%93%E5%BC%80tty%E8%AE%BE%E5%A4%87%E5%B9%B6%E5%90%91%E5%85%B6%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-text">16.4 打开tty设备并向其写入数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-5-%E4%BB%8Etty%E8%AF%BB%E5%8F%96%E9%94%AE%E5%80%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B6%E6%98%BE%E7%A4%BA"><span class="nav-text">16.5 从tty读取键值字符串并显示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%90%91%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%99%E5%85%A5%EF%BC%8C%E5%B9%B6%E9%80%9A%E7%9F%A5%E7%A1%AC%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%B7%B2%E5%88%B0%E8%BE%BE"><span class="nav-text">1、向缓冲区写入，并通知硬件数据已到达</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BB%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-text">2、从缓冲区读取数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-6-%E6%89%93%E5%BC%80%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E5%8F%8A%E9%94%99%E8%AF%AF%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6"><span class="nav-text">16.6 打开标准输出及错误输出文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-7-%E5%85%81%E8%AE%B8%E5%88%87%E6%8D%A2tty%E7%AA%97%E5%8F%A3"><span class="nav-text">16.7 允许切换tty窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E9%80%9A%E8%BF%87%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%96%B9%E5%BC%8F%E5%88%87%E6%8D%A2"><span class="nav-text">1、通过快捷键方式切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%9C%A8first-task%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%968%E4%B8%AA%E7%AA%97%E5%8F%A3"><span class="nav-text">2、在first_task中初始化8个窗口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%83%E3%80%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-text">十七、实现一个命令行解释器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#17-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-text">17.1 初始化命令行解释器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81show-promot"><span class="nav-text">1、show_promot()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%9C%A8shell%E4%B8%AD%E6%8C%89%E4%B8%8B%E5%9B%9E%E9%80%80%E9%94%AE%EF%BC%8C%E5%9B%9E%E9%80%80%E9%94%AE%E4%B9%9F%E4%BC%9A%E8%A2%AB%E5%86%99%E5%85%A5"><span class="nav-text">2、在shell中按下回退键，回退键也会被写入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-2-%E8%BF%9B%E7%A8%8B%E4%B8%BB%E5%8A%A8%E9%80%80%E5%87%BAexit"><span class="nav-text">17.2 进程主动退出exit()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%AD%A5%E9%AA%A4%E4%B8%80"><span class="nav-text">1、步骤一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%AD%A5%E9%AA%A4%E4%BA%8C"><span class="nav-text">2、步骤二</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%B8%A4%E4%B8%AA%E6%AD%A5%E9%AA%A4%E5%AF%B9%E6%AF%94"><span class="nav-text">3、两个步骤对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-3-%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85wait"><span class="nav-text">17.3 进程等待wait()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E9%81%8D%E5%8E%86%E4%BB%BB%E5%8A%A1%E8%A1%A8%EF%BC%8C%E5%AF%BB%E6%89%BE%E5%83%B5%E5%B0%B8%E7%8A%B6%E6%80%81%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-text">1、遍历任务表，寻找僵尸状态的子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%9B%9E%E6%94%B6%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-text">2、回收僵尸进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%AD%89%E5%BE%85%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA"><span class="nav-text">3、等待子进程退出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4%E6%80%BB%E7%BB%93"><span class="nav-text">4、关键步骤总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-4-%E8%AE%A9%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%BB%A7%E6%89%BF%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%B7%B2%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-text">17.4 让子进程继承父进程已打开的文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E9%97%AE%E9%A2%98"><span class="nav-text">1、问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-text">2、解决方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E5%85%AB%E3%80%81%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87"><span class="nav-text">十八、使用文件系统管理硬件设备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#18-1-%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">18.1 描述一个文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E9%97%AE%E9%A2%981%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E8%B7%AF%E5%BE%84%E5%8C%BA%E5%88%86%E4%B8%8D%E5%90%8C%E7%9A%84%E8%AE%BE%E5%A4%87"><span class="nav-text">1、问题1：如何通过路径区分不同的设备</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-2-%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">18.2 挂载设备文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%8C%82%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="nav-text">1、挂载原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%85%B7%E4%BD%93%E6%8C%82%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="nav-text">2、具体挂载流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-3-%E6%89%93%E5%BC%80dev-tty0%E8%AE%BE%E5%A4%87"><span class="nav-text">18.3 打开dev&#x2F;tty0设备</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B9%9D%E3%80%81%E7%A3%81%E7%9B%98%E4%B8%8Efat16%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">十九、磁盘与fat16文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#19-1-%E7%A3%81%E7%9B%98%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%E7%AE%80%E4%BB%8B"><span class="nav-text">19.1 磁盘基本特性简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81MBR%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">1、MBR是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%A3%81%E7%9B%98%E7%9A%84%E5%88%86%E5%8C%BA%E5%92%8C%E6%89%87%E5%8C%BA%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-text">2、磁盘的分区和扇区有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84%E5%92%8C%E5%88%86%E5%8C%BA%E7%BB%93%E6%9E%84"><span class="nav-text">3、初始化磁盘结构和分区结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-2-%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B7%B2%E6%9C%89%E7%9A%84%E7%A3%81%E7%9B%98"><span class="nav-text">19.2 识别系统中已有的磁盘</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E5%9D%97%E7%A1%AC%E7%9B%98"><span class="nav-text">1、系统中有多少块硬盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%A3%81%E7%9B%98%E6%A3%80%E6%B5%8B"><span class="nav-text">2、磁盘检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E7%BB%86%E8%8A%82"><span class="nav-text">3、代码细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E7%BB%93%E6%9E%9C"><span class="nav-text">4、结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-3-%E8%A7%A3%E6%9E%90%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="nav-text">19.3 解析磁盘分区表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-4-%E5%A2%9E%E5%8A%A0%E7%A3%81%E7%9B%98%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="nav-text">19.4 增加磁盘设备管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-5-%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E7%9A%84%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5"><span class="nav-text">19.5 实现磁盘的读取和写入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-6-FAT16%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">19.6 FAT16文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81FAT16"><span class="nav-text">1、FAT16</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81FAT%E8%A1%A8%E9%A1%B9%E9%85%8D%E7%BD%AE"><span class="nav-text">2、FAT表项配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-7-%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E5%91%BD%E4%BB%A4ls"><span class="nav-text">19.7 遍历目录命令ls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-8-%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4less"><span class="nav-text">19.8 文件查看命令less</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="midorii"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">midorii</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">midorii</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">287k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:23</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
