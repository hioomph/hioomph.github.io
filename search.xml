<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>手撕算法</title>
    <url>/2024/04/13/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>合并K个有序数组</p>
<p>TOPK问题</p>
<p>逆波兰表达式</p>
<p>动态规划</p>
<p>快排最坏情况的比较次数，归并排序呢？</p>
<p>自定义实现strcpy函数</p>
<span id="more"></span>

<h3 id="1、字符串分割函数"><a href="#1、字符串分割函数" class="headerlink" title="1、字符串分割函数"></a>1、字符串分割函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//字符串分割函数</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">split</span><span class="params">(std::string str, std::string pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string::size_type pos;</span><br><span class="line">    std::vector&lt;std::string&gt; result;</span><br><span class="line">    str += pattern;<span class="comment">//扩展字符串以方便操作</span></span><br><span class="line">    <span class="type">int</span> size = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = str.<span class="built_in">find</span>(pattern, i);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; size)</span><br><span class="line">        &#123;</span><br><span class="line">            std::string s = str.<span class="built_in">substr</span>(i, pos - i);</span><br><span class="line">            result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            i = pos + pattern.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、string转int"><a href="#2、string转int" class="headerlink" title="2、string转int"></a>2、string转int</h3><p>1、使用atoi转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure>

<p>2、 使用std::stoi</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;-10&quot;</span>;</span><br><span class="line">std::<span class="built_in">stoi</span>(str);</span><br><span class="line"><span class="comment">// stoi()函数没有数字的话，程序虽然可以编译，但运行时会出错</span></span><br></pre></td></tr></table></figure>

<p>3、 通过 istringstream 转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;668&quot;</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function">std::istringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">ss &gt;&gt; num;</span><br></pre></td></tr></table></figure>

<p>使用 istringstream 可以从字符流中读取整数，与 ostringstream 是一种相反的操作</p>
<p>4、使用 sscanf</p>
<p>sscanf 函数是 C 语言标准库中的函数，可以用于从一个格式化的字符串中提取数据。在 C++ 中，可以使用 sscanf 函数将字符串转换为整数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">sscanf</span>(str.<span class="built_in">c_str</span>(), <span class="string">&quot;%d&quot;</span>, &amp;num) == <span class="number">1</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted number: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to convert the string to an integer.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、int转为string"><a href="#3、int转为string" class="headerlink" title="3、int转为string"></a>3、int转为string</h3><p>1、通过 std::to_string() 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">to_string</span>(num)</span><br></pre></td></tr></table></figure>

<p>这种方式在 C++11 中才能使用，编译时记得加上 –std&#x3D;c++11 的选项</p>
<p>2、通过 ostringstream</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">std::ostringstream ss;</span><br><span class="line">ss &lt;&lt; num;</span><br><span class="line">std::cout &lt;&lt; ss.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure>

<p>这是一种通过字符流的方式将整数转换成字符串，这种方式在C++11之前也可以使用</p>
<p>3、通过 sprintf</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br></pre></td></tr></table></figure>

<p>这是一种C语言中的转换方式，sprintf 也可以换成更安全的 snprintf 函数，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;%d&quot;</span>, num);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>--暂不分类</category>
      </categories>
  </entry>
  <entry>
    <title>OpenPose原理及编译</title>
    <url>/2023/12/25/%E7%A7%91%E7%A0%94/OpenPose%E5%8E%9F%E7%90%86%E5%8F%8A%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h2 id="1-前提思考"><a href="#1-前提思考" class="headerlink" title="1 前提思考"></a>1 前提思考</h2><p>1、姿态估计中的关键任务是什么？</p>
<p>识别人体骨干躯干的关键点，并进行定位与拼接。</p>
<p>2、姿态估计中的难点是什么？</p>
<p><strong>（1）遮挡；（2）匹配。</strong></p>
<p>3、COCO数据集的关键点有几个，分别是？</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251524168.png" alt="COCO数据集关键点" style="zoom: 50%;" />

<p>数据集中是<code>17</code>个点，实际上训练时候还要加上<code>1</code>个脖子的点，共<code>18</code>个点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Joint index:</span></span><br><span class="line"><span class="comment"># &#123;0,  &quot;Nose&quot;&#125;</span></span><br><span class="line"><span class="comment"># &#123;1,  &quot;Neck&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;2,  &quot;RShoulder&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;3,  &quot;RElbow&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;4,  &quot;RWrist&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;5,  &quot;LShoulder&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;6,  &quot;LElbow&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;7,  &quot;LWrist&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;8,  &quot;RHip&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;9,  &quot;RKnee&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;10, &quot;RAnkle&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;11, &quot;LHip&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;12, &quot;LKnee&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;13, &quot;LAnkle&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;14, &quot;REye&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;15, &quot;LEye&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;16, &quot;REar&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;17, &quot;LEar&quot;&#125;,</span></span><br></pre></td></tr></table></figure>

<p>4、姿态估计方法分为几个大类？</p>
<p>（1）<code>Top-down</code>（自顶向下）：先检测所有的人，再对每个框的人进行姿态估计输出结果</p>
<p>优点：准确率高，点的回归率高；</p>
<p>缺点：算法性能依赖检测效果，复杂度较高，实时性比较差。</p>
<p>主要用于一些离线的项目，对实时性没要求。</p>
<p>（2）<code>bottom-up</code>（自底向上）：先检测所有关键点，再进行匹配连接</p>
<p>优点：计算量较小，可以达到实时性的效果；</p>
<p>缺点：精度较差，匹配策略比较复杂。</p>
<h2 id="2-论文解读"><a href="#2-论文解读" class="headerlink" title="2 论文解读"></a>2 论文解读</h2><p>论文地址：<a href="https://arxiv.org/pdf/1611.08050.pdf">https://arxiv.org/pdf/1611.08050.pdf</a></p>
<h3 id="1、网络框架"><a href="#1、网络框架" class="headerlink" title="1、网络框架"></a>1、网络框架</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251524273.png" alt="网络整体流程图">	<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251532476.jpg" alt="网络框架1"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251534898.png" alt="网络框架2"></p>
<p>其中的重点：</p>
<p>（1）关键点的<code>heatmap</code>标注生成，采用高斯热度图的方式；</p>
<p>（2）<code>PAF</code>：部分亲和域。这也是论文中的重点和难点；</p>
<p>（3）匹配策略：匈牙利匹配。</p>
<h3 id="2、数据制作"><a href="#2、数据制作" class="headerlink" title="2、数据制作"></a>2、数据制作</h3><p>采用的数据集为<code>COCO</code>数据集，其中人体骨骼点的标注信息为<code>[x, y, label]</code>。</p>
<p><code>label</code>取值为<code>0</code>、<code>1</code>、<code>2</code>，分别表示不存在、遮挡、正常，其中不存在的关键点是需要去除的。</p>
<p>（1）关键点高斯热力图实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">putGaussianMaps</span>(<span class="params">center, accumulate_confid_map, sigma, grid_y, grid_x, stride</span>):</span><br><span class="line"></span><br><span class="line">    start = stride / <span class="number">2.0</span> - <span class="number">0.5</span></span><br><span class="line">    y_range = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(grid_y))]</span><br><span class="line">    x_range = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(grid_x))]</span><br><span class="line">    xx, yy = np.meshgrid(x_range, y_range)      <span class="comment"># 构建棋盘</span></span><br><span class="line">    xx = xx * stride + start                    <span class="comment"># 每个点在原始图像上的位置</span></span><br><span class="line">    yy = yy * stride + start</span><br><span class="line">    d2 = (xx - center[<span class="number">0</span>]) ** <span class="number">2</span> + (yy - center[<span class="number">1</span>]) ** <span class="number">2</span>  <span class="comment"># 计算每个点和GT点的距离</span></span><br><span class="line">    exponent = d2 / <span class="number">2.0</span> / sigma / sigma                 <span class="comment"># 这里在做一个高斯计算</span></span><br><span class="line">    mask = exponent &lt;= <span class="number">4.6052</span>                           <span class="comment"># 将在这个阈值范围内的点用True记录</span></span><br><span class="line">    cofid_map = np.exp(-exponent)                       <span class="comment"># 这里做一个标准化</span></span><br><span class="line">    cofid_map = np.multiply(mask, cofid_map)            <span class="comment"># 取出对应关系为True的点</span></span><br><span class="line">    accumulate_confid_map += cofid_map                  <span class="comment"># 将每个点计算的结果都累加到上一次的特征中</span></span><br><span class="line">    accumulate_confid_map[accumulate_confid_map &gt; <span class="number">1.0</span>] = <span class="number">1.0</span>      <span class="comment"># 对结果大于1的值，只取1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> accumulate_confid_map    <span class="comment"># 返回热力图（heatmap）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）PAF数据计算的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">putVecMaps</span>(<span class="params">centerA, centerB, accumulate_vec_map, count, grid_y, grid_x, stride</span>):</span><br><span class="line">    centerA = centerA.astype(<span class="built_in">float</span>)</span><br><span class="line">    centerB = centerB.astype(<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line">    thre = <span class="number">1</span>  <span class="comment"># 表示宽度，也就是一个设定好的参数</span></span><br><span class="line">    centerB = centerB / stride  <span class="comment"># 缩放比例特定到特征图中</span></span><br><span class="line">    centerA = centerA / stride</span><br><span class="line"></span><br><span class="line">    limb_vec = centerB - centerA  <span class="comment"># 求出两个点的向量</span></span><br><span class="line">    norm = np.linalg.norm(limb_vec)  <span class="comment"># 是需要求单位向量，所以先计算范数，也就是向量模长</span></span><br><span class="line">    <span class="keyword">if</span> (norm == <span class="number">0.0</span>):  <span class="comment"># 这里表示两个点基本重合了</span></span><br><span class="line">        <span class="comment"># print &#x27;limb is too short, ignore it...&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> accumulate_vec_map, count</span><br><span class="line">    limb_vec_unit = limb_vec / norm  <span class="comment"># 向量除以模长，得到单位向量</span></span><br><span class="line">    <span class="comment"># print &#x27;limb unit vector: &#123;&#125;&#x27;.format(limb_vec_unit)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># To make sure not beyond the border of this two points</span></span><br><span class="line">    <span class="comment"># 得到所有可能存在方向的区域(这里就用到了之前的超参数阈值)</span></span><br><span class="line">    min_x = <span class="built_in">max</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="built_in">min</span>(centerA[<span class="number">0</span>], centerB[<span class="number">0</span>]) - thre)), <span class="number">0</span>)</span><br><span class="line">    max_x = <span class="built_in">min</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="built_in">max</span>(centerA[<span class="number">0</span>], centerB[<span class="number">0</span>]) + thre)), grid_x)</span><br><span class="line">    min_y = <span class="built_in">max</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="built_in">min</span>(centerA[<span class="number">1</span>], centerB[<span class="number">1</span>]) - thre)), <span class="number">0</span>)</span><br><span class="line">    max_y = <span class="built_in">min</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="built_in">max</span>(centerA[<span class="number">1</span>], centerB[<span class="number">1</span>]) + thre)), grid_y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 得到一个可能存在向量的矩形框</span></span><br><span class="line">    range_x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">int</span>(min_x), <span class="built_in">int</span>(max_x), <span class="number">1</span>))</span><br><span class="line">    range_y = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">int</span>(min_y), <span class="built_in">int</span>(max_y), <span class="number">1</span>))</span><br><span class="line">    xx, yy = np.meshgrid(range_x, range_y)  <span class="comment"># 制作一个网格</span></span><br><span class="line">    ba_x = xx - centerA[<span class="number">0</span>]  <span class="comment"># the vector from (x,y) to centerA 根据位置判断是否在该区域上（分别得到X和Y方向的）</span></span><br><span class="line">    ba_y = yy - centerA[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 向量叉乘根据阈值选择赋值区域，任何向量与单位向量的叉乘即为四边形的面积</span></span><br><span class="line">    <span class="comment"># 这里是重点步骤，也就是论文中的公式，表示计算出两个向量组成四边形的面积</span></span><br><span class="line">    limb_width = np.<span class="built_in">abs</span>(ba_x * limb_vec_unit[<span class="number">1</span>] - ba_y * limb_vec_unit[<span class="number">0</span>])</span><br><span class="line">    mask = limb_width &lt; thre  <span class="comment"># mask is 2D （小于阈值的表示在该区域上）</span></span><br><span class="line"></span><br><span class="line">    vec_map = np.copy(accumulate_vec_map) * <span class="number">0.0</span>  <span class="comment"># 构建一个全为0的矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这行代码主要作用是将mask扩展一个维度并且赋值给vec_map数组</span></span><br><span class="line">    vec_map[yy, xx] = np.repeat(mask[:, :, np.newaxis], <span class="number">2</span>, axis=<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 在该区域上的都用对应的方向向量表示（根据mask结果表示是否在，通过乘法的方式）</span></span><br><span class="line">    vec_map[yy, xx] *= limb_vec_unit[np.newaxis, np.newaxis, :]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># #在特征图中（46*46）中 哪些区域是该躯干所在区域，判断x或者y向量都不为0</span></span><br><span class="line">    mask = np.logical_or.reduce(</span><br><span class="line">        (np.<span class="built_in">abs</span>(vec_map[:, :, <span class="number">0</span>]) &gt; <span class="number">0</span>, np.<span class="built_in">abs</span>(vec_map[:, :, <span class="number">1</span>]) &gt; <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每次返回的accumulate_vec_map都是平均值，现在还原成实际值</span></span><br><span class="line">    accumulate_vec_map = np.multiply(</span><br><span class="line">        accumulate_vec_map, count[:, :, np.newaxis])</span><br><span class="line">    accumulate_vec_map += vec_map  <span class="comment"># 加上当前关键点位置形成的向量</span></span><br><span class="line">    count[mask == <span class="literal">True</span>] += <span class="number">1</span>  <span class="comment"># 该区域计算次数都+1</span></span><br><span class="line"></span><br><span class="line">    mask = count == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    count[mask == <span class="literal">True</span>] = <span class="number">1</span>  <span class="comment"># 没有被计算过的地方就等于自身（因为一会要除法）</span></span><br><span class="line"></span><br><span class="line">    accumulate_vec_map = np.divide(accumulate_vec_map, count[:, :, np.newaxis])  <span class="comment"># 算平均向量</span></span><br><span class="line">    count[mask == <span class="literal">True</span>] = <span class="number">0</span>  <span class="comment"># 还原回去</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> accumulate_vec_map, count</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两个函数是最重要的两个部分，也就是对训练数据的处理，生成出需要的训练数据。</p>
<h3 id="3、预测推理"><a href="#3、预测推理" class="headerlink" title="3、预测推理"></a>3、预测推理</h3><p>预测模型这里，在官方源码中是将<code>paf</code>的处理封装在一个<code>cpp</code>库中，<strong>通过编译得到静态库，代码中可以调用</strong>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">swig -python -c++ pafprocess.i</span><br><span class="line">python3 setup.py build_ext --inplace</span><br></pre></td></tr></table></figure>

<p>这里PAF的处理主要是采用积分计算的方式，也就是对于连线的点的方向选择，采用积分的方式计算最佳连线策略。</p>
<h2 id="3-OpenPose-Windows-cpu-only-编译"><a href="#3-OpenPose-Windows-cpu-only-编译" class="headerlink" title="3 OpenPose_Windows_cpu_only 编译"></a>3 OpenPose_Windows_cpu_only 编译</h2><p>主要步骤参考：</p>
<p><a href="https://blog.csdn.net/qq_51209492/article/details/124185106?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%AE%89%E8%A3%85openpose%E5%B9%B6%E4%BD%BF%E7%94%A8python%E8%B0%83%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-124185106.142%5Ev96%5Epc_search_result_base7&spm=1018.2226.3001.4187">CSDN——win10环境下下载安装openpose(only cpu)并在pycharm中运行代码（超详细）</a></p>
<p>基本按照这上面来走就可以正确编译，但其中要注意以下几点：</p>
<p><strong>1、<code>bat</code>批处理命令运行时给的网站我根本无法访问，一直<code>retry</code></strong></p>
<p>最后选择用迅雷下载，然后放进<code>\openpose\3rdparty\windows</code>文件夹下。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312272200864.png" alt="image-20231227220003816"></p>
<p>同时这里面的<code>caffe_cpu</code>不是用这4个<code>bat</code>文件下载的，但是由于网址同样进不去，也选择先用迅雷下载好后放进去。</p>
<p>我这里的4个<code>zip</code>文件大小显示为<code>0kb</code>似乎是<code>cmake</code>编译后自己更改的，不用去管。</p>
<p><strong>2、用迅雷提前下载好<code>\openpose\models</code>后，<code>cmake</code>编译依然会重新下载模型。</strong></p>
<p>这里我参考了<a href="https://zhuanlan.zhihu.com/p/446981890">OpenPose-CPU版本安装</a>的方法：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312272207425.png" alt="image-20231227220706339"></p>
<p>修改<code>CmakeLists.txt</code>文件后就不会再重新下载模型了。</p>
<p><strong>3、用<code>CMAKE</code>编译<code>openpose</code>项目时，一定要在第一次<code>configure</code>之前，点击<code>Add Entry</code>选择<code>Python</code>版本。</strong></p>
<p>如下所示：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312272202637.png" alt="在这里插入图片描述"></p>
<p>实际上这一步就是要确保在<code>cmake</code>编译时访问的<code>python</code>解释器和最后在<code>pycharm</code>中运行时选择的python解释器一致，否则可能会在<code>pycharm</code>中报错<code>No module named pyopenpose</code>。</p>
<p>我第一次在这里就是因为没有关注这个细节，导致<code>cmake</code>选择的是<code>python 3.6.5</code>的编译器，而<code>pycharm</code>选择的是<code>3.7.6</code>的编译器，出现错误。</p>
<p><strong>4、最好采用本地<code>python</code>解释器，不要用<code>anaconda</code>虚拟环境。</strong></p>
<p>我也不知道为什么虚拟环境会报错，可能还是路径的问题吧。</p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基础相关</title>
    <url>/2024/04/17/Computer/Base/Linux%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="1、GCC安装"><a href="#1、GCC安装" class="headerlink" title="1、GCC安装"></a>1、GCC安装</h1><h2 id="（1）GCC相关知识点"><a href="#（1）GCC相关知识点" class="headerlink" title="（1）GCC相关知识点"></a>（1）GCC相关知识点</h2><p>GCC（GNU Compiler Collection， GNU编译器套件）是由GNU开发的编程语言译器。</p>
<p>gcc和g++都是GNU（组织）的一个编译器</p>
<ul>
<li>误区一：gcc只能编译C程序，g++只能编译C++代码：<ul>
<li>后缀为.c时，gcc认为其是C程序，g++认为其是C++程序；</li>
<li>后缀为.cpp时，gcc和g++均认为其是C++程序。</li>
</ul>
</li>
<li>误区二：编译只能用gcc，链接只能用g++：<ul>
<li>严格来说不算错误，但混淆了概念，应该说：编译可以用gcc&#x2F;g++，而链接可以用g++或者gcc -lstdc++;</li>
<li>gcc命令不能自动和C++程序使用的库链接，所以通常使用g++来完成链接。但在编译阶段，g++会自动调用gcc，二者等价。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171012036.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171012580.png" alt="2"></p>
<h2 id="（2）GCC工作流程"><a href="#（2）GCC工作流程" class="headerlink" title="（2）GCC工作流程"></a>（2）GCC工作流程</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013866.png" alt="3"></p>
<ul>
<li><p>预处理：对头文件展开\删除代码中的注释\宏替换</p>
</li>
<li><p><strong>程序编译成可执行程序的过程：</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013529.png" alt="4"></p>
</li>
</ul>
<h1 id="2、静态库和动态库"><a href="#2、静态库和动态库" class="headerlink" title="2、静态库和动态库"></a>2、静态库和动态库</h1><h2 id="（1）静态库"><a href="#（1）静态库" class="headerlink" title="（1）静态库"></a>（1）静态库</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013337.png" alt="5"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013840.png" alt="6"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@iisayhi:~/lesson/library<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">├── add.c</span><br><span class="line">├── div.c</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br><span class="line">root@iisayhi:~/lesson/library<span class="comment"># gcc main.c -o app -I ./include/ -l calc -L ./lib/</span></span><br><span class="line">root@iisayhi:~/lesson/library<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── app</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">		├── add.c</span><br><span class="line">		├── div.c</span><br><span class="line">		├── mult.c</span><br><span class="line">		└── sub.c</span><br></pre></td></tr></table></figure>

<h2 id="（2）动态库"><a href="#（2）动态库" class="headerlink" title="（2）动态库"></a>（2）动态库</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013622.png" alt="7"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013961.png" alt="8"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013076.png" alt="9"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/calc# **gcc -c -fpic add.c mult.c sub.c div.c** </span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# ls</span><br><span class="line">add.c  add.o  div.c  div.o  head.h  main.c  mult.c  mult.o  sub.c  sub.o</span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# **gcc -shared *.o -o libcalc.so**</span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# ll</span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x 2 root root  4096 Apr  6 22:49 ./</span><br><span class="line">drwxr-xr-x 4 root root  4096 Apr  6 22:47 ../</span><br><span class="line">-rw-r--r-- 1 root root    80 Apr  6 22:47 add.c</span><br><span class="line">-rw-r--r-- 1 root root  1376 Apr  6 22:48 add.o</span><br><span class="line">-rw-r--r-- 1 root root    94 Apr  6 22:47 div.c</span><br><span class="line">-rw-r--r-- 1 root root  1384 Apr  6 22:48 div.o</span><br><span class="line">-rw-r--r-- 1 root root   189 Apr  6 22:47 head.h</span><br><span class="line">-rwxr-xr-x 1 root root 15824 Apr  6 22:49 libcalc.so*</span><br><span class="line">-rw-r--r-- 1 root root   306 Apr  6 22:47 main.c</span><br><span class="line">-rw-r--r-- 1 root root    85 Apr  6 22:47 mult.c</span><br><span class="line">-rw-r--r-- 1 root root  1384 Apr  6 22:48 mult.o</span><br><span class="line">-rw-r--r-- 1 root root    85 Apr  6 22:47 sub.c</span><br><span class="line">-rw-r--r-- 1 root root  1376 Apr  6 22:48 sub.o</span><br></pre></td></tr></table></figure>

<ul>
<li>运行main可执行文件报错：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># gcc main.c -o main -I include/ -L lib/ -l calc</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ls</span></span><br><span class="line">include  lib  main  main.c  src</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">**./main: error <span class="keyword">while</span> loading shared libraries: [libcalc.so](&lt;http://libcalc.so/&gt;): cannot open shared object file: No such file or directory**</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffda29fd000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; not found</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbe8fa25000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007fbe8fc31000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>原因即是由于动态库是在程序启动后才被加载到内存中，而我们自己写的动态库libcalc.so并没有给出对应的路径去查找它，所以会报错。</p>
<p>解决方法：</p>
<blockquote>
<p>对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的 <strong>DT_RPATH段</strong> ——&gt; <strong>环境变量LD_LIBRARY_PATH</strong> ——&gt; <strong>&#x2F;etc&#x2F;ld.so.cache</strong>文件列表 ——&gt; <strong>&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib</strong>目录找到库文件后将其载入内存</p>
</blockquote>
<p><strong>1）DT_RPATH段 无法修改，系统本身固定值</strong></p>
<p><strong>2）环境变量LD_LIBRARY_PATH</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># echo $LD_LIBRARY_PATH </span></span><br><span class="line">:/root/lesson/lesson01/library/lib</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffff57e5000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; /root/lesson/lesson01/library/lib/libcalc.so (0x00007f06515af000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f06513aa000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f06515bb000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">a = 20, b = 12</span><br><span class="line">a + b = 32</span><br><span class="line">a - b = 8</span><br><span class="line">a * b = 240</span><br><span class="line">a / b = 1.666667</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>直接在终端中配置，当终端被关闭后该环境变量就会消失了，属于临时性配置。</p>
<p>永久性配置：</p>
<ul>
<li><p>用户级别</p>
<ul>
<li><p>根目录下，<code>vim .bashrc</code></p>
</li>
<li><p>在最后一行加上要添加的路径</p>
<p><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</code></p>
</li>
<li><p><code>source ~/.bashrc</code></p>
</li>
</ul>
</li>
<li><p>系统级别</p>
<ul>
<li><p><code>sudo vim /etc/profile</code></p>
</li>
<li><p>在最后一行加上要添加的路径</p>
<p><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</code></p>
</li>
<li><p><code>source /etc/profile</code></p>
</li>
</ul>
</li>
</ul>
<p><strong>3）&#x2F;etc&#x2F;ld.so.cache文件列表</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@iisayhi:~/lesson<span class="comment"># ll /etc/ld.so.cache</span></span><br><span class="line">-rw-r--r-- 1 root root 74025 Jan 12 21:15 /etc/ld.so.cache</span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># **sudo vim /etc/ld.so.conf**</span></span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># **sudo ldconfig**</span></span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># cd lesson01/library/</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffd633f6000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; /root/lesson/lesson01/library/lib/libcalc.so (0x00007f7b8a4e1000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7b8a2ef000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f7b8a500000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">a = 20, b = 12</span><br><span class="line">a + b = 32</span><br><span class="line">a - b = 8</span><br><span class="line">a * b = 240</span><br><span class="line">a / b = 1.666667</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p><code>/etc/ld.so.cache</code>是一个二进制文件，无法直接用vim进行修改；</p>
<p>因此要借助<code>/etc/ld.so.conf</code>的帮助：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014770.png" alt="10"></p>
<p><strong>4）&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib目录</strong></p>
<p>不推荐使用，因为在上述目录下已经包含很多系统自带的库文件，因此可能存在重名导致被替换的问题存在。</p>
<h2 id="（3）静态库和动态库的对比"><a href="#（3）静态库和动态库的对比" class="headerlink" title="（3）静态库和动态库的对比"></a>（3）静态库和动态库的对比</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014481.png" alt="11"></p>
<ul>
<li>消耗系统资源、浪费内存：<ul>
<li>每个程序在运行时都会将静态库复制一份到内存中，多个程序同时运行时浪费内存；</li>
</ul>
</li>
<li>更新、部署、发布麻烦：<ul>
<li>每次更新、部署或发布时都需要重新编译</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014264.png" alt="12"></p>
<h1 id="3、Makefile"><a href="#3、Makefile" class="headerlink" title="3、Makefile"></a>3、Makefile</h1><ul>
<li>定义<ul>
<li>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 <code>Makefile 文件就像一个 Shell 脚本一样，也可以执行操作系统的命令</code>。</li>
<li><strong>Makefile 带来的好处就是“自动化编译”</strong> ，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如 Delphi 的 <code>make</code>，Visual C++ 的 <code>nmake</code>，Linux 下 GNU 的 <code>make</code>。</li>
</ul>
</li>
<li>命名规则</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014308.png" alt="13"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014605.png" alt="14"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014917.png" alt="15"></p>
<ul>
<li>工作原理</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015389.png" alt="16"></p>
<ul>
<li>变量</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015553.png" alt="17"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171018439.png" alt="Untitled"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019513.png" alt="Untitled"></p>
<p><strong>对原始写法进行简写：</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015837.png" alt="20"></p>
<p>改进1：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171018316.png" alt="Untitled"></p>
<p>改进2：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015549.png" alt="22"></p>
<p>改进3：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015818.png" alt="23"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.PHONY:clean  # 定义clean为伪目标</span><br></pre></td></tr></table></figure>

<p>改进4：<code>Makefile</code>中写了<code>clean</code>之后，在命令行要用<code>make clean</code>来调用</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019153.png" alt="24"></p>
<h1 id="4、GDB调试"><a href="#4、GDB调试" class="headerlink" title="4、GDB调试"></a>4、GDB调试</h1><!--more-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">man gdb</span><br></pre></td></tr></table></figure>

<p>要进入gdb调试模式需要加上-g参数，<code>gcc -g filename</code></p>
<blockquote>
<p>gdb基本命令</p>
</blockquote>
<p><code>list</code> 查看当前源代码</p>
<p><code>run</code> 运行程序</p>
<p><code>break(b)</code> 打断点，有两种打断点方式：</p>
<ol>
<li><code>break function</code></li>
<li><code>break 可执行文件:行号</code></li>
</ol>
<p><code>info b</code> 查看已经打的断点</p>
<p><code>next(n)</code> 执行下一步</p>
<p><code>step(s)</code> 执行函数内部</p>
<p><code>print(p)</code> 打印当前变量内容</p>
<blockquote>
<p>gdb小技巧</p>
</blockquote>
<ol>
<li>gdb中可以通过<code>shell</code>调取终端命令，如：</li>
</ol>
<ul>
<li>shell ls</li>
<li>shell cat filename</li>
</ul>
<ol>
<li>设置日志功能，<code>set logging on</code></li>
<li>断点的相关设置：</li>
</ol>
<ul>
<li>breakpoints</li>
<li>watchpoints：观察变量是否变化</li>
<li>catchpoints</li>
</ul>
<blockquote>
<p>调试core文件</p>
</blockquote>
<p>系统不会默认生成core文件，需要进行手动设置</p>
<p>man ulimit</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404170953727.png" alt="1"></p>
<p>注意其中一行：<code>open file 65535</code>，能打开的最大文件数是65535</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulimit -c unlimited</span><br></pre></td></tr></table></figure>

<p>这样设置之后，运行可执行文件后出现(core dump)即为生成了对应的core文件。若仍为生成core文件，调用命令：<code>echo &quot;core&quot; &gt; /proc/sys/kernel/core_pattern</code></p>
<p>此时的gdb调试命令为：<code>gdb 可执行文件名（二进制文件） 可执行文件生成的core文件名</code></p>
<blockquote>
<p>调试正在运行的文件</p>
</blockquote>
<p>后台运行一个程序并返回其pid号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./a.out &amp;</span><br><span class="line">[1] 96929</span><br></pre></td></tr></table></figure>

<p>gdb调试该后台程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb -p 96929</span><br><span class="line">root@iisayhi:~/Documents/useless# vim test_for.c </span><br><span class="line">root@iisayhi:~/Documents/useless# **gcc test_for.c -g**</span><br><span class="line">root@iisayhi:~/Documents/useless# **./a.out &amp;**</span><br><span class="line">**[1] 96929**</span><br><span class="line">root@iisayhi:~/Documents/useless# **gdb -p 96929**</span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br><span class="line">Attaching to process 96929</span><br><span class="line">Reading symbols from /root/Documents/useless/a.out...</span><br><span class="line">Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...</span><br><span class="line">Reading symbols from /usr/lib/debug/.build-id/ee/be5d5f4b608b8a53ec446b63981bba373ca0ca.debug...</span><br><span class="line">Reading symbols from /lib64/ld-linux-x86-64.so.2...</span><br><span class="line">Reading symbols from /usr/lib/debug/.build-id/7a/e2aaae1a0e5b262df913ee0885582d2e327982.debug...</span><br><span class="line">test1 () at test_for.c:14</span><br><span class="line">14	&#125;</span><br><span class="line">(gdb) n</span><br><span class="line">main () at test_for.c:18</span><br><span class="line">18			test();</span><br><span class="line">(gdb) n</span><br><span class="line">19			test1();</span><br><span class="line">(gdb) s</span><br><span class="line">test1 () at test_for.c:11</span><br><span class="line">11	void test1() &#123;</span><br><span class="line">(gdb) n</span><br><span class="line">12		int i = 0;</span><br><span class="line">(gdb) n</span><br><span class="line">13		i++;</span><br><span class="line">(gdb) p i</span><br><span class="line">$1 = 0</span><br><span class="line">(gdb) n</span><br><span class="line">14	&#125;</span><br><span class="line">(gdb) p i</span><br><span class="line">$2 = 1</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// test test1</span><br><span class="line">// i i++</span><br><span class="line">// call test test1</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test1() &#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	for(;;) &#123;</span><br><span class="line">		test();</span><br><span class="line">		test1();</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5、文件I-O"><a href="#5、文件I-O" class="headerlink" title="5、文件I&#x2F;O"></a>5、文件I&#x2F;O</h1><h2 id="（1）标准C库IO函数"><a href="#（1）标准C库IO函数" class="headerlink" title="（1）标准C库IO函数"></a>（1）标准C库IO函数</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019600.png" alt="25"></p>
<p>标准C库IO函数可以跨平台（win\linux等）。</p>
<p><strong>在不同平台上调用不同的系统API，从而实现跨平台。</strong></p>
<p>写数据时首先有一个缓冲区，内容首先写到缓冲区（内存，默认<em><strong>8k</strong></em>）中，当<strong>缓冲区内容满后&#x2F;强行刷新缓冲区&#x2F;正常关闭文件后</strong>，再将当前缓冲区的内容传递到磁盘中。</p>
<ul>
<li>标准C库IO和Linux系统IO的关系：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019149.png" alt="26"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020236.png" alt="27"></p>
<h2 id="（2）虚拟地址空间"><a href="#（2）虚拟地址空间" class="headerlink" title="（2）虚拟地址空间"></a>（2）虚拟地址空间</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020344.png" alt="28"></p>
<p>虚拟地址空间会通过MMU映射到真实物理空间上。</p>
<p>NULL\NULL pointer — 受保护的地址</p>
<p>new\malloc              — 堆空间</p>
<p>局部变量                  — 栈空间</p>
<h2 id="（3）文件描述符"><a href="#（3）文件描述符" class="headerlink" title="（3）文件描述符"></a>（3）文件描述符</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020768.png" alt="29"></p>
<ul>
<li><p>程序和进程间的区别</p>
<ul>
<li>程序（test.c)\可执行程序(test) — 不占用内存空间，只占用磁盘空间，是伪文件；</li>
<li>进程 — 运行一个程序时，操作系统创建一个进程为其分配资源，会占用内存空间。</li>
</ul>
</li>
<li><pre><code>PCB进程控制块
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">是一个复杂的结构体，位于Linux kernel的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
内存管理
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  。中封装了各类信息，如文件描述符表</span><br><span class="line"></span><br><span class="line">  - 文件描述符表，是一个数组</span><br><span class="line"></span><br><span class="line">    ，存储多个文件描述符 — 使得一个进程可以打开多个文件（产生多个文件描述符）</span><br><span class="line"></span><br><span class="line">    - 默认的大小是**1024（默认能打开的文件数）；**</span><br><span class="line">    - 数组前3位被默认占用，为**标准输入、标准输出、标准错误，且默认是打开状态**（此三个文件描述符和**当前终端**绑定，联系linux系统一切皆文件的思想来理解）；</span><br><span class="line">    - 占用文件描述符时内核会自动寻找最小的没有被占用的文件描述符来使用。</span><br><span class="line"></span><br><span class="line">## （4）Linux系统IO函数</span><br><span class="line"></span><br><span class="line">![30](https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020793.png)</span><br><span class="line"></span><br><span class="line">1）open函数</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">// 打开一个已经存在的文件</span><br><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">    参数：</span><br><span class="line">        - pathname  要打开的文件路径</span><br><span class="line">        - flags     对文件的操作权限设置还有其他的设置</span><br><span class="line">                    O_RDONLY, O_WRONLY, or O_RDWR 这三个操作互斥</span><br><span class="line">    返回值：</span><br><span class="line">        返回一个新的文件描述符；若失败则返回-1</span><br><span class="line"></span><br><span class="line">errno：属于Linux系统函数库里面的一个全局变量，记录的是最近的错误号</span><br><span class="line">    #include &lt;stdio.h&gt;</span><br><span class="line">    void perror(const char *s);</span><br><span class="line">        作用：打印errno对应的错误描述</span><br><span class="line">        参数：</span><br><span class="line">            - s     用户描述</span><br><span class="line">// 创建一个新的文件</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line">    参数：</span><br><span class="line">        - pathname  要打开的文件路径</span><br><span class="line"></span><br><span class="line">        - flags     对文件的操作权限设置还有其他的设置</span><br><span class="line">                    - 必选项：O_RDONLY, O_WRONLY, O_RDWR 这三个操作互斥</span><br><span class="line">                    - 可选项：O_CREAT 文件不存在，创建新文件</span><br><span class="line">                    flags参数是一个int类型的数据，占4个字节，32位</span><br><span class="line">                    flags32位，每一位就是一个标志位</span><br><span class="line"></span><br><span class="line">        - mode      八进制数，表述用户对创建出的新的文件的操作权限</span><br><span class="line">                    - 0777</span><br><span class="line">                        0：     0开头，八进制数</span><br><span class="line">                        777：   并非就是777，涉及到掩码，最终的权限是 mode &amp; ~umask</span><br><span class="line">                                    umask = 0022  ~umask = 0755</span><br><span class="line">                                        0777 -&gt; 111111111</span><br><span class="line">                                    &amp;   0755 -&gt; 111101101</span><br><span class="line">                                        0755 -&gt; 111101101</span><br><span class="line">                    umask的作用就是抹去某些权限</span><br><span class="line"></span><br><span class="line">                                </span><br><span class="line">    返回值：</span><br><span class="line">    返回一个新的文件描述符；若失败则返回-1</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code>flags
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">和</span><br><span class="line"></span><br></pre></td></tr></table></figure>
mode_t
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  的区别：</span><br><span class="line"></span><br><span class="line">  - `flags`是程序在运行时，能以什么权限对文件进行操作；</span><br><span class="line">  - `mode_t`是指这个文件本身的权限。</span><br><span class="line"></span><br><span class="line">- 关于rwx权限：</span><br><span class="line"></span><br><span class="line">  - r   - 读，对文件而言，具有读取文件内容的权限；对目录来说，具有浏览该目录信息的权限</span><br><span class="line"></span><br><span class="line">  - w  - 写，对文件而言，具有修改文件内容的权限；对目录来说具有删除移动目录内文件的权限</span><br><span class="line"></span><br><span class="line">  - x   - 可执行，对文件而言，具有执行文件的权限；对目录来说，具有进入目录的权限</span><br><span class="line"></span><br><span class="line">    | 第一位  | 用户   | 组用户 | 其他用户 |</span><br><span class="line">    | ------- | ------ | ------ | -------- |</span><br><span class="line">    | -  文件 | d 目录 | rwx    | r-x      |</span><br><span class="line"></span><br><span class="line">2）read &amp; write函数</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">        参数：</span><br><span class="line">            - fd        文件描述符，open得到</span><br><span class="line">            - *buf      缓冲区，读取数据存放的地方，数组的地址</span><br><span class="line">            - count     指定的数组的大小</span><br><span class="line">        返回值</span><br><span class="line">            - 成功：</span><br><span class="line">                &gt;0      返回实际读取到的字节数</span><br><span class="line">                =0      文件已经读取完毕</span><br><span class="line">            - 失败</span><br><span class="line">                -1      并设置errno</span><br><span class="line"></span><br><span class="line">ssize_t  write(int  fd,  const void *buf, size_t count);</span><br><span class="line">        参数：</span><br><span class="line">		        - fd        文件描述符，open得到</span><br><span class="line">		        - *buf      要往磁盘写入的数据，数据</span><br><span class="line">		        - count     实际写入数据大小</span><br><span class="line">        返回值</span><br><span class="line">            - 成功：</span><br><span class="line">                &gt;0      返回实际读取到的字节数</span><br><span class="line">                =0      无任何数据写到文件中</span><br><span class="line">            - 失败</span><br><span class="line">                -1      并设置errno</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>对于write函数来说，如果count的大小（实际写入数据的大小）大于缓冲区实际大小时，那么会把缓冲区后面的内存中的数据写进去，只不过这些数据我们是不确定的，是野内存，操作野内存有可能会产生问题，所以一般不会这么去做。缓冲区中有多少数据，我们就写多少数据即可。</p>
</li>
</ul>
<p>3）lseek函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">标准C库：</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"></span><br><span class="line">Linux系统函数：</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line">    <span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line">        对文件指针进行操作</span><br><span class="line">        参数：</span><br><span class="line">            - fd        文件描述符</span><br><span class="line">            - offset    偏移量  </span><br><span class="line">            - whence    </span><br><span class="line">                SEEK_SET</span><br><span class="line">                    设置文件指针的偏移量</span><br><span class="line"></span><br><span class="line">                SEEK_CUR</span><br><span class="line">                    设置偏移量：当前位置 + 第二个参数offset的值</span><br><span class="line"></span><br><span class="line">                SEEK_END</span><br><span class="line">                    设置偏移量：文件大小 + 第二个参数offset的值</span><br><span class="line">        返回值：返回文件指针的位置</span><br><span class="line">        作用：</span><br><span class="line">            <span class="number">1</span>、移动文件指针到头文件</span><br><span class="line">                lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">            <span class="number">2</span>、获取当前文件指针的位置</span><br><span class="line">                lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line">            <span class="number">3</span>、获取文件长度</span><br><span class="line">                lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">            <span class="number">4</span>、拓展文件长度 ex. <span class="number">10b</span> =&gt; <span class="number">110b</span></span><br><span class="line">                lseek(fd, <span class="number">100</span>, SEEK_END);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>利用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lseek</span><br></pre></td></tr></table></figure>

<p>函数拓展文件长度时需要写入一次数据才能起作用：</p>
<ul>
<li>拓展时，<code>lseek</code>只是逻辑上移动文件指针的位置，并没有为文件分配存储空间，为了让这些空间实际得到分配，可以使用<code>write</code>在最后补充一个字符，这样拓展的存储空间应该就分配了。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓展文件长度</span></span><br><span class="line">    <span class="type">int</span> ret = lseek(fd, <span class="number">100</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入空数据，被写入到第112b的位置上</span></span><br><span class="line">    <span class="comment">// 不执行这一步之前一般ll是看不到hello.txt的文件大小变化的</span></span><br><span class="line">    <span class="comment">// hello.txt : 11b ==&gt; 112b</span></span><br><span class="line">    write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br></pre></td></tr></table></figure>

<p>4）stat\lstat函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line">    作用：获取一个文件相关的一些信息</span><br><span class="line">    参数:</span><br><span class="line">        - pathname：    操作的文件的路径</span><br><span class="line">        - statbuf：     结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="line">    返回值：</span><br><span class="line">        成功：返回<span class="number">0</span></span><br><span class="line">        失败：返回<span class="number">-1</span> 设置errno</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line">    参数:</span><br><span class="line">        - pathname：    操作的文件的路径</span><br><span class="line">        - statbuf：     结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="line">    返回值：</span><br><span class="line">        成功：返回<span class="number">0</span></span><br><span class="line">        失败：返回<span class="number">-1</span> 设置errno</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020543.png" alt="31"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020502.png" alt="32"></p>
<p>5）文件属性操作函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>;</span><br><span class="line">    作用：判断某个文件是否有某个权限，或者判断文件是否存在</span><br><span class="line">    参数：</span><br><span class="line">        - pathname: 判断的文件路径</span><br><span class="line">        - mode:</span><br><span class="line">            R_OK: 判断是否有读权限</span><br><span class="line">            W_OK: 判断是否有写权限</span><br><span class="line">            X_OK: 判断是否有执行权限</span><br><span class="line">            F_OK: 判断文件是否存在</span><br><span class="line">    返回值：成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">    修改文件的权限</span><br><span class="line">    参数：</span><br><span class="line">        - pathname: 需要修改的文件的路径</span><br><span class="line">        - mode:需要修改的权限值，八进制的数</span><br><span class="line">    返回值：成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line">    作用：缩减或者扩展文件的尺寸至指定的大小</span><br><span class="line">    参数：</span><br><span class="line">        - path: 需要修改的文件的路径</span><br><span class="line">        - length: 需要最终文件变成的大小</span><br><span class="line">    返回值：</span><br><span class="line">        成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前用户id和组id：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vim /etc/passwd <span class="comment">// 用户</span></span><br><span class="line">vim /etc/group   <span class="comment">// 组</span></span><br></pre></td></tr></table></figure>

<p>6）目录操作函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">    作用：创建一个目录</span><br><span class="line">    参数：</span><br><span class="line">        pathname: 创建的目录的路径</span><br><span class="line">        mode: 权限，八进制的数</span><br><span class="line">    返回值：</span><br><span class="line">        成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"><span class="type">int</span> ret = mkdir(<span class="string">&quot;aaa&quot;</span>, <span class="number">0777</span>);</span><br><span class="line"><span class="comment">// 最终的权限结果是 mode &amp; ~umask &amp; 0777</span></span><br><span class="line"><span class="comment">// 给的是0777 ==&gt; 最终得到 drwxr-xr-x</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line">    作用：修改进程的工作目录</span><br><span class="line">        比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder</span><br><span class="line">    参数：</span><br><span class="line">        path : 需要修改的工作目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br><span class="line">    作用：获取当前工作目录</span><br><span class="line">    参数：</span><br><span class="line">        - buf : 存储的路径，指向的是一个数组（传出参数）</span><br><span class="line">        - size: 数组的大小</span><br><span class="line">    返回值：</span><br><span class="line">        返回的指向的一块内存，这个数据就是第一个参数</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure>

<p>7）目录遍历函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开一个目录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - name: 需要打开的目录的名称</span><br><span class="line">    返回值：</span><br><span class="line">        DIR * 类型，理解为目录流</span><br><span class="line">        错误返回<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取目录中的数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line">    - 参数：dirp是opendir返回的结果</span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>，代表读取到的文件的信息</span></span><br><span class="line"><span class="class">        读取到了末尾或者失败了，返回<span class="title">NULL</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 关闭目录</span></span><br><span class="line"><span class="class">#<span class="title">include</span> &lt;</span>sys/types.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171021405.png" alt="33"></p>
<p>8）dup\dup2函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line">	  作用：复制一个新的文件描述符</span><br><span class="line">	  fd=<span class="number">3</span>, <span class="type">int</span> fd1 = dup(fd),</span><br><span class="line">	  fd指向的是a.txt, fd1也是指向a.txt</span><br><span class="line">		从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> dup2(<span class="type">int</span> oldfd, <span class="type">int</span> newfd);</span><br><span class="line">    作用：重定向文件描述符</span><br><span class="line">    oldfd 指向 a.txt, newfd 指向 b.txt</span><br><span class="line">    调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt</span><br><span class="line">    oldfd 必须是一个有效的文件描述符</span><br><span class="line">    oldfd和newfd值相同，相当于什么都没有做</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd1 = open(<span class="string">&quot;2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line"><span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d\\n&quot;</span>, fd, fd1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做了dup2之后 fd1就和2.txt没有关系了  </span></span><br><span class="line"><span class="comment">// 返回值fd2其实没必要再做任何操作了</span></span><br><span class="line"><span class="type">int</span> fd2 = dup2(fd, fd1);</span><br><span class="line"><span class="keyword">if</span>(fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样重定向之后2.txt就没有任何文件描述符了</span></span><br><span class="line"><span class="comment">// 如果还需要访问2.txt，则需要重新open一下，赋值一个新的文件描述符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过fd1去写数据，实际操作的是1.txt，而不是2.txt</span></span><br><span class="line"><span class="type">char</span> * str = <span class="string">&quot;hello, dup2&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9）fcntl函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span>;</span><br><span class="line">参数：</span><br><span class="line">    fd : 表示需要操作的文件描述符</span><br><span class="line">    cmd: 表示对文件描述符进行如何操作</span><br><span class="line">        - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）</span><br><span class="line">            <span class="type">int</span> ret = fcntl(fd, F_DUPFD);</span><br><span class="line"></span><br><span class="line">        - F_GETFL : 获取指定的文件描述符文件状态flag</span><br><span class="line">          获取的flag和我们通过open函数传递的flag是一个东西。</span><br><span class="line"></span><br><span class="line">        - F_SETFL : 设置文件描述符文件状态flag</span><br><span class="line">          必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改</span><br><span class="line">          可选性：O_APPEND, O_NONBLOCK</span><br><span class="line">            O_APPEND 表示追加数据</span><br><span class="line">            O_NONBLOCK 设置成非阻塞</span><br><span class="line">    </span><br><span class="line">    阻塞和非阻塞：描述的是函数调用的行为。</span><br></pre></td></tr></table></figure>

<h1 id="6、进程"><a href="#6、进程" class="headerlink" title="6、进程"></a>6、进程</h1><h2 id="（1）进程概述"><a href="#（1）进程概述" class="headerlink" title="（1）进程概述"></a>（1）进程概述</h2><ul>
<li>进程要占用内存和CPU资源，而程序不占用</li>
<li>从内核角度看：进程 &#x3D; 用户内存空间 + 内核数据结构</li>
<li><code>时间片(timeslice)</code>是操作系统分配给每个正在运行的进程微观上的一段CPU时间。由于timeslice的存在，让进程“看起来像”是同时运行的。<strong>Linux一般为5ms-800ms</strong></li>
<li>并行和并发<ul>
<li><code>并行(parallel)</code>：指在同一时刻，有多条指令在多个处理器上同时执行。</li>
<li><code>并发(concurrency)</code>：指在同一时刻只能有一条指令执行，但多个进程指令被快速的 轮换执行，本质上是把时间分成若干段，使多个进程快速交替的执行。</li>
</ul>
</li>
<li>内核为每个进程分配一个PCB(Processing Control Block)进程控制块</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171022599.png" alt="34"></p>
<h2 id="（2）进程状态转换"><a href="#（2）进程状态转换" class="headerlink" title="（2）进程状态转换"></a>（2）进程状态转换</h2><p>1）进程状态</p>
<ul>
<li><p>三态模型</p>
<ul>
<li>就绪态：进程具备运行条件，已分配到除CPU以外的所有必要资源；处于就绪态的多个进程排成就绪队列</li>
<li>运行态：进程占有处理器正在运行</li>
<li>阻塞态：进程不具备运行条件，又称wait或sleep态，需要与用户进行交互时也将阻塞</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171024144.png" alt="35"></p>
</li>
<li><p>五态模型</p>
<ul>
<li>新建态：进程刚被创建，尚未进入就绪队列</li>
<li>就绪态</li>
<li>运行态</li>
<li>阻塞态</li>
<li>终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统以及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171024552.png" alt="36"></p>
</li>
</ul>
<p>2）进程相关命令</p>
<ul>
<li>查看进程 <code>ps aux / ajx</code> a：显示终端上的所有进程，包括其他用户的进程 u：显示进程的详细信息 x：显示没有控制终端的进程 j：列出与作业控制相关的信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@iisayhi:~/lesson<span class="meta"># ps aux</span></span><br><span class="line">USER  PID  %CPU  %MEM  VSZ  RSS  TTY  STAT  START  TIME  COMMAND</span><br><span class="line"></span><br><span class="line">root@iisayhi:~/lesson<span class="meta"># ps ajx</span></span><br><span class="line">PPID  PID  PGID  SID  TTY  TPGID  STAT  UID  TIME  COMMAND</span><br><span class="line">PPID - 父进程ID  </span><br><span class="line">PID  - 进程ID  </span><br><span class="line">PGID - 进程组的ID</span><br><span class="line">SID  - 会话的ID</span><br><span class="line">TTY  - 终端  </span><br></pre></td></tr></table></figure>

<ul>
<li>实时显示进程动态 <code>top</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171024495.png" alt="37"></p>
<ul>
<li>杀死进程<ul>
<li><code>kill [-signal] pid</code></li>
<li><code>kill –l</code> 列出所有信号</li>
<li><code>kill –SIGKILL</code> 进程ID</li>
<li><code>kill -9</code> 进程ID</li>
<li><code>killall name</code> 根据进程名杀死进程</li>
</ul>
</li>
</ul>
<p>3）进程相关</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025257.png" alt="38"></p>
<ul>
<li>父子进程虚拟地址空间情况</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid : %d\\n&quot;</span>, pid);</span><br><span class="line">        <span class="comment">// 若大于0，当前为父进程，并返回子进程的进程号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent procress, pid : %d, ppid : %d\\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 若等于0，当前为子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child procress, pid : %d, ppid : %d\\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d, pid : %d\\n&quot;</span>, i, getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。</span></span><br><span class="line"><span class="comment">写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</span></span><br><span class="line"><span class="comment">内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</span></span><br><span class="line"><span class="comment">只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</span></span><br><span class="line"><span class="comment">也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</span></span><br><span class="line"><span class="comment">注意：fork之后父子进程共享文件，</span></span><br><span class="line"><span class="comment">fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">root@iisayhi:~/lesson/lesson07<span class="meta"># gcc fork.c -o fork</span></span><br><span class="line">root@iisayhi:~/lesson/lesson07# ./fork</span><br><span class="line">pid : <span class="number">265418</span></span><br><span class="line">I am parent procress, pid : <span class="number">265417</span>, ppid : <span class="number">264856</span></span><br><span class="line">i : <span class="number">0</span>, pid : <span class="number">265417</span></span><br><span class="line">I am child procress, pid : <span class="number">265418</span>, ppid : <span class="number">265417</span></span><br><span class="line">i : <span class="number">0</span>, pid : <span class="number">265418</span></span><br><span class="line">i : <span class="number">1</span>, pid : <span class="number">265417</span></span><br><span class="line">i : <span class="number">1</span>, pid : <span class="number">265418</span></span><br><span class="line">i : <span class="number">2</span>, pid : <span class="number">265417</span></span><br><span class="line">i : <span class="number">2</span>, pid : <span class="number">265418</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025204.png" alt="39"></p>
<blockquote>
<p>Linux父子进程中变量地址相同——虚拟内存</p>
<p>csdn参考网址：<a href="https://blog.csdn.net/weixin_45636061/article/details/124610215?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124610215-blog-124260634.235%5Ev28%5Epc_relevant_t0_download&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124610215-blog-124260634.235%5Ev28%5Epc_relevant_t0_download&utm_relevant_index=2">虚拟内存</a></p>
<p><strong>物理内存和虚拟内存被分成了页框与页之后，其存储单元原来的地址都被自然地分成了两段，并且这两段各自代表着不同的意义：高位段分别叫做页框码和页码，它们是识别页框和页的编码；低位段分别叫做页框偏移量和页内偏移量，它们是存储单元在页框和页内的地址编码。</strong></p>
<p><strong>处理器遇到的地址都是虚拟地址。虚拟地址和物理地址都分成页码（页框码）和偏移值两部分。在由虚拟地址转化成物理地址的过程中，偏移值不变。而页码和页框码之间的映射就在一个映射记录表——页表中。</strong></p>
<p><strong>当程序执行fork()并创建子进程时，子进程会完全复制父进程的栈空间，包括页表，但没有复制物理页面，所以这时父子进程的变量地址相同，也即虚拟地址和物理地址相同。</strong></p>
<p>但是此时父子共享的页面仅标记为“只读”，在父子进程都没有访问内存时，二者共享一个页面。</p>
<p>当发生内存访问操作时，内核会复制一个物理页面给该进程，并修改其页表。同时把原来的只读页面标记为“可写”，留给另一个进程。以上即为所谓的“<strong>写时复制</strong>”或“<strong>写时拷贝</strong>”。</p>
</blockquote>
<ul>
<li><p>父子进程关系</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">父子进程之间的关系：</span><br><span class="line">    区别：</span><br><span class="line">        <span class="number">1.f</span>ork()函数的返回值不同</span><br><span class="line">            父进程中: &gt;<span class="number">0</span> 返回的子进程的ID</span><br><span class="line">            子进程中: =<span class="number">0</span></span><br><span class="line">        <span class="number">2.</span>pcb（进程控制块）中的一些数据</span><br><span class="line">            当前的进程的id pid</span><br><span class="line">            当前的进程的父进程的id ppid</span><br><span class="line">            信号集</span><br><span class="line"></span><br><span class="line">    共同点：</span><br><span class="line">        某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</span><br><span class="line">            - 用户区的数据</span><br><span class="line">            - 文件描述符表</span><br><span class="line">    </span><br><span class="line">    父子进程对变量是不是共享的？</span><br><span class="line">        - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。</span><br><span class="line">        - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。</span><br></pre></td></tr></table></figure>
</li>
<li><p>GDB多进程调试</p>
<ul>
<li><p>GDB默认只能跟踪一个进程，<strong>默认跟踪父进程</strong>。所以需要指令设置GDB跟踪的是父进程还是子进程</p>
</li>
<li><p>设置调试父进程或子进程：</p>
<ul>
<li><code>set follow-fork-mode [parent(默认) | child]</code></li>
</ul>
</li>
<li><p>设置调试模式</p>
<ul>
<li><pre><code>set detach-on-fork [on | off]
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      - `on`：调试当前进程时，其它进程继续运行；</span><br><span class="line">      - `off`：调试当前进程时，其它进程被GDB挂起。</span><br><span class="line"></span><br><span class="line">  - 查看调试的进程：</span><br><span class="line"></span><br><span class="line">    - `info inderiors`</span><br><span class="line"></span><br><span class="line">  - 切换当前调试的进程：</span><br><span class="line"></span><br><span class="line">    - `inferior id`</span><br><span class="line"></span><br><span class="line">  - 使进程脱离GDB调试：</span><br><span class="line"></span><br><span class="line">    - `detach inferiors id`</span><br><span class="line"></span><br><span class="line">## （3）exec函数族</span><br><span class="line"></span><br><span class="line">- **exec函数族**的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件</span><br><span class="line"></span><br><span class="line">- **exec函数族**的函数执行成功后不会返回，因为**调用进程的实体，包括代码段，数据段和堆栈等（即即将执行的可执行文件的用户区内容）都已经被新的内容取代**，只留下进程 ID 等一些表面上的信息仍保持原样；**只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行**</span><br><span class="line"></span><br><span class="line">- 函数原型：</span><br><span class="line"></span><br><span class="line">  ![40](https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025390.png)</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  #include &lt;unistd.h&gt;</span><br><span class="line">  int execl(const char *path, const char *arg, ...);</span><br><span class="line">      - 参数：</span><br><span class="line">          - path:需要指定的执行的文件的路径或者名称</span><br><span class="line">              a.out /home/nowcoder/a.out 推荐使用绝对路径</span><br><span class="line">              ./a.out hello world</span><br><span class="line">  </span><br><span class="line">          - arg:是执行可执行文件所需要的参数列表</span><br><span class="line">              第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="line">              从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="line">              参数最后需要以NULL结束（哨兵）</span><br><span class="line">  </span><br><span class="line">      - 返回值：</span><br><span class="line">          只有当调用失败，才会有返回值，返回-1，并且设置errno</span><br><span class="line">          如果调用成功，没有返回值。</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="（4）进程控制"><a href="#（4）进程控制" class="headerlink" title="（4）进程控制"></a>（4）进程控制</h2><p>1）进程退出</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025341.png" alt="41"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">    void exit(int status);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    void _exit(int status);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\\n&quot;</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exit(0); // 可打印hello world</span></span><br><span class="line">    _exit(<span class="number">0</span>);   <span class="comment">// 仅打印hello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分析：</span></span><br><span class="line">    <span class="comment">// 对于标准c库函数printf，首先会把其中的内容放入缓冲区</span></span><br><span class="line">    <span class="comment">// 当有\\n时，会对缓冲区进行刷新，从而就可以获取到hello这一内容</span></span><br><span class="line">    <span class="comment">// 而没有\\n时，world会首先被放到缓冲区，_exit也不会对缓冲区进行刷新，从而无法打印</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）孤儿进程</p>
<ul>
<li>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程<strong>（Orphan Process）</strong></li>
<li>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为<code>init</code>，而<code>init</code>进程会循环地 <code>wait()</code>已经退出的子进程。这样，当一个孤儿进程结束了其生命周期的时候，<code>init</code>进程就会处理它的一切善后工作</li>
<li>孤儿进程实际上无危害</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d, ppid : %d\\n&quot;</span>, getpid(), getppid());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 当前是子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d, ppid : %d\\n&quot;</span>, getpid(),getppid());</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d , pid : %d\\n&quot;</span>, i , getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">root@iisayhi:~/lesson/lesson08# ./orphan</span><br><span class="line">i am parent process, pid : <span class="number">275127</span>, ppid : <span class="number">272697</span></span><br><span class="line">i : <span class="number">0</span> , pid : <span class="number">275127</span></span><br><span class="line">i : <span class="number">1</span> , pid : <span class="number">275127</span></span><br><span class="line">i : <span class="number">2</span> , pid : <span class="number">275127</span></span><br><span class="line">root@iisayhi:~/lesson/lesson08<span class="meta"># i am child process, pid : 275128, **ppid : 1**</span></span><br><span class="line">i : <span class="number">0</span> , pid : <span class="number">275128</span></span><br><span class="line">i : <span class="number">1</span> , pid : <span class="number">275128</span></span><br><span class="line">i : <span class="number">2</span> , pid : <span class="number">275128</span></span><br></pre></td></tr></table></figure>

<p>3）僵尸进程</p>
<ul>
<li>每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。<strong>进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程</strong></li>
<li><strong>僵尸进程不能被</strong><code>kill -9</code><strong>杀死</strong>，因此如果父进程不调用<code>wait()</code>或<code>waitpid()</code>的话，那么保留的那段信息就不会释放，<strong>其进程号就会一直被占用</strong>，但是系统所能使用的进程号是有限的，<strong>如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免</strong></li>
</ul>
<p>4）wait &amp; waitpid</p>
<ul>
<li><p><strong>注意：一次<code>wait</code>或<code>waitpid</code>调用只能清理一个子进程，清理多个子进程应使用循环</strong></p>
</li>
<li><p><code>wait()</code></p>
<ul>
<li><code>wait()</code>函数会阻塞<strong>（阻塞的意思就是说，在子进程结束前，会一直阻塞在<code>wait()</code>函数处，等到子进程结束后才会继续向下执行）</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025019.png" alt="42"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *wstatus)</span>;</span><br><span class="line">    功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源。</span><br><span class="line">    参数：<span class="type">int</span> *wstatus</span><br><span class="line">        进程退出时的状态信息，传入的是一个<span class="type">int</span>类型的地址，传出参数。</span><br><span class="line">    返回值：</span><br><span class="line">        - 成功：返回被回收的子进程的id</span><br><span class="line">        - 失败：<span class="number">-1</span> (所有的子进程都结束，调用函数失败)</span><br><span class="line"></span><br><span class="line">调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span><br><span class="line">如果没有子进程了，函数立刻返回，返回<span class="number">-1</span>；如果子进程都已经结束了，也会立即返回，返回<span class="number">-1.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>waitpid()</code></p>
<ul>
<li><code>waitpid()</code>可以设置不阻塞<strong>（不阻塞的意思就是说，即使子进程还未结束，<code>waitpid()</code>也会立刻返回，程序可以接着往下执行）</strong>，<code>waitpid()</code>还可以指定等待哪个子进程结束</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line">    功能：回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="line">    参数：</span><br><span class="line">        - pid:</span><br><span class="line">            pid &gt; <span class="number">0</span> : 某个子进程的pid</span><br><span class="line">            pid = <span class="number">0</span> : 回收当前进程组的所有子进程    </span><br><span class="line">            pid = <span class="number">-1</span> : 回收所有的子进程，相当于 wait()  （最常用）</span><br><span class="line">            pid &lt; <span class="number">-1</span> : 某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="line">        - options：设置阻塞或者非阻塞</span><br><span class="line">            <span class="number">0</span> : 阻塞</span><br><span class="line">            WNOHANG : 非阻塞</span><br><span class="line">     返回值：</span><br><span class="line">        &gt; <span class="number">0</span> : 返回子进程的id</span><br><span class="line">        = <span class="number">0</span> : options=WNOHANG, 表示还有子进程或者</span><br><span class="line">        = <span class="number">-1</span> ：错误，或者没有子进程了</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="（5）进程间通信"><a href="#（5）进程间通信" class="headerlink" title="（5）进程间通信"></a>（5）进程间通信</h2><h3 id="1）匿名管道"><a href="#1）匿名管道" class="headerlink" title="1）匿名管道"></a>1）匿名管道</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">管道的读写特点：</span><br><span class="line">使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I/O操作）</span><br><span class="line">	<span class="number">1.</span>所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为<span class="number">0</span>），有进程从管道的读端</span><br><span class="line">	读数据，那么管道中剩余的数据被读取以后，再次read会返回<span class="number">0</span>，就像读到文件末尾一样。</span><br><span class="line">	</span><br><span class="line">	<span class="number">2.</span>如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于<span class="number">0</span>），而持有管道写端的进程</span><br><span class="line">	也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，</span><br><span class="line">	再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。</span><br><span class="line">	</span><br><span class="line">	<span class="number">3.</span>如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为<span class="number">0</span>），这个时候有进程</span><br><span class="line">	向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。</span><br><span class="line">	</span><br><span class="line">	<span class="number">4.</span>如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于<span class="number">0</span>），而持有管道读端的进程</span><br><span class="line">	也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，</span><br><span class="line">	直到管道中有空位置才能再次写入数据并返回。</span><br><span class="line">总结：</span><br><span class="line">	读管道：</span><br><span class="line">		管道中有数据，read返回实际读到的字节数。</span><br><span class="line">		管道中无数据：</span><br><span class="line">			写端被全部关闭，read返回<span class="number">0</span>（相当于读到文件的末尾）</span><br><span class="line">			写端没有完全关闭，read阻塞等待</span><br><span class="line">	</span><br><span class="line">	写管道：</span><br><span class="line">    管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）</span><br><span class="line">    管道读端没有全部关闭：</span><br><span class="line">        管道已满，write阻塞</span><br><span class="line">        管道没有满，write将数据写入，并返回实际写入的字节数</span><br></pre></td></tr></table></figure>

<h3 id="2）有名管道"><a href="#2）有名管道" class="headerlink" title="2）有名管道"></a>2）有名管道</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">有名管道的注意事项：</span><br><span class="line">	<span class="number">1.</span>一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</span><br><span class="line">	<span class="number">2.</span>一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</span><br><span class="line"></span><br><span class="line">读管道：</span><br><span class="line">    管道中有数据，read返回实际读到的字节数</span><br><span class="line">    管道中无数据：</span><br><span class="line">        写端被全部关闭，read返回<span class="number">0</span>（相当于读到文件末尾）</span><br><span class="line">        写端没有完全关闭，read阻塞等待</span><br><span class="line"></span><br><span class="line">写管道：</span><br><span class="line">    管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）</span><br><span class="line">    管道读端没有全部关闭：</span><br><span class="line">        管道已满，write阻塞</span><br><span class="line">        管道没有满，write将数据写入，并返回实际写入的字节数。</span><br></pre></td></tr></table></figure>

<ul>
<li>有名管道实现简单版聊天功能</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171026474.png" alt="43"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读数据</span></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">  ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">  <span class="comment">// ret = read(fdr, buf, strlen(buf)); 错误写法</span></span><br><span class="line">  <span class="keyword">if</span>(ret &lt;= <span class="number">0</span> )&#123;perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>read</code>函数的原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>fd</code>为文件描述符；<code>buf</code>表示读出数据缓冲区地址；<code>count</code>表示读出的字节数。</p>
<p>因此，若写成<code>ret = read(fdr, buf, strlen(buf))</code>，在当时所写程序中，最开始并未写入数据，因此读到的数据为空，则将报错</p>
<h2 id="（6）内存映射"><a href="#（6）内存映射" class="headerlink" title="（6）内存映射"></a>（6）内存映射</h2><p>内存映射（Memory-mapped I&#x2F;O）是将磁盘文件的数据映射到内存，用户通过修改 内存就能修改磁盘文件。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171026332.png" alt="44"></p>
<h1 id="7、阻塞-非阻塞-同步-异步"><a href="#7、阻塞-非阻塞-同步-异步" class="headerlink" title="7、阻塞&#x2F;非阻塞 &amp;&amp; 同步&#x2F;异步"></a>7、阻塞&#x2F;非阻塞 &amp;&amp; 同步&#x2F;异步</h1><p><a href="https://blog.csdn.net/lengxiao1993/article/details/78154467?ops_request_misc=%7B%22request_id%22:%22168319803316800182190279%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168319803316800182190279&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-78154467-null-null.142%5Ev86%5Ekoosearch_v1,239%5Ev2%5Einsert_chatgpt&utm_term=%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E&spm=1018.2226.3001.4187">阻塞与非阻塞_csdn</a></p>
<ul>
<li><p>阻塞（Blocking）与非阻塞（Nonblocking）是在数据就绪阶段进行判断</p>
<ul>
<li><p>阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。</p>
</li>
<li><p>非阻塞指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。当前线程可以去干别的事情。</p>
</li>
<li><p>sockfd对应操作系统中一个tcp缓冲区，阻塞与非阻塞都在该缓冲区中进行考虑。</p>
<blockquote>
<p><strong>阻塞IO和非阻塞IO的区别就在于</strong>： 应用程序的调用是否立即返回</p>
</blockquote>
</li>
</ul>
</li>
<li><p>同步（Synchronous）与非同步（Asynchronous）在数据读写阶段进行判断</p>
<ul>
<li><p>同步即应用程序自己从内核缓冲区中获取数据送入自己定义的buf中，只有数据获取结束之后应用程序才能进行其他的操作。</p>
</li>
<li><p>异步中有一个非常重要的“通知方式”，异步即为操作系统将数据从内核中送入自己定义的buf中，不需要我们自己操作，数据放好后通过“通知方式”告诉我们</p>
<blockquote>
<p><strong>同步IO</strong>：应用程序主动向内核查询是否有可用数据，如果有,当前进程自己负责把数据从内核copy到用户空间，拷贝的过程中进程阻塞。 <strong>异步IO</strong>：应用程序向内核发起读数据请求时需要：（1）告诉内核数据存放位置（2）注册回调函数，当内核完成数据copy后调用回调通知应用程序取数据。因为数据copy由内核完成的，所以拷贝的时候进程不阻塞。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="8、用户空间和内核空间"><a href="#8、用户空间和内核空间" class="headerlink" title="8、用户空间和内核空间"></a>8、用户空间和内核空间</h1><ul>
<li>内存空间的划分<ul>
<li>内核空间</li>
<li>用户空间</li>
</ul>
</li>
<li><strong>操作系统内核需要拥有高于普通进程的权限</strong>， 以此来调度和管理用户的应用程序，不同进程间相对独立。</li>
<li>硬件层面的内存访问权限控制细节：DPL&#x2F;CPL</li>
</ul>
<h1 id="9、进程切换与进程阻塞"><a href="#9、进程切换与进程阻塞" class="headerlink" title="9、进程切换与进程阻塞"></a>9、进程切换与进程阻塞</h1><ul>
<li>进程切换中几个最重要的步骤：</li>
</ul>
<p>1）当一个程序正在执行的过程中， 中断（interrupt） 或 系统调用（system call） 发生可以使得CPU的控制权会从当前进程转移到操作系统内核。</p>
<p>2）操作系统内核负责保存<code>进程i</code>在CPU中的上下文（程序计数器， 寄存器）到<code>PCBi</code>（操作系统分配给进程的一个内存块）中。</p>
<p>3）从<code>PCBj</code>取出<code>进程j</code>的CPU 上下文， 将 CPU 控制权转移给<code>进程j</code> ， 开始执行<code>进程j</code>的指令。</p>
<ul>
<li>中断<ul>
<li>在每个时钟周期末尾查询当前CPU中断位是否有中断信号送入，若有，判断当前正在执行的指令和中断信号的指令的优先级，决定执行哪个指令</li>
</ul>
</li>
<li>时钟中断<ul>
<li>一个硬件时钟会每隔一段（很短）的时间就产生一个中断信号发送给 CPU，CPU 在响应这个中断时， 就会去执行操作系统内核的指令， 继而将 CPU 的控制权转移给了操作系统内核， 可以由操作系统内核决定下一个要被执行的指令</li>
</ul>
</li>
<li>系统调用<ul>
<li>system call 是操作系统提供给应用程序的接口。 用户通过调用 system call 来完成那些需要操作系统内核进行的操作， 例如硬盘， 网络接口设备的读写等</li>
</ul>
</li>
<li><strong>对于一个运行着 UNIX 系统的现代 PC 来说， 进程切换至少需要花费 300 us 的时间</strong></li>
<li>进程阻塞<ul>
<li>我们所说的 “阻塞”是指进程在<strong>发起了一个系统调用</strong>（System Call） 后， 由于该系统调用的操作不能立即完成，需要等待一段时间，于是内核将进程挂起为等待 （waiting）状态， 以确保它不会被调度执行， 占用 CPU 资源。</li>
</ul>
</li>
</ul>
<h1 id="10、Unix-Linux上的五种IO模型"><a href="#10、Unix-Linux上的五种IO模型" class="headerlink" title="10、Unix&#x2F;Linux上的五种IO模型"></a>10、Unix&#x2F;Linux上的五种IO模型</h1><p>（1）<strong>（同步）阻塞 blocking</strong></p>
<p>阻塞即为：调用某函数后，必须等到该函数返回之后才能进行下一步动作。</p>
<p>（2）<strong>（同步）非阻塞 non-blocking</strong></p>
<p>非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。一旦内核中的数据准备好了，并且又再次收到了用户进程的请求，那么<strong>进程就会将内核中的数据拷贝到用户内存</strong>，然后返回。</p>
<p>非阻塞I&#x2F;O执行系统调用总是立即返回，不管事件是否已经发生。</p>
<p>（3）<strong>IO复用 IO multiplexing</strong></p>
<p>Linux 用 <code>select/poll/epoll</code> 函数实现 IO 复用模型。</p>
<p>这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。</p>
<p>（4）<strong>信号驱动 signal-driven</strong></p>
<p>Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到<code>SIGIO</code>信号，然后处理 IO 事件。</p>
<blockquote>
<p>多路复用和信号驱动的区别与联系：</p>
<ul>
<li>多路复用：内核们监听多个文件描述符，阻塞在监听的函数处（如<code>select/poll/epoll</code>），同时也阻塞在数据拷贝阶段。多路复用只是<strong>防止进程在某个io阻塞后，不能及时处理其他io的事件。</strong></li>
<li>信号驱动：先登记信号处理函数，当数据准备完毕后由内核发送信号给进程，让进程处理。信号驱动<strong>不阻塞在数据准备过程，但阻塞在数据拷贝</strong>。</li>
</ul>
</blockquote>
<p>💡 <strong>前四种方式都属于同步IO。</strong></p>
<p>（5）<strong>异步 asynchronous</strong></p>
<p>Linux中，可以调用 <code>aio_read</code> 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及<strong>通知的方式</strong>，然后<strong>立即返回</strong>，当内核将数据拷贝到缓冲区后，再通知应用程序。</p>
<h1 id="11、Web-Server（网页服务器）"><a href="#11、Web-Server（网页服务器）" class="headerlink" title="11、Web Server（网页服务器）"></a>11、<strong>Web Server（网页服务器）</strong></h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171026839.png" alt="45"></p>
]]></content>
      <categories>
        <category>Computer</category>
        <category>Base</category>
      </categories>
  </entry>
  <entry>
    <title>vscode相关</title>
    <url>/2023/08/01/Computer/Base/vscode%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="1、-vscode连接阿里云如何免密？"><a href="#1、-vscode连接阿里云如何免密？" class="headerlink" title="1、 vscode连接阿里云如何免密？"></a>1、 vscode连接阿里云如何免密？</h1><h2 id="windows端："><a href="#windows端：" class="headerlink" title="windows端："></a><code>windows</code>端：</h2><p>1）在<code>cmd</code>中输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>

<p>在<code>c:\Users\用户名\\.ssh</code>下会生成私钥和公钥。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308021257775.png" alt="image-20230802125702563"></p>
<p>2）复制<code>id_rsa.pub</code>中的内容</p>
<h2 id="linux端："><a href="#linux端：" class="headerlink" title="linux端："></a><code>linux</code>端：</h2><p>1）输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>生成<code>linux</code>端的密钥，进入<code>/root/.ssh/id_rsa</code>路径下。</p>
<p>2）创建一个文件，名字叫<code>authorized_keys</code></p>
<p>3）把复制的<code>windows</code>公钥粘贴到<code>authorized_keys</code>中，保存退出</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308012055885.png" alt="Snipaste_2023-08-01_20-46-53"></p>
<h1 id="2、Linux环境使用VSCode调试简单C-代码"><a href="#2、Linux环境使用VSCode调试简单C-代码" class="headerlink" title="2、Linux环境使用VSCode调试简单C++代码"></a>2、Linux环境使用VSCode调试简单C++代码</h1><p>参考教程：<a href="https://blog.csdn.net/hypc9709/article/details/129413482?ops_request_misc=&request_id=&biz_id=102&utm_term=vscode%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-129413482.142%5Ev96%5Epc_search_result_base7&spm=1018.2226.3001.4187">Linux环境使用VSCode调试简单C++代码</a></p>
<h2 id="1）终端命令行进行编译、调试"><a href="#1）终端命令行进行编译、调试" class="headerlink" title="1）终端命令行进行编译、调试"></a>1）终端命令行进行编译、调试</h2><h2 id="2）通过VSCode进行编译、调试"><a href="#2）通过VSCode进行编译、调试" class="headerlink" title="2）通过VSCode进行编译、调试"></a>2）通过VSCode进行编译、调试</h2><h3 id="（1）前置条件"><a href="#（1）前置条件" class="headerlink" title="（1）前置条件"></a>（1）前置条件</h3><p>插件<code>C/C++</code>已安装；<code>g++编译器</code>和<code>gdb调试器</code>已安装。</p>
<h3 id="（2）配置tasks-json"><a href="#（2）配置tasks-json" class="headerlink" title="（2）配置tasks.json"></a>（2）配置<code>tasks.json</code></h3><ul>
<li><p>在<code>VSCode</code>的主菜单中，选择<code>Terminal&gt;Configure Default Build Task</code></p>
</li>
<li><p>出现一个下拉菜单，显示<code>C++</code>编译器的各种预定义编译任务。选择<code>C/C++: g++ build active file</code>（如果配置了中文，会显示<code>C/C++: g++ 生成活动文件</code>）</p>
</li>
<li><p>选择后，<code>VSCode</code>会自动生成一个<code>.vscode</code>文件夹和<code>tasks.json</code>文件，如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312071610116.png" alt="image-20231207144919415"></p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++ 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/g++&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>tasks.json</code>的作用是告诉<code>VSCode</code>如何编译程序，因此从其中的<code>Command</code>和<code>args</code>可以看出，实际上是执行了以下命令：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/usr/bin/g++ -g $&#123;file&#125; -o $&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li><code>$&#123;file&#125;</code>：当前活动文件是<code>VSCode</code>当前查看的文件，如<code>Main.cpp</code>；</li>
<li><code>$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;</code>：用于获取当前文件的目录和不包含扩展名的文件名，如<code>Main</code>。</li>
</ul>
<h3 id="（3）执行编译"><a href="#（3）执行编译" class="headerlink" title="（3）执行编译"></a>（3）执行编译</h3><ul>
<li><p><strong>回到需要执行编译的文件</strong>（这一步很重要，否则<code>\$&#123;file&#125;</code>和<code>$&#123;fileDirname&#125;</code>这些变量都会错）；</p>
</li>
<li><p>快捷键<code>ctrl+shift+B</code>或从菜单中选择运行：<strong>Terminal -&gt; Run Build Task</strong>，即可执行<code>tasks.json</code>中指定的编译过程；</p>
<p>编译任务完成后，会出现终端提示，对于成功的g++编译，输出如下：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312071609602.png" alt="image-20231207150223290"></p>
<p>（这里我将<code>tasks.json</code>中的<code>&quot;$&#123;file&#125;&quot;</code>项更改为<code>&quot;$&#123;fileDirname&#125;/*.cpp&quot;</code></p>
<h3 id="（4）调试文件"><a href="#（4）调试文件" class="headerlink" title="（4）调试文件"></a>（4）调试文件</h3><p>对需要调试的文件设置断点，选择<code>Debug C/C++ file</code>进行调试。</p>
<h3 id="（5）个性化配置launch-json"><a href="#（5）个性化配置launch-json" class="headerlink" title="（5）个性化配置launch.json"></a>（5）个性化配置<code>launch.json</code></h3><blockquote>
<p>这里<code>launch.json</code>的作用就是告诉<code>VSCode</code>如何调用<code>gdb调试器</code>。</p>
</blockquote>
<p>如果想要在调试&#x2F;运行程序时添加参数，只需要把参数添加在<code>&quot;args&quot;</code>选项中即可。</p>
<h4 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h4><p>在<code>VSCode</code>中编译、调试一个简单的<code>.cpp</code>文件，所需要做的就是：</p>
<ol>
<li>在<code>tasks.json</code>中调用<code>g++</code>生成一个可执行二进制文件；</li>
<li>在<code>launch.json</code>中调用<code>gdb</code>对生成的可执行文件进行调试。</li>
</ol>
<h3 id="（7）复用C-配置"><a href="#（7）复用C-配置" class="headerlink" title="（7）复用C++配置"></a>（7）复用C++配置</h3><p>上面的过程已经完成了在<code>VSCode</code>中调试<code>Linux</code>环境下的<code>C++</code>代码的配置，但只适用于当前工作空间。</p>
<p>如果想要在其他的工程文件夹下复用这种配置，只需要把<code>tasks.json</code>和<code>launch.json</code>文件复制到新文件夹下的<code>.vscode</code>目录下，然后根据需要改变对应的源文件和可执行文件的名称即可。</p>
<h1 id="3、VSCode自动生成头文件的-ifndef-define-endif"><a href="#3、VSCode自动生成头文件的-ifndef-define-endif" class="headerlink" title="3、VSCode自动生成头文件的 #ifndef #define #endif"></a>3、VSCode自动生成头文件的 #ifndef #define #endif</h1><p>参考这篇博客：<a href="https://blog.csdn.net/p1279030826/article/details/123851420">VSCode自动生成头文件的 #ifndef #define #endif</a></p>
]]></content>
      <categories>
        <category>Computer</category>
        <category>Base</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2024/04/08/Computer/Base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、因特网概述"><a href="#1、因特网概述" class="headerlink" title="1、因特网概述"></a>1、因特网概述</h2><p><strong>internet与Internet的区别</strong></p>
<ul>
<li><p><strong>internet(互联网或互连网)<strong>是一个通用名词，它泛指</strong>多个计算机网络互连而成的网络</strong>。在这些网络之间的通信协议可以是任意的。</p>
</li>
<li><p><strong>Internet（因特网）则是一个专用名词</strong>，它指<strong>当前全球最大的、开放的、由众多网络互连而成的特定计算机网络</strong>，它采用TCP&#x2F;IP协议族作为通信的规则，其前身是美国的ARPANET。</p>
</li>
</ul>
<p>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是互联网(Internet)。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121642022.webp" alt="img"></p>
<blockquote>
<p>普通用户是如何接入到因特网的呢？</p>
<p>答：<strong>通过ISP接入因特网</strong></p>
<p>ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从<strong>ISP的得到所需要的IP地址</strong>。</p>
<p><strong>因为因特网上的主机都必须有IP地址才能进行通信，这样就可以通过该ISP接入到因特网</strong></p>
</blockquote>
<h2 id="2、计算机网络体系结构"><a href="#2、计算机网络体系结构" class="headerlink" title="2、计算机网络体系结构"></a>2、计算机网络体系结构</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121644183.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121645050.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121645246.webp" alt="img"></p>
<h1 id="二、网络层"><a href="#二、网络层" class="headerlink" title="二、网络层"></a>二、网络层</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646323.png" alt="image-20240412164600035"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646120.png" alt="image-20240412164607943"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646736.png" alt="image-20240412164616479"></p>
<h1 id="三、运输层"><a href="#三、运输层" class="headerlink" title="三、运输层"></a>三、运输层</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-d9a70806edc95dc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的。</strong></p>
<h2 id="2、运输层端口号、复用与分用的概念"><a href="#2、运输层端口号、复用与分用的概念" class="headerlink" title="2、运输层端口号、复用与分用的概念"></a>2、运输层端口号、复用与分用的概念</h2><h3 id="（1）为什么用端口号"><a href="#（1）为什么用端口号" class="headerlink" title="（1）为什么用端口号"></a>（1）为什么用端口号</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-de597eda77aa6acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（2）发送方的复用和接收方的分用"><a href="#（2）发送方的复用和接收方的分用" class="headerlink" title="（2）发送方的复用和接收方的分用"></a>（2）发送方的复用和接收方的分用</h3><ul>
<li><p><strong>多个进程</strong>利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据——<strong>复用</strong></p>
</li>
<li><p><strong>多个进程</strong>利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>数据—— <strong>分用</strong></p>
</li>
<li><p>这里一个端口表示一个进程</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2a4ec3f5d5c11433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（3）常用端口号"><a href="#（3）常用端口号" class="headerlink" title="（3）常用端口号"></a>（3）常用端口号</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2117fa99a7f2a89c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="3、TCP和UDP的对比"><a href="#3、TCP和UDP的对比" class="headerlink" title="3、TCP和UDP的对比"></a>3、TCP和UDP的对比</h2><h3 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h3><ul>
<li><p>TCP</p>
<ol>
<li>面向连接，需要在两个套接字之间建立连接，提供可靠服务；</li>
<li>传送TCP报文；</li>
<li>支持点对点单播，不支持多播、广播；</li>
<li>应用场景如万维网、电子邮件、文件传送等。</li>
</ol>
</li>
<li><p>UDP</p>
<ol>
<li><p>无连接，不需要套接字，不提供可靠交付；</p>
</li>
<li><p>传送UDP报文或用户数据报；</p>
</li>
<li><p>支持单播、多播和广播；</p>
</li>
<li><p>应用场景如多媒体应用等。</p>
<img src="https:////upload-images.jianshu.io/upload_images/24878825-624005a24bc5bfcd.png?imageMogr2/auto-orient/strip|imageView2/2/w/871/format/webp" alt="img" style="zoom: 50%;" /></li>
</ol>
</li>
</ul>
<h3 id="（2）TCP"><a href="#（2）TCP" class="headerlink" title="（2）TCP"></a>（2）TCP</h3><p>TCP（Transmission Control Protocol）</p>
<p>发送方</p>
<ul>
<li><p>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，但不知道这些待传送的字节流的含义</p>
</li>
<li><p>将他们编号，并存储在自己发送缓存中</p>
</li>
<li><p>根据发送策略，提取一定量的字节构建TCP报文并发送</p>
</li>
</ul>
<p>接收方</p>
<ul>
<li><p>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</p>
</li>
<li><p>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</p>
</li>
<li><p>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</p>
</li>
</ul>
<p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础。在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收。</p>
<img src="https:////upload-images.jianshu.io/upload_images/24878825-db48b70af7fb7884.png?imageMogr2/auto-orient/strip|imageView2/2/w/897/format/webp" alt="img" style="zoom:50%;" />

<h2 id="4、TCP的流量控制"><a href="#4、TCP的流量控制" class="headerlink" title="4、TCP的流量控制"></a>4、TCP的流量控制</h2><p>流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p>
<ul>
<li>当主机A收到主机B对相关字节数据的<strong>累计确认</strong>时，可以将其在发送缓存中删除。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f73e94f75e94ea4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5bd53b8a5a5ac400.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ea9dc3589e6c6bd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面。因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传。</p>
</blockquote>
<h2 id="5、TCP的拥塞控制"><a href="#5、TCP的拥塞控制" class="headerlink" title="5、TCP的拥塞控制"></a>5、TCP的拥塞控制</h2><p>在某段时间中，若对网络中某一资源（如链路容量&#x2F;带宽、缓存和处理机等）的需求超过了该资源所能提供的可用部分，就称发生了<strong>拥塞</strong>。</p>
<p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p>
<ol>
<li>点缓存的容量太小；</li>
<li>链路的容量不足；</li>
<li>处理机处理的速率太慢；</li>
<li>拥塞本身会进一步加剧拥塞；</li>
</ol>
<blockquote>
<p>相关算法</p>
<ul>
<li><strong>慢开始（slow-start）</strong></li>
<li><strong>拥塞避免（congestion avoidance）</strong></li>
<li><strong>快重传（fast transmit）</strong></li>
<li><strong>快恢复（fast recovery）</strong></li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c7682fe29ebcb6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>真正的发送窗口值 &#x3D; Min (接收方窗口值，拥塞窗口值)</p>
</blockquote>
<h3 id="（1）慢开始和拥塞避免"><a href="#（1）慢开始和拥塞避免" class="headerlink" title="（1）慢开始和拥塞避免"></a>（1）慢开始和拥塞避免</h3><h4 id="A-慢开始"><a href="#A-慢开始" class="headerlink" title="A. 慢开始"></a>A. 慢开始</h4><ul>
<li>目的：用来确定网络的负载能力或拥塞程度。</li>
<li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li>
<li>两个变量：<ul>
<li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。<ul>
<li>1 至 2 个最大报文段 （旧标准）</li>
<li>2 至 4 个最大报文段 （RFC 5681）</li>
</ul>
</li>
<li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-47dba7f2068f35df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1bca665e8eaa965a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/713/format/webp" alt="img"></p>
<blockquote>
<p>图中swnd是发送窗口</p>
<p>每经过一个传输轮次，拥塞窗口就加倍</p>
<p>窗口大小按<strong>指数增加</strong>，2的n-1次方</p>
</blockquote>
<h4 id="B-拥塞避免"><a href="#B-拥塞避免" class="headerlink" title="B. 拥塞避免"></a>B. 拥塞避免</h4><ul>
<li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。</li>
<li>每经过一个传输轮次，拥塞窗口 <strong>cwnd &#x3D; cwnd + 1</strong>。</li>
<li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li>
<li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。<img src="https://upload-images.jianshu.io/upload_images/24878825-f5db7ea25d8aca73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></li>
</ul>
<h3 id="（2）快重传和快恢复"><a href="#（2）快重传和快恢复" class="headerlink" title="（2）快重传和快恢复"></a>（2）快重传和快恢复</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-fee86fb3707a175c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="A-快重传"><a href="#A-快重传" class="headerlink" title="A. 快重传"></a>A. 快重传</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a57c7cc819aa4bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="B-快恢复"><a href="#B-快恢复" class="headerlink" title="B. 快恢复"></a>B. 快恢复</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-ab5a63efbd586eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="C-改进后的整体示意图"><a href="#C-改进后的整体示意图" class="headerlink" title="C. 改进后的整体示意图"></a>C. 改进后的整体示意图</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-8f61b8eddb5b2624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="6、TCP超时重传"><a href="#6、TCP超时重传" class="headerlink" title="6、TCP超时重传"></a>6、TCP超时重传</h2><blockquote>
<p>往返时间：<strong>RTT0</strong></p>
<p>超时重传时间：<strong>RTO</strong></p>
</blockquote>
<p>如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大；如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率。因此需要合理选择RTO的值。</p>
<ul>
<li>不能直接使用某次测量得到的RTT样本来计算超时重传时间RTO。应该利用每次测量得到的RTT样本，计算加权平均往返时间<strong>RTTs</strong>（又称为平滑的往返时间）</li>
</ul>
<p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107689.webp" alt="img"></p>
<p><strong>往返时间RTT的测量比较复杂</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107552.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107260.webp" alt="img"></p>
<p><strong>TCP超时重传的计算</strong></p>
<p>举例</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107514.webp" alt="img"></p>
<h2 id="7、TCP可靠传输的实现"><a href="#7、TCP可靠传输的实现" class="headerlink" title="7、TCP可靠传输的实现"></a>7、TCP可靠传输的实现</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-6d10ea76a1ea032b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-92d975bc880db892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-35bff0a8cc5b0d71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="8、三次握手"><a href="#8、三次握手" class="headerlink" title="8、三次握手"></a>8、三次握手</h2><h3 id="（1）三次握手详解"><a href="#（1）三次握手详解" class="headerlink" title="（1）三次握手详解"></a>（1）三次握手详解</h3><ul>
<li>采用<strong>三次握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li>
</ul>
<ul>
<li><p>TCP的连接建立要解决以下三个问题</p>
<ul>
<li>使得双方能够确知对方的存在；</li>
<li>使得双方能够协商一些参数（如最大窗口值、是否使用时间戳选项和服务质量等）；</li>
<li>使得双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li>
</ul>
</li>
<li><p><strong>具体过程</strong></p>
<ol>
<li><p><strong>TCP服务器进程创建传输控制块，用来存储TCP连接中的一些重要信息，并进入监听状态，等待TCP客户端进程的连接请求</strong></p>
</li>
<li><p><strong>TCP客户进程也是首先创建传输控制块</strong></p>
</li>
<li><p><strong>TCP客户进程向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态。</strong></p>
<ol>
<li>其中， TCP连接请求报文段首部中的同步位syn被设置为1，表明这是一个TCP连接请求报文段；</li>
<li>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号；</li>
<li>注意<em>该报文段不能携带数据</em>，但要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态。</strong></p>
<ol>
<li>同步位SYN和确认位ACK都设置为1，表明这是一个TCP连接请求确认报文段；</li>
<li>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号；</li>
<li>确认位ACK的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认；</li>
<li>注意<em>该报文段也不能携带数据</em>，且同样要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态。</strong></p>
<ol>
<li>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1；</li>
<li>确认位ACK被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认；</li>
<li>注意<em>普通的TCP确认报文段可以携带数据</em>，但如果不携带数据，则不消耗序号。</li>
</ol>
</li>
<li><p><strong>TCP服务器进程收到该确认报文段后也进入连接已建立状态。</strong></p>
</li>
</ol>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-987d5c8512392422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（2）为什么不能“两次握手”？"><a href="#（2）为什么不能“两次握手”？" class="headerlink" title="（2）为什么不能“两次握手”？"></a>（2）为什么不能“两次握手”？</h3><blockquote>
<p>不采用两次握手主要是为了<strong>防止已经失效的连接请求报文段突然又传到服务端</strong>，因而产生错误。</p>
<p>这种情况是：<strong>客户端发出的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到下一个连接释放以后的某个时间才到达服务器端。</strong>当服务器端收到此失效报文后，会误认为是客户端发出的一个新连接请求，于是客户端又发出确认报文，表示同意建立连接。</p>
<p>如果不采用“三次握手”，那么只要服务器端发出确认报文就会认为新的连接已经建立了，但此时客户端并没有发出建立连接的请求，因此不会向服务器端发送数据。服务器端没有收到数据就会一直等待，这样就会白白浪费掉很多资源。</p>
<p>所以必须采用“三次握手”而非“两次握手”。</p>
</blockquote>
<p>下图是“两次握手”的示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0a5773a600817c41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="9、四次挥手"><a href="#9、四次挥手" class="headerlink" title="9、四次挥手"></a>9、四次挥手</h2><h3 id="（1）四次挥手详解"><a href="#（1）四次挥手详解" class="headerlink" title="（1）四次挥手详解"></a>（1）四次挥手详解</h3><ul>
<li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong>端，被动等待连接建立的应用进程叫做<strong>TCP服务器</strong>。<strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong>。</li>
</ul>
<ul>
<li><p>具体过程</p>
<ol>
<li><p><strong>当客户端和服务器端都处于连接已建立状态时，若要释放连接，客户进程会发送TCP连接释放报文段，并进入终止等待状态。</strong></p>
<ol>
<li>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；</li>
<li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1；</li>
<li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1；</li>
<li>注意FIN等于1的报文段即使不携带数据，也要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态。</strong></p>
<ol>
<li>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配；</li>
<li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认。</li>
</ol>
</li>
<li><p><strong>此时，从客户进程到服务器进程这个方向的连接就释放了，这时的TCP连接属于半关闭状态，也就是客户进程已经没有数据要发送了。但如果服务器进程还有数据要发送，客户进程仍要接收，也就是说从服务器进程到客户进程这个方向的连接并未关闭。</strong></p>
</li>
<li><p><strong>客户进程收到TCP确认报文段后就进入终止等待状态，等待服务器进程发出的TCP连接释放报文段。若服务器进程已经没有数据要发送了，服务器进程即释放连接。由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接。</strong></p>
</li>
<li><p><strong>服务器进程发送TCP连接释放报文段并进入最后确认状态。</strong></p>
<ol>
<li><p>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；</p>
</li>
<li><p>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送；</p>
</li>
<li><p>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认。</p>
</li>
</ol>
</li>
<li><p><strong>客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态。服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要经过2MSL后才能进入关闭状态。</strong></p>
<ol>
<li>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号；</li>
<li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认。</li>
</ol>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1c5e0c6357d039ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
</li>
</ul>
<h3 id="（2）为什么不能“三次挥手”？"><a href="#（2）为什么不能“三次挥手”？" class="headerlink" title="（2）为什么不能“三次挥手”？"></a>（2）为什么不能“三次挥手”？</h3><p>TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p>
<blockquote>
<p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。</p>
<p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ef85470fe120f146.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="10、TCP保活计时器"><a href="#10、TCP保活计时器" class="headerlink" title="10、TCP保活计时器"></a>10、TCP保活计时器</h2><p>TCP双方已经建立连接时，TCP客户进程所在的主机突然出现了故障。此时服务器进程无法再收到客户进程发来的数据。因此，应当有措施使TCP服务器进程不要再白白等待下去。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2dc97e06fe1d82ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h1 id="四、应用层"><a href="#四、应用层" class="headerlink" title="四、应用层"></a>四、应用层</h1><h2 id="1、CS方式和P2P方式"><a href="#1、CS方式和P2P方式" class="headerlink" title="1、CS方式和P2P方式"></a>1、CS方式和P2P方式</h2><h3 id="（1）CS方式（客户-服务器方式）"><a href="#（1）CS方式（客户-服务器方式）" class="headerlink" title="（1）CS方式（客户&#x2F;服务器方式）"></a>（1）CS方式（客户&#x2F;服务器方式）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121850174.webp" alt="img"></p>
<h3 id="（2）P2P方式（对等方式）"><a href="#（2）P2P方式（对等方式）" class="headerlink" title="（2）P2P方式（对等方式）"></a>（2）P2P方式（对等方式）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121850280.webp" alt="img"></p>
<h2 id="2、动态主机配置协议DHCP"><a href="#2、动态主机配置协议DHCP" class="headerlink" title="2、动态主机配置协议DHCP"></a>2、动态主机配置协议DHCP</h2><ul>
<li><p>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</p>
</li>
<li><p>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</p>
</li>
<li><p>DHCP的工作过程</p>
<ul>
<li><p><strong>DHCP 使用客户 - 服务器方式</strong></p>
<ul>
<li><p>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文  （DHCP DISCOVER），这时该主机就成为 DHCP 客户。</p>
</li>
<li><p>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</p>
</li>
<li><p>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</p>
</li>
</ul>
</li>
<li><p><strong>DHCP 工作方式</strong></p>
<ul>
<li><p>DHCP 使用客户-服务器方式，采用请求&#x2F;应答方式工作。</p>
</li>
<li><p>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121853443.webp" alt="img"></p>
<ul>
<li><p>DHCP中继代理</p>
<h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p>下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-33c64efac75f0ad2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p>
</blockquote>
</li>
<li><p>总结</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121854516.webp" alt="img"></p>
</li>
</ul>
<h2 id="3、域名系统DNS"><a href="#3、域名系统DNS" class="headerlink" title="3、域名系统DNS"></a>3、域名系统DNS</h2><h3 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855489.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855338.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855952.webp" alt="img"></p>
<h3 id="（2）域名解析过程"><a href="#（2）域名解析过程" class="headerlink" title="（2）域名解析过程"></a>（2）域名解析过程</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856499.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856729.webp" alt="img"></p>
<h2 id="4、文件传送协议FTP"><a href="#4、文件传送协议FTP" class="headerlink" title="4、文件传送协议FTP"></a>4、文件传送协议FTP</h2><blockquote>
<p>注意两种模式都是（1）控制连接在整个会话期间保持打开状态；（2）数据连接传输完毕后就关闭。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856907.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121857685.webp" alt="img"></p>
]]></content>
      <categories>
        <category>Computer</category>
        <category>Base</category>
      </categories>
  </entry>
  <entry>
    <title>Ch1 计算机系统漫游</title>
    <url>/2024/04/03/Computer/CSAPP/CSAPP_Ch1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="Ch1-计算机系统漫游"><a href="#Ch1-计算机系统漫游" class="headerlink" title="Ch1 计算机系统漫游"></a>Ch1 计算机系统漫游</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031123622.png" alt="CSAPP Ch1-Ch3_00"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031124622.png" alt="CSAPP Ch1-Ch3_01"></p>
]]></content>
      <categories>
        <category>Computer</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch10 系统级I/O</title>
    <url>/2024/04/03/Computer/CSAPP/CSAPP_Ch10%20%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="Ch10-系统级I-O"><a href="#Ch10-系统级I-O" class="headerlink" title="Ch10 系统级I&#x2F;O"></a>Ch10 系统级I&#x2F;O</h1><p><strong>I-Input&#x2F;O-Output：外设和内存之间进行数据交互的过程</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052201601.png" alt="image-20240405220142526"></p>
<h2 id="1、系统级I-O"><a href="#1、系统级I-O" class="headerlink" title="1、系统级I&#x2F;O"></a>1、系统级I&#x2F;O</h2><h3 id="（1）Unix-I-O"><a href="#（1）Unix-I-O" class="headerlink" title="（1）Unix I&#x2F;O"></a>（1）Unix I&#x2F;O</h3><ul>
<li>Opening files——返回文件描述符（file discripitor，fd）<ul>
<li>standard unput</li>
<li>standard output</li>
<li>standard err</li>
</ul>
</li>
<li>Changing the current file（改变当前文件的位置）</li>
<li>Reading and Writing files</li>
<li>Closing files</li>
</ul>
<h3 id="（2）Files"><a href="#（2）Files" class="headerlink" title="（2）Files"></a>（2）Files</h3><ul>
<li><p><strong>Regular file</strong>（普通文件）</p>
</li>
<li><p><strong>Directory</strong>（目录文件）</p>
<ul>
<li>相当于文件夹，是一个<strong>存储链接信息</strong>的数组，即<strong>文件和文件名的映射</strong></li>
</ul>
</li>
<li><p><strong>Socket</strong>（套接字）</p>
</li>
<li><p><strong>named pipe</strong>（命名管道），<strong>symbolic link</strong>（符号链接），<strong>character and block device</strong>（字符和块设备）</p>
<ul>
<li>如键盘、鼠标等为字符设备；硬盘为块设备</li>
</ul>
</li>
<li><p><strong>usr</strong>——Unix Software Resources的缩写</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052220580.png" alt="image-20240405222033196"></p>
<h3 id="（3）Opening-and-Closing-Files"><a href="#（3）Opening-and-Closing-Files" class="headerlink" title="（3）Opening and Closing Files"></a>（3）Opening and Closing Files</h3><ul>
<li><p>打开文件</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052222286.png" alt="image-20240405222257203"></p>
</li>
<li><p>关闭文件</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052223245.png" alt="image-20240405222318176"></p>
</li>
</ul>
<h3 id="（4）File-Permission"><a href="#（4）File-Permission" class="headerlink" title="（4）File Permission"></a>（4）File Permission</h3><ul>
<li><p>User（文件拥有者）</p>
</li>
<li><p>Group（群组）</p>
</li>
<li><p>Others（其他人）</p>
</li>
<li><p>观察下图，可以看出：</p>
<ul>
<li>普通文件由<code>-</code>开头；目录文件由<code>d</code>开头</li>
<li><code>rwx</code>：<ul>
<li><code>r</code>：read</li>
<li><code>w</code>：write</li>
<li><code>x</code>：execute</li>
</ul>
</li>
<li>一共有三组，如hello.c：<code>-rw-rw-r--</code>，可以看作是：<code>-|rw-|rw-|r--</code>，分别对应User、Group和Others的权限</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052227053.png" alt="image-20240405222704994"></p>
<h3 id="（5）Reading-and-Writing-Files"><a href="#（5）Reading-and-Writing-Files" class="headerlink" title="（5）Reading and Writing Files"></a>（5）Reading and Writing Files</h3><ul>
<li><code>EOF</code>：End of File</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052233018.png" alt="image-20240405223313949"></p>
<h3 id="（6）Reading-File-Metadata"><a href="#（6）Reading-File-Metadata" class="headerlink" title="（6）Reading File Metadata"></a>（6）Reading File Metadata</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052235910.png" alt="image-20240405223528846"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052235669.png" alt="image-20240405223540586"></p>
<h2 id="2、Robust-I-O"><a href="#2、Robust-I-O" class="headerlink" title="2、Robust I&#x2F;O"></a>2、Robust I&#x2F;O</h2><p><strong>Robust I&#x2F;O主要用于网络中。</strong></p>
<blockquote>
<p>Robust I&#x2F;O（健壮的I&#x2F;O）是一种设计模式，旨在提高程序对输入输出（I&#x2F;O）操作的稳健性和可靠性。具体来说，Robust I&#x2F;O 的作用包括以下几个方面：</p>
<ol>
<li><strong>错误处理：</strong> Robust I&#x2F;O 强调对I&#x2F;O操作的错误处理。它会在发生错误时进行适当的处理，例如捕获异常、返回错误码或者记录日志，从而确保程序在出现异常情况时能够做出合适的应对，而不会导致程序崩溃或者数据丢失。</li>
<li><strong>超时处理：</strong> Robust I&#x2F;O 考虑到可能发生的网络超时、设备故障等情况，会设置适当的超时时间，并在超时发生时进行处理，例如重新尝试连接或者报告错误，以保证程序能够及时响应并继续执行。</li>
<li><strong>资源释放：</strong> Robust I&#x2F;O 确保在完成I&#x2F;O操作后及时释放资源，避免资源泄露和内存溢出等问题，提高程序的稳定性和性能。</li>
<li><strong>容错机制：</strong> Robust I&#x2F;O 通过实现容错机制，可以在遇到部分错误或异常情况时，仍然保持程序的正常运行，尽量避免中断整个操作流程。</li>
<li><strong>重试机制：</strong> Robust I&#x2F;O 可能会实现重试机制，以确保在出现一次性错误时，能够尝试多次重复操作，从而提高操作的成功率。</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052239600.png" alt="image-20240405223951531"></p>
<ul>
<li><p>rio_t结构体</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052240176.png" alt="image-20240405224031108"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Computer</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch2 信息的表示和处理</title>
    <url>/2024/04/03/Computer/CSAPP/CSAPP_Ch2%20%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="Ch2-信息的表示和处理"><a href="#Ch2-信息的表示和处理" class="headerlink" title="Ch2 信息的表示和处理"></a>Ch2 信息的表示和处理</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031130352.png" alt="CSAPP Ch1-Ch3_02"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031130692.png" alt="CSAPP Ch1-Ch3_03"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031130543.png" alt="CSAPP Ch1-Ch3_04"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031131731.png" alt="CSAPP Ch1-Ch3_05"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031131498.png" alt="CSAPP Ch1-Ch3_06"></p>
]]></content>
      <categories>
        <category>Computer</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch3 程序的机器级表示</title>
    <url>/2024/04/03/Computer/CSAPP/CSAPP_Ch3%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="Ch3-程序的机器级表示"><a href="#Ch3-程序的机器级表示" class="headerlink" title="Ch3 程序的机器级表示"></a>Ch3 程序的机器级表示</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031125101.png" alt="CSAPP Ch1-Ch3_07"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031125684.png" alt="CSAPP Ch1-Ch3_08"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031125146.png" alt="CSAPP Ch1-Ch3_09"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031125670.png" alt="CSAPP Ch1-Ch3_10"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031126892.png" alt="CSAPP Ch1-Ch3_11"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031126616.png" alt="CSAPP Ch1-Ch3_12"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031126789.png" alt="CSAPP Ch1-Ch3_13"></p>
]]></content>
      <categories>
        <category>Computer</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch4 处理器体系结构</title>
    <url>/2024/04/01/Computer/CSAPP/CSAPP_Ch4%20%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="Ch4-处理器体系结构"><a href="#Ch4-处理器体系结构" class="headerlink" title="Ch4 处理器体系结构"></a>Ch4 处理器体系结构</h1><p>CSAPP自定义了一个Y86-64</p>
<h2 id="1、指令系统结构"><a href="#1、指令系统结构" class="headerlink" title="1、指令系统结构"></a>1、指令系统结构</h2><h3 id="（1）Programmer-Visible-State"><a href="#（1）Programmer-Visible-State" class="headerlink" title="（1）Programmer-Visible State"></a>（1）Programmer-Visible State</h3><p>可见状态：每条指令都会去读取或修改处理器某些部分，如下图所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011539557.png" alt="image-20240401153926464" style="zoom:33%;" />

<h3 id="（2）指令编码"><a href="#（2）指令编码" class="headerlink" title="（2）指令编码"></a>（2）指令编码</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011540371.png" alt="image-20240401154030167" style="zoom:33%;" />

<p>如上图最后一条：</p>
<ul>
<li><p>5 指令代码</p>
</li>
<li><p>0 指令功能</p>
</li>
<li><p>rA&#x2F;rB 寄存器指示符字节</p>
<ul>
<li><p>对寄存器编码，用16进制数<strong>0~0xE</strong>表示</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011531970.png" alt="image-20240401153138807" style="zoom:33%;" /></li>
</ul>
</li>
</ul>
<p>举例：（小端法存储）</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011536946.png" alt="image-20240401153606853" style="zoom:33%;" />

<h3 id="（3）处理异常"><a href="#（3）处理异常" class="headerlink" title="（3）处理异常"></a>（3）处理异常</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011540188.png" alt="image-20240401154055033" style="zoom:33%;" />

<h2 id="2、数字电路与处理器设计"><a href="#2、数字电路与处理器设计" class="headerlink" title="2、数字电路与处理器设计"></a>2、数字电路与处理器设计</h2><p>Register File 寄存器文件（寄存器堆）输出端口与ALU的输入端口串联。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011545861.png" alt="image-20240401154517784" style="zoom:33%;" />

<ul>
<li>读写操作共用地址线；</li>
<li>定义15个寄存器，因此地址线设计成4为即可；</li>
<li>we_（写使能信号）&#x2F;reeset（复位信号）</li>
</ul>
<p>下图为Register File的内部结构：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011547329.png" alt="image-20240401154700867" style="zoom: 50%;" />

<p>逻辑门，这些门结构可通过P管和N管（CMOS管）组合表现。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011548500.png" alt="image-20240401154803404" style="zoom: 33%;" />

<h2 id="3、Y86-64的顺序实现"><a href="#3、Y86-64的顺序实现" class="headerlink" title="3、Y86-64的顺序实现"></a>3、Y86-64的顺序实现</h2><p>举例：sum程序对应的汇编代码和二进制指令：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011554476.png" alt="image-20240401155427243" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011554403.png" alt="image-20240401155410294" style="zoom:50%;" />

<h3 id="（1）处理器六大阶段"><a href="#（1）处理器六大阶段" class="headerlink" title="（1）处理器六大阶段"></a>（1）处理器六大阶段</h3><ul>
<li><p>取指：分析指令；</p>
</li>
<li><p>译码：读寄存器文件；</p>
</li>
<li><p>执行：ALU执行 1)算术逻辑运算； 2)计算内存引用的有效地址； 3)执行push和pop指令；</p>
</li>
<li><p>访存：针对内存的读写操作；</p>
</li>
<li><p>写回：写寄存器文件；</p>
</li>
<li><p>更新PC：将PC的内容设置为下一条指令的地址。</p>
</li>
</ul>
<h3 id="（2）各阶段的硬件结构"><a href="#（2）各阶段的硬件结构" class="headerlink" title="（2）各阶段的硬件结构"></a>（2）各阶段的硬件结构</h3><p>总体结构（<strong>其中从valP到Data的橙色线错误，应该为从valC到Data！</strong>），对于顺序操作，这6个阶段在一个时钟周期内完成。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011906322.png" alt="image-20240401190602950"></p>
<ul>
<li><p>取指</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011619659.png" alt="image-20240401161926457" style="zoom: 33%;" />
</li>
<li><p>译码</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011621480.png" alt="image-20240401162105328" style="zoom: 33%;" />
</li>
<li><p>执行</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011622684.png" alt="image-20240401162222519" style="zoom: 33%;" />
</li>
<li><p>访存</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011622546.png" alt="image-20240401162255349" style="zoom: 33%;" />
</li>
<li><p>写回</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011623806.png" alt="image-20240401162342626" style="zoom: 33%;" />
</li>
<li><p>更新PC</p>
<ol>
<li>call指令常数字段；</li>
<li>在访存阶段从内存（栈）中读出的返回地址；</li>
<li>跳转指令的常数字段；</li>
<li>当前PC+当前指令长度。</li>
</ol>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011624170.png" alt="image-20240401162430019" style="zoom: 33%;" /></li>
</ul>
<h3 id="（3）举例"><a href="#（3）举例" class="headerlink" title="（3）举例"></a>（3）举例</h3><p>举例1：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011600331.png" alt="image-20240401160018132" style="zoom: 33%;" />

<p>举例2：（下图中的<strong>valE&#x3D;0+8</strong>是因为寄存器文件的写入端与ALU的输出端相连）</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011605541.png" alt="image-20240401160504446" style="zoom:33%;" />

<p>举例3：</p>
<p>该指令为<strong>将寄存器 <code>%rsp</code> 中的值存储到以 <code>%rbx</code> 寄存器的值为基地址偏移100个字节的内存单元中</strong>，因此不涉及写寄存器操作。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011608224.png" alt="image-20240401160808121" style="zoom:33%;" />

<p>举例4：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011612305.png" alt="image-20240401161239187" style="zoom:33%;" />

<p>举例5：跳转指令</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011613911.png" alt="image-20240401161359730" style="zoom:33%;" />

<h2 id="4、流水线"><a href="#4、流水线" class="headerlink" title="4、流水线"></a>4、流水线</h2><h3 id="（1）属性及原理"><a href="#（1）属性及原理" class="headerlink" title="（1）属性及原理"></a>（1）属性及原理</h3><p>假设有一个非流水线设计，如下图所示，该系统的吞吐量约为<strong>3.12GIPS</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011659177.png" alt="image-20240401165925089" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011659832.png" alt="image-20240401165943770" style="zoom:33%;" />

<p>若采用流水线设计，将组合逻辑单元阶段分为三个阶段，每个阶段120ps，此时吞吐量为<strong>8.33GIPS</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011701350.png" alt="image-20240401170120155" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011702592.png" alt="image-20240401170206480" style="zoom:33%;" />

<ul>
<li>流水线的局限性：此时各个阶段的延迟可能都是不等的，此时时钟的速率受最慢阶段的限制（木桶效应）：</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011706596.png" alt="image-20240401170631392" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011836974.png" alt="image-20240401183610851" style="zoom:33%;" />

<ul>
<li>此外，过深的流水线会导致系统性能的下降。实际中的指令间存在数据依赖，以及指令控制流造成的控制依赖。</li>
</ul>
<h3 id="（2）硬件结构"><a href="#（2）硬件结构" class="headerlink" title="（2）硬件结构"></a>（2）硬件结构</h3><p>在顺序实现的硬件结构中，取指发生在时钟周期刚开始时，而更新PC发生在时钟快要结束时，如下图所示（<strong>橙色线需勘误</strong>）。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011906322.png" alt="image-20240401190602950"></p>
<p>为了实现流水线的硬件结构，将更新PC的操作从时钟周期快要结束时移动到时钟刚开始执行时（即最左侧新增的寄存器）</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011910589.png" alt="image-20240401191048453"></p>
<p>从宏观上来说，也就是在各个阶段前加入流水线寄存器。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011911529.png" alt="image-20240401191145449"></p>
<p>其展开后的整体逻辑如下：</p>
<ul>
<li>寄存器F保存PC的预测值；</li>
<li>寄存器D保存刚取出的指令信息；</li>
<li>寄存器E保存最新译码指令的状态以及从寄存器文件中读出的数值；</li>
<li>寄存器M保存最新执行指令的结果，包含ALU处理的那三类；</li>
<li>寄存器W保存访存执行的结果，而反馈路径将结果写回寄存器文件。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011924576.png" alt="image-20240401192450295"></p>
<h3 id="（3）数据冒险"><a href="#（3）数据冒险" class="headerlink" title="（3）数据冒险"></a>（3）数据冒险</h3><p>在下图的时钟周期4中，读取到的值并非所期望的10和3，而是默认值0，这是因为此时指令1处于访存阶段，10仍未写回%rdx中；而指令2处于执行阶段，3也未写回%rax。这种情况称为<strong>冒险&#x2F;冲突</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011937082.png" alt="image-20240401193745913" style="zoom:50%;" />

<p>解决方法：</p>
<ul>
<li><p>暂停技术</p>
<ul>
<li><p>在D阶段读取寄存器的ID值，分别于执行阶段、访存阶段及写回阶段所执行指令的目的寄存器ID比较，若相等，则存在数据相关，需要在译码阶段等待；</p>
</li>
<li><p>方式为插入气泡：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011941588.png" alt="image-20240401194157407"></p>
</li>
</ul>
</li>
<li><p>数据转发&#x2F;旁路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011943090.png" alt="image-20240401194351754"></p>
</li>
</ul>
<h3 id="（4）控制冒险"><a href="#（4）控制冒险" class="headerlink" title="（4）控制冒险"></a>（4）控制冒险</h3><p>控制冒险的情况例举如下：</p>
<ul>
<li>若取出的是ret指令，下一条指令的地址需要等到访存结束后才能从栈中取出；  —— 解决：暂停处理新指令</li>
<li>若取出的是分支条件指令，需要经过执行阶段后才能确定是否跳转。—— 解决：分支预测（预测其总是跳转或总是不跳转）</li>
</ul>
<p>暂停和插入气泡是如何实现的？</p>
<p>流水线寄存器是通过时钟的上升沿来改变输出的值，遇到上升沿时，加载其输入作为新的输出。因此，给每个流水线寄存器引入stall信号和bubble信号，<strong>当需要暂停时</strong>，将halt信号设为1，寄存器保存原状态；<strong>当需要插入气泡时</strong>，将bubble信号设为1，寄存器的状态设置成某个固定的复位配置，等效于nop。</p>
<h2 id="5、Y86-64的流水线实现"><a href="#5、Y86-64的流水线实现" class="headerlink" title="5、Y86-64的流水线实现"></a>5、Y86-64的流水线实现</h2><h3 id="（1）取指阶段"><a href="#（1）取指阶段" class="headerlink" title="（1）取指阶段"></a>（1）取指阶段</h3><ul>
<li><p>顺序执行：valP &#x3D; 当前PC + 指令长度</p>
</li>
<li><p>跳转执行：valP &#x3D; （指令中的常数字段）valC</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404012055519.png" alt="image-20240401205520162" style="zoom:50%;" />
</li>
<li><p>为了应对出错的情况，设置<strong>select PC部件</strong>纠错：</p>
<ul>
<li><p>若取到<strong>ret</strong>，需要等到译码、执行和访存后，才能从内存中读到正确的返回地址，此时的改正方法为：<strong>将流水线寄存器W中的访存结果（W_valM）作为下一条指令的地址；</strong></p>
</li>
<li><p>若取到<strong>条件分支指令</strong>，需要等到译码、执行后才能判断是否跳转，此时的改正方法为：<strong>根据Cnd信号判断是否跳转，若不跳转，则从流水线寄存器M读取（M_valA）下一条指令的地址</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404012104691.png" alt="image-20240401210442459"></p>
</li>
</ul>
</li>
</ul>
<h3 id="（2）译码阶段"><a href="#（2）译码阶段" class="headerlink" title="（2）译码阶段"></a>（2）译码阶段</h3><ul>
<li><p>需要判断是1）<strong>直接使用转发的数据</strong>；还是2）<strong>从寄存器文件中读取数据</strong>。</p>
</li>
<li><p>哪些数据需要转发？</p>
<ul>
<li><strong>ALU的输出结果</strong><ul>
<li>正常需要经访存和写回后，才能完成寄存器的数据更新；</li>
<li>采用转发设计时，ALU的输出结果可以马上作为译码阶段的结果。</li>
</ul>
</li>
<li><strong>内存的输出数据</strong><ul>
<li>和ALU类似</li>
</ul>
</li>
<li><strong>访存阶段时，寄存器写入端口E还没有写入的数据</strong></li>
<li><strong>写回阶段时，寄存器写入端口M还没有写入的数据</strong></li>
<li><strong>写回阶段时，寄存器写入端口E还没有写入的数据</strong></li>
</ul>
</li>
<li><p>每个转发源包括：1）<strong>寄存器的ID值</strong>；2）<strong>转发数据</strong>。</p>
</li>
<li><p>Sel+Fwd A与Fwd B相比，<strong>多了一个valP输入</strong>。这里将valA与valP合并，可以合并的原因是只有函数调用指令和跳转指令在后面的阶段才需要用到valP，而这两类指令并不需要从A端口读取数据（见3(3).举例5.跳转指令）</p>
<ul>
<li>valP是顺序执行时下一条指令的地址，而跳转执行指令在译码阶段不需要valP；</li>
<li>根据icode判断是否为这两类指令，如果是则可以进行合并。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404012117651.png" alt="image-20240401211720521"></p>
</li>
</ul>
<p>其他阶段和顺序设计相差不大，不再赘述。</p>
<h2 id="6、流水线的控制逻辑"><a href="#6、流水线的控制逻辑" class="headerlink" title="6、流水线的控制逻辑"></a>6、流水线的控制逻辑</h2><h3 id="（1）加载-使用冒险"><a href="#（1）加载-使用冒险" class="headerlink" title="（1）加载&#x2F;使用冒险"></a>（1）加载&#x2F;使用冒险</h3><h3 id="（2）分支预测发生错误"><a href="#（2）分支预测发生错误" class="headerlink" title="（2）分支预测发生错误"></a>（2）分支预测发生错误</h3><h3 id="（3）返回阶段的处理"><a href="#（3）返回阶段的处理" class="headerlink" title="（3）返回阶段的处理"></a>（3）返回阶段的处理</h3>]]></content>
      <categories>
        <category>Computer</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch5 优化程序性能</title>
    <url>/2024/04/03/Computer/CSAPP/CSAPP_Ch5%20%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>



<h1 id="Ch5-优化程序性能"><a href="#Ch5-优化程序性能" class="headerlink" title="Ch5 优化程序性能"></a>Ch5 优化程序性能</h1><h2 id="1、优化程序性能"><a href="#1、优化程序性能" class="headerlink" title="1、优化程序性能"></a>1、优化程序性能</h2><h3 id="（1）局限性"><a href="#（1）局限性" class="headerlink" title="（1）局限性"></a>（1）局限性</h3><ul>
<li><strong>如果编译器无法确定两个指针是否指向同一个位置，那么编译器会假设所有情况都有可能发生，反而限制了优化策略。</strong></li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404012134539.png" alt="image-20240401213441380" style="zoom:33%;" />

<p>当编译器在优化代码时，会假设xp和yp有可能指向同一个内存位置，如下图所示，此时add1 res&#x3D;4x，add2 res&#x3D;3x，因此不能将add2用于优化add1。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404012134793.png" alt="image-20240401213457648" style="zoom:33%;" />

<ul>
<li><strong>函数调用影响优化策略</strong></li>
</ul>
<p>如下图所示，大多数编译器不会把func1优化为func2（注意func2返回0是因为counter为后++，先返回再++）。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021006812.png" alt="image-20240402100639099" style="zoom:33%;" />

<h3 id="（2）优化方式"><a href="#（2）优化方式" class="headerlink" title="（2）优化方式"></a>（2）优化方式</h3><ul>
<li><p>1）代码移动</p>
<ul>
<li>循环不变式外提，比如在执行for循环前先计算出数组长度；</li>
</ul>
</li>
<li><p>2）优化函数调用</p>
<ul>
<li><p>举例：在循环中将函数get_vec_element变为直接数组访问，这样反而降低了效率，这是因为每次操作数组时需要两次读内存和一次写内存：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021022591.png" alt="image-20240402102218521"></p>
</li>
<li><p>基于此再进行优化，设置临时变量，直到循环结束再写入，此时只需要一次读内存，性能得到了很大的提升：</p>
<ul>
<li><strong>这里的acc是临时变量， 通常情况下，临时变量会被保存在栈帧（栈帧是用来存储函数调用期间的局部变量和其他临时数据的一块内存区域）中， 由于 acc 在循环中频繁使用，并且在每次迭代中都需要更新，将其保存在寄存器中可以提高访问速度，避免了频繁的内存访问操作。寄存器的访问速度比内存更快，因此可以加快循环的执行速度；</strong></li>
<li><strong>由于循环中的代码会被频繁执行，对循环内的变量进行优化以提高性能尤为重要。将累加器保存在寄存器中可以减少内存访问次数，从而提高代码的执行效率。</strong></li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021022289.png" alt="image-20240402102255146" style="zoom:33%;" /></li>
</ul>
</li>
</ul>
<h2 id="2、现代处理器"><a href="#2、现代处理器" class="headerlink" title="2、现代处理器"></a>2、现代处理器</h2><p>在1的基础上，考虑利用处理器的微体系结构进行优化。现代处理器可以实现多指令并行。</p>
<h3 id="（1）功能单元"><a href="#（1）功能单元" class="headerlink" title="（1）功能单元"></a>（1）功能单元</h3><ul>
<li>指令控制单元（Instruction Control Unit，ICU）<ul>
<li>从内存中读取指令序列并译码，之后进行一系列操作</li>
<li>退役单元，控制着寄存器文件<ul>
<li>若指令执行完毕，相应更新寄存器文件；</li>
<li>若不该执行该条指令，则丢弃所有运算结果。</li>
</ul>
</li>
</ul>
</li>
<li>执行单元（Execution Unit，EU）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021039315.png" alt="image-20240402103925031"></p>
<h3 id="（2）功能单元的性能衡量指标"><a href="#（2）功能单元的性能衡量指标" class="headerlink" title="（2）功能单元的性能衡量指标"></a>（2）功能单元的性能衡量指标</h3><ul>
<li>延迟（Latency）：完成运算需要的总时间</li>
<li>发射（Isuue）：两次运算间间隔的最小周期数</li>
<li>容量（Capacity）：执行该运算的功能单元的数量</li>
</ul>
<p>CPE&#x2F;Clocks Per Instruction，每条指令所需的时钟周期数，衡量计算机指令执行效率的一个指标。</p>
<p>延迟界限和吞吐量界限的CPE值</p>
<ul>
<li>延迟界限：在给定的工作负载下，系统性能受到的主要限制是每个任务或指令的执行时间（延迟）的上限<ul>
<li>对于任何必须严格按照顺序执行的合并运算，延迟界限给出了所需要的最小的CPE值</li>
</ul>
</li>
</ul>
<p>吞吐量界限：在给定的工作负载下，系统性能受到的主要限制是系统的总体吞吐量（Throughput）的上限</p>
<ul>
<li>吞吐量是指单位时间内完成的任务数或指令数，它反映了系统的处理能力和效率</li>
<li>吞吐量界限通常与系统资源的利用率相关联，包括处理器的吞吐量、内存带宽、缓存命中率等因素</li>
</ul>
]]></content>
      <categories>
        <category>Computer</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch7 链接</title>
    <url>/2024/04/03/Computer/CSAPP/CSAPP_Ch7%20%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="Ch7-链接"><a href="#Ch7-链接" class="headerlink" title="Ch7 链接"></a>Ch7 链接</h1><h2 id="1、编译器驱动程序"><a href="#1、编译器驱动程序" class="headerlink" title="1、编译器驱动程序"></a>1、编译器驱动程序</h2><p>链接（Linking）：<strong>将可重定位目标文件以及必要的系统文件组合起来，生成一个可执行文件</strong>，并加载到内存执行。</p>
<ul>
<li>构造大型程序时，容易遇到<strong>缺少库文件或库文件的版权不兼容导致连接错误</strong>的问题，因此需要理解链接器是如何用库文件来解析引用的；</li>
<li>遇到一些危险的编译错误；</li>
<li>理解语言的作用域如何实现；</li>
<li>理解其他重要的系统概念；</li>
<li>更好地利用共享库。</li>
</ul>
<p>编译系统四步：</p>
<ul>
<li><p>预处理</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021919552.png" alt="image-20240402191932454" style="zoom: 33%;" />
</li>
<li><p>编译</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021920420.png" alt="image-20240402192004172" style="zoom:33%;" />
</li>
<li><p>汇编</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021920745.png" alt="image-20240402192028410" style="zoom:33%;" />
</li>
<li><p>链接</p>
<ul>
<li><p>crt  –  c runtime</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021920762.png" alt="image-20240402192057662" style="zoom:33%;" />
</li>
<li><p>ld  –  链接器</p>
</li>
<li><p>-static – 静态链接</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021921378.png" alt="image-20240402192107260" style="zoom:33%;" /></li>
</ul>
</li>
</ul>
<h2 id="2、可重定位目标文件"><a href="#2、可重定位目标文件" class="headerlink" title="2、可重定位目标文件"></a>2、可重定位目标文件</h2><p>可重定位文件的组成：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021927625.png" alt="image-20240402192742394" style="zoom: 50%;" />

<p>本节举例用到的程序：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022023749.png" alt="image-20240402202308661" style="zoom:33%;" />

<h3 id="（1）ELF-header"><a href="#（1）ELF-header" class="headerlink" title="（1）ELF header"></a>（1）ELF header</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021928876.png" alt="image-20240402192847629" style="zoom:50%;" />

<ul>
<li><p>Magic（魔数），用于确定文件类型，操作系统在加载可执行文件时会确认魔数是否正确。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021930868.png" alt="image-20240402193033694" style="zoom:33%;" />
</li>
<li><p>start of section headers：为section header table的起始地址</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021936802.png" alt="image-20240402193640661" style="zoom:33%;" /></li>
</ul>
<h3 id="（2）Section-header-table"><a href="#（2）Section-header-table" class="headerlink" title="（2）Section header table"></a>（2）Section header table</h3><p>查看表的全部内容：<code>readelf -S main.o</code></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022030317.png" alt="image-20240402203056995" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022020376.png" alt="image-20240402202016269" style="zoom:50%;" />

<ul>
<li><p><strong><code>.text</code> Section：</strong>存放<strong>已经编译好的机器代码</strong>，使用<code>objdump -s -d main.o</code>查看</p>
</li>
<li><p><strong><code>.data</code> Section：</strong>存放<strong>已初始化的全局变量和静态变量</strong>的值</p>
</li>
<li><p><strong><code>.bss</code> Section：</strong>存放<strong>未初始化的全局变量和静态变量</strong>的值</p>
<ul>
<li>实际上bss section并不占据实际的空间，它仅仅只是一个占位符</li>
<li>区分已初始化和未初始化的变量是为了节省空间<ul>
<li><strong>节省空间</strong>的含义：在可执行文件中不存储未初始化的全局变量和静态变量的实际初始值，而是延迟到程序运行时动态分配内存并初始化为零，从而减小可执行文件的体积。</li>
</ul>
</li>
<li><strong>和COMMON的区别</strong><ul>
<li>COMMON：未初始化的全局变量</li>
<li>.bss：未初始化的静态变量，初始化为0的全局或静态变量</li>
</ul>
</li>
</ul>
</li>
<li><p><code>.rodata</code> Section：ro-read only，如printf语句中的格式串和switch语句中的跳转表</p>
</li>
<li><p><strong>其余Section：</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022020768.png" alt="image-20240402202046576" style="zoom: 50%;" />
</li>
<li><p><strong><code>.symtab</code> Section</strong></p>
<ul>
<li><p>使用<code>readelf -s main.o</code>命令查看符号表的内容</p>
<ul>
<li>ndx 字段则用于指示该 section 在 section header table 中的索引</li>
<li>由于printf只是在main.c中被引用，并非定义在main.c中，因此其Ndx为UND(Undefine)类型</li>
<li>OBJECT类型表示符号为数据对象</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022030660.png" alt="image-20240402203002144"></p>
</li>
<li><p><strong>有三种类型的符号</strong></p>
<ul>
<li>全局符号：由<strong>该模块</strong>定义，同时能被其他模块引用</li>
<li>外部符号：由<strong>其他模块</strong>定义，同时能被其他模块引用</li>
<li>局部符号：由<strong>该模块</strong>定义，不能被其他模块引用<ul>
<li>任何带有<code>static</code>属性声明的全局变量或函数都是模块私有的</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>强符号与弱符号</strong></p>
<ul>
<li>强符号：函数和已初始化的全局变量</li>
<li>弱符号：未初始化的全局变量</li>
</ul>
</li>
<li><p><strong>符号解析</strong></p>
<ul>
<li><p><strong>当编译器遇到一个不是在当前模块中定义的符号时，会假设该符号是在其他模块中定义的。此时仅执行编译和汇编，而不执行链接的话是没有问题的</strong></p>
</li>
<li><p>找不到符号定义时的报错：</p>
<p><img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240402204455103.png" alt="image-20240402204455103"></p>
</li>
<li><p>多个可重定位文件中定义了同名的全局符号，有以下三种情况：</p>
<ul>
<li><p><strong>多个同名强符号一起出现——不允许</strong></p>
</li>
<li><p>一个强符号和多个同名弱符号——允许</p>
</li>
<li><p>多个同名弱符号——允许</p>
<ul>
<li><p>但容易发生不易发现的错误，如下图所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022103873.png" alt="image-20240402210359483" style="zoom: 33%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（3）静态库"><a href="#（3）静态库" class="headerlink" title="（3）静态库"></a>（3）静态库</h3><ul>
<li><p>定义：在Linux系统中，静态库以一种称为archive的特殊文件格式存放在磁盘上，如<code>libc.a</code>。<strong>archive文件是一组可重定位目标文件的集合。</strong></p>
</li>
<li><p>举例：如何构造一个静态库文件<code>libvector.a</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022111482.png" alt="image-20240402211100296"></p>
<p>​	之后就可以在链接时使用该静态库文件：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022111559.png" alt="image-20240402211151493" style="zoom:50%;" />
</li>
<li><p><strong>静态库的链接过程</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022113150.png" alt="image-20240402211346051" style="zoom:50%;" />
</li>
<li><p><strong>静态库的解析过程</strong></p>
<ul>
<li><p>链接器<strong>从左到右</strong>按命令行中出现的顺序来扫描可重定位文件和静态库文件（libc.a可以不用显式写出）</p>
<ul>
<li><p>由于是按从左到右的顺序扫描，因此命令行中各文件的输入顺序十分重要，遵循<strong>调用者在前</strong>的顺序</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022125679.png" alt="image-20240402212530449" style="zoom:50%;" /></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">linux&gt; gcc -<span class="type">static</span> -o prog main.o ./libvector.a [libc.a]</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理三个集合，直至集合U和D不再发生变化，<strong>仅当集合U为空时才会链接正确</strong></p>
<ul>
<li>集合E：扫描中发现的可重定位目标文件</li>
<li>集合U：引用了但尚未定义的符号（也即是在其他模块中定义的符号）<ul>
<li>放入目标文件的符号表中未定义，仅引用的符号</li>
<li><strong>而尝试会用扫描到的静态库文件解析集合U中未定义的符号，找到其相关定义后转移到集合D中</strong></li>
</ul>
</li>
<li>集合D：已经定义了的符号</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>重定位（Relocation）</strong></p>
<ul>
<li><p>链接器合并输入模块，并为每个符号分配运行时地址</p>
</li>
<li><p>步骤</p>
<ul>
<li><p>重定位section和符号定义</p>
<ul>
<li>将所有可重定位目标文件中<strong>相同类型的section合并为一个新的section</strong></li>
</ul>
</li>
<li><p>重定位section中的符号引用，使其指向正确的运行地址</p>
<ul>
<li><p>依赖于可重定位条目的数据结构</p>
</li>
<li><p>由于汇编器在生成可重定位目标文件时，并不知道数据和代码在内存的什么位置，同时也不知道该模块所引用的外部定义的函数以及全局变量的位置。因此，<strong>当遇到最终位置不确定的符号引用时，就产生一个可重定位条目，告诉链接器在合成可执行文件时应该如何修改这个引用</strong></p>
<ul>
<li><p>关于代码的重定位条目放在<code>.rel.text</code>；已初始化数据的重定位条目放在<code>.rel.data</code></p>
</li>
<li><p>重定位条目的结构体定义</p>
<ul>
<li>offset：被修改的引用的section偏移量</li>
<li>type：重定位条目的类型，此处仅关心图中两种类型</li>
<li>symbol：表示被修改的引用时是哪一个符号</li>
<li>addend：常数，用于对某些类型的重定位条目进行偏移调整</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031016083.png" alt="image-20240403101650663" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>举例说明：此处ref_addr为运行时的地址；而*ref_ptr相当于计算的是当前PC要加上多少才能跳转到sum函数的地址处</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031022768.png" alt="image-20240403102210671" style="zoom: 80%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>举例：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031034256.png" alt="image-20240403103405171" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031034682.png" alt="image-20240403103432537" style="zoom:50%;" />

<h3 id="（4）可执行目标文件"><a href="#（4）可执行目标文件" class="headerlink" title="（4）可执行目标文件"></a>（4）可执行目标文件</h3><ul>
<li><strong>总体概述</strong></li>
</ul>
<p>下图左侧为可执行（目标）文件，右图为可重定位目标文件</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031035608.png" alt="image-20240403103531280"></p>
<p>具体来说，<strong>代码段和数据段会在执行时加入内存，而剩余的如符号表、调试信息等不会加入内存。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031036213.png" alt="image-20240403103641109" style="zoom:50%;" />

<ul>
<li><p><strong>段头部表（Segment header table）</strong></p>
<ul>
<li><p>描述代码段、数据段与内存的映射关系</p>
</li>
<li><p>末尾的<code>r-x/rw-</code>表示是否可读、可写以及可执行；</p>
</li>
<li><p><code>off</code>表示这个段在可执行文件中的偏移量</p>
</li>
<li><p><code>vaddr/paddr</code>表示该段在内存中的开始地址</p>
</li>
<li><p><code>filesz</code>表示该段的大小</p>
</li>
<li><p><code>memsz</code>表示运行时该段在内存中的大小，包括ELF header、程序头部表以及.init、.text和.rodata section的内容。<strong>注意：数据段中memsz比filesz多8个字节，是为了存储.bss的数据（仅运行时分配内存）</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031044703.png" alt="image-20240403104441234"></p>
</li>
</ul>
</li>
<li><p><strong>程序的加载过程（大致）</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031049727.png" alt="image-20240403104941601"></p>
</li>
</ul>
<h3 id="（5）动态链接共享库"><a href="#（5）动态链接共享库" class="headerlink" title="（5）动态链接共享库"></a>（5）动态链接共享库</h3><p>Linux中的<code>.so</code>文件和Windows中的<code>.dll</code>文件。</p>
<ul>
<li><p><strong>如何构造共享库</strong></p>
<ul>
<li><p>-shared</p>
</li>
<li><p>-fpic：位置无关选项，这样共享库才能被加载到任意的内存位置</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031113305.png" alt="image-20240403111355228" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031114886.png" alt="image-20240403111421652" style="zoom:50%;" /></li>
</ul>
</li>
<li><p><strong>动态链接过程</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031115921.png" alt="image-20240403111521660" style="zoom: 50%;" /></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032057373.png" alt="image-20240403205722302"></p>
]]></content>
      <categories>
        <category>Computer</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch6 存储器层次结构</title>
    <url>/2024/04/03/Computer/CSAPP/CSAPP_Ch6%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="Ch6-存储器层次结构"><a href="#Ch6-存储器层次结构" class="headerlink" title="Ch6 存储器层次结构"></a>Ch6 存储器层次结构</h1><h2 id="1、存储技术"><a href="#1、存储技术" class="headerlink" title="1、存储技术"></a>1、存储技术</h2><h3 id="（1）随机访问存储器（RAM）"><a href="#（1）随机访问存储器（RAM）" class="headerlink" title="（1）随机访问存储器（RAM）"></a>（1）随机访问存储器（RAM）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021437441.png" alt="image-20240402143708229"></p>
<ul>
<li><p>静态RAM（SRAM）</p>
<ul>
<li>将每个bit位的信息存储在一个双稳态的存储器单元内，每个存储体单元由6个晶体管实现</li>
</ul>
</li>
<li><p>动态RAM（DRAM）</p>
<ul>
<li><p>电容充电，将每个bit位的存储对应1个电容和1个晶体管</p>
</li>
<li><p>存在缺陷：漏电时在10-100毫秒失去电荷，内存系统需要不断读出数据并重写，通过刷新来保存数据</p>
</li>
<li><p>举例：</p>
<ul>
<li>16：超单元（即supercell，DRAM的单个存储单元）个数</li>
<li>8：每个超单元存储8比特数据</li>
<li>下图分行、列两次发送地址，虽然增加了访问时间，原因<strong>DRAM存储结构为二位阵列而非一维数组，可以减少地址引脚数量</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021444685.png" alt="image-20240402144425635"></p>
</li>
<li><p>DRAM0-DRAM7以此存储低八位字节至最高八位字节，当处理器向内存控制器发起读取数据的请求时，内存控制器将地址转换为超单元地址，内存模块将i和j广播给每个DRAM，从而找到对应的数据，最终返回一个64bit的数据：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021450063.png" alt="image-20240402145000491"></p>
</li>
</ul>
</li>
</ul>
<h3 id="（2）机械磁盘"><a href="#（2）机械磁盘" class="headerlink" title="（2）机械磁盘"></a>（2）机械磁盘</h3><p>依靠盘片存储数据，表面涂有磁性记录材料。如下图共3个盘片，即6个盘面存储数据。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021453039.png" alt="image-20240402145348856" style="zoom: 50%;" />

<p>盘片表面由一圈圈的磁道组成。每一圈磁盘划分为多个扇区（通常存储512字节），扇区间存在间隙用于存储扇区的标识信息。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021457089.png" alt="image-20240402145714941" style="zoom:33%;" />

<p>每个盘片有独立的读&#x2F;写头，所有读&#x2F;写头连接在一个<strong>传动臂</strong>上，只能在半径方向上移动来读写数据，称为<strong>寻道</strong>。所有的读&#x2F;写头必须垂直排列、一致行动。读&#x2F;写头距离表盘的距离约0.1微米。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021458391.png" alt="image-20240402145841146" style="zoom: 33%;" />

<p>磁盘访问数据花费时间：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021513461.png" alt="image-20240402151318110" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021515859.png" alt="image-20240402151514499" style="zoom:50%;" />

<h3 id="（3）固态硬盘"><a href="#（3）固态硬盘" class="headerlink" title="（3）固态硬盘"></a>（3）固态硬盘</h3><p>固态磁盘由一个或多个闪存芯片组成，使用闪存芯片替代传动臂加盘片这种机械工作方式。</p>
<p>Flash translation layer：FTL，闪存转换层，将操作系统对逻辑块的请求翻译成对底层物理设备的访问。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021515854.png" alt="image-20240402151543579"></p>
<ul>
<li><p>闪存芯片（falsh chip）</p>
<ul>
<li><p>基于Nand Flash实现，下图的block与逻辑块无关。</p>
</li>
<li><p>包含读、写和擦除三个操作。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021521937.png" alt="image-20240402152128719"></p>
</li>
</ul>
</li>
</ul>
<h3 id="（4）程序的局部性"><a href="#（4）程序的局部性" class="headerlink" title="（4）程序的局部性"></a>（4）程序的局部性</h3><ul>
<li>时间局部性<ul>
<li>若被引用过的内存位置很可能在不远的将来还会被多次引用，则具有较好的时间局部性；</li>
</ul>
</li>
<li>空间局部性<ul>
<li>若一个内存位置被引用一次后，程序在不远的将来引用其附近的一个内存位置，则具有较好的时间局部性；</li>
</ul>
</li>
</ul>
<h2 id="2、存储器层次结构"><a href="#2、存储器层次结构" class="headerlink" title="2、存储器层次结构"></a>2、存储器层次结构</h2><p>结构如下图所示，基本思想是上层存储设备作为下层存储设备的缓存。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021433966.png" alt="image-20240402143353405"></p>
<h3 id="（1）cache"><a href="#（1）cache" class="headerlink" title="（1）cache"></a>（1）cache</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021603503.png" alt="image-20240402160342276"></p>
<ul>
<li><p>缓存命中（cache Hit）</p>
<ul>
<li>当程序需要第k+1层的某个数据对象d时，它首先从第k层的数据块中检索是否包含目标数据d的副本。若第k层包含目标数据d，称为缓存明中，否则称之为缓存不命中（cache Miss）</li>
<li>当发生不命中时，第k层的缓存要从第k+1层取出包含目标数据的块；若第k层缓存已满，会覆盖已有的块，被替换的块称为牺牲块。</li>
<li>步骤分三步：<ul>
<li>set selection（组选择）</li>
<li>line matching（行匹配）</li>
<li>word extraction（字抽取）</li>
</ul>
</li>
</ul>
</li>
<li><p>内部结构</p>
<ul>
<li><p>划分为S个Set，每个Set包含E行cache Line，地址为m位。</p>
</li>
<li><p>每行cache Line包含valid（数据是否有效）、Tag（目标数据是否存在在当前cache Line中）和大小为B的数据副本</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021607690.png" alt="image-20240402160725448" style="zoom: 50%;" />
</li>
<li><p>cache通过下面的方式知道自己是否包含目标数据的副本</p>
<ul>
<li>假设目标数据的地址A长度为m位，该地址会被S和B分为3个字段，如下图所示。<ul>
<li><strong>Set index确定目标数据存储在哪个set中</strong></li>
<li><strong>Tag确定目标数据在set的哪一行（此时valid必须为1）</strong></li>
<li><strong>Block index指示块偏移量，确定目标数据的确切数据</strong></li>
</ul>
</li>
<li>cache用中间的位作为Set索引，是为了避免使用高位作为索引时造成映射到相同的区域。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021609317.png" alt="image-20240402160935274" style="zoom: 50%;" />
</li>
<li><p>Issues With Writes</p>
<ul>
<li>写命中（Write Hit）<ul>
<li>写穿透（write-through）：写入cache的同时写回内存（更低一级cache），这样cache在替换可以直接丢掉旧的</li>
<li>写回（write-back）：只写入cache，在cache需要替换时才写回内存</li>
</ul>
</li>
<li>写不命中（Write Miss）<ul>
<li>写分配（write-allocate）：先把目标数据所在的块从内存（更低一级cache）加载到cache中，然后再往cache中写</li>
<li>写不分配（no-write-allocate）：绕开cache，直接把要写的内容写到内存里</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（2）直接映射高速缓存"><a href="#（2）直接映射高速缓存" class="headerlink" title="（2）直接映射高速缓存"></a>（2）直接映射高速缓存</h3><ul>
<li><p>直接映射：每个Set只包含1行cache line</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021611962.png" alt="image-20240402161142799" style="zoom:50%;" />
</li>
<li><p>举例说明：假设存在一个cache，大小为(4, 1, 2, 4)，则整个地址空间可以由0-15标记，而标记位Tag和索引位Index连起来可以唯一的标识每一个内存块。</p>
<ul>
<li><p><strong>s1、组选择</strong>：根据Set index进行选择</p>
</li>
<li><p><strong>s2、行匹配</strong>：</p>
<ul>
<li>1、valid是否为1？</li>
<li>2、对比cache Line中的Tag与地址中的Tag是否一致</li>
</ul>
</li>
<li><p><strong>s3、字抽取</strong></p>
<ul>
<li>若一致，根据Block offset找到确切的地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021620864.png" alt="image-20240402162006768" style="zoom: 50%;" />

<ul>
<li><p>举例说明：假设有一个cache如下图所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021640771.png" alt="image-20240402164025528" style="zoom: 50%;" />

<ul>
<li>当地址是4位时，整个地址空间用编号0-15表示</li>
<li>地址中的Tag和Index二者结合标识唯一的内存块（即右侧的Block number）。由于<strong>每个内存块由两个字节组成</strong>，因此整个内存空间被分成8个块</li>
<li>由于cache中仅包含4个Set，因此会出现两个内存块映射到同一个Set的情况</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021636016.png" alt="image-20240402163600762"></p>
</li>
<li><p><strong>冲突不命中</strong>：内存中的不同块映射到cache的同一个Set中，此时不同块之间交替引用，即使cache中还存在空闲的块，也依旧造成不命中。</p>
</li>
</ul>
<h3 id="（3）组相联-全相联高速缓存"><a href="#（3）组相联-全相联高速缓存" class="headerlink" title="（3）组相联&#x2F;全相联高速缓存"></a>（3）组相联&#x2F;全相联高速缓存</h3><ul>
<li><p>组相联cache的每个set包含多个cache line，下图是一个2路组相联，其中C为cache的容量。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021659281.png" alt="image-20240402165930042" style="zoom:50%;" />
</li>
<li><p>全相联cache只有一个set</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021859412.png" alt="image-20240402185940143" style="zoom:50%;" /></li>
</ul>
]]></content>
      <categories>
        <category>Computer</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch8 异常控制流</title>
    <url>/2024/04/03/Computer/CSAPP/CSAPP_Ch8%20%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="Ch8-异常控制流"><a href="#Ch8-异常控制流" class="headerlink" title="Ch8 异常控制流"></a>Ch8 异常控制流</h1><h2 id="1、异常控制流"><a href="#1、异常控制流" class="headerlink" title="1、异常控制流"></a>1、异常控制流</h2><h3 id="（1）控制流"><a href="#（1）控制流" class="headerlink" title="（1）控制流"></a>（1）控制流</h3><p>处理器上电运行到断点关机的过程中，如下图，从ak到ak+1的过渡称为控制转移。最简单的控制流是平滑序列，其中平滑指内存中地址相邻，当出现跳转、函数调用和返回这类指令时会造成“不平滑”，会导致突变。</p>
<p><strong>异常控制流（Exception Control Flow）</strong>指的是程序执行过程中由于发生异常而导致的控制流程的变化。在计算机系统中，异常是一种特殊的事件，它表示了一种不寻常的情况，可能需要程序或者操作系统采取相应的措施来处理。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031243585.png" alt="image-20240403124332377" style="zoom: 33%;" />

<h2 id="2、异常"><a href="#2、异常" class="headerlink" title="2、异常"></a>2、异常</h2><ul>
<li>定义：在执行某个指令时，可能发生一个与当前指令有关或无关的<strong>事件</strong>，此时处理器将从执行应用程序切换到<strong>异常处理程序</strong>，待起处理完成后，根据引起异常的事件类型选择是否返回。</li>
<li>对异常的处理类似于一个间接的函数调用，但存在一些细微的差异：<ul>
<li>函数调用时，在跳转到目前函数之前，处理器首先将返回地址压入栈中；而处理器在处理异常时，会<strong>把处理器额外的一些状态压到栈中</strong></li>
<li>此外，若控制是从用户态转向内核态，那么所有的这些内容会被压到<strong>内核栈</strong>中，而不是用户栈中</li>
<li><strong>异常处理程序运行在内核态</strong>，因此对所有的系统资源都有访问权限</li>
</ul>
</li>
</ul>
<p>​	<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031250335.png" alt="image-20240403125006994"  /></p>
<ul>
<li>当异常处理程序处理完事件后，有以下三种情况：<ul>
<li>将控制交还给之前正在执行的指令</li>
<li>将控制返回给如果未发生异常时将会执行的下一条指令</li>
<li>终止程序</li>
</ul>
</li>
</ul>
<h3 id="（1）异常的分类"><a href="#（1）异常的分类" class="headerlink" title="（1）异常的分类"></a>（1）异常的分类</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031334140.png" alt="image-20240403133440480"></p>
<ul>
<li><p>中断（异步，即由处理器，即<strong>CPU外部</strong>的I&#x2F;O设备产生的）	</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031340026.png" alt="image-20240403134055559"></p>
</li>
<li><p>陷阱（同步）</p>
<ul>
<li>故意触发异常，是执行一条指令的结果，为用户程序和操作系统内核之间提供一个类似函数的接口</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031343706.png" alt="image-20240403134303996"></p>
</li>
<li><p>故障（同步）</p>
<ul>
<li>由错误情况引起，故障处理程序会尝试修复</li>
<li>经典示例：缺页异常</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031344402.png" alt="image-20240403134407074"></p>
</li>
<li><p>终止（同步）</p>
<ul>
<li>由不可恢复的致命错误导致</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031345806.png" alt="image-20240403134503470"></p>
</li>
</ul>
<h3 id="（2）x86-64系统中的异常"><a href="#（2）x86-64系统中的异常" class="headerlink" title="（2）x86-64系统中的异常"></a>（2）x86-64系统中的异常</h3><p>共定义256种异常，其中编号0-31所对应的异常由Intel的架构师定义，因此对于任意的x86-64系统都是一样的。编号32-255所对应的异常由操作系统定义。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031346638.png" alt="image-20240403134638369"></p>
<h2 id="3、进程"><a href="#3、进程" class="headerlink" title="3、进程"></a>3、进程</h2><p>进程即一个正在执行的程序实例。</p>
<h3 id="（1）逻辑控制流"><a href="#（1）逻辑控制流" class="headerlink" title="（1）逻辑控制流"></a>（1）逻辑控制流</h3><p>当使用调试器来控制程序单步执行时，会得到一系列的程序计数器的数值，这些数值与可执行程序中的指令一一对应。把这个<strong>PC值的序列</strong>叫做<strong>逻辑控制流</strong>，简称逻辑流。</p>
<ul>
<li>区分并发和并行：<ul>
<li><strong>并发</strong>：并发指的是，在<strong>同一个处理器核</strong>上，多个任务<strong>同一时间段内交替地执行</strong>，它们共享系统资源</li>
<li><strong>并行</strong>：两个进程<strong>在不同的处理器核上同时运行</strong></li>
</ul>
</li>
</ul>
<h3 id="（2）用户态和内核态"><a href="#（2）用户态和内核态" class="headerlink" title="（2）用户态和内核态"></a>（2）用户态和内核态</h3><p>为了限制应用程序执行某些特殊的指令以及限制可以访问的地址空间范围，通常处理器通过<strong>控制寄存器（Control Register）的模式位</strong>实现这些限制功能。</p>
<ul>
<li><p>控制寄存器：描述进程当前的权限</p>
</li>
<li><p><strong>用户程序可以通过系统调用来间接地访问内核的代码和数据</strong></p>
</li>
<li><p>从User Mode到Kernel Mode：中断&#x2F;故障&#x2F;系统调用</p>
</li>
<li><p>上下文（Context）</p>
<ul>
<li><p><strong>内核为每个进程维持了一个上下文</strong>，是内核重启一个被抢占的进程所需的状态，状态包括如下：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032014836.png" alt="image-20240403201459671" style="zoom: 67%;" />
</li>
<li><p>内核调度进程时使用上下文切换的机制将控制转移到新的进程，分为以下三步：</p>
<ul>
<li>保存当前进程的上下文；</li>
<li>恢复某个先前被抢占进程的上下文；</li>
<li>将控制传递给这个新恢复的进程。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（3）进程的创建"><a href="#（3）进程的创建" class="headerlink" title="（3）进程的创建"></a>（3）进程的创建</h3><ul>
<li><p>进程的状态：运行、暂停、终止</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032028003.png" alt="image-20240403202844940" style="zoom:50%;" /></li>
</ul>
<h2 id="4、进程相关函数"><a href="#4、进程相关函数" class="headerlink" title="4、进程相关函数"></a>4、进程相关函数</h2><h3 id="（1）fork函数"><a href="#（1）fork函数" class="headerlink" title="（1）fork函数"></a>（1）fork函数</h3><p>调用该函数会返回两次：1）返回到父进程；2）返回到创建的子进程。<strong>父子进程各有一份副本，不同的进程有各自的栈（即各自的地址空间）。父子进程并发执行。</strong>以下图为例，父子进程有各自的x。</p>
<ul>
<li><p>父进程中fork的返回值是<strong>子进程的PID</strong>；</p>
</li>
<li><p>子进程中fork的返回值是<strong>0</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032031897.png" alt="image-20240403203131780"></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032050294.png" alt="image-20240403205019101"></p>
<h3 id="（2）execve-waitpid函数"><a href="#（2）execve-waitpid函数" class="headerlink" title="（2）execve&#x2F;waitpid函数"></a>（2）execve&#x2F;waitpid函数</h3><ul>
<li><p>execve函数</p>
<ul>
<li><code>*argv[]</code>：参数列表</li>
<li><code>*envp[]</code>：环境变量列表，包括当前的工作目录PWD、用户名等信息</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032052443.png" alt="image-20240403205217368" style="zoom: 67%;" />

<ul>
<li>作用：调用加载器，在执行可执行程序的main函数之前，启动代码需要设置的用户栈，并将控制传递给新程序的主函数。</li>
</ul>
</li>
<li><p>waitpid函数</p>
<ul>
<li><p>僵尸进程(<code>zombie</code>)：一个终止运行但是还未被父进程回收的进程。</p>
<blockquote>
<p>在大多数情况下，僵尸进程的大部分内存资源都会被回收，因为进程的地址空间、堆栈和数据段等资源都会在进程终止时由操作系统回收。但是，还有一些资源可能没有被完全回收：</p>
<ol>
<li><strong>进程描述符（Process Descriptor）：</strong> 操作系统仍然会保留僵尸进程的进程描述符，其中包含了一些关于进程的信息，比如进程 ID、父进程 ID、状态等。这些信息可以被父进程使用 <code>wait()</code> 或 <code>waitpid()</code> 函数来获取。</li>
<li><strong>进程表项（Process Table Entry）：</strong> 操作系统的进程表中仍然会保留僵尸进程的表项，这是因为操作系统需要跟踪所有进程的状态信息。</li>
</ol>
</blockquote>
</li>
<li><p>但父进程需要获取子进程的某些信息时，通过**waitpid()**等待它的子进程终止或者停止。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032103323.png" alt="image-20240403210325217"></p>
<ul>
<li>（1）pid &gt; 0<ul>
<li>表示等待的进程是一个单独的子进程，那么该子进程的ID即为该pid的值</li>
</ul>
</li>
<li>（2）pid &#x3D; -1<ul>
<li>表示等待的进程是由父进程创建的所有进程组成的集合</li>
</ul>
</li>
<li>status中存放导致返回的子进程的状态信息，用<code>statusp</code>指向</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032110406.png" alt="image-20240403211011042"></p>
</li>
</ul>
<h2 id="5、Linux信号"><a href="#5、Linux信号" class="headerlink" title="5、Linux信号"></a>5、Linux信号</h2><p>信号是软件形式的异常。</p>
<ul>
<li>进程组：默认情况下，父子进程属于一个进程组。可通过<code>setpgrp()</code>修改进程组。</li>
</ul>
]]></content>
      <categories>
        <category>Computer</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch9 虚拟内存</title>
    <url>/2024/04/03/Computer/CSAPP/CSAPP_Ch9%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="Ch9-虚拟内存"><a href="#Ch9-虚拟内存" class="headerlink" title="Ch9 虚拟内存"></a>Ch9 虚拟内存</h1><p>计算机系统三大件：CPU&#x2F;内存&#x2F;Disk</p>
<h2 id="1、虚拟内存"><a href="#1、虚拟内存" class="headerlink" title="1、虚拟内存"></a>1、虚拟内存</h2><p>“虚拟”这两个字究竟指的是什么？</p>
<h3 id="（1）两种寻址方法"><a href="#（1）两种寻址方法" class="headerlink" title="（1）两种寻址方法"></a>（1）两种寻址方法</h3><ul>
<li><p>物理地址</p>
<ul>
<li><p>将内存看作一个非常大的数组，将地址看作下标。</p>
</li>
<li><p>CPU访问时通过总线将物理地址发给内存控制器，取出具体的数据并返回给CPU。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032355663.png" alt="image-20240403235534488" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>虚拟寻址</p>
<ul>
<li><p>在CPU和内存中加入MMU（Memory Management Unit），通过MMU将物理地址转换为虚拟地址</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032355710.png" alt="image-20240403235558629"></p>
</li>
</ul>
</li>
</ul>
<h3 id="（2）虚拟内存"><a href="#（2）虚拟内存" class="headerlink" title="（2）虚拟内存"></a>（2）虚拟内存</h3><ul>
<li><p><strong>地址空间</strong></p>
<ul>
<li><p>虚拟地址空间：用于存放进程运行时所需的代码、数据和堆栈等信息</p>
</li>
<li><p>如下图所示，<strong>8位</strong>的虚拟地址位数可以表示<strong>2^8个</strong>虚拟地址</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040006809.png" alt="image-20240404000647696"></p>
</li>
<li><p>物理地址空间</p>
</li>
</ul>
</li>
<li><p>CPU-Cache-内存-Disk</p>
</li>
<li><p>如下图所示的Virtual Pages，共N个字节，每个字节成为一个页（Page），每个页约为4KB-2MB。<strong>页是内存和磁盘间数据交换的单位。在虚拟内存中，数据通常被分割成称为页面（Page）或者页面帧（Page Frame）的固定大小的块，这些页面可以存储在物理内存中，也可以存储在磁盘上。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040017251.png" alt="image-20240404001727055"></p>
</li>
<li><p>虚拟内存中页的状态：</p>
<ul>
<li><p><code>Unallocated</code>：未分配数据，不占用磁盘空间；当调用<code>malloc()</code>函数时会用到这些未分配的页</p>
<blockquote>
<p><strong>malloc()分配的内存在堆上，为什么会分配一个虚拟页呢？</strong></p>
</blockquote>
</li>
<li><p><code>Cached</code>：该页的数据已经缓存到物理内存中，访问时CPU直接访问内存即可</p>
</li>
<li><p><code>UnCached</code>：已分配数据，但仍未缓存到物理内存中</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040020594.png" alt="image-20240404002021516"></p>
</li>
<li><p><strong>区分SRAM缓存和DRAM缓存</strong></p>
<ul>
<li>其中DRAM执行的是<strong>写回策略</strong>而非写穿透策略</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040022266.png" alt="image-20240404002223222" style="zoom:50%;" /></li>
</ul>
<h3 id="（3）页表"><a href="#（3）页表" class="headerlink" title="（3）页表"></a>（3）页表</h3><ul>
<li><p><strong>页表中的每一项页表项</strong>与<strong>虚拟内存中的每一页</strong>是一一对应的</p>
</li>
<li><p>MMU使用页表做虚拟地址到物理地址的映射</p>
</li>
<li><p><strong>页命中</strong>：要访问的目的数据页已经缓存到物理内存中</p>
<ul>
<li>若未命中，会触发缺页故障&#x2F;缺页异常，异常处理程序将页加载到物理内存中</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040029732.png" alt="image-20240404002955643" style="zoom:67%;" /></li>
</ul>
<h2 id="2、地址翻译"><a href="#2、地址翻译" class="headerlink" title="2、地址翻译"></a>2、地址翻译</h2><p><strong>地址翻译即为：将虚拟地址映射到真实物理地址</strong></p>
<ul>
<li>虚拟地址（VA） &#x3D; 虚拟页号（VPN）+ 虚拟页偏移量（VPO）<ul>
<li>虚拟页号：虚拟地址中用来索引页表的部分，<strong>表示了虚拟页在页表中的索引位置，用于确定对应的物理页框</strong></li>
<li>虚拟页偏移量：虚拟地址中用于表示页内偏移的部分，<strong>表示了虚拟页内的地址偏移量，用于在物理页框中定位具体的数据</strong>；每个页通常为<strong>4KB(&#x3D;4096Byte&#x3D;2^12，即12位)</strong></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040038957.png" alt="image-20240404003849872"></p>
<ul>
<li><p><strong>页命中的情况</strong></p>
<ul>
<li>VA：虚拟地址 &#x2F; PA：物理地址</li>
<li>PTEA：页表项地址 &#x2F; PTE：页表项</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040053564.png" alt="image-20240404005347498"></p>
</li>
<li><p><strong>缺页的情况</strong></p>
<ul>
<li>牺牲页（victim page）需要写回磁盘</li>
<li><strong>注意步骤7</strong>：<ul>
<li>步骤7在此处是因为当发现异常并处理完成后，会返回到原来引发异常的那条指令</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040054592.png" alt="image-20240404005427513"></p>
</li>
<li><p><strong>TLB&#x2F;Translation Lookaside Buffer</strong></p>
<ul>
<li>高速缓存，用于存储虚拟地址到物理地址的转换信息。它位于CPU和内存之间，用于加速虚拟地址到物理地址的转换过程。</li>
<li><strong>虚拟页号(VPN) &#x3D; TLBT(TLB Tag) + TLBI(TLB Index)</strong></li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040102671.png" alt="image-20240404010233622" style="zoom: 67%;" />
</li>
<li><p><strong>TLB Hit</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040106432.png" alt="image-20240404010601364"></p>
</li>
<li><p><strong>TLB Miss</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040106189.png" alt="image-20240404010620118"></p>
</li>
<li><p>多级页表</p>
<ul>
<li><p>多级页表（Multi-level Page Tables）是一种用于管理大型虚拟内存空间的技术，它将整个虚拟地址空间分割成多个级别的页表，从而降低了页表的大小和访问时间。</p>
</li>
<li><p>下图是一个<strong>2级页表</strong>的示例。其中2级页表才指向真正的虚拟页的地址。 </p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041446551.png" alt="image-20240404144628382"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041508429.png" alt="image-20240404150817364"></p>
</li>
</ul>
</li>
</ul>
<h2 id="3、Inter-Core-i7"><a href="#3、Inter-Core-i7" class="headerlink" title="3、Inter Core i7"></a>3、Inter Core i7</h2><h3 id="（1）Cache-Hierarchy"><a href="#（1）Cache-Hierarchy" class="headerlink" title="（1）Cache Hierarchy"></a>（1）Cache Hierarchy</h3><ul>
<li>共4个Core(核心)，每个Core有自己的L1 d-cache(数据cache)、L1 i-cache(指令cache)和L2 cache</li>
<li>4个Core共享L3 cache</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041509298.png" alt="image-20240404150908225"></p>
<ul>
<li><p>单个Core中的结构（包含TLB）</p>
<ul>
<li><strong>L2 unified TLB直接连到了DDR3 memory controller上，访问内存</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041511470.png" alt="image-20240404151102359"></p>
</li>
</ul>
<h3 id="（2）i7中如何进行地址翻译"><a href="#（2）i7中如何进行地址翻译" class="headerlink" title="（2）i7中如何进行地址翻译"></a>（2）i7中如何进行地址翻译</h3><ul>
<li><p>CPU发出一个虚拟地址去访存（-48位）</p>
<ul>
<li><p><strong>VPN</strong>(&#x3D;TLBT(-32位)+TLBI(-4位))：-36位； <strong>VPO</strong>：-12位(&#x3D;2^12&#x3D;4096B&#x3D;4KB)</p>
</li>
<li><p>根据TLBI查询相应的Set</p>
</li>
<li><p>组成52位的物理地址</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041536104.png" alt="image-20240404153626039"></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041535284.png" alt="image-20240404153537221"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041537071.png" alt="image-20240404153719985"></p>
</li>
</ul>
<h3 id="（3）Page-Memory-Area（段-Segment）"><a href="#（3）Page-Memory-Area（段-Segment）" class="headerlink" title="（3）Page Memory Area（段&#x2F;Segment）"></a>（3）Page Memory Area（段&#x2F;Segment）</h3><blockquote>
<ol>
<li><strong>进程私有部分（Process Private Memory）：</strong> 每个进程拥有自己独立的虚拟内存空间，包括代码、数据、堆、栈等部分。这些内存区域是进程私有的，不同进程之间互不干扰。当进程被创建时，操作系统会为其分配一定的虚拟地址空间，进程可以在这个地址空间中进行内存操作。</li>
<li><strong>内核部分（Kernel Space）：</strong> 所有进程共享一份内核虚拟内存空间，其中包含了操作系统的内核代码和数据。这部分内存空间被所有进程共享，用于执行操作系统提供的系统调用、管理硬件资源等操作。进程无法直接访问内核空间，需要通过系统调用等方式请求操作系统执行相应的操作。</li>
</ol>
<p>总之，每个进程都有自己独立的虚拟内存空间，但所有进程共享一份内核虚拟内存空间。这种设计既保证了进程间的隔离和安全性，又能够高效地共享操作系统提供的资源和功能。</p>
</blockquote>
<ul>
<li>pdg——page global directory</li>
<li>mmap——结构体<ul>
<li>vm_start-vm_end——该段的起始地址到结束地址，如：共享库&#x2F;Data<ul>
<li>若在这个vm_area_struct中找不到合法的起始地址，将报错<code>segment fault</code></li>
</ul>
</li>
<li>vm_prot——protect 段的权限信息<ul>
<li>若找到了对应的地址，但和段的当前权限不匹配，如需要写，但该段仅可读，也会报错</li>
</ul>
</li>
<li>vm_flags——段的某些属性</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041539849.png" alt="image-20240404153947715"></p>
<h2 id="4、内存映射"><a href="#4、内存映射" class="headerlink" title="4、内存映射"></a>4、内存映射</h2><p>通俗来讲，内存映射（Memory Mapping）是指要把段（Virtual Memory Area）上的内容（比如共享库、数据、代码等）与磁盘中的页关联起来。也即是将磁盘上的页加载到内存中的过程。</p>
<blockquote>
<p>内存映射是一种操作系统的内存管理技术，它允许将文件或其他设备映射到进程的虚拟地址空间，使得进程可以通过内存访问的方式来操作文件或设备。</p>
<p>在内存映射中，操作系统会在进程的虚拟地址空间中创建一个映射区域（Memory-mapped region），将文件的内容或设备的数据映射到这个区域中。进程可以像访问内存一样对这个映射区域进行读写操作，而不需要显式地进行文件的读写或设备的输入输出。</p>
</blockquote>
<p>对于如下图所示的ELF（Executable and Linkable Format）文件，将磁盘中的数据按照4KB的大小抽象成一页一页的虚拟页，映射到相应的虚拟地址空间中。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042220837.png" alt="image-20240404222055630"></p>
<p>这个过程也就是下图所示的<code>Loaded from the executable file</code>，<strong>这个过程只是做了一个映射，而并没有把实际的代码&#x2F;数据等写入真实物理内存。真正执行这一步是依靠缺页处理程序来实现的。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042221907.png" alt="image-20240404222120839"></p>
<p><strong>这里有个问题，那就是针对下图，对于代码段、数据段以及共享库段等，ELF文件（磁盘上）是有对应的数据对其进行映射的，但对于其他的部分，诸如用户栈、堆等，是没有可以与之映射的。</strong></p>
<ul>
<li>解决方法是将栈和堆映射到一个<strong>匿名文件（由内核创建）</strong>，也叫<strong>请求二进制（demand-zero）</strong>，其存储的全是二进制的0。当需要使用堆中的数据时（如malloc()），内核就去物理页中找一个页，用二进制0做覆盖并更新页表。</li>
</ul>
<p>也就是说：<strong>操作系统用匿名文件来映射栈和堆区域。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042226192.png" alt="image-20240404222601119"></p>
<ul>
<li><p>对于进程间的<strong>共享对象</strong>（如libc.so），不需要再复制一份到内存中，<strong>只需多个进程映射到一个相同的物理地址空间即可</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042234474.png" alt="image-20240404223431408"></p>
</li>
<li><p>对于<strong>私有对象</strong>，采用<code>copy-on-write</code>的策略</p>
<ul>
<li>在读数据时，和共享对象的映射策略一致；</li>
<li>一旦某个进程触发了一个写操作，则在写时需要<strong>先将其复制到内存上再进行修改</strong>，如下图2</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042235045.png" alt="image-20240404223543989"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042237697.png" alt="image-20240404223756633"> </p>
</li>
<li><p>用户级的内存映射函数：<code>mmap()</code></p>
<ul>
<li><code>*start</code>：一般为null，是由内核选择的虚拟地址空间的起始位置</li>
<li><code>length</code>：要映射的长度</li>
<li><code>prot</code>：权限问题</li>
<li><code>fd(file discriptor)</code></li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042303799.png" alt="image-20240404230341734" style="zoom: 50%;" /></li>
</ul>
<h2 id="5、动态内存分配"><a href="#5、动态内存分配" class="headerlink" title="5、动态内存分配"></a>5、动态内存分配</h2><p>示例：<code>array = (int *)malloc(n * sizeof(int));</code>其中malloc()申请到的地址空间位于堆中。</p>
<p><code>brk</code>指针指向堆的最底端，<strong>堆的生长空间是从低地址到高地址</strong>，与之相区别的，<strong>栈的生长空间是从高地址到低地址</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404050001970.png" alt="image-20240405000133888" style="zoom:50%;" />

<ul>
<li><p><strong><code>malloc()</code>的地址返回需要对齐，32位要求为8的倍数，64位要求为16的倍数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> incr)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Allocator动态分配时的要求</p>
<ul>
<li>处理任意请求序列</li>
<li>立即响应请求</li>
<li>只使用堆</li>
<li>对齐块</li>
<li>不修改已分配的块</li>
</ul>
</li>
<li><p>Allocator动态分配时的目标</p>
<ul>
<li>最大化吞吐率</li>
<li>最大化内存利用率<ul>
<li>存在<strong>内部碎片（internal fragmentation）</strong>和<strong>外部碎片（external fragmentation）</strong><ul>
<li><strong>内部碎片：</strong> 当一个分配的内存块的实际大小大于请求的大小时，产生了内部碎片，分配的内存块中存在的一部分空闲的空间</li>
<li><strong>外部碎片：</strong> 外部碎片是指由于连续的空闲内存块分散在内存中，导致无法满足一个新的内存分配请求。即使系统总的空闲内存足够大，但由于空闲内存块分布不连续，导致无法找到一个足够大的连续空间来满足新的内存分配请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用malloc()申请到的一块内存的数据结构：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404050020437.png" alt="image-20240405002017373"></p>
<ul>
<li><p>Header：头部信息，用户成员无法访问该信息</p>
<ul>
<li><p>29个bit表示整个Header的大小</p>
</li>
<li><p>0-2位仅0位上有有效信息，表明该块是否被分配</p>
</li>
<li><p>这里用29位表示大小，而留下了最后3位，是由于内存对齐的要求下，要求大小为8的倍数，因此对于任意8的倍数的二进制表示，其最低三位都为0</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404050026188.png" alt="image-20240405002607101"  /></li>
</ul>
</li>
<li><p>Payload：有效载荷，即实际存放的数据，其大小为请求的内存空间大小</p>
</li>
<li><p>Padding：用于内存对齐，用户成员无法访问该信息</p>
</li>
</ul>
</li>
<li><p>隐式空闲链表（Implicit Free List）</p>
<ul>
<li>隐式空闲链表是动态内存分配中一种常见的内存管理数据结构，用于管理堆中的空闲内存块。在隐式空闲链表中，空闲的内存块不是显式地维护在一个链表中，而是通过在堆中连续的空闲内存块之间插入一个特殊的标记来隐式地表示空闲空间的位置和大小</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404050028163.png" alt="image-20240405002833100"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Computer</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>cmu15-445 Course Related (Spring 2023)</title>
    <url>/2024/03/02/Project/cmu15-445/cmu15-445%20Course%20Related%20(Spring%202023)/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>PPT</th>
<th>Project</th>
<th>Date</th>
</tr>
</thead>
<tbody><tr>
<td>1-5</td>
<td>P0 &amp; P1</td>
<td>2.26-3.24</td>
</tr>
<tr>
<td>6-9</td>
<td>P2</td>
<td>3.24-</td>
</tr>
<tr>
<td>10-14</td>
<td>P3</td>
<td></td>
</tr>
<tr>
<td>15-21</td>
<td>P4</td>
<td></td>
</tr>
</tbody></table>
<p><code>DBMS</code>的磁盘管理模块主要解决两个问题：</p>
<ul>
<li>如何使用磁盘文件来表示数据库的数据（元数据、索引、数据表等）；</li>
<li>（<code>Buffer Pool</code>）如何管理数据在内存与磁盘之间的移动<ul>
<li>空间控制（<code>Spatio Control</code>）：决定将<code>pages</code>写入磁盘的哪个位置，使得尝尝一起使用的<code>pages</code>能离得更近，提高<code>I/O</code>效率；</li>
<li>时间控制（<code>Temporal Control</code>）：决定何时将<code>pages</code>读入内存，写回磁盘，使得读写的次数最小，从而提高<code>I/O</code>效率。</li>
</ul>
</li>
</ul>
<p>[TOC]</p>
<span id="more"></span>

<p>整体图片：</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-LZUa28zEosfmp4uFA77%2F-LZUJRryGLyHUdcOnhD0%2FScreen%20Shot%202019-02-24%20at%207.43.51%20PM.jpg?alt=media&token=5ca91d06-1e09-43be-afd2-5a52918ad9c9" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242055708.png" alt="image-20240324205507545"></p>
<h1 id="1-Buffer-Pool"><a href="#1-Buffer-Pool" class="headerlink" title="1 Buffer Pool"></a>1 Buffer Pool</h1><h2 id="1-1-Buffer-Pool-Manager"><a href="#1-1-Buffer-Pool-Manager" class="headerlink" title="1.1 Buffer Pool Manager"></a>1.1 Buffer Pool Manager</h2><p><code>DBMS</code>启动时，从<code>OS</code>申请一片<strong>内存区域</strong>，即<code>Buffer Pool</code>，并把这块区域划分成大小相同的<code>pages</code>，通常称为 <code>frames</code>，当<code>DBMS</code>请求一个<code>disk page</code>时，它首先需要被复制到<code>Buffer Pool</code>的一个<code>frame</code>中。</p>
<p><code>Page Table</code>中存储的<code>meta-data</code>包括：</p>
<ul>
<li><p><code>page_table</code>：内存中的哈希表，跟踪当前在内存中的页面；</p>
</li>
<li><p><code>dirty flag</code>：当线程修改页面时设置（需要回写）；</p>
</li>
<li><p><code>pin count</code>：在有线程<strong>读页面</strong>时加<code>1</code>。</p>
</li>
</ul>
<p>当有线程需要**写<code>Page Table</code>**时，需要加一个<code>latch</code>。</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-LZUa28zEosfmp4uFA77%2F-LZUP5rlT7qWNo8qYSuD%2FScreen%20Shot%202019-02-24%20at%208.08.44%20PM.jpg?alt=media&token=f492f425-12b9-47bc-af9a-b4e2430e12bf" alt="img"></p>
<h3 id="locks和latches"><a href="#locks和latches" class="headerlink" title="locks和latches"></a>locks和latches</h3><p><code>Locks</code>（逻辑上的）</p>
<ul>
<li>保护<strong>数据库逻辑内容</strong>免受其他事务的影响</li>
<li>持有直到事务结束</li>
<li><strong>需要支持回滚</strong>（回滚即回到之前的版本状态）</li>
<li>保护元组（行），表，索引</li>
</ul>
<p><code>Latches/Mutex</code>（偏底层的）</p>
<ul>
<li>保护**<code>DBMS</code>内部数据结构**的关键部分不受其他线程的影响</li>
<li>持有直到一个操作结束</li>
<li><strong>不需要支持回滚</strong></li>
</ul>
<h3 id="scan-sharing"><a href="#scan-sharing" class="headerlink" title="scan sharing"></a>scan sharing</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403021705443.png" alt="image-20240302170551246" style="zoom:33%;" />

<p>图中的查询语句可能会导致<code>Q2</code>得不到自己真实想要的结果，需要加上<code>ORDER BY</code>限制才行。</p>
<p>假如有<code>Page0-Page199</code>，<code>scan sharing</code>可能导致：</p>
<ul>
<li><code>Q1</code>-&gt;<code>Page0-Page99</code></li>
<li><code>Q2</code>-&gt;<code>Page40-Page139</code></li>
</ul>
<h3 id="buffer-pool-bypass"><a href="#buffer-pool-bypass" class="headerlink" title="buffer pool bypass"></a>buffer pool bypass</h3><p>只需要调用一次的<code>page</code>，用完后直接丢弃，则可以不放入<code>buffer pool</code>。</p>
<h2 id="1-2-Buffer-Replacement-Policies"><a href="#1-2-Buffer-Replacement-Policies" class="headerlink" title="1.2 Buffer Replacement Policies"></a>1.2 Buffer Replacement Policies</h2><p>当<code>Buffer Pool</code>空间不足时，选择移除其中的哪些<code>pages</code>的问题。</p>
<h3 id="Least-Recently-Used-LRU"><a href="#Least-Recently-Used-LRU" class="headerlink" title="Least-Recently Used(LRU)"></a>Least-Recently Used(LRU)</h3><p><code>LRU</code>维护每个<code>page</code>上一次被访问的时间戳，每次移除时间戳最早的<code>page</code>。</p>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p><code>LRU</code>的近似实现。快速的<code>LRU</code>实现。</p>
<blockquote>
<p>但<code>LRU</code>和<code>Clock</code>容易被<code>sequential flooding</code>现象影响，从而导致最近被访问的<code>page</code>实际上却是最不可能需要的<code>page</code>。<strong>比如在全表扫描时，刚被访问的<code>page</code>实际上再访问完成后就不再需要了，因此反而成为了最不需要的<code>page</code>。</strong></p>
<p>为了解决这个问题，提出了<code>LRU-K</code>策略。</p>
</blockquote>
<h3 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h3><p><code>LRU-K</code>保存每个<code>page</code>的最后<code>K</code>次访问时间戳，利用这些时间戳来估计它们下次被访问的时间，通常<code>K</code>取<code>1</code>就能获得很好的效果。</p>
<p><strong>时间局部性原理：程序最近访问的地址在不久的将来很可能再次被访问。</strong></p>
<p><code>K</code>指的是最后第<code>K</code>次访问的距离，也就是倒数第<code>K</code>次访问时和最近一次访问的时间差。<code>LRU-K</code>算法主要是对比最后第<code>K</code>次的访问距离，访问距离越大则代表每次的访问间隔越长，因此更容易被替换出<code>cahce</code>。</p>
<ul>
<li><code>Correlated References Period</code>：指的是块首次访问后的一段时间。在这段时间以内的多次访问不会被记录，只有这段时间过后再次访问才会被记录。</li>
<li><code>Reference Retained Information Period</code>：指的是块被替换出<code>cache</code>后的一段时间。为了避免块被替换出<code>cache</code>后短时间内被反复重新访问、替换，因此对于替换出<code>cache</code>后的块会继续保留访问信息一段时间。</li>
</ul>
<h3 id="Dirty-Page"><a href="#Dirty-Page" class="headerlink" title="Dirty Page"></a>Dirty Page</h3><p><code>Dirty</code>：内存中的<code>page</code>和磁盘中的<code>page</code>有差别。</p>
<ul>
<li><p><code>FAST</code>：如果缓冲池中的页面不脏，那么<code>DBMS</code>可以简单地“删除”它；</p>
</li>
<li><p><code>SLOW</code>：如果页面是脏的，则<code>DBMS</code>必须写回磁盘以确保其更改是持久的。</p>
</li>
</ul>
<p><a href="https://www.jianshu.com/p/f242bc1e95ff">MySQL的WAL（Write-Ahead Logging）机制</a></p>
<h2 id="1-3-Other-Memory-Pools"><a href="#1-3-Other-Memory-Pools" class="headerlink" title="1.3 Other Memory Pools"></a>1.3 Other Memory Pools</h2><p>除了存储<code>tuples</code>和<code>indexes</code>，<code>DBMS</code>还需要<code>Memory Pools</code>来存储其它数据：</p>
<ul>
<li><code>Sorting + Join Buffers</code></li>
<li><code>Query Caches</code></li>
<li><code>Maintenance Buffers</code></li>
<li><code>Log Buffers</code></li>
<li><code>Dictionary Caches</code></li>
</ul>
<h1 id="2-B-Tree-Index"><a href="#2-B-Tree-Index" class="headerlink" title="2 B+Tree Index"></a>2 B+Tree Index</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271651204.png" alt="image-20240327165111130"></p>
<h2 id="2-1-Hash-Tables"><a href="#2-1-Hash-Tables" class="headerlink" title="2.1 Hash Tables"></a>2.1 Hash Tables</h2><h3 id="2-1-1-Hash-Functions"><a href="#2-1-1-Hash-Functions" class="headerlink" title="2.1.1 Hash Functions"></a>2.1.1 Hash Functions</h3><p>由于<code>DBMS</code>内使用的<code>Hash Function</code>并不会暴露在外，因此<strong>没必要使用加密（<code>cryptographic</code>）哈希函数</strong>，我们希望它速度越快，<code>collision rate</code>越低越好。</p>
<p>目前各 DBMS 主要在用的 Hash Functions 包括：</p>
<ul>
<li><a href="https://github.com/aappleby/smhasher">MurmurHash (2008)</a></li>
<li><a href="https://github.com/google/cityhash">Google CityHash (2011)</a></li>
<li><a href="https://github.com/google/farmhash">Google FarmHash (2014)</a></li>
<li><a href="https://github.com/lemire/clhash">CLHash (2016)</a></li>
</ul>
<h4 id="SHA256算法"><a href="#SHA256算法" class="headerlink" title="SHA256算法"></a>SHA256算法</h4><h3 id="2-1-2-Static-Hashing-Scheme"><a href="#2-1-2-Static-Hashing-Scheme" class="headerlink" title="2.1.2 Static Hashing Scheme"></a>2.1.2 Static Hashing Scheme</h3><p>（1）Linear Probe Hashing 开放地址哈希</p>
<p>“开放”的意思就是说：对于所有的key来说地址是开放的。碰撞时则往下一个地址存。</p>
<p>在删除时可能会因为前项被删除导致的空白，造成找不到当前项，这时有两个解决思路：</p>
<ul>
<li>Tombstone；</li>
<li>Movement</li>
</ul>
<p>重复key出现时的解决思路：</p>
<ul>
<li>Separate Linked List，把当前key作为指针指向一个新的区域：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242120365.png" alt="image-20240324212003301"></p>
<ul>
<li>Redundant Keys，把key和value拼在一起作为新的key：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242120828.png" alt="image-20240324212049757"></p>
<p>（2）Robin Hood Hashing，是开放地址哈希的变种，其基本思想是“劫富济贫”。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242123712.png" alt="image-20240324212329536"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242123232.png" alt="image-20240324212342001"></p>
<p>简单来说就是，当E和A碰撞时，正常E偏移3位，但为了不让自己比D“惨”太多，它就把D推到后面去，自己占了D的位置。此时D和E均为2。</p>
<p>（3）Cuckoo Hashing</p>
<blockquote>
<p>静态的哈希结构的问题在于需要DBMS能够预判所存数据的总量，否则每次数量超过范围时都需要重建 Hash Table。这显然是很困难的。</p>
</blockquote>
<h3 id="2-1-3-Dynamic-Hash-Tables"><a href="#2-1-3-Dynamic-Hash-Tables" class="headerlink" title="2.1.3 Dynamic Hash Tables"></a>2.1.3 Dynamic Hash Tables</h3><p>（1）Chained Hashing（※）</p>
<p>每个 key 对应一个链表，每个节点是一个 bucket，装满了就再往后挂一个 bucket。需要写操作时，需要请求 latch。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242129786.png" alt="image-20240324212955629"></p>
<ul>
<li>好处：简单；</li>
<li>坏处：最坏的情况下Hash Table可能降级为链表，操作的时间复杂度降格为 O(n)。</li>
</ul>
<p>（2）Extendible Hashing</p>
<p>Extendible Hashing 的基本思路是一边扩容，一边 rehash。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242134200.png" alt="image-20240324213443953"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242134195.png" alt="image-20240324213451869"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242134845.png" alt="image-20240324213459513"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242135620.png" alt="image-20240324213509210"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242135275.png" alt="image-20240324213516681"></p>
<p>（3）Linear Hashing</p>
<p>基本思想：维护一个指针，指向下一个将被拆分的 bucket，每当任意一个 bucket 溢出（标准自定，如利用率到达阈值等）时，将指针指向的 bucket 拆分。</p>
<h3 id="2-1-4-总结"><a href="#2-1-4-总结" class="headerlink" title="2.1.4 总结"></a>2.1.4 总结</h3><p>Hash Tables 提供 O(1)O(1) 的访问效率，因此它被大量地应用于 DBMS 的内部实现中。即便如此，它并不适合作为 table index 的数据结构，而 table index 的首选就是下节将介绍的 B+ Tree。</p>
<p><strong>哈希表对于范围索引是效率极低的。</strong></p>
<h2 id="2-2-Tree-Indexes（B-索引）"><a href="#2-2-Tree-Indexes（B-索引）" class="headerlink" title="2.2 Tree Indexes（B+索引）"></a>2.2 Tree Indexes（B+索引）</h2><blockquote>
<p>table index 为提供 DBMS 数据查询的快速索引，它本身存储着某表某列排序后的数据，并包含指向相应 tuple 的指针。DBMS 需要保证表信息与索引信息在逻辑上保持同步。用户可以在 DBMS 中为任意表建立多个索引，DBMS 负责选择最优的索引提升查询效率。但索引自身需要占用存储空间，因此在索引数量与索引存储、维护成本之间存在权衡。</p>
</blockquote>
<p>索引本质上就是一种小表，是把大表中的某些列抽取出来。</p>
<h3 id="2-2-1-B-Tree"><a href="#2-2-1-B-Tree" class="headerlink" title="2.2.1 B+ Tree"></a>2.2.1 B+ Tree</h3><p>B+ Tree 是一种自平衡树，它将数据有序地存储，且在 search、sequential access、insertions 以及 deletions 操作的复杂度上都满足 O(logn)，其中 sequential access 的最终复杂度还与所需数据总量有关。</p>
<blockquote>
<p>这里的O(logn)的意义在于，随着数据的增长，操作的复杂度增长是要慢于数据的增长速度的。比如数据增长到原来的2倍，但搜索时间不会变成原来的2倍。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242151303.png" alt="image-20240324215134042"></p>
<h4 id="B-Tree-Nodes"><a href="#B-Tree-Nodes" class="headerlink" title="B+ Tree Nodes"></a>B+ Tree Nodes</h4><p>B+ Tree 中的每个 node 都包含一列按 key 排好序的 key&#x2F;value pairs，key 就是 table index 对应的 column，value 的取值与 node 类型相关，在 inner nodes 和 leaf nodes 中存的内容不同。</p>
<p>values主要有两种存法：</p>
<ul>
<li>Record IDs，存储指向最终 tuple 的指针。</li>
<li>Tuple Data，直接将 tuple data 存在 leaf node 中。key为ID，v为整个行数据。如主键索引，其key为主键，value即为这张表的全部内容。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242154259.png" alt="image-20240324215455186"></p>
<h4 id="B-Tree-Operations"><a href="#B-Tree-Operations" class="headerlink" title="B+ Tree Operations"></a>B+ Tree Operations</h4><p><em>Insert</em></p>
<ol>
<li>找到对应的 leaf node，L</li>
<li>将 key&#x2F;value pair 按顺序插入到 L 中</li>
<li>如果 L 还有足够的空间，操作结束；如果空间不足，则需要将 L 分裂成两个节点，同时在 parent node 上新增 entry，若 parent node 也空间不足，则递归地分裂，直到 root node 为止。</li>
</ol>
<p><em>Delete</em></p>
<ol>
<li>从 root 开始，找到目标 entry 所处的 leaf node, L</li>
<li>删除该 entry</li>
<li>如果 L 仍然至少处于半满状态，则操作结束；否则先尝试从 siblings 那里拆借 entries，如果失败，则将 L 与相应的 sibling 合并</li>
<li>如果合并发生了，则可能需要递归地删除 parent node 中的 entry</li>
</ol>
<h4 id="Clustered-Indexes-聚簇索引"><a href="#Clustered-Indexes-聚簇索引" class="headerlink" title="Clustered Indexes 聚簇索引"></a>Clustered Indexes 聚簇索引</h4><h3 id="2-2-2-B-Tree-Design-Choices"><a href="#2-2-2-B-Tree-Design-Choices" class="headerlink" title="2.2.2 B+ Tree Design Choices"></a>2.2.2 B+ Tree Design Choices</h3><h4 id="Node-Size"><a href="#Node-Size" class="headerlink" title="Node Size"></a>Node Size</h4><p>通常来说，disk 的数据读取速度越慢，node size 就越大：</p>
<table>
<thead>
<tr>
<th>Disk Type</th>
<th>Node Size</th>
</tr>
</thead>
<tbody><tr>
<td>HDD</td>
<td>~1MB</td>
</tr>
<tr>
<td>SSD</td>
<td>~10KB</td>
</tr>
<tr>
<td>In-Memory</td>
<td>~512B</td>
</tr>
</tbody></table>
<p>具体情境下的最优大小由 workload 决定。</p>
<h4 id="Merge-Threshold"><a href="#Merge-Threshold" class="headerlink" title="Merge Threshold"></a>Merge Threshold</h4><p>由于 merge 操作引起的修改较大，有些 DBMS 选择延迟 merge 操作的发生时间，甚至可以利用其它进程来负责周期性地重建 table index。</p>
<h4 id="Variable-Length-Keys"><a href="#Variable-Length-Keys" class="headerlink" title="Variable Length Keys"></a>Variable Length Keys</h4><p>B+ Tree 中存储的 key 经常是变长的，通常有三种手段来应对：</p>
<ul>
<li>Pointers：存储指向 key 的指针；</li>
<li>Variable Length Nodes：需要精细的内存管理操作，不推荐；</li>
<li>Padding：给每个变长的key都强制转成一致的长度；</li>
<li>key Map：内嵌一个指针数组，指向 node 中的 key&#x2F;val list</li>
</ul>
<h4 id="Non-unique-Indexes-变长字段"><a href="#Non-unique-Indexes-变长字段" class="headerlink" title="Non-unique Indexes 变长字段"></a>Non-unique Indexes 变长字段</h4><p>索引针对的 key 可能是非唯一的，通常有两种手段来应对：</p>
<ul>
<li><p>Duplicate Keys：存储多次相同的 key；</p>
</li>
<li><p>Value Lists：每个 key 只出现一次，但同时维护另一个链表，存储 key 对应的多个 values，类似 chained hashing</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251235897.png" alt="image-20240325123534595"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251235251.png" alt="image-20240325123553069"></p>
<h4 id="Intra-node-Search-结点的内部搜素"><a href="#Intra-node-Search-结点的内部搜素" class="headerlink" title="Intra-node Search 结点的内部搜素"></a>Intra-node Search 结点的内部搜素</h4><p>在节点内部搜索，就是在排好序的序列中检索元素，手段通常有：</p>
<ul>
<li>Linear Scan，这种线性扫描虽然似乎很费时，但相比把page从磁盘读到内存的时间来看几乎已经不算什么了；</li>
<li>Binary Search，用二分来优化线性搜索；</li>
<li>Interpolation：通过 keys 的分布统计信息来估计大概位置进行检索</li>
</ul>
<h3 id="2-2-3-Optimizations"><a href="#2-2-3-Optimizations" class="headerlink" title="2.2.3 Optimizations"></a>2.2.3 Optimizations</h3><h4 id="Prefix-Compression"><a href="#Prefix-Compression" class="headerlink" title="Prefix Compression"></a>Prefix Compression</h4><p>同一个 leaf node 中的 keys 通常有相同的 prefix，如下图所示。为了节省空间，可以只存所有 keys 的不同的 suffix。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251240293.png" alt="image-20240325124020194"></p>
<h4 id="Suffix-Truncation"><a href="#Suffix-Truncation" class="headerlink" title="Suffix Truncation"></a>Suffix Truncation</h4><p>由于 inner nodes 只用于引导搜索，因此没有必要在 inner nodes 中储存完整的 key，我们可以<strong>只存储足够的 prefix 即可</strong>，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251241456.png" alt="image-20240325124132291"></p>
<h4 id="Bulk-Insert"><a href="#Bulk-Insert" class="headerlink" title="Bulk Insert"></a>Bulk Insert</h4><p>建 B+ Tree 的最快方式是先将 keys 排好序后，再从下往上建树，如下图所示。因此如果有<strong>大量插入操作</strong>，可以利用这种方式提高效率。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251241413.png" alt="image-20240325124150282"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251242426.png" alt="image-20240325124207283"></p>
<h4 id="Pointer-Swizzling"><a href="#Pointer-Swizzling" class="headerlink" title="Pointer Swizzling"></a>Pointer Swizzling</h4><p>Nodes 使用 page id 来存储其它 nodes 的引用，DBMS 每次需要首先从 page table 中获取对应的内存地址，然后才能获取相应的 nodes 本身，如果 page 已经在 buffer pool 中，我们可以直接存储其它 page 在 buffer pool 中的内存地址作为引用，从而提高访问效率。</p>
<h2 id="2-3-Index-Concurrency-Control"><a href="#2-3-Index-Concurrency-Control" class="headerlink" title="2.3 Index Concurrency Control"></a>2.3 Index Concurrency Control</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251246471.png" alt="image-20240325124646316"></p>
<h3 id="2-3-1-Latch-Modes"><a href="#2-3-1-Latch-Modes" class="headerlink" title="2.3.1 Latch Modes"></a>2.3.1 Latch Modes</h3><h4 id="Read-Mode"><a href="#Read-Mode" class="headerlink" title="Read Mode"></a>Read Mode</h4><ul>
<li>多个线程可以同时读取相同的数据</li>
<li>针对相同的数据，当别的线程已经获得处于 read mode 的 latch，新的线程也可以继续获取 read mode 的 latch</li>
</ul>
<h4 id="Write-Mode"><a href="#Write-Mode" class="headerlink" title="Write Mode"></a>Write Mode</h4><ul>
<li>同一时间只有单个线程可以访问</li>
<li>针对相同的数据，如果获取前已经有别的线程获得任何 mode 的 latch，新的线程就无法获取 write mode  的 latch</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251249774.png" alt="image-20240325124932586"></p>
<p><strong>锁的实现：</strong></p>
<ul>
<li><p>Blocking OS Mutex：如std::mutex，好处是竞争的线程会陷入sleep，但坏处是需要OS去进行唤醒，极度浪费资源；</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251251222.png" alt="image-20240325125111105"></p>
</li>
<li><p>Test-ans-Set Spin Latch(TAS)：自旋锁，如std::atomic<T>，不需要OS操作，自己在死循环内不断旋转，直到可以获取到该锁；</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251253634.png" alt="image-20240325125323436"></p>
</li>
<li><p>Reader-Writer Latches：自旋锁的基础上实现。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251255541.png" alt="image-20240325125549330"></p>
<p>这里注意：若有线程需要加写锁，那么此时如果再有线程希望加读锁也会被阻塞。只有等之前的读锁都释放，写锁成功加上后，后续的读锁才能正常上锁。（这样做是为了避免写锁被无止境地锁住）</p>
</li>
</ul>
<h4 id="hash-table-latching"><a href="#hash-table-latching" class="headerlink" title="hash table latching"></a><strong>hash table latching</strong></h4><p>相较于B+ Tree，Hash Table不容易遇到死锁，尤其是开放地址哈希，因为大家都是朝着一个方向去进行的。一般在扩容（resize）操作时，加一个全局的写锁，因为此时哈希表内部的数据需要进行一个整理。</p>
<ul>
<li>page latches：块与块之间的锁独立。线程会给所有块加分段锁。例如下图，块1的写锁和块2的读锁独立。这样的优势是：1）锁的粒度不会太细；2）支持一定的并发操作。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271610143.png" alt="image-20240327161025853"></p>
<ul>
<li><p>slot latches：以槽为单位进行加锁。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271611923.png" alt="image-20240327161157762"></p>
</li>
<li><p>compare-and-swap，CAS，使得hash table实现无锁插入。例如下图：让os先0判断是否为20，若是再加到30，属于原子操作。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271629958.png" alt="image-20240327162902774"></p>
</li>
</ul>
<h3 id="2-3-2-Index-Crabbing-Coupling"><a href="#2-3-2-Index-Crabbing-Coupling" class="headerlink" title="2.3.2 Index Crabbing&#x2F;Coupling"></a>2.3.2 Index Crabbing&#x2F;Coupling</h3><p>B+Tree考虑两方面的并发问题：</p>
<ul>
<li>1）结点内部的数据，即多个线程同时修改一个node；</li>
<li>2）结点间的合并和分裂操作，即一个线程正在遍历 B+ Tree 的同时，另一个线程正在 splits&#x2F;merges nodes。</li>
</ul>
<p><strong>Latch Crabbing 的基本思想如下：</strong></p>
<ul>
<li>获取 parent 的 latch</li>
<li>获取 child 的 latch</li>
<li>如果<strong>安全</strong>，可以释放 parent 的 latch</li>
</ul>
<p><strong>这里的“安全”指的是，当发生更新操作时，该节点不会发生 split 或 merge 的操作，即：</strong></p>
<ul>
<li>在插入元素时，节点未满</li>
<li>在删除元素时，节点超过半满</li>
</ul>
<p>按照上述方法，无论对叶子结点执行何种操作，第一步都是先锁住根节点，这是一种“悲观”的做法。“乐观”的做法是：一路加读锁，最后加写锁。当然也有可能出现到了最后一步，发现会改动前面的parent，因此需要放弃当前的操作，重新从root开始加写锁。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271638410.png" alt="image-20240327163836210"></p>
<h3 id="2-3-3-Leaf-Scans"><a href="#2-3-3-Leaf-Scans" class="headerlink" title="2.3.3 Leaf Scans"></a>2.3.3 Leaf Scans</h3><p>之前的分析中我们仅仅关注了从上到下的访问模式，而没有考虑到左右方向的访问模式，在 range query 中，常常需要横向访问相邻的 nodes。</p>
<p>当遇到横向扫描无法获取下一个节点的 latch 时，该线程将释放 latch 后自杀。这种策略逻辑简单，尽管有理论上的优化空间，但在实践中是常见的避免死锁的方式。</p>
<h3 id="2-3-4-Delayed-Parent-Updates"><a href="#2-3-4-Delayed-Parent-Updates" class="headerlink" title="2.3.4 Delayed Parent Updates"></a>2.3.4 Delayed Parent Updates</h3><p>从上文中，我们可以观察到：每当 leaf node 溢出时，我们都需要更新至少 3 个节点：</p>
<ul>
<li>即将被拆分的 leaf node</li>
<li>新的 leaf node</li>
<li>parent node</li>
</ul>
<p>修改的成本较高，因此 B-link Tree 提出了一种优化策略：<strong>每当 leaf node 溢出时，只是标记一下而暂时不更新 parent node，等下一次有别的线程获取 parnet node 的 write latch 时，一并修改。</strong></p>
<h2 id="2-4-Sorting-and-Aggregations"><a href="#2-4-Sorting-and-Aggregations" class="headerlink" title="2.4 Sorting and Aggregations"></a>2.4 Sorting and Aggregations</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271648356.png" alt="image-20240327164819130"></p>
<p>一个disk-oriented DBMS不能假定query results和内存大小完全适配。有可能筛选出来的query results也需要存到磁盘中，和buffer pool互相配合来实现操作。需要最大化利用sequential I&#x2F;O。</p>
<p><strong>为什么需要排序：关系型数据库是unsorted的。</strong></p>
<h3 id="2-4-1-Sorting-Algorithm"><a href="#2-4-1-Sorting-Algorithm" class="headerlink" title="2.4.1 Sorting Algorithm"></a>2.4.1 Sorting Algorithm</h3><ul>
<li>early materialization：排序时value直接存储当前key那一行的剩余数据；</li>
<li>later materialization：排序时value存储ID值。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271703469.png" alt="image-20240327170300327"></p>
<h4 id="External-Merge-Sort"><a href="#External-Merge-Sort" class="headerlink" title="External Merge Sort"></a>External Merge Sort</h4><p>外部排序通常有两个步骤：</p>
<p>1、Sorting Phase：将数据分成多个 chunks，每个 chunk 可以完全读入到 memory 中，在 memory 中排好序后再写回到 disk 中</p>
<p>2、Merge Phase：将多个子文件合并成一个大文件</p>
<ul>
<li><p>2-Way External Merge Sort：这里的“2-way”即是指每次读入两页。</p>
</li>
<li><p>General External Merge Sort：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271947535.png" alt="image-20240327194734264"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271949041.png" alt="image-20240327194933847"></p>
</li>
</ul>
<h4 id="Using-B-Tree-for-Sorting"><a href="#Using-B-Tree-for-Sorting" class="headerlink" title="Using B+Tree for Sorting"></a>Using B+Tree for Sorting</h4><p>注意包含聚簇和非聚簇两种情况。</p>
<h3 id="2-4-2-Aggregations"><a href="#2-4-2-Aggregations" class="headerlink" title="2.4.2 Aggregations"></a>2.4.2 Aggregations</h3><h4 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271953093.png" alt="image-20240327195346706"></p>
<p>但很多时候我们并不需要排好序的数据，如：</p>
<ul>
<li>Forming groups in GROUP BY</li>
<li>Removing duplicates in DISTINCT</li>
</ul>
<p>在这样的场景下 hashing 是更好的选择，它能有效减少排序所需的额外工作。</p>
<h4 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h4><p>利用一个临时 (ephemeral) 的 hash table 来记录必要的信息，即检查 hash table 中是否存在已经记录过的元素并作出相应操作：</p>
<ul>
<li>DISTINCT: Discard duplicate</li>
<li>GROUP BY: Perform aggregate computation</li>
</ul>
<p>如果所有信息都能一次性读入内存，那事情就很简单了，但如若不然，我们就得变得更聪明。</p>
<p>hashing aggregation 同样分成两步：</p>
<ul>
<li>Partition Phase: 将 tuples 根据 hash key 放入不同的 buckets<ul>
<li>use a hash function h1 to split tuples into partitions on disk<ul>
<li>all matches live in the same partition</li>
<li>partitions are “spilled” to disk via output buffers</li>
</ul>
</li>
<li>这里有个额外的假设，即每个 partition 能够被放到 memory 中</li>
</ul>
</li>
<li>ReHash Phase: 在内存中针对每个 partition 利用 hash table 计算 aggregation 的结果</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403272000471.png" alt="image-20240327200043163"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403272000726.png" alt="image-20240327200052468"></p>
<p>在 ReHash phase 中，存着 (GroupKey→RunningVal)(GroupKey→RunningVal) 的键值对，当我们需要向 hash table 中插入新的 tuple 时：</p>
<ul>
<li>如果我们发现相应的 GroupKey 已经在内存中，只需要更新 RunningVal 就可以</li>
<li>反之，则插入新的 GroupKey 到 RunningVal 的键值对</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403272001082.png" alt="image-20240327200117774"></p>
]]></content>
      <categories>
        <category>Project</category>
        <category>cmu15-445</category>
      </categories>
  </entry>
  <entry>
    <title>cmu15-445 Homework1_SQL (Spring 2023)</title>
    <url>/2024/02/28/Project/cmu15-445/cmu15-445%20Homework1_SQL/</url>
    <content><![CDATA[<h1 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> CategoryName <span class="keyword">FROM</span> Category <span class="keyword">ORDER</span> <span class="keyword">BY</span> CategoryName;</span><br><span class="line"></span><br><span class="line">Beverages</span><br><span class="line">Condiments</span><br><span class="line">Confections</span><br><span class="line">Dairy Products</span><br><span class="line">Grains<span class="operator">/</span>Cereals</span><br><span class="line">Meat<span class="operator">/</span>Poultry</span><br><span class="line">Produce</span><br><span class="line">Seafood</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> ShipName <span class="keyword">FROM</span> <span class="string">&#x27;Order&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span>  ShipName <span class="keyword">LIKE</span> <span class="string">&#x27;%-%&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> ShipName;</span><br><span class="line"></span><br><span class="line">Bottom<span class="operator">-</span>Dollar Markets</span><br><span class="line">Chop<span class="operator">-</span>suey Chinese</span><br><span class="line">GROSELLA<span class="operator">-</span>Restaurante</span><br><span class="line">HILARION<span class="operator">-</span>Abastos</span><br><span class="line">Hungry Owl <span class="keyword">All</span><span class="operator">-</span>Night Grocers</span><br><span class="line">LILA<span class="operator">-</span>Supermercado</span><br><span class="line">LINO<span class="operator">-</span>Delicateses</span><br><span class="line">QUICK<span class="operator">-</span>Stop</span><br><span class="line">Save<span class="operator">-</span>a<span class="operator">-</span>lot Markets</span><br><span class="line"></span><br><span class="line">DETAILS:</span><br><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> ShipName <span class="operator">||</span> <span class="string">&#x27;|&#x27;</span> <span class="operator">||</span> SUBSTR(ShipName, <span class="number">1</span>, INSTR(ShipName, <span class="string">&#x27;-&#x27;</span>) <span class="operator">-</span> <span class="number">1</span>) <span class="keyword">AS</span> formatted_res</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="string">&#x27;Order&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> ShipName <span class="keyword">like</span> <span class="string">&#x27;%-%&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> ShipName;</span><br><span class="line"></span><br><span class="line">Bottom<span class="operator">-</span>Dollar Markets<span class="operator">|</span>Bottom</span><br><span class="line">Chop<span class="operator">-</span>suey Chinese<span class="operator">|</span>Chop</span><br><span class="line">GROSELLA<span class="operator">-</span>Restaurante<span class="operator">|</span>GROSELLA</span><br><span class="line">HILARION<span class="operator">-</span>Abastos<span class="operator">|</span>HILARION</span><br><span class="line">Hungry Owl <span class="keyword">All</span><span class="operator">-</span>Night Grocers<span class="operator">|</span>Hungry Owl <span class="keyword">All</span></span><br><span class="line">LILA<span class="operator">-</span>Supermercado<span class="operator">|</span>LILA</span><br><span class="line">LINO<span class="operator">-</span>Delicateses<span class="operator">|</span>LINO</span><br><span class="line">QUICK<span class="operator">-</span>Stop<span class="operator">|</span>QUICK</span><br><span class="line">Save<span class="operator">-</span>a<span class="operator">-</span>lot Markets<span class="operator">|</span>Save</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> INSTR(ShipName, <span class="string">&#x27;-&#x27;</span>)：该函数找到在 ShipName 字符串中连字符（<span class="string">&#x27;-&#x27;</span>）的位置</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> SUBSTR(ShipName, <span class="number">1</span>, INSTR(ShipName, <span class="string">&#x27;-&#x27;</span>) <span class="operator">-</span> <span class="number">1</span>)：该 SUBSTR 函数从 ShipName 字符串的开头（位置<span class="number">1</span>）提取子字符串，直到连字符的位置减<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Id <span class="operator">||</span> <span class="string">&#x27;|&#x27;</span> <span class="operator">||</span> ShipCountry <span class="operator">||</span> <span class="string">&#x27;|&#x27;</span> <span class="operator">||</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">CASE</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">WHEN</span> ShipCountry <span class="keyword">IN</span> (<span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Mexico&#x27;</span>, <span class="string">&#x27;Canada&#x27;</span>) <span class="keyword">THEN</span> <span class="string">&#x27;NorthAmerica&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">ELSE</span> <span class="string">&#x27;OtherPlace&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">END</span> <span class="keyword">AS</span> Region</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="string">&#x27;Order&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> Id<span class="operator">&gt;=</span><span class="number">15445</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> Id</span><br><span class="line">   ...<span class="operator">&gt;</span> LIMIT <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">15445</span><span class="operator">|</span>France<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15446</span><span class="operator">|</span>Italy<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15447</span><span class="operator">|</span>Portugal<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15448</span><span class="operator">|</span>Argentina<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15449</span><span class="operator">|</span>Portugal<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15450</span><span class="operator">|</span>Venezuela<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15451</span><span class="operator">|</span>Brazil<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15452</span><span class="operator">|</span>France<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15453</span><span class="operator">|</span>France<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15454</span><span class="operator">|</span>Canada<span class="operator">|</span>NorthAmerica</span><br><span class="line"><span class="number">15455</span><span class="operator">|</span>USA<span class="operator">|</span>NorthAmerica</span><br><span class="line"><span class="number">15456</span><span class="operator">|</span>France<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15457</span><span class="operator">|</span>Mexico<span class="operator">|</span>NorthAmerica</span><br><span class="line"><span class="number">15458</span><span class="operator">|</span>USA<span class="operator">|</span>NorthAmerica</span><br><span class="line"><span class="number">15459</span><span class="operator">|</span>Germany<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15460</span><span class="operator">|</span>Argentina<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15461</span><span class="operator">|</span>Austria<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15462</span><span class="operator">|</span>Austria<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15463</span><span class="operator">|</span>Finland<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15464</span><span class="operator">|</span>Brazil<span class="operator">|</span>OtherPlace</span><br></pre></td></tr></table></figure>

<h1 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span></span><br><span class="line">   ...<span class="operator">&gt;</span> s.CompanyName <span class="operator">||</span> <span class="string">&#x27;|&#x27;</span> <span class="operator">||</span></span><br><span class="line">   ...<span class="operator">&gt;</span> ROUND(<span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> o.ShippedDate <span class="operator">&gt;</span> o.RequiredDate <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="operator">*</span> <span class="number">100.0</span> <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>), <span class="number">2</span>) <span class="keyword">AS</span> Percentage</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> Shipper <span class="keyword">as</span> s</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">JOIN</span> [<span class="keyword">Order</span>] <span class="keyword">as</span> o <span class="keyword">ON</span> s.Id <span class="operator">=</span> o.ShipVia</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> s.CompanyName</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> Percentage <span class="keyword">DESC</span>; </span><br><span class="line"></span><br><span class="line">United Package<span class="operator">|</span><span class="number">23.44</span></span><br><span class="line">Speedy Express<span class="operator">|</span><span class="number">23.46</span></span><br><span class="line">Federal Shipping<span class="operator">|</span><span class="number">23.61</span></span><br></pre></td></tr></table></figure>

<h1 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span></span><br><span class="line">   ...<span class="operator">&gt;</span> a.CategoryName,</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="built_in">COUNT</span>(a.Id) <span class="keyword">AS</span> TotalCategoryCount,</span><br><span class="line">   ...<span class="operator">&gt;</span> ROUND(((<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(UnitPrice) <span class="keyword">FROM</span> Category b, Product c <span class="keyword">WHERE</span> b.Id <span class="operator">=</span> c.CategoryId <span class="keyword">AND</span> b.CategoryName <span class="operator">=</span> a.CategoryName) <span class="operator">*</span> <span class="number">1.0</span>) <span class="operator">/</span> ((<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> Category d, Product e <span class="keyword">WHERE</span> d.Id <span class="operator">=</span> e.CategoryId <span class="keyword">AND</span> d.CategoryName <span class="operator">=</span> a.CategoryName) <span class="operator">*</span> <span class="number">1.0</span>) , <span class="number">2</span>),</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="built_in">MIN</span>(f.UnitPrice),</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="built_in">MAX</span>(f.UnitPrice),</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="built_in">SUM</span>(f.UnitsOnOrder)</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> Category a, Product f</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> a.Id <span class="operator">=</span> f.CategoryId</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.CategoryName</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">HAVING</span> TotalCategoryCount <span class="operator">&gt;</span> <span class="number">10</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a.Id <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">Beverages<span class="operator">|</span><span class="number">12</span><span class="operator">|</span><span class="number">37.98</span><span class="operator">|</span><span class="number">4.5</span><span class="operator">|</span><span class="number">263.5</span><span class="operator">|</span><span class="number">60</span></span><br><span class="line">Condiments<span class="operator">|</span><span class="number">12</span><span class="operator">|</span><span class="number">23.06</span><span class="operator">|</span><span class="number">10</span><span class="operator">|</span><span class="number">43.9</span><span class="operator">|</span><span class="number">170</span></span><br><span class="line">Confections<span class="operator">|</span><span class="number">13</span><span class="operator">|</span><span class="number">25.16</span><span class="operator">|</span><span class="number">9.2</span><span class="operator">|</span><span class="number">81</span><span class="operator">|</span><span class="number">180</span></span><br><span class="line">Seafood<span class="operator">|</span><span class="number">12</span><span class="operator">|</span><span class="number">20.68</span><span class="operator">|</span><span class="number">6</span><span class="operator">|</span><span class="number">62.5</span><span class="operator">|</span><span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> b.CategoryName <span class="operator">=</span> a.CategoryName 这个条件确保了在计算每个类别的商品价格总和时，只考虑了与当前类别相关的商品</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 这是为了满足 <span class="keyword">HAVING</span> TotalCategoryCount <span class="operator">&gt;</span> <span class="number">10</span> 中的条件</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">*</span><span class="number">1.0</span> 的目的是将整数值转换为浮点数。这是为了确保在计算平均商品价格时，得到的结果是一个浮点数，而不是整数</span><br></pre></td></tr></table></figure>

<h1 id="Q6"><a href="#Q6" class="headerlink" title="Q6*"></a>Q6*</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">SELECT</span> p.ProductName, </span><br><span class="line">(<span class="keyword">SELECT</span> </span><br><span class="line">  c1.CompanyName <span class="operator">||</span> <span class="string">&#x27;|&#x27;</span> <span class="operator">||</span> c1.ContactName </span><br><span class="line">  <span class="keyword">FROM</span> Customer c1 </span><br><span class="line">  <span class="keyword">JOIN</span> [<span class="keyword">Order</span>] o1 <span class="keyword">ON</span> o1.CustomerId <span class="operator">=</span> c1.Id</span><br><span class="line">  <span class="keyword">JOIN</span> OrderDetail od1 <span class="keyword">ON</span> o1.Id <span class="operator">=</span> od1.OrderID</span><br><span class="line">  <span class="keyword">WHERE</span> od1.ProductId <span class="operator">=</span> p.Id</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> o1.OrderDate <span class="keyword">ASC</span> LIMIT <span class="number">1</span>) <span class="keyword">AS</span> CustomerInfo</span><br><span class="line"><span class="keyword">FROM</span> Product p</span><br><span class="line"><span class="keyword">JOIN</span> OrderDetail od <span class="keyword">ON</span> p.Id <span class="operator">=</span> od.ProductId</span><br><span class="line"><span class="keyword">JOIN</span> [<span class="keyword">Order</span>] o <span class="keyword">ON</span> od.OrderId <span class="operator">=</span> o.Id</span><br><span class="line"><span class="keyword">JOIN</span> CUSTOMER c <span class="keyword">ON</span> o.CustomerID <span class="operator">=</span> c.Id</span><br><span class="line"><span class="keyword">WHERE</span> p.Discontinued <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> p.ProductName;</span><br><span class="line"></span><br><span class="line">Alice Mutton<span class="operator">|</span>Consolidated Holdings<span class="operator">|</span>Elizabeth Brown</span><br><span class="line">Chef Anton<span class="string">&#x27;s Gumbo Mix|Piccolo und mehr|Georg Pipps</span></span><br><span class="line"><span class="string">Guaraná Fantástica|Piccolo und mehr|Georg Pipps</span></span><br><span class="line"><span class="string">Mishi Kobe Niku|Old World Delicatessen|Rene Phillips</span></span><br><span class="line"><span class="string">Perth Pasties|Piccolo und mehr|Georg Pipps</span></span><br><span class="line"><span class="string">Rössle Sauerkraut|Piccolo und mehr|Georg Pipps</span></span><br><span class="line"><span class="string">Singaporean Hokkien Fried Mee|Vins et alcools Chevalier|Paul Henriot</span></span><br><span class="line"><span class="string">Thüringer Rostbratwurst|Piccolo und mehr|Georg Pipps</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// c1		==&gt; FROM Customer c1 </span></span><br><span class="line"><span class="string">// c1-&gt;o1	==&gt; JOIN [Order] o1 ON o1.CustomerId = c1.Id</span></span><br><span class="line"><span class="string">// o1-&gt;od1	==&gt; JOIN OrderDetail od1 ON o1.Id = od1.OrderID</span></span><br><span class="line"><span class="string">// od1-&gt;p	==&gt; (将子查询和外部主查询联系起来)WHERE od1.ProductId = p.Id</span></span><br></pre></td></tr></table></figure>

<h2 id="Q7"><a href="#Q7" class="headerlink" title="Q7*"></a>Q7*</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Id, Orderdate, pre_OrderDate, ROUND(julianday(OrderDate)<span class="operator">-</span>julianday(pre_orderdate) , <span class="number">2</span>)</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> Id, OrderDate, <span class="built_in">LAG</span>(Orderdate, <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> CustomerId <span class="keyword">ORDER</span> <span class="keyword">BY</span> OrderDate <span class="keyword">ASC</span>) pre_OrderDate</span><br><span class="line">      <span class="keyword">FROM</span> [<span class="keyword">Order</span>]</span><br><span class="line">      <span class="keyword">WHERE</span> CustomerId <span class="operator">=</span> <span class="string">&#x27;BLONP&#x27;</span></span><br><span class="line">      LIMIT <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">16766</span><span class="operator">|</span><span class="number">2012</span><span class="number">-07</span><span class="number">-22</span> <span class="number">23</span>:<span class="number">11</span>:<span class="number">15</span><span class="operator">|</span><span class="number">0</span><span class="operator">|</span><span class="number">2456131.47</span></span><br><span class="line"><span class="number">10265</span><span class="operator">|</span><span class="number">2012</span><span class="number">-07</span><span class="number">-25</span><span class="operator">|</span><span class="number">2012</span><span class="number">-07</span><span class="number">-22</span> <span class="number">23</span>:<span class="number">11</span>:<span class="number">15</span><span class="operator">|</span><span class="number">2.03</span></span><br><span class="line"><span class="number">12594</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-16</span> <span class="number">12</span>:<span class="number">35</span>:<span class="number">15</span><span class="operator">|</span><span class="number">2012</span><span class="number">-07</span><span class="number">-25</span><span class="operator">|</span><span class="number">22.52</span></span><br><span class="line"><span class="number">20249</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">52</span>:<span class="number">23</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-16</span> <span class="number">12</span>:<span class="number">35</span>:<span class="number">15</span><span class="operator">|</span><span class="number">0.18</span></span><br><span class="line"><span class="number">20882</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-18</span> <span class="number">19</span>:<span class="number">11</span>:<span class="number">48</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">52</span>:<span class="number">23</span><span class="operator">|</span><span class="number">2.1</span></span><br><span class="line"><span class="number">18443</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-28</span> <span class="number">05</span>:<span class="number">34</span>:<span class="number">03</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-18</span> <span class="number">19</span>:<span class="number">11</span>:<span class="number">48</span><span class="operator">|</span><span class="number">9.43</span></span><br><span class="line"><span class="number">10297</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-04</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-28</span> <span class="number">05</span>:<span class="number">34</span>:<span class="number">03</span><span class="operator">|</span><span class="number">6.77</span></span><br><span class="line"><span class="number">11694</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-17</span> <span class="number">00</span>:<span class="number">27</span>:<span class="number">14</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-04</span><span class="operator">|</span><span class="number">13.02</span></span><br><span class="line"><span class="number">25613</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-18</span> <span class="number">22</span>:<span class="number">37</span>:<span class="number">15</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-17</span> <span class="number">00</span>:<span class="number">27</span>:<span class="number">14</span><span class="operator">|</span><span class="number">1.92</span></span><br><span class="line"><span class="number">17361</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">13</span>:<span class="number">21</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-18</span> <span class="number">22</span>:<span class="number">37</span>:<span class="number">15</span><span class="operator">|</span><span class="number">0.57</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> julianday(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">Result</span>: <span class="number">2458220.59892027</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 返回从格林尼治时间的公元前 <span class="number">4714</span> 年 <span class="number">11</span> 月 <span class="number">24</span> 日正午算起的天数</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="built_in">LAG</span>(expr, <span class="keyword">offset</span>, <span class="keyword">default</span>) <span class="keyword">OVER</span> (partition_by_clause order_by_clause)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 计算当前行向前数若干行的值，该函数专门用作窗口函数(<span class="keyword">window</span> functions)，<span class="keyword">partition</span> <span class="keyword">by</span>功能类似<span class="keyword">group</span> <span class="keyword">by</span></span><br></pre></td></tr></table></figure>

<h1 id="Q8"><a href="#Q8" class="headerlink" title="Q8*"></a>Q8*</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">WITH</span> expenditures <span class="keyword">AS</span>(</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">SELECT</span> </span><br><span class="line">   ...<span class="operator">&gt;</span>                        IFNULL(c.CompanyName, <span class="string">&#x27;MISSING_NAME&#x27;</span>) <span class="keyword">AS</span> CompanyName,</span><br><span class="line">   ...<span class="operator">&gt;</span>                        o.CustomerId,</span><br><span class="line">   ...<span class="operator">&gt;</span>                        ROUND((<span class="built_in">SUM</span>(od.Quantity <span class="operator">*</span> od.UnitPrice)) , <span class="number">2</span>) <span class="keyword">AS</span> totalcost</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">FROM</span> [<span class="keyword">Order</span>] o</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">JOIN</span> OrderDetail od <span class="keyword">ON</span> od.OrderId <span class="operator">=</span> o.Id</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Customer c <span class="keyword">ON</span> c.Id <span class="operator">=</span> o.CustomerId</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">GROUP</span> <span class="keyword">BY</span> o.CustomerId),</span><br><span class="line">   ...<span class="operator">&gt;</span>      quartiles <span class="keyword">AS</span>(</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">SELECT</span></span><br><span class="line">   ...<span class="operator">&gt;</span>                        <span class="operator">*</span>,</span><br><span class="line">   ...<span class="operator">&gt;</span>                        <span class="built_in">NTILE</span>(<span class="number">4</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> totalcost <span class="keyword">ASC</span>) <span class="keyword">AS</span> ExpenditureQuartile</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">FROM</span> expenditures)</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">SELECT</span> CompanyName, CustomerId, totalcost</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> quartiles</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> ExpenditureQuartile <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> totalcost <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">MISSING_NAME<span class="operator">|</span>DUMO<span class="operator">|</span><span class="number">1615.9</span></span><br><span class="line">MISSING_NAME<span class="operator">|</span>OCEA<span class="operator">|</span><span class="number">3460.2</span></span><br><span class="line">MISSING_NAME<span class="operator">|</span>ANTO<span class="operator">|</span><span class="number">7515.35</span></span><br><span class="line">MISSING_NAME<span class="operator">|</span>QUEE<span class="operator">|</span><span class="number">30226.1</span></span><br><span class="line">Trail<span class="string">&#x27;s Head Gourmet Provisioners|TRAIH|3874502.02</span></span><br><span class="line"><span class="string">Blondesddsl père et fils|BLONP|3879728.69</span></span><br><span class="line"><span class="string">Around the Horn|AROUT|4395636.28</span></span><br><span class="line"><span class="string">Hungry Owl All-Night Grocers|HUNGO|4431457.1</span></span><br><span class="line"><span class="string">Bon app|BONAP|4485708.49</span></span><br><span class="line"><span class="string">Bólido Comidas preparadas|BOLID|4520121.88</span></span><br><span class="line"><span class="string">Galería del gastrónomo|GALED|4533089.9</span></span><br><span class="line"><span class="string">FISSA Fabrica Inter. Salchichas S.A.|FISSA|4554591.02</span></span><br><span class="line"><span class="string">Maison Dewey|MAISD|4555931.37</span></span><br><span class="line"><span class="string">Cactus Comidas para llevar|CACTU|4559046.87</span></span><br><span class="line"><span class="string">Spécialités du monde|SPECD|4571764.89</span></span><br><span class="line"><span class="string">Magazzini Alimentari Riuniti|MAGAA|4572382.35</span></span><br><span class="line"><span class="string">Toms Spezialitäten|TOMSP|4628403.36</span></span><br><span class="line"><span class="string">Split Rail Beer &amp; Ale|SPLIR|4641383.53</span></span><br><span class="line"><span class="string">Santé Gourmet|SANTG|4647668.15</span></span><br><span class="line"><span class="string">Morgenstern Gesundkost|MORGK|4676234.2</span></span><br><span class="line"><span class="string">White Clover Markets|WHITC|4681531.74</span></span><br><span class="line"><span class="string">La corne d&#x27;</span>abondance<span class="operator">|</span>LACOR<span class="operator">|</span><span class="number">4724494.22</span></span><br><span class="line">Victuailles en stock<span class="operator">|</span>VICTE<span class="operator">|</span><span class="number">4726476.33</span></span><br><span class="line">Lonesome Pine Restaurant<span class="operator">|</span>LONEP<span class="operator">|</span><span class="number">4735780.66</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> IFNULL(c.CompanyName, <span class="string">&#x27;MISSING_NAME&#x27;</span>) <span class="keyword">AS</span> CompanyName  </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 处理<span class="keyword">NULL</span>值</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Customer c <span class="keyword">ON</span> c.Id <span class="operator">=</span> o.CustomerId</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 这种连接类型包含左表的所有行，以及右表中满足连接条件的行。如果右表中没有匹配的行，那么结果集中将包含 <span class="keyword">NULL</span> 值</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="built_in">NTILE</span>(<span class="number">4</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> totalcost <span class="keyword">ASC</span>) <span class="keyword">AS</span> ExpenditureQuartile</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 它将结果集划分为指定数量的桶（buckets），并为每个桶分配一个标识号（bucket number）</span><br></pre></td></tr></table></figure>
<p>现在，假设有以下支出数据：</p>
<table>
<thead>
<tr>
<th>CompanyName</th>
<th>CustomerId</th>
<th>totalcost</th>
</tr>
</thead>
<tbody><tr>
<td>Company1</td>
<td>1</td>
<td>100</td>
</tr>
<tr>
<td>Company2</td>
<td>2</td>
<td>150</td>
</tr>
<tr>
<td>Company3</td>
<td>3</td>
<td>200</td>
</tr>
<tr>
<td>Company4</td>
<td>4</td>
<td>250</td>
</tr>
<tr>
<td>Company5</td>
<td>5</td>
<td>300</td>
</tr>
</tbody></table>
<p><code>NTILE(4) OVER (ORDER BY totalcost ASC) AS ExpenditureQuartile</code>将分配 ExpenditureQuartile 值，结果如下：</p>
<table>
<thead>
<tr>
<th>CompanyName</th>
<th>CustomerId</th>
<th>totalcost</th>
</tr>
</thead>
<tbody><tr>
<td>Company1</td>
<td>1</td>
<td>100</td>
</tr>
<tr>
<td>Company2</td>
<td>2</td>
<td>150</td>
</tr>
<tr>
<td>Company3</td>
<td>3</td>
<td>200</td>
</tr>
<tr>
<td>Company4</td>
<td>4</td>
<td>250</td>
</tr>
<tr>
<td>Company5</td>
<td>5</td>
<td>300</td>
</tr>
</tbody></table>
<h1 id="Q9"><a href="#Q9" class="headerlink" title="Q9"></a>Q9</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> r.RegionDescription, e.FirstName, e.LastName, <span class="built_in">MAX</span>(e.BirthDate)</span><br><span class="line"><span class="keyword">FROM</span> Region r</span><br><span class="line"><span class="keyword">JOIN</span> Territory t <span class="keyword">ON</span> t.RegionId <span class="operator">=</span> r.Id</span><br><span class="line"><span class="keyword">JOIN</span> EmployeeTerritory et <span class="keyword">ON</span> et.TerritoryId <span class="operator">=</span> t.Id</span><br><span class="line"><span class="keyword">JOIN</span> Employee e <span class="keyword">On</span> e.Id <span class="operator">=</span> et.EmployeeId</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t.RegionId;</span><br><span class="line"></span><br><span class="line">Eastern<span class="operator">|</span>Steven<span class="operator">|</span>Buchanan<span class="operator">|</span><span class="number">1987</span><span class="number">-03</span><span class="number">-04</span></span><br><span class="line">Western<span class="operator">|</span>Michael<span class="operator">|</span>Suyama<span class="operator">|</span><span class="number">1995</span><span class="number">-07</span><span class="number">-02</span></span><br><span class="line">Northern<span class="operator">|</span>Anne<span class="operator">|</span>Dodsworth<span class="operator">|</span><span class="number">1998</span><span class="number">-01</span><span class="number">-27</span></span><br><span class="line">Southern<span class="operator">|</span>Janet<span class="operator">|</span>Leverling<span class="operator">|</span><span class="number">1995</span><span class="number">-08</span><span class="number">-30</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="built_in">MAX</span>(e.BirthDate)</span><br></pre></td></tr></table></figure>

<h1 id="Q10"><a href="#Q10" class="headerlink" title="Q10"></a>Q10</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> temptable <span class="keyword">AS</span>(</span><br><span class="line">                  <span class="keyword">SELECT</span> </span><br><span class="line">                    d.ProductName myproductname,</span><br><span class="line">                    strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>, b.OrderDate) <span class="type">date</span></span><br><span class="line">                  <span class="keyword">FROM</span> Customer a, [<span class="keyword">Order</span>] b, OrderDetail c, Product d</span><br><span class="line">                  <span class="keyword">WHERE</span> a.Id <span class="operator">=</span> b.CustomerId </span><br><span class="line">                    <span class="keyword">AND</span> b.Id <span class="operator">=</span> c.OrderId </span><br><span class="line">                    <span class="keyword">AND</span> c.ProductId <span class="operator">=</span> d.Id </span><br><span class="line">                    <span class="keyword">AND</span> a.CompanyName <span class="operator">=</span> <span class="string">&#x27;Queen Cozinha&#x27;</span> </span><br><span class="line">                    <span class="keyword">AND</span> <span class="type">date</span> <span class="operator">=</span> <span class="string">&#x27;2014-12-25&#x27;</span></span><br><span class="line">                  <span class="keyword">ORDER</span> <span class="keyword">BY</span> d.Id <span class="keyword">ASC</span>)</span><br><span class="line"><span class="keyword">SELECT</span> group_concat(myproductname)</span><br><span class="line"><span class="keyword">FROM</span> temptable;</span><br><span class="line"></span><br><span class="line">Mishi Kobe Niku,NuNuCa Nuß<span class="operator">-</span>Nougat<span class="operator">-</span>Creme,Schoggi Schokolade,Mascarpone Fabioli,Sasquatch Ale,Boston Crab Meat,Manjimup Dried Apples,Longlife Tofu,Lakkalikööri</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>, b.OrderDate) <span class="type">date</span>  </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 将日期和时间格式化为字符串，将原始日期格式转换为 &quot;年-月-日&quot; 的字符串格式</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Project</category>
        <category>cmu15-445</category>
      </categories>
  </entry>
  <entry>
    <title>cmu15-445 Project 0 (Spring 2023)</title>
    <url>/2024/02/28/Project/cmu15-445/cmu15-445%20Project%200%20(Spring%202023)%20%20/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="Task-1-Copy-On-Write-Trie"><a href="#Task-1-Copy-On-Write-Trie" class="headerlink" title="Task #1 - Copy-On-Write Trie"></a>Task #1 - Copy-On-Write Trie</h1><p>在<code>trie.cpp</code>中实现<code>COW Trie</code>。</p>
<p><code>COW</code>即代表，对<code>Trie</code>的添加&#x2F;删除操作不会在原<code>Trie</code>上进行，而是对原<code>Trie</code>进行拷贝后再进行修改。</p>
<p><code>trie.h</code>中共有三个类：</p>
<ul>
<li>​	<code>TrieNode</code>：表示Trie树不包含value的普通节点。<ul>
<li>组成：<ul>
<li><code>bool is_value_node_&#123;false&#125;;</code></li>
<li><code>std::map&lt;char, std::shared_ptr&lt;const TrieNode&gt;&gt; children_;</code></li>
</ul>
</li>
</ul>
</li>
<li><code>TrieNodeWithValue</code>：<code>Trie</code>树包含<code>value</code>的节点，由<code>TrieNode</code>派生而来。<ul>
<li>新增组成：<ul>
<li><code>std::shared_ptr&lt;T&gt; value_;</code></li>
</ul>
</li>
</ul>
</li>
<li><code>Trie</code>：<code>Trie</code> 树的本体，<ul>
<li>组成：<ul>
<li><code>std::shared_ptr&lt;const TrieNode&gt; root_&#123;nullptr&#125;;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注意：</p>
<p>1、一个 <code>shared_ptr&lt;const TrieNode&gt;</code> 智能指针（<code>root</code>）指向一个 <code>TrieNode</code> 节点，而 <code>TrieNode</code> 节点中的 <code>map</code> 则含有多个可以指向下一个 <code>TrieNode</code> 节点的智能指针。也就是说，当 <code>TrieNode</code> 调用 <code>Clone()</code> 时，会复制一份<strong>当前节点</strong>并返回。由于返回的是 <code>unique_ptr</code>，因此我们只能用 <code>shared_ptr</code> 的构造函数来接收，然后再对 <code>shared_ptr</code> 进行赋值，类似于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;TrieNode&gt; new_root = std::<span class="built_in">shared_ptr</span>&lt;TrieNode&gt;(<span class="keyword">this</span>-&gt;root_-&gt;<span class="built_in">Clone</span>());</span><br></pre></td></tr></table></figure>

<h2 id="1、Get-key"><a href="#1、Get-key" class="headerlink" title="1、Get(key)"></a>1、<code>Get(key)</code></h2><p>（1）考虑<code>key</code>为空的边界情况，此时看<code>root</code>是否是一个<code>TrieNodeWithVal</code>节点；</p>
<p>（2）考虑<code>root</code>为空的边界情况，此时直接返回一个<code>nullptr</code>；</p>
<p>（3）若非上述两种边界情况，则通过遍历进行<code>Get</code>操作：</p>
<ul>
<li>定义一个<code>cur</code>指向当前根节点，注意<code>root</code>的类型是<code>std::shared_ptr&lt;const bustub::TrieNode&gt;</code></li>
<li>对<code>key</code>的所有字符进行遍历，<code>cur</code>不断更新迭代指向<code>cur-&gt;children-&gt;second</code>，直到找到<code>key</code>的键尾为止；</li>
<li>判断此时的<code>cur</code>是否是一个<code>TrieNodeWithVal</code>节点</li>
</ul>
<p>注意：返回的<code>value</code>——<code>std::shared_ptr&lt;T&gt; value_</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> *twnv = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> bustub::TrieNodeWithValue&lt;T&gt; *&gt;(root_.<span class="built_in">get</span>());</span><br><span class="line"><span class="comment">// const确保twnv是一个指向常量对象的指针，最好保留以明确这种限制</span></span><br><span class="line"><span class="comment">// dynamic_cast的目的是为了检查在运行时root_所指向的对象是否实际上是TrieNodeWithValue&lt;T&gt;或其派生类型</span></span><br></pre></td></tr></table></figure>

<h2 id="2、Put-key-value"><a href="#2、Put-key-value" class="headerlink" title="2、Put(key, value)"></a>2、<code>Put(key, value)</code></h2><p><code>Put</code>操作最需要注意的点在于：在插入时，已有的节点执行<code>Clone()</code>操作，新建的节点执行<code>make_shared</code>操作，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/b8962d07c7484d00bdb71214b75ea157.png#pic_center" alt="在这里插入图片描述"></p>
<p>逻辑如下：</p>
<p>（1）考虑<code>key</code>为空的边界情况，此时在<code>root</code>处插入</p>
<ul>
<li>创建新的<code>shared_ptr</code>指针指向<code>value</code>和为空的<code>new_root</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;T&gt; val_p = std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">std::shared_ptr&lt;bustub::TrieNodeWithValue&lt;T&gt;&gt; new_root = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>判断原<code>root</code>是否有子节点，处理后返回新的<code>Trie</code>的根结点<code>new_root</code></p>
<ul>
<li><p>若无，则直接对<code>new_root</code>进行修改；</p>
</li>
<li><p>若有，则构造一个新节点指向<code>root</code>的<code>children</code>，如图</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403011541108.png" alt="image-20240301154103793"></p>
</li>
</ul>
</li>
</ul>
<p>（2）若<code>key</code>非空</p>
<ul>
<li><p>首先拷贝根节点<code>root</code></p>
<ul>
<li>若<code>root</code>空，直接新建空的<code>Trie</code></li>
<li>若<code>root</code>非空，调用<code>Clone()</code>操作，拷贝<code>root</code>的已有<code>children</code>给<code>new_root</code></li>
</ul>
</li>
<li><p><code>Put1()</code>函数递归插入</p>
<ul>
<li><p>遍历<code>new_root</code>的<code>children</code>，找到是否有哪一个<code>children</code>的<code>key</code>等于传入<code>key</code>的<code>key[0]</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pair : new_root-&gt;children_) &#123;&#125;</span><br><span class="line"><span class="comment">// pari类型：std::map&lt;char, std::shared_ptr&lt;const TrieNode&gt;&gt; children</span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断完<code>key[0]</code>后，对<code>key</code>剩余的值进行判断<ul>
<li>若到达<code>key</code>的键尾，新建一个节点并覆盖掉<code>pair</code>的<code>second</code></li>
<li>若未到达键尾，拷贝已有节点、递归调用<code>Put1</code>写入<code>key</code>、将写入完成后的节点重新拷贝给<code>pair.second</code></li>
</ul>
</li>
</ul>
</li>
<li><p>若未找到匹配的<code>key[0]</code>，则直接新建节点插入。注意判断<code>key</code>的长度以决定是否需要递归操作。</p>
</li>
</ul>
</li>
<li><p>返回新的<code>Trie</code></p>
</li>
</ul>
<p>注意：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;bustub::TrieNode&gt; ptr = pair.second-&gt;<span class="built_in">Clone</span>();</span><br><span class="line"><span class="comment">// Clone()返回的对象是std::unique_ptr&lt;TrieNode&gt;类型，为了确保ptr能够在程序的其他地方被共享所有权，因此</span></span><br><span class="line"><span class="comment">// 用std::shared_ptr&lt;bustub::TrieNode&gt;接收</span></span><br></pre></td></tr></table></figure>

<h2 id="3、Remove-key"><a href="#3、Remove-key" class="headerlink" title="3、Remove(key)"></a>3、<code>Remove(key)</code></h2><p><code>Remove</code>的思想和<code>Put</code>一致，不再赘述。</p>
<h1 id="Task-2-Concurrent-Key-Value-Store"><a href="#Task-2-Concurrent-Key-Value-Store" class="headerlink" title="Task #2 - Concurrent Key-Value Store"></a>Task #2 - Concurrent Key-Value Store</h1><p>注意加锁的时机即可。</p>
<p><code>read</code>操作只需要在获取根节点时加锁。</p>
<p><code>write</code>操作则需要全程添加写锁，从而保证只有一名<code>writer</code>。此外，在获取根节点和更新修改后的根结点时，需要添加读锁。</p>
]]></content>
      <categories>
        <category>Project</category>
        <category>cmu15-445</category>
      </categories>
  </entry>
  <entry>
    <title>代码随想录</title>
    <url>/2024/04/09/%E9%9D%A2%E8%AF%95/DataStruct/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><h2 id="1、二分法"><a href="#1、二分法" class="headerlink" title="1、二分法"></a>1、二分法</h2><p>采用二分法的前提条件：</p>
<ol>
<li><strong>数组有序（升序）；</strong></li>
<li><strong>无重复元素。</strong></li>
</ol>
<p>基础模版：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭区间 [left, right]</span></span><br><span class="line"><span class="comment">// 1. while(left &lt;= right) </span></span><br><span class="line"><span class="comment">// 2. right = mid - 1;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></p>
<p><a href="https://leetcode.cn/problems/search-insert-position/submissions/521863494/">35. 搜索插入位置</a></p>
<p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<p>这道题做的时候卡了很久，最开始采用前闭后开的区间，但结果是错的，改成前闭后闭的区间就正确了。</p>
<p><a href="https://leetcode.cn/problems/sqrtx/">69. x的平方根</a></p>
<p>1、由于y&#x3D;√x的图像是单调递增的，符合二分查找的条件，因此本题可采用二分查找的方式解决。</p>
<p>2、题目所述x为非负整数，因此left应该初始化为1而非0。</p>
<p>3、<strong>最后结束循环，返回右边界，主要是因为平方根是向下取整，例如 8 的平方跟是 2，而循环结束的条件又是 l &gt; r，因此最后返回右边界 r</strong></p>
<h2 id="2、双指针法"><a href="#2、双指针法" class="headerlink" title="2、双指针法"></a>2、双指针法</h2><p>双指针法：通过一个快指针和一个慢指针在一个for循环下完成两个for循环的工作</p>
<ol>
<li><p><strong>快慢指针</strong>：<strong>快慢指针通常都从下标为0的地方开始走</strong>，当快指针达到末尾时，慢指针通常还在中间位置。</p>
<ul>
<li><p>快指针（<code>fast</code>）：用于判断是否满足题目条件；</p>
</li>
<li><p>慢指针（<code>slow</code>）：保存不满足条件的值（<code>nums[fast]</code>），比如题目要求是移除数组中等于<code>val</code>的值，那么fast遍历完毕数组后，剩下的就是不等于<code>val</code>的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> fast=<span class="number">0</span>; fast&lt;nums.<span class="built_in">size</span>(); fast++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">            nums[slow++] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>左右指针</strong>：<strong>左右指针分别从数组的两端出发</strong>，根据问题的要求移动指针，并通过调整指针位置来实现问题的解决。</p>
</li>
<li><p><strong>滑动窗口</strong>：常用于解决数组或字符串中的子数组或子串问题，如最小覆盖子串、最长无重复字符的子串等。滑动窗口由左右指针定义，<strong>左指针指向窗口的起始位置，右指针指向窗口的结束位置，通过移动两个指针来扩大或缩小窗口</strong>，从而找到满足特定条件的子数组或子串。</p>
<blockquote>
<p><strong>滑动窗口的核心在于当找到一个满足条件的子数组时，要继续尝试缩小窗口以找到更小的子数组。</strong></p>
<p>在采用滑动窗口解决问题时，主要确定以下三点：</p>
<ul>
<li><p>窗口内是什么？</p>
</li>
<li><p>如何移动窗口的起始位置？</p>
</li>
<li><p>如何移动窗口的结束位置？</p>
</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></p>
<ul>
<li><p>解题思路</p>
<p>本题要求：<em>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组</em>，看到这样的要求时，就要很快地联想到<strong>双指针法（快慢指针法）</strong>。</p>
<ol>
<li><code>fast</code>和<code>slow</code>同时指向数组开始；</li>
<li>判断是否<code>nums[fast]==val</code>，若相等，<code>fast</code>前移一位，继续判断，直到<code>nums[fast]!=val</code>；</li>
<li>此时，将<code>nums[fast]</code>赋值给<code>nums[slow]</code>，<code>slow</code>前移一位；</li>
<li>循环执行步骤<strong>2&amp;3</strong>，直到<code>fast</code>遍历到数组末尾。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[fast] == val) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">                <span class="keyword">if</span> (fast == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> slow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></p>
<ul>
<li><p>解题思路</p>
<p>由于题目中已经说了“整数数组<code>nums</code>是非递减的”，那么在包含负数的情况下，平方后最大值就只能位于数组的两端。因此可以采用<strong>双指针法</strong>，用两个指针分别指向最左边和最右边，依次向中间移动。</p>
<ol>
<li>用两个指针<code>l</code>和<code>r</code>分别指向最左边和最右边，同时定义一个新的数组作为结果数组返回；</li>
<li>判断左右两边谁平方后的值更大，将大的那个放入结果数组的最右边；</li>
<li>更新指针；</li>
<li>重复步骤2&amp;3，直到原数组遍历完毕。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> index = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> tmpl = nums[l] * nums[l];</span><br><span class="line">            <span class="type">int</span> tmpr = nums[r] * nums[r];</span><br><span class="line">            <span class="keyword">if</span> (tmpl &lt; tmpr) &#123;</span><br><span class="line">                res[index] = tmpr;</span><br><span class="line">                index--;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[index] = tmpl;</span><br><span class="line">                index--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></p>
<ul>
<li><p>解题思路</p>
<p><strong>当看到题目中出现“子数组”、“子序列”等时，一般就要想到采用滑动窗口来解决。</strong>但这里我最开始想的是下面这种解法，这样实际上就是一种暴力的思想，而非双指针的思想。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样写会超时</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="type">int</span> sum = nums[i];</span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        sum += nums[j];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = j-i+<span class="number">1</span>;</span><br><span class="line">            len = tmp &lt; len ? tmp : len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，在本题中窗口就是满足其<code>和&gt;=target</code>的长度最小的连续子数组。移动窗口的起始位置是为了在满足条件的情况下缩小窗口，移动窗口的结束位置是为了遍历数组的所有元素。</p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        sum += nums[r++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, r-l);</span><br><span class="line">            sum -= nums[l++];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 或</span></span><br><span class="line">            <span class="comment">// sum -= nums[l++];</span></span><br><span class="line">            /res = <span class="built_in">min</span>(res, r-l+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、循环不变原则"><a href="#3、循环不变原则" class="headerlink" title="3、循环不变原则"></a>3、循环不变原则</h2><h3 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59. 螺旋矩阵II"></a>59. 螺旋矩阵II</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵II</a></p>
<ul>
<li><p>解题思路</p>
<p>本题实际上就是考察了<strong>循环不变量原则</strong>，要注意选择好了遍历<strong>区间的开闭</strong>后就一定要贯彻其开闭原则。</p>
<p>将整个过程分为从外到内“画”每一圈的过程。在此基础上，每一圈又包含4步：</p>
<ol>
<li>从左至右</li>
<li>从上至下</li>
<li>从右至左</li>
<li>从下至上</li>
</ol>
<p>这样经过一圈之后，就会回到这一圈的起点，接下来遍历下一圈，直到结束为止。</p>
<p>要注意几个地方：</p>
<ol>
<li><p>每一圈的起始坐标依次为<code>(1, 1)</code>，<code>(2, 2)</code>，….，因此每一圈结束后，<code>x</code>和<code>y</code>的起始位置都要分别加1才能进入下一圈；</p>
</li>
<li><p>循环的结束条件就是遍历到了最后一圈，其中要循环的圈数是<code>n/2</code>，这个可以举几个例子推导；另外一个要注意的就是当<code>n</code>为奇数时，最内圈是一个单独的值<code>n^2</code>，需要单独填充；</p>
</li>
<li><p>在遍历每一圈的4条边时，坚持左闭右开的原则：也就是说，每一条边的最后<code>n</code>个值属于下一条边。如下图所示，这是第一圈的情况。一定要记得设置一个<code>offset</code>，<strong>因为每遍历一圈，每条边的右边界就要收缩一位。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404102110076.png" alt="image-20240410211008731" style="zoom:33%;" /></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>;     <span class="comment">// 定义每一圈的起始坐标位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>;               <span class="comment">// 定义循环几圈</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>;                 <span class="comment">// 定义每一条边遍历的长度 </span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;                  <span class="comment">// 用来给矩阵赋值</span></span><br><span class="line">        <span class="keyword">while</span> (loop--) &#123;</span><br><span class="line">            <span class="type">int</span> i = startx;</span><br><span class="line">            <span class="type">int</span> j = starty;</span><br><span class="line">            <span class="comment">// 从左至右</span></span><br><span class="line">            <span class="keyword">for</span> (j; j&lt;n-offset; ++j) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="comment">// 从上至下</span></span><br><span class="line">            <span class="keyword">for</span> (i; i&lt;n-offset; ++i) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从右至左</span></span><br><span class="line">            <span class="keyword">for</span> (j; j&gt;starty; --j) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从下至上</span></span><br><span class="line">            <span class="keyword">for</span> (i; i&gt;startx; --i) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset++;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            res[n/<span class="number">2</span>][n/<span class="number">2</span>] = n*n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h1><p>实际上感觉链表的题都可以用快慢指针来解决。</p>
<h2 id="1、链表的定义"><a href="#1、链表的定义" class="headerlink" title="1、链表的定义"></a>1、链表的定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	ListNode *next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、删除链表元素"><a href="#2、删除链表元素" class="headerlink" title="2、删除链表元素"></a>2、删除链表元素</h2><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><p>举例来说，从<code>2-&gt;6-&gt;3</code>中删除节点6，需要完成以下几步：</p>
<p>（1）保存节点6，便于后续释放；</p>
<p>（2）将2的next改完3；</p>
<p>（3）释放原节点6。</p>
</li>
<li><p>注意要引入一个虚拟头结点，这样就可以避免在操作时还要区分头节点和非头节点两种情况。并且注意在最后返回真正的头节点时，返回的是<code>dummyhead-&gt;next</code>。</p>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *dummynode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummynode-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode *cur = dummynode;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode *tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummynode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummynode;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a>707. 设计链表</h3><p><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></p>
<ul>
<li><p>解题思路</p>
<p>这里有一个要注意的点，那就是对于这个<code>index</code>，在访问操作和增删操作时，遍历停止的位置是不同的：</p>
<ol>
<li>对于访问操作，需要<code>cur</code>正好停在<strong>下标为<code>index</code>的节点</strong>上，这样才能正确取到值；</li>
<li>对于增删操作，需要<code>cur</code>停在<strong>下标为<code>index</code>的前一个节点</strong>上，这样才方便进行增删操作。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (index-- &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        tmp-&gt;next = _dummyhead-&gt;next;</span><br><span class="line">        _dummyhead-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListNode *_dummyhead;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="19-删除链表的倒数第N个结点"><a href="#19-删除链表的倒数第N个结点" class="headerlink" title="19. 删除链表的倒数第N个结点"></a>19. 删除链表的倒数第N个结点</h3><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第N个结点</a></p>
<ul>
<li><p>解题思路</p>
<p>本题我采用了两趟扫描的方式进行解答。第一趟扫描确定了链表的长度，第二趟扫描则定位到了<strong>要删除结点的前一个结点</strong>。</p>
<ol>
<li><p>由于涉及到对头节点<code>head</code>的操作，因此定义一个<code>dummyhead</code>，避免需要对头结点单独操作；</p>
</li>
<li><p>如何定位到要删除结点的前一个结点，实际上需要分析<code>n</code>和<code>sz</code>之间的关系，如下图所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404120946983.png" alt="image-20240412094658218" style="zoom: 33%;" /></li>
</ol>
<blockquote>
<p>然而这道题我看了代码随想录提供的题解，实际上也是快慢指针法的一种变体，并且使用快慢指针法就可以无需先遍历一遍链表来求出链表的总长度。</p>
<p>只需要定义<code>fast</code>和<code>slow</code>两个指针</p>
<ul>
<li><code>fast</code>先走<code>n+1</code>步。之后<code>fast</code>和<code>slow</code>同时向前走；</li>
<li>当<code>fast</code>指向<code>nullptr</code>时，<code>slow</code>就正好指向要删除结点的前一个结点。</li>
</ul>
</blockquote>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *cur1 = head;</span><br><span class="line">        <span class="type">int</span> sz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            sz++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line">        ListNode *cur = dummyhead;</span><br><span class="line">        <span class="type">int</span> m = sz-n;</span><br><span class="line">        <span class="keyword">while</span> (m &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        head = dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyhead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、反转链表"><a href="#3、反转链表" class="headerlink" title="3、反转链表"></a>3、反转链表</h2><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><p>这道题实际上也相当于是双指针法中的快慢指针，通过定义两个指针<code>pre</code>和<code>cur</code>来依次遍历链表中的所有元素，并在遍历的过程中修改指针的指向。</p>
</li>
<li><p>有一个要注意的点在于：<code>while</code>循环的终止条件是<code>cur != nullptr</code>，若采用<code>cur-&gt;next != nullptr</code>，则最后一个节点不会被遍历到。</p>
</li>
</ol>
</li>
<li><p>AC代码（双指针法）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AC代码（递归法）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode *pre, ListNode *cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        ListNode *tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(cur, tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">NULL</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p>
<ul>
<li><p>解题思路</p>
<p>实际上这道题只要能够画图模拟出交换的过程，就没有问题了。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404111457295.png" alt="image-20240411145728810"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode *cur = dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode *tmp1 = cur-&gt;next;</span><br><span class="line">            ListNode *tmp2 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next = tmp1;</span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = tmp2;</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next;  <span class="comment">// cur要往后跳两步</span></span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyhead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、链表相交"><a href="#4、链表相交" class="headerlink" title="4、链表相交"></a>4、链表相交</h2><h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></p>
<ul>
<li><p>解题思路</p>
<p>主要有以下几个点要注意：</p>
<ol>
<li><p>最开始我额外定义了<code>a</code>和<code>b</code>用于去遍历两个链表来长度，实际上可以直接定义<code>curA</code>和<code>curB</code>，在遍历结束上让其重新指向头结点即可；</p>
</li>
<li><p>该题交点不是数值相等，而是指针相等！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (curA-&gt;val == curB-&gt;val)  <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">if</span> (curA == curB)			 <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size_a = <span class="number">0</span>, size_b = <span class="number">0</span>;</span><br><span class="line">        ListNode *curA = headA;</span><br><span class="line">        ListNode *curB = headB;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            size_a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">            size_b++;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">abs</span>(size_a - size_b);</span><br><span class="line">        <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// if (curA-&gt;val == curB-&gt;val) &#123;</span></span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></p>
<ul>
<li><p>解题思路</p>
<p>定义快慢指针<code>fast</code>和<code>slow</code>，其中<code>fast</code>每次走两个结点，<code>slow</code>每次走一个结点。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121316807.png" alt="image-20240412131623148"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *index1 = fast;</span><br><span class="line">                ListNode *index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三、哈希表"><a href="#三、哈希表" class="headerlink" title="三、哈希表"></a>三、哈希表</h1><h2 id="1、理论基础"><a href="#1、理论基础" class="headerlink" title="1、理论基础"></a>1、理论基础</h2><p>哈希表即为散列表，一般用于判断一个元素是否出现在集合里。</p>
<p>（1）常见的三种哈希函数：</p>
<ul>
<li><p>数组</p>
</li>
<li><p>集合（<code>set</code>）</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<ul>
<li><code>std::unordered_set</code>底层实现为哈希表；</li>
<li><code>std::set</code>和<code>std::multiset</code>的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以<code>key</code>值是有序的，但<code>key</code>不可以修改，改动<code>key</code>值会导致整棵树的错乱，所以只能删除和增加。</li>
</ul>
</li>
<li><p>映射（<code>map</code>）</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<ul>
<li><code>std::unordered_map</code>底层实现为哈希表；</li>
<li><code>std::map</code>和<code>std::multimap</code>的底层实现是红黑树。同理，<code>std::map</code>和<code>std::multimap</code>的<code>key</code>也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</li>
</ul>
</li>
</ul>
<p>（2）<code>std::unordered_set</code>提供了一系列方法来管理集合中的元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">插入元素：</span><br><span class="line">    <span class="built_in">insert</span>(): 向集合中插入元素。</span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">    <span class="built_in">erase</span>(): 删除集合中的元素。</span><br><span class="line">    <span class="built_in">clear</span>(): 清空集合中的所有元素。</span><br><span class="line"></span><br><span class="line">查找元素：</span><br><span class="line">    <span class="built_in">find</span>(): 查找集合中是否存在指定元素。</span><br><span class="line">    <span class="built_in">count</span>(): 统计集合中指定元素的个数。</span><br><span class="line"></span><br><span class="line">迭代器：</span><br><span class="line">    <span class="built_in">begin</span>(): 返回指向集合起始元素的迭代器。</span><br><span class="line">    <span class="built_in">end</span>(): 返回指向集合末尾元素的迭代器。</span><br><span class="line"></span><br><span class="line">大小和容量：</span><br><span class="line">    <span class="built_in">size</span>(): 返回集合中元素的个数。</span><br><span class="line">    <span class="built_in">empty</span>(): 检查集合是否为空。</span><br><span class="line"></span><br><span class="line">其他操作：</span><br><span class="line">    <span class="built_in">bucket_count</span>(): 返回集合中桶的数量。</span><br><span class="line">    <span class="built_in">load_factor</span>(): 返回集合的负载因子。</span><br><span class="line">    <span class="built_in">max_load_factor</span>(): 设置或返回集合的最大负载因子。</span><br></pre></td></tr></table></figure>

<p>（3）<code>std::set</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">插入元素：</span><br><span class="line">    <span class="built_in">insert</span>(): 向集合中插入元素。</span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">    <span class="built_in">erase</span>(): 删除集合中的元素。</span><br><span class="line">    <span class="built_in">clear</span>(): 清空集合中的所有元素。</span><br><span class="line"></span><br><span class="line">查找元素：</span><br><span class="line">    <span class="built_in">find</span>(): 查找集合中是否存在指定元素。</span><br><span class="line">    <span class="built_in">count</span>(): 统计集合中指定元素的个数。</span><br><span class="line"></span><br><span class="line">迭代器：</span><br><span class="line">    <span class="built_in">begin</span>(): 返回指向集合起始元素的迭代器。</span><br><span class="line">    <span class="built_in">end</span>(): 返回指向集合末尾元素的迭代器。</span><br><span class="line"></span><br><span class="line">大小和容量：</span><br><span class="line">    <span class="built_in">size</span>(): 返回集合中元素的个数。</span><br><span class="line">    <span class="built_in">empty</span>(): 检查集合是否为空。</span><br><span class="line"></span><br><span class="line">其他操作：</span><br><span class="line">    <span class="built_in">lower_bound</span>(): 返回指向大于或等于给定值的第一个元素的迭代器。</span><br><span class="line">    <span class="built_in">upper_bound</span>(): 返回指向大于给定值的第一个元素的迭代器。</span><br><span class="line">    <span class="built_in">equal_range</span>(): 返回集合中与给定值相等的元素范围。</span><br></pre></td></tr></table></figure>

<p>（3）<code>std::map</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">相关操作：</span><br><span class="line">    <span class="built_in">insert</span>()：用于将元素插入到map中。</span><br><span class="line">    <span class="built_in">erase</span>()：用于从map中删除指定的元素。</span><br><span class="line">    <span class="built_in">find</span>()：用于查找指定键对应的元素。</span><br><span class="line">    <span class="built_in">size</span>()：返回map中元素的数量。</span><br><span class="line">    <span class="built_in">clear</span>()：清空map中的所有元素。</span><br><span class="line">    <span class="built_in">begin</span>()：返回指向map起始元素的迭代器。</span><br><span class="line">    <span class="built_in">end</span>()：返回指向map末尾元素的迭代器。</span><br><span class="line">    <span class="built_in">count</span>()：返回指定键在map中出现的次数。</span><br></pre></td></tr></table></figure>

<h2 id="2、数组、set和map该如何选择？"><a href="#2、数组、set和map该如何选择？" class="headerlink" title="2、数组、set和map该如何选择？"></a>2、数组、set和map该如何选择？</h2><h3 id="什么时候选择用哈希表？"><a href="#什么时候选择用哈希表？" class="headerlink" title="什么时候选择用哈希表？"></a>什么时候选择用哈希表？</h3><p>当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候。</p>
<h3 id="什么时候选择用数组？"><a href="#什么时候选择用数组？" class="headerlink" title="什么时候选择用数组？"></a>什么时候选择用数组？</h3><p>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</p>
<p>如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费，此时不应使用数组。</p>
<h3 id="什么时候选择用set？"><a href="#什么时候选择用set？" class="headerlink" title="什么时候选择用set？"></a>什么时候选择用set？</h3><h3 id="什么时候选择用map？"><a href="#什么时候选择用map？" class="headerlink" title="什么时候选择用map？"></a>什么时候选择用map？</h3><h2 id="3、采用数组作为哈希函数"><a href="#3、采用数组作为哈希函数" class="headerlink" title="3、采用数组作为哈希函数"></a>3、采用数组作为哈希函数</h2><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h3><p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></p>
<ul>
<li><p>解题思路</p>
<p>由于“字母异位词”的定义是：两个词中每个字符出现的数组相同，而本题假设词中仅包含小写字母。因此直观的想法就是定义一个数组，先遍历<code>s</code>，将每个字符在数组中对应的位置加1，再遍历<code>t</code>，将每个字符在数组中对应的位置减1，这样若最终数组为全0，则这两个词是字母异位词。</p>
<p>但我陷入的思维瓶颈在于，我想的是按照<code>s</code>中每个字符出现的顺序定义数组<code>a</code>，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s = &quot;anagram&quot;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">// 其中下标1代表字符a</span></span><br></pre></td></tr></table></figure>

<p>但这样实际上就相当于是一个<code>map</code>了，操作变得格外复杂。</p>
<p>实际上，由于小写字母是有顺序的26个，因此只需要定义一个<code>int a[26]</code>，对于<code>s</code>中遍历到的每个字符，通过<code>s[i] - &#39;a&#39;</code>就可以定位到对应的下标。</p>
</li>
<li><p>易混知识点：</p>
<ol>
<li><p><code>a - &#39;a&#39;</code>:</p>
<ul>
<li><strong>用于将字母字符转换成一个从0开始的索引</strong>（例如，’a’变成0, ‘b’变成1, 等等）。</li>
</ul>
<ul>
<li>这里 <code>&#39;a&#39;</code> 是一个字符，其ASCII值是 97。</li>
<li>所以 <code>a - &#39;a&#39;</code> 实际上是计算 <code>97 - 97</code>，结果是 0。</li>
</ul>
</li>
<li><p><code>&#39;1&#39; - &#39;0&#39;</code> </p>
<ul>
<li><strong>计算两个字符的ASCII值之差，用于将字符表示的数字转换成其对应的整数值。</strong></li>
</ul>
<ul>
<li><code>&#39;1&#39;</code> 的 ASCII 值是 49，<code>&#39;0&#39;</code>是 48。所以，<code>&#39;1&#39;-&#39;0&#39;</code> 的计算过程是 <code>49-48</code>，结果是 1。</li>
</ul>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;t.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            record[t[j] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m=<span class="number">0</span>; m&lt;<span class="number">26</span>; ++m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[m] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></p>
<ul>
<li><p>解题思路</p>
<p>和242完全一致。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131611.png" alt="image-20240420113156470"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;magazine.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            record[magazine[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ransomNote.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            record[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m=<span class="number">0</span>; m&lt;<span class="number">26</span>; ++m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[m] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、采用set解题"><a href="#4、采用set解题" class="headerlink" title="4、采用set解题"></a>4、采用set解题</h2><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></p>
<ul>
<li><p>解题思路</p>
<p>由于本题的哈希值较少、较分散且跨度非常大，因此不能采用数组来实现。由于最终的结果无需排序，无重复，且只需要返回元素本身，不需要返回对应的下标，因此采用set即可。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131372.png" alt="image-20240420113120142"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; nums_set;</span><br><span class="line">        nums_set.<span class="built_in">insert</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> nums : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums_set.<span class="built_in">find</span>(nums) != nums_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></p>
<ul>
<li><p>解题思路</p>
<p>可以发现</p>
<ul>
<li>1）哈希值较分散，且跨度较大（不采用数组，应采用set或map）；</li>
<li>2）不需要同时保存元素和下标等成对出现，有对应关系的元素（不采用map）；</li>
<li>3）就是要找是否有重复的元素出现，因此采用set实现。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131501.png" alt="image-20240420113130345"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            sum += (n%<span class="number">10</span>) * (n%<span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; compare_set = &#123;n&#125;;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">        <span class="keyword">while</span> (sum != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compare_set.<span class="built_in">find</span>(sum) != compare_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// sum = getSum(sum);</span></span><br><span class="line">                compare_set.<span class="built_in">insert</span>(sum);</span><br><span class="line">                sum = <span class="built_in">getSum</span>(sum);  <span class="comment">// 这里一定要先把上一步计算得到的sum加入compare_set后，再计算新的sum</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、采用map解题"><a href="#5、采用map解题" class="headerlink" title="5、采用map解题"></a>5、采用map解题</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p>
<ul>
<li><p>解题思路</p>
<p>本题不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，<strong>需要使用key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p>
<p><strong>这道题目中并不需要key有序，选择std::unordered_map 效率更高</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131120.png" alt="image-20240420113138973"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; compare_map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = compare_map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (iter != compare_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second, i&#125;;           </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// compare_map.insert(nums[i], i);</span></span><br><span class="line">                compare_map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(nums[i], i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454. 四数相加II"></a>454. 四数相加II</h3><p><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加II</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131021.png" alt="image-20240420113148798"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; res1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num1 : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num2 : nums2) &#123;</span><br><span class="line">                <span class="type">int</span> sum = num1 + num2;</span><br><span class="line">                res1[sum]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num3 : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num4 : nums4) &#123;</span><br><span class="line">                <span class="type">int</span> sum = num3 + num4;</span><br><span class="line">                cnt += res1[-sum];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h1><h2 id="1、反转字符串"><a href="#1、反转字符串" class="headerlink" title="1、反转字符串"></a>1、反转字符串</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h3><ul>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> il = s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">auto</span> ir = s.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (il &lt;= ir) &#123;</span><br><span class="line">            <span class="comment">// char tmp;</span></span><br><span class="line">            <span class="comment">// tmp = *il;</span></span><br><span class="line">            <span class="comment">// *il = *ir;</span></span><br><span class="line">            <span class="comment">// *ir = tmp;</span></span><br><span class="line">            <span class="built_in">swap</span>(*il, *ir)</span><br><span class="line">            il++;</span><br><span class="line">            ir--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404222114861.png" alt="image-20240422211359195"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i+=<span class="number">2</span>*k) &#123;</span><br><span class="line">            <span class="type">int</span> start = i;</span><br><span class="line">            <span class="type">int</span> end = std::<span class="built_in">min</span>(start+k, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>()));</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+start, s.<span class="built_in">begin</span>()+end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a>151. 反转字符串中的单词</h3><ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404222114609.png" alt="image-20240422211419481"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string &amp;s, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=begin, j=end; i&lt;=j; ++i, --j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeSpace</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slow) &#123;</span><br><span class="line">                    s[slow++] = <span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">                    <span class="comment">// 当slow不在开头时，如果此时遇到了s[i]不为空格，则说明接下来需要从slow开始写新的单词了</span></span><br><span class="line">                    <span class="comment">// 因此手动控制添加一个空格</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow);  <span class="comment">// important</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeSpace</span>(s);</span><br><span class="line">        <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// for (int i=0; i&lt;s.size(); ++i) &#123;</span></span><br><span class="line">            <span class="comment">// if (s[i] == &#x27; &#x27;) &#123;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() || s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s, start, i<span class="number">-1</span>);  <span class="comment">// 翻转当前单词</span></span><br><span class="line">                <span class="comment">// start = i;</span></span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2、KMP算法"><a href="#2、KMP算法" class="headerlink" title="2、KMP算法"></a>2、KMP算法</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242023050.png" alt="image-20240424202306816"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> *next, <span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// i -&gt; 待匹配的后缀的末尾</span></span><br><span class="line">   <span class="comment">// j -&gt; 待匹配的前缀的末尾</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1. 初始化</span></span><br><span class="line">   <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">   next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">       <span class="comment">// 2. 处理前后缀不相同的情况</span></span><br><span class="line">       <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">           j = next[j<span class="number">-1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 3. 处理前后缀不相同的情况</span></span><br><span class="line">       <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">           j++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4. 更新next数组</span></span><br><span class="line">       next[i] = j;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 实现 strStr()</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li>求解字符串<code>s</code>的<code>next</code>数组；</li>
<li>定义<code>i</code>和<code>j</code>分别用来遍历<code>haystack</code>和<code>needle</code>，根据<code>next</code>数组调整对比的位置；</li>
<li>当<code>j</code>等于<code>needle</code>字符串的长度时，说明此时在<code>haystack</code>中找到了对应的匹配子串，因此返回该子串的开始下标。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line">        <span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;haystack.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> (i-needle.<span class="built_in">size</span>()+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a>459. 重复的子字符串</h3><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242023207.png" alt="image-20240424202348060"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> *next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; s[i]!=s[j]) &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(s.size())</span></span>;</span><br><span class="line">        <span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], s);</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(next[len<span class="number">-1</span>]!=<span class="number">0</span> &amp;&amp; (len%(len-next[len<span class="number">-1</span>])==<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="五、栈和队列"><a href="#五、栈和队列" class="headerlink" title="五、栈和队列"></a>五、栈和队列</h1><h2 id="1、栈和队列的理论基础"><a href="#1、栈和队列的理论基础" class="headerlink" title="1、栈和队列的理论基础"></a>1、栈和队列的理论基础</h2><ol>
<li><p>C++中stack 是容器么？</p>
<p>STL中stack往往不被归类为容器，而被归类为容器适配器（container adapter）。因为<strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p>
</li>
<li><p>我们使用的stack是属于哪个版本的STL？</p>
<p>SGI STL。</p>
</li>
<li><p>我们使用的STL中stack是如何实现的？</p>
<p>栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。<strong>常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。</strong></p>
<p>此外，<strong>SGI STL中队列一样是以deque为缺省情况下的底部结构。</strong></p>
<p>可以指定vector为栈的底层实现，初始化语句如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br></pre></td></tr></table></figure>

<p>也可以指定list 为起底层实现，初始化queue的语句如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242029774.png" alt="栈与队列理论3" style="zoom:50%;" />
</li>
<li><p>stack 提供迭代器来遍历stack空间么？</p>
<p>不提供。</p>
</li>
</ol>
<blockquote>
<p>三个最为普遍的STL版本：</p>
<ol>
<li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li>
<li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li>
<li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li>
</ol>
</blockquote>
<h2 id="2、栈的基本操作"><a href="#2、栈的基本操作" class="headerlink" title="2、栈的基本操作"></a>2、栈的基本操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">empty</span>();		<span class="comment">// 栈为空时返回1，非空返回0</span></span><br><span class="line">st.<span class="built_in">size</span>();		<span class="comment">// 返回栈中元素数量，size_type size() const;</span></span><br><span class="line">st.<span class="built_in">top</span>();		<span class="comment">// 返回栈顶元素，value_type&amp; top();</span></span><br><span class="line">st.<span class="built_in">push</span>(value);	<span class="comment">// 在栈顶插入一个元素，void push( const value_tyoe&amp; val );</span></span><br><span class="line">st.<span class="built_in">emplace</span>(value);	<span class="comment">// 在栈顶增加一个元素，void emplace( args&amp;&amp; args );</span></span><br><span class="line">st.<span class="built_in">pop</span>();			<span class="comment">// 栈顶元素出栈，即删除栈顶元素，void pop(); </span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st2;</span><br><span class="line">st1.<span class="built_in">swap</span>( st2 );	<span class="comment">// 交换两个栈中的内容，void swap( stack&amp; x );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与vector一样，重载了运算符：== != &lt; &lt;= &gt; &gt;=</span></span><br></pre></td></tr></table></figure>

<h2 id="3、队列的基本操作"><a href="#3、队列的基本操作" class="headerlink" title="3、队列的基本操作"></a>3、队列的基本操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">queue&lt;<span class="type">double</span>&gt; d;</span><br><span class="line">queue&lt;node&gt; n;  <span class="comment">// node是一个结构体</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">size</span>();	<span class="comment">// 返回q里元素个数</span></span><br><span class="line">q.<span class="built_in">empty</span>();	<span class="comment">// 返回q是否为空，空则返回1，否则返回0</span></span><br><span class="line">q.<span class="built_in">push</span>(k);	<span class="comment">// 在q的末尾插入k</span></span><br><span class="line">q.<span class="built_in">pop</span>();	<span class="comment">// 删掉q的第一个元素</span></span><br><span class="line">q.<span class="built_in">front</span>();	<span class="comment">// 返回q的第一个元素</span></span><br><span class="line">q.<span class="built_in">back</span>();	<span class="comment">// 返回q的末尾元素</span></span><br></pre></td></tr></table></figure>

<h2 id="4、对称匹配问题"><a href="#4、对称匹配问题" class="headerlink" title="4、对称匹配问题"></a>4、对称匹配问题</h2><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><p><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404252121420.png" alt="image-20240425212136199"></p>
<p>这里有两个要注意的地方：</p>
<ol>
<li><p>在遍历到左括号时，可以直接向栈中放入对应的右括号，这样遍历到右括号时可以直接比较是否相等；</p>
</li>
<li><p>注意在遍历到右括号时需要先判断此时栈是否为空。</p>
<p>对于<code>s = &quot;)&#123;&quot;</code>的情况，由于遍历到左括号时才会入栈，遍历到右括号时只执行比较操作，因此此时<code>st</code>为空，若直接执行<code>st.top()</code>会造成错误！</p>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">&#x27;)&#x27;</span> || i == <span class="string">&#x27;]&#x27;</span> || i == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == i) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h3><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404252121802.png" alt="image-20240425212128346"></p>
<p>注意输出的时候要进行一个reverse操作，因为栈是先进先出，和需要的结果次序是相反的。</p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == i) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res += st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h3><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261554153.png" alt="image-20240426155453665"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isDigit</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> token : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isDigit</span>(token)) &#123;</span><br><span class="line">                    <span class="comment">// 操作符</span></span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> tmp1 = res.<span class="built_in">top</span>();</span><br><span class="line">                    res.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> tmp2 = res.<span class="built_in">top</span>();</span><br><span class="line">                    res.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 + tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 - tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 * tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 / tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res.<span class="built_in">push</span>(tmp);   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push</span>(<span class="built_in">stoi</span>(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、队列解决相关问题"><a href="#5、队列解决相关问题" class="headerlink" title="5、队列解决相关问题"></a>5、队列解决相关问题</h2><blockquote>
<p>可用于以下题目：</p>
<ol>
<li>单调队列解决“<strong>区间内的最大值</strong>”问题；</li>
<li>优先级队列解决“<strong>统计元素出现频率</strong>”问题</li>
</ol>
</blockquote>
<h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261557720.png" alt="image-20240426155748508"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            <span class="comment">// 如果val == que.front()</span></span><br><span class="line">            <span class="comment">// 说明队列要pop()的元素为此时滑动窗口的最大值，需要执行实际的pop()操作</span></span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          que.<span class="built_in">push_back</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getMaxValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">      MyQueue que;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">      <span class="comment">// 先将前k个元素放进单调队列</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; ++i) &#123;</span><br><span class="line">        que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// res先记录这前k个元素的最大值</span></span><br><span class="line">      res.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=k; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        que.<span class="built_in">pop</span>(nums[i-k]);</span><br><span class="line">        que.<span class="built_in">push</span>((nums[i]));</span><br><span class="line">        res.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h3><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347.前 K 个高频元素</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261557691.png" alt="image-20240426155759481"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// step1</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            map[num]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step2</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pri_que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it=map.<span class="built_in">begin</span>(); it!=map.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            pri_que.<span class="built_in">push</span>(*it);</span><br><span class="line">            <span class="comment">// step3</span></span><br><span class="line">            <span class="keyword">if</span> (pri_que.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                pri_que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step4</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=k<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">            res[i] = pri_que.<span class="built_in">top</span>().first;</span><br><span class="line">            pri_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="六、二叉树"><a href="#六、二叉树" class="headerlink" title="六、二叉树"></a>六、二叉树</h1><h2 id="1、理论基础-1"><a href="#1、理论基础-1" class="headerlink" title="1、理论基础"></a>1、理论基础</h2><h3 id="（1）分类"><a href="#（1）分类" class="headerlink" title="（1）分类"></a>（1）分类</h3><blockquote>
<p>度：二叉树中某个结点的子结点或直接后继结点的个数。叶子节点的度为0。</p>
</blockquote>
<ul>
<li><p>满二叉树：一课二叉树上只有度为0的结点和度为2的结点，且度为0的结点在同一层上，则为满二叉树。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035207.png" alt="img"></p>
</li>
<li><p>完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035385.png" alt="img"></p>
</li>
<li><p>二叉搜索树：有序树。1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；3）左、右子树也分别为二叉排序树。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035643.png" alt="img"></p>
</li>
<li><p>平衡二叉搜索树：又称AVL（Adelson-Velsky and Landis）树。它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035200.png" alt="img"></p>
</li>
</ul>
<h3 id="（2）存储方式"><a href="#（2）存储方式" class="headerlink" title="（2）存储方式"></a>（2）存储方式</h3><ul>
<li><p>链式存储：指针。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271036601.png" alt="img"></p>
</li>
<li><p>顺序存储：数组。此时若父结点下标为<code>i</code>，则左孩子下标为<code>i*2+1</code>，右孩子下标为<code>i*2+2</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271036512.png" alt="img"></p>
</li>
</ul>
<h3 id="（3）遍历方式"><a href="#（3）遍历方式" class="headerlink" title="（3）遍历方式"></a>（3）遍历方式</h3><ul>
<li><p>深度优先遍历</p>
<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271039957.png" alt="img"></p>
</li>
<li><p>广度优先遍历</p>
<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ul>
<p>栈其实就是递归的一种实现结构，<strong>深度优先遍历可以借助栈来使用递归的方式实现。而广度优先遍历一般使用队列来实现</strong>。</p>
<h3 id="（4）定义方式"><a href="#（4）定义方式" class="headerlink" title="（4）定义方式"></a>（4）定义方式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	TreeNode *left;</span><br><span class="line">	TreeNode *right;</span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、深度优先遍历"><a href="#2、深度优先遍历" class="headerlink" title="2、深度优先遍历"></a>2、深度优先遍历</h2><p>递归三要素：</p>
<ul>
<li>确定递归函数的参数和返回值：如果在递归过程中需要处理某些参数，就在递归函数中加上这个参数；</li>
<li>确定终止条件</li>
<li>确定单层递归的逻辑</li>
</ul>
<h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h3><ul>
<li><p>AC代码（递归遍历）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, v);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">traversal</span>(root, v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代遍历的思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292106760.png" alt="image-20240429210650617"></p>
</li>
<li><p>AC代码（迭代遍历）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> v; &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *node = st.<span class="built_in">top</span>();                  <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            v.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) &#123; st.<span class="built_in">push</span>(node-&gt;right); &#125;  <span class="comment">// 右（入栈时先入右，出栈时才能先出左）</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) &#123; st.<span class="built_in">push</span>(node-&gt;left); &#125;    <span class="comment">// 左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h3><ul>
<li><p>AC代码（递归遍历）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, v);</span><br><span class="line">        v.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">traversal</span>(root, v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AC代码（迭代遍历）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历到最左侧的左孩子</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;        <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将左孩子加入完毕，开始从栈中弹出元素</span></span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                v.<span class="built_in">push_back</span>(cur-&gt;val);  <span class="comment">// 中</span></span><br><span class="line">                cur = cur-&gt;right;       <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h3><ul>
<li><p>AC代码（递归遍历）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;int&gt; v;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        while (cur != nullptr || !st.empty()) &#123;</span><br><span class="line">            if (cur != nullptr) &#123;</span><br><span class="line">                // 遍历到最左侧的左孩子</span><br><span class="line">                st.push(cur);</span><br><span class="line">                cur = cur-&gt;left;        // 左</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 将左孩子加入完毕，开始从栈中弹出元素</span><br><span class="line">                cur = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                v.push_back(cur-&gt;val);  // 中</span><br><span class="line">                cur = cur-&gt;right;       // 右</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AC代码（迭代遍历）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> v; &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            v.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123; st.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123; st.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、广度优先遍历"><a href="#3、广度优先遍历" class="headerlink" title="3、广度优先遍历"></a>3、广度优先遍历</h2><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292104737.png" alt="image-20240429210415502"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                v.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h3><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292105474.png" alt="image-20240429210504161"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                v.<span class="built_in">push_back</span>(node-&gt;val);  <span class="comment">// 方法1</span></span><br><span class="line">                <span class="comment">// if (i == (size - 1)) result.push_back(node-&gt;val);  // 方法2</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(*(v.<span class="built_in">end</span>()<span class="number">-1</span>));  <span class="comment">// 方法1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429. N叉树的层序遍历"></a>429. N叉树的层序遍历</h3><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N叉树的层序遍历</a></p>
<ul>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Node* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;children.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 将节点孩子加入队列</span></span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;children[i]) que.<span class="built_in">push</span>(node-&gt;children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h3><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292105156.png" alt="image-20240429210553988"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node *node;</span><br><span class="line">            Node *nodePre;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    nodePre = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    node = nodePre;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    nodePre-&gt;next = node;  <span class="comment">// 本层前一个节点(nodePre)的next指向本节点(node)</span></span><br><span class="line">                    nodePre = nodePre-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nodePre-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 本层最后一个节点指向NULL</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、二叉树的属性"><a href="#4、二叉树的属性" class="headerlink" title="4、二叉树的属性"></a>4、二叉树的属性</h2><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h3><p><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404301959840.png" alt="image-20240430195926626"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode *left, TreeNode *right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);</span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> outside &amp;&amp; inside;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h3><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p>
<ul>
<li><p>解题思路</p>
<blockquote>
<ul>
<li>二叉树节点的<strong>深度</strong>：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）– <strong>前序遍历</strong></li>
<li>二叉树节点的<strong>高度</strong>：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）– <strong>后序遍历</strong></li>
</ul>
</blockquote>
<p>本题牢记一点，<strong>根节点的高度就是二叉树的最大深度</strong>。因此采用后序遍历。</p>
</li>
<li><p>AC代码（解法1：层序遍历）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="type">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
<li><p>AC代码（解法2：递归法）</p>
<p>利用<strong>根节点的高度就是二叉树的最大深度</strong>这一理论。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getdepth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftdepth = <span class="built_in">getdepth</span>(node-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightdepth = <span class="built_in">getdepth</span>(node-&gt;right);     <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth); <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getdepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="559-n叉树的最大深度"><a href="#559-n叉树的最大深度" class="headerlink" title="559. n叉树的最大深度"></a>559. n叉树的最大深度</h3><p><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. n叉树的最大深度</a></p>
<ul>
<li><p>AC代码（迭代法）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;node-&gt;children.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[i]) &#123;</span><br><span class="line">                depth = <span class="built_in">max</span>(depth, <span class="built_in">getDepth</span>(node-&gt;children[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getDepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h3><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405071213847.png" alt="image-20240507121354366"></p>
</li>
<li><p>AC代码（迭代法）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">getDepth</span>(node-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">getDepth</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;left &amp;&amp; node-&gt;right) &#123; <span class="keyword">return</span> <span class="number">1</span> + rightDepth; &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left &amp;&amp; !node-&gt;right) &#123; <span class="keyword">return</span> <span class="number">1</span> + leftDepth; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> depth = <span class="built_in">getDepth</span>(root);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>精简版</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a>222. 完全二叉树的节点个数</h3><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><strong>完全二叉树</strong>只有两种情况：</li>
</ol>
<ul>
<li>满二叉树；<strong>（此时假设树深度为N，节点数为2^N-1）</strong></li>
<li>最后一层叶子节点没有满。<strong>（分别递归左右孩子，地轨道某一深度一定会有左孩子或右孩子为满二叉树）</strong></li>
</ul>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124092543662.png" alt="222.完全二叉树的节点个数" style="zoom:50%;" />

<ol start="2">
<li><p>如何判断<strong>完全二叉树是否是满二叉树</strong>？</p>
<p>在一棵完全二叉树中，如果递归向左遍历的深度等于递归向右遍历的深度，那就说明是满二叉树。</p>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163554.png" alt="img" style="zoom:50%;" />

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163709.png" alt="img" style="zoom:50%;" /></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="comment">// 开始根据左深度和右深度是否相同来判断该子树是不是满二叉树</span></span><br><span class="line">        TreeNode *left = root-&gt;left;</span><br><span class="line">        TreeNode *right = root-&gt;right;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="number">0</span>, rightDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left) &#123;</span><br><span class="line">            left = left-&gt;left;  <span class="comment">// 向左遍历</span></span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right) &#123;</span><br><span class="line">            right = right-&gt;right;  <span class="comment">// 向右遍历</span></span><br><span class="line">            rightDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h3><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></p>
<ul>
<li><p>解题思路</p>
<p>首先，<strong>求高度还是用到了后序遍历。</strong></p>
<p>递归三部曲分析：</p>
<ol>
<li><p>明确递归参数和返回值</p>
<ul>
<li>参数：当前传入节点</li>
<li>返回值：以当前传入节点为根节点的树的高度。但如果已经不是二叉平衡树了，则直接返回-1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode *node)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>明确终止条件</p>
<p>遇到了空节点即返回</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>明确单层递归的逻辑</p>
<p>分别求出其左右子树的高度：</p>
<ul>
<li>若差值小于等于1，则返回当前二叉树的高度</li>
<li>否则返回-1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line"><span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"><span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line"><span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;   <span class="comment">// 中</span></span><br><span class="line">    height =  <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    height = <span class="number">1</span> + <span class="built_in">max</span>(leftHeight, rightHeight);  <span class="comment">// 以当前节点为根节点的树的最大高度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> height;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">        <span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>+<span class="built_in">max</span>(leftHeight, rightHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHeight</span>(root) != <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h3><p><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><p>递归函数参数及返回值</p>
<ul>
<li>传入根节点、记录每一条路径的path、存放结果集的result</li>
<li>无需返回值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;string&gt; &amp;result)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归终止条件</p>
<p>本题不能写<code>if(cur == nullptr)</code>，因为这样写就直接跳过了叶子节点，而本题需要找到叶子节点所在处并进行相应的处理逻辑，因此终止条件如下，且此处无需判断cur是否为空，将在单层递归逻辑中进行判断。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 终止处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于终止处理逻辑，这里使用vector 结构path来记录路径，所以要把vector 结构的path转为string格式，再把这个string 放进 result里。<strong>那么为什么使用了vector 结构来记录路径呢？</strong>  因为在下面处理单层递归逻辑的时候，要做回溯，使用vector方便来做回溯。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123; <span class="comment">// 遇到叶子节点</span></span><br><span class="line">    string sPath;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123; <span class="comment">// 将path里记录的路径转为string格式</span></span><br><span class="line">        sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">        sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>() - <span class="number">1</span>]); <span class="comment">// 记录最后一个节点（叶子节点）</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(sPath); <span class="comment">// 收集一个路径</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单层递归逻辑</p>
<p>因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中，<code>path.push_back(cur-&gt;val);</code>。</p>
<ul>
<li><p>递归与回溯</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归和回溯一一对应，写到一个大括号里</span></span><br><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>AC代码（迭代法）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;string&gt; &amp;result)</span> </span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(cur-&gt;val);  <span class="comment">// 中（写在最前面是为了把这条路径的所有节点都加进path中）</span></span><br><span class="line">        <span class="comment">// 现在开始处理叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            string sPath;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;path.<span class="built_in">size</span>()<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">                sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">                sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(sPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;left, path, result);  <span class="comment">// 左</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;right, path, result); <span class="comment">// 右</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">        <span class="built_in">traversal</span>(root, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a>404. 左叶子之和</h3><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081211988.png" alt="image-20240508121115767"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> lval = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123;</span><br><span class="line">            lval = root-&gt;left-&gt;val;  <span class="comment">// 此处的root是左叶子的父结点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rval = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> val = lval + rval;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a>513. 找树左下角的值</h3><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></p>
<ul>
<li><p>解题思路</p>
<p>本题采用层序遍历的方式即可，只需要求最后一层的第一个元素。</p>
</li>
<li><p>AC代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                v.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = res[res.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h3><p><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></p>
<ul>
<li><p>AC代码（版本1，参考257的解法）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;path, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历到叶子节点了，开始计算和</span></span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> i : path) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == targetSum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> fleft = <span class="literal">false</span>, fright = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">            fleft = <span class="built_in">traversal</span>(cur-&gt;left, path, targetSum);  <span class="comment">// 左</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">            fright = <span class="built_in">traversal</span>(cur-&gt;right, path, targetSum); <span class="comment">// 右</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fleft || fright;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">traversal</span>(root, path, targetSum);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AC代码2（在遍历节点时就跟着计算和）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遇到叶子节点，并且计数为0</span></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遇到叶子节点直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            count -= cur-&gt;left-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;left-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            count -= cur-&gt;right-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;right-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、二叉树的修改与构造"><a href="#5、二叉树的修改与构造" class="headerlink" title="5、二叉树的修改与构造"></a>5、二叉树的修改与构造</h2><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h3><p><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></p>
<ul>
<li><p>解题思路</p>
<p>这道题只需要在遍历的过程中将每个节点的左右孩子翻转一遍，最终就可以达到整体翻转的效果。<strong>注意本题不能使用中序遍历，因为会把某些节点的左右孩子翻转两次。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302000083.png" alt="image-20240430200020967" style="zoom:67%;" />
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversel</span><span class="params">(TreeNode *cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left || cur-&gt;right) &#123;</span><br><span class="line">            TreeNode *tmp;</span><br><span class="line">            tmp = cur-&gt;left;</span><br><span class="line">            cur-&gt;left = cur-&gt;right;</span><br><span class="line">            cur-&gt;right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traversel</span>(cur-&gt;left);</span><br><span class="line">        <span class="built_in">traversel</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversel</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a>106. 从中序与后序遍历序列构造二叉树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081210471.png" alt="image-20240508121021941"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;inorder, vector&lt;<span class="type">int</span>&gt; &amp;postorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s1. 如果数组大小为零的话，说明是空节点</span></span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s2. 后序数组的最后一个元素就是当前的root</span></span><br><span class="line">        <span class="type">int</span> rootValue = postorder[postorder.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s3. 找到后序数组最后一个元素在中序数组的位置，作为切割点</span></span><br><span class="line">        <span class="type">int</span> cut1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootValue) &#123;</span><br><span class="line">                cut1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s4. 切割中序数组，切成中序左数组和中序右数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_inorder</span><span class="params">(inorder.begin(), inorder.begin()+cut1)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_inorder</span><span class="params">(inorder.begin()+cut1+<span class="number">1</span>, inorder.end())</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// s5. 切割后序数组，切成后序左数组和后序右数组</span></span><br><span class="line">        postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>() - <span class="number">1</span>);  <span class="comment">// [important]postorder 舍弃末尾元素</span></span><br><span class="line">        <span class="type">int</span> cut2 = left_inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_postorder</span><span class="params">(postorder.begin(), postorder.begin()+cut2)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_postorder</span><span class="params">(postorder.begin()+cut2, postorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s6. 递归处理左区间和右区间</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(left_inorder, left_postorder);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(right_inorder, right_postorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>)  &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p>
<ul>
<li><p>解题思路</p>
<p>步骤如下：</p>
<ol>
<li>若数组为空，则说明是空树；</li>
<li>若数组非空，则取前序数组的第一个元素作为root；</li>
<li>找到前序数组的第一个元素在中序数组的位置，作为切割点；</li>
<li>切割中序数组，切成中序左数组和中序右数组；</li>
<li>切割前序数组，切成前序左树组和前序右数组；</li>
<li>递归处理左区间和右区间。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s1. </span></span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s2. </span></span><br><span class="line">        <span class="type">int</span> rootValue = preorder[<span class="number">0</span>];</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">size</span>() == <span class="number">1</span>) &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s3. </span></span><br><span class="line">        <span class="type">int</span> cut1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootValue) &#123;</span><br><span class="line">                cut1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s4. </span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_inorder</span><span class="params">(inorder.begin(), inorder.begin()+cut1)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_inorder</span><span class="params">(inorder.begin()+cut1+<span class="number">1</span>, inorder.end())</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// s5. </span></span><br><span class="line">        preorder.<span class="built_in">erase</span>(preorder.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="type">int</span> cut2 = left_inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_preorder</span><span class="params">(preorder.begin(), preorder.begin()+cut2)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_preorder</span><span class="params">(preorder.begin()+cut2, preorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s6. </span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(left_preorder, left_inorder);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(right_preorder, right_inorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || preorder.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(preorder, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6、求二叉搜索树的属性"><a href="#6、求二叉搜索树的属性" class="headerlink" title="6、求二叉搜索树的属性"></a>6、求二叉搜索树的属性</h2><h2 id="7、二叉树公共祖先问题"><a href="#7、二叉树公共祖先问题" class="headerlink" title="7、二叉树公共祖先问题"></a>7、二叉树公共祖先问题</h2><h2 id="8、二叉搜索数的修改与构造"><a href="#8、二叉搜索数的修改与构造" class="headerlink" title="8、二叉搜索数的修改与构造"></a>8、二叉搜索数的修改与构造</h2><h1 id="七、回溯"><a href="#七、回溯" class="headerlink" title="七、回溯"></a>七、回溯</h1><h2 id="1、回溯法解决的问题"><a href="#1、回溯法解决的问题" class="headerlink" title="1、回溯法解决的问题"></a>1、回溯法解决的问题</h2><p>回溯法一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<h2 id="2、回溯算法模板框架如下："><a href="#2、回溯算法模板框架如下：" class="headerlink" title="2、回溯算法模板框架如下："></a>2、回溯算法模板框架如下：</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用树形结构来模拟回溯的过程：</p>
<ol>
<li>对于组合问题来说，目标是找树的叶子节点。横向代表不同的组合方式，纵向的每一根树枝代表了一种具体的组合；</li>
<li>对于切割问题来说，目标是找树的叶子节点。横向代表不同的切割方式，纵向的每一根树枝代表了一种具体的切割；</li>
<li>对于组合问题来说，目标是找树的所有节点。</li>
</ol>
]]></content>
      <categories>
        <category>Computer</category>
        <category>DataStruct</category>
      </categories>
  </entry>
  <entry>
    <title>cmu15-445 Project 1 (Spring 2023)</title>
    <url>/2024/03/02/Project/cmu15-445/cmu15-445%20Project%201%20(Spring%202023)/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="Task-1-LRU-K-Replacement-Policy"><a href="#Task-1-LRU-K-Replacement-Policy" class="headerlink" title="Task #1 - LRU-K Replacement Policy"></a>Task #1 - LRU-K Replacement Policy</h1><p>跟踪缓冲池中页面的使用情况，用于记录、更新以及删除页<code>(frame)</code>。</p>
<p><code>src/include/buffer/lru_k_replacer.h</code>  &#x3D;&#x3D;&gt; 实现<code>LRUKReplacer</code>的新类，且独立</p>
<p><code>src/buffer/lru_k_replacer.cpp</code> &#x3D;&#x3D;&gt; 对应实现，实现<code>LRU-K</code>替换策略。</p>
<p><code>LRU-K</code>将替换帧中<code>backward k-distance</code>最大的帧剔除。<code>backward k-distance</code>计算的是当前时间戳与前<code>k</code>次访问的时间戳之差。</p>
<p>历史链表：记录出现的历史时间戳，新的时间戳追加到链表尾部；</p>
<p><code>k-distance</code>：若出现此时小于<code>k</code>，则为无穷大；若大于等于<code>k</code>，则对应为历史链表头部；</p>
<p>驱逐方法：1）优先驱逐<code>k-distance</code>为无穷大的页，且按照<code>FIFO</code>的策略进行驱逐；2）若无无穷大的页，则驱逐<code>k-distance</code>最小的页（说明其倒数第<code>k</code>次出现最遥远，时间局部性更弱）。</p>
<h2 id="Task1踩坑处"><a href="#Task1踩坑处" class="headerlink" title="Task1踩坑处"></a>Task1踩坑处</h2><h3 id="（1）-15634-ERROR-AddressSanitizer-attempting-free-on-address-which-was-not-malloc-ed-0x7ffd62284260-in-thread-T0"><a href="#（1）-15634-ERROR-AddressSanitizer-attempting-free-on-address-which-was-not-malloc-ed-0x7ffd62284260-in-thread-T0" class="headerlink" title="（1）&#x3D;&#x3D;15634&#x3D;&#x3D;ERROR: AddressSanitizer: attempting free on address which was not malloc()-ed: 0x7ffd62284260 in thread T0"></a>（1）&#x3D;&#x3D;15634&#x3D;&#x3D;ERROR: AddressSanitizer: attempting free on address which was not malloc()-ed: 0x7ffd62284260 in thread T0</h3><p>表明在试图释放一个未经 malloc 分配的地址。</p>
<p>错误代码处为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// history 已满，更新 history</span></span><br><span class="line">node.history_.<span class="built_in">pop_front</span>();</span><br><span class="line">node.history_.<span class="built_in">push_back</span>(current_timestamp_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 more</span></span><br><span class="line">node_more_k_.<span class="built_in">erase</span>(node_more_k_.<span class="built_in">find</span>(&amp;node)); </span><br><span class="line">node_more_k_.<span class="built_in">insert</span>(&amp;node);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">node_more_k_.<span class="built_in">erase</span>(node_more_k_.<span class="built_in">find</span>(&amp;node));  <span class="comment">// here</span></span><br></pre></td></tr></table></figure>

<p>在 C++ 的 <code>std::set</code> 中，<code>erase</code> 函数会删除指定的元素，但不会直接释放其内存。相反，它会调用元素类型的析构函数，然后将元素从 <code>std::set</code> 中移除。然而这里尝试擦除的是一个指向局部对象 <code>node</code> 的指针，而不是指向 <code>std::set</code> 中元素的指针。一旦 <code>node</code> 超出作用域，其地址将变为无效地址。因此，这样的写法可能导致悬垂指针问题，当再次访问 <code>node_more_k_</code> 时，可能会引发未定义行为或崩溃。</p>
<p>修正后为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// history 已满，更新 history</span></span><br><span class="line">LRUKNode&amp; tmp = node;</span><br><span class="line">node_more_k_.<span class="built_in">erase</span>(&amp;node);</span><br><span class="line"><span class="comment">// 更新 more</span></span><br><span class="line">tmp.history_.<span class="built_in">pop_front</span>();</span><br><span class="line">tmp.history_.<span class="built_in">push_back</span>(current_timestamp_);</span><br><span class="line">node_more_k_.<span class="built_in">insert</span>(&amp;tmp);</span><br></pre></td></tr></table></figure>

<h3 id="（2）-17474-ERROR-LeakSanitizer-detected-memory-leaks"><a href="#（2）-17474-ERROR-LeakSanitizer-detected-memory-leaks" class="headerlink" title="（2）&#x3D;&#x3D;17474&#x3D;&#x3D;ERROR: LeakSanitizer: detected memory leaks"></a>（2）&#x3D;&#x3D;17474&#x3D;&#x3D;ERROR: LeakSanitizer: detected memory leaks</h3><p>表明存在内存泄漏问题。</p>
<p>错误代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果在node_store_中没有找到对应的元素，创建一个新的LRUKNode</span></span><br><span class="line"><span class="keyword">auto</span> *new_node = <span class="keyword">new</span> <span class="built_in">LRUKNode</span>();</span><br><span class="line">new_node-&gt;fid_ = frame_id;</span><br><span class="line">new_node-&gt;history_.<span class="built_in">push_back</span>(current_timestamp_);</span><br><span class="line">new_node-&gt;k_ = <span class="keyword">this</span>-&gt;k_;</span><br><span class="line"></span><br><span class="line">node_store_[frame_id] = *new_node;</span><br><span class="line">node_less_k_.<span class="built_in">insert</span>(node_less_k_.<span class="built_in">end</span>(), new_node);</span><br><span class="line">node_store_[frame_id].pos_ = std::<span class="built_in">prev</span>(node_less_k_.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>上述代码中，由于<code>node_store_</code> 的声明是 <code>std::unordered_map&lt;frame_id_t, LRUKNode&gt;</code>，这表示它存储的是 <code>LRUKNode</code> 对象的副本而不是指针。因此在使用<code>new</code>运算符分配内存后，将对象的副本赋值给了<code>node_store_[frame_id]</code>，而不是直接将指针存储在<code>node_store_</code>中。</p>
<p>改正的方式是直接存储指向动态分配的对象的指针，而不是对象的副本。同时，应该考虑采用智能指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::unordered_map&lt;<span class="type">frame_id_t</span>, std::shared_ptr&lt;LRUKNode&gt;&gt; node_store_;</span><br><span class="line">std::list&lt;std::shared_ptr&lt;LRUKNode&gt;&gt; node_less_k_;  <span class="comment">// 访问 k 次以下的页面，FIFO 队列</span></span><br><span class="line">std::set&lt;std::shared_ptr&lt;LRUKNode&gt;, MyCompare&gt; node_more_k_;  <span class="comment">// 访问 k 次以上的页面，LRU 队列</span></span><br></pre></td></tr></table></figure>

<p>此时上述代码可修改为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> new_node = std::<span class="built_in">make_shared</span>&lt;LRUKNode&gt;();</span><br><span class="line">new_node-&gt;fid_ = frame_id;</span><br><span class="line">new_node-&gt;history_.<span class="built_in">push_back</span>(current_timestamp_);</span><br><span class="line">new_node-&gt;k_ = <span class="keyword">this</span>-&gt;k_;</span><br><span class="line"></span><br><span class="line">node_store_[frame_id] = new_node;</span><br><span class="line">node_less_k_.<span class="built_in">insert</span>(node_less_k_.<span class="built_in">end</span>(), new_node);</span><br><span class="line">node_store_[frame_id]-&gt;pos_ = std::<span class="built_in">prev</span>(node_less_k_.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h1 id="Task-2-Buffer-Pool-Manager"><a href="#Task-2-Buffer-Pool-Manager" class="headerlink" title="Task #2 - Buffer Pool Manager"></a>Task #2 - Buffer Pool Manager</h1><blockquote>
<p><code>BufferPoolManager</code>负责从<code>DiskManager</code>抓取数据库页面并将其存储到内存中。<code>BufferPoolManager</code>还可以在收到明确指示或需要删除页面以便为新页面腾出空间时，将脏页面写入磁盘。</p>
<p>实际读取和写入磁盘数据的代码已经写好，不需要自己实现（<code>DiskManager</code>）。</p>
<p>系统中的所有内存页面都由<code>Page</code>对象表示。缓冲池管理器无需了解这些页面的内容。但作为系统开发人员，您必须明白，<code>Page</code>对象只是缓冲池中内存的容器，因此并不特定于某个页面。也就是说，每个页面对象都包含一个内存块，<code>DiskManager</code>将把它用作从磁盘读取物理页面内容的复制位置。<strong>缓冲池管理器（<code>BufferPoolManager</code>）会重复使用同一个页面对象来存储数据，因为数据会在磁盘上来回移动。这意味着，在系统的整个生命周期中，同一个页面对象可能包含不同的物理页面。</strong>页面对象的标识符（<code>page_id</code>）可追踪其包含的物理页面；如果页面对象不包含物理页面，则其<code>page_id</code>必须设置为<code>INVALID_PAGE_ID</code>。每个页面对象还维护一个计数器，用于记录 “钉住 “该页面的线程数。缓冲池管理器不允许释放被钉住的页面。每个页面对象也会记录它是否变脏。你的工作就是记录页面在解除固定前是否被修改过。<code>BufferPoolManager</code>必须先将脏页面的内容写回磁盘，然后才能重新使用该对象。</p>
<p>您的<code>BufferPoolManager</code>实现将使用您在本作业前几步中创建的<code>LRUKReplacer</code>类。<code>LRUKReplacer</code>将跟踪页面对象被访问的时间，以便在必须释放帧以腾出空间从磁盘复制新的物理页面时，决定驱逐哪个页面对象。在<code>BufferPoolManager</code>中将<code>page_id</code>映射到<code>frame_id</code>时，请再次注意 STL 容器不是线程安全的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Page *pages_;  <span class="comment">// 数组，索引为frame_id</span></span><br><span class="line">std::unordered_map&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; page_table_;  <span class="comment">// 即内存，存放page_id与frame_id的映射</span></span><br><span class="line">std::unique_ptr&lt;LRUKReplacer&gt; replacer_;</span><br><span class="line">std::list&lt;<span class="type">frame_id_t</span>&gt; free_list_;  <span class="comment">// 记录哪些位置为空</span></span><br><span class="line">std::mutex latch_;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>NewPage</code>：<ul>
<li>先在内存里(<code>free_list_</code>)找到一个空<code>frame</code>;</li>
<li>若没有，则替换出一个可驱逐的<code>replacement frame</code>，并更新访问历史和不可驱逐状态，注意若包含<code>dirty page</code>，则先将脏数据写回<code>disk</code>；</li>
<li>创建新<code>page</code>；</li>
<li>写回内存（<code>page_table_</code>）。</li>
</ul>
</li>
<li><code>FetchPage</code>：<ul>
<li>找<code>page_id</code>对应的页：<ul>
<li>先在<code>page_table_</code>中查找是否有<code>page_id</code>对应的页：<ul>
<li>若找到，<code>pin_count_</code>自增；</li>
<li>更新<code>frame</code>的访问历史，设置不可驱逐状态；</li>
</ul>
</li>
<li>若内存没有，则在<code>disk</code>中找，并在内存中腾出一个空位（<code>replacer_</code>）：<ul>
<li>若<code>replacement frame</code>包含<code>dirty page</code>，则先将脏数据写回<code>disk</code>；</li>
<li>更新<code>frame</code>的访问历史，设置不可驱逐状态；</li>
<li>在<code>disk</code>中读取该<code>page</code>的内容并写入；</li>
<li>写回内存（<code>page_table_</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>UnpinPage</code>：<ul>
<li>若<code>page_id</code>不存在，直接返回；</li>
<li>若存在，但<code>unpin</code>后<code>pin_count_</code>为<code>0</code>，也直接返回，并设置<code>frame</code>可驱逐；</li>
<li>除此之外，注意此处应该为：<code>pages_[frame_id].is_dirty_ |= is_dirty;</code>。</li>
</ul>
</li>
</ul>
<h2 id="Task2踩坑处"><a href="#Task2踩坑处" class="headerlink" title="Task2踩坑处"></a>Task2踩坑处</h2><h3 id="（1）unknown-file-Failure-C-exception-with-description-“The-id-not-found-in-cache”-thrown-in-the-test-body"><a href="#（1）unknown-file-Failure-C-exception-with-description-“The-id-not-found-in-cache”-thrown-in-the-test-body" class="headerlink" title="（1）unknown file: Failure C++ exception with description “The id not found in cache” thrown in the test body."></a>（1）unknown file: Failure C++ exception with description “The id not found in cache” thrown in the test body.</h3><p>一个很粗心的错误，那就是<code>RecordAccess</code>和<code>SetEvictable</code>的顺序搞反了。</p>
<p>正确的顺序应该是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">replacer_-&gt;<span class="built_in">RecordAccess</span>(frame_id);</span><br><span class="line">replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="（2）ERROR-AddressSanitizer-SEGV-on-unknown-address-0x000000000000-pc-0x7fb0fb78fdbe-bp-0x61a0000002d0-sp-0x7ffd1c504cc0-T0-、"><a href="#（2）ERROR-AddressSanitizer-SEGV-on-unknown-address-0x000000000000-pc-0x7fb0fb78fdbe-bp-0x61a0000002d0-sp-0x7ffd1c504cc0-T0-、" class="headerlink" title="（2）ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7fb0fb78fdbe bp 0x61a0000002d0 sp 0x7ffd1c504cc0 T0)、"></a>（2）ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7fb0fb78fdbe bp 0x61a0000002d0 sp 0x7ffd1c504cc0 T0)、</h3><p>这个错误是由于在程序执行期间发生了段错误（<code>Segmentation Fault</code>），导致程序崩溃。</p>
<p>根据错误信息，问题出现在调用 <code>std::basic_streambuf&lt;char, std::char_traits&lt;char&gt;&gt;::xsgetn(char*, long)</code> 函数时，发生了对未知地址的写操作，这可能是由于访问了空指针或者其他非法内存区域引起的。</p>
<p>引起错误的代码行为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">page0 = bpm-&gt;<span class="built_in">FetchPage</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"><span class="type">char</span> *page_data = <span class="literal">nullptr</span>;</span><br><span class="line">disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, page_data);</span><br></pre></td></tr></table></figure>

<p>报错的原因可能是因为 <code>disk_manager_-&gt;ReadPage</code> 函数中的 <code>page_data</code> 参数被传入了空指针。在 C&#x2F;C++ 中，如果要通过函数修改指针指向的内存内容，需要确保传入的指针指向有效的内存空间，而不是空指针。</p>
<p>这里实际上应该直接传入<code>pages_[frame_id].dara_</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, pages_[frame_id].data_);</span><br></pre></td></tr></table></figure>

<h1 id="Task-3-Read-Write-Page-Guards"><a href="#Task-3-Read-Write-Page-Guards" class="headerlink" title="Task #3 - Read&#x2F;Write Page Guards"></a>Task #3 - Read&#x2F;Write Page Guards</h1><blockquote>
<p>您将实现BasicPageGuard，它存储指向BufferPoolManager和Page对象的指针。页面保护确保在相应的page对象超出作用域时立即在其上调用UnpinPage。注意，它仍然应该为程序员提供一个方法来手动解除页面的锁定。</p>
<p>由于BasicPageGuard隐藏了底层的Page指针，它还可以提供只读&#x2F;写数据api，提供编译时检查，以确保针对每种用例正确设置is_dirty标志。</p>
<p>在未来的项目中，多个线程将从同一个页面读取和写入，因此需要读写锁存器来确保数据的正确性。请注意，在Page类中，有用于此目的的相关锁存方法。与页面的解锁类似，程序员在使用页面后可能会忘记解锁页面。为了缓解这个问题，你将实现ReadPageGuard和WritePageGuard，它们会在页面超出范围时自动解锁。</p>
<p>你需要为所有的BasicPageGuard, ReadPageGuard和WritePageGuard实现以下函数。</p>
<ul>
<li><code>PageGuard(PageGuard &amp;&amp;that)</code> : Move constructor.</li>
<li><code>operator=(PageGuard &amp;&amp;that)</code> : Move operator.</li>
<li><code>Drop()</code> : Unpin and&#x2F;or unlatch.</li>
<li><code>~PageGuard()</code> : Destructor.</li>
</ul>
<p>使用新的页面保护，在BufferPoolManager中实现以下wrappers。</p>
<ul>
<li><code>FetchPageBasic(page_id_t page_id)</code></li>
<li><code>FetchPageRead(page_id_t page_id)</code></li>
<li><code>FetchPageWrite(page_id_t page_id)</code></li>
<li><code>NewPageGuarded(page_id_t *page_id)</code></li>
</ul>
</blockquote>
<p>这个<code>task</code>的重点就是实现移动构造、移动幅值、<code>Drop</code>和析构这四个函数。</p>
<h1 id="GradeScope在线测试"><a href="#GradeScope在线测试" class="headerlink" title="GradeScope在线测试"></a>GradeScope在线测试</h1><h2 id="1、LRUKReplacerTest-Evict"><a href="#1、LRUKReplacerTest-Evict" class="headerlink" title="1、LRUKReplacerTest.Evict"></a>1、LRUKReplacerTest.Evict</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19: /autograder/source/bustub/test/buffer/grading_lru_k_replacer_test.cpp:276: Failure</span><br><span class="line">19: Expected equality of these values:</span><br><span class="line">19:   i</span><br><span class="line">19:     Which is: 100</span><br><span class="line">19:   result</span><br><span class="line">19:     Which is: 0</span><br><span class="line">19: Check your return value behavior for LRUKReplacer::Evict</span><br></pre></td></tr></table></figure>

<p>这个问题我真的研究了很久，本地测试和前面的一大部分在线测试都可以过，但是就是卡在这里。后来查了很久，知乎上有一个博主说是发现他的<code>LRUKReplacer::Remove</code>。于是我去检查了我的<code>Remove</code>函数，发现我也没有写完……我只在<code>node_store_</code>中进行了删除，而没有在<code>node_less_k_</code>或者<code>node_more_k_</code>中删除，补上后这个测试就通过了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (it-&gt;second-&gt;is_evictable_) &#123;</span><br><span class="line">      <span class="comment">// 该帧为可驱逐状态，继续操作</span></span><br><span class="line">      it-&gt;second-&gt;history_.<span class="built_in">clear</span>();</span><br><span class="line">      <span class="comment">// -------- add ------------------------------ //</span></span><br><span class="line">      <span class="keyword">if</span> (it-&gt;second-&gt;pos_ != node_less_k_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        node_less_k_.<span class="built_in">erase</span>(it-&gt;second-&gt;pos_);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node_more_k_.<span class="built_in">erase</span>(it-&gt;second);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// -------- add ------------------------------ //</span></span><br><span class="line">      node_store_.<span class="built_in">erase</span>(it);</span><br><span class="line">      curr_size_--;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、BufferPoolManagerTest-UnpinPage"><a href="#2、BufferPoolManagerTest-UnpinPage" class="headerlink" title="2、BufferPoolManagerTest.UnpinPage"></a>2、BufferPoolManagerTest.UnpinPage</h2><h3 id="DeletePage"><a href="#DeletePage" class="headerlink" title="DeletePage"></a>DeletePage</h3><p>[*]Bug:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">------------------------------------------</span><br><span class="line"><span class="number">7</span>: UnpinPage: <span class="number">0</span></span><br><span class="line"><span class="number">7</span>: --- Before UnpinPage: --- </span><br><span class="line"><span class="number">7</span>: ---page_table size: <span class="number">2</span></span><br><span class="line"><span class="number">7</span>: ---page_table content:</span><br><span class="line"><span class="number">7</span>: page_id: <span class="number">1</span>, frame_id: <span class="number">1</span>, pin_count: <span class="number">1</span>, page_data: page1</span><br><span class="line"><span class="number">7</span>: page_id: <span class="number">0</span>, frame_id: <span class="number">0</span>, pin_count: <span class="number">1</span>, page_data: page0</span><br><span class="line"><span class="number">7</span>: ---free_list size: <span class="number">0</span></span><br><span class="line"><span class="number">7</span>: ---free_list Content:</span><br><span class="line"><span class="number">7</span>: </span><br><span class="line"><span class="number">7</span>: --- After UnpinPage: --- </span><br><span class="line"><span class="number">7</span>: ---page_table size: <span class="number">1</span></span><br><span class="line"><span class="number">7</span>: ---page_table content:</span><br><span class="line"><span class="number">7</span>: page_id: <span class="number">1</span>, frame_id: <span class="number">1</span>, pin_count: <span class="number">1</span>, page_data: page1</span><br><span class="line"><span class="number">7</span>: ---free_list size: <span class="number">0</span></span><br><span class="line"><span class="number">7</span>: ---free_list Content:  <span class="comment">// free_list的更新出错</span></span><br></pre></td></tr></table></figure>

<p>要在DeletePage中实现将不再使用的frame从Replacer中删除，并重新放入free_list中</p>
<h3 id="NewPage"><a href="#NewPage" class="headerlink" title="NewPage"></a>NewPage</h3><ul>
<li>通过evict获取frame时，要先删除其上的old page</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">page_table_.<span class="built_in">erase</span>(pages_[frame_id].page_id_);  <span class="comment">// debug</span></span><br></pre></td></tr></table></figure>

<h3 id="FetchPage"><a href="#FetchPage" class="headerlink" title="FetchPage"></a>FetchPage</h3><ul>
<li><p>同NewPage，通过evict获取frame时，要先删除其上的old page；</p>
</li>
<li><p>若在内存中没找到对应的page，而需要从disk中获取时，注意除了要在page_table中绑定page_id和frame_id，还要在pages_对象中更新page_id和frame_id的绑定关系</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pages_[frame_id].page_id_ = page_id;  <span class="comment">// debug</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在fetch一个page后，更新其dirty状态为false，因为此时的page刚从disk写完数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pages_[frame_id].is_dirty_ = <span class="literal">false</span>;  <span class="comment">// debug</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、BufferPoolManagerTest-ConcurrencyTest"><a href="#3、BufferPoolManagerTest-ConcurrencyTest" class="headerlink" title="3、BufferPoolManagerTest.ConcurrencyTest"></a>3、BufferPoolManagerTest.ConcurrencyTest</h2><p>问题出在每个函数的加锁写在了日志打印后面，因此出现并发错误。</p>
<h2 id="4、PageGuardTest-DropTest-PageGuardTest-MoveTest"><a href="#4、PageGuardTest-DropTest-PageGuardTest-MoveTest" class="headerlink" title="4、PageGuardTest.DropTest &amp;&amp; PageGuardTest.MoveTest"></a>4、PageGuardTest.DropTest &amp;&amp; PageGuardTest.MoveTest</h2><blockquote>
<p>PageGuardTest.DropTest (0&#x2F;8)<br>PageGuardTest.MoveTest (0&#x2F;8)<br>PageGuardTest.BPMTest (0&#x2F;9)</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403241940804.png" alt="image-20240324194001569"></p>
<p>经过研究，我重写了PageGuard.cpp中几个函数的逻辑：</p>
<h3 id="BasicPageGuard"><a href="#BasicPageGuard" class="headerlink" title="BasicPageGuard"></a>BasicPageGuard</h3><h4 id="（1）Drop"><a href="#（1）Drop" class="headerlink" title="（1）Drop()"></a>（1）Drop()</h4><p>忘记了对bpm_重置为nullptr;</p>
<h4 id="（2）operator-BasicPageGuard-that"><a href="#（2）operator-BasicPageGuard-that" class="headerlink" title="（2）operator&#x3D;(BasicPageGuard &amp;&amp;that)"></a>（2）operator&#x3D;(BasicPageGuard &amp;&amp;that)</h4><p>注意要先调用<code>Drop()</code>来drop掉当前的old guarded page，然后再进行资源转移。</p>
<h3 id="ReadPageGuard"><a href="#ReadPageGuard" class="headerlink" title="ReadPageGuard"></a>ReadPageGuard</h3><h4 id="（1）ReadPageGuard-ReadPageGuard-that"><a href="#（1）ReadPageGuard-ReadPageGuard-that" class="headerlink" title="（1）ReadPageGuard(ReadPageGuard &amp;&amp;that)"></a>（1）ReadPageGuard(ReadPageGuard &amp;&amp;that)</h4><p>虽然.cpp文件中写的是<code>=default</code>，但.h文件中又要求实现，所以还是实现了一下。</p>
<h4 id="（2）operator-ReadPageGuard-that"><a href="#（2）operator-ReadPageGuard-that" class="headerlink" title="（2）operator&#x3D;(ReadPageGuard &amp;&amp;that)"></a>（2）operator&#x3D;(ReadPageGuard &amp;&amp;that)</h4><p>这里我最开始只调用了<code>std::move(that.guard_)</code>，实际上应该1)先在page_不为空时进行解读锁；2)然后进行资源转移。</p>
<h4 id="（3）Drop"><a href="#（3）Drop" class="headerlink" title="（3）Drop()"></a>（3）Drop()</h4><p>这里和重载移动赋值运算符一样，最开始只调用了<code>Drop()</code>，而实际上也应该先解读锁。</p>
<h3 id="WritePageGuard"><a href="#WritePageGuard" class="headerlink" title="WritePageGuard"></a>WritePageGuard</h3><p>和ReadPageGuard同理。</p>
<p>最后，历时许久，第一个Project终于通过了！</p>
]]></content>
      <categories>
        <category>Project</category>
        <category>cmu15-445</category>
      </categories>
  </entry>
  <entry>
    <title>cmu15-445 Project 2 (Spring 2023)</title>
    <url>/2024/03/27/Project/cmu15-445/cmu15-445%20Project%202%20(Spring%202023)/</url>
    <content><![CDATA[<p>Overview：</p>
<blockquote>
<p>In this programming project you will implement a <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+Tree</a> index in your database system. <strong>A B+Tree is a balanced search tree in which the internal pages direct the search and leaf pages contain the actual data entries.</strong> The index provides fast data retrieval without needing to search every row in a database table, enabling rapid random lookups and efficient scans of ordered records. Your implementation will support thread-safe search, insertion, deletion (including splitting and merging nodes), and an iterator to support in-order leaf scans.</p>
<p>在这个编程项目中，您将在数据库系统中实现B+树索引。B+树是一种平衡搜索树，其中internal pages指导搜索，leaf pages包含实际的数据项。索引提供了快速的数据检索，而不需要搜索数据库表中的每一行，支持快速随机查找和高效的有序记录扫描。你的实现将支持<strong>线程安全</strong>的搜索、插入、删除(包括节点拆分和合并)，以及一个支持按序叶扫描的迭代器。</p>
</blockquote>
<p>Project2的实现依赖于Project1的buffer pool和page guards。</p>
<p>[TOC]</p>
<span id="more"></span>

<h1 id="Checkpoint-1-15-points"><a href="#Checkpoint-1-15-points" class="headerlink" title="Checkpoint #1 (15 points)"></a><strong>Checkpoint #1 (15 points)</strong></h1><h2 id="Task-1-B-Tree-Pages"><a href="#Task-1-B-Tree-Pages" class="headerlink" title="Task #1 - B+Tree Pages"></a>Task #1 - B+Tree Pages</h2><p>实现三个Page Classes去存储B+Tree的数据：</p>
<ul>
<li><p>B+Tree Page</p>
<ul>
<li>Base class，以供下面两个类继承。</li>
</ul>
</li>
<li><p>B+Tree Internal Page</p>
<ul>
<li><strong>存储m个ordered keys和m+1个child pointers</strong>（即page_ids，指向其他的B+Tree Pages），表现为<code>key/page_id</code>pairs；</li>
</ul>
<blockquote>
<p>Because the number of pointers does not equal the number of keys, the first key is set to be invalid, and lookups should always start with the second key.</p>
</blockquote>
<ul>
<li>在任意时刻，internal page必须至少为<code>half full</code>。<ul>
<li>删除时，两个<code>half full pages</code>可以合并，或<code>keys and pointers</code>重新分布来避免合并；</li>
<li>插入时，一个<code>full pages</code>可以拆分成两个，或<code>keys and pointers</code>重新分布来避免拆分。</li>
</ul>
</li>
</ul>
</li>
<li><p>B+Tree Leaf Page</p>
<ul>
<li><strong>存储m个ordered keys和m个相对应的value。</strong>value需要被设置为<strong>64-bit record-id</strong>。</li>
<li>其余设置和internal pages一致。</li>
</ul>
<blockquote>
<p>即使叶子页和内部页包含相同类型的键，它们的值类型也可能不同。因此，max_size 也可能不同。</p>
</blockquote>
</li>
</ul>
<p>注意：</p>
<p>1、每个 B+Tree 的叶子页&#x2F;内部页都与缓冲池获取的内存页的内容（即 data_ 部分）相对应；</p>
<p>2、每次read&#x2F;write一个leaf&#x2F;internal page时：</p>
<p>（1）从buffer pool中fetch该页；（page id）</p>
<p>（2）reinterpret cast to leaf&#x2F;internal page；</p>
<p>（3）读&#x2F;写完后Unpin该page。</p>
<ul>
<li><p>flexible array</p>
<ul>
<li><p>flexible array 必须是类中的最后一个成员，并且仅能有一个。在为对象分配内存时，flexible array 会自动填充，占用未被其他变量使用的内存。这样就可以确定自己的长度了。</p>
</li>
<li><p>举例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如有一个类 C：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">// 4 byte</span></span><br><span class="line">    <span class="type">int</span> array[<span class="number">1</span>]; <span class="comment">// unknown size</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在初始化一个 C 的对象，并为其分配了 24 byte 的内存。a 占了 4 byte 内存</span></span><br><span class="line"><span class="comment">// 那么 array 会尝试填充剩下的内存，大小变为 5。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="B-PLUS-TREE-INTERNAL-PAGE"><a href="#B-PLUS-TREE-INTERNAL-PAGE" class="headerlink" title="B_PLUS_TREE_INTERNAL_PAGE"></a><strong>B_PLUS_TREE_INTERNAL_PAGE</strong></h3><ul>
<li><p>对于 Internal Page 其储存的节点数最大正好是 internal_max_size，可能被存满</p>
<ul>
<li>由于先插入会导致空间溢出，因此考虑单独开辟一块内存空间，在完成插入与分裂后释放。</li>
</ul>
</li>
<li><p>要求第一个key为空的原因：在 internal page 中，n 个 key 可以将数轴划分为 n+1 个区域，也就对应着 n+1 个 value。</p>
</li>
<li><p>internal page 中的 key 并不代表实际上的索引值，仅仅是作为一个向导，引导需要插入&#x2F;删除&#x2F;查询的 key 找到这个 key 真正所在的 leaf page。</p>
</li>
<li><p>Header大小为24Byte：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">IndexPageType page_type_;   <span class="comment">// leaf or internal. 4 Byte</span></span><br><span class="line"><span class="type">lsn_t</span> lsn_  <span class="comment">// temporarily unused. 4 Byte</span></span><br><span class="line"><span class="type">int</span> size_;  <span class="comment">// tree page data size(not in byte, in count). 4 Byte</span></span><br><span class="line"><span class="type">int</span> max_size_;  <span class="comment">// tree page data max size(not in byte, in count). 4 Byte</span></span><br><span class="line"><span class="type">page_id_t</span> parent_page_id_; <span class="comment">// 4 Byte</span></span><br><span class="line"><span class="type">page_id_t</span> page_id_; <span class="comment">// 4 Byte</span></span><br><span class="line"><span class="comment">// 24 Byte in total</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>internal page的KV对</strong>中：</p>
<ul>
<li>K-比较大小的索引；</li>
<li>V-page_id，指向下一层的节点。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403291930057.png" alt="image-20240329193009583"></p>
<h3 id="B-PLUS-TREE-LEAF-PAGE"><a href="#B-PLUS-TREE-LEAF-PAGE" class="headerlink" title="B_PLUS_TREE_LEAF_PAGE"></a><strong>B_PLUS_TREE_LEAF_PAGE</strong></h3><ul>
<li>对于 Leaf Page 其储存的节点数最大永远是 leaf_max_size - 1，永远存不满、<ul>
<li>对于Leaf Page，直接先插入再分裂；</li>
</ul>
</li>
<li>Header大小为28Byte，多了一个成员变量 <code>next_page_id</code>。</li>
<li><strong>leaf page的KV对</strong>中：<ul>
<li>K-实际的索引；</li>
<li>V-Record ID，用于识别表中的某一条数据。</li>
</ul>
</li>
</ul>
<h2 id="Task-2a-B-Tree-Data-Structure-Insertion-Point-Search"><a href="#Task-2a-B-Tree-Data-Structure-Insertion-Point-Search" class="headerlink" title="Task #2a - B+Tree Data Structure (Insertion, Point Search)"></a>Task #2a - B+Tree Data Structure (Insertion, Point Search)</h2><ul>
<li>目标：实现1）<code>insertion：Insert()</code>；2）<code>Search：Getvalue()</code></li>
</ul>
<blockquote>
<p>index仅支持unique keys。</p>
<p>如果插入会改变树的不变形，需要进行结点的拆分或keys的重组。</p>
<p>若改变了root的page ID，必须更新<code>root_page_id</code>。为此，可以访问构造函数中给出的 <code>header_page_id_</code> 页面。然后，通过使用 <code>reinterpret cast</code>，可以将该页面解释为 <code>BPlusTreeHeaderPage</code>，并从这里更新root的page ID。此外，必须实现 <code>GetRootPageId</code>（目前默认返回 0）。</p>
<p>推荐使用<code>FetchPageBasic</code>来访问页。</p>
</blockquote>
<ul>
<li><p>对于取得的页进行操作：1）根据page_id取得guard；2）将其数据部分<code>data_</code>强制转换成对应的类型（reinterpret_cast&#x2F;As&#x2F;AsMut）。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将内部存储的指针按照指定的类型进行类型转换</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">As</span><span class="params">()</span> -&gt; <span class="type">const</span> T * </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> guard_.<span class="built_in">As</span>&lt;T&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><em><strong>（under analyze）补充</strong></em></p>
<h3 id="src-storage-page-b-plus-tree-internal-page-cpp"><a href="#src-storage-page-b-plus-tree-internal-page-cpp" class="headerlink" title="src&#x2F;storage&#x2F;page&#x2F;b_plus_tree_internal_page.cpp"></a>src&#x2F;storage&#x2F;page&#x2F;b_plus_tree_internal_page.cpp</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ==under analyze 1: FindValue的逻辑</span><br><span class="line">// ==under analyze 2: lambda 表达式 &amp; [comparator]</span><br><span class="line">// ==under analyze 2: std::lower_bound &amp; std::prev</span><br></pre></td></tr></table></figure>

<h3 id="src-storage-page-b-plus-tree-leaf-page-cpp"><a href="#src-storage-page-b-plus-tree-leaf-page-cpp" class="headerlink" title="src&#x2F;storage&#x2F;page&#x2F;b_plus_tree_leaf_page.cpp"></a>src&#x2F;storage&#x2F;page&#x2F;b_plus_tree_leaf_page.cpp</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ==under analyze 1: FindValue的逻辑</span><br></pre></td></tr></table></figure>

<h3 id="src-storage-index-b-plus-tree-cpp"><a href="#src-storage-index-b-plus-tree-cpp" class="headerlink" title="src&#x2F;storage&#x2F;index&#x2F;b_plus_tree.cpp"></a>src&#x2F;storage&#x2F;index&#x2F;b_plus_tree.cpp</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ==under analyze1: emplace_back()</span><br></pre></td></tr></table></figure>

<h1 id="Checkpoint-2-85-points"><a href="#Checkpoint-2-85-points" class="headerlink" title="Checkpoint #2 (85 points)"></a><strong>Checkpoint #2 (85 points)</strong></h1><h2 id="Task-2b-B-Tree-Data-Structure-Deletion"><a href="#Task-2b-B-Tree-Data-Structure-Deletion" class="headerlink" title="Task #2b - B+Tree Data Structure (Deletion)"></a>Task #2b - B+Tree Data Structure (Deletion)</h2><h2 id="Task-3-Index-Iterator"><a href="#Task-3-Index-Iterator" class="headerlink" title="Task #3 - Index Iterator"></a>Task #3 - Index Iterator</h2><h2 id="Task-4-Concurrency-Control"><a href="#Task-4-Concurrency-Control" class="headerlink" title="Task #4 - Concurrency Control"></a>Task #4 - Concurrency Control</h2>]]></content>
      <categories>
        <category>Project</category>
        <category>cmu15-445</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2023/12/05/%E9%9D%A2%E8%AF%95/DataStruct/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>《数据结构（严蔚敏）》_b站鲍松山</p>
<p>[TOC]</p>
<span id="more"></span>

<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><p>数据结构（Data Struct）：数据之间的组织架构&#x2F;结构。</p>
<blockquote>
<p><strong>DS：</strong></p>
<ul>
<li><strong>线性结构</strong><ul>
<li><strong>SeqList&#x2F;List&#x2F;Stack&#x2F;Queue&#x2F;String&#x2F;Array</strong></li>
</ul>
</li>
<li><strong>非线性结构</strong><ul>
<li><strong>Tree&#x2F;Graph</strong></li>
</ul>
</li>
<li><strong>排序</strong></li>
<li><strong>查找</strong></li>
<li><strong>算法</strong></li>
</ul>
</blockquote>
<h1 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2 线性表"></a>2 线性表</h1><h2 id="2-1-顺序表（SeqList）"><a href="#2-1-顺序表（SeqList）" class="headerlink" title="2.1 顺序表（SeqList）"></a>2.1 顺序表（SeqList）</h2><p>顺序表通过一组地址连续的空间对数据进行存储。</p>
<h2 id="2-2-单链表（List）"><a href="#2-2-单链表（List）" class="headerlink" title="2.2 单链表（List）"></a>2.2 单链表（List）</h2><p>不要求逻辑上相邻的元素在物理位置上也相邻，因此无法实现随机存取。</p>
<p>分清“谁的谁是谁”。 </p>
<p>操作时要时刻注意<code>last</code>这一项。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120918067.png" alt="image-20231212091813193" style="zoom: 33%;" />

<p><strong>头部插入时易错：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(List *<span class="built_in">list</span>, ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *s = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    assert(s != <span class="literal">NULL</span>);</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="built_in">list</span>-&gt;first-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;first-&gt;next = s;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下图所示，当使用头插法向<code>空list</code>中插入<code>1</code>后，<code>list-&gt;last</code>仍然指向头结点。‘</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915222.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915816.png" alt="2"></p>
<p> 对<code>pop_front</code>进行修改，加入对<code>size</code>的判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">list</span>-&gt;last = s; <span class="comment">// 当list为空时，对last进行移动</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915584.png" alt="3"></p>
<p><strong>头部删除时同理</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_front</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Node *p = <span class="built_in">list</span>-&gt;first-&gt;next;</span><br><span class="line">    <span class="built_in">list</span>-&gt;first-&gt;next = <span class="built_in">list</span>-&gt;first-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">list</span>-&gt;last = <span class="built_in">list</span>-&gt;first;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-静态链表（StaticList）"><a href="#2-3-静态链表（StaticList）" class="headerlink" title="2.3 静态链表（StaticList）"></a>2.3 静态链表（StaticList）</h2><p>使用<strong>静态链表</strong>可以便于在不设<em>指针</em>类型的高级程序设计语言中使用链表结构。</p>
<p>静态链表实际上就是用数组去模拟链表。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915948.png" alt="4" style="zoom: 67%;" />

<p>这里的<code>pool</code>指明下一个备用空间的地址。</p>
<h2 id="2-4-单循环链表（SCList）"><a href="#2-4-单循环链表（SCList）" class="headerlink" title="2.4 单循环链表（SCList）"></a>2.4 单循环链表（SCList）</h2><p>特点：尾节点指向头节点，整个链表形成一个环。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312121129584.png" alt="image-20231212112956184" style="zoom:33%;" />

<p>循环链表的操作和线性链表基本一致,差别仪在于算法中的循环条件不是<code>p</code>或<code>p-&gt;next</code>是否为空，而是它们是否等于头指针。但有的时候，若在循环链表中设立尾指针而不设头指针，可使某些操作简化。例如将两个线性表合并成一个表时，仅需将一个表的表尾和另一个表的表头相接。</p>
<p>初始化时，注意：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>-&gt;first = <span class="built_in">list</span>-&gt;last = s;</span><br><span class="line"><span class="built_in">list</span>-&gt;last-&gt;next = <span class="built_in">list</span>-&gt;first;</span><br><span class="line"><span class="built_in">list</span>-&gt;size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120928507.png" alt="image-20231212092812466"></p>
<p>尾插时的各节点地址：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120954889.png" alt="image-20231212095457800"  />

<p><strong>掌握按值删除这里的的思想：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按值删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_val</span><span class="params">(List *<span class="built_in">list</span>, ElemType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Node *p = find(<span class="built_in">list</span>, key);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;要删除的数据不存在！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p == <span class="built_in">list</span>-&gt;last)</span><br><span class="line">        pop_back(<span class="built_in">list</span>);</span><br><span class="line">    <span class="comment">////////////////////////////////***</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 即不是删除当前节点，而是将下一个节点的值赋值给当前节点，然后删除下一个节点</span></span><br><span class="line">        <span class="comment">// 这样做避免从头遍历链表</span></span><br><span class="line">        Node *q = p-&gt;next;</span><br><span class="line">        p-&gt;data = q-&gt;data;</span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        <span class="built_in">list</span>-&gt;size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">////////////////////////////////***</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>申请节点：Node *s<br>遍历节点：Node *p<br>删除节点：Node *q</p>
</blockquote>
<h2 id="2-5-双向链表（DList）"><a href="#2-5-双向链表（DList）" class="headerlink" title="2.5 双向链表（DList）"></a>2.5 双向链表（DList）</h2><p>每次操作时涉及4个指针：</p>
<ul>
<li>当前节点的前驱；</li>
<li>当前节点的后继；</li>
<li>前一个节点的后继；</li>
<li>后一个节点的前驱。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312131154818.png" alt="image-20231213115430268" style="zoom:33%;" />

<h2 id="2-6-双向循环链表（DCList）"><a href="#2-6-双向循环链表（DCList）" class="headerlink" title="2.6 双向循环链表（DCList）"></a>2.6 双向循环链表（DCList）</h2><p>存在两个环。</p>
<p><strong>环1是<code>list-&gt;last-&gt;next</code></strong></p>
<p><strong>环2是<code>list-&gt;first-&gt;prev</code></strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312140920009.png" alt="image-20231214092024742" style="zoom: 25%;" />

<h1 id="3-栈和队列"><a href="#3-栈和队列" class="headerlink" title="3 栈和队列"></a>3 栈和队列</h1><h2 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h2><p><strong>栈和队列的基本操作是线性表操作的子集，是操作受限的线性表。</strong></p>
<p>栈：限定仅在表尾插入或删除操作的线性表。表尾称为<strong>栈顶</strong>，表头称为<strong>栈底</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312141056107.png" alt="image-20231214105656926" style="zoom: 25%;" />

<h3 id="3-1-1-顺序栈（SeqStack）"><a href="#3-1-1-顺序栈（SeqStack）" class="headerlink" title="3.1.1 顺序栈（SeqStack）"></a>3.1.1 顺序栈（SeqStack）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312141103006.png" alt="image-20231214110346157" style="zoom:25%;" />

<h3 id="3-1-2-链栈（LinkStack）"><a href="#3-1-2-链栈（LinkStack）" class="headerlink" title="3.1.2 链栈（LinkStack）"></a>3.1.2 链栈（LinkStack）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312151207109.png" alt="image-20231215120659701" style="zoom:25%;" />

<h3 id="3-1-3-栈的应用"><a href="#3-1-3-栈的应用" class="headerlink" title="3.1.3 栈的应用"></a>3.1.3 栈的应用</h3><h4 id="1、数制转换"><a href="#1、数制转换" class="headerlink" title="1、数制转换"></a>1、数制转换</h4><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312151258969.png" alt="image-20231215125804838" style="zoom:67%;" />

<p>由于结果要从下往上读取，因此用一个栈来依次存放余数。最终依次取栈顶元素，就可以得到转换后的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;SeqStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数制转换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Convert_8</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqStack st;</span><br><span class="line">    InitStack(&amp;st);</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;st, value%<span class="number">8</span>);</span><br><span class="line">        value /= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Show(&amp;st);</span></span><br><span class="line">    <span class="keyword">while</span> (!(IsEmpty(&amp;st)))</span><br><span class="line">    &#123;</span><br><span class="line">        GetTop(&amp;st, &amp;v);</span><br><span class="line">        Pop(&amp;st);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.数制转换 ElemType int</span></span><br><span class="line">    <span class="type">int</span> value = <span class="number">47183</span>;</span><br><span class="line">    Convert_8(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、括号匹配"><a href="#2、括号匹配" class="headerlink" title="2、括号匹配"></a>2、括号匹配</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 括号匹配</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Check</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqStack st;</span><br><span class="line">    InitStack(&amp;st);</span><br><span class="line">    <span class="type">char</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">&#x27;[&#x27;</span> || *str == <span class="string">&#x27;&#123;&#x27;</span> || *str == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            Push(&amp;st, *str);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetTop(&amp;st, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Pop(&amp;st);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetTop(&amp;st, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Pop(&amp;st);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetTop(&amp;st, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Pop(&amp;st);</span><br><span class="line">        &#125; </span><br><span class="line">        *str++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IsEmpty(&amp;st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2.括号匹配 ElemType char</span></span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;[([][])]&quot;</span>; <span class="comment">// char *str    str是一个指向字符数组的指针</span></span><br><span class="line">    <span class="type">bool</span> flag = Check(str);</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Ok!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、行编辑程序"><a href="#3、行编辑程序" class="headerlink" title="3、行编辑程序"></a>3、行编辑程序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 3.行编辑程序</span></span><br><span class="line">    SeqStack st;</span><br><span class="line">    InitStack(&amp;st);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch != <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(ch !=<span class="string">&#x27;$&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(ch)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    Pop(&amp;st);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">                    Clear(&amp;st);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    Push(&amp;st, ch);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        Print(&amp;st);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    Destroy(&amp;st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-队列（LinkQueue）"><a href="#3-2-队列（LinkQueue）" class="headerlink" title="3.2 队列（LinkQueue）"></a>3.2 队列（LinkQueue）</h2><p>先进先出的结构。</p>
<p>最典型的队列例子是<strong>操作系统中的作业排队</strong>。</p>
<p>队列可分为单端队列和双端队列，但双端队列实际上远不及栈和单端队列有用。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161259625.png" alt="image-20231216125953859" style="zoom: 25%;" />

<h3 id="3-2-1-链队列（LinkQueue）"><a href="#3-2-1-链队列（LinkQueue）" class="headerlink" title="3.2.1 链队列（LinkQueue）"></a>3.2.1 链队列（LinkQueue）</h3><p>由两个分别指向队头和队尾的指针唯一确定一个队列。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161300828.png" alt="image-20231216130008621" style="zoom:20%;" />

<h3 id="3-2-2-顺序队列（SeqQueue）实现循环队列"><a href="#3-2-2-顺序队列（SeqQueue）实现循环队列" class="headerlink" title="3.2.2 顺序队列（SeqQueue）实现循环队列"></a>3.2.2 顺序队列（SeqQueue）实现循环队列</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161300215.png" alt="image-20231216130020025" style="zoom:25%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161300091.png" alt="image-20231216130034444" style="zoom: 33%;" />

<h1 id="4-串"><a href="#4-串" class="headerlink" title="4 串"></a>4 串</h1><p><code>C</code>语言实际上不存在字符串的概念。它是通过相应的字符指针指向一串字符。</p>
<p>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>而在<code>C++</code>中则出现了<code>string</code>类型，它实际上是一个用类实现的数据结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>串的定义：串（<code>string</code>）（或字符串）是由零个或多个字符组成的有限序列。</p>
<p>一般对串的整体进行操作，而不是对其中的单个元素进行操作。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312182049251.png" alt="image-20231218204922589" style="zoom: 25%;" />

<h2 id="4-1-定长顺序存储方式（StackString）"><a href="#4-1-定长顺序存储方式（StackString）" class="headerlink" title="4.1 定长顺序存储方式（StackString）"></a>4.1 定长顺序存储方式（StackString）</h2><p>定长的方式：<strong>先开辟的定长数组</strong>描述字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRLEN 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> u_char unsigned char</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> u_char SString[MAXSTRLEN+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<h2 id="4-2-堆分配存储方式（HeapString）"><a href="#4-2-堆分配存储方式（HeapString）" class="headerlink" title="4.2 堆分配存储方式（HeapString）"></a>4.2 堆分配存储方式（HeapString）</h2><p>仍以一组地址连续的存储单元存放串值字符序列，但其存储空间在程序执行过程中动态分配而得。用<code>malloc()</code>来为新产生的串分配存储空间，并约定串长也作为存储结构的一部分。</p>
<p>函数内部四步：</p>
<ul>
<li>条件判断（不满足条件直接返回）</li>
<li>空间判断（涉及操作的串的空间是否需要赋空，<code>free</code>）</li>
<li>空间分配（给串分配空间，<code>malloc</code>)</li>
<li>赋值操作</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312182049570.png" alt="image-20231218204932225" style="zoom: 33%;" />

<h1 id="5-数组和广义表"><a href="#5-数组和广义表" class="headerlink" title="5 数组和广义表"></a>5 数组和广义表</h1><h2 id="5-1-矩阵的压缩存储（SparseMatrix）"><a href="#5-1-矩阵的压缩存储（SparseMatrix）" class="headerlink" title="5.1 矩阵的压缩存储（SparseMatrix）"></a>5.1 矩阵的压缩存储（SparseMatrix）</h2><p>感兴趣的不是矩阵本身，而是如何存储矩阵的元，使得矩阵进行各项运算。</p>
<p>压缩存储：为多个值相同的元只分配一个存储空间；对零元不分配存储空间。假若值相同的元素或者零元素在矩阵中的分布有一定规律，称为<strong>特殊矩阵</strong>；反之，称为<strong>稀疏矩阵</strong>。</p>
<p><strong>压缩存储时，需要用一个三元组<code>(i,j,aij)</code>唯一确定矩阵A的一个非零元，即除了存储非零元的值<code>aij</code>外，还需要存储其所在行和列的位置<code>(i,j)</code>。</strong></p>
<p>稀疏矩阵的压缩存储示例：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312191547788.png" alt="image-20231219154712437" style="zoom:80%;" />

<h2 id="5-2-矩阵的快速转置算法实现"><a href="#5-2-矩阵的快速转置算法实现" class="headerlink" title="5.2 矩阵的快速转置算法实现"></a>5.2 矩阵的快速转置算法实现</h2><ul>
<li><p>（1）交换矩阵的行列值；</p>
</li>
<li><p>（2）交换三元组中的<code>i</code>和<code>j</code>；</p>
</li>
<li><p><strong>（3）重排三元组之间的次序。—-重点！</strong></p>
<ul>
<li>实现方法1：较为笨拙的重复遍历</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312192015890.png" alt="image-20231219201524473" style="zoom: 33%;" />

<ul>
<li><p>实现方法2：快速转置算法</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312192039855.png" alt="image-20231219203949650" style="zoom: 50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矩阵快速转置（实现方法2）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FastTransposeMatrix</span><span class="params">(SparseMatrix *M, SparseMatrix *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    T-&gt;mu = M-&gt;nu;</span><br><span class="line">    T-&gt;nu = M-&gt;mu;</span><br><span class="line">    T-&gt;tu = M-&gt;tu;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *num = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * M-&gt;nu);  <span class="comment">// M中每一列非零元的个数</span></span><br><span class="line">    assert(num != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">int</span> *cpot = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * M-&gt;nu);  <span class="comment">// M中每一列的第一个非零元对应三元组空间所在位置</span></span><br><span class="line">    assert(cpot != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;tu != <span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 初始化num数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>; col&lt;M-&gt;nu; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            num[col] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>; t&lt;M-&gt;tu; ++t)</span><br><span class="line">        &#123;</span><br><span class="line">            num[M-&gt;data[t].j]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化cpot数组</span></span><br><span class="line">        cpot[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">1</span>; col&lt;M-&gt;nu; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            cpot[col] = cpot[col<span class="number">-1</span>] + num[col<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行转置映射</span></span><br><span class="line">        <span class="type">int</span> col = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> kt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> km=<span class="number">0</span>; km&lt;M-&gt;tu; ++km)</span><br><span class="line">        &#123;</span><br><span class="line">            col = M-&gt;data[km].j;</span><br><span class="line">            kt = cpot[col];</span><br><span class="line">            T-&gt;data[kt].i = M-&gt;data[km].j;</span><br><span class="line">            T-&gt;data[kt].j = M-&gt;data[km].i;</span><br><span class="line">            T-&gt;data[kt].e = M-&gt;data[km].e;</span><br><span class="line">            cpot[col]++; <span class="comment">// 重要步骤</span></span><br><span class="line">            kt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在C中，如果使用了动态内存分配函数如malloc、calloc或realloc来分配内存</span></span><br><span class="line">    <span class="comment">// 那么最终应该使用 free 函数来释放已分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(num);</span><br><span class="line">    <span class="built_in">free</span>(cpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="5-3-广义表（GenList"><a href="#5-3-广义表（GenList" class="headerlink" title="5.3 广义表（GenList)"></a>5.3 广义表（GenList)</h2><blockquote>
<p><strong>所谓的广义表实际上就是一个递归概念。</strong></p>
<p><strong>1、处理tag&#x3D;&#x3D;ATOM的节点；</strong></p>
<p><strong>2、对子表进行递归操作；</strong></p>
<ul>
<li><strong>找到子表中的tag&#x3D;&#x3D;ATOM的节点并处理；</strong></li>
<li><strong>对剩下的节点组成的新的子表重复步骤2，直至子表中不存在节点。</strong></li>
</ul>
</blockquote>
<h3 id="1、含义"><a href="#1、含义" class="headerlink" title="1、含义"></a>1、含义</h3><p>线性表的推广。简单来说就是<strong>表中有表</strong>。</p>
<p>因此，有一个概念要尤其注意，<strong>即广义表是由无数个广义表组成的自身。</strong></p>
<h3 id="2、定义"><a href="#2、定义" class="headerlink" title="2、定义"></a>2、定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LS=(a1,a2,...an)</span><br></pre></td></tr></table></figure>

<p>其中，<code>ai(1&lt;=i&lt;=n)</code>可以是单个元素，也可以是广义表，分别称为<strong>原子</strong>和<strong>子集</strong>。当广义表非空时，<code>a1</code>称为表头（<code>Head</code>），其余元素组成的表<code>(a2,a3,...,an)</code>称为表尾（<code>Tail</code>）。</p>
<p><strong>举例：</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312200930160.png" alt="image-20231220093015065"></p>
<p><strong>注意：</strong>           </p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312200931491.png" alt="image-20231220093159352"></p>
<h3 id="3、存储结构"><a href="#3、存储结构" class="headerlink" title="3、存储结构"></a>3、存储结构</h3><p>由于表中的数据元素可以具有不同结构，因此一般采用<strong>链式存储方式</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312201010034.png" alt="image-20231220101006602" style="zoom: 33%;" />

<h2 id="5-4-表头分割算法"><a href="#5-4-表头分割算法" class="headerlink" title="5.4 表头分割算法"></a>5.4 表头分割算法</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312201628127.png" alt="image-20231220162815397" style="zoom: 33%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建广义表：通过字符串str来创建广义表gl</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateGenList</span><span class="params">(GenList &amp;gl, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(str);  <span class="comment">// 求解字符串长度</span></span><br><span class="line">	<span class="comment">// 存储表内元素</span></span><br><span class="line">	<span class="type">char</span> *sub = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (n<span class="number">-2</span>));</span><br><span class="line">	<span class="comment">// 存储表头</span></span><br><span class="line">	<span class="type">char</span> *hsub = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (n<span class="number">-2</span>));</span><br><span class="line">	assert(sub!=<span class="literal">NULL</span> &amp;&amp; hsub!=<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &quot;1,2,3&quot;</span></span><br><span class="line">	<span class="comment">// 去掉sub左右两边的括号</span></span><br><span class="line">	<span class="built_in">strncpy</span>(sub,str+<span class="number">1</span>,n<span class="number">-2</span>); </span><br><span class="line">	sub[n<span class="number">-2</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//加上结束符</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断广义表是否为空</span></span><br><span class="line">	<span class="keyword">if</span>(gl == <span class="literal">NULL</span>)  <span class="comment">// 为空</span></span><br><span class="line">	&#123;   </span><br><span class="line">		<span class="comment">//  创建头结点(广义表的第一个结点为头结点，其余都为尾结点)</span></span><br><span class="line">		gl = (GLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GLNode));</span><br><span class="line">		assert(gl != <span class="literal">NULL</span>);</span><br><span class="line">		gl-&gt;tag = HEAD;  <span class="comment">// 结点标记为头结点</span></span><br><span class="line">		gl-&gt;hp = gl-&gt;tp = <span class="literal">NULL</span>;  <span class="comment">// 把子表指针和尾指针都指向空</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	GLNode *p = gl;  <span class="comment">// 为了不丢失gl的指向，定义一个指针来操作</span></span><br><span class="line">	<span class="comment">// 求子串长度，当sub长度不为零时，说明广义表还未创建完成</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">strlen</span>(sub) != <span class="number">0</span>)</span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="comment">//  采用尾插法,在后面插入结点</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			1、创建一个结点</span></span><br><span class="line"><span class="comment">			2、让p所指结点的尾指针指向新建的结点</span></span><br><span class="line"><span class="comment">			3、让p指向新建结点</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		p = p-&gt;tp = (GLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GLNode));</span><br><span class="line">		assert(p != <span class="literal">NULL</span>);</span><br><span class="line">		p-&gt;hp = p-&gt;tp = <span class="literal">NULL</span>;  <span class="comment">// 将新建结点的子表指针和尾指针都赋空</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//  &quot;1,2,3&quot;     ==&gt;  &quot;1&quot;      hsub=&quot;1&quot;  sub=&quot;2,3&quot;;</span></span><br><span class="line">		<span class="comment">//  &quot;(1,2),3,4&quot; ==&gt;  &quot;(1,2)&quot;  hsub=&quot;(1,2)&quot; sub=&quot;3,4&quot;</span></span><br><span class="line">		<span class="keyword">if</span>(sever(sub,hsub))  <span class="comment">// sever函数分离表头，并将表头存入hsub中</span></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 对分离出来的表头进行判断，是否包含括号</span></span><br><span class="line">			<span class="keyword">if</span>(hsub[<span class="number">0</span>] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 说明要创建的结点是子表类型</span></span><br><span class="line">				p-&gt;tag = CHILDLIST;  <span class="comment">// 设置子表标记</span></span><br><span class="line">				CreateGenList(p-&gt;hp,hsub);  <span class="comment">// 在p的表头结点处，创建hsub子表</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 说明要创建的结点是原子类型</span></span><br><span class="line">				p-&gt;tag = ATOM;  <span class="comment">// 设置原子标记</span></span><br><span class="line">				p-&gt;atom = atoi(hsub);  <span class="comment">// 将表头字符串转换成整型数据，赋值给原子数据</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广义表表头分割函数，将sub中的表头分割到hsub中</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sever</span><span class="params">(<span class="type">char</span> *sub, <span class="type">char</span> *hsub)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//  判断sub是否为空</span></span><br><span class="line">	<span class="keyword">if</span>(*sub==<span class="string">&#x27;\0&#x27;</span> || <span class="built_in">strcmp</span>(sub,<span class="string">&quot;()&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 是 情况：&quot;&quot;  或  &quot;()&quot;</span></span><br><span class="line">		hsub[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 将hsub赋空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(sub);  <span class="comment">// 求sub的长度</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch = sub[<span class="number">0</span>];  <span class="comment">// 获取第一个字符</span></span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;  <span class="comment">// 表示括号的信息</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        当sub还没遍历完成且还未检测到括号外的逗号，继续遍历</span></span><br><span class="line"><span class="comment">	    注：当检测到括号外的逗号时，说明找到表头分割点，如：&quot;(1,2),3,4&quot; 表头即为(1,2)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;n &amp;&amp; (ch!=<span class="string">&#x27;,&#x27;</span>|| k!=<span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 判断是否运到左括号</span></span><br><span class="line">		<span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">			k++;  <span class="comment">// k++表示进入一层括号</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;)&#x27;</span>)  <span class="comment">// 判断是否遇到右括号</span></span><br><span class="line">			k--;   <span class="comment">// k--表示退出一层括号</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取下一个元素</span></span><br><span class="line">		i++;</span><br><span class="line">		ch = sub[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断是否是因为检测到括号外的逗号而结束的</span></span><br><span class="line">	<span class="keyword">if</span>(i &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 是</span></span><br><span class="line">		<span class="comment">// 在i位置截断，前面部分就是表头</span></span><br><span class="line">		sub[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="comment">// 将取得的表头放入hsub中</span></span><br><span class="line">		<span class="built_in">strcpy</span>(hsub,sub);</span><br><span class="line">		<span class="comment">// 更新sub的值：此时的sub应该去掉表头hsub</span></span><br><span class="line">		<span class="built_in">strcpy</span>(sub,sub+i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(k != <span class="number">0</span>)  <span class="comment">// 判断是否是因为内部括号不匹配</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 是，分割失败</span></span><br><span class="line">	<span class="keyword">else</span>  <span class="comment">// 判断是否是因为i&gt;=n而结束</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 是，情况 &quot;(1,2)&quot;  ==&gt; hsub =&quot;(1,2)&quot;  sub = &quot;&quot;</span></span><br><span class="line">		<span class="comment">// 说明sub整个就是表头</span></span><br><span class="line">		<span class="built_in">strcpy</span>(hsub,sub);  <span class="comment">// 把sub整个赋值给hsub</span></span><br><span class="line">		sub[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// sub赋给hsub后，此时sub为空</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-树和二叉树"><a href="#6-树和二叉树" class="headerlink" title="6 树和二叉树"></a>6 树和二叉树</h1><h2 id="6-1-树及二叉树的概念与性质"><a href="#6-1-树及二叉树的概念与性质" class="headerlink" title="6.1 树及二叉树的概念与性质"></a>6.1 树及二叉树的概念与性质</h2><p><strong>树</strong>：</p>
<ul>
<li><p>结点拥有的子树数称为结点的<strong>度</strong>；</p>
</li>
<li><p>树种结点的最大层次（横向）称为树的<strong>深度****或</strong>高度**；</p>
</li>
<li><p><strong>森林</strong>是<code>m(m&gt;=0)</code>棵互不相交的树的集合。</p>
</li>
</ul>
<p><strong>二叉树</strong></p>
<ul>
<li><p>每个结点至多只有两颗子树，且有左右之分；</p>
<ul>
<li><strong>性质1：</strong>第<code>i</code>层（层次）至多有<code>2^(i-1)</code>个结点；</li>
<li><strong>性质2：</strong>深度为<code>k</code>的二叉树至多有<code>2^k-1</code>个结点；</li>
<li><strong>性质3：</strong>对任何一棵二叉树<code>T</code>，其终端结点数为<code>n0</code>，度为<code>2</code>的结点数为<code>n2</code>，则<code>n0=n2+1</code>；</li>
</ul>
</li>
<li><p>满二叉树：所有结点（除叶子结点外）均有左右分支；</p>
</li>
<li><p>完全二叉树：基于满二叉树实现，<em><strong>性质4&#x2F;5代表从<code>1</code>开始编号的情况。</strong></em></p>
<ul>
<li><strong>性质4：</strong>具有<code>n</code>个结点的<strong>完全二叉树</strong>的深度为<code>[log2n]+1</code>(<code>&quot;[]&quot;</code>表示向下取整)；</li>
<li><strong>性质5：</strong>对一棵有<code>n</code>个结点的<strong>完全二叉树</strong>的结点按层序编号，对任一结点<code>i(1&lt;=i&lt;=n)</code>：<ul>
<li><strong>（1）</strong>若<code>i=1</code>，则结点i是二叉树的根，无双亲；若<code>i&gt;1</code>，则其双亲<code>PARENT(i)</code>是结点<code>[i/2]</code>；</li>
<li><strong>（2）</strong>若<code>2i&gt;n</code>，则结点<code>i</code>无左孩子；否则左孩子是<code>2i</code>；</li>
<li><strong>（3）</strong>若<code>2i+1&gt;n</code>，则结点<code>i</code>无右孩子；否则右孩子是<code>2i+1</code>；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-2-二叉树的链式存储方式（二叉链表，BinTree）"><a href="#6-2-二叉树的链式存储方式（二叉链表，BinTree）" class="headerlink" title="6.2 二叉树的链式存储方式（二叉链表，BinTree）"></a>6.2 二叉树的链式存储方式（二叉链表，BinTree）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType BinTreeNode*</span></span><br></pre></td></tr></table></figure>

<h2 id="6-3-二叉树的非递归遍历"><a href="#6-3-二叉树的非递归遍历" class="headerlink" title="6.3 二叉树的非递归遍历"></a>6.3 二叉树的非递归遍历</h2><p>用<strong>栈</strong>实现。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221544737.png" alt="image-20231222154427982"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221544992.png" alt="image-20231222154440257"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221544658.png" alt="image-20231222154447677"></p>
<h2 id="6-4-二叉树的恢复实现"><a href="#6-4-二叉树的恢复实现" class="headerlink" title="6.4 二叉树的恢复实现"></a>6.4 二叉树的恢复实现</h2><p>两个概念：二叉树的<strong>相似</strong>和<strong>等价</strong>。</p>
<ul>
<li>相似：形状相同，内容不同</li>
<li>等价：形状和内容均相同。</li>
</ul>
<p>二叉树的计数问题：讨论具有<code>n</code>个结点、互不相似的二叉树的数目<code>b</code>。</p>
<p>含有<code>n</code>个结点的不相似的二叉树有：<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221413095.png" alt="image-20231222141353060" style="zoom: 50%;" />棵。</p>
<blockquote>
<p>1、前序+中序唯一恢复一棵二叉树。</p>
<p>2、中序+后序唯一恢复一棵二叉树。</p>
<p>注意：<strong>恢复二叉树时一定要有中序存在</strong>，因为通过中序遍历可以得知这棵二叉树的左右分布。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序+中序恢复二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_5</span><span class="params">(BinTree *bt, <span class="type">char</span> *VLR, <span class="type">char</span>*LVR, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    CreateBinTree_5(bt-&gt;root, VLR, LVR, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_5</span><span class="params">(BinTreeNode *&amp;t, <span class="type">char</span> *VLR, <span class="type">char</span>*LVR, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(VLR[<span class="number">0</span>] != LVR[k])</span><br><span class="line">            k++;</span><br><span class="line"></span><br><span class="line">        t = (BinTreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTreeNode));</span><br><span class="line">        assert(t != <span class="literal">NULL</span>);</span><br><span class="line">        t-&gt;data = LVR[k];</span><br><span class="line"></span><br><span class="line">        CreateBinTree_5(t-&gt;leftChild, VLR+<span class="number">1</span>, LVR, k);</span><br><span class="line">        CreateBinTree_5(t-&gt;rightChild, VLR+k+<span class="number">1</span>, LVR+k+<span class="number">1</span>, n-k<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序+后序恢复二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_6</span><span class="params">(BinTree *bt, <span class="type">char</span> *LVR, <span class="type">char</span>*LRV, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    CreateBinTree_6(bt-&gt;root, LVR, LRV, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_6</span><span class="params">(BinTreeNode *&amp;t, <span class="type">char</span> *LVR, <span class="type">char</span>*LRV, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(LRV[n<span class="number">-1</span>] != LVR[k])</span><br><span class="line">            k++;</span><br><span class="line">        </span><br><span class="line">        t = (BinTreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTreeNode));</span><br><span class="line">        assert(t != <span class="literal">NULL</span>);</span><br><span class="line">        t-&gt;data = LVR[k];</span><br><span class="line"></span><br><span class="line">        CreateBinTree_6(t-&gt;rightChild, LVR+k+<span class="number">1</span>, LRV+k, n-k<span class="number">-1</span>);</span><br><span class="line">        CreateBinTree_6(t-&gt;leftChild, LVR, LRV, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-5-线索二叉树"><a href="#6-5-线索二叉树" class="headerlink" title="6.5 线索二叉树"></a>6.5 线索二叉树</h2><blockquote>
<p>同时保存节点的<strong>前驱和后继</strong>信息。由于<code>n</code>个结点必然存在<code>n+1</code>个空链，实际上并未完全保存所有的前驱后继信息，而只是利用了这<code>n+1</code>个空链。</p>
</blockquote>
<p>举例：对下面这棵二叉树按照中序遍历线索化</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312232026443.png" alt="image-20231223202641174"></p>
<h2 id="6-6-树和森林"><a href="#6-6-树和森林" class="headerlink" title="6.6 树和森林"></a>6.6 树和森林</h2><p>讨论树的表示及其遍历操作，并建立森林与二叉树的对应关系。</p>
<p>注意这里的树<em>不局限于二叉树</em>。</p>
<h3 id="1、双亲表示法（仅了解即可）"><a href="#1、双亲表示法（仅了解即可）" class="headerlink" title="1、双亲表示法（仅了解即可）"></a>1、双亲表示法（仅了解即可）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241441068.png" alt="image-20231224144144837" style="zoom: 80%;" />

<p><strong>缺点</strong>：求父结点很方便，但求孩子结点时需要遍历整个结构。</p>
<h3 id="2、孩子表示法（仅了解即可）"><a href="#2、孩子表示法（仅了解即可）" class="headerlink" title="2、孩子表示法（仅了解即可）"></a>2、孩子表示法（仅了解即可）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241517749.png" alt="image-20231224151751633"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241518866.png" alt="image-20231224151800720"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241517901.png" alt="image-20231224151730578"></p>
<h3 id="3、孩子兄弟表示法（重要）"><a href="#3、孩子兄弟表示法（重要）" class="headerlink" title="3、孩子兄弟表示法（重要）"></a>3、孩子兄弟表示法（重要）</h3><p>又称二叉树表示法或二叉链表表示法。即以二叉链表作为树的存储结构。</p>
<p>链表中结点的两个链域分别指向该结点的第一个<strong>孩子结点</strong>和下一个<strong>兄弟结点</strong>。<em>（即左孩子，右兄弟）</em></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241541154.png" alt="image-20231224154137327" style="zoom: 33%;" />

<p>对其进行遍历可得：</p>
<p>（1）先序遍历<strong>（先访问根，再依次访问根的每棵子树）</strong>：<code>A B C D E</code></p>
<p>（2）后序遍历<strong>（先依次访问根的每棵子树，再访问根）</strong>：<code>B D C E A</code></p>
<p><strong>树不包含中序遍历！</strong></p>
<h3 id="4、森林和二叉树的转换"><a href="#4、森林和二叉树的转换" class="headerlink" title="4、森林和二叉树的转换"></a>4、森林和二叉树的转换</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241530772.png" alt="image-20231224153024529" style="zoom: 67%;" />

<p>上图依然遵循“左孩子右兄弟”的概念。当三棵树的树根相连时，树根结点之间的关系即为“兄弟”的关系。</p>
<p>对其进行遍历可得：</p>
<p>（1）先序遍历：<code>A B C D E F G H I J</code></p>
<ul>
<li>访问第一棵树的根结点；</li>
<li>先序遍历第一棵树的根结点的子树森林；</li>
<li>先序遍历除去第一棵树之后剩余的树构成的森林。</li>
</ul>
<p>（2）中序遍历：<code>B C D A F E H J I G</code></p>
<ul>
<li>中序遍历森林中第一棵树的根结点的子树森林；</li>
<li>访问第一棵树的根结点；</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林。</li>
</ul>
<blockquote>
<p>对比图6.15和图6.17可以发现，若以二叉链表的形式表示时：</p>
<ul>
<li>如果仅包含左孩子，则为一棵树的二叉链表表示；</li>
<li>否则，则是森林的二叉链表表示。</li>
</ul>
</blockquote>
<h3 id="5、在树中查找父结点和在二叉树中查找父结点"><a href="#5、在树中查找父结点和在二叉树中查找父结点" class="headerlink" title="5、在树中查找父结点和在二叉树中查找父结点"></a>5、在树中查找父结点和在二叉树中查找父结点</h3><h4 id="（1）在树中查找父结点"><a href="#（1）在树中查找父结点" class="headerlink" title="（1）在树中查找父结点"></a>（1）在树中查找父结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找父结点</span></span><br><span class="line">TreeNode* <span class="title function_">Parent</span><span class="params">(Tree *tree, TreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Parent(tree-&gt;root, p);</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* <span class="title function_">Parent</span><span class="params">(TreeNode *t, TreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span> || p == <span class="literal">NULL</span> || p == t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode *q = t-&gt;firstChild;</span><br><span class="line">    TreeNode *parent;</span><br><span class="line">    <span class="keyword">while</span>(q != <span class="literal">NULL</span> &amp;&amp; q != p)</span><br><span class="line">    &#123;</span><br><span class="line">        parent = Parent(q, p);  <span class="comment">// 在第一个孩子结点中查找parent结点</span></span><br><span class="line">        <span class="keyword">if</span>(parent != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        q = q-&gt;nextSilbing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(q != <span class="literal">NULL</span> &amp;&amp; q == p)  <span class="comment">// q(t-&gt;firstChild)==p说明要查找的结点p的父结点即为t</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241742171.png" alt="image-20231224174224376" style="zoom: 33%;" />

<h4 id="（2）在二叉树中查找父结点"><a href="#（2）在二叉树中查找父结点" class="headerlink" title="（2）在二叉树中查找父结点"></a>（2）在二叉树中查找父结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找父节点</span></span><br><span class="line">BinTreeNode* <span class="title function_">Parent</span><span class="params">(BinTree *bt, BinTreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Parent(bt-&gt;root, p);</span><br><span class="line">&#125;</span><br><span class="line">BinTreeNode* <span class="title function_">Parent</span><span class="params">(BinTreeNode *t, BinTreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span> || p == <span class="literal">NULL</span>)  <span class="comment">// 树为空或查找的节点为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">if</span>(t-&gt;leftChild == p || t-&gt;leftChild == p)</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    </span><br><span class="line">    BinTreeNode *q = Parent(t-&gt;leftChild, p);</span><br><span class="line">    <span class="keyword">if</span>(q != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    <span class="keyword">return</span> Parent(t-&gt;rightChild, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-图"><a href="#7-图" class="headerlink" title="7 图"></a>7 图</h1><h2 id="7-1-图的定义与概念"><a href="#7-1-图的定义与概念" class="headerlink" title="7.1 图的定义与概念"></a>7.1 图的定义与概念</h2><p>图中的数据元素称为<strong>顶点</strong>(<code>Vertex</code>)，<code>V</code>是顶点的有穷非空集合。<code>E</code>是两个顶点之间的集合。</p>
<ul>
<li><p><code>&lt;v, w&gt;</code>：从顶点<code>v</code>到顶点<code>w</code>的有向边；</p>
</li>
<li><p><code>(v, w)</code>：从顶点<code>v</code>到顶点<code>w</code>的无向边。</p>
</li>
</ul>
<p>图中共<code>n</code>个顶点，此时：</p>
<ul>
<li>对无向图来说边的个数范围为<code>0~1/2(n(n-1))</code>，当有<code>1/2(n(n-1)</code>条边时为<strong>无向完全图</strong>。</li>
<li>对有向图来说边的个数范围为<code>0~n(n-1)</code>，当有<code>n(n-1)</code>条边时为<strong>有向完全图</strong>。</li>
</ul>
<p>图（<code>Graph</code>）与子图（<code>Subgraph</code>）</p>
<p>权（<code>Weight</code>）</p>
<p>邻接点</p>
<p>顶点<code>v</code>的度（<code>Degree</code>）是和<code>v</code>相关联的边的数目。在有向图中还要分<strong>入度</strong>和<strong>出度</strong>。</p>
<p>从顶点<code>v</code>到顶点<code>v&#39;</code>的路径（<code>Path</code>）是一个顶点序列。路径的长度是路径上的边或弧的数目。第一个顶点和最后一个顶点相同的路径称为回路或环（<code>Cycle</code>）。在无向图<code>G</code>中，若从顶点<code>v</code>到顶点<code>v&#39;</code>有路径，则称<code>v</code>和<code>v&#39;</code>是连通的。若图中任意两个顶点都是连通的，则称<code>G</code>为<strong>连通图</strong>。而<strong>连通分量</strong>（<code>Connected Component</code>）是指无向图中的<strong>极大连通子图</strong>。</p>
<p>一个连通图的<strong>生成树</strong>是一个极小连通子图。如果在一棵生成树上添加一条边，必定形成一个环。</p>
<h2 id="7-2-图的存储方式"><a href="#7-2-图的存储方式" class="headerlink" title="7.2 图的存储方式"></a>7.2 图的存储方式</h2><h3 id="1、邻接矩阵表示方式（数组形式，重要）"><a href="#1、邻接矩阵表示方式（数组形式，重要）" class="headerlink" title="1、邻接矩阵表示方式（数组形式，重要）"></a>1、邻接矩阵表示方式（数组形式，重要）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251216684.png" alt="image-20231225121641478" style="zoom: 25%;" />

<p>两个数组分别存储数据元素（顶点）的信息和数据元素之间的关系（边或弧）的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Default_Vertex_Size 10  <span class="comment">// 默认顶点数大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T char</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphMtx</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span>   MaxVertices;    <span class="comment">// 最大顶点数，即容量</span></span><br><span class="line">    <span class="type">int</span>   NumVertices;    <span class="comment">// 当前顶点数，即真实大小</span></span><br><span class="line">    <span class="type">int</span>   NumEdges;       <span class="comment">// 当前边数</span></span><br><span class="line"></span><br><span class="line">    T    *VerticesList;   <span class="comment">// 顶点列表</span></span><br><span class="line">    <span class="type">int</span> **Edge;           <span class="comment">// 指向邻接矩阵，二维数组</span></span><br><span class="line">    <span class="comment">// 一维数组：指向每一行，即每个顶点和其他顶点的边的连接</span></span><br><span class="line">    <span class="comment">// 二维数组：指向每一列，即当前图包含的所有顶点</span></span><br><span class="line"></span><br><span class="line">&#125;GraphMtx;</span><br></pre></td></tr></table></figure>

<h3 id="2、邻接表表示方式（链表形式，重要）"><a href="#2、邻接表表示方式（链表形式，重要）" class="headerlink" title="2、邻接表表示方式（链表形式，重要）"></a>2、邻接表表示方式（链表形式，重要）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Dafault_Vertex_Size 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 边结构。1）保存顶点的位置信息；2）指向下一个顶点的位置信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> dest;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点结构。包含1）顶点的信息；2）指向的边的信息。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T data;</span><br><span class="line">    Edge *adj;</span><br><span class="line">&#125;Vertex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphLink</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> MaxVertices;</span><br><span class="line">    <span class="type">int</span> NumVertices;</span><br><span class="line">    <span class="type">int</span> NumEdges;</span><br><span class="line"></span><br><span class="line">    Vertex *NodeTable;  <span class="comment">// 存放顶点的“List”</span></span><br><span class="line">&#125;GraphLink;</span><br></pre></td></tr></table></figure>

<p>最重要也是最复杂的函数：删除顶点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除顶点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RemoveVertex</span><span class="params">(GraphLink *g, T vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v = GetVertexPos(g, vertex);</span><br><span class="line">    <span class="comment">// 顶点v不存在，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(v == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除顶点：用最后一个顶点的值覆盖要删除的顶点</span></span><br><span class="line">    <span class="comment">// 删除边：直接调用函数RemoveEdge</span></span><br><span class="line"></span><br><span class="line">    Edge *p = g-&gt;NodeTable[v].adj;  <span class="comment">// p指向要删除结点v的边链表</span></span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    Edge *t = <span class="literal">NULL</span>;  <span class="comment">// s的前驱t，注意一定要先赋值为NULL</span></span><br><span class="line">    Edge *s;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        k = p-&gt;dest;  <span class="comment">// 在释放边之前要先获取和这个顶点有关的顶点的位置信息</span></span><br><span class="line">        s = g-&gt;NodeTable[k].adj;  <span class="comment">// s指向和v相连的第一个顶点的边链表</span></span><br><span class="line">        <span class="keyword">while</span>(s != <span class="literal">NULL</span> &amp;&amp; s-&gt;dest != v)</span><br><span class="line">        &#123;</span><br><span class="line">            t = s;</span><br><span class="line">            s = s-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="literal">NULL</span>) </span><br><span class="line">                g-&gt;NodeTable[k].adj = s-&gt;link;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t-&gt;link = s-&gt;link;</span><br><span class="line">            <span class="built_in">free</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放当前结点</span></span><br><span class="line">        g-&gt;NodeTable[v].adj = p-&gt;link;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="comment">// p指向下一个结点，执行下一次删除</span></span><br><span class="line">        p = g-&gt;NodeTable[v].adj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g-&gt;NumVertices--;</span><br><span class="line">    <span class="comment">// 用最后一个结点vl覆盖要删除的结点v</span></span><br><span class="line">    g-&gt;NodeTable[v].data = g-&gt;NodeTable[g-&gt;NumVertices].data;</span><br><span class="line">    g-&gt;NodeTable[v].adj = g-&gt;NodeTable[g-&gt;NumVertices].adj;</span><br><span class="line">    <span class="comment">// 由于此时vl的下标改变，因此遍历vl的边，对应修改和vl相连的顶点，其指向vl的边的下标位置</span></span><br><span class="line">    s = g-&gt;NodeTable[v].adj;</span><br><span class="line">    <span class="keyword">while</span>(s != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        k = s-&gt;dest;</span><br><span class="line">        p = g-&gt;NodeTable[k].adj;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;dest == g-&gt;NumVertices)  <span class="comment">// 找到了指向vl的边</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;dest = v;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、十字链表（仅了解即可）"><a href="#3、十字链表（仅了解即可）" class="headerlink" title="3、十字链表（仅了解即可）"></a>3、十字链表（仅了解即可）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312261148808.png" alt="image-20231226114811489" style="zoom:50%;" />

<h3 id="4、多重邻接表（仅了解即可）"><a href="#4、多重邻接表（仅了解即可）" class="headerlink" title="4、多重邻接表（仅了解即可）"></a>4、多重邻接表（仅了解即可）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312261256940.png" alt="image-20231226125619799" style="zoom: 50%;" />

<h3 id="5、四种存储结构的对比"><a href="#5、四种存储结构的对比" class="headerlink" title="5、四种存储结构的对比"></a>5、四种存储结构的对比</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312261300229.png" alt="image-20231226130055141" style="zoom: 25%;" />

<h2 id="7-3-图的两种遍历方式"><a href="#7-3-图的两种遍历方式" class="headerlink" title="7.3 图的两种遍历方式"></a>7.3 图的两种遍历方式</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312281111625.png" alt="image-20231228111115955" style="zoom:25%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphLink *g, T vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    <span class="type">bool</span> *visited = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * n);  <span class="comment">// visited数组指明当前顶点是否被访问过</span></span><br><span class="line">    assert(visited != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v = GetVertexPos(g, vertex);</span><br><span class="line">    <span class="keyword">if</span>(v == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    DFS(g, v, visited);</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphLink *g, <span class="type">int</span> v, <span class="type">bool</span> visited[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 顶点A对应的位置为A</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;&quot;</span>, GetVertexValue(g, v));</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问顶点A的邻接点</span></span><br><span class="line">    <span class="type">int</span> w = GetFirstNeighbor(g, GetVertexValue(g, v));</span><br><span class="line">    <span class="keyword">while</span>(w != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 深度遍历</span></span><br><span class="line">        <span class="comment">// 递归访问和当前邻接点相连的邻接点</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[w])</span><br><span class="line">            DFS(g, w, visited);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归访问A的其他邻接点</span></span><br><span class="line">        <span class="comment">// 类似于链表中的 w = w-&gt;next;</span></span><br><span class="line">        w = GetNextNeighbor(g, GetVertexValue(g, v), GetVertexValue(g, w));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 广度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(GraphLink *g, T vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    <span class="type">bool</span> *visited = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * n);  <span class="comment">// visited数组指明当前顶点是否被访问过</span></span><br><span class="line">    assert(visited != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> v = GetVertexPos(g, vertex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;&quot;</span>, GetVertexValue(g, v));</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line"></span><br><span class="line">    EnQueue(&amp;Q, v);</span><br><span class="line">    <span class="keyword">while</span>(!EmptyQueue(&amp;Q))</span><br><span class="line">    &#123;</span><br><span class="line">        GetHead(&amp;Q, &amp;v);</span><br><span class="line">        DeQueue(&amp;Q);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> w = GetFirstNeighbor(g, GetVertexValue(g, v));</span><br><span class="line">        <span class="keyword">while</span>(w != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;&quot;</span>, GetVertexValue(g, w));</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                EnQueue(&amp;Q, w);</span><br><span class="line">            &#125;</span><br><span class="line">            w = GetNextNeighbor(g, GetVertexValue(g, v), GetVertexValue(g, w));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-4-图的连通性问题"><a href="#7-4-图的连通性问题" class="headerlink" title="7.4 图的连通性问题"></a>7.4 图的连通性问题</h2><p><strong>连通图：任意顶点间都有路径可以相互到达。</strong></p>
<p>对于无向图来说，若图连通，则采用<code>DFS/BFS</code>即可遍历整张图。</p>
<h3 id="1、非连通图遍历"><a href="#1、非连通图遍历" class="headerlink" title="1、非连通图遍历"></a>1、非连通图遍历</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312281110107.png" alt="image-20231228111031643" style="zoom: 25%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非连通图遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Components</span><span class="params">(GraphLink *g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    <span class="type">bool</span> *visited = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * n);  <span class="comment">// visited数组指明当前顶点是否被访问过</span></span><br><span class="line">    assert(visited != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            DFS(g, i, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、最小生成树（Minimum-Spanning-Tree-MST）"><a href="#2、最小生成树（Minimum-Spanning-Tree-MST）" class="headerlink" title="2、最小生成树（Minimum Spanning Tree, MST）"></a>2、最小生成树（Minimum Spanning Tree, MST）</h3><p>对于<code>n</code>个顶点，通过<code>n-1</code>条边进行连接，找到加权和最小的图。</p>
<h4 id="（1）Prim算法"><a href="#（1）Prim算法" class="headerlink" title="（1）Prim算法"></a>（1）<code>Prim</code>算法</h4><p>先找一条权值最小的边，然后从这两个顶点出发，依次找和这两个顶点连接的边中权值较小的，逐步扩散。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312281115869.png" alt="image-20231228111509756" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401030936983.png" alt="image-20240103093658857" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401030937827.png" alt="image-20240103093711759" style="zoom:67%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最小生成树_Prim算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MinSpanTree_Prim</span><span class="params">(GraphMtx *g, T vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;  <span class="comment">// 计算顶点个数</span></span><br><span class="line">    E *lowcost = (E*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E)*n);  <span class="comment">// lowcost[n]，最小花费的数组</span></span><br><span class="line">    <span class="type">int</span> *mst = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*n);  <span class="comment">// mst[n]，最小花费的起始顶点的数组</span></span><br><span class="line">    assert(lowcost != <span class="literal">NULL</span> &amp;&amp; mst != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、初始化lowcost</span></span><br><span class="line">    <span class="type">int</span> k = GetVertexPos(g, vertex);  <span class="comment">// 获取vertex的位置，作为初始的起始顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != k)</span><br><span class="line">        &#123;</span><br><span class="line">            lowcost[i] = GetWeight(g, k, i);  <span class="comment">// 获取从k到i的边的权重，lowcost[i]中i为终点顶点</span></span><br><span class="line">            mst[i] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            lowcost[i] = <span class="number">0</span>;  <span class="comment">// lowcost[i]=0 ==&gt; 顶点i属于MST的顶点集合</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、从初始起始顶点出发，寻找最小代价的边值</span></span><br><span class="line">    <span class="type">int</span> min, min_index;</span><br><span class="line">    <span class="type">int</span> begin, end;</span><br><span class="line">    E cost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历找到需要的n-1条边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)  <span class="comment">// n-1 ==&gt; n个顶点最多n-1条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        min = MAX_COST;</span><br><span class="line">        min_index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// （1）经过n次遍历，找到从vertex出发的一条权值最小的路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j]&lt;min)  </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// lowcost[j] != 0 ==&gt; 说明顶点j还未加入MST的顶点集合</span></span><br><span class="line">                min = lowcost[j];</span><br><span class="line">                min_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        begin = mst[min_index];</span><br><span class="line">        end = min_index;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;%c : %d\n&quot;</span>, g-&gt;VerticesList[begin], g-&gt;VerticesList[end], min);</span><br><span class="line">        </span><br><span class="line">        lowcost[min_index] = <span class="number">0</span>;  <span class="comment">// 将minx_index所代表的顶点加入MST顶点集合中，后续不再进行考虑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// （2）加入新顶点后，更新此时的lowcost和mst数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cost = GetWeight(g, min_index, j);</span><br><span class="line">            <span class="keyword">if</span>(cost &lt; lowcost[j])</span><br><span class="line">            &#123;</span><br><span class="line">                lowcost[j] = cost;  <span class="comment">// 顶点j到min_index对应顶点的权值比到之前保存的权值更小，因此更新权值</span></span><br><span class="line">                mst[j] = min_index;  <span class="comment">// 更新此时顶点j所对应的起始顶点为min_index对应顶点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（2）Kruskal算法"><a href="#（2）Kruskal算法" class="headerlink" title="（2）Kruskal算法"></a>（2）<code>Kruskal</code>算法</h4><p>每次找权值最小的边，但不关心此时顶点是否已与其他顶点相连。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312281115942.png" alt="image-20231228111533837" style="zoom:80%;" />

<p><strong>关键点：判断新加入的边是否可已有的边属于同一个连通子图。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断i和j是否处于同一连通子图</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_Same</span><span class="params">(<span class="type">int</span> *father, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从当前节点i开始层层追踪，直到找到其最后的父节点</span></span><br><span class="line">    <span class="comment">// father[i]==i说明i自己是一个单独的存在，没有和它连通的顶点</span></span><br><span class="line">    <span class="keyword">while</span>(father[i] != i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 否则，找到和它连通的顶点，并且层层寻找，直到找到最后一个不和其他顶点相连的顶点</span></span><br><span class="line">        <span class="comment">// 这样就追溯到了他的根节点</span></span><br><span class="line">        i = father[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(father[j] != j)</span><br><span class="line">    &#123;</span><br><span class="line">        j = father[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i==j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将i和j标记为相同集合</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mark_Same</span><span class="params">(<span class="type">int</span> *father, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(father[i] != i)</span><br><span class="line">    &#123;</span><br><span class="line">        i = father[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(father[j] != j)</span><br><span class="line">    &#123;</span><br><span class="line">        j = father[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    father[j] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MinSpanTree_Kruskal</span><span class="params">(GraphMtx *g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    Edge *edge = (Edge*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Edge) * (n*(n<span class="number">-1</span>)/<span class="number">2</span>));</span><br><span class="line">    assert(edge != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化edge结构</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查找邻接矩阵的上三角矩阵，避免重复查找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 顶点间的边存在时，初始化edge结构体</span></span><br><span class="line">            <span class="keyword">if</span>(g-&gt;Edge[i][j] != <span class="number">0</span> &amp;&amp; g-&gt;Edge[i][j] != MAX_COST)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[k].x = i;</span><br><span class="line">                edge[k].y = j;</span><br><span class="line">                edge[k].cost = g-&gt;Edge[i][j];</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;k; ++i)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     v1 = edge[i].x;</span></span><br><span class="line">    <span class="comment">//     v2 = edge[i].y;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%c--&gt;%c : %d\n&quot;, g-&gt;VerticesList[v1], g-&gt;VerticesList[v2], edge[i].cost);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将边按照权值升序排序</span></span><br><span class="line">    qsort(edge, k, <span class="keyword">sizeof</span>(Edge), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法核心，判断新加入的边是否可已有的边属于同一个连通子图</span></span><br><span class="line">    <span class="type">int</span> *father = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) *n);</span><br><span class="line">    assert(father != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i] = i;  <span class="comment">// 初始化i的父节点为i自己</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当x与y的父节点不为同一个父节点时，进行连接</span></span><br><span class="line">        <span class="keyword">if</span>(!Is_Same(father, edge[i].x, edge[i].y))</span><br><span class="line">        &#123;</span><br><span class="line">            v1 = edge[i].x;</span><br><span class="line">            v2 = edge[i].y;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;%c : %d\n&quot;</span>, g-&gt;VerticesList[v1], g-&gt;VerticesList[v2], edge[i].cost);</span><br><span class="line">            Mark_Same(father, edge[i].x, edge[i].y);  <span class="comment">// 连接x和y后，将其标记为Same，合并为一个整体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一般来说，两个算法得到的最小生成树唯一。权值相同时可能形状存在差异，但加权和一定一致。</strong></p>
<h2 id="7-5-有向无环图（Directed-Acyclic-Graph-DAG）"><a href="#7-5-有向无环图（Directed-Acyclic-Graph-DAG）" class="headerlink" title="7.5 有向无环图（Directed Acyclic Graph, DAG）"></a>7.5 有向无环图（Directed Acyclic Graph, DAG）</h2><p><code>DAG</code>图是描述含有公共子式的表达式的有效工具。</p>
<ul>
<li><p><code>AOV（Activity On Vertex）</code>：以顶点为活动的网络图</p>
</li>
<li><p><code>AOE（Activity On Edge）</code>：以边为活动的网络图</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401071525659.png" alt="image-20240107152528272"></p>
<h3 id="1、拓扑排序（Topological-Sort）"><a href="#1、拓扑排序（Topological-Sort）" class="headerlink" title="1、拓扑排序（Topological Sort）"></a>1、拓扑排序（<code>Topological Sort</code>）</h3><p><strong>定义</strong>：由某个集合上的一个偏序得到该集合上的一个全序，这个操作称为拓扑排序。（<code>AOV</code>）</p>
<blockquote>
<p><strong>步骤：</strong></p>
<p><strong>s1、先找到一个没有入度的顶点，放入排序中；</strong></p>
<p><strong>s2、删除该顶点和与其相关的边，此时各顶点的入度改变；</strong></p>
<p><strong>s3、重复s1和s2，直至不存在顶点未被排序。</strong></p>
</blockquote>
<p><strong>关键实现</strong>：</p>
<ul>
<li>建立一个栈结构，保存顶点及其入度相关的信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TopologicalSort</span><span class="params">(GraphLink *g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;  <span class="comment">// 顶点个数</span></span><br><span class="line">    <span class="type">int</span> *count = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*n);  <span class="comment">// 初始化count数组，存储顶点及其入度信息</span></span><br><span class="line">    assert(count != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        count[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计入度信息</span></span><br><span class="line">    Edge *p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = g-&gt;NodeTable[i].adj;  <span class="comment">// p指向存放当前顶点边信息的邻接表</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count[p-&gt;dest]++;  <span class="comment">// 在count数组中，对应有入度的顶点位置++</span></span><br><span class="line">            p = p-&gt;link;  <span class="comment">// p指向下一个顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;n; ++i)</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\n&quot;, count[i]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历count，找到所有入度为0的顶点，并存入栈中</span></span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;  <span class="comment">// 所谓的“栈顶指针”</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若该顶点入度为0</span></span><br><span class="line">        <span class="keyword">if</span>(count[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 模拟入栈</span></span><br><span class="line">            count[i] = top;  <span class="comment">// count[i]保存了上一个入度为0的顶点的下标   </span></span><br><span class="line">            top = i;  <span class="comment">// top指向顶点i（即入度为0的栈顶元素）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v, w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(top == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;网络中有回路，无法进行拓扑排序！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 模拟出栈</span></span><br><span class="line">            v = top;  <span class="comment">// v指向栈顶元素（即此时度为0的顶点）</span></span><br><span class="line">            top = count[top];  <span class="comment">// 相当于出栈顶点v的操作</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;&quot;</span>, g-&gt;NodeTable[v]);</span><br><span class="line">            <span class="comment">// 求解v的邻接顶点</span></span><br><span class="line">            w = GetFirstNeighbor(g, g-&gt;NodeTable[v].data);</span><br><span class="line">            <span class="keyword">while</span>(w != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 删去对应的边后若入度为0，则对顶点w进行入栈操作</span></span><br><span class="line">                <span class="keyword">if</span>(--count[w] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 入栈</span></span><br><span class="line">                    count[w] = top;</span><br><span class="line">                    top = w;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则不进行入栈操作，寻找下一个邻接顶点</span></span><br><span class="line">                w = GetNextNeighbor(g, g-&gt;NodeTable[v].data, g-&gt;NodeTable[w].data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Nul.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、关键路径求解（Critical-Path）"><a href="#2、关键路径求解（Critical-Path）" class="headerlink" title="2、关键路径求解（Critical Path）"></a>2、关键路径求解（Critical Path）</h3><p><strong>定义</strong>：由于在<code>AOE</code>网中有些活动可以并行地进行，所以完成工程的最短时间是从开始点到完成点的最长路径的长度，路径长度最长的路径叫做关键路径。（这里的路径长度指路径上各活动的持续时间之和）</p>
<blockquote>
<p><strong>步骤：</strong></p>
<p><strong>s1、先正向求解每个顶点的最早开始时间；</strong></p>
<p><strong>s2、再反向求解每个顶点的最晚开始时间。</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求解关键路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CriticalPath</span><span class="params">(GraphMtx *g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    <span class="type">int</span> *ve = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    <span class="type">int</span> *vl = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    assert(ve != <span class="literal">NULL</span> &amp;&amp; vl != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ve[i] = <span class="number">0</span>;</span><br><span class="line">        vl[i] = MAX_COST;  <span class="comment">// 此处不能初始化为0，否则求解vl时会出现负数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正向求解每个顶点的最早开始时间，ve</span></span><br><span class="line">    <span class="comment">// 实际上这个步骤相当于在初始化最早开始时间</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        对最早开始时间的理解：</span></span><br><span class="line"><span class="comment">            假设此时有一条边从v指向w，</span></span><br><span class="line"><span class="comment">            v的最早开始时间为t1，w的最早开始时间为t2，边v-&gt;w的权值为cost，</span></span><br><span class="line"><span class="comment">            若t1+cost&gt;t2，则更新t2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> j, w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        j = GetFirstNeighbor(g, g-&gt;VerticesList[i]);  <span class="comment">// 指向i的第一个邻接顶点</span></span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            w = GetWeight(g, i, j);  <span class="comment">// 获取边i-&gt;j的权值</span></span><br><span class="line">            <span class="keyword">if</span>((ve[i] + w) &gt; ve[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ve[j] = ve[i] + w;</span><br><span class="line">            &#125;</span><br><span class="line">            j = GetNextNeighbor(g, g-&gt;VerticesList[i], g-&gt;VerticesList[j]);  <span class="comment">// 获取下一个邻接顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;n; ++i)</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\t&quot;, ve[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向求解每个顶点的最晚开始时间，vl</span></span><br><span class="line">    <span class="comment">// 实际上这个步骤相当于在初始化最晚开始时间</span></span><br><span class="line">    <span class="comment">// 最晚开始时间：如果从顶点i到顶点j存在多条路径，则最长时间的那条路径A为关键路径，而小于最长时间的其他路径可以在A开始后一段时间再进行</span></span><br><span class="line">    vl[n<span class="number">-1</span>] = ve[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>; i&gt;<span class="number">0</span>; --i)  <span class="comment">// 从倒数第二个顶点开始往前遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        j = GetFirstNeighbor(g, g-&gt;VerticesList[i]);  <span class="comment">// 指向i的第一个邻接顶点</span></span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            w = GetWeight(g, i, j);</span><br><span class="line">            <span class="comment">// 若步骤j的最晚开始时间（vl[j]）减去活动(i, j)的时间（w）小于步骤i的最晚开始时间（vl[i]），更新vl[i]</span></span><br><span class="line">            <span class="comment">// 因为说明此时活动(i, j)的持续时间要长于原先走的那条路径，所以要进行更新</span></span><br><span class="line">            <span class="comment">// 也就是说，应该选择更小的时间</span></span><br><span class="line">            <span class="keyword">if</span>((vl[j] - w) &lt; vl[i])  </span><br><span class="line">            &#123;</span><br><span class="line">                vl[i] = vl[j] - w;</span><br><span class="line">            &#125;</span><br><span class="line">            j = GetNextNeighbor(g, g-&gt;VerticesList[i], g-&gt;VerticesList[j]);  <span class="comment">// 获取下一个邻接顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;n; ++i)</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\t&quot;, vl[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> Ae, Al;  <span class="comment">// 活动的最早开始时间和最晚开始时间，这里的A代表边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        j = GetFirstNeighbor(g, g-&gt;VerticesList[i]);  <span class="comment">// 指向i的第一个邻接顶点</span></span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Ae = ve[i];  <span class="comment">// 活动的最早开始时间</span></span><br><span class="line">            Al = vl[j] - GetWeight(g, i, j);  <span class="comment">// 有点没太理解这一行</span></span><br><span class="line">            <span class="comment">// vl[j]是顶点j代表该步骤的最晚开始时间，边ij的权重是从完成步骤i所需的时间</span></span><br><span class="line">            <span class="comment">// vl[j] - GetWeight(g, i, j)即代表活动j的最晚开始时间</span></span><br><span class="line">            <span class="keyword">if</span>(Ae == Al)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 说明i和j是关键路径上的两个顶点</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;%c, %c&gt;是关键路径.\n&quot;</span>, g-&gt;VerticesList[i], g-&gt;VerticesList[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            j = GetNextNeighbor(g, g-&gt;VerticesList[i], g-&gt;VerticesList[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ve);</span><br><span class="line">    <span class="built_in">free</span>(vl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-6-最短路径"><a href="#7-6-最短路径" class="headerlink" title="7.6 最短路径"></a>7.6 最短路径</h2><p><strong>从某个源点到其余各个顶点的最短路径</strong></p>
<p><strong><code>Dijkstra</code>算法</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401081053558.png" alt="image-20240108105354193" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401081055708.png" alt="image-20240108105532557" style="zoom: 50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// diskstra算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath</span><span class="params">(GraphMtx *g, T vertex, E dist[], <span class="type">int</span> path[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;  <span class="comment">// 记录顶点个数</span></span><br><span class="line">    <span class="type">bool</span> *S = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>)*n);  <span class="comment">// 已找到从vertex出发的最短路径的终点的集合</span></span><br><span class="line">    assert(S != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v = GetVertexPos(g, vertex);  <span class="comment">// 得到vertex的下标位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dist[i] = GetWeight(g, v, i);  <span class="comment">// 获取顶点vertex到其余各顶点对应的权值，初始化dist</span></span><br><span class="line">        S[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(i != v &amp;&amp; dist[i] &lt; MAX_COST)</span><br><span class="line">        &#123;</span><br><span class="line">            path[i] = v;  <span class="comment">// 若vertex和顶点i有边（方向为vertex-&gt;i），则初始化其起始点为vertex</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            path[i] = <span class="number">-1</span>;  <span class="comment">// 否则初始化其起始点为-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    S[v] = <span class="literal">true</span>;  <span class="comment">// 代表顶点vertex已经加入集合</span></span><br><span class="line">    <span class="type">int</span> min, w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)  <span class="comment">// n-1是因为起始点已经定为vertex了</span></span><br><span class="line">    &#123;</span><br><span class="line">        min = MAX_COST;  <span class="comment">// 初始化最小花费为最大代价</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在本次循环中找到花费最小的路径&lt;i, j&gt;，并用顶点u记录这个顶点j方便后续处理</span></span><br><span class="line">        <span class="type">int</span> u = v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!S[j] &amp;&amp; dist[j] &lt; min)  <span class="comment">// !S[j] --&gt; 未加入集合</span></span><br><span class="line">            &#123;</span><br><span class="line">                u = j;  <span class="comment">// 记录当前顶点</span></span><br><span class="line">                min = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        S[u] = <span class="literal">true</span>;  <span class="comment">// 加入顶点u</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从顶点u出发，更新从u出发到达其他顶点的dist对应的权重</span></span><br><span class="line">        <span class="comment">// 相当于更新dist数组，以便进入下一次循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            w = GetWeight(g, u, k);  <span class="comment">// 顶点u到其余顶点的权值</span></span><br><span class="line">            <span class="keyword">if</span>(!S[k] &amp;&amp; w &lt; MAX_COST &amp;&amp; (dist[u]+w)&lt;dist[k])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[k] = dist[u] + w;</span><br><span class="line">                path[k] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d--&gt;&quot;</span>, path[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Nul.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d--&gt;&quot;</span>, dist[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Nul.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-查找"><a href="#8-查找" class="headerlink" title="8 查找"></a>8 查找</h1><p><strong>查找表</strong>（<code>Search Table</code>）：由同一类型的数据元素（或记录）构成的集合。</p>
<h2 id="8-1-静态查找表"><a href="#8-1-静态查找表" class="headerlink" title="8.1 静态查找表"></a>8.1 静态查找表</h2><h2 id="8-2-动态查找表"><a href="#8-2-动态查找表" class="headerlink" title="8.2 动态查找表"></a>8.2 动态查找表</h2><p><strong>定义</strong>：表结构本身是在查找过程中动态生成的。即对于给定key值，若表中存在关键字等于key值的记录，则查找成功返回；否则插入关键字等于key的记录。</p>
<h3 id="1、二叉排序树（Binary-Sort-Tree）"><a href="#1、二叉排序树（Binary-Sort-Tree）" class="headerlink" title="1、二叉排序树（Binary Sort Tree）"></a>1、二叉排序树（Binary Sort Tree）</h3><p>二叉排序树又称二叉搜索树。</p>
<p><strong>定义</strong>：</p>
<ul>
<li>（1）若左子树非空，则左子树上的所有结点的值小于根节点的值；</li>
<li>（2）若右子树非空，则右子树上的所有结点的值大于根节点的值；</li>
<li>（3）左、右子树分别也为二叉排序树。</li>
</ul>
<h3 id="2、平衡二叉树（Balanced-Binary-Tree-Height-Balanced-Tree）"><a href="#2、平衡二叉树（Balanced-Binary-Tree-Height-Balanced-Tree）" class="headerlink" title="2、平衡二叉树（Balanced Binary Tree&#x2F;Height-Balanced Tree）"></a>2、平衡二叉树（Balanced Binary Tree&#x2F;Height-Balanced Tree）</h3><p>平衡二叉树的前提是这棵树为二叉搜索树。</p>
<p><strong>平衡</strong>：左右子树的深度之差绝对值不大于1。</p>
<p><strong>平衡因子</strong><code>BF(Balanced Factor)</code>：该结点的右子树的深度减去其左子树的深度。</p>
<blockquote>
<p>深度：从根节点数到它的叶节点；</p>
<p>⾼度：从叶节点数到它的根节点</p>
</blockquote>
<p><strong>处理方法</strong>：旋转时结点的处理顺序是从<strong>第一个不平衡的结点</strong>开始。</p>
<ul>
<li>单旋转：不平衡的结点处于同一直线<ul>
<li>左旋转</li>
<li>右旋转</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401191222815.png" alt="image-20240119122225757" style="zoom: 25%;" />

<ul>
<li>双旋转：不平衡的结点处于折线状态<ul>
<li>先左后右（针对向左突出，＜）</li>
<li>先右后左（针对向右突出，＞）</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401191600972.png" alt="image-20240119160055303" style="zoom:25%;" />

<p>删除结点：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401211202772.png" alt="image-20240121120204211"></p>
<h3 id="3、哈希表"><a href="#3、哈希表" class="headerlink" title="3、哈希表"></a>3、哈希表</h3><p><strong>定义：</strong></p>
<p>根据设定的哈希函数<code>H(key)</code>和处理冲突的方法将一组关键字映像到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置。这一映像过程称为<strong>哈希表</strong>或<strong>散列</strong>，所得存储位置称哈希地址或散列地址。</p>
<p><strong>关键问题：</strong></p>
<p>1、创建哈希函数；</p>
<ul>
<li><strong>除留余数法</strong>；（使用最广泛）</li>
</ul>
<p>2、解决哈希冲突。</p>
<ul>
<li><strong>链地址法</strong>；（使用最广泛，相当于顺序表+链表）</li>
</ul>
<p><strong>溢出表算法（公司面试题）</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401231117485.png" alt="image-20240123111749039"></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401231307889.png" alt="image-20240123130752821" style="zoom: 25%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init_bucket_node</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;P; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;BUCKET_NODE_SIZE; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            hash_table[i].data[j] = NULL_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">        hash_table[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Insert_new_element</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="built_in">Hash</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;BUCKET_NODE_SIZE; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hash_table[index].data[i] == NULL_DATA)</span><br><span class="line">        &#123;</span><br><span class="line">            hash_table[index].data[i] = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 溢出桶有空余，直接插入</span></span><br><span class="line">    bucket_node *p = &amp;hash_table[index];</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;BUCKET_NODE_SIZE; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data[i] == NULL_DATA)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;data[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不存在有空余的溢出桶，则新建一个</span></span><br><span class="line">    bucket_node *s = (bucket_node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(bucket_node));</span><br><span class="line">    <span class="built_in">assert</span>(s != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;BUCKET_NODE_SIZE; ++i)</span><br><span class="line">        s-&gt;data[i] = NULL_DATA;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    s-&gt;data[<span class="number">0</span>] = x;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-排序"><a href="#9-排序" class="headerlink" title="9 排序"></a>9 排序</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><p>线性&#x2F;非线性数据结构和排序都是为了最终的查找服务的。</p>
<p><strong>排序方法的稳定与否是针对相同的关键字而言的。若相同的关键字在排序后次序无变化，则其是稳定的。</strong></p>
<p><strong>分类：</strong></p>
<ul>
<li>内部排序：数据量较小，所有的数据一次性全部放入<strong>内存</strong>进行。<ul>
<li><strong>插入排序（稳定排序）</strong></li>
<li><strong>交换排序</strong></li>
<li><strong>选择排序</strong></li>
<li><strong>归并排序</strong></li>
<li><strong>基数排序</strong></li>
</ul>
</li>
<li>外部排序：数据量过大，一部分数据在<strong>内存</strong>中先进行排序，其余的数据暂存在磁盘中。</li>
</ul>
<p><strong>基本方法：</strong></p>
<ul>
<li>比较两个关键字的大小；</li>
<li>将记录从一个位置移动至另一个位置。</li>
</ul>
<h2 id="9-2-插入排序"><a href="#9-2-插入排序" class="headerlink" title="9.2 插入排序"></a>9.2 插入排序</h2><p>插入排序（稳定排序）</p>
<h3 id="1、直接插入排序"><a href="#1、直接插入排序" class="headerlink" title="1、直接插入排序"></a>1、直接插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接插入排序 O(n^2)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T *a, T*b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void InsertSort(SqList &amp;L, int n)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    for(int i=1; i&lt;n; ++i)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(L[i] &lt; L[i-1])</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            Swap(&amp;L[i], &amp;L[i-1]);</span></span><br><span class="line"><span class="comment">            for(int j=i-1; j&gt;0 &amp;&amp; L[j]&lt;L[j-1]; --j)  // important</span></span><br><span class="line"><span class="comment">                Swap(&amp;L[j], &amp;L[j-1]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 改进</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] &lt; L[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            L[<span class="number">0</span>] = L[i];</span><br><span class="line">            L[i] = L[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> j = i<span class="number">-2</span>;            </span><br><span class="line">            <span class="keyword">while</span>(L[<span class="number">0</span>]&lt;L[j])</span><br><span class="line">            &#123;</span><br><span class="line">                L[j+<span class="number">1</span>] = L[j];</span><br><span class="line">                --j;</span><br><span class="line">            &#125;            </span><br><span class="line">            L[j+<span class="number">1</span>] = L[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、折半插入排序"><a href="#2、折半插入排序" class="headerlink" title="2、折半插入排序"></a>2、折半插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 折半插入排序 O(n^2)  -- 减少直接插入排序的关键字比较次数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BInsertSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        L[<span class="number">0</span>] = L[i];</span><br><span class="line">        <span class="type">int</span> low = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> high = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)  <span class="comment">// 折半插入，通过移动low/high找到该插入的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(L[<span class="number">0</span>] &gt;= L[mid])</span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&gt;high+<span class="number">1</span>; --j)  <span class="comment">// high+1是要插入L[0]的数值的位置，因此把high+1到i的值全部往后挪动一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            L[j] = L[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        L[high+<span class="number">1</span>] = L[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、2路插入排序"><a href="#3、2路插入排序" class="headerlink" title="3、2路插入排序"></a>3、2路插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2路插入排序  -- 减少折半插入排序的数据移动次数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TWayInsertSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList tmp;</span><br><span class="line">    tmp[<span class="number">0</span>] = L[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> head, tail;</span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; ++i)  <span class="comment">// L[i]是当前要插入tmp的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] &lt; tmp[head])  <span class="comment">// 若当前遍历到的L[i]小于head所指元素，则将L[i]插入到head的前一个位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = (head<span class="number">-1</span>+n) % n;  <span class="comment">// 取模操作实现循环操作</span></span><br><span class="line">            tmp[head] = L[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L[i] &gt; tmp[tail])  <span class="comment">// 同理，若当前遍历到的L[i]大于head所指元素，则将L[i]插入到head的后一个位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            tail++;</span><br><span class="line">            tmp[tail] = L[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 若tmp[head]&lt;L[i]&lt;tmp[tail]，则需要移动数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            tail++;</span><br><span class="line">            tmp[tail] = tmp[tail<span class="number">-1</span>];  <span class="comment">// 将tmp[tail]向后移动一个，并将tail本身的值加1</span></span><br><span class="line">            <span class="type">int</span> j = tail<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(L[i] &lt; tmp[(j<span class="number">-1</span>+n)%n])  <span class="comment">// L[i]&lt;tmp[(j-1+n)%n]，找到L[i]应该插入的地方，即tmp[j]</span></span><br><span class="line">                                          <span class="comment">// 由于这里的j的指向是循环的，所以(j-1+n)%n相当于j-1</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp[j] = tmp[(j<span class="number">-1</span>+n)%n];</span><br><span class="line">                j = (j<span class="number">-1</span>+n)%n;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp[j] = L[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        L[i] = tmp[head];</span><br><span class="line">        head = (head+<span class="number">1</span>)%n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、表插入排序"><a href="#4、表插入排序" class="headerlink" title="4、表插入排序"></a>4、表插入排序</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401241536655.png" alt="image-20240124153639775" style="zoom: 25%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表插入排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVALUE 0x7fffffff</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SLNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">    <span class="type">int</span> link;</span><br><span class="line">&#125;SLNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> SLNode Table[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableInsertSort</span><span class="params">(Table t, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[<span class="number">0</span>].link = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p, q;  <span class="comment">// q是p的前驱</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = t[<span class="number">0</span>].link;  <span class="comment">// p指向当前检索的值的下标，每一次都要从t[0].link指向的头开始排序</span></span><br><span class="line">        q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">0</span> &amp;&amp; t[p].data&lt;=t[i].data)  <span class="comment">// p!=0说明未检索完；t[p].data&lt;=t[i].data说明当前检索到的值小于等于要排序进来的值，所以要接着往下找更大的值</span></span><br><span class="line">        &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = t[p].link;  <span class="comment">// p指向下一个更大的值对应的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当退出循环时，t[p].data&gt;t[i].data，则i在p的前驱位置插入</span></span><br><span class="line">        t[i].link = t[q].link;</span><br><span class="line">        t[q].link = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、希尔排序"><a href="#5、希尔排序" class="headerlink" title="5、希尔排序"></a>5、希尔排序</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401251321618.png" alt="image-20240125132057065"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> n, <span class="type">int</span> dk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=dk+<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] &lt; L[i-dk])  <span class="comment">// 间隔两端的两个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            L[<span class="number">0</span>] = L[i];</span><br><span class="line">            <span class="type">int</span> j = i - dk;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; L[<span class="number">0</span>] &lt; L[j])</span><br><span class="line">            &#123;</span><br><span class="line">                L[j+dk] = L[j];  <span class="comment">// 在间隔上取的几个数之间进行直接插入排序，需要注意这里数之间的间隔是dk</span></span><br><span class="line">                j -= dk;</span><br><span class="line">            &#125;</span><br><span class="line">            L[j+dk] = L[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n, <span class="type">int</span> dlta[], <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;t; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShellInsert</span>(L, n, dlta[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-3-交换排序"><a href="#9-3-交换排序" class="headerlink" title="9.3 交换排序"></a>9.3 交换排序</h2><h3 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n<span class="number">-1</span>-i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L[j] &gt; L[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Swap</span>(&amp;L[j], &amp;L[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、快速排序"><a href="#2、快速排序" class="headerlink" title="2、快速排序"></a>2、快速排序</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401251320399.png" alt="image-20240125132023301" style="zoom: 25%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T pk = L[low];  <span class="comment">// 先指定L[low]为关键字</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; L[high]&gt;=pk)  <span class="comment">// 循环使得high指向小于枢轴的值</span></span><br><span class="line">            high--;</span><br><span class="line">        L[low] = L[high];  <span class="comment">// 将这个较小的L[high]值赋值给low所处的位置</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; L[low]&lt;pk)  <span class="comment">// 循环使得low指向大于枢轴的值</span></span><br><span class="line">            low++;</span><br><span class="line">        L[high] = L[low];  <span class="comment">// 将这个较大的L[low]值赋值给high所处的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    L[low] = pk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)  <span class="comment">// 未排序完成</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pkloc = <span class="built_in">Partition</span>(L, low, high);  <span class="comment">// 求枢轴关键字的位置</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(L, low, pkloc<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(L, pkloc+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-4-选择排序"><a href="#9-4-选择排序" class="headerlink" title="9.4 选择排序"></a>9.4 选择排序</h2><h3 id="1、简单选择排序"><a href="#1、简单选择排序" class="headerlink" title="1、简单选择排序"></a>1、简单选择排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SelectMinKey</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T minval = L[i];</span><br><span class="line">    <span class="type">int</span> pos = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m=i+<span class="number">1</span>; m&lt;n; ++m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[m] &lt; minval)</span><br><span class="line">        &#123;</span><br><span class="line">            minval = L[m];</span><br><span class="line">            pos = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="built_in">SelectMinKey</span>(L, i, n);  <span class="comment">// 找到最小值对应的下标位置</span></span><br><span class="line">        <span class="keyword">if</span>(j != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Swap</span>(&amp;L[j], &amp;L[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、树形选择排序"><a href="#2、树形选择排序" class="headerlink" title="2、树形选择排序"></a>2、树形选择排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 树形选择排序，相较于简单选择排序减少了比较次数（锦标赛排序）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVALUE 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">GetValue</span><span class="params">(T e[], <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p &gt;= n)</span><br><span class="line">        <span class="keyword">return</span> MAXVALUE;</span><br><span class="line">    </span><br><span class="line">    T value;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; n/<span class="number">2</span>)  <span class="comment">// 得到的是下标位置</span></span><br><span class="line">        value = e[e[p]];</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 否则为叶子节点，直接返回e[p]</span></span><br><span class="line">        value = e[p];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Play</span><span class="params">(T e[], <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> left, right;  <span class="comment">// 左右下标</span></span><br><span class="line">    T lval, rval;  <span class="comment">// 左右值</span></span><br><span class="line">    <span class="keyword">while</span>(p &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        left = <span class="number">2</span>*p+<span class="number">1</span>;</span><br><span class="line">        right = <span class="number">2</span>*p+<span class="number">2</span>;</span><br><span class="line">        lval = <span class="built_in">GetValue</span>(e, n, left);</span><br><span class="line">        rval = <span class="built_in">GetValue</span>(e, n, right);</span><br><span class="line">        <span class="keyword">if</span>(lval &lt;= rval)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &lt; n/<span class="number">2</span>)</span><br><span class="line">                e[p] = e[left];  <span class="comment">// important</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[p] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(right &lt; n/<span class="number">2</span>)</span><br><span class="line">                e[p] = e[right];  <span class="comment">// important</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[p] = right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        --p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select</span><span class="params">(T e[], <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = p;  <span class="comment">// 父节点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">2</span>*p+<span class="number">1</span>;  <span class="comment">// 左子树</span></span><br><span class="line">    T lval, rval;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; flag)</span><br><span class="line">    &#123;</span><br><span class="line">        lval = <span class="built_in">GetValue</span>(e, n, j);</span><br><span class="line">        rval = <span class="built_in">GetValue</span>(e, n, j+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(lval &lt;= rval)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; n/<span class="number">2</span>)</span><br><span class="line">                e[i] = e[j];  <span class="comment">// j&lt;n/2说明j的位置在非叶子节点的位置，所以对于j的父节点，需要的是位置j上存储的内容即e[j]</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[i] = j;  <span class="comment">// j&gt;=n/2说明j的位置在叶子节点的位置，所以对于j的父节点，需要的是就是位置j本身</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((j+<span class="number">1</span>) &lt; n/<span class="number">2</span>)</span><br><span class="line">                e[i] = e[j+<span class="number">1</span>];  <span class="comment">// 同上</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[i] = j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            flag--;</span><br><span class="line">        <span class="comment">// 向上递归，找到新的父节点和对应的左孩子</span></span><br><span class="line">        i = (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        j = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TreeSelectSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">    T *e = (T*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T) * size);</span><br><span class="line">    <span class="built_in">assert</span>(e != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = size / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        e[k++] = L[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> curpos = size/<span class="number">2</span><span class="number">-1</span>;  <span class="comment">// 树最后一个叶子分支的父节点，相当于要打的第一场比赛</span></span><br><span class="line">    <span class="built_in">Play</span>(e, size, curpos);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    L[i] = e[e[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将已经选出来的最小值的节点A，将其赋值为最大值，使其不参与后续的比较</span></span><br><span class="line">    e[e[<span class="number">0</span>]] = MAXVALUE;  </span><br><span class="line">    <span class="comment">// 从A的父节点开始一路向上比较，直到到达根节点，比较完毕</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        curpos = (e[<span class="number">0</span>]<span class="number">-1</span>)/<span class="number">2</span>;  <span class="comment">// A的父节点</span></span><br><span class="line">        <span class="built_in">Select</span>(e, size, curpos);</span><br><span class="line">        L[i] = e[e[<span class="number">0</span>]];</span><br><span class="line">        e[e[<span class="number">0</span>]] = MAXVALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(e);</span><br><span class="line">    e = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、堆排序"><a href="#3、堆排序" class="headerlink" title="3、堆排序"></a>3、堆排序</h3><p><strong>大堆</strong>：父节点大于左右孩子；</p>
<p><strong>小堆</strong>：父节点小于左右孩子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆排序，相较于树形选择排序辅助空间大幅减少，只需要1个辅助空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(T heap[], <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = p;  <span class="comment">// 父节点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">2</span>*i+<span class="number">1</span>;  <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; n)  <span class="comment">// 说明p有左孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;n<span class="number">-1</span> &amp;&amp; heap[j]&gt;heap[j+<span class="number">1</span>])  <span class="comment">// j&lt;n-1说明有右孩子，heap[j]&gt;heap[j+1]说明左孩子大于右孩子</span></span><br><span class="line">            j++;  <span class="comment">// j指向右孩子，也即是保证j指向左右孩子中较小的那个值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(heap[i] &lt;= heap[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Swap</span>(&amp;heap[i], &amp;heap[j]);</span><br><span class="line">            <span class="comment">// 继续递归，使得该函数从位置p一直遍历到叶子结点</span></span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T <span class="title">RemoveMinKey</span><span class="params">(T heap[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T key = heap[<span class="number">0</span>];</span><br><span class="line">    heap[<span class="number">0</span>] = heap[n];</span><br><span class="line">    <span class="built_in">siftDown</span>(heap, n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T *heap = (T*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T) * n);</span><br><span class="line">    <span class="built_in">assert</span>(heap != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        heap[i] = L[i];  <span class="comment">// 将原始数据拷贝到heap空间中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将heap调整为小堆</span></span><br><span class="line">    <span class="comment">// 1、找到最后一个分支节点，调用函数SiftDown后，目前的堆顶元素即为当前序列的最小值</span></span><br><span class="line">    <span class="type">int</span> curpos = n/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(curpos &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">siftDown</span>(heap, n, curpos);</span><br><span class="line">        curpos--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、取走堆顶元素后，依次用最后一个节点补上根节点（最小值），重新进行小堆排序并取堆顶元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        L[i] = <span class="built_in">RemoveMinKey</span>(heap, n-i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-5-归并排序"><a href="#9-5-归并排序" class="headerlink" title="9.5 归并排序"></a>9.5 归并排序</h2><p><strong>2-路归并排序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(SqList &amp;L, SqList &amp;TP, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left; i&lt;=right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        TP[i] = L[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s1 = left;</span><br><span class="line">    <span class="type">int</span> s2 = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = left;</span><br><span class="line">    <span class="keyword">while</span>(s1&lt;=mid &amp;&amp; s2&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(TP[s1] &lt;= TP[s2])</span><br><span class="line">            L[k++] = TP[s1++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L[k++] = TP[s2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s1 &lt;= mid)</span><br><span class="line">        L[k++] = TP[s1++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(s2&lt;=right)</span><br><span class="line">        L[k++] = TP[s2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(SqList &amp;L, SqList &amp;TP, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(L, TP, left, mid);</span><br><span class="line">    <span class="built_in">MergeSort</span>(L, TP, mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="built_in">Merge</span>(L, TP, left, mid, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-6-基数排序"><a href="#9-6-基数排序" class="headerlink" title="9.6 基数排序"></a>9.6 基数排序</h2><p>对数据的<strong>分配和收集</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401262157878.png" alt="image-20240126215723896"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基数排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getkey</span><span class="params">(T value, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">while</span>(k &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        key = value % <span class="number">10</span>;</span><br><span class="line">        value /= <span class="number">10</span>;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Distribute</span><span class="params">(SqList &amp;L, <span class="type">int</span> n, List (&amp;lt)[<span class="number">10</span>], <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>(&amp;lt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        key = <span class="built_in">getkey</span>(L[i], k);  <span class="comment">// 取得需要比对的位置上的值</span></span><br><span class="line">        <span class="built_in">push_back</span>(&amp;lt[key], L[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Collect</span><span class="params">(SqList &amp;L, List (&amp;lt)[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Node *p = lt[i].first-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L[k++] = p-&gt;data;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List list[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InitList</span>(&amp;list[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Distribute</span>(L, n, list, i);</span><br><span class="line">        <span class="built_in">Collect</span>(L, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Computer</category>
        <category>DataStruct</category>
      </categories>
  </entry>
  <entry>
    <title>时间&amp;空间复杂度</title>
    <url>/2024/06/11/%E9%9D%A2%E8%AF%95/DataStruct/%E6%97%B6%E9%97%B4&amp;%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<p>[toc]</p>
<span id="more"></span>

<h1 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h1><h2 id="1、时间复杂度"><a href="#1、时间复杂度" class="headerlink" title="1、时间复杂度"></a>1、时间复杂度</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;     <span class="comment">// for循环语句执行 n+1 次</span></span><br><span class="line">  x++;                         <span class="comment">// x++;语句执行 n 次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段代码，总执行次数是<code>2n+1</code>，因此取其最大阶，其时间复杂度就是<code>O(n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;   <span class="comment">// 该for循环语句执行 n*(n+1) 次</span></span><br><span class="line">    x++;                       <span class="comment">// 该x++;语句执行 n*n 次</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段代码，总执行次数是<code>n+1+n*(n+1)+n*n</code>，因此取其最大阶，其时间复杂度就是<code>O(n^2)</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=i; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>; k&lt;=j; k++) &#123;</span><br><span class="line">            x++;                     <span class="comment">// 该x++;语句执行 A 次（见下方注释）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段代码，取其最大阶，其时间复杂度就是<code>O(n^3)</code>。</p>
<blockquote>
<p>A</p>
<p>对于这三个<code>for</code>循环语句，从下往上分析：</p>
<ul>
<li><pre><code class="c++">
</code></pre>
</li>
</ul>
<p> for (int k&#x3D;1; k&lt;&#x3D;j; k++) {<br>     x++;<br>  }<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> 执行`j`次；</span><br><span class="line"></span><br><span class="line">&gt;+ ```c++</span><br><span class="line"> for (int j=1; j&lt;=i; j++) &#123; </span><br><span class="line">     for (int k=1; k&lt;=j; k++) &#123; </span><br><span class="line">         x++; </span><br><span class="line">     &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p> 执行<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111459800.png" alt="image-20240611145906766" style="zoom:67%;" />次；</p>
<ul>
<li><pre><code class="c++">
</code></pre>
</li>
</ul>
<p> for (int i&#x3D;1; i&lt;&#x3D;n; i++) {<br>     for (int j&#x3D;1; j&lt;&#x3D;i; j++) {<br>         for (int k&#x3D;1; k&lt;&#x3D;j; k++) {<br>             x++;<br>         }<br>     }<br>  }</p>
<p>执行<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111500830.png" alt="image-20240611150038794" style="zoom: 67%;" />次。</p>
<p>综上所述，<code>x++;</code>语句执行的次数如下所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111457129.png" alt="image-20240611145732091" style="zoom:67%;" />
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i=i*<span class="number">2</span>) &#123;</span><br><span class="line">    x++;                         <span class="comment">// 该x++;语句执行 B 次（见下方注释）</span></span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段代码，取其最大阶，其时间复杂度就是<code>O(log2n)</code>。</p>
<blockquote>
<p>B</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111455603.png" alt="image-20240611145554310" style="zoom: 67%;" />

<p>所以，对于<code>for</code>循环语句来说，其执行了<code>k+1</code>次；但对于<code>x++;</code>语句来说，只执行了<code>k</code>次。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111527560.png" alt="image-20240611152735504" style="zoom:67%;" />
</blockquote>
<h2 id="2、空间复杂度"><a href="#2、空间复杂度" class="headerlink" title="2、空间复杂度"></a>2、空间复杂度</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111529670.png" alt="image-20240611152906551"></p>
<h1 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h1><h2 id="1、二分查找"><a href="#1、二分查找" class="headerlink" title="1、二分查找"></a>1、二分查找</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）时间复杂度</p>
<p><code>int left = 0, right = nums.size() - 1;</code>的时间复杂度为<code>O(1)</code>。</p>
<p>接下来看<code>while (left &lt;= right)</code>这个while循环最多会执行几次。</p>
<p>由于<code>int mid = left + (right - left) / 2;</code>，因此每一次会将搜索空间（<code>S</code>）折半，如下所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111544858.png" alt="image-20240611154411802" style="zoom: 80%;" />

<p>（2）空间复杂度</p>
<p>空间复杂度主要看算法使用的额外空间量（不包括输入数据本身）。</p>
<ol>
<li><strong>变量声明</strong>：<ul>
<li><code>int left</code>, <code>int right</code>, <code>int mid</code> 都是常数空间<code>O(1)</code>。</li>
</ul>
</li>
<li><strong>没有递归或额外的数据结构</strong>：<ul>
<li>算法不需要额外的数组、栈或队列等辅助数据结构。</li>
</ul>
</li>
</ol>
<p>综上，整个算法的空间复杂度是 <code>O(1)</code>。</p>
<h2 id="2、滑动窗口"><a href="#2、滑动窗口" class="headerlink" title="2、滑动窗口"></a>2、滑动窗口</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        sum += nums[r++];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if (sum &gt;= target) &#123;</span></span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, r - l);</span><br><span class="line">            sum -= nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<blockquote>
<p>注意此处的时间复杂度不是O(n^2)！分析如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (r &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    sum += nums[r++]; <span class="comment">// 这个操作会执行 n 次</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">        res = <span class="built_in">min</span>(res, r - l);</span><br><span class="line">        sum -= nums[l++]; <span class="comment">// 最坏情况下，内层 while 循环会执行 n 次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然嵌套了两层循环，但是由于整个过程中，<code>nums</code>中的每个元素最多会被<code>l</code>和<code>r</code>各访问一次，也即被操作两次，因此时间复杂度是<code>2n</code>，也即<code>O(n)</code>。</p>
]]></content>
      <categories>
        <category>Computer</category>
        <category>DataStruct</category>
      </categories>
  </entry>
  <entry>
    <title>洛谷刷题</title>
    <url>/2024/03/15/%E9%9D%A2%E8%AF%95/DataStruct/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="1-基础算法"><a href="#1-基础算法" class="headerlink" title="1 基础算法"></a>1 基础算法</h1><h2 id="1-1-枚举"><a href="#1-1-枚举" class="headerlink" title="1.1 枚举"></a>1.1 枚举</h2><h3 id="1-1-1-循环枚举"><a href="#1-1-1-循环枚举" class="headerlink" title="1.1.1 循环枚举"></a>1.1.1 循环枚举</h3><h4 id="P2241-统计方形"><a href="#P2241-统计方形" class="headerlink" title="P2241 统计方形"></a>P2241 统计方形</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> sq_cnt = <span class="number">0</span>, rec_cnt = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">      <span class="type">int</span> temp = std::<span class="built_in">min</span>(n-i, m-j);  <span class="comment">// important</span></span><br><span class="line">      sq_cnt += temp;</span><br><span class="line">      rec_cnt += (n-i)*(m-j) - temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  std::cout &lt;&lt; sq_cnt &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; rec_cnt &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--more-->

<h4 id="P2089-烤鸡"><a href="#P2089-烤鸡" class="headerlink" title="P2089 烤鸡"></a>P2089 烤鸡</h4><h4 id="P1618-三连击"><a href="#P1618-三连击" class="headerlink" title="P1618 三连击"></a>P1618 三连击</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> standard[] = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量数组法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> a, b, c, flag=<span class="number">1</span>;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">329</span>; i++) &#123;\</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d%d%d&quot;</span>, a*i, b*i, c*i);</span><br><span class="line">    <span class="built_in">sort</span>(buf, buf+<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(standard, buf) == <span class="number">0</span>) &#123;</span><br><span class="line">      flag = <span class="number">0</span>;</span><br><span class="line">      cout &lt;&lt; a*i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b*i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c*i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题的解题用到了常量数组法。一开始我想着正推，但是没有头绪。看了题解之后我才发现可以反着从比例开始推。先遍历所有满足<code>A:B:C</code>的三位数的情况，然后将这三个三位数，共9个数看成一个整体的<code>buf</code>数组，和<code>123456789</code>对比是否一致。</p>
<h4 id="P3392-涂国旗"><a href="#P3392-涂国旗" class="headerlink" title="P3392 涂国旗"></a>P3392 涂国旗</h4><p>思想实际很简单，注意两个调试中发现的错误点：</p>
<p>1、输入格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">WRWRW</span><br><span class="line">BWRWB</span><br><span class="line">WRWRW</span><br><span class="line">RWBWR</span><br></pre></td></tr></table></figure>

<p>因此对应的代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    string row;</span><br><span class="line">    cin &gt;&gt; row; <span class="comment">// 读取一行数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字符串转换为字符数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        a[i][j] = row[j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误！</span></span><br><span class="line"><span class="comment">// 这种方法会尝试直接读取整个输入流，也就是说一次读取n*m个数据，而不是逐行逐个读取</span></span><br><span class="line"><span class="comment">// for (int i=0; i&lt;n; i++) &#123;</span></span><br><span class="line"><span class="comment">//     for (int j=0; j&lt;m; ++j) &#123;</span></span><br><span class="line"><span class="comment">//         cin &gt;&gt; a[i][j];</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>2、在统计每一行转换为<code>w\b\r</code>需要的个数时，因为<code>wc\bc\rc</code>定义为全局变量，因此要记得及时清零；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">int</span> wc = <span class="number">0</span>, bc = <span class="number">0</span>, rc = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 预处理：每一行转换成w\b\r的需转换的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; ++j) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (a[i][j]) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">            wc++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            bc++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">            rc++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      cnt[i][<span class="number">0</span>] = m-wc;</span><br><span class="line">      cnt[i][<span class="number">1</span>] = m-bc;</span><br><span class="line">      cnt[i][<span class="number">2</span>] = m-rc;</span><br><span class="line"></span><br><span class="line">      wc = bc = rc= <span class="number">0</span>;  <span class="comment">// important!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    ...       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="P3654-First-Step"><a href="#P3654-First-Step" class="headerlink" title="P3654 First Step"></a>P3654 First Step</h4><p>由于这个题算的是<code>1×K</code>的排列方式，因此遗漏掉的一点是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.###.</span><br><span class="line">##.#.</span><br><span class="line">..#..</span><br><span class="line">#..#.</span><br><span class="line">#.###</span><br></pre></td></tr></table></figure>

<p>针对上述的情况，<code>K=1</code>是横着排和竖着排是一样的，因此属于特例，结果要除<code>2</code>。</p>
<h3 id="1-1-2-子集枚举"><a href="#1-1-2-子集枚举" class="headerlink" title="1.1.2 子集枚举"></a>1.1.2 子集枚举</h3><h4 id="P1036-选数"><a href="#P1036-选数" class="headerlink" title="P1036 选数"></a>P1036 选数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> x[<span class="number">25</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为素数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i*i&lt;=num; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归遍历查询</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> sum, <span class="type">int</span> startx)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// m      当前选择了多少个数</span></span><br><span class="line">  <span class="comment">// sum    当前和</span></span><br><span class="line">  <span class="comment">// startx 升序排列</span></span><br><span class="line">  <span class="keyword">if</span> (m == k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_prime</span>(sum)) &#123;</span><br><span class="line">      ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=startx; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(m+<span class="number">1</span>, sum+x[i], i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; x[i];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="P1157-组合的输出※"><a href="#P1157-组合的输出※" class="headerlink" title="P1157 组合的输出※"></a>P1157 组合的输出※</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, r;</span><br><span class="line"><span class="type">int</span> a[<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// m ==&gt; 为当前选择的数</span></span><br><span class="line">  <span class="comment">// 已经选了足够的数</span></span><br><span class="line">  <span class="keyword">if</span> (m &gt; r) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=r; i++) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 未选够，继续遍历</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=a[m<span class="number">-1</span>]+<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="comment">// i=a[m-1]+1指i从上一个选取的整数a[m-1]的下一个数开始</span></span><br><span class="line">    a[m] = i; <span class="comment">// 把上一行提到的那个数赋给当前a[k]</span></span><br><span class="line">    <span class="built_in">dfs</span>(m+<span class="number">1</span>); <span class="comment">// 递归调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; r;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-1-3-排列枚举"><a href="#1-1-3-排列枚举" class="headerlink" title="1.1.3 排列枚举"></a>1.1.3 排列枚举</h3><h4 id="P1706-全排列"><a href="#P1706-全排列" class="headerlink" title="P1706 全排列"></a>P1706 全排列</h4><p>1、直接用<code>c++</code>的<code>next_permutation</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    a[i] = i+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">sort</span>(a, a+n);</span><br><span class="line">  <span class="comment">// sort(a, a+n, greater&lt;&gt;());  -- prev_permutation(a, a+n)</span></span><br><span class="line">  <span class="comment">// greater&lt;int&gt;() 是一个函数对象，用于比较两个同类型的值</span></span><br><span class="line">  <span class="comment">// 第一个参数比第二个参数大时返回true</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(a, a+n));</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、深度搜索：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, pos=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>], b[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深搜函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;  <span class="comment">// 用i遍历所有可能的n种可能（因为这道题遍历的对象即为自然数，因此也就是i本身）</span></span><br><span class="line">    <span class="keyword">if</span> (!b[i]) &#123;  <span class="comment">// 当前b[i]为未使用状态</span></span><br><span class="line">      b[i] = <span class="number">1</span>;  <span class="comment">// 则首先将b[i]设置为使用状态</span></span><br><span class="line">      a[pos] = i;  <span class="comment">// 存储当前i值，</span></span><br><span class="line">      pos++;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (k == n) &#123;</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">search</span>(k+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      pos--;  <span class="comment">// 执行到这一步说明已经打印完了一组数据，因此进行回溯</span></span><br><span class="line">      b[i] = <span class="number">0</span>;  <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">search</span>(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="P1088-火星人"><a href="#P1088-火星人" class="headerlink" title="P1088 火星人"></a>P1088 火星人</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;  <span class="comment">// 火星人手指数</span></span><br><span class="line"><span class="type">int</span> m;  <span class="comment">// 要加上的数B</span></span><br><span class="line"><span class="type">int</span> k[<span class="number">10005</span>];  <span class="comment">// 加数A</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">    cout &lt;&lt; k[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  cin &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; k[i];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; ++i) &#123;</span><br><span class="line">    <span class="built_in">next_permutation</span>(k, k+n);</span><br><span class="line">    <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">      <span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-贪心"><a href="#1-2-贪心" class="headerlink" title="1.2 贪心"></a>1.2 贪心</h2><p>贪心算法中常见的定义<code>结构体</code>并排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Oj</span>&#123;</span><br><span class="line">    <span class="type">int</span> begin;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">&#125;a[<span class="number">1001000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Oj o1, Oj o2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> o1.end &lt;= o2.end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">sort</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>, cmp);  <span class="comment">// 按结束时间对所有oj排序</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-1-线段覆盖"><a href="#1-2-1-线段覆盖" class="headerlink" title="1.2.1 线段覆盖"></a>1.2.1 线段覆盖</h3><blockquote>
<p>通用问题表述：</p>
<p>在一个数轴上有<code>n</code>条线段，现要选取其中<code>k</code>条选段使得这<code>k</code>条线段两两没有重合部分，问最大的<code>k</code>为多少？</p>
</blockquote>
<p>1、最左边的线段放<code>右端点最靠左的线段</code>；</p>
<p>2、剩下的其他线段<code>按右端点排序</code>，贪心放置线段，即能放就放。</p>
<h2 id="1-3-二分法"><a href="#1-3-二分法" class="headerlink" title="1.3 二分法"></a>1.3 二分法</h2><p><strong>二分题的几个特征：</strong></p>
<p>1、求最大&#x2F;最小值；</p>
<p>2、答案离散（答案有多种可能）；</p>
<p>3、容易判断答案是否正确。</p>
<p><strong>做法：</strong></p>
<p>1、确定答案区间；</p>
<p>2、在保证答案在区间内的前提下,逐步缩小区间；</p>
<p>3、当区间缩小到仅包含一个可能解时，该可能解即为答案。</p>
<p><strong>易错点：</strong></p>
<p>1、取边界条件时是选择<code>while(left&lt;right)</code>还是<code>while(left&lt;=right)</code>？</p>
<p>2、当中间值大于（或小于）所需查找的目标时，下一步要迭代更新的<code>right</code>（或<code>left</code>）应该取<code>middle</code>还是<code>middle-1</code>？</p>
<p><strong>解答：</strong></p>
<p>对上述边界条件的选取要参考解法选择“<strong>左闭右闭</strong>”的区间还是“<strong>左闭右开</strong>”的区间。</p>
<ul>
<li><p><strong>左闭右闭</strong>：（在做题时首选这种方法！）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">left = <span class="number">0</span>;</span><br><span class="line">right = nums.size<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">right = middle<span class="number">-1</span>; &amp;&amp; left = middle+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>左闭右开：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">left = <span class="number">0</span>;</span><br><span class="line">right = nums.size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">right = middle; &amp;&amp; left = midlle+<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="P2249-查找"><a href="#P2249-查找" class="headerlink" title="P2249 查找"></a>P2249 查找</h3><p>这道题有一个要掌握的知识点：</p>
<p>在<code>1 3 3 3 5 7 9 11 13 15 15</code>中如何找到第一个<code>3</code>出现的位置：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> right = n;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] == target) &#123;</span><br><span class="line">      res = mid;</span><br><span class="line">      right = mid - <span class="number">1</span>;  <span class="comment">// 这两步是为了找到第一个出现a[mid]的位置</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P1102-A-B数对"><a href="#P1102-A-B数对" class="headerlink" title="P1102 A-B数对"></a>P1102 A-B数对</h3><p>本题需要求解满足<code>A-B=C</code>的数对的个数。由于题中告知了<strong>不同位置但数字一样的数对算不同的数对</strong>，因此求解思路如下：</p>
<p>1、<code>A-B=C</code>即<code>A-C=B</code>；首先建立<code>map</code>映射，统计<code>A</code>取不同值的个数；</p>
<p>2、将所有的<code>A</code>减去<code>C</code>，这个时候得到<code>B</code>，再统计此时<code>map</code>中以<code>B</code>的值为键的个数，即为所求答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, c;</span><br><span class="line"><span class="comment">// int res;</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res;</span><br><span class="line"><span class="type">int</span> a[<span class="number">200001</span>];  <span class="comment">// n个正整数</span></span><br><span class="line">map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; boo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">    boo[a[i]]++;</span><br><span class="line">    a[i]-=c;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">    res += boo[a[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个易错点在第<code>6</code>行，由于</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403211101376.png" alt="image-20240321110105721" style="zoom: 67%;" />

<p>因此<code>res</code>应该定义为<code>long long</code>，而非<code>int</code>。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>long long</td>
<td>-2^63 ~ 2^63-1</td>
</tr>
<tr>
<td>int</td>
<td>-2^31 ~ 2^31-1</td>
</tr>
</tbody></table>
<h3 id="P1873-砍树"><a href="#P1873-砍树" class="headerlink" title="P1873 砍树"></a>P1873 砍树</h3><p>这道题的“二分”思想体现如下：</p>
<p>对于给出的N棵树的高度：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 7</span><br><span class="line">20 15 10 17</span><br></pre></td></tr></table></figure>

<p>假设锯片高度为14:，此时可得到的木材长度（总和<code>s</code>）为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 1 0 3  ==&gt;  s=10</span><br></pre></td></tr></table></figure>

<p>得到的木材多于需要的木材，因此说明<strong>得到的“答案区间大了”，需要对其进行缩小</strong>。（这就可以类比到二分的思想上）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, m, a[<span class="number">1000001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">get</span><span class="params">(<span class="type">long</span> <span class="type">long</span> h)</span> </span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">    s += ((a[i]-h) &gt;= <span class="number">0</span> ? (a[i]-h) : <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>;  <span class="comment">// left、right和mid用来衡量锯片长度</span></span><br><span class="line">  <span class="comment">// long long right = 400001;  // 错误，若m恰好为0或所有木块长度都小于m，则不对</span></span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> right = *<span class="built_in">max_element</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// long long s = 0;</span></span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> s = <span class="number">-1</span>;  <span class="comment">// 初始化为一个无效的值</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// ------------------- 错误 ------------------------- //</span></span><br><span class="line">    <span class="comment">// if (get(mid) == m) &#123;</span></span><br><span class="line">    <span class="comment">//   // 如果恰好找到一个mid使得get(mid)==m，并不一定就是正确的解</span></span><br><span class="line">    <span class="comment">//   // 因为题目要求的是最大的s，而不是等于m的s</span></span><br><span class="line">    <span class="comment">//   s = mid;</span></span><br><span class="line">    <span class="comment">//   break;</span></span><br><span class="line">    <span class="comment">// &#125; else if (get(mid) &gt; m) &#123;</span></span><br><span class="line">    <span class="comment">//   // 当前获得的木材长度太大，需要增大锯片长度</span></span><br><span class="line">    <span class="comment">//   left = mid + 1;</span></span><br><span class="line">    <span class="comment">// &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//   // 当前获得的木材长度太大，需要减小锯片长度</span></span><br><span class="line">    <span class="comment">//   right = mid - 1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//   // 同时，没有处理找不到合适的解的情况</span></span><br><span class="line">    <span class="comment">// ------------------- 错误 ------------------------- //</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get</span>(mid) &gt;= m) &#123;  <span class="comment">// 修正条件，使得可以找到最大的s</span></span><br><span class="line">      s = mid;</span><br><span class="line">      left = mid + <span class="number">1</span>;  <span class="comment">// 向右搜索，寻找更大的锯片高度，使得得到的木材总长度减小</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>;  <span class="comment">// 向左搜索，寻找更小的锯片高度，使得得到的木材总长度增大</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P1024-一元三次方程求解"><a href="#P1024-一元三次方程求解" class="headerlink" title="P1024 一元三次方程求解"></a>P1024 一元三次方程求解</h3><p>首先分析这道题：由于这道题的答案区间很大，因此可以考虑采用二分法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l/r/m	x取值</span><br><span class="line">a[m]	f(x)的值</span><br><span class="line">target	方程的根</span><br></pre></td></tr></table></figure>

<p>但本题的特殊之处在于，不能把<code>l</code>和<code>r</code>想当然地认为是<code>-100</code>和<code>100</code>。这是因为本题需要求解出<code>3个实根</code>。根据题中给出的提示：<strong>根与根之差的绝对值 ≥1</strong>，可以得知<strong>每个长度为<code>1</code>的区间内部至多有<code>1</code>个实根</strong>。明确这一点之后，就可以依次遍历每个长度为<code>1</code>的区间，进行二分查找了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> a, b, c, d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a*x*x*x+b*x*x+c*x+d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">  <span class="type">double</span> l, r, m;</span><br><span class="line">  <span class="type">int</span> s = <span class="number">0</span>;  <span class="comment">// 记录找到的根个数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">-100</span>; i&lt;<span class="number">100</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 由于题目说根与根之差的绝对值大于等于1，也即长度为1的区间内至多只存在1个根</span></span><br><span class="line">    <span class="comment">// 因此，所要做的就是在每个长度为1的区间内进行二分查找</span></span><br><span class="line">    l = i;</span><br><span class="line">    r = i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(l) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 说明此时左端点为根，输出</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%.2lf &quot;</span>, l);</span><br><span class="line">      s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(l) * <span class="built_in">f</span>(r) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// f(x1)*f(x2)&lt;0，说明该区间内存在根</span></span><br><span class="line">      <span class="keyword">while</span> (r-l&gt;=<span class="number">0.001</span>) &#123;  <span class="comment">// 二分控制精度</span></span><br><span class="line">        m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">f</span>(m) * <span class="built_in">f</span>(r) &lt;=<span class="number">0</span>) &#123;</span><br><span class="line">          l = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r = m;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%.2lf &quot;</span>, r);</span><br><span class="line">      s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<code>26</code>行不用<code>while(l &lt;= r)</code>是因为：</p>
<p><code>while(r-l&gt;=0.001)</code> 这个条件是用来控制二分法的精度，它的含义是在区间的长度小于等于0.001时停止循环。这里的0.001是一个预先设定的精度值，表示当根的范围缩小到小于等于0.001时，认为已经找到了一个满足要求的根。</p>
<p>使用 <code>while(r-l&gt;=0.001)</code> 的原因是为了控制二分法的迭代次数，从而提高程序的效率和准确性。当根的范围缩小到足够小的时候，再继续迭代寻找根就没有必要了，因为已经达到了所需的精度要求。</p>
<p>而如果使用 <code>while(l&lt;=r)</code> 作为条件，则无法直接控制迭代的精度。在这种情况下，循环会一直进行，直到区间的长度小于等于0时才停止，这可能会导致不必要的迭代次数，影响程序的效率。因此，使用 <code>while(r-l&gt;=0.001)</code> 能够更好地控制迭代的精度，从而提高程序的性能。</p>
<h1 id="2-搜索算法"><a href="#2-搜索算法" class="headerlink" title="2 搜索算法"></a>2 搜索算法</h1><h2 id="2-1-深度搜索DFS"><a href="#2-1-深度搜索DFS" class="headerlink" title="2.1 深度搜索DFS"></a>2.1 深度搜索DFS</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否满足终止搜索条件</span></span><br><span class="line">  <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 进行相应操作</span></span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// 回溯</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历所有可能的情况</span></span><br><span class="line">  <span class="keyword">for</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 标记当前状态，或执行当前操作</span></span><br><span class="line">    <span class="built_in">dfs</span>(...);  <span class="comment">// dfs搜索</span></span><br><span class="line">    <span class="comment">// 回溯状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P1605-迷宫"><a href="#P1605-迷宫" class="headerlink" title="P1605 迷宫"></a>P1605 迷宫</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251029500.png" alt="image-20240325102955228"></p>
]]></content>
      <categories>
        <category>Computer</category>
        <category>DataStruct</category>
      </categories>
  </entry>
  <entry>
    <title>new与operator new</title>
    <url>/2024/04/24/%E9%9D%A2%E8%AF%95/%E9%9B%B6%E6%95%A3/new%E4%B8%8Eoperator%20new/</url>
    <content><![CDATA[<blockquote>
<p><strong>区分三个概念：new operator、operator new和placement new</strong></p>
</blockquote>
<p>[TOC]</p>
<span id="more"></span>

<h1 id="一、new-operator、operator-new和placement-new"><a href="#一、new-operator、operator-new和placement-new" class="headerlink" title="一、new operator、operator new和placement new"></a>一、new operator、operator new和placement new</h1><h2 id="1、new-operator（new-操作符）"><a href="#1、new-operator（new-操作符）" class="headerlink" title="1、new operator（new 操作符）"></a>1、new operator（new 操作符）</h2><p>当写下<code>string *ps = new string(&quot;Memory Management&quot;)</code>时，使用的<code>new</code>是<strong>new操作符</strong>。这个操作符和<code>sizeof</code>一样是语言内置的，它总是完成以下功能：</p>
<ol>
<li>分配内存（调用 operator new 函数）；</li>
<li>调用构造函数初始化内存中的对象。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241419515.png" alt="image-20240424141921292"></p>
<h2 id="2、operator-new"><a href="#2、operator-new" class="headerlink" title="2、operator new"></a>2、operator new</h2><p>new 操作符调用一个函数来完毕必需的内存分配，即 <code>operator new</code>。注意这个函数的职责和<code>malloc</code>一样，只是为了分配内存。</p>
<p>函数 operator new 通常这样声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值类型：<code>void *</code>（返回一个未经处理的<code>raw</code>指针）</li>
<li>参数<code>size_t size</code>：确定分配多少内存。可以添加额外的參数重载函数<code>operator new</code>，但第一个參数类型必须是<code>size_t</code>。</li>
</ul>
<blockquote>
<p>operator new&#x2F;delete 是可以被设定为 &#x3D;delete，当 &#x3D;delete 时候。其不允许被分配。</p>
</blockquote>
<h2 id="3、placement-new"><a href="#3、placement-new" class="headerlink" title="3、placement new"></a>3、placement new</h2><blockquote>
<p><strong>placement new 是一种特殊的 operator new，作用于一块已分配但未处理或未初始化的 raw 内存。</strong></p>
</blockquote>
<p>当存在一些已经被分配单尚未被处理的<code>raw</code>内存时，如果需要再这些内存中构造一个对象，可以使用<strong>一个特殊的operator new</strong> ，它被称为<strong>placement new</strong>。当程序使用共享内存或 memory-mapped I&#x2F;O 时这个函数可能实用，由于在这样程序里对象必须被放置在一个确定地址上或一块被例程分配的内存里。</p>
<p>如下例所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">　<span class="keyword">public</span>:</span><br><span class="line">　　<span class="built_in">Widget</span>(<span class="type">int</span> widgetSize);</span><br><span class="line">　　...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Widget * <span class="title">constructWidgetInBuffer</span><span class="params">(<span class="type">void</span> *buffer,<span class="type">int</span> widgetSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　<span class="keyword">return</span> <span class="built_in">new</span> (buffer) <span class="built_in">Widget</span>(widgetSize);  <span class="comment">// placement new的用法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细来说，<code>new (buffer) Widget(widgetSize)</code>是new操作符的一个使用方法，需要使用一个额外的变量<code>buffer</code>。当new操作符隐含调用operator new函数时，把这个变量传递给它，此时，被调用的operator new函数除了带有强制的参数<code>size_t</code>外，还必须接受<code>void *</code>指针参数，指向构造对象占用的内存空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>, <span class="type">void</span> *location)</span>  <span class="comment">// size_t没有名字，以防止编译器发出警告说它没有使用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　<span class="keyword">return</span> location;</span><br><span class="line">  <span class="comment">// 在使用placement new的情况下，调用者已经获得了指向内存的指针</span></span><br><span class="line">  <span class="comment">// 由于调用者知道对象应该放在哪里，placement new必须做的就是返回转递给它的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p><strong>new 、operator new 和 placement new 区别</strong></p>
<p>（1）<code>new</code>：不能被重载，其行为总是一致的。它先调用operator new分配内存，然后调用构造函数初始化那段内存。</p>
<p>（2）<code>operator new</code>：要实现不同的内存分配行为，应该重载operator new，而不是new。</p>
<ul>
<li>operator new 就像 operator + 一样，是可以重载的。如果类中没有重载 operator new，那么调用的就是全局的 ::operator  new 来完成堆的分配。同理，operator new[]、operator delete、operator delete[] 也是可以重载的。</li>
<li>重载时，返回类型必须声明为 void*，第一个参数类型必须为表达要求分配空间的大小（字节），类型为 size_t，可以带其它参数。</li>
</ul>
<p>（3）<code>placement new</code>：只是 operator new 重载的一个标准、全局的版本。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。因此不能删除它，但需要调用对象的析构函数。placement new 允许在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。原型中 void* p 实际上就是指向一个已经分配好的内存缓冲区的的首地址。</p>
<h1 id="二、Deletion-and-Memory-Deallocation"><a href="#二、Deletion-and-Memory-Deallocation" class="headerlink" title="二、Deletion and Memory Deallocation"></a>二、Deletion and Memory Deallocation</h1><h2 id="1、delete-和-operator-delete"><a href="#1、delete-和-operator-delete" class="headerlink" title="1、delete 和 operator delete"></a>1、delete 和 operator delete</h2><p>为了避免内存泄漏，每一个动态内存分配必须与一个等同相反的 deallocation 相应。<strong>函数 operator delete</strong> 与 <strong>delete操作符</strong>的关系与 <strong>operator new</strong>与 <strong>new 操作符</strong>的关系一样。</p>
<p><code>delete</code>总是完成下述功能：</p>
<ol>
<li>调用析构函数；</li>
<li>释放内存。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241445181.png" alt="image-20240424144503094"></p>
<p><code>operator delete</code>函数用来释放内存，声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *memoryToBeDeallocated)</span></span>;</span><br></pre></td></tr></table></figure>

<p>因此，<strong>假设你仅仅想处理未被初始化的内存，你应该绕过 new 和 delete 操作符，而调用 operator new 获得内存和 operator delete 释放内存给系统</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *buffer = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="number">50</span>*<span class="built_in">sizeof</span>(<span class="type">char</span>)); <span class="comment">// 分配足够的内存以容纳50个char</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//没有调用构造函数</span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>; <span class="comment">// 释放内存</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 没有调用析构函数</span></span><br></pre></td></tr></table></figure>

<p>这与在 C 中调用 malloc 和 free 等同。</p>
<h2 id="2、placement-new建立的对象怎样释放？"><a href="#2、placement-new建立的对象怎样释放？" class="headerlink" title="2、placement new建立的对象怎样释放？"></a>2、placement new建立的对象怎样释放？</h2><p>假设用 <code>placement new</code> 在内存中建立对象，应该避免在该内存中使用 delete 操作符。</p>
<p>由于 delete 操作符调用 operator delete 释放内存，但这片存最开始并不是被 operator new 分配的，placement new 只是返回传递给它的这片内存的指针，因此无法得知这片内存究竟来自何处。因此，<strong>应该显式调用析构函数来解除构造函数的影响</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在共享内存中分配和释放内存的函数 void * mallocShared(size_t size);</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">freeShared</span><span class="params">(<span class="type">void</span> *memory)</span></span>;</span><br><span class="line"><span class="type">void</span> *sharedMemory = <span class="built_in">mallocShared</span>(<span class="built_in">sizeof</span>(Widget));</span><br><span class="line">Widget *pw = <span class="comment">// 如上所看到的</span></span><br><span class="line"><span class="built_in">constructWidgetInBuffer</span>(sharedMemory, <span class="number">10</span>); <span class="comment">// 使用</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 执行placement new操作 </span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">delete</span> pw;      <span class="comment">// 结果不确定! 共享内存来自mallocShared, 而不是operator new</span></span><br><span class="line">pw-&gt;~<span class="built_in">Widget</span>();  <span class="comment">// 正确。 析构pw指向的Widget，但并未释放存放Widget的这片内存</span></span><br><span class="line"><span class="built_in">freeShared</span>(pw); <span class="comment">// 正确。 释放pw指向的共享内存，但并未调用析构函数</span></span><br></pre></td></tr></table></figure>

<h2 id="3、new-delete和array-new-array-delete应该搭配使用"><a href="#3、new-delete和array-new-array-delete应该搭配使用" class="headerlink" title="3、new&#x2F;delete和array new&#x2F;array delete应该搭配使用"></a>3、new&#x2F;delete和array new&#x2F;array delete应该搭配使用</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241457401.png" alt="image-20240424145754309"></p>
<h1 id="三、相关问题"><a href="#三、相关问题" class="headerlink" title="三、相关问题"></a>三、相关问题</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Accoun *parray= <span class="keyword">new</span> Account[<span class="number">100</span>]; </span><br><span class="line"><span class="keyword">delete</span> parray; </span><br><span class="line"><span class="keyword">delete</span>[] parray; </span><br></pre></td></tr></table></figure>

<p>方括号的存在会使编译器获取数组大小（size）然后析构函数再被依次应用在每个元素上，一共size次。否则，只有一个元素被析构。 但无论哪种情况，分配的全部空间被返还给自由存储区。 </p>
<h2 id="1、为什么无论哪种情况，分配的全部空间被返还给自由存储区"><a href="#1、为什么无论哪种情况，分配的全部空间被返还给自由存储区" class="headerlink" title="1、为什么无论哪种情况，分配的全部空间被返还给自由存储区?"></a>1、为什么无论哪种情况，分配的全部空间被返还给自由存储区?</h2><p>首先，针对最后一句话“<strong>无论哪种情况，分配的全部空间被返还给自由存储区</strong>”，实际上是指：</p>
<p>无论是使用 <code>delete</code> 还是 <code>delete []</code>，分配的全部空间都会被释放，并返回给自由存储区。区别在于，<code>delete</code> 只会调用一次析构函数，而 <code>delete []</code> 会调用数组中每个元素的析构函数。因此，如果你分配了一个数组并使用 <code>delete</code> 来释放，只有一个元素的析构函数会被调用，可能导致内存泄漏，因为其他元素的资源没有得到正确释放。而使用 <code>delete []</code> 则能保证每个元素的析构函数都被正确调用，避免了这种潜在的内存泄漏问题。</p>
<h2 id="2、对于delete-parray，编译器怎么知道parray这个指针实际指向的是数组还是单个元素？"><a href="#2、对于delete-parray，编译器怎么知道parray这个指针实际指向的是数组还是单个元素？" class="headerlink" title="2、对于delete[] parray，编译器怎么知道parray这个指针实际指向的是数组还是单个元素？"></a>2、对于delete[] parray，编译器怎么知道parray这个指针实际指向的是数组还是单个元素？</h2><p>（1）一般在分配时分配器会自动写一个日志（即在分配的内存之前有一个结构）用于记录分配的大小，分配内容的sizeof等等。 </p>
<p>直观来说，<code>delete</code>和<code>delete[]</code>都是传入一个<code>void*</code>，因此如果不保存日志就无法知道分配时到底是分配了一个还是多个单元。所以虽然<code>delete</code>和<code>delete[]</code>不同，但是分配器在执行释放过程中都会读取这个日志，从而了解到底应该释放多少内存，但是从程序员的角度来说，既然分配了数组，就应该用<code>delete[]</code>。</p>
<p>（2）在VC下用汇编跟过delete[]的执行情况,发现这个 “日志 “就是一个4字节长的整数记录数组元素个数,紧挨在数组第一个元素之前。但是有个前提：对象类型(或其基类)有显式析构函数.换句话说,析构函数是非<code>virtual</code>的。否则的话,数组前面是没有这个日志的。其实对于析构函数是<code>virtual</code>的情况，<code>delete[]</code>时无需调用其析构函数，因此此时<code>VC</code>把<code>delete[]</code>当做<code>delete</code>同样处理。</p>
<p>（3）<code>delete parray</code>，编译器得到类型信息是<code>Account</code>单个的指针，那么释放时，只调用一次析构函数。<br><code>delete[] parray</code>，编译器得到的类型信息是<code>Account[]</code>类型，则按照<code>Account</code>数组来处理，依次调用每个元素的析构函数。 </p>
<h2 id="3、编译器又是如何获知这个数组的大小？"><a href="#3、编译器又是如何获知这个数组的大小？" class="headerlink" title="3、编译器又是如何获知这个数组的大小？"></a>3、编译器又是如何获知这个数组的大小？</h2><p>当我们使用<code>operator new</code>为一个自定义类型对象分配内存时，我们得到的内存要比实际对象的内存大一些，这些内存除了要存储对象数据外，还需要记录这片内存的大小，此方法称为<code>cookie</code>。这一点上的实现依据不同的编译器不同。（例如<code>MFC</code>选择在所分配内存的头部存储对象实际数据，而后面的部分存储边界标志和内存大小信息。<code>g++</code>则采用在所分配内存的头4个自己存储相关信息，而后面的内存存储对象实际数据。）当我们使用<code>delete operator</code>进行内存释放操作时，<code>delete operator</code>就可以根据这些信息正确的释放指针所指向的内存块。<br>对于<code>parray</code>指针，可以根据这样的<code>cookie</code>信息来得到指向内存空间的大小，<code>delete parray</code>和<code>delete[] parray</code>都是一样的，同样一个指针，<code>cookie</code>信息是相同的，所以对应的内存都会被释放掉。但是由于编译器理解两种情况下的类型是不同的，所以调用析构函数会有不同。 </p>
<h2 id="4、new-handler相关"><a href="#4、new-handler相关" class="headerlink" title="4、new handler相关"></a>4、new handler相关</h2><p>我们在分配内存的时候。分配内存可能会有失败的情况，在失败的时候往往会抛出异常。对于内存，我们在抛出失败之前。可以先调用一个自己制作的<code>handler</code>，这个<code>handler</code>可能能帮助正确的分配内存或者终止进程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">new</span> handler)</span><span class="params">()</span></span>;<span class="comment">//定义一个handler</span></span><br><span class="line"><span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span><span class="title">throw</span><span class="params">()</span></span>;<span class="comment">//设定一个handler</span></span><br></pre></td></tr></table></figure>

<p><code>new handler</code>的两种选择</p>
<ul>
<li>让更多<code>memory</code>可以被使用</li>
<li>抛出异常（<code>abort()</code>或<code>exit()</code>）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handlerx</span><span class="params">()</span></span>&#123;<span class="comment">//类似这样的就可以</span></span><br><span class="line">	cerr&lt;&lt;<span class="string">&quot;no&quot;</span>;</span><br><span class="line">	<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">set_new_handler</span>(handler);</span><br><span class="line">	..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、相关参考"><a href="#四、相关参考" class="headerlink" title="四、相关参考"></a>四、相关参考</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241530554.png" alt="image-20240424153034458"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241530444.png" alt="image-20240424153053351"></p>
<p><a href="https://www.cnblogs.com/luxiaoxun/archive/2012/08/10/2631812.html">C++中的new、operator new与placement new</a></p>
]]></content>
      <categories>
        <category>面试</category>
        <category>零散</category>
      </categories>
  </entry>
  <entry>
    <title>字符串与整数的相互转换</title>
    <url>/2024/04/26/%E9%9D%A2%E8%AF%95/%E9%9B%B6%E6%95%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<p>今天在做<strong>Leetcode 150. 逆波兰表达式求值</strong>一题时，涉及到字符串转换为整数的相关问题，遂进行如下探讨：</p>
<h2 id="1、字符串转换为整数"><a href="#1、字符串转换为整数" class="headerlink" title="1、字符串转换为整数"></a>1、字符串转换为整数</h2><h3 id="（1）四种转换方法"><a href="#（1）四种转换方法" class="headerlink" title="（1）四种转换方法"></a>（1）四种转换方法</h3>   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、stoi()，传入string类型</span></span><br><span class="line">  string s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">  <span class="type">int</span> num1 = <span class="built_in">stoi</span>(s1);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2、atoi()，传入const char *类型</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s2 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">  <span class="type">int</span> num2 = <span class="built_in">atoi</span>(s2);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3、stringstream</span></span><br><span class="line">  <span class="function">stringstream <span class="title">ss</span><span class="params">(s1)</span></span>;</span><br><span class="line">  <span class="type">int</span> num3;</span><br><span class="line">  ss &gt;&gt; num3;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="type">int</span> num4;</span><br><span class="line">  <span class="built_in">sscanf</span>(s1.<span class="built_in">c_str</span>(), <span class="string">&quot;%d&quot;</span>, &amp;num4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）为什么下面四行代码得到了如下结果？"><a href="#（2）为什么下面四行代码得到了如下结果？" class="headerlink" title="（2）为什么下面四行代码得到了如下结果？"></a>（2）为什么下面四行代码得到了如下结果？</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">stoi</span>(<span class="string">&quot;13&quot;</span>) &lt;&lt; endl;  <span class="comment">// 13</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;13&quot;</span> - <span class="string">&quot;0&quot;</span> &lt;&lt; endl;  <span class="comment">// -3</span></span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;1&#x27;</span> - <span class="string">&#x27;0&#x27;</span> &lt;&lt; endl;   <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;1&quot;</span> - <span class="string">&quot;0&quot;</span> &lt;&lt; endl;   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>解释如下：</p>
<ol>
<li><code>stoi(&quot;13&quot;)</code> 将字符串 “13” 转换为整数，结果是 13。</li>
<li><code>&quot;13&quot; - &quot;0&quot;</code> 这里使用了字符串字面值进行减法运算，实际上这是不允许的，因为 C++ 中字符串字面值不能直接进行减法运算。但是在这个上下文中，编译器会尝试将字符串字面值转换为字符指针，然后进行指针运算，因此得到的结果是字符指针之间的差，即指向字符串 “13” 和 “0” 的地址之间的距离，而不是它们所代表的整数之差。在这个例子中，”13” 的地址比 “0” 的地址大，因此结果是负值，具体数值取决于编译器和平台。</li>
<li><code>&#39;1&#39; - &#39;0&#39;</code> 是字符之间的减法运算。字符 ‘1’ 对应的 ASCII 码是 49，字符 ‘0’ 对应的 ASCII 码是 48，因此结果是 1。</li>
<li><code>&quot;1&quot; - &quot;0&quot;</code> 和第二行的情况类似，仍然是字符串字面值之间的指针运算，结果是字符串指针之间的差，而不是字符串所代表的整数之差。</li>
</ol>
<h2 id="2、整数转换为字符串"><a href="#2、整数转换为字符串" class="headerlink" title="2、整数转换为字符串"></a>2、整数转换为字符串</h2>   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">intToString</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">  string str;</span><br><span class="line">  <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> digit = num % <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> ch = digit + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    str = ch + str;  <span class="comment">// 将字符添加到字符串的前面</span></span><br><span class="line">    num /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、to_string</span></span><br><span class="line">  <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">  string str1 = <span class="built_in">to_string</span>(num);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2、stringstream</span></span><br><span class="line">  stringstream ss;</span><br><span class="line">  ss &lt;&lt; num;</span><br><span class="line">  string str2 = ss.<span class="built_in">str</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3、sprintf</span></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">20</span>];</span><br><span class="line">  <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">  <span class="function">string <span class="title">str</span><span class="params">(buffer)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4、自定义实现</span></span><br><span class="line">  str = <span class="built_in">intToString</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
        <category>零散</category>
      </categories>
  </entry>
  <entry>
    <title>对含有虚函数的类进行sizeof</title>
    <url>/2024/06/13/%E9%9D%A2%E8%AF%95/%E9%9B%B6%E6%95%A3/%E5%AF%B9%E5%90%AB%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E8%BF%9B%E8%A1%8Csizeof/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoMember</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i1;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g3</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h3</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * B3继承空类和B2：</span></span><br><span class="line"><span class="comment"> *  由于本身有数据成员，所以空类的大小并未计算进来；</span></span><br><span class="line"><span class="comment"> *  继承B2的数据成员i1</span></span><br><span class="line"><span class="comment"> * 最终的大小为：4(i2) + 8(vptr) + 4(i1) = 16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B3</span> : <span class="keyword">public</span> NoMember, <span class="keyword">public</span> B2 &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h1</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * B4继承B1和B2：</span></span><br><span class="line"><span class="comment"> *  继承B1的数据成员ch</span></span><br><span class="line"><span class="comment"> *  继承B2的数据成员i1</span></span><br><span class="line"><span class="comment"> * 4(i3) + 8(vptr_B1) + 1(ch) + 4(i1) + 8(vptr_B2) = 25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B4</span> : <span class="keyword">public</span> B1, <span class="keyword">public</span> B2 &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i3;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g2</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h2</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共用虚基类A的虚表指针，内存大小为 4(int) + 8(指向虚基类A的指针) = 12</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfunB</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共用虚基类A的虚表指针，内存大小为 4(int) + 8(指向虚基类A的指针) = 12</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfunC</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于B,C都是虚继承，因此D只包含一个A的副本</span></span><br><span class="line"><span class="comment">// 内存大小为 4(int) + 8(B类中指向虚基类A的指针) + 8(C类中指向虚基类A的指针) = 20</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfunD</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(char b[10]) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="number">10</span>; <span class="comment">// 定义数组大小</span></span><br><span class="line">    std::array&lt;<span class="type">int</span>, n&gt; arr; <span class="comment">// 创建 std::array 对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(std::array&lt;int, &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;&gt;) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::string s1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(std::string s1) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s1) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(Base) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(NoMember) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(NoMember) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B1) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B1) &lt;&lt; std::endl;  <span class="comment">// 9    |   16</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B2) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B2) &lt;&lt; std::endl;  <span class="comment">// 12   |   16</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B3) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B3) &lt;&lt; std::endl;  <span class="comment">// 16   |   16</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B4) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B4) &lt;&lt; std::endl;  <span class="comment">// 25   |   32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(A) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; std::endl;  <span class="comment">// 4</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; std::endl;  <span class="comment">// 12</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(C) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(C) &lt;&lt; std::endl;  <span class="comment">// 12</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(D) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(D) &lt;&lt; std::endl;  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面试</category>
        <category>零散</category>
      </categories>
  </entry>
  <entry>
    <title>diyx86os</title>
    <url>/2024/05/08/Project/diyx86os/diyx86os/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="一、源码测试过程报错"><a href="#一、源码测试过程报错" class="headerlink" title="一、源码测试过程报错"></a>一、源码测试过程报错</h1><p>1、出现报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[build] x86_64-elf-objdump: Dwarf Error: found dwarf version <span class="string">&#x27;7424&#x27;</span>, this reader only handles version 2, 3 and 4 information.</span><br></pre></td></tr></table></figure>

<p>工具链相关错误，可忽略。</p>
<p>2、测试过程中的编译时遇到错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DiskPart 遇到错误: 由于虚拟磁盘系统限制，无法完成请求的操作。虚拟硬盘文件必须是未压缩和未加密的文件，并且不能是稀疏文件。</span><br></pre></td></tr></table></figure>

<p>解决：取消勾选“压缩或加密属性”</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081530696.png" alt="image-20240508153049493" style="zoom: 67%;" />

<p>3、dd命令不存在：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;dd if=kernel.elf of=disk1.vhd bs=512 conv=notrunc seek=100 &#x27;dd&#x27; 不是内部或外部命令，也不是可运行的程序 或批处理文件。</span><br></pre></td></tr></table></figure>

<p>在Git的安装路径下找到dd.exe文件，并将对应的bin目录添加到系统变量中：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081641135.png" alt="image-20240508164113684"></p>
<p>4、调试成功时，终端显示如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> not exist <span class="string">&quot;disk1.vhd&quot;</span> (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;disk1.vhd not found in image directory&quot;</span></span><br><span class="line"> notepad win_error.txt</span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> not exist <span class="string">&quot;disk2.vhd&quot;</span> (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;disk2.vhd not found in image directory&quot;</span></span><br><span class="line"> notepad win_error.txt</span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">set</span> DISK1_NAME=disk1.vhd</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">dd</span> <span class="keyword">if</span>=boot.bin of=disk1.vhd bs=512 conv=notrunc count=1 </span><br><span class="line">1+0 records <span class="keyword">in</span></span><br><span class="line">1+0 records out</span><br><span class="line">512 bytes copied, 0.009362 s, 54.7 kB/s</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">dd</span> <span class="keyword">if</span>=loader.bin of=disk1.vhd bs=512 conv=notrunc seek=1 </span><br><span class="line">24+0 records <span class="keyword">in</span></span><br><span class="line">24+0 records out</span><br><span class="line">12288 bytes (12 kB, 12 KiB) copied, 0.0077902 s, 1.6 MB/s</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">dd</span> <span class="keyword">if</span>=kernel.elf of=disk1.vhd bs=512 conv=notrunc seek=100 </span><br><span class="line">98+1 records <span class="keyword">in</span></span><br><span class="line">98+1 records out</span><br><span class="line">50452 bytes (50 kB, 49 KiB) copied, 0.0353497 s, 1.4 MB/s</span><br><span class="line">83+1 records <span class="keyword">in</span></span><br><span class="line">83+1 records out</span><br><span class="line">42968 bytes (43 kB, 42 KiB) copied, 0.0838259 s, 513 kB/s</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">set</span> DISK2_NAME=disk2.vhd</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">set</span> TARGET_PATH=k</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> <span class="keyword">select</span> vdisk file=<span class="string">&quot;D:\PostGraduate\cppex\diyx86os\image\disk2.vhd&quot;</span>  1&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> attach vdisk  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> <span class="keyword">select</span> partition 1  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> assign letter=k  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;diskpart /s a.txt</span><br><span class="line"></span><br><span class="line">Microsoft DiskPart 版本 10.0.19041.3636</span><br><span class="line"></span><br><span class="line">Copyright (C) Microsoft Corporation.</span><br><span class="line">在计算机上: DESKTOP-TVGU2EA</span><br><span class="line"></span><br><span class="line">DiskPart 已成功选择虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">  100 百分比已完成</span><br><span class="line"></span><br><span class="line">DiskPart 已成功连接虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">分区 1 现在是所选分区。</span><br><span class="line"></span><br><span class="line">DiskPart 成功地分配了驱动器号或装载点。</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> 0 NEQ 0 (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;attach disk2.vhd failed&quot;</span></span><br><span class="line"> notepad win_error.txt</span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;del a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;copy /Y *.elf k:\</span><br><span class="line">init.elf</span><br><span class="line">kernel.elf</span><br><span class="line">loop.elf</span><br><span class="line">shell.elf</span><br><span class="line">snake.elf</span><br><span class="line">已复制         5 个文件。</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> <span class="keyword">select</span> vdisk file=<span class="string">&quot;D:\PostGraduate\cppex\diyx86os\image\disk2.vhd&quot;</span>  1&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> detach vdisk  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;diskpart /s a.txt</span><br><span class="line"></span><br><span class="line">Microsoft DiskPart 版本 10.0.19041.3636</span><br><span class="line"></span><br><span class="line">Copyright (C) Microsoft Corporation.</span><br><span class="line">在计算机上: DESKTOP-TVGU2EA</span><br><span class="line"></span><br><span class="line">DiskPart 已成功选择虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">DiskPart 已成功分离虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> 0 NEQ 0 (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;detach disk2.vhd failed&quot;</span></span><br><span class="line"> notepad win_error.txt  </span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;del a.txt</span><br><span class="line"> *  终端将被任务重用，按任意键关闭。 </span><br><span class="line"></span><br><span class="line"> *  正在执行任务: D:\PostGraduate\cppex\diyx86os\start\<span class="built_in">test</span>/script/qemu-debug-win.bat </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;start qemu-system-i386  -m 128M -s -S -serial stdio -drive file=disk1.vhd,index=0,media=disk,format=raw -drive file=disk2.vhd,index=1,media=disk,format=raw -d pcall,page,mmu,cpu_reset,guest_errors,page,trace:ps2_keyboard_set_translation</span><br><span class="line"> *  终端将被任务重用，按任意键关闭。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二、引导程序：接管控制权"><a href="#二、引导程序：接管控制权" class="headerlink" title="二、引导程序：接管控制权"></a>二、引导程序：接管控制权</h1><h2 id="2-1-计算机启动流程简介"><a href="#2-1-计算机启动流程简介" class="headerlink" title="2.1 计算机启动流程简介"></a>2.1 计算机启动流程简介</h2><p>从上电到运行计算机经历了什么？</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081654966.png" alt="image-20240508165407603"></p>
<p><code>BIOS</code>：基本输入输出系统。固化在flash芯片上。</p>
<p><strong>BIOS程序由硬件自己控制，本项目编写自己的引导代码和操作系统代码。</strong></p>
<p><code>disk1</code>是<code>qemu</code>的启动硬盘，<code>qemu</code>启动时会从磁盘最开始取<code>512</code>字节。</p>
<p><code>BIOS</code>在加载引导代码时，会根据用户的配置选择从磁盘加载还是从软盘加载，整个课程处理从磁盘加载的情况。</p>
<h2 id="2-2-接管计算机运行控制权"><a href="#2-2-接管计算机运行控制权" class="headerlink" title="2.2 接管计算机运行控制权"></a>2.2 接管计算机运行控制权</h2><p>硬盘的分类：</p>
<ul>
<li><p>机械硬盘：包含电机。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081957449.png" alt="image-20240508195742085"></p>
</li>
<li><p>固态硬盘：容量小但速度快。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081959718.png" alt="image-20240508195937467"></p>
</li>
</ul>
<p>启动时，<code>BIOS</code>会将磁盘的第<code>0</code>个扇区加载到<code>0x7c00</code>处开始运行。即只需要将程序放在第<code>0</code>号扇区，就会自动被加载到内存中运行。完成从<code>BIOS</code>程序到引导程序的跳转过程。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082011134.png" alt="image-20240508201149042"></p>
<p>在<code>vscode</code>中以十六进制编辑器模式打开<code>disk1.vhd</code>，在<code>000001F0</code>处（即第<code>0</code>号扇区的最后两个字节）可看到<code>1FE:0x55</code>, <code>1FF:0xAA</code>，即为上图所示的两个引导标志所在位置。只有这两个引导标志正确时，<code>BIOS</code>才会将磁盘的第<code>0</code>个扇区加载到<code>0x7c00</code>处开始运行。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082008662.png" alt="image-20240508200825616"></p>
<p>此时，若将<code>55/AA</code>进行改动，并重新启动<code>qemu</code>，操作系统将无法被正常启动，会显示如下结果：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082009410.png" alt="image-20240508200958280" style="zoom:67%;" />

<p><strong>为简化，本项目不考虑引导过程中一个磁盘包含多个分区的情况。</strong></p>
<h2 id="2-3-创建可引导的启动程序"><a href="#2-3-创建可引导的启动程序" class="headerlink" title="2.3 创建可引导的启动程序"></a>2.3 创建可引导的启动程序</h2><h3 id="1-整体的项目逻辑"><a href="#1-整体的项目逻辑" class="headerlink" title="1. 整体的项目逻辑"></a>1. 整体的项目逻辑</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-.vscode</span><br><span class="line">	- launch.json	// GDB调试相关信息</span><br><span class="line">	- settings.json</span><br><span class="line">	- tasks.json	// 定义[终端-运行任务]中的相关任务</span><br><span class="line">	</span><br><span class="line">// 定义了[终端-运行任务]中相关任务的命令脚本</span><br><span class="line">- script	</span><br><span class="line"></span><br><span class="line">// 包含若干个子工程</span><br><span class="line">- <span class="built_in">source</span>			</span><br><span class="line">    - applib		// 系统调用库</span><br><span class="line">    - boot			// 引导程序</span><br><span class="line">    - <span class="built_in">comm</span></span><br><span class="line">    - init			// 初始进程</span><br><span class="line">    - kernel		// 操作系统内核</span><br><span class="line">    	- cpu			// 存放cpu相关</span><br><span class="line">    	- include		// 存放头文件</span><br><span class="line">    	- init			// 相关初始化</span><br><span class="line">    - loader		// 加载程序</span><br><span class="line">    - loop			// 应用程序</span><br><span class="line">    - shell			// 命令行应用</span><br><span class="line">    </span><br><span class="line">- CMakeLists.txt</span><br></pre></td></tr></table></figure>

<h3 id="2-整体的开发工作流程："><a href="#2-整体的开发工作流程：" class="headerlink" title="2. 整体的开发工作流程："></a>2. 整体的开发工作流程：</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082034893.png" alt="image-20240508203408507" style="zoom:150%;" />

<h2 id="2-4-初始化引导程序"><a href="#2-4-初始化引导程序" class="headerlink" title="2.4 初始化引导程序"></a>2.4 初始化引导程序</h2><p><strong>主要任务：对boot程序进行简单初始化。</strong></p>
<h3 id="1-什么是引导程序？"><a href="#1-什么是引导程序？" class="headerlink" title="1. 什么是引导程序？"></a>1. 什么是引导程序？</h3><ul>
<li><p>主要用于为操作系统运行初始化运行环境，并加载操作系统运行。</p>
</li>
<li><p><strong>本项目中的引导程序涉及以下三个工作</strong>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082059875.png" alt="image-20240508205916747"></p>
</li>
</ul>
<p>由于BIOS只加载磁盘的第0扇区（512字节）到内存中，对于上述功能来说这个代码大小是不够的，因此需要考虑采用扩展程序的办法。</p>
<p>有以下两种方式，<strong>本项目采用方式二</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082102910.png" alt="image-20240508210246804"></p>
<h3 id="2-为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。"><a href="#2-为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。" class="headerlink" title="2. 为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。"></a>2. 为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。</h3><p>实模式包含以下特点：</p>
<ul>
<li>16位代码</li>
<li>无保护机制</li>
<li>无分页机制</li>
<li>仅使用1MB内存</li>
</ul>
<h3 id="3-x86与编程相关的主要内核寄存器"><a href="#3-x86与编程相关的主要内核寄存器" class="headerlink" title="3. x86与编程相关的主要内核寄存器"></a>3. x86与编程相关的主要内核寄存器</h3><p>   <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082107803.png" alt="image-20240508210729628"></p>
<ul>
<li><p>CS&#x2F;DS&#x2F;SS&#x2F;ES&#x2F;FS&#x2F;GS为段寄存器</p>
<ul>
<li><p>当访问特定内存地址时，需要采用<code>段:偏移</code>的形式，即实际地址为<code>段值&lt;&lt;4+偏移</code>。</p>
</li>
<li><p>例如：访问<code>0x7c00</code>，需要使用<code>0x7c0:0</code>，或<code>0:0x7c00</code></p>
</li>
<li><p>注意：初始化段寄存器时无需显示初始化<code>CS</code>。</p>
<blockquote>
<p>在 x86 架构中，CS（Code Segment）寄存器是用于存放代码段的选择子，在实模式下，CS 寄存器的初始化通常由处理器自动完成。</p>
<p>在启动阶段，处理器会将 CS 寄存器设置为默认值，通常为 0xFFFF，这意味着 CS 段选择子为 0xFFFF，代码段的起始地址是 0xFFFF0。这个默认的值使得处理器能够正常从 BIOS 的 ROM 中加载启动代码，并执行第一条指令。因此，在启动阶段，通常不需要显式地设置 CS 寄存器。</p>
<p>相反，通过设置 DS、SS、ES、FS、GS 等段寄存器为 0，可以将默认的段地址 0 应用于数据段、栈段和其他段。这样，CPU 将能够正确访问位于物理地址 0 处的引导程序代码，并且在实模式下，所有的段都共享同一个地址空间，因此 CS 寄存器的设置可以由 CPU 自动处理。</p>
</blockquote>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082110449.png" alt="image-20240508211028354"></p>
</li>
</ul>
<h3 id="4-实模式下的内存映射（8086）"><a href="#4-实模式下的内存映射（8086）" class="headerlink" title="4. 实模式下的内存映射（8086）"></a>4. 实模式下的内存映射（8086）</h3><ul>
<li><p>其中灰色为可用区域。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082112921.png" alt="image-20240508211243702" style="zoom:50%;" /></li>
</ul>
<h2 id="2-5-使用BIOS中断显示字符"><a href="#2-5-使用BIOS中断显示字符" class="headerlink" title="2.5 使用BIOS中断显示字符"></a>2.5 使用BIOS中断显示字符</h2><h3 id="1-如何显示字符？"><a href="#1-如何显示字符？" class="headerlink" title="1. 如何显示字符？"></a>1. 如何显示字符？</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090906770.png" alt="image-20240509090652672" style="zoom: 80%;" />

<p>BIOS提供了一组服务，可以方便地帮助我们操纵硬件，避免与硬件细节打交道。</p>
<ul>
<li>当调用<code>INT</code>软中断时，<code>CPU</code>会转到中断向量表处（<code>0x00000000~0x000003FF</code>），从中取出相应的地址位置，取出<code>BIOS</code>程序的入口地址，从而转到<code>BIOS</code>程序中运行。</li>
<li>参数通过寄存器传递。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090908623.png" alt="image-20240509090809536" />

<ul>
<li>本项目采用<code>INT 10, AH=0xE</code>显示字符<ul>
<li>该<code>BIOS</code>中断的作用是：显示字符，同时光标前移，其中（寄存器）<code>AL=字符</code>、<code>BL=前景色</code>、<code>BH=页码</code>。</li>
<li>具体来说<ul>
<li><code>BH</code>为目前的显示页。若在图形模式，<code>BH</code>需设置为0；</li>
<li>假如在图形模式下，也可设定<code>BL</code>来表示文字的颜色，文字模式下的<code>BL</code>则无此功能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2、BIOS-INT-10中断功能"><a href="#2、BIOS-INT-10中断功能" class="headerlink" title="2、BIOS INT 10中断功能"></a>2、BIOS INT 10中断功能</h3><p><a href="https://blog.csdn.net/qq_28256699/article/details/121103977">BIOS INT 10中断功能详解</a></p>
<h2 id="2-6-使用BIOS中断读取磁盘"><a href="#2-6-使用BIOS中断读取磁盘" class="headerlink" title="2.6 使用BIOS中断读取磁盘"></a>2.6 使用BIOS中断读取磁盘</h2><h3 id="1-怎样完成从Boot加载loader的过程？"><a href="#1-怎样完成从Boot加载loader的过程？" class="headerlink" title="1. 怎样完成从Boot加载loader的过程？"></a>1. 怎样完成从Boot加载loader的过程？</h3><p><code>BIOS</code>提供了磁盘读取的接口，便于从磁盘上读取<code>loader</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090926726.png" alt="image-20240509092600575"></p>
<p><strong>本项目的设计是在磁盘的第<code>0</code>号扇区（即<code>Boot</code>程序后）紧挨着放置<code>loader</code>程序。在加载时，考虑将其加载到<code>0x8000</code>处。</strong></p>
<ul>
<li>从磁盘上的第<code>1</code>号扇区开始，读取指定数量的扇区；</li>
<li>将其加载到内存中的指定地址处（<code>0x8000</code>）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090931367.png" alt="image-20240509093110267"></p>
<h3 id="2-INT-13磁盘读取"><a href="#2-INT-13磁盘读取" class="headerlink" title="2. INT 13磁盘读取"></a>2. INT 13磁盘读取</h3><p>（1）BIOS提供了磁盘操作的服务中断，其具体使用方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入口参数								</span></span><br><span class="line">    AH = <span class="number">02</span>H							   						</span><br><span class="line">    AL = 扇区数								 </span><br><span class="line">    CH = 柱面									  </span><br><span class="line">    CL = 扇区								     </span><br><span class="line">    DH = 磁头								 </span><br><span class="line">    DL = 驱动器</span><br><span class="line">      - <span class="number">00</span>H~<span class="number">7F</span>H  ：软盘</span><br><span class="line">      - <span class="number">80</span>H~<span class="number">0F</span>FH ：硬盘</span><br><span class="line">    ES:BX = 缓冲区地址（即要加载到的内存中的地址）</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 出口参数</span></span><br><span class="line">- 若传输成功，	</span><br><span class="line">	CF = <span class="number">0</span></span><br><span class="line">	AH = <span class="number">00</span>H</span><br><span class="line">	AL = 传输的扇区数</span><br><span class="line">- 若传输失败，AH = 状态码</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cx=ch:cl</code>（<code>ch</code>占高<code>8</code>位，<code>cl</code>占低<code>8</code>位）。<ul>
<li>因此<code>mov $0x2, %cx</code>相当于直接一步到位，将<code>ch</code>设置为<code>0</code>，<code>cl</code>设置为<code>2</code>。</li>
<li>注意<code>cl</code>为<code>2</code>是因为：<strong>在本项目采用的读取方法下，BIOS认为磁盘的编号是从1开始的。</strong></li>
</ul>
</li>
<li><code>mov $64, %al</code><ul>
<li><code>al</code>为读取的扇区数量，必须小于<code>128</code>，暂设置成<code>32KB</code></li>
<li>因为一个扇区大小是<code>512B</code>，即<code>0.5KB</code>。因此若要暂设成<code>32KB</code>，即相当于<code>64</code>个扇区。</li>
</ul>
</li>
</ul>
<p>（2）运行完成后，将会把磁盘<code>1</code>中的相关内容加载到内存的<code>0x8000</code>处：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091016385.png" alt="image-20240509101626325"></p>
<h2 id="2-7-初始化引导程序"><a href="#2-7-初始化引导程序" class="headerlink" title="2.7 初始化引导程序"></a>2.7 初始化引导程序</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091022007.png" alt="image-20240509102201895"></p>
<h3 id="1、如何生成loader并写入磁盘映像？"><a href="#1、如何生成loader并写入磁盘映像？" class="headerlink" title="1、如何生成loader并写入磁盘映像？"></a>1、如何生成loader并写入磁盘映像？</h3><h3 id="2、怎样从boot跳转到loader执行？"><a href="#2、怎样从boot跳转到loader执行？" class="headerlink" title="2、怎样从boot跳转到loader执行？"></a>2、怎样从boot跳转到loader执行？</h3><h1 id="三、加载器loader的实现"><a href="#三、加载器loader的实现" class="headerlink" title="三、加载器loader的实现"></a>三、加载器loader的实现</h1><h2 id="3-1-利用内联汇编显示字符串"><a href="#3-1-利用内联汇编显示字符串" class="headerlink" title="3.1 利用内联汇编显示字符串"></a>3.1 利用内联汇编显示字符串</h2><p>用于显示loader加载过程，从而提示加载到哪一步时出现问题。</p>
<h3 id="1、内联汇编理论"><a href="#1、内联汇编理论" class="headerlink" title="1、内联汇编理论"></a>1、内联汇编理论</h3><ul>
<li><p><strong>概述</strong></p>
<p>在开发操作系统过程中，有时必须使用某些特殊的指令（如<code>int/outb/hlt</code>等），而<code>C</code>编译器无法自动使用这些指令。因此，如果要使用这些指令，有两种方式：</p>
<ul>
<li>在汇编文件中为该指令的使用<strong>创建汇编函数（子程序）</strong>，然后在C代码中以函数调用的方式去使用；</li>
<li>使用<strong>内联汇编</strong>，即在C代码中嵌入汇编程序。</li>
</ul>
<p>在大多数情况下，使用内联汇编会更加简单、易用。因此，以下将简要介绍本项目中所用的相关的GCC内联汇编的写法。</p>
</li>
<li><p><strong>基本格式</strong></p>
<p>基本格式如下，以<code>asm</code>关键字开头，包含<code>3</code>个可选的配置项。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>(汇编语句</span><br><span class="line"> :输出操作数(可选)</span><br><span class="line"> :输入操作数(可选)</span><br><span class="line"> :被破坏的寄存器列表(可选)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>下面举个例子，其功能为将<code>a</code>的值赋值给<code>b</code>，具体代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>, b;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;movl %1,%%eax; movl %%eax, %0;&quot;</span></span><br><span class="line">	:<span class="string">&quot;=r&quot;</span>(b)	<span class="comment">/* 输出 */</span></span><br><span class="line">	:<span class="string">&quot;r&quot;</span>(a)		<span class="comment">/* 输入 */</span></span><br><span class="line">	:<span class="string">&quot;%eax&quot;</span>		<span class="comment">/* 破坏寄存器 */</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其效果等价于<code>movl a, %%eax; movl %%eax, b</code>，即：将<code>a</code>的值先给<code>eax</code>寄存器，再将<code>eax</code>寄存器的值给到<code>b</code>，最终实现<code>b=a</code>的效果。</p>
</li>
<li><p><strong>具体格式说明</strong></p>
<ul>
<li><p>只有一条汇编语句</p>
<p>在内联汇编中，可以只有汇编语句，即没有输出、输入操作数，没有被破坏的寄存器列表。例如:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;hlt&quot;</span>);  <span class="comment">// 让CPU暂停运行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有多条汇编语句</p>
<p>当有多条汇编语句时，需要写在同一字符串中，不同语句之间用<code>;</code>或者<code>\n\t</code>分隔。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;sti; hlt&quot;</span>);	<span class="comment">// 开启中断，然后让CPU暂停运行</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;sti\n\thlt&quot;</span>);	<span class="comment">// 开启中断，然后让CPU暂停运行</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;sti\n\t&quot;</span>		<span class="comment">// 同上。C语言中多个连续的字符串，会被认为是同一字符串</span></span><br><span class="line">    <span class="string">&quot;hlt&quot;</span>);			<span class="comment">// 开启中断，然后让CPU暂停运行</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>有输出操作数</strong></p>
<p>当汇编语句中有些数据需要存储到<code>C</code>语言中的某些变量中时，则可以使用输出操作数。例如，下面的代码是将<code>c</code>变量的值通过<code>mov $3, c</code>设置成<code>3</code>。其中<code>%[out]</code>为定义的一个输出约束，其名称应与<code>:</code>后的<code>out</code>相同，<code>&quot;=r&quot;(c)</code>指定了<code>c</code>变量映射到某个寄存器中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;mov $3, %[out]&quot;</span>:[out]<span class="string">&quot;=r&quot;</span>(c));</span><br></pre></td></tr></table></figure>

<p>通过上述方式，即实现了类似<code>mov $3,c</code>的效果。</p>
<p>其中<code>=r</code>还可以设置成其它，如下表所示</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">寄存器</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="center">任意寄存器</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">%eax,%ax,%al</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">%ebx,%bx,%bl</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">%ecx,%cx,%cl</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">%edx,%dx,%d</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">%esi,%si</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">%edi,%di</td>
</tr>
</tbody></table>
</li>
<li><p><strong>有输入操作数</strong></p>
<p>当需要从<code>C</code>语言中读取变量的值到汇编语句中时，则需要使用输入操作数。例如，下面的代码中，<code>mov%[ch], %%al</code>用于将<code>c</code>变量中的字符写到<code>al</code>中。因此，在输入操作数中使用了<code>[ch]&quot;r&quot;(c)</code>，即<code>c</code>变量映射到某个寄存器上（见上文中输出操作数的类似设置）。最终的效果为：<code>mov$0xe,%%ah、mov%[c],%%al</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line">    <span class="string">&quot;mov $0xe, %%ah\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;mov %[ch], %%al\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;int $Ox10&quot;</span>::[ch]<span class="string">&quot;r&quot;</span>(c)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免优化</p>
<p>在某些情况下，<code>GCC</code>编译器会对内联汇编中的汇编语句进行优化处理，最终导致生成语句和预期的不同，影响程序的执行结果。为了避免这些问题，可以强制要求<code>GCC</code>不对其进行优化，即原样的生成。要达到这点，可以使用<code>__asm__ __volatile_</code>替代原来的<code>asm</code>。</p>
</li>
<li><p>参考资料</p>
<p>GCC内联汇编介绍：<a href="https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a><br>GCC内联汇编介绍：<a href="https://wiki.osdev.org/Inline_Assembly">https://wiki.osdev.org/Inline_Assembly</a><br>内联汇编示例：<a href="https://wiki.osdev.org/Inline_Assembly/Examples">https://wiki.osdev.org/Inline_Assembly/Examples</a></p>
</li>
</ul>
<h3 id="2、示例"><a href="#2、示例" class="headerlink" title="2、示例"></a>2、示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_msg</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> * msg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = *msg++) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 利用内联汇编显示字符串</span></span><br><span class="line">        <span class="keyword">asm</span>(</span><br><span class="line">            <span class="string">&quot;mov $0xe, %%ah\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;mov %[ch], %%al\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;int $0x10&quot;</span></span><br><span class="line">            ::[ch]<span class="string">&quot;r&quot;</span>(c)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loader_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    show_msg(<span class="string">&quot;....loading....\n\r&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091941355.png" alt="image-20240509194129987"></p>
<h2 id="3-2-检测内存容量"><a href="#3-2-检测内存容量" class="headerlink" title="3.2 检测内存容量"></a>3.2 检测内存容量</h2><p>对<code>loader</code>做一些功能扩展。</p>
<h3 id="1、内存检测方法理论"><a href="#1、内存检测方法理论" class="headerlink" title="1、内存检测方法理论"></a>1、内存检测方法理论</h3><p>内存检测方法：<code>INT 0x15, EAX = 0xE820</code></p>
<p>没有找到专门介绍内存检测方法的官方文档，只在<code>osdev</code>网站上（见下文参考资料）中找到相关的检测方法。具体来看，其中有简单也有复杂的方法，有的只在某些机器上可用。最推荐的一种方法如下（摘自osdev）：</p>
<blockquote>
<p><strong>第一次调用时，ES: DI存储保存读取的信息的存储位置：</strong><br>清除<code>EBX</code>，设置为<code>0</code><br><code>EDX</code>设置成	<code>0x534D4150</code><br><code>EAX</code>设置成	<code>0xE820</code><br><code>ECX</code>设置成	<code>24</code><br>执行		   	 <code>INT 0x15</code><br>返回结果      <code>EAX=0x534D4150</code>，<code>CF</code>标志清<code>0</code>，<code>EBX</code>被设置成某个数值用于下次调用，<code>CL</code>&#x3D;实际读取的字节数</p>
<p><strong>后续调用：</strong><br><code>EDX</code>设置成	<code>0x534D4150</code><br><code>EAX</code>重设为	<code>0xE820</code><br><code>ECX</code>重设为	<code>24</code><br>执行				  <code>INT 0x15</code><br>返回结果	   <code>EAX=0x534D4150</code>，<code>CF</code>标志清<code>0</code>。如果<code>EBX=0</code>，则表明读取完毕，否则当前条目有效。</p>
</blockquote>
<p>参考资料——内存检测方法：<a href="https://wiki.osdev.org/Detecting_Memory_(x86)">https://wiki.osdev.org/Detecting_Memory_(x86)</a></p>
<h3 id="2、示例-1"><a href="#2、示例-1" class="headerlink" title="2、示例"></a>2、示例</h3><p>首先需要自定义一个结构体来保存boot获取到的硬件信息，以便后期传递给操作系统使用。定义在comm中</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092034455.png" alt="image-20240509203459102"></p>
<p>当<code>for</code>循环执行完毕后，<code>boot_info</code>内部的信息如下，共分配两块内存区域：</p>
<ul>
<li>第1块，<code>0-640KB</code>左右，在<code>1MB</code>以内；</li>
<li>第2块，<code>1MB-128MB</code>左右。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092042975.png" alt="image-20240509204234901"></p>
<p>可以结合<code>qemu</code>的配置脚本来看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@REM 适用于windows</span><br><span class="line">start qemu-system-i386  -m 128M -s -S  -drive file=disk1.vhd,index=0,media=disk,format=raw -drive file=disk2.vhd,index=1,media=disk,format=raw -d pcall,page,mmu,cpu_reset,guest_errors,page,trace:ps2_keyboard_set_translation</span><br></pre></td></tr></table></figure>

<p><code>qemu</code>启动时内存大小分配即为<code>128M</code>，即<code>-m 128M</code>。</p>
<h2 id="3-3-切换至保护模式"><a href="#3-3-切换至保护模式" class="headerlink" title="3.3 切换至保护模式"></a>3.3 切换至保护模式</h2><h3 id="1、理论基础"><a href="#1、理论基础" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092111828.png" alt="image-20240509211140943"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092111423.png" alt="image-20240509211151568"></p>
<h3 id="2、编程细节"><a href="#2、编程细节" class="headerlink" title="2、编程细节"></a>2、编程细节</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gdt.start31_16 = start &gt;&gt; <span class="number">16</span>;</span><br><span class="line">gdt.start15_0 = start &amp; <span class="number">0xffff</span>;</span><br></pre></td></tr></table></figure>

<p><strong>（1）关闭中断</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关中断</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">cli</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;cli&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 禁用中断</span></span><br><span class="line">cli();</span><br></pre></td></tr></table></figure>

<p><code>cli()</code>会影响<code>eflags</code>寄存器：</p>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405100950973.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405100954581.png" width="300"/>
</center>

<p><strong>（2）打开<code>A20</code>地址线</strong></p>
<p><a href="https://blog.csdn.net/sinolover/article/details/93877845">一步步编写操作系统 26 打开A20地址线</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 打开A20地址线</span></span><br><span class="line"><span class="type">uint8_t</span> v = inb(<span class="number">0x92</span>);</span><br><span class="line">outb(<span class="number">0x92</span>, v | <span class="number">0x2</span>);  <span class="comment">// 0x00000010</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）加载<code>GDT</code>表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint16_t</span> gdt_table[][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xffff</span>, <span class="number">0x0000</span>, <span class="number">0x9a00</span>, <span class="number">0x00cf</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xffff</span>, <span class="number">0x0000</span>, <span class="number">0x9200</span>, <span class="number">0x00cf</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 加载GDT表</span></span><br><span class="line">lgdt((<span class="type">uint32_t</span>)gdt_table, <span class="keyword">sizeof</span>(gdt_table));</span><br></pre></td></tr></table></figure>

<p>在<code>qemu</code>的<code>[view-&gt;compatmonitor()]</code>中输入<code>info registers</code>，可以看到<code>GDT</code>的信息变化：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101016115.png" alt="image-20240510101651071"></p>
<p><code>GDT</code>表写入后，<code>GDT=00009358 00000017</code>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101452241.png" alt="image-20240510145235174"></p>
<p>加载的<code>GDT</code>表项与所给出的表项一致：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101453798.png" alt="image-20240510145356743"></p>
<p><strong>（4）开启保护模式使能位</strong></p>
<p>开启保护位时，需设置<code>CR0</code>寄存器的<code>PE</code>位为<code>1</code>。由于<code>CR0</code>无法直接读写，必须先读取到某个中间寄存器，修改值后，再将值回写到<code>CR0</code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. 开启保护模式使能位</span></span><br><span class="line"><span class="type">uint32_t</span> cr0 = read_cr0();</span><br><span class="line">write_cr0(cr0 | (<span class="number">1</span> &lt;&lt; <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p><strong>（5）远跳转</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5. 远跳转，跳转到32位指令的入口处</span></span><br><span class="line">far_jump(<span class="number">8</span>, (<span class="type">uint32_t</span>)protect_mode_entry);  <span class="comment">// 这个8和保护模式的硬件细节，以及GDT表有关</span></span><br></pre></td></tr></table></figure>

<p>当跳转到<code>protect_mode_entry</code>后，可以看到段寄存器<code>CS</code>项变为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0000 00000000 0000ffff 00cf9a00 DPL=0 CS32</span><br></pre></td></tr></table></figure>

<p>即进入<code>32</code>位代码模式。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101455214.png" alt="image-20240510145523144"></p>
<p>将剩余的寄存器也修改到32位模式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">protect_mode_entry:</span><br><span class="line">	mov $<span class="number">16</span>, %ax</span><br><span class="line">	mov %ax, %ds</span><br><span class="line">	mov %ax, %ss</span><br><span class="line">	mov %ax, %es</span><br><span class="line">	mov %ax, %fs</span><br><span class="line">	mov %ax, %gs</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101500881.png" alt="image-20240510150001767"></p>
<h2 id="3-4-使用LBA读取磁盘"><a href="#3-4-使用LBA读取磁盘" class="headerlink" title="3.4 使用LBA读取磁盘"></a>3.4 使用LBA读取磁盘</h2><p>参考资料：<a href="https://wiki.osdev.org/ATA_PIO_Mode">硬盘访问模式及相关寄存器</a></p>
<p>虽然<code>BIOS</code>提供了磁盘读取的接口，方便从磁盘上读取<code>loader</code>，但在进入保护模式后，<code>BIOS</code>功能无法使用，<strong>读取磁盘需要使用到<code>LBA</code>模式</strong>。因此必须自己设计磁盘读取的代码。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101510647.png" alt="image-20240510151038444"></p>
<p>具体来讲，本项目采用<code>LBA48</code>模式。<code>LBA48</code>模式将硬盘上所有的扇区看成线性排列，没有磁盘、柱面等概念，因此访问起来更加简单，序号从<code>0</code>开始，其访问序列如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">outb(0x1F6,0x40|(slavebit&lt;&lt;4))  	// 选择硬盘:主盘或从盘</span><br><span class="line"></span><br><span class="line">outb(0x1F2,sectorcount high byte)	// 将扇区数量的高8位写入端口0x1F2</span><br><span class="line">// 分别将LBA(Logical Block Address)的第4、5、6个字节写入端口0x1F3、0x1F4、0x1F5</span><br><span class="line">outb(0x1F3,LBA4)							 </span><br><span class="line">outb(0x1F4,LBA5)</span><br><span class="line">outb(0x1F5,LBA6)</span><br><span class="line"></span><br><span class="line">outb (0x1F2,sectorcount low byte)	// 将扇区数量的低8位写入端口0x1F2</span><br><span class="line">// 分别将LBA(Logical Block Address)的第1、2、3个字节写入端口0x1F3、0x1F4、0x1F5</span><br><span class="line">outb(0x1F3,LBA1)</span><br><span class="line">outb(0x1F4,LBA2)</span><br><span class="line">outb(0x1F5,LBA3)</span><br><span class="line"></span><br><span class="line">Send the &quot;READ SECTORS EXT&quot; command (0x24) to port 0x1F7: </span><br><span class="line">outb(0x1F7,0x24)	// 告诉硬盘要读取扇区的数据</span><br></pre></td></tr></table></figure>

<p>各寄存器说明如下:</p>
<table>
<thead>
<tr>
<th>寄存器偏移</th>
<th>读写</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>R&#x2F;W</td>
<td>数据寄存器</td>
</tr>
<tr>
<td>1</td>
<td>R</td>
<td>错误寄存器</td>
</tr>
<tr>
<td>1</td>
<td>W</td>
<td>特性寄存器</td>
</tr>
<tr>
<td>2</td>
<td>R&#x2F;W</td>
<td>扇区数量寄存器</td>
</tr>
<tr>
<td>3</td>
<td>R&#x2F;W</td>
<td>Sector Number Register (LBAlo)</td>
</tr>
<tr>
<td>4</td>
<td>R&#x2F;W</td>
<td>Cylinder Low Register &#x2F;(LBAmid)</td>
</tr>
<tr>
<td>5</td>
<td>R&#x2F;W</td>
<td>Cylinder High Register &#x2F;(LBAhi)</td>
</tr>
<tr>
<td>6</td>
<td>R&#x2F;W</td>
<td>Drive &#x2F; Head Register</td>
</tr>
<tr>
<td>7</td>
<td>R</td>
<td>状态寄存器</td>
</tr>
<tr>
<td>7</td>
<td>W</td>
<td>命令寄存器</td>
</tr>
</tbody></table>
<ul>
<li>其中<code>0x1F6</code>寄存器（<code>Drive/Head</code>）对应的位如下：</li>
</ul>
<table>
<thead>
<tr>
<th>位</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0-3</td>
<td></td>
<td>在, bits 24 to 27 of the block number.</td>
</tr>
<tr>
<td>4</td>
<td>DRV</td>
<td>驱动器号（驱动器号：主盘和从盘。当只有一块硬盘时，默认第一块硬盘上放在主盘上。）</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>LBA</td>
<td>LBA模式下设置为1</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><code>Status Register(I/O base + 7)</code></li>
</ul>
<table>
<thead>
<tr>
<th>位</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>ERR</td>
<td>发生错误</td>
</tr>
<tr>
<td>1</td>
<td>IDX</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>CORR</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>DRQ</td>
<td>就绪，可以写数据或读取数据</td>
</tr>
<tr>
<td>4</td>
<td>SRV</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>DF</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>RDY</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>BSY</td>
<td>忙</td>
</tr>
</tbody></table>
<p>由于<code>loader</code>占用的大小较大，约几十<code>kb</code>的样子。由于不确定具体大小，因此尽量将内核往后放，放在第<code>100</code>个扇区的位置，并且将内核的大小为<code>500</code>，即<code>250kb</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static void read_disk (uint32_t sector, uint32_t sector_count, uint8_t *buf);</span></span><br><span class="line">read_disk(<span class="number">100</span>, <span class="number">500</span>, (<span class="type">uint8_t</span> *)SYS_KERNEL_LOAD_ADDR);</span><br></pre></td></tr></table></figure>

<h2 id="3-5-创建内核工程"><a href="#3-5-创建内核工程" class="headerlink" title="3.5 创建内核工程"></a>3.5 创建内核工程</h2><p>创建内核工程，并将工程写到磁盘上第<code>1MB</code>位置处，<code>loader</code>加载后将跳转过去。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101622446.png" alt="image-20240510162243231"></p>
<p>新建<code>kernel</code>文件夹，并在内部新建<code>CMakeLists.txt</code>如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">project(kernel LANGUAGES C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的链接器</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;-m elf_i386  -Ttext=0x100000&quot;</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_LINK_EXECUTABLE <span class="string">&quot;<span class="variable">$&#123;LINKER_TOOL&#125;</span> &lt;OBJECTS&gt; <span class="variable">$&#123;CMAKE_EXE_LINKER_FLAGS&#125;</span> -o <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有的汇编、C文件加入工程</span></span><br><span class="line"><span class="comment"># 注意保证start.asm在最前头，这样对应的程序会放在bin文件开头，从而在加载到0x8000时能在开头处</span></span><br><span class="line">file(GLOB_RECURSE C_LIST <span class="string">&quot;*.c&quot;</span> <span class="string">&quot;*.h&quot;</span>)</span><br><span class="line"><span class="comment"># 将GLOB改为GLOB_RECURSE，因为kernel目录下包含init等子目录，需要进行递归</span></span><br><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> init/start.S <span class="variable">$&#123;C_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bin文件生成，写入到image目录下</span></span><br><span class="line">add_custom_command(TARGET <span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">                   POST_BUILD</span><br><span class="line">                   COMMAND <span class="variable">$&#123;OBJCOPY_TOOL&#125;</span> -O binary <span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../../image/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.bin</span><br><span class="line">                   COMMAND <span class="variable">$&#123;OBJDUMP_TOOL&#125;</span> -x -d -S -m i386 <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf &gt; <span class="variable">$&#123;PROJECT_NAME&#125;</span>_dis.txt</span><br><span class="line">                   <span class="comment"># i8086改为i386，即从16位模式改为32位模式</span></span><br><span class="line">                   COMMAND <span class="variable">$&#123;READELF_TOOL&#125;</span> -a <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf &gt; <span class="variable">$&#123;PROJECT_NAME&#125;</span>_elf.txt</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="3-6-向内核传递启动信息"><a href="#3-6-向内核传递启动信息" class="headerlink" title="3.6 向内核传递启动信息"></a>3.6 向内核传递启动信息</h2><h3 id="1、如何实现从loader到kernel的信息传输？"><a href="#1、如何实现从loader到kernel的信息传输？" class="headerlink" title="1、如何实现从loader到kernel的信息传输？"></a>1、如何实现从loader到kernel的信息传输？</h3><p>信息的传递流程为：<code>boot_info-&gt;loader-&gt;kernel</code>。现在的问题就是如何实现从<code>loader</code>到<code>kernel</code>的传输？</p>
<ul>
<li><p>方式一：将<code>boot_info</code>写到某个固定的地址，再由<code>kernel</code>自行去取：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101952279.png" alt="image-20240510195254050"></p>
</li>
<li><p>方式二：将内核的入口地址处视为存放着一个接受启动信息参数的函数，使用函数调用：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101954937.png" alt="image-20240510195449809"></p>
<blockquote>
<p><code>(void(*)(boot_info_t *))(SYS_KERNEL_LOAD_ADDR)(&amp;boot_info)</code></p>
<p>这个表达式是一个函数指针的类型转换，用于将一个特定地址处的函数映射到一个特定类型的函数指针。调用这个函数指针，并将 <code>boot_info</code> 作为参数传递给该函数。</p>
<ol>
<li><code>(SYS_KERNEL_LOAD_ADDR)</code>：<ul>
<li>这部分表示一个地址，即内核加载的地址 <code>SYS_KERNEL_LOAD_ADDR</code>。</li>
</ul>
</li>
<li><code>(void (*)(boot_info_t *))</code>：<ul>
<li>这部分是一个函数指针类型的转换。</li>
<li><code>void (*)(boot_info_t *)</code> 表示一个函数指针，指向一个接受 <code>boot_info_t *</code> 类型参数并返回 <code>void</code> 类型的函数。</li>
</ul>
</li>
<li><code>(SYS_KERNEL_LOAD_ADDR)(&amp;boot_info)</code>：<ul>
<li>这部分将 <code>boot_info</code> 的地址作为参数传递给地址 <code>SYS_KERNEL_LOAD_ADDR</code> 处的函数，并且将返回的结果转换为 <code>(void (*)(boot_info_t *))</code> 类型的函数指针。</li>
</ul>
</li>
</ol>
<p>综合起来，整个表达式的作用是将位于地址 <code>SYS_KERNEL_LOAD_ADDR</code> 处的函数转换为一个接受 <code>boot_info_t *</code> 类型参数的函数指针，并且调用这个函数，将 <code>boot_info</code> 作为参数传递给它。</p>
</blockquote>
</li>
</ul>
<h3 id="2、x86栈的基本结构"><a href="#2、x86栈的基本结构" class="headerlink" title="2、x86栈的基本结构"></a>2、x86栈的基本结构</h3><p>保护模式下，栈单元大小为<code>32</code>位&#x2F;<code>4</code>字节。（在<code>32</code>位系统中）</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102027415.png" alt="image-20240510202728422"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102027751.png" alt="image-20240510202743173"></p>
<h3 id="3、实现细节"><a href="#3、实现细节" class="headerlink" title="3、实现细节"></a>3、实现细节</h3><p>（1）总体程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    .text</span><br><span class="line">    .extern kernel_init</span><br><span class="line">    .global _start</span><br><span class="line">    # void start (boot_info_t *boot_info)</span><br><span class="line">_start:</span><br><span class="line">    /*</span><br><span class="line">        将boot_info压入栈中，并传递给kernel_init</span><br><span class="line">        boot_info则来自_start被调用时，((void (*)(boot_info_t *))SYS_KERNEL_LOAD_ADDR)(&amp;boot_info);也会压栈</span><br><span class="line">            ((void (*)(boot_info_t *))SYS_KERNEL_LOAD_ADDR)(&amp;boot_info);</span><br><span class="line">            84d8:	83 ec 0c             	sub    $0xc,%sp</span><br><span class="line">            84db:	68 40 95             	push   $0x9540</span><br><span class="line">            84de:	00 00                	add    %al,(%bx,%si)</span><br><span class="line">            84e0:	b8 00 00             	mov    $0x0,%ax</span><br><span class="line">            84e3:	10 00                	adc    %al,(%bx,%si)</span><br><span class="line">            84e5:	ff d0                	call   *%ax</span><br><span class="line">            84e7:	83 c4 10             	add    $0x10,%sp</span><br><span class="line">        也即是说_start实际上是被调函数，参考讲义中的test函数的逻辑来操作</span><br><span class="line">    */</span><br><span class="line">    push %ebp</span><br><span class="line">    mov %esp, %ebp</span><br><span class="line">    mov 0x8(%ebp), %eax</span><br><span class="line">    /*</span><br><span class="line">        通过ebp+偏移来取得boot_info</span><br><span class="line">        由于_start仅1个参数，因此栈的局部结构为：</span><br><span class="line">            - 参数：boot_info</span><br><span class="line">            - 返回地址</span><br><span class="line">            - ebp当前指向位置（esp当前指向位置）</span><br><span class="line">        所以为0x8(%ebp)</span><br><span class="line">    */  </span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        由于最终是原地跳转，不会回到loader中，因此也可以不考虑ebp恢复的情况，此时上述三行可用一行来实现：</span><br><span class="line">            mov 4(%esp), %eax</span><br><span class="line"></span><br><span class="line">        当不考虑ebp时，esp+4即可取到boot_info</span><br><span class="line">        由于_start仅1个参数，因此栈的局部结构为：</span><br><span class="line">            - 参数：boot_info</span><br><span class="line">            - 返回地址（esp当前指向位置）</span><br><span class="line">        所以为4(%esp)</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    # kernel_init (boot_info)</span><br><span class="line">    push %eax  </span><br><span class="line">    call kernel_init  # 此时的kernel_init是被_start调用的函数</span><br><span class="line"></span><br><span class="line">    jmp .</span><br></pre></td></tr></table></figure>

<p>（2）具体执行</p>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push %ebp</span><br><span class="line">mov %esp, %ebp</span><br><span class="line">mov 0x8(%ebp), %eax</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102049124.png" alt="image-20240510204938049"></p>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov 0x8(%ebp), %eax</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102050925.png" alt="image-20240510205045871"></p>
<p>而在<code>./build/source/loader/loder_elf.txt</code>的符号表中，可以看到<code>boot_info</code>的地址即为<code>0x9540</code>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102052194.png" alt="image-20240510205246084"></p>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push %eax  </span><br><span class="line">call kernel_init  # 此时的kernel_init是被_start调用的函数</span><br><span class="line">jmp .</span><br></pre></td></tr></table></figure>

<p>当进入<code>kernel_init</code>函数后，可以看到传入的<code>boot_info</code>的地址也是<code>0x9540</code>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102054365.png" alt="image-20240510205443276"></p>
<h2 id="3-7-代码-数据段与链接脚本"><a href="#3-7-代码-数据段与链接脚本" class="headerlink" title="3.7 代码&#x2F;数据段与链接脚本"></a>3.7 代码&#x2F;数据段与链接脚本</h2><h3 id="1、链接的理论基础"><a href="#1、链接的理论基础" class="headerlink" title="1、链接的理论基础"></a>1、链接的理论基础</h3><blockquote>
<p>可参考【Computer-&gt;CSAPP-CSAPP_Ch7 链接】相关笔记。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102057812.png" alt="image-20240510205719578"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102108837.png" alt="image-20240510210839581"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102108978.png" alt="image-20240510210855757"></p>
<p>举例如下：</p>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102114815.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102116737.png" width="300"/>
</center>



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102111597.png" alt="image-20240510211122344"></p>
<h3 id="2、自定义链接脚本"><a href="#2、自定义链接脚本" class="headerlink" title="2、自定义链接脚本"></a>2、自定义链接脚本</h3><p>上述所讲为编译器默认配置。可自定义链接脚本，定义工程中相应的代码或数据放在哪些位置。</p>
<p>编写<code>kernel.lds</code>文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x20000;  // 控制.text section的起始地址，后续的section也可以进行相应的设置</span><br><span class="line"></span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text)  // 通配符： *</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		*(.rodata)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.data : &#123;</span><br><span class="line">		*(.data)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.bss : &#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并修改对应的<code>[kernel/CMakeLists.txt]</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(CMAKE_EXE_LINKER_FLAGS &quot;-m elf_i386  -T $&#123;PROJECT_SOURCE_DIR&#125;/kernel.lds&quot;)</span><br></pre></td></tr></table></figure>

<p>也就是说链接脚本控制了各个<code>section</code>具体的存放位置，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102138372.png" alt="image-20240510213841287"></p>
<blockquote>
<p>参考资料：</p>
<p><a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html">GCC LD官方文档</a></p>
<p><a href="https://wiki.osdev.org/Linker_Scripts">linker脚本(较易阅读)</a></p>
<p><a href="http://www.bravegnu.org/gnu-eprog/linker.html">ARM Linker链接脚本</a></p>
<p><a href="https://sourceware.org/binutils/docs/ld/">ld脚本编写</a></p>
</blockquote>
<h2 id="3-8-加载内核映像文件"><a href="#3-8-加载内核映像文件" class="headerlink" title="3.8 加载内核映像文件"></a>3.8 加载内核映像文件</h2><h3 id="1、理论基础-1"><a href="#1、理论基础-1" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112014421.png" alt="image-20240511201413000"></p>
<p>若在<code>#12</code>行设置<code>. = 200000</code>，则会导致在<code>.rodata</code>和<code>.data</code>中间出现较大的空闲空间，导致最终的文件大小大于<code>1MB</code>，这个大小过大了。且如果采用二进制映像文件，操作系统是无法得知各个<code>section</code>在内存中分布的具体位置的。</p>
<p>为了更好地组织程序和数据，一般需要专用的文件格式，如<code>PE</code>格式或者<code>ELF</code>格式。<code>ELF</code>用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件的文件格式。</p>
<blockquote>
<p>ELF文件的详细细节可参考【Computer-&gt;CSAPP-CSAPP_Ch7 链接】相关笔记。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112021480.png" alt="image-20240511202122375"></p>
<ul>
<li><p>可执行代码段和数据段从<code>p_offset</code>的位置拷贝到内存的<code>p_paddr</code>中，拷贝的大小为<code>p_filesz</code>。</p>
</li>
<li><p>在<code>ELF</code>文件格式中，<code>.data</code> 和 <code>.bss</code> 区域通常用来存储程序的已初始化和未初始化数据。在加载可执行文件时，操作系统会负责为这些区域分配内存，并将它们初始化为零。</p>
<p>因此，在生成<code>ELF</code>可执行文件时，不需要将 <code>.data</code> 和 <code>.bss</code> 区域的实际数据写入文件中。相反，只需在文件中标记出这些区域的大小，并在加载时告知操作系统需要为它们分配多大的内存空间，并将其初始化为零。</p>
</li>
<li><p><code>p_memsz = p_filesz + 清零区域</code></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112105777.png" alt="image-20240511210512520"></p>
<h3 id="2、代码实现细节"><a href="#2、代码实现细节" class="headerlink" title="2、代码实现细节"></a>2、代码实现细节</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># bin文件生成，写入到image目录下</span><br><span class="line">add_custom_command(TARGET $&#123;PROJECT_NAME&#125;</span><br><span class="line">                   POST_BUILD</span><br><span class="line">                   # 修改前</span><br><span class="line">                   # COMMAND $&#123;OBJCOPY_TOOL&#125; -O binary $&#123;PROJECT_NAME&#125;.elf $&#123;CMAKE_SOURCE_DIR&#125;/../../image/$&#123;PROJECT_NAME&#125;.elf</span><br><span class="line">                   # 修改后：-O binary =&gt; -S</span><br><span class="line">                   COMMAND $&#123;OBJCOPY_TOOL&#125; -S $&#123;PROJECT_NAME&#125;.elf $&#123;CMAKE_SOURCE_DIR&#125;/../../image/$&#123;PROJECT_NAME&#125;.elf</span><br><span class="line">				   COMMAND $&#123;OBJDUMP_TOOL&#125; -x -d -S -m i386 $&#123;PROJECT_BINARY_DIR&#125;/$&#123;PROJECT_NAME&#125;.elf &gt; $&#123;PROJECT_NAME&#125;_dis.txt</span><br><span class="line">                   COMMAND $&#123;READELF_TOOL&#125; -a $&#123;PROJECT_BINARY_DIR&#125;/$&#123;PROJECT_NAME&#125;.elf &gt; $&#123;PROJECT_NAME&#125;_elf.txt</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>修改后，新的存储规划如下：</p>
<ul>
<li>将<code>kernel</code>，即内核工程放在<code>64KB/0x10000</code>的位置；</li>
<li>也就是说，<code>0x100000</code>处只是存放一个临时的<code>ELF</code>文件，实际的内容会被加载到<code>0x10000</code>处执行。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112030942.png" alt="image-20240511203046852"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">reload_elf_file</span><span class="params">(<span class="type">uint8_t</span> *file_buffer)</span> &#123;</span><br><span class="line">    Elf32_Ehdr *elf_hdr = (Elf32_Ehdr *)file_buffer;</span><br><span class="line">    <span class="comment">// 检查是否为有效文件（粗略检查）</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr-&gt;e_ident[<span class="number">0</span>] != <span class="number">0x7F</span>) || (elf_hdr-&gt;e_ident[<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">        || (elf_hdr-&gt;e_ident[<span class="number">2</span>] != <span class="string">&#x27;L&#x27;</span>) || (elf_hdr-&gt;e_ident[<span class="number">3</span>] != <span class="string">&#x27;F&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取相应的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elf_hdr-&gt;e_phnum; i++) &#123;</span><br><span class="line">        Elf32_Phdr *phdr = (Elf32_Phdr *)(file_buffer + elf_hdr-&gt;e_phoff) + i;  <span class="comment">// 偏移量：elf_hdr-&gt;e_phoff</span></span><br><span class="line">        <span class="comment">// 判断该段是需要被加载到内存中的可执行代码或数据段</span></span><br><span class="line">        <span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将可执行代码或数据段从文件中拷贝到内存中</span></span><br><span class="line">        <span class="type">uint8_t</span> *src = file_buffer + phdr-&gt;p_offset;</span><br><span class="line">        <span class="type">uint8_t</span> *dest = (<span class="type">uint8_t</span> *)phdr-&gt;p_paddr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; phdr-&gt;p_filesz; j++) &#123;</span><br><span class="line">            *dest++ = *src++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 针对.data和.bss做进一步处理</span></span><br><span class="line">        dest = (<span class="type">uint8_t</span> *)phdr-&gt;p_paddr + phdr-&gt;p_filesz;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; phdr-&gt;p_memsz - phdr-&gt;p_filesz; j++) &#123;</span><br><span class="line">            *dest++ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elf_hdr-&gt;e_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112120766.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112119587.png" width="300"/>    
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112121617.png" width="300"/>
</center>



<h1 id="四、中断与异常处理"><a href="#四、中断与异常处理" class="headerlink" title="四、中断与异常处理"></a>四、中断与异常处理</h1><h2 id="4-1-创建GDT表及其表项"><a href="#4-1-创建GDT表及其表项" class="headerlink" title="4.1 创建GDT表及其表项"></a>4.1 创建GDT表及其表项</h2><h3 id="1、理论基础-2"><a href="#1、理论基础-2" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p><code>x86</code>系统架构（<code>IA32</code>模式）</p>
<ul>
<li><p>分段存储</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121404633.png" alt="image-20240512140427535"></p>
</li>
<li><p>分页存储</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121404406.png" alt="image-20240512140446313"></p>
</li>
</ul>
<p><strong>在进入保护模式以后，所有有关内存访问的操作都需要经过<code>GDT</code>表</strong>，表中的每项称为<strong>段描述符</strong>（<code>Segment descriptor</code>）。</p>
<p>每一项是一个结构体，<code>64</code>位结构，包含<code>base addr/基地址</code>、<code>limit/界限</code>以及<code>属性值</code></p>
<ul>
<li><code>limit</code>分为<code>2</code>块，<code>limit 15:00</code>和<code>limit 19:16</code></li>
<li><code>base addr</code>分为<code>3</code>块，<code>base 15:00</code>、<code>base 23:16</code>和<code>base 31:24</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121405202.png" alt="image-20240512140536089"></p>
<h3 id="2、代码细节"><a href="#2、代码细节" class="headerlink" title="2、代码细节"></a>2、代码细节</h3><ul>
<li><p><code>GDT</code>结构体的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">segment_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit15_0;</span><br><span class="line">    <span class="type">uint16_t</span> base15_0;</span><br><span class="line">    <span class="type">uint8_t</span> base23_16;</span><br><span class="line">    <span class="type">uint16_t</span> attr;</span><br><span class="line">    <span class="type">uint8_t</span> base31_24;</span><br><span class="line">&#125;<span class="type">segment_desc_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化<code>GDT</code>表项</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">segment_desc_t</span> gdt_table[GDT_TABLE_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    selector：从gdt表中选择某个表项</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">segment_desc_set</span> <span class="params">(<span class="type">int</span> selector, <span class="type">uint32_t</span> base, <span class="type">uint32_t</span> limit, <span class="type">uint16_t</span> attr)</span> &#123;</span><br><span class="line">    <span class="type">segment_desc_t</span> *desc = gdt_table + selector / <span class="keyword">sizeof</span>(<span class="type">segment_desc_t</span>);</span><br><span class="line"></span><br><span class="line">    desc-&gt;limit15_0 = limit &amp; <span class="number">0xFFFF</span>;                   <span class="comment">// limit低16位</span></span><br><span class="line">    desc-&gt;base15_0 = base &amp; <span class="number">0xFFFF</span>;                     <span class="comment">// base低16位</span></span><br><span class="line">    desc-&gt;base23_16 = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;              <span class="comment">// base右移16位后取低8位</span></span><br><span class="line">    desc-&gt;attr = attr | (((limit &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xF</span>) &lt;&lt; <span class="number">8</span>);   <span class="comment">// 将limit的高4位存储到attr字段 </span></span><br><span class="line">    desc-&gt;base31_24 = (base &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;              <span class="comment">// base右移24位后取低8位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空gdt表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; GDT_TABLE_SIZE; ++i) &#123;</span><br><span class="line">        segment_desc_set(i * <span class="keyword">sizeof</span>(<span class="type">segment_desc_t</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cpu_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    init_gdt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>理论上，处理器可以访问寻址处理任意地址的字节，但实际上为了保证计算机读取数据的高效性，<code>CPU</code>通过地址总线来访问内存。以32位处理器为例，一般来说寻址步长为32位(4个字节)，也就是每次从内存读取4个字节。为了提高存取效率，一般来说编译器会自动将一个数据尽量放在一个步长之内，避免跨步长存储，称为内存对齐。<br>每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。可通过预编译命令<code>#pragma pack(n)</code>，<code>n=1,2,4,8,16</code>来改变这一系数，其中的n就是你要指定的“对齐系数”。</p>
</blockquote>
<h2 id="4-2-保护模式下的内存管理简介"><a href="#4-2-保护模式下的内存管理简介" class="headerlink" title="4.2 保护模式下的内存管理简介"></a>4.2 保护模式下的内存管理简介</h2><h3 id="1、理论基础-3"><a href="#1、理论基础-3" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p>参考<code>325384-sdm-vol-3abcd.pdf</code>的<code>Ch3 Protected-Mode Memory Management</code></p>
</blockquote>
<ul>
<li><p>分段存储和分页存储及其异同</p>
<ul>
<li>分页存储</li>
</ul>
<p>  将程序的逻辑地址空间划分为固定大小的页(<code>page</code>)，而物理内存划分为同样大小的页框(<code>page frame</code>)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。</p>
<ul>
<li>分段存储</li>
</ul>
<p>  在分段存储管理中，将程序的地址空间划分为若干个段(<code>segment</code>)，这样每个进程有一个二维的地址空间。每个段分配一个连续的分区，而进程中的各个段可以不连续地存放在内存的不同分区中。程序加载时，操作系统为所有段分配其所需内存，这些段不必连续。</p>
<ul>
<li><p>分页和分段的相同点</p>
<ul>
<li><p>分页机制和分段机制都是为了提高内存利用率，产生较少的内存碎片。</p>
</li>
<li><p>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是每个页和段中的内存是连续的。</p>
</li>
</ul>
</li>
<li><p>分页和分段的区别</p>
<ul>
<li><p>页的大小是固定的，由操作系统决定，而段的大小不固定，取决于我们当前运行的程序。</p>
</li>
<li><p>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，它含有一组其意义相对完整的信息，在程序中可以体现为代码段，数据段，是为了满足用户的需要。</p>
</li>
<li><p>分页的作业地址空间是维一的，即单一的线性空间，程序员只须利用一个记忆符，即可表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</p>
</li>
<li><p>段一般比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121550258.png" alt="image-20240512155014746"></p>
</li>
<li><p>下图是一种比较复杂的设计，一般不采用</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121551856.png" alt="image-20240512155154382"></p>
</li>
<li><p>为简单起见，可采用平坦模型，分为基础平坦模式和带保护的平坦模式。</p>
</li>
<li><p><strong>本项目采用基础平坦模式。</strong></p>
<ul>
<li><code>CS</code>指向代码段；剩余寄存器指向数据段；</li>
<li>两个段的起始地址均为<code>0</code>，大小为<code>4GB</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121555355.png" alt="image-20240512155513883"></p>
</li>
<li><p>从逻辑地址转换到线性地址</p>
<ul>
<li>举例，对于逻辑地址<code>0x8:0x1234</code>：<ul>
<li><code>0x8</code>对应<code>GDT</code>的表项<code>1</code>；</li>
<li><code>GDT</code>的表项<code>1</code>中基地址为<code>0x10000</code>，因此线性地址为<code>0x11234</code>。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121558156.png" alt="image-20240512155843842"></p>
</li>
<li><p>对于上文所述的<code>0x8</code>，观察选择子的结构可以得知，低<code>3</code>位用于其他用途，剩余位用于判断索引<code>index</code>。因此<code>0x8 = (b)00001000</code>，因此对应表项1。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121603986.png" alt="image-20240512160330889" style="zoom:50%;" /></li>
</ul>
<h3 id="2、内存访问的整体流程"><a href="#2、内存访问的整体流程" class="headerlink" title="2、内存访问的整体流程"></a>2、内存访问的整体流程</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121603112.png" alt="image-20240512160353942"></p>
<h2 id="4-3-重新加载GDT表"><a href="#4-3-重新加载GDT表" class="headerlink" title="4.3 重新加载GDT表"></a>4.3 重新加载GDT表</h2><p>在<code>loader_16.c</code>中曾经自定义了一个简单的<code>GDT</code>表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GDT表（临时用，后面内容会替换成自己的）</span></span><br><span class="line"><span class="type">uint16_t</span> gdt_table[][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xFFFF</span>, <span class="number">0x0000</span>, <span class="number">0x9A00</span>, <span class="number">0x00CF</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xFFFF</span>, <span class="number">0x0000</span>, <span class="number">0x9200</span>, <span class="number">0x00CF</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>存在以下不足：</p>
<p>1）表项过小，在后期涉及到多进程以及中断管理时需要加入新的配置项；</p>
<p>2）当前这个表存储所在的内存区域为<code>loader</code>，即数据区，在后面可能会被覆盖。</p>
<p>因此，在<code>kernel</code>工程中设计了一个包含<code>256</code>个表项的新<code>GDT</code>表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_TABLE_SIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">segment_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit15_0;</span><br><span class="line">    <span class="type">uint16_t</span> base15_0;</span><br><span class="line">    <span class="type">uint8_t</span> base23_16;</span><br><span class="line">    <span class="type">uint16_t</span> attr;</span><br><span class="line">    <span class="type">uint8_t</span> base31_24;</span><br><span class="line">&#125;<span class="type">segment_desc_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、实现细节"><a href="#2、实现细节" class="headerlink" title="2、实现细节"></a>2、实现细节</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121656373.png" alt="image-20240512165607190"></p>
<p>重新加载<code>GDT</code>表后：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121657737.png" alt="image-20240512165730560"></p>
<p>对于<code>CS</code>项：</p>
<ul>
<li><code>0008</code>：选择子</li>
<li>后面的数字则是具体的表项，包括<code>limit</code>、<code>base</code>和<code>attr</code>等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121701389.png" alt="image-20240512170129300"></p>
<h2 id="4-4-触发异常与异常简介"><a href="#4-4-触发异常与异常简介" class="headerlink" title="4.4 触发异常与异常简介"></a>4.4 触发异常与异常简介</h2><h3 id="1、理论基础-4"><a href="#1、理论基础-4" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>在程序运行过程中，有可能会发生各种异常事件，CPU需要跳转到相应的程序对这些事件进行处理。</p>
<ul>
<li>异常<ul>
<li>由于CPU内部事件所引起的中断，如程序出错（非法指令、地址越界以及除0异常等）</li>
<li>通常由于执行了现行指令所引起</li>
</ul>
</li>
<li>中断<ul>
<li>由于外部设备事件所引起的中断，如通常的磁盘中断以及打印机中断等</li>
<li>通常与现行指令无关，由外部事件引起</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122031495.png" alt="image-20240512203148228"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122032412.png" alt="image-20240512203209841"></p>
<h2 id="4-5-添加中断门描述符"><a href="#4-5-添加中断门描述符" class="headerlink" title="4.5 添加中断门描述符"></a>4.5 添加中断门描述符</h2><h3 id="1、理论基础-5"><a href="#1、理论基础-5" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>进入保护模式后，中断向量表需要重新配置。</p>
<p><code>IA-32</code>中断向量表：<code>IDTR</code>寄存器指向的<code>IDT/Interrupt Descriptor Table</code>表。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122035869.png" alt="image-20240512203547782"></p>
<ul>
<li><code>IDTR</code>寄存器，由<code>Base Address</code>和<code>Limit</code>组成。<ul>
<li>基地址：保存<code>IDT</code>表的起始位置</li>
<li><code>Limit</code>：指定<code>IDT</code>表的大小</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122035976.png" alt="image-20240512203508876"></p>
<ul>
<li><p><code>IDT</code>表项的具体格式</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122039950.png" alt="image-20240512203943834"></p>
<ul>
<li><p><code>Interrupt Gate</code>：本项目主要采用该格式。</p>
<ul>
<li><p>包含选择子、偏移量以及一些其他的标志位。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122044231.png" alt="image-20240512204443158" style="zoom: 80%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IDT表项/Interrupt Gate中断门表项</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">gate_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> offset15_0;</span><br><span class="line">    <span class="type">uint16_t</span> selector;</span><br><span class="line">    <span class="type">uint16_t</span> attr;</span><br><span class="line">    <span class="type">uint16_t</span> offset31_16;</span><br><span class="line">&#125;<span class="type">gate_desc_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置IDT表项/中断门表项 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gate_desc_set</span> <span class="params">(<span class="type">gate_desc_t</span> *desc, <span class="type">uint16_t</span> selector, <span class="type">uint32_t</span> offset, <span class="type">uint16_t</span> attr)</span> &#123;</span><br><span class="line">    desc-&gt;offset15_0 = offset &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    desc-&gt;selector = selector;</span><br><span class="line">    desc-&gt;attr = attr;</span><br><span class="line">    desc-&gt;offset31_16 = (offset &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行初始化后可以看到<code>IDT</code>的值被设置为<code>idt_table</code>的首地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">irq_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空IDT表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IDT_TABLE_NR; i++) &#123;</span><br><span class="line">        gate_desc_set(idt_table + i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将IDTR寄存器指向IDT表</span></span><br><span class="line">    lidt((<span class="type">uint32_t</span>)idt_table, <span class="keyword">sizeof</span>(idt_table));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122109920.png" alt="image-20240512210927867"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122109701.png" alt="image-20240512210916635"></p>
<h2 id="4-6-捕获除0异常"><a href="#4-6-捕获除0异常" class="headerlink" title="4.6 捕获除0异常"></a>4.6 捕获除0异常</h2><h3 id="1、为所有异常配置缺省的处理程序"><a href="#1、为所有异常配置缺省的处理程序" class="headerlink" title="1、为所有异常配置缺省的处理程序"></a>1、为所有异常配置缺省的处理程序</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122113907.png" alt="image-20240512211301703"></p>
<p>设置缺省处理程序时，由于基地址为<code>0</code>，只需将处理程序的起始地址赋值给<code>offset</code>，然后将<code>IDT</code>的选择子设置为代码段的选择子即可。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122124096.png" alt="image-20240512212443637"></p>
<p>注意：中断处理程序只能用汇编来写，而不能用C语言来写！</p>
<blockquote>
<p>中断处理程序需要使用 <code>iret</code> 指令来正确地恢复被中断的程序的执行状态。<code>iret</code> 指令用于从中断处理程序返回到被中断的程序，并恢复被中断程序的执行现场，包括栈指针、标志寄存器和程序计数器等。</p>
<p>在 x86 架构中，<code>iret</code> 指令不能在 C 函数中直接使用，因为 C 函数的结尾通常是 <code>ret</code> 指令，这个指令只能用于从函数返回，而不能正确地恢复中断处理程序的执行状态。</p>
<p>因此，为了正确处理中断，特别是在中断处理程序中使用 <code>iret</code> 指令，需要使用汇编语言编写中断处理程序。只有在汇编语言中，可以直接使用 <code>iret</code> 指令来正确地返回到被中断的程序。</p>
</blockquote>
<h3 id="2、除0异常发生"><a href="#2、除0异常发生" class="headerlink" title="2、除0异常发生"></a>2、除0异常发生</h3><p>当发生除<code>0</code>异常时，首先会跳转到<code>iret</code>指令，</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122152287.png" alt="image-20240512215244219"></p>
<p>接下按<code>F11</code>单步调试，然后又会回到除<code>0</code>指令（<code>int a = 3 / 0</code>）上，</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122149517.png" alt="image-20240512214929396"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122150962.png" alt="image-20240512215020824"></p>
<p>再次处理发现仍旧无法解决，因此又会回到<code>iret</code>指令，</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122152287.png" alt="image-20240512215244219"></p>
<p>这样就会陷入死循环。因此在用户端程序遇到异常时一般需要将程序杀掉，但在操作系统中则无法处理，因此一般采用死机的处理。</p>
<p>详述“死机”的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exception_handle_unkown:</span><br><span class="line">    call do_handler_unkown</span><br><span class="line">    iret </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_default_handle</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_unkown</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    do_default_handle(<span class="string">&quot;unkown exception&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发现除<code>0</code>异常时：</p>
<p>-&gt; <code>exception_handle_unkown</code></p>
<p>-&gt; <code>do_handler_unkown</code></p>
<p>-&gt; <code>do_default_handle</code></p>
<p>-&gt; 进入死循环，即死机</p>
<h3 id="3、预先保存寄存器状态"><a href="#3、预先保存寄存器状态" class="headerlink" title="3、预先保存寄存器状态"></a>3、预先保存寄存器状态</h3><p>此外，在跳转到中断处理程序开始处理中断之前，需要先保存当前寄存器的状态，以防止后续对寄存器进行修改。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122236298.png" alt="image-20240512223603745"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exception_handle_unkown:</span><br><span class="line">    # 寄存器压栈</span><br><span class="line">    pusha</span><br><span class="line">    push %ds</span><br><span class="line">    push %es</span><br><span class="line">    push %fs</span><br><span class="line">    push %gs</span><br><span class="line"></span><br><span class="line">    call do_handler_unkown</span><br><span class="line"></span><br><span class="line">    # 寄存器出栈</span><br><span class="line">    pop %gs</span><br><span class="line">    pop %fs</span><br><span class="line">    pop %es</span><br><span class="line">    pop %ds</span><br><span class="line">    popa</span><br><span class="line"></span><br><span class="line">    iret </span><br></pre></td></tr></table></figure>

<p>注意：此处不必压栈<code>ss</code>和<code>esp</code>寄存器，原因如下：</p>
<blockquote>
<ol>
<li><strong>特权级不变</strong>： 在x86保护模式下，当从一个特权级（例如内核模式，特权级0）中断或异常到同一特权级时，不会自动保存 <code>ss</code> 和 <code>esp</code> 寄存器。仅当从低特权级（如用户模式，特权级3）切换到高特权级（如内核模式，特权级0）时，才会自动保存 <code>ss</code> 和 <code>esp</code> 寄存器。</li>
<li><strong>特权级切换</strong>： 如果特权级发生变化，例如从用户模式（特权级3）切换到内核模式（特权级0），CPU 会自动将 <code>ss</code> 和 <code>esp</code> 压入堆栈。为了处理这种情况，你需要一个包含 <code>ss</code> 的扩展结构体。</li>
</ol>
</blockquote>
<h2 id="4-7-解析异常栈信息"><a href="#4-7-解析异常栈信息" class="headerlink" title="4.7 解析异常栈信息"></a>4.7 解析异常栈信息</h2><h3 id="1、理论基础-6"><a href="#1、理论基础-6" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p>在发生异常而跳转到异常处理程序时，希望能够知道究竟是哪里触发了异常。此时就需要查看异常栈的相关信息。</p>
</blockquote>
<p>对于下图：当异常发生后，会将<code>EFLAGS/CS/EIP/Error Code</code>压入栈中</p>
<ul>
<li><code>EFLAGS</code>保存了状态一些相关状态</li>
<li><code>EIP</code>指示了异常发生时是哪条指令触发了异常，会将对应的地址压入<code>EIP</code>中</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131022114.png" alt="image-20240513102222754"></p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/650880105">x86—EFLAGS寄存器详解【转载】</a></p>
<p><a href="https://www.cnblogs.com/Reverse-xiaoyu/p/11397584.html">EFLAGS寄存器（标志寄存器）</a></p>
</blockquote>
<p>在调试控制台查看<code>esp:0x12e28</code>开始栈的相关信息，但这样做比较繁琐。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131026877.png" alt="image-20240513102619780"></p>
<p>在进入异常处理时，用<code>pusha</code>指令主动保存了一部分：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131032907.png" alt="image-20240513103220789"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131033545.png" alt="image-20240513103300450"></p>
<p>此外，通过<code>push</code>指令压入其他寄存器：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131034526.png" alt="image-20240513103415308"></p>
<p><strong>因此，这些要获取的栈中的寄存器信息则类似于向缺省处理函数传递的参数。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131036123.png" alt="image-20240513103626832"></p>
<p>但如果按上图中那样去写，会显得过于繁琐。因此可以将其封装为结构体，从而转换为压入这个结构体的地址（作为一个指针）。</p>
<p>根据上图，当前<code>ESP</code>指向<code>GS</code>寄存器，在将<code>ES</code>到<code>EFLAGS</code>包装为结构体后，将结构体的指针压入栈中，此时这个指针指向<code>GS</code>的地址；而执行压栈操作后，<code>ESP</code>指向该指针。</p>
<ul>
<li><p>即——<code>ESP-&gt;指针-&gt;GS</code></p>
</li>
<li><p>语法为：<code>push %esp</code></p>
<blockquote>
<p>在x86汇编语言中，<code>push %esp</code> 指令用于将栈指针 <code>%esp</code> 的当前值压入栈顶。</p>
<p>1）将 <code>%esp</code> 寄存器中的当前值（即栈指针指向的地址）减去 4；</p>
<p>2）将其指向的内存位置（即原栈顶）的值复制到减去 4 后的新栈顶地址中；</p>
<p>3）然后更新 <code>%esp</code> 寄存器的值，使其指向新的栈顶地址。</p>
</blockquote>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131039358.png" alt="image-20240513103940064"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exception_handle_unkown:</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    push %esp  </span><br><span class="line">    # 由于将GS到EFLAGS这个整体作为一个结构体，此时当前esp指向GS寄存器的下一位，因此在压入栈时只需要将GS的地址压入</span><br><span class="line">    call do_handler_unkown</span><br><span class="line">    add $(1*4), %esp  # 出栈</span><br><span class="line">	</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131104164.png" alt="image-20240513110407067"></p>
<p>对比下图，可以看到获取到的栈信息和<code>Segs</code>中的相关寄存器（左）相同，且<code>eip</code>寄存器保存的即为除<code>0</code>指令（右）所对应的地址。</p>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131104668.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131105155.png" width="300"/>    
</center>

<h2 id="4-8-利用宏重用异常处理代码"><a href="#4-8-利用宏重用异常处理代码" class="headerlink" title="4.8 利用宏重用异常处理代码"></a>4.8 利用宏重用异常处理代码</h2><h3 id="1、宏重用相关"><a href="#1、宏重用相关" class="headerlink" title="1、宏重用相关"></a>1、宏重用相关</h3><p>下表展示了22种异常&#x2F;中断的类型。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131125038.png" alt="image-20240513112516959"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131125775.png" alt="image-20240513112528641"></p>
<p>如果要对这22种异常&#x2F;中断各自编写一段汇编代码，就会使得代码过于冗杂，因为仅仅只有函数名称和内部调用C函数的区别，处理的逻辑是一致的。因此考虑采用<strong>宏重用</strong>的方式。</p>
<p>注意此处</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exception_handler_\name:</span><br><span class="line">    # 错误码入栈</span><br><span class="line">    .if \with_err_code == 0</span><br><span class="line">        push $0  # 压入0表示没有错误码</span><br><span class="line">    .endif</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    # 类型编号和错误码出栈</span><br><span class="line">    add $(2*4), %esp</span><br><span class="line"></span><br><span class="line">    iret </span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<blockquote>
<p>错误想法：对于有错误码的异常类型，会自动将错误码入栈，因此最后出栈时不需要考虑它，只需要<code>add $(1*4), %esp</code>；只有对于需要手动压入错误码的异常，才需要<code>add $(2*4), %esp</code>进行手动出栈。</p>
<p>这种想法的错误在于：<code>iret</code>指令在执行时会忽略<code>Error Code</code>，也就是说不管这个异常有没有自动入栈错误码，都需要我们手动去出栈。</p>
</blockquote>
<p>设定好宏后，测试并查看对应的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exception_handler unknown, -1, 0</span><br><span class="line">exception_handler divider, 0, 0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exception_handler unknown, -1, 0</span><br><span class="line">   1002b:	6a 00                	push   $0x0</span><br><span class="line">   1002d:	6a ff                	push   $0xffffffff</span><br><span class="line">   1002f:	60                   	pusha  </span><br><span class="line">   10030:	1e                   	push   %ds</span><br><span class="line">   10031:	06                   	push   %es</span><br><span class="line">   10032:	0f a0                	push   %fs</span><br><span class="line">   10034:	0f a8                	push   %gs</span><br><span class="line">   10036:	54                   	push   %esp</span><br><span class="line">   10037:	e8 c4 01 00 00       	call   10200 &lt;do_handler_unknown&gt;</span><br><span class="line">   1003c:	83 c4 04             	add    $0x4,%esp</span><br><span class="line">   1003f:	0f a9                	pop    %gs</span><br><span class="line">   10041:	0f a1                	pop    %fs</span><br><span class="line">   10043:	07                   	pop    %es</span><br><span class="line">   10044:	1f                   	pop    %ds</span><br><span class="line">   10045:	61                   	popa   </span><br><span class="line">   10046:	83 c4 08             	add    $0x8,%esp</span><br><span class="line">   10049:	cf                   	iret   </span><br><span class="line">  </span><br><span class="line">0001004a &lt;exception_handler_divider&gt;:</span><br><span class="line">   1004a:	6a 00                	push   $0x0</span><br><span class="line">   1004c:	6a 00                	push   $0x0</span><br><span class="line">   1004e:	60                   	pusha  </span><br><span class="line">   1004f:	1e                   	push   %ds</span><br><span class="line">   10050:	06                   	push   %es</span><br><span class="line">   10051:	0f a0                	push   %fs</span><br><span class="line">   10053:	0f a8                	push   %gs</span><br><span class="line">   10055:	54                   	push   %esp</span><br><span class="line">   10056:	e8 bb 01 00 00       	call   10216 &lt;do_handler_divider&gt;</span><br><span class="line">   1005b:	83 c4 04             	add    $0x4,%esp</span><br><span class="line">   1005e:	0f a9                	pop    %gs</span><br><span class="line">   10060:	0f a1                	pop    %fs</span><br><span class="line">   10062:	07                   	pop    %es</span><br><span class="line">   10063:	1f                   	pop    %ds</span><br><span class="line">   10064:	61                   	popa   </span><br><span class="line">   10065:	83 c4 08             	add    $0x8,%esp</span><br><span class="line">   10068:	cf                   	iret   </span><br></pre></td></tr></table></figure>

<h3 id="2、向IDT表项中安装中断处理程序"><a href="#2、向IDT表项中安装中断处理程序" class="headerlink" title="2、向IDT表项中安装中断处理程序"></a>2、向IDT表项中安装中断处理程序</h3><p>接下来编写<strong>安装中断处理程序</strong>的函数，它接受两个参数：<code>irq_num</code> 表示中断号，<code>handler</code> 是一个指向中断处理函数的指针。</p>
<ul>
<li>函数首先检查给定的中断号是否超过了 IDT 表项的范围。如果超过了，就返回 <code>-1</code> 表示失败；</li>
<li>然后，函数调用 <code>gate_desc_set</code> 函数来设置 IDT 表中的表项。<code>gate_desc_set</code> 函数的目的是将中断处理函数与指定的中断号关联起来，并将相应的中断处理函数的地址写入到 IDT 表中。这样，当相应的中断发生时，CPU 就会根据 IDT 表中的设置跳转到相应的中断处理函数；</li>
<li>最后，函数返回 <code>0</code> 表示成功安装中断处理程序。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">irq_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空IDT表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IDT_TABLE_NR; i++) &#123;</span><br><span class="line">        gate_desc_set(</span><br><span class="line">            idt_table + i, </span><br><span class="line">            KERNEL_SELECTOR_CS,</span><br><span class="line">            (<span class="type">uint32_t</span>)exception_handler_unknown, </span><br><span class="line">            GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安装中断处理程序到 IDT（中断描述符表）中</span></span><br><span class="line">    irq_install(IRQ0_DE, (<span class="type">irq_handler_t</span>)exception_handler_divider);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将IDTR寄存器指向IDT表</span></span><br><span class="line">    lidt((<span class="type">uint32_t</span>)idt_table, <span class="keyword">sizeof</span>(idt_table));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">irq_install</span> <span class="params">(<span class="type">int</span> irq_num, <span class="type">irq_handler_t</span> handler)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断异常编号是否超过IDT表项的范围</span></span><br><span class="line">    <span class="keyword">if</span> (irq_num &gt;= IDT_TABLE_NR) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置IDT表项</span></span><br><span class="line">    gate_desc_set(idt_table + irq_num, KERNEL_SELECTOR_CS, </span><br><span class="line">                (<span class="type">uint32_t</span>)handler, GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131532647.png" alt="image-20240513153252414"></p>
<p>按照前述方式，可对其他类型的异常进行类似的处理。</p>
<h2 id="4-9-初始化中断控制器"><a href="#4-9-初始化中断控制器" class="headerlink" title="4.9 初始化中断控制器"></a>4.9 初始化中断控制器</h2><h3 id="1、理论基础-7"><a href="#1、理论基础-7" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p> CPU如何管理系统中的中断？</p>
</blockquote>
<p>一个<code>8259</code>芯片可以接收<code>IRQ0-IRQ7</code>共<code>8</code>个信号，当接收到相应的中断信号时，在内部进行处理，并通过<code>INT</code>信号连接到<code>CPU</code>，并向<code>CPU</code>发出中断请求。</p>
<p>由于个数限制，早期的<code>x86</code>处理器级联两片<code>8259</code>，接收共<code>15</code>个中断信号，其中一块芯片的<code>IR2</code>用于和另一块芯片连接。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131707991.png" alt="image-20240513170754592"></p>
<p>随着多核处理器的发展，<code>8259</code>被<code>APIC</code>替代。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131857119.png" alt="image-20240513185732842"></p>
<p><code>8259A</code>的内部结构图</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131859253.png" alt="image-20240513185944144"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131901488.png" alt="image-20240513190140086"></p>
<p><code>8259A</code>的初始化流程</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131902640.png" alt="image-20240513190216562"></p>
<blockquote>
<p><strong>8259的相关参考资料</strong></p>
<ul>
<li>《8259.pdf》</li>
<li><a href="https://wiki.osdev.org/PIC">osdev关于8259的文档</a></li>
<li>《LINUX内核完全剖析:基于0.12内核》第180页</li>
</ul>
</blockquote>
<h3 id="2、实现细节-1"><a href="#2、实现细节-1" class="headerlink" title="2、实现细节"></a>2、实现细节</h3><p>初始化两个<code>8259</code>芯片。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// irq.h</span></span><br><span class="line"><span class="comment">// Interrupt Controller</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW1           0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW2           0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW3           0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW4           0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_IMR            0x21</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW1           0xA0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW2           0xA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW3           0xA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW4           0xA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_IMR            0xA1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_ICW1_ALWAYS_1   (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_ICW1_ICW4       (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_ICW4_8086       (1 &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_PIC_START       0x20</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// irq.c</span></span><br><span class="line"><span class="comment">/* Interrupt Controller Initialization */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_pic</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 对两个8259芯片进行初始化</span></span><br><span class="line">    outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);</span><br><span class="line">    outb(PIC0_ICW2, IRQ_PIC_START);</span><br><span class="line">    outb(PIC0_ICW3, <span class="number">1</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    outb(PIC0_ICW4, PIC_ICW4_8086);</span><br><span class="line"></span><br><span class="line">    outb(PIC1_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);</span><br><span class="line">    outb(PIC1_ICW2, IRQ_PIC_START + <span class="number">8</span>);</span><br><span class="line">    outb(PIC1_ICW3, <span class="number">2</span>);</span><br><span class="line">    outb(PIC1_ICW4, PIC_ICW4_8086);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断屏蔽寄存器初始化</span></span><br><span class="line">    outb(PIC0_IMR, <span class="number">0xFF</span> &amp; ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>));  <span class="comment">// 不禁止来自IRQ2的中断信号，因为其用于连接从片</span></span><br><span class="line">    outb(PIC1_IMR, <span class="number">0xFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131920596.png" alt="image-20240513192023489"></p>
<p>该寄存器的相应位为1时，会屏蔽对应的中断，使得CPU不予相应。当对芯片刚完成初始化时，还未配置相应的中断处理程序，因此需要将这个寄存器先设置为全1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中断屏蔽寄存器初始化</span></span><br><span class="line">outb(PIC0_IMR, <span class="number">0xFF</span> &amp; ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>));  <span class="comment">// 不禁止来自IRQ2的中断信号，因为其用于连接从片</span></span><br><span class="line">outb(PIC1_IMR, <span class="number">0xFF</span>);</span><br></pre></td></tr></table></figure>

<h2 id="4-10-中断的打开与关闭"><a href="#4-10-中断的打开与关闭" class="headerlink" title="4.10 中断的打开与关闭"></a>4.10 中断的打开与关闭</h2><p>中断的打开与关闭受制于两个配置：</p>
<ol>
<li><code>EFLAGS</code>的<code>IF</code>标志位；</li>
<li><code>8259</code>的<code>IMR</code>寄存器。</li>
</ol>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131933225.png" width="400"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131920596.png" width="400"/>    
</center>




<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> mask = inb(PIC0_IMR) &amp; ~(<span class="number">1</span> &lt;&lt; irq_num);</span><br><span class="line"><span class="type">uint8_t</span> mask = inb(PIC0_IMR) | (<span class="number">1</span> &lt;&lt; irq_num);</span><br></pre></td></tr></table></figure>

<p><strong>分别做了什么操作？</strong></p>
<p>这两行代码分别对 PIC0 的中断屏蔽寄存器（PIC0_IMR）进行了修改操作：</p>
<ol>
<li><code>uint8_t mask = inb(PIC0_IMR) &amp; ~(1 &lt;&lt; irq_num);</code><ul>
<li>这行代码首先读取了 PIC0_IMR 寄存器的当前值，使用 <code>inb</code> 函数。</li>
<li>然后，它通过 <code>(1 &lt;&lt; irq_num)</code> 生成了一个只有第 <code>irq_num</code> 位为 0，其它位为 1 的屏蔽码。</li>
<li>最后，通过 <code>&amp;</code> 操作符，将读取的值与生成的屏蔽码进行按位与操作，将指定的中断号 <code>irq_num</code> 对应的位清零。</li>
<li>最终结果存储在 <code>mask</code> 变量中。</li>
</ul>
</li>
<li><code>uint8_t mask = inb(PIC0_IMR) | (1 &lt;&lt; irq_num);</code><ul>
<li>这行代码也是首先读取了 PIC0_IMR 寄存器的当前值，使用 <code>inb</code> 函数。</li>
<li>然后，它通过 <code>(1 &lt;&lt; irq_num)</code> 生成了一个只有第 <code>irq_num</code> 位为 1，其它位为 0 的屏蔽码。</li>
<li>最后，通过 <code>|</code> 操作符，将读取的值与生成的屏蔽码进行按位或操作，将指定的中断号 <code>irq_num</code> 对应的位设置为 1。</li>
<li>最终结果存储在 <code>mask</code> 变量中。</li>
</ul>
</li>
</ol>
<p>这两行代码的目的是对指定的中断号 <code>irq_num</code> 进行屏蔽或解除屏蔽操作，以控制该中断是否被响应。</p>
<h2 id="4-11-启动定时器并打开中断"><a href="#4-11-启动定时器并打开中断" class="headerlink" title="4.11 启动定时器并打开中断"></a>4.11 启动定时器并打开中断</h2><blockquote>
<p>参考资料</p>
<ul>
<li>《8259.pdf》</li>
<li><a href="https://wiki.osdev.org/Programmable_Interval_Timer">osdev关于8253的文档</a></li>
<li><a href="http://www.osdever.net/bkerndev/Docs/pit.htm">关于8253配置的文档</a></li>
<li>《LINUX内核完全剖析:基于0.12内核》第316页</li>
</ul>
</blockquote>
<p>示例：外部中断的产生，以及如何跳转到对应的中断处理程序中。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405132011988.png" alt="image-20240513201126601"></p>
<ul>
<li><p>8253芯片是一个可编程的计时器&#x2F;计数器芯片，它有三个独立的计时器&#x2F;计数器通道（定时器0、定时器1和定时器2）。</p>
<ol>
<li><strong>定时器0</strong>：主要用于系统时钟中断，即产生系统时钟滴答，用于操作系统的时钟中断。这是确保操作系统能够定期执行任务调度和其他定时任务的关键。</li>
<li><strong>定时器1</strong>：通常用于动态内存刷新，但在现代系统中，这一功能已经被集成到内存控制器中，定时器1基本上已经不再使用。</li>
<li><strong>定时器2</strong>：常用于扬声器的声音发生。在大多数系统中，如果没有特别的需求，也不需要初始化定时器2。</li>
</ol>
</li>
<li><p>定时器0的初始化原因</p>
<ul>
<li><p>系统时钟中断：操作系统依赖于系统时钟中断来管理时间和任务调度。通过定时器0，操作系统可以产生定时中断（通常是每秒多次），以进行以下任务：</p>
<ul>
<li><p><strong>任务调度</strong>：定时中断使得操作系统能够在多任务环境中切换任务。</p>
</li>
<li><p><strong>系统时间更新</strong>：维护系统的时间和日期。</p>
</li>
<li><p><strong>超时处理</strong>：处理某些操作的超时功能。</p>
</li>
</ul>
</li>
<li><p>通常的配置方式：初始化定时器0时，设置它为重复模式（模式3，即方波模式），并指定合适的计数值，以产生所需频率的中断。例如，如果需要每秒产生100个中断（100Hz），则可以根据时钟频率和目标频率计算合适的计数值。</p>
</li>
</ul>
</li>
<li><p>初始化定时器0的步骤</p>
<p><strong>本项目中，只需要一个可以周期性产生中断的定时器，无需考虑各种硬件方面的东西。</strong>因此，只需要将定时器设置成自动周期性触发中断即可，而模式<code>3</code>可以方便的实现此功能，因此选用的模式<code>3</code>其它模式较为复杂，有的需要和硬件配合，有的需要在中断中重新配置定时器，所以没有使用这些模式。</p>
</li>
</ul>
<p><code>8253</code>端口地址与说明</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405140922412.png" alt="image-20240514092203861"></p>
<blockquote>
<p>（注：无论是手册上还是各种资料上关于工作模式都讲得过细，特别是有些资料还讲了一些<code>8253</code>硬件输出信号的问题。这些与我们的操作系统设计没什么关系，不用看，直接跳过即可。)</p>
</blockquote>
<ul>
<li><p>定时器工作原理</p>
<p>8253&#x2F;8254定时器芯片的工作原理是基于一个固定频率的晶体振荡器（例如1193182 Hz）。该芯片有三个独立的计数器，每个计数器都有一个初始计数值，从这个值开始<strong>倒计时</strong>。倒计时完成后，计数器会溢出，触发一个中断或者在输出引脚上产生一个信号。</p>
</li>
<li><p>初始计数值的作用</p>
<ul>
<li>控制中断频率</li>
</ul>
<ul>
<li><p>通过设置不同的初始计数值，可以控制定时器的中断频率。初始计数值越大，倒计时的时间越长，生成中断的频率就越低。反之，初始计数值越小，倒计时的时间越短，生成中断的频率就越高。</p>
</li>
<li><p>具体来说，计数器的倒计时周期是晶体振荡器周期和初始计数值的乘积。假设晶体振荡器频率为<code>1193182 Hz</code>，初始计数值为计数器倒计时的周期数，那么<code>中断频率（Hz） = 振荡器频率（Hz） / 初始计数值</code>。</p>
</li>
</ul>
</li>
<li><p>计算初始计数值</p>
<p>假设我们想设置定时器<code>0</code>生成每秒<code>100</code>次的中断（即中断频率为<code>100 Hz</code>），我们需要计算初始计数值如下：</p>
<p><code>初始计数值=振荡器频率/中断频率=1193182/100=11931</code></p>
<p>这意味着，我们将定时器<code>0</code>的初始计数值设置为<code>11931</code>，它将在每经过<code>11931</code>个时钟周期后触发一次中断，产生<code>100 Hz</code>的中断频率。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exception_handler time, 0x20, 0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>0x20</code>：将<code>8253</code>芯片关联到<code>8259</code>的<code>IRQ0</code>端口，而<code>8259</code>的起始地址为<code>0x20</code>。</li>
</ul>
<h1 id="五、日志与printf格式化输出"><a href="#五、日志与printf格式化输出" class="headerlink" title="五、日志与printf格式化输出"></a>五、日志与printf格式化输出</h1><h2 id="5-1-创建日志打印接口"><a href="#5-1-创建日志打印接口" class="headerlink" title="5.1 创建日志打印接口"></a>5.1 创建日志打印接口</h2><p><strong>在操作系统内核中编写日志接口时，通常不使用C库自带的<code>printf</code>函数。</strong>这是由于以下几个关键原因：</p>
<ol>
<li><p><strong>依赖性和可移植性</strong></p>
<ul>
<li><p><strong>标准库依赖性</strong>：<code>printf</code>是标准C库的一部分，它依赖于操作系统提供的底层设施（如文件系统、IO设备、内存管理等）。在操作系统内核早期启动阶段，这些设施可能尚未初始化。</p>
</li>
<li><p><strong>可移植性问题</strong>：不同的标准库实现可能有所不同，在某些平台上，标准库可能并不适用于内核空间。</p>
</li>
</ul>
</li>
<li><p><strong>内核空间和用户空间的区别</strong></p>
<ul>
<li><p><strong>内核空间和用户空间</strong>：标准库函数如<code>printf</code>通常在用户空间中运行，而操作系统内核运行在特权的内核空间。内核代码需要直接访问硬件和内存管理，这些功能在用户空间的标准库中不可用。</p>
</li>
<li><p><strong>上下文切换</strong>：使用标准库函数可能会引起不必要的上下文切换和中断，这在内核模式下可能是不允许的或是效率低下的。</p>
</li>
</ul>
</li>
<li><p><strong>资源管理</strong></p>
<ul>
<li><p><strong>内存管理</strong>：内核必须处理自己的内存分配和管理，而标准C库中的<code>printf</code>会隐含地调用一些内存管理函数，这可能与内核的内存管理机制冲突。</p>
</li>
<li><p><strong>线程安全性</strong>：<code>printf</code>在多线程环境下的行为在内核中可能不可靠，因为内核需要处理并发性和同步问题。</p>
</li>
</ul>
</li>
<li><p><strong>性能和实时性要求</strong></p>
<ul>
<li><p><strong>性能</strong>：内核态代码通常需要高效和快速地执行，标准库的<code>printf</code>包含复杂的格式解析和输出操作，这可能带来不必要的性能开销。</p>
</li>
<li><p><strong>实时性</strong>：内核中某些操作需要实时响应，而<code>printf</code>的执行时间不可预测，这可能导致内核无法满足实时性要求。</p>
</li>
</ul>
</li>
<li><p><strong>调试和错误处理</strong></p>
<ul>
<li><p><strong>错误处理</strong>：内核需要处理低级错误，而<code>printf</code>可能引入新的故障点。例如，<code>printf</code>依赖的某些资源在内核执行时不可用或已被其他部分使用。</p>
</li>
<li><p><strong>调试支持</strong>：在内核开发过程中，使用自定义的日志函数可以提供更多控制和定制，便于内核态调试和问题追踪。</p>
</li>
</ul>
</li>
</ol>
<h2 id="5-2-实现基本的信息输出"><a href="#5-2-实现基本的信息输出" class="headerlink" title="5.2 实现基本的信息输出"></a>5.2 实现基本的信息输出</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405141437793.png" alt="image-20240514143659706"></p>
<p>在以前的计算机中有一个<code>9</code>针的串行接口<code>RS-232</code>，有两根数据线，双向通信，分别用于发送和接收数据。<strong>在本项目中会用到这个接口来实现数据的发送的接收。</strong></p>
<p>虽然现在的计算机上没有这种接口了，但是<code>QEMU</code>依然支持这种接口。选择<code>[view-&gt;serial0]</code>，则会连接到串行接口，并将串行接口发出的数据显示到此处，而不是显示在显示器上。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405141441877.png" alt="image-20240514144102736"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm/cpu_instr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM1_PORT 0x3F8     <span class="comment">// 串行接口初始地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 日志初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化串行接口，无需了解细节</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">1</span>, <span class="number">0x00</span>);  <span class="comment">// 关闭串行接口相关中断</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">3</span>, <span class="number">0x80</span>);  <span class="comment">// 数据发送速度</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">0</span>, <span class="number">0x3</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">1</span>, <span class="number">0x00</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">3</span>, <span class="number">0x03</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">2</span>, <span class="number">0xc7</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">4</span>, <span class="number">0x0F</span>);</span><br><span class="line">&#125;                  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数可变的打印模版函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = fmt;</span><br><span class="line">    <span class="comment">// 打印fmt相关内容</span></span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 串行接口忙检测</span></span><br><span class="line">        <span class="keyword">while</span> ((inb(COM1_PORT + <span class="number">5</span>) &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>)) == <span class="number">0</span>);        </span><br><span class="line">        outb(COM1_PORT, *p++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="5-3-实现字符串的格式化输出"><a href="#5-3-实现字符串的格式化输出" class="headerlink" title="5.3 实现字符串的格式化输出"></a>5.3 实现字符串的格式化输出</h2><h3 id="1、字符串的常规处理"><a href="#1、字符串的常规处理" class="headerlink" title="1、字符串的常规处理"></a>1、字符串的常规处理</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _KLIB_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _KLIB_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm/types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_strcopy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_strncopy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">void</span> *src, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_memset</span><span class="params">(<span class="type">void</span> *dest, <span class="type">uint8_t</span> v, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_memcmp</span><span class="params">(<span class="type">void</span> *d1, <span class="type">void</span> *d2, <span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _KLIB_H_</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2、字符串的格式化输出"><a href="#2、字符串的格式化输出" class="headerlink" title="2、字符串的格式化输出"></a>2、字符串的格式化输出</h3><ol>
<li><p><strong>枚举类型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>NORMAL, READ_FMT&#125; state = NORMAL;</span><br></pre></td></tr></table></figure>

<p>定义一个无名枚举类型，包含两个状态 <code>NORMAL</code> 和 <code>READ_FMT</code>，并将 <code>state</code> 变量初始化为 <code>NORMAL</code>。</p>
</li>
<li><p><strong>可变参数函数</strong><br>在 C 语言中，可以定义一个函数，使其接受可变数量的参数。这些函数通常使用 <code>&lt;stdarg.h&gt;</code> 中的宏来处理可变参数。下面是一些相关的宏：</p>
<ul>
<li><p><code>va_list</code>：声明一个变量，该变量用于访问可变参数列表。</p>
</li>
<li><p><code>va_start</code>：初始化一个 <code>va_list</code> 变量，使其指向第一个可变参数。</p>
</li>
<li><p><code>va_end</code>：清理 <code>va_list</code> 变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">va_list args;  <span class="comment">// 声明va_list变量</span></span><br><span class="line">va_start(args, fmt);  <span class="comment">// 指向第一个可变参数</span></span><br><span class="line">va_end(args);  <span class="comment">// 释放args</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>va_arg</code>：获取可变参数列表中的下一个参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *str = va_arg(args, <span class="type">char</span> *);</span><br><span class="line"><span class="comment">// 第一个参数是va_list变量</span></span><br><span class="line"><span class="comment">// 第二个参数是期望的参数类型</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    num = 12345 -&gt; 10</span></span><br><span class="line"><span class="comment">    1. 12345 % 10 = 5   12345 / 10 = 1234</span></span><br><span class="line"><span class="comment">    2. 1234  % 10 = 4   1234  / 10 = 123</span></span><br><span class="line"><span class="comment">    3. 123   % 10 = 3   123   / 10 = 12</span></span><br><span class="line"><span class="comment">    4. 12    % 10 = 2   12    / 10 = 1</span></span><br><span class="line"><span class="comment">    5. 1     % 10 = 1   1     / 10 = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_itoa</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> num, <span class="type">int</span> base)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *num2ch = &#123;<span class="string">&quot;0123456789ASBCDEF&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *p = buf;</span><br><span class="line">    <span class="type">int</span> is_negative = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅处理2/8/10/16进制</span></span><br><span class="line">    <span class="keyword">if</span> ((base != <span class="number">2</span>) &amp;&amp; (base != <span class="number">8</span>) &amp;&amp; (base != <span class="number">10</span>) &amp;&amp; (base != <span class="number">16</span>)) &#123;</span><br><span class="line">        *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若为负数，则添加负号</span></span><br><span class="line">    <span class="keyword">if</span> ((num &lt; <span class="number">0</span>) &amp;&amp; (base == <span class="number">10</span>)) &#123;</span><br><span class="line">        is_negative = <span class="number">1</span>;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// num to string</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">char</span> ch = num2ch[num % base];</span><br><span class="line">        *p++ = ch;</span><br><span class="line">        num /= base;       </span><br><span class="line">    &#125;<span class="keyword">while</span> (num);</span><br><span class="line">    <span class="keyword">if</span> (is_negative) &#123;</span><br><span class="line">        *p++ = <span class="string">&#x27;-&#x27;</span>;  <span class="comment">// 若为负数，添加负号，注意放到最后以便后续进行翻转</span></span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转字符串</span></span><br><span class="line">    <span class="type">char</span> *start = buf;</span><br><span class="line">    <span class="type">char</span> *end = p - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> ch = *start;</span><br><span class="line">        *start = *end;</span><br><span class="line">        *end = ch;</span><br><span class="line"></span><br><span class="line">        end--;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_printf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理可变字符串</span></span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);  </span><br><span class="line">    kernel_vsprintf(buf, fmt, args);</span><br><span class="line">    va_end(args);  <span class="comment">// 释放args</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;Version: %s&quot;, &quot;1.0.0&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span> &#123;</span><br><span class="line">    <span class="comment">// NORMAL：原样输出状态  READ_FMT：格式化输出状态</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>NORMAL, READ_FMT&#125; state = NORMAL;</span><br><span class="line">    <span class="type">char</span> *curr = buf;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = *fmt++)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (state)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> NORMAL:</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">                state = READ_FMT;  <span class="comment">// 当遇到&#x27;%&#x27;时需要切换到格式化输出状态</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *curr++ = ch;   <span class="comment">// 否则直接原样输出即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> READ_FMT:</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;d&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> num = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                kernel_itoa(curr, num, <span class="number">10</span>);  <span class="comment">// int型变量转换为ASCII码对应的字符串</span></span><br><span class="line">                curr += kernel_strlen(curr);  <span class="comment">// curr进行跳转</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> num = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                kernel_itoa(curr, num, <span class="number">16</span>);  <span class="comment">// int型变量转换为ASCII码对应的字符串</span></span><br><span class="line">                curr += kernel_strlen(curr);  <span class="comment">// curr进行跳转</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">char</span> c = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                *curr++ = c;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *str = va_arg(args, <span class="type">char</span> *);  <span class="comment">// 此时const char *str = &quot;1.0.0&quot;</span></span><br><span class="line">                <span class="type">int</span> len = kernel_strlen(str);</span><br><span class="line">                <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">                    *curr++ = *str++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state = NORMAL;  <span class="comment">// 处理完可变参数，切换回NORMAL状态</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-利用assert辅助调试"><a href="#5-4-利用assert辅助调试" class="headerlink" title="5.4 利用assert辅助调试"></a>5.4 利用assert辅助调试</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RELEASE  <span class="comment">// 若未定义RELEASE版本，说明在调试状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(expr)    \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!(expr)) pannic(__FILE__, __LINE__, __func__, #expr);</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pannic</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span> *func, <span class="type">const</span> <span class="type">char</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(expr)    ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="六、实现简单的进程切换"><a href="#六、实现简单的进程切换" class="headerlink" title="六、实现简单的进程切换"></a>六、实现简单的进程切换</h1><h2 id="6-1-添加任务状态段"><a href="#6-1-添加任务状态段" class="headerlink" title="6.1 添加任务状态段"></a>6.1 添加任务状态段</h2><p><strong>目前的代码中，中断处理程序处理中断相关的工作，主程序负责执行所有其它工作</strong>（仅考虑只有一个CPU内核的情况）。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142022102.png" alt="image-20240514202203665" style="zoom: 50%;" />

<p>借助于操作系统的进程切换机制，我们可以同时运行多个程序。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142023040.png" alt="image-20240514202342715" style="zoom:50%;" />

<p>现在考虑实现这样一个任务，即利用进程切换机制，同时实现以下两个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;init task: %d&quot;</span>, count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a = 3 / 0;</span></span><br><span class="line">    <span class="comment">// irq_enable_global();</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;init main: %d&quot;</span>, count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、理论基础-8"><a href="#1、理论基础-8" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>操作系统为了让CPU能够同时执行多个程序，在切换到另一个程序运行前需要<strong>记录当前程序的运行状态</strong>。<br>这样当程序再次运行时，才能够恢复到之前的运行状态。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142039947.png" alt="image-20240514203914718" style="zoom:50%;" />

<ul>
<li><code>TSS/Task-State Segment</code>：保存当前程序的运行状态。（用<code>Task</code>表示进程的运行状态）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142038829.png" alt="image-20240514203814450"></p>
<h3 id="2、TSS定义"><a href="#2、TSS定义" class="headerlink" title="2、TSS定义"></a>2、TSS定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TSS/Task-State Segment r 任务状态段</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tss_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> pre_link;      <span class="comment">// 上一个任务链接</span></span><br><span class="line">    <span class="type">uint32_t</span> esp0, ss0;     <span class="comment">// 内核模式下的栈指针和栈段选择子</span></span><br><span class="line">    <span class="type">uint32_t</span> esp1, ss1;     <span class="comment">// 备用栈指针和栈段选择子（通常不使用）</span></span><br><span class="line">    <span class="type">uint32_t</span> esp2, ss2;     <span class="comment">// 备用栈指针和栈段选择子（通常不使用）</span></span><br><span class="line">    <span class="type">uint32_t</span> cr3;           <span class="comment">// 页目录基地址寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> eip;           <span class="comment">// 指令指针寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> eflags;        <span class="comment">// 标志寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi; <span class="comment">// 通用寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> es, cs, ss, ds, fs, gs; <span class="comment">// 段寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> ldt;           <span class="comment">// 局部描述符表的段选择子</span></span><br><span class="line">    <span class="type">uint32_t</span> iomap;         <span class="comment">// I/O许可位图的基地址</span></span><br><span class="line">&#125;<span class="type">tss_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>TSS</code>如何描述任务状态？</p>
<ul>
<li><p><code>TSS</code>中各字段的分类</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142050761.png" alt="image-20240514205059174"></p>
</li>
<li><p>程序的运行状态，包含了诸多信息：</p>
<ul>
<li>当前正执行哪些代码、有哪些数据、使用了哪块区域做堆栈、当前执行指令的地址、前一指令的运行状态、运算所用的寄存器信息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142057431.png" alt="image-20240514205712046"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142115267.png" alt="image-20240514211539824"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142117502.png" alt="image-20240514211733961"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142118228.png" alt="image-20240514211833645"></p>
</li>
</ul>
<h2 id="6-2-任务的简单初始化"><a href="#6-2-任务的简单初始化" class="headerlink" title="6.2 任务的简单初始化"></a>6.2 任务的简单初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> *      TSS Initialization </span></span><br><span class="line"><span class="comment"> *      当有程序/进程第一次运行时会调用tss_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tss_init</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    kernel_memset(&amp;task-&gt;tss, <span class="number">0</span>, <span class="keyword">sizeof</span>(task-&gt;tss));</span><br><span class="line">    task-&gt;tss.eip = entry;  <span class="comment">// 调用tss_init的函数的入口地址（该函数第一次运行）</span></span><br><span class="line">    task-&gt;tss.esp = task-&gt;tss.esp0 = esp;  <span class="comment">// 指示调用tss_init的函数的栈顶的位置（此时栈为空）</span></span><br><span class="line">    task-&gt;tss.ss = task-&gt;tss.ss0 = KERNEL_SELECTOR_DS;  <span class="comment">// 由于第一次运行，因此寄存器设置为默认的选择子</span></span><br><span class="line">    task-&gt;tss.es = task-&gt;tss.ds = task-&gt;tss.fs = task-&gt;tss.gs = KERNEL_SELECTOR_DS;</span><br><span class="line">    task-&gt;tss.cs = KERNEL_SELECTOR_CS;</span><br><span class="line">    task-&gt;tss.eflags = EFLAGS_DEFAULT | EFLAGS_IF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task Initializtion */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ASSERT((task != (<span class="type">task_t</span> *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    tss_init(task, entry, esp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-简单双任务相互切换"><a href="#6-3-简单双任务相互切换" class="headerlink" title="6.3 简单双任务相互切换"></a>6.3 简单双任务相互切换</h2><h3 id="1、理论"><a href="#1、理论" class="headerlink" title="1、理论"></a>1、理论</h3><p><code>x86</code>硬件对于任务的管理包括：</p>
<ul>
<li><code>Task Register/TR寄存器</code>：保存了<code>Task</code>相关的选择子</li>
<li><code>TSS</code>描述符：<code>GDT</code>表中的<code>TSS Desc</code>表项，每个<code>TSS</code>有自己对应的描述符</li>
<li><code>TSS</code></li>
<li>任务的代码、数据和栈空间</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405150949978.png" alt="image-20240515094947839"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405150958664.png" alt="image-20240515095802569"></p>
<h3 id="2、采用JMP进行任务切换"><a href="#2、采用JMP进行任务切换" class="headerlink" title="2、采用JMP进行任务切换"></a>2、采用JMP进行任务切换</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151000598.png" alt="image-20240515100023458" style="zoom:50%;" />

<blockquote>
<p>解答一下<code>task init(&amp;first task,0,0)</code>两个参数为<code>0</code>的问题：由于<code>first task</code>在<code>kernel</code>跑起来后已经运行，因此并不需要从<code>tss</code>中加载初始化的值，所以里面的值无所谓，并且在后面切换到<code>init task</code>时会因保存状态而被改写。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">task_t</span> sub_task;</span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> first_task;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> init_task_stack[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;sub task: %d&quot;</span>, count++);</span><br><span class="line">        task_switch_from_to(&amp;sub_task, &amp;first_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a = 3 / 0;</span></span><br><span class="line">    <span class="comment">// irq_enable_global();</span></span><br><span class="line">    task_init(&amp;sub_task, (<span class="type">uint32_t</span>)init_task_entry, (<span class="type">uint32_t</span>)&amp;init_task_stack[<span class="number">1024</span>]);</span><br><span class="line">    task_init(&amp;first_task, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// ?-&gt;看上面的引用部分，有相关解释</span></span><br><span class="line">    write_tr(first_task.tss_sel);  <span class="comment">// 对TR寄存器初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;main task: %d&quot;</span>, count++);</span><br><span class="line">        task_switch_from_to(&amp;first_task, &amp;sub_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Task Switch */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_switch_from_to</span> <span class="params">(<span class="type">task_t</span> *from, <span class="type">task_t</span> *to)</span> &#123;</span><br><span class="line">    switch_to_tss(to-&gt;tss_sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 远跳转实现任务切换 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">switch_to_tss</span> <span class="params">(<span class="type">int</span> tss_sel)</span> &#123;</span><br><span class="line">    far_jump(tss_sel, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-4-另一种任务切换方式"><a href="#6-4-另一种任务切换方式" class="headerlink" title="6.4 另一种任务切换方式"></a>6.4 另一种任务切换方式</h2><h3 id="1、理论基础-9"><a href="#1、理论基础-9" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p>任务切换的本质是保存前一任务的运行状态，恢复下一任务的运行状态。</p>
</blockquote>
<p>硬件实际上会帮助我们去自动保存这些状态，但是如果采用手动保存的方式，切换会更快。</p>
<p>需要保存的状态如下。<strong>可以为这些状态单独设置空间保存，也可以直接将其保存在任务自己的栈中。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151054801.png" alt="image-20240515105445584" style="zoom:50%;" />

<p>当然，对于上述状态也可以进行选择性保存：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151058922.png" alt="image-20240515105836713"></p>
<p>因此，最终只需要保存少量的寄存器就可以实现任务切换：</p>
<ul>
<li>注意<code>esp</code>指示此处的栈顶位置，因此要在别处单独存放。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151454378.png" alt="image-20240515145411029" style="zoom:50%;" />

<h3 id="2、代码实现-1"><a href="#2、代码实现-1" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 描述程序/进程运行状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>    *<span class="built_in">stack</span>;     <span class="comment">// 当前Task的任务栈</span></span><br><span class="line">    <span class="type">tss_t</span>       tss;        <span class="comment">// TSS段</span></span><br><span class="line">    <span class="type">int</span>         tss_sel;    <span class="comment">// Task Selector</span></span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel-&gt;init-&gt;init.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> sub_task;</span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> first_task;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> init_task_stack[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;sub task: %d&quot;</span>, count++);</span><br><span class="line">        task_switch_from_to(&amp;sub_task, &amp;first_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a = 3 / 0;</span></span><br><span class="line">    <span class="comment">// irq_enable_global();</span></span><br><span class="line">    task_init(&amp;sub_task, (<span class="type">uint32_t</span>)init_task_entry, (<span class="type">uint32_t</span>)&amp;init_task_stack[<span class="number">1024</span>]);</span><br><span class="line">    task_init(&amp;first_task, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    write_tr(first_task.tss_sel);  <span class="comment">// 对TR寄存器初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;main task: %d&quot;</span>, count++);</span><br><span class="line">        task_switch_from_to(&amp;first_task, &amp;sub_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel-&gt;core-&gt;task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task Initializtion */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ASSERT((task != (<span class="type">task_t</span> *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tss_init(task, entry, esp);</span></span><br><span class="line">    <span class="type">uint32_t</span> *pesp = (<span class="type">uint32_t</span> *)esp;  <span class="comment">// 取出当前栈顶指针</span></span><br><span class="line">    <span class="keyword">if</span> (pesp) &#123;  </span><br><span class="line">        <span class="comment">// 将任务入口地址入栈</span></span><br><span class="line">        *(--pesp) = entry;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置edi, esi, ebx, ebp</span></span><br><span class="line">        *(--pesp) = <span class="number">0</span>;</span><br><span class="line">        *(--pesp) = <span class="number">0</span>;</span><br><span class="line">        *(--pesp) = <span class="number">0</span>;</span><br><span class="line">        *(--pesp) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前栈指针保存到任务结构体中</span></span><br><span class="line">        task-&gt;<span class="built_in">stack</span> = pesp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      **from      指向[当前任务的栈指针]的指针</span></span><br><span class="line"><span class="comment"> *      *to         指向[新任务]的栈指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">simple_switch</span> <span class="params">(<span class="type">uint32_t</span> **from, <span class="type">uint32_t</span> *to)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task Switch */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_switch_from_to</span> <span class="params">(<span class="type">task_t</span> *from, <span class="type">task_t</span> *to)</span> &#123;</span><br><span class="line">    <span class="comment">// switch_to_tss(to-&gt;tss_sel);</span></span><br><span class="line">    simple_switch(&amp;from-&gt;<span class="built_in">stack</span>, to-&gt;<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">simple_switch:</span><br><span class="line">    # 向当前Task对应的栈压栈</span><br><span class="line">    mov 4(%esp), %eax    # 将当前任务的栈指针地址（**from）传递给eax</span><br><span class="line">    mov 8(%esp), %edx    # 将下一个任务的栈指针地址（*to）传递给edx</span><br><span class="line"></span><br><span class="line">    push %ebp            # 保存当前任务的ebp寄存器</span><br><span class="line">    push %ebx            # 保存当前任务的ebx寄存器</span><br><span class="line">    push %esi            # 保存当前任务的esi寄存器</span><br><span class="line">    push %edi            # 保存当前任务的edi寄存器</span><br><span class="line"></span><br><span class="line">    # 从另一个任务的栈中出栈</span><br><span class="line">    mov %esp, (%eax)     # 保存当前任务的esp到eax指向的内存中（保存当前任务的栈指针）</span><br><span class="line">    mov %edx, %esp       # 切换到下一个任务的栈指针（esp指向新任务的栈顶）</span><br><span class="line">    pop %edi             # 恢复下一个任务的edi寄存器</span><br><span class="line">    pop %esi             # 恢复下一个任务的esi寄存器</span><br><span class="line">    pop %ebx             # 恢复下一个任务的ebx寄存器</span><br><span class="line">    pop %ebp             # 恢复下一个任务的ebp寄存器</span><br><span class="line"></span><br><span class="line">    ret                  # 返回，切换到下一个任务的执行</span><br></pre></td></tr></table></figure>

<h1 id="七、实现链表数据结构"><a href="#七、实现链表数据结构" class="headerlink" title="七、实现链表数据结构"></a>七、实现链表数据结构</h1><h2 id="7-1-定义结点和链表"><a href="#7-1-定义结点和链表" class="headerlink" title="7.1 定义结点和链表"></a>7.1 定义结点和链表</h2><p>在进程运行过程中，可能因为多种原因需要等待，从而加入相应的等待队列中。如下图共有三个队列，其中就绪队列中的进程已经准备好了，随时可以运行，只是在等待处理器空闲。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151550561.png" alt="image-20240515155011285" style="zoom:50%;" />

<p>考虑到系统中可能有很多进程，因此采用链表结构进行管理。</p>
<img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240515155549617.png" alt="image-20240515155549617" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list_node_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">list_node_t</span> *<span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">list_node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;<span class="type">list_node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_node_init</span> <span class="params">(<span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    node-&gt;pre = node-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">list_node_t</span> *<span class="title function_">list_node_pre</span> <span class="params">(<span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">list_node_t</span> *<span class="title function_">list_node_next</span> <span class="params">(<span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list_t</span> &#123;</span></span><br><span class="line">    <span class="type">list_node_t</span> *first;</span><br><span class="line">    <span class="type">list_node_t</span> *last;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;<span class="type">list_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_init</span> <span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-链表的两种插入"><a href="#7-2-链表的两种插入" class="headerlink" title="7.2 链表的两种插入"></a>7.2 链表的两种插入</h2><h3 id="1、头插"><a href="#1、头插" class="headerlink" title="1、头插"></a>1、头插</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151634229.png" alt="image-20240515163412939" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头插</span></span><br><span class="line"><span class="comment"> * @param list 待插入的链表</span></span><br><span class="line"><span class="comment"> * @param node 待插入的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_first</span><span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>, <span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置node</span></span><br><span class="line">    node-&gt;next = <span class="built_in">list</span>-&gt;first;</span><br><span class="line">    node-&gt;pre = (<span class="type">list_node_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list_is_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">        <span class="comment">// 若list为空，则first &amp; last均指向node</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;last = <span class="built_in">list</span>-&gt;first = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，仅调整first指向</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;first-&gt;pre = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;first = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、尾插"><a href="#2、尾插" class="headerlink" title="2、尾插"></a>2、尾插</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151730245.png" alt="image-20240515173058966" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾插</span></span><br><span class="line"><span class="comment"> * @param list 操作的链表</span></span><br><span class="line"><span class="comment"> * @param node 待插入的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_last</span><span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>, <span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置node</span></span><br><span class="line">    node-&gt;pre = <span class="built_in">list</span>-&gt;last;</span><br><span class="line">    node-&gt;next = (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list_is_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">        <span class="comment">// 若list为空，则first &amp; last均指向node</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;first = <span class="built_in">list</span>-&gt;last = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，仅调整last指向</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;last-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;last = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-链表的两种删除"><a href="#7-3-链表的两种删除" class="headerlink" title="7.3 链表的两种删除"></a>7.3 链表的两种删除</h2><h3 id="1、头删"><a href="#1、头删" class="headerlink" title="1、头删"></a>1、头删</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151731170.png" alt="image-20240515173113880" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头删</span></span><br><span class="line"><span class="comment"> * @param list 操作的链表</span></span><br><span class="line"><span class="comment"> * @return 链表的第一个结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">list_node_t</span>* <span class="title function_">list_remove_first</span><span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// list为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (list_is_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取要删除的结点</span></span><br><span class="line">    <span class="type">list_node_t</span> * remove_node = <span class="built_in">list</span>-&gt;first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改first指向</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;first = remove_node-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;first == (<span class="type">list_node_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 若list为空，修改last也指向空</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;last = (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若list非空，修改当前first的前驱为0</span></span><br><span class="line">        remove_node-&gt;next-&gt;pre = (<span class="type">list_node_t</span> *)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改node的pre和next为0</span></span><br><span class="line">    remove_node-&gt;next = remove_node-&gt;pre = (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;count--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> remove_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、删除任意结点"><a href="#2、删除任意结点" class="headerlink" title="2、删除任意结点"></a>2、删除任意结点</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151731210.png" alt="image-20240515173125900" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除任意结点，但不检查node是否在list中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">list_node_t</span> * <span class="title function_">list_remove</span><span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>, <span class="type">list_node_t</span> *remove_node)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是头，则头往前移</span></span><br><span class="line">    <span class="keyword">if</span> (remove_node == <span class="built_in">list</span>-&gt;first) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;first = remove_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是尾，则尾往回移</span></span><br><span class="line">    <span class="keyword">if</span> (remove_node == <span class="built_in">list</span>-&gt;last) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;last = remove_node-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有前，则调整前的后继</span></span><br><span class="line">    <span class="keyword">if</span> (remove_node-&gt;pre) &#123;</span><br><span class="line">        remove_node-&gt;pre-&gt;next = remove_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有后，则调整后的前驱</span></span><br><span class="line">    <span class="keyword">if</span> (remove_node-&gt;next) &#123;</span><br><span class="line">        remove_node-&gt;next-&gt;pre = remove_node-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空node指向</span></span><br><span class="line">    remove_node-&gt;pre = remove_node-&gt;next = (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line">    --<span class="built_in">list</span>-&gt;count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> remove_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-4-获取结点所在的结构"><a href="#7-4-获取结点所在的结构" class="headerlink" title="7.4 获取结点所在的结构"></a>7.4 获取结点所在的结构</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152028459.png" alt="image-20240515202836119"></p>
<p>对下图的解释：</p>
<p>比如说对于下图的<code>node</code>，要取其地址用到了<code>&amp;(a-&gt;node)</code>，这一行代码实际上是完成了<code>a的基地址+offset(node相对于基地址的offset)</code>这个操作。</p>
<p>因此，如果要求解这一段<code>offset</code>，就可以假定在最开始有一个和<code>node</code>同类型的数据，这样<code>a的基地址</code>这一项就为<code>0</code>，所以求解到的就是<code>offset</code>的值。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152033989.png" alt="image-20240515203321728"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offset_in_parent(parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    ((uint32_t)&amp;(((parent_type *)0)-&gt;node_name))</span></span><br><span class="line"><span class="comment">// parent_addr  --  parent的起始地址</span></span><br><span class="line"><span class="comment">// node         --  node的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> parent_addr(node, parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    (((uint32_t)node) -  offset_in_parent(parent_type, node_name))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_node_parent(node, parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    ((parent_type *)(node ? parent_addr(node, parent_type, node_name) : 0))</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>offset_in_parent</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offset_in_parent(parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    ((uint32_t)&amp;(((parent_type *)0)-&gt;node_name))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能</strong>：计算一个节点在其父结构体中的偏移量。</li>
<li>参数<ul>
<li><code>parent_type</code>：父结构体的类型。</li>
<li><code>node_name</code>：节点在父结构体中的成员变量名。</li>
</ul>
</li>
<li><strong>实现</strong>：通过将一个空指针类型转换为 <code>parent_type</code> 并访问 <code>node_name</code> 成员，然后取该成员的地址。由于起始地址为0，这样计算出的地址即为偏移量。</li>
</ul>
</li>
<li><p><strong>parent_addr</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> parent_addr(node, parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    (((uint32_t)node) - offset_in_parent(parent_type, node_name))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能</strong>：从节点地址推导出包含该节点的父结构体的地址。</li>
<li>参数<ul>
<li><code>node</code>：节点的地址。</li>
<li><code>parent_type</code>：父结构体的类型。</li>
<li><code>node_name</code>：节点在父结构体中的成员变量名。</li>
</ul>
</li>
<li><strong>实现</strong>：通过节点地址减去节点在父结构体中的偏移量来获取父结构体的地址。</li>
</ul>
</li>
<li><p><strong>list_node_parent</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_node_parent(node, parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    ((parent_type *)(node ? parent_addr(node, parent_type, node_name) : 0))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能</strong>：从节点地址安全地获取包含该节点的父结构体的地址。</li>
<li>参数<ul>
<li><code>node</code>：节点的地址。</li>
<li><code>parent_type</code>：父结构体的类型。</li>
<li><code>node_name</code>：节点在父结构体中的成员变量名。</li>
</ul>
</li>
<li><strong>实现</strong>：如果节点不为 <code>NULL</code>，则调用 <code>parent_addr</code> 宏；否则返回 <code>NULL</code>。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_test</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">list_t</span> <span class="built_in">list</span>;</span><br><span class="line">    <span class="type">list_node_t</span> nodes[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    list_init(&amp;<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">list_node_t</span> *node = nodes + i;</span><br><span class="line">        log_printf(<span class="string">&quot;insert first to list: %d, 0x%x&quot;</span>, i, (<span class="type">uint32_t</span>)node);</span><br><span class="line">        list_insert_first(&amp;<span class="built_in">list</span>, node);</span><br><span class="line">    &#125;</span><br><span class="line">    log_printf(<span class="string">&quot;list: first=0x%x, last=0x%x, count=%d&quot;</span>,</span><br><span class="line">        list_first(&amp;<span class="built_in">list</span>), list_last(&amp;<span class="built_in">list</span>), list_count(&amp;<span class="built_in">list</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type_t</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">list_node_t</span> node;</span><br><span class="line">    &#125;v = &#123;<span class="number">0x123456</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type_t</span> *<span class="title">a</span> =</span> (<span class="keyword">struct</span> <span class="type">type_t</span> *)<span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> addr = (<span class="type">uint32_t</span>)&amp;a-&gt;node;  <span class="comment">// 4                        </span></span><br><span class="line">    <span class="type">uint32_t</span> addr_p = offset_in_parent(<span class="keyword">struct</span> <span class="type">type_t</span>, node);  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已知node的起始地址，利用定义的宏求解v的起始地址</span></span><br><span class="line">    <span class="type">list_node_t</span> *v_node = &amp;v.node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type_t</span> *<span class="title">p</span> =</span> list_node_parent(v_node, <span class="keyword">struct</span> <span class="type">type_t</span>, node);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;i != <span class="number">0x123456</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、进程的管理与延时"><a href="#八、进程的管理与延时" class="headerlink" title="八、进程的管理与延时"></a>八、进程的管理与延时</h1><h2 id="8-1-添加任务管理器"><a href="#8-1-添加任务管理器" class="headerlink" title="8.1 添加任务管理器"></a>8.1 添加任务管理器</h2><p>截止目前，只支持两个任务，切需要进程自己主动切换，不支持延时等功能。因此需要对功能进行拓展。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152102022.png" alt="image-20240515210203823" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_manager_t</span> &#123;</span></span><br><span class="line">    <span class="type">list_t</span> ready_list;  <span class="comment">// 就绪队列</span></span><br><span class="line">    <span class="type">list_t</span> task_list;   <span class="comment">// 所有已创建队列</span></span><br><span class="line">    <span class="type">task_t</span> first_task;  <span class="comment">// 最先创建的任务</span></span><br><span class="line">    <span class="type">task_t</span> *curr_task;  <span class="comment">// 当前正在进行的任务</span></span><br><span class="line">&#125;<span class="type">task_manager_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 任务管理器初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span>;    <span class="comment">// 初始任务初始化</span></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_first_take</span> <span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 返回first task</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    list_init(&amp;task_manager.ready_list);  <span class="comment">// 初始化就绪队列</span></span><br><span class="line">    list_init(&amp;task_manager.task_list);   <span class="comment">// 初始化所有任务队列</span></span><br><span class="line">    task_manager.curr_task = (<span class="type">task_t</span> *)<span class="number">0</span>; <span class="comment">// 设置当前任务为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    task_init(&amp;task_manager.first_task, <span class="number">0</span>, <span class="number">0</span>);  		<span class="comment">// Task Initialization</span></span><br><span class="line">    write_tr(task_manager.first_task.tss_sel);          <span class="comment">// 对TR寄存器初始化</span></span><br><span class="line">    task_manager.curr_task = &amp;task_manager.first_task;  <span class="comment">// 设置当前任务为first task </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_first_take</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;task_manager.first_task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-2-将任务加入就绪队列"><a href="#8-2-将任务加入就绪队列" class="headerlink" title="8.2 将任务加入就绪队列"></a>8.2 将任务加入就绪队列</h2><p>当任务已经初始化完成时，进入<code>created</code>状态；当加入就绪队列时，进入<code>ready</code>状态。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152123227.png" alt="image-20240515212313112" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述程序/进程运行状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// uint32_t    *stack;      // 当前Task的任务栈（采用链表管理任务时不再采用stack，直接用硬件的TSS支持切换）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>                      <span class="comment">// 任务状态</span></span><br><span class="line">        TASK_CREATED,</span><br><span class="line">        TASK_RUNNING,</span><br><span class="line">        TASK_SLEEP,</span><br><span class="line">        TASK_READY,</span><br><span class="line">        TASK_WAITING,</span><br><span class="line">    &#125;state;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> name[TASK_NAME_SIZE];  <span class="comment">// 任务名称</span></span><br><span class="line"></span><br><span class="line">    <span class="type">list_node_t</span> run_node;       <span class="comment">// run_node插入ready_list中，而非将整个task_t加入</span></span><br><span class="line">    <span class="type">list_node_t</span> all_node;       <span class="comment">// all_node插入task_list中</span></span><br><span class="line"></span><br><span class="line">    <span class="type">tss_t</span>       tss;            <span class="comment">// TSS段</span></span><br><span class="line">    <span class="type">int</span>         tss_sel;        <span class="comment">// Task Selector</span></span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task Initializtion */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ASSERT((task != (<span class="type">task_t</span> *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化TSS</span></span><br><span class="line">    tss_init(task, entry, esp);</span><br><span class="line">    <span class="comment">// 初始化任务</span></span><br><span class="line">    kernel_strncpy(task-&gt;name, name, TASK_NAME_SIZE);</span><br><span class="line">    task-&gt;state = TASK_CREATED;</span><br><span class="line">    <span class="comment">// 初始化结点</span></span><br><span class="line">    list_node_init(&amp;task-&gt;all_node);</span><br><span class="line">    list_node_init(&amp;task-&gt;run_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务加入ready_list</span></span><br><span class="line">    task_set_ready(task);</span><br><span class="line">    <span class="comment">// 任务加入task_list</span></span><br><span class="line">    list_insert_last(&amp;task_manager.task_list, &amp;task-&gt;all_node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_ready</span><span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    list_insert_first(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">    task-&gt;state = TASK_READY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_block</span><span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    list_remove(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3-任务主动放弃CPU"><a href="#8-3-任务主动放弃CPU" class="headerlink" title="8.3 任务主动放弃CPU"></a>8.3 任务主动放弃CPU</h2><p>为了避免某个进程长时间占用CPU，可以让进程主动释放CPU的使用权，但不应当让进程指定切换到哪个进程运行。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161022580.png" alt="image-20240516102215352"></p>
<p><strong>简单起见，当进程需要让出CPU时，只需要将自己移到就绪队列的尾部即可。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161024659.png" alt="image-20240516102441540" style="zoom:50%;" />



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的实现用到了7.4所设计的宏</span></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_next_run</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">list_node_t</span> *task_node = list_first(&amp;task_manager.ready_list);</span><br><span class="line">    <span class="keyword">return</span> list_node_parent(task_node, <span class="type">task_t</span>, run_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_current</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> task_manager.curr_task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sched_yield</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前就绪队列是否还有其他任务</span></span><br><span class="line">    <span class="keyword">if</span> (list_count(&amp;task_manager.ready_list) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 取当前任务，并将其重新加入到就绪队列尾部</span></span><br><span class="line">        <span class="type">task_t</span> *curr_task = task_current();</span><br><span class="line">        task_set_block(curr_task);</span><br><span class="line">        task_set_ready(curr_task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放CPU使用权，将进程切换到当前就绪队列的第一个任务</span></span><br><span class="line">        task_dispatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_dispatch</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *to = task_next_run();</span><br><span class="line">    <span class="keyword">if</span> (to != task_manager.curr_task) &#123;</span><br><span class="line">        <span class="type">task_t</span> *from = task_current();  <span class="comment">// 定义[原来正在运行的任务]为[将要被切换掉的任务]</span></span><br><span class="line">        task_manager.curr_task = to;    <span class="comment">// 将task_manager中[当前正在运行的任务]修改为[将要切换过去的任务]</span></span><br><span class="line">        to-&gt;state = TASK_RUNNING;       <span class="comment">// 修改此任务的状态</span></span><br><span class="line"></span><br><span class="line">        task_switch_from_to(from, to);  <span class="comment">// 执行任务切换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// init.c </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    sys_sched_yield();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    sys_sched_yield();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p> 解析上述代码</p>
</blockquote>
<p>根据<code>sys_sched_yield();</code>改写了整个任务切换的逻辑，不再由当前进程指定要切换到哪一个进程中，而是：</p>
<ol>
<li>当前进程放弃CPU使用权，重新移动到就绪队列的尾部；</li>
<li>从就绪队列中获取下一个要执【【行的任务<code>task_t *to = task_next_run()</code>；</li>
<li>定义[原来正在运行的任务]为[将要被切换掉的任务]<code>task_t *from = task_current()</code>；</li>
<li>将task_manager中[当前正在运行的任务]修改为[将要切换过去的任务]<code>task_manager.curr_task = to</code>；</li>
<li>修改此任务的状态为<code>TASK_RUNNING</code>；</li>
<li>执行任务切换<code>task_switch_from_to(from, to)</code>。</li>
</ol>
<h2 id="8-4-让进程按时间片运行"><a href="#8-4-让进程按时间片运行" class="headerlink" title="8.4 让进程按时间片运行"></a>8.4 让进程按时间片运行</h2><p><code>sys_sched_yield()</code>必须由进程主动调用才能放弃CPU，如果不主动调用，进程仍然长期占用CPU。为了避免进程长时间占用CPU，可以强制其运行一定时间后释放CPU。</p>
<p><strong>本项目中选择[一段时间]为<code>100ms</code>。</strong>通过<code>task_time_tick()</code>函数实现。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161046155.png" alt="image-20240516104613960" style="zoom:50%;" />

<p>注意：需要在<code>init.c</code>中开启全局中断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    irq_enable_global();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// sys_sched_yield();  注意要注释掉这个函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来对<code>task_init</code>进行修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Task Initializtion */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ASSERT((task != (<span class="type">task_t</span> *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化TSS</span></span><br><span class="line">    tss_init(task, entry, esp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化任务结点</span></span><br><span class="line">    kernel_strncpy(task-&gt;name, name, TASK_NAME_SIZE);</span><br><span class="line">    task-&gt;state = TASK_CREATED;</span><br><span class="line">    <span class="comment">// =========================== 加入 ========================== //</span></span><br><span class="line">    task-&gt;time_ticks = TASK_TIME_SLICE_DEFAULT;</span><br><span class="line">    task-&gt;slice_ticks = task-&gt;time_ticks;</span><br><span class="line">    <span class="comment">// ========================================================== //</span></span><br><span class="line">    list_node_init(&amp;task-&gt;all_node);</span><br><span class="line">    list_node_init(&amp;task-&gt;run_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务加入ready_list</span></span><br><span class="line">    task_set_ready(task);</span><br><span class="line">    <span class="comment">// 任务加入task_list</span></span><br><span class="line">    list_insert_last(&amp;task_manager.task_list, &amp;task-&gt;all_node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在<code>time.c</code>中加入任务相关的中断处理<code>task_time_tick()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// time.c </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_time</span> <span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">    sys_tick++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向8259通知对应的中断已完成</span></span><br><span class="line">    pic_send_eoi(IRQ0_TIMER);</span><br><span class="line">    <span class="comment">// =========================== 加入 ========================== //</span></span><br><span class="line">    task_time_tick();  <span class="comment">// 任务相关的处理</span></span><br><span class="line">    <span class="comment">// ========================================================== //</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里<code>pic_send_eoi(IRQ0_TIMER);</code>和<code>task_time_tick();</code>的顺序不能错。原因如下：、</p>
<blockquote>
<p>在中断处理程序 <code>do_handler_time</code> 中，<code>pic_send_eoi</code> 和 <code>task_time_tick</code> 的顺序不能交换，主要是为了保证中断的正确处理和系统的稳定运行。以下是详细解释：</p>
<ul>
<li><code>pic_send_eoi</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pic_send_eoi</span> <span class="params">(<span class="type">int</span> irq_num)</span> &#123;</span><br><span class="line">    irq_num -= IRQ_PIC_START;  <span class="comment">// 将irq_num变为内部序号</span></span><br><span class="line">    <span class="keyword">if</span> (irq_num &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">        outb(PIC1_OCW2, PIC_OCW2_EOI);  <span class="comment">// 向第二块8259发送eoi指令</span></span><br><span class="line">    &#125;</span><br><span class="line">    outb(PIC0_OCW2, PIC_OCW2_EOI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数向 8259 可编程中断控制器 (PIC) 发送中断结束信号 (EOI)，通知 PIC 当前中断已经处理完毕，可以接受新的中断请求。这个过程非常关键，因为它控制着中断的优先级和处理顺序。</p>
<ul>
<li><code>task_time_tick</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_time_tick</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *curr_task = task_current();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若当前任务的时间切片在运行后减少为0，说明需要对其进行任务切换</span></span><br><span class="line">    <span class="keyword">if</span> (--curr_task-&gt;slice_ticks == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 重新设置时间切片</span></span><br><span class="line">        curr_task-&gt;slice_ticks = curr_task-&gt;time_ticks;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行任务切换</span></span><br><span class="line">        task_set_block(curr_task);</span><br><span class="line">        task_set_ready(curr_task);</span><br><span class="line">        task_dispatch();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数处理与任务调度相关的逻辑，例如更新当前任务的时间片，并在需要时触发任务切换。</p>
<ul>
<li>不能交换顺序的原因</li>
</ul>
<ol>
<li><strong>中断优先级控制</strong>：<ul>
<li>在中断处理程序中，优先向 PIC 发送 EOI 信号，确保 PIC 能够继续处理其他中断。这可以防止中断嵌套过多，避免中断响应延迟。</li>
</ul>
</li>
<li><strong>任务切换时的安全性</strong>：<ul>
<li><code>task_time_tick</code> 可能会触发任务切换，这意味着当前任务的上下文（CPU 寄存器状态、栈指针等）可能会被保存，并切换到另一个任务的上下文。如果在 <code>task_time_tick</code> 中执行任务切换之前没有发送 EOI 信号，可能会导致中断处理未完全结束就切换到另一个任务，造成中断处理不完整或混乱。</li>
</ul>
</li>
<li><strong>系统稳定性</strong>：<ul>
<li>及时发送 EOI 信号可以确保系统中断处理机制的稳定性，避免中断嵌套层数过多，导致系统无法及时响应其他硬件中断请求。</li>
</ul>
</li>
</ol>
<p>因此，将 <code>task_time_tick</code> 放在 <code>pic_send_eoi</code> 之后，可以确保在进行任务切换等复杂操作前，已经通知 PIC 当前中断处理完毕。这种顺序确保了中断处理的及时性和系统的稳定性。因此，<code>pic_send_eoi</code> 和 <code>task_time_tick</code> 的调用顺序不能交换。</p>
</blockquote>
<p>最后的实现效果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161536876.png" alt="image-20240516153646690"></p>
<h2 id="8-5-临界资源与临界区"><a href="#8-5-临界资源与临界区" class="headerlink" title="8.5 临界资源与临界区"></a>8.5 临界资源与临界区</h2><p>上述任务存在一些问题，即：<strong>在两个任务进行切换的时刻输出的信息是乱的。</strong>因此需要对其进行修改。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161540957.png" alt="image-20240516154041859"></p>
<h3 id="1、理论基础-10"><a href="#1、理论基础-10" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><ul>
<li><p>并发与并行</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161541337.png" alt="image-20240516154127142"></p>
<p>因此，当多个进程或任务共同访问统一资源时，有可能产生冲突。</p>
<p>如下图所示，假设<code>first_task</code>此时运行到<code>log_printf</code>函数时，正在执行串口输出，且时间较长。由于任务间按时间片方式轮流执行，因此可能输出到一半时<code>first_task</code>的时间片用完了，正好定时器中断也到了，那么此时就会将任务切换到<code>init_task</code>，会接下来打印<code>init_task</code>的信息，从而造成输出信息混乱。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161544397.png" alt="image-20240516154434937"></p>
</li>
<li><p>临界资源和临界区</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161548492.png" alt="image-20240516154831083"></p>
</li>
</ul>
<h3 id="2、互斥实现"><a href="#2、互斥实现" class="headerlink" title="2、互斥实现"></a>2、互斥实现</h3><p>解决方法1：互斥。即一次只允许一个进程在临界区中。互斥的实现方法之一是：禁用中断。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161550138.png" alt="image-20240516155039989" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// irq.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">irq_state_t</span>;</span><br><span class="line"><span class="type">irq_state_t</span> <span class="title function_">irq_enter_protection</span> <span class="params">(<span class="type">void</span>)</span>;        <span class="comment">// 进入临界区保护状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_leave_protection</span> <span class="params">(<span class="type">irq_state_t</span> state)</span>;  <span class="comment">// 退出临界区保护状态</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// log.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数可变的打印模版函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界资源保护</span></span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = str_buf;</span><br><span class="line">    <span class="comment">// 打印fmt相关内容</span></span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 串行接口忙检测</span></span><br><span class="line">        <span class="keyword">while</span> ((inb(COM1_PORT + <span class="number">5</span>) &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>)) == <span class="number">0</span>);        </span><br><span class="line">        outb(COM1_PORT, *p++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 退出临界资源保护模式</span></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// irq.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通过关闭中断的方式实现互斥，主要需要保存进入临界区之前中断的开关状态，避免退出时意外开启中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">irq_state_t</span> <span class="title function_">irq_enter_protection</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 读取原中断状态</span></span><br><span class="line">    <span class="type">irq_state_t</span> state = read_eflags();</span><br><span class="line">    <span class="comment">// 关中断</span></span><br><span class="line">    irq_disable_global();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_leave_protection</span> <span class="params">(<span class="type">irq_state_t</span> state)</span> &#123;</span><br><span class="line">    <span class="comment">// 写回中断状态，若原中断为关闭状态，则保持；若原中断为开启状态，则恢复打开</span></span><br><span class="line">    write_eflags(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpu_instr.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读EFLAGS寄存器</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">read_eflags</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> eflags;</span><br><span class="line"></span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;pushf\n\tpop %%eax&quot;</span>:<span class="string">&quot;=a&quot;</span>(eflags));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> eflags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写EFLAGS寄存器</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">write_eflags</span> <span class="params">(<span class="type">uint32_t</span> eflags)</span> &#123;</span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;push %%eax\n\tpopf&quot;</span>::<span class="string">&quot;a&quot;</span>(eflags));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时切换点会执行完整输出</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161610637.png" alt="image-20240516160955146"></p>
<h2 id="8-6-让进程能够延时运行"><a href="#8-6-让进程能够延时运行" class="headerlink" title="8.6 让进程能够延时运行"></a>8.6 让进程能够延时运行</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;main task: %d&quot;</span>, count++);  <span class="comment">// 需求：每隔一秒输出一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当进程需要延时运行时，应当将其从就绪队列中移出，以免占用CPU；等延时时间到达后，再将其移回就绪队列。</strong>因此，专门设计一个队列，用于放置需要延时的进程。<strong>在每个时钟节拍中断发生时，扫描延时队列，发现延时时间到，则再将进程移回就绪队列尾部。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161656774.png" alt="image-20240516165606592" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_manager_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">list_t</span> sleep_list;  <span class="comment">// 睡眠队列</span></span><br><span class="line">&#125;<span class="type">task_manager_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述程序/进程运行状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> sleep_ticks;            <span class="comment">// 延时</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_sleep</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> ticks)</span>;  <span class="comment">// 任务加入睡眠队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_wakeup</span> <span class="params">(<span class="type">task_t</span> *task)</span>;                 <span class="comment">// 任务移除睡眠队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_sleep</span> <span class="params">(<span class="type">uint32_t</span> ms)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务加入睡眠队列的尾部</span></span><br><span class="line"><span class="comment"> * @param ticks 要睡眠的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_sleep</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> ticks)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ticks == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task-&gt;sleep_ticks = ticks;</span><br><span class="line">    task-&gt;state = TASK_SLEEP;</span><br><span class="line">    list_insert_last(&amp;task_manager.sleep_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务移除睡眠队列 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_wakeup</span> <span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    list_remove(&amp;task_manager.sleep_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 实现睡眠机制，使当前任务进入睡眠状态一段时间，并切换到其他任务继续执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_sleep</span> <span class="params">(<span class="type">uint32_t</span> ms)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将任务从就绪队列移动到睡眠队列</span></span><br><span class="line">    task_set_block(task_manager.curr_task);</span><br><span class="line">    task_set_sleep(task_manager.curr_task, ms + (OS_TICKS_MS - <span class="number">1</span>) / OS_TICKS_MS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到就绪队列的下一个任务执行</span></span><br><span class="line">    task_dispatch();</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现效果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161945180.png" alt="image-20240516194523931"></p>
<h2 id="8-7-让所有进程都能延时"><a href="#8-7-让所有进程都能延时" class="headerlink" title="8.7 让所有进程都能延时"></a>8.7 让所有进程都能延时</h2><p>当所有进程都进入睡眠状态时，就绪队列为空，也就是说在<code>task_dispatch()</code>中，<code>to</code>取出的下一个任务为空，造成操作系统崩溃。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通过任务队列实现任务切换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_dispatch</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line">    </span><br><span class="line">    <span class="type">task_t</span> *to = task_next_run();		<span class="comment">// !!!!!!!此处!!!!!!!</span></span><br><span class="line">    <span class="keyword">if</span> (to != task_manager.curr_task) &#123;</span><br><span class="line">        <span class="type">task_t</span> *from = task_current();  <span class="comment">// 定义[原来正在运行的任务]为[将要被切换掉的任务]</span></span><br><span class="line">        task_manager.curr_task = to;    <span class="comment">// 将task_manager中[当前正在运行的任务]修改为[将要切换过去的任务]</span></span><br><span class="line">        to-&gt;state = TASK_RUNNING;       <span class="comment">// 修改此任务的状态</span></span><br><span class="line"></span><br><span class="line">        task_switch_from_to(from, to);  <span class="comment">// 执行任务切换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：当就绪队列为空时，运行<strong>空闲进程</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_manager_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">task_t</span> idle_task;   <span class="comment">// 空闲进程</span></span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="type">task_manager_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 任务管理器初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    list_init(&amp;task_manager.ready_list);  <span class="comment">// 初始化就绪队列</span></span><br><span class="line">    list_init(&amp;task_manager.sleep_list);  <span class="comment">// 初始化睡眠队列</span></span><br><span class="line">    list_init(&amp;task_manager.task_list);   <span class="comment">// 初始化所有任务队列</span></span><br><span class="line">    task_manager.curr_task = (<span class="type">task_t</span> *)<span class="number">0</span>;  <span class="comment">// 设置当前任务为0</span></span><br><span class="line"></span><br><span class="line">    task_init(&amp;task_manager.idle_task,</span><br><span class="line">        <span class="string">&quot;idle_task&quot;</span>,</span><br><span class="line">        (<span class="type">uint32_t</span>)idle_task_entry,</span><br><span class="line">        (<span class="type">uint32_t</span>)(idle_task_stack + IDLE_TASK_SIZE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务加入就绪队列的尾部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_ready</span> <span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于空闲进程，不应加入时间片轮换中</span></span><br><span class="line">    <span class="keyword">if</span> (task == &amp;task_manager.idle_task) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list_insert_last(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">    task-&gt;state = TASK_READY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务移除就绪队列 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_block</span> <span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于空闲进程，不应加入时间片轮换中</span></span><br><span class="line">    <span class="keyword">if</span> (task == &amp;task_manager.idle_task) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list_remove(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  从就绪队列中选取下一个要运行的任务</span></span><br><span class="line"><span class="comment"> *         这里实际上需要根据run_node取到包含run_node的task的整个结构体的起始地址，</span></span><br><span class="line"><span class="comment"> *         因为对于要对task进行操作的函数来说，需要操作的是task这个整体</span></span><br><span class="line"><span class="comment"> * @return 指向该任务的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_next_run</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 若就绪队列为空，运行空闲进程</span></span><br><span class="line">    <span class="keyword">if</span> (list_count(&amp;task_manager.ready_list) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;task_manager.idle_task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">list_node_t</span> *task_node = list_first(&amp;task_manager.ready_list);</span><br><span class="line">    <span class="keyword">return</span> list_node_parent(task_node, <span class="type">task_t</span>, run_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现效果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162010349.png" alt="image-20240516201030225"></p>
<h1 id="九、进程间的同步与互斥"><a href="#九、进程间的同步与互斥" class="headerlink" title="九、进程间的同步与互斥"></a>九、进程间的同步与互斥</h1><h2 id="9-1-计数信号量及其初始化"><a href="#9-1-计数信号量及其初始化" class="headerlink" title="9.1 计数信号量及其初始化"></a>9.1 计数信号量及其初始化</h2><h3 id="1、理论基础-11"><a href="#1、理论基础-11" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>在多进程运行环境中，进程之间、进程与中断之间需要协作，也可以通过信号来同步行为。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162022801.png" alt="image-20240516202243580" style="zoom:50%;" />

<p>为实现这种行为上的同步，需要提供两种操作，等信号和发信号，且在某些情况下，可能连续发多次信号，因此可以将发送的信号数记录下来。</p>
<ul>
<li>等信号：如果信号计数&#x3D;0， 则进程等待；否则，计数减1，进程继续执行。</li>
<li>发信号：若有进程等待，则唤醒进程继续执行；否则，增加计数。</li>
</ul>
<blockquote>
<p><strong>可以类比停车场停车。</strong></p>
<p>等信号相当于车辆进入停车场，信号计数相当于空车位。</p>
<ul>
<li>信号计数为0相当于没有空车位，因此车辆需要等待（即进程等待）；</li>
<li>若信号计数不为0，则当前有空车位，车辆可以驶入（即进程执行），而空车位的数量要减1。</li>
</ul>
<p>发信号则相当于车辆离开停车场。</p>
<ul>
<li>若此时恰好有另一辆车要进入（待执行进程），那么这辆车可以直接进入（待执行进程被唤醒），空车位数不变（信号量不变）；</li>
<li>否则，空车位数加1（信号量加1）。</li>
</ul>
</blockquote>
<p>计数信号量：包含1）一个计数器，以及2）当计数为0时让进程排队等待的队列。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162035492.png" alt="image-20240516203555357" style="zoom:50%;" />

<h3 id="2、代码实现-2"><a href="#2、代码实现-2" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><p>新建<code>ipc</code>目录。</p>
<blockquote>
<p>IPC（Inter-Process Communication，进程间通信）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数信号量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">sem_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">list_t</span> wait_list;</span><br><span class="line">&#125;<span class="type">sem_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_init</span> <span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> init_count)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="9-2-发信号和等信号"><a href="#9-2-发信号和等信号" class="headerlink" title="9.2 发信号和等信号"></a>9.2 发信号和等信号</h2><ul>
<li><p>等信号：如果信号计数&#x3D;0， 则进程等待；否则，计数减1，进程继续执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 等信号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_wait</span> <span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 信号量不为0，进程可继续执行</span></span><br><span class="line">        sem-&gt;count--;  <span class="comment">// 信号量减1，表明当前进程获得一个信号</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 信号量为0，进程由就绪队列移动到等待队列</span></span><br><span class="line">        <span class="type">task_t</span> *curr =  task_current();</span><br><span class="line">        task_set_block(curr);</span><br><span class="line">        list_insert_last(&amp;sem-&gt;wait_list, &amp;curr-&gt;wait_node);</span><br><span class="line">        task_dispatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162047328.png" alt="image-20240516204721126" style="zoom: 50%;" />
</li>
<li><p>发信号：若有进程等待，则唤醒进程继续执行；否则，增加计数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 发信号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_notify</span> <span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list_count(&amp;sem-&gt;wait_list)) &#123;</span><br><span class="line">        <span class="comment">// 等待队列非空，有进程在等待执行</span></span><br><span class="line">        <span class="type">list_node_t</span> *node = list_remove_first(&amp;sem-&gt;wait_list);  <span class="comment">// 从等待队列中取第一个任务     </span></span><br><span class="line">        <span class="type">task_t</span> *task = list_node_parent(node, <span class="type">task_t</span>, wait_node);  <span class="comment">// 获取该任务对应的task_t地址</span></span><br><span class="line">        task_set_ready(task);   <span class="comment">// 设置该任务为就绪状态</span></span><br><span class="line"></span><br><span class="line">        task_dispatch();        <span class="comment">// 执行任务切换</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 等待队列为空，信号量加1</span></span><br><span class="line">        sem-&gt;count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162048307.png" alt="image-20240516204803152" style="zoom:50%;" /></li>
</ul>
<h2 id="9-3-使用计数信号量"><a href="#9-3-使用计数信号量" class="headerlink" title="9.3 使用计数信号量"></a>9.3 使用计数信号量</h2><p>实例：收到信号量打印信息。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162101361.png" alt="image-20240516210150112" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">task_t</span> sub_task;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> init_task_stack[<span class="number">1024</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        sem_wait(&amp;sem);</span><br><span class="line">        log_printf(<span class="string">&quot;sub task: %d&quot;</span>, count++);</span><br><span class="line">        <span class="comment">// task_switch_from_to(&amp;sub_task, task_first_take());</span></span><br><span class="line">        <span class="comment">// sys_sched_yield();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a = 3 / 0;</span></span><br><span class="line">    <span class="comment">// irq_enable_global();</span></span><br><span class="line">    task_init(&amp;sub_task, <span class="string">&quot;sub task&quot;</span>, (<span class="type">uint32_t</span>)init_task_entry, (<span class="type">uint32_t</span>)&amp;init_task_stack[<span class="number">1024</span>]);</span><br><span class="line">    task_first_init();</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;sem, <span class="number">0</span>);  <span class="comment">// 信号量初始化（放在开中断前，以避免定时中断切换至其它任务，而此时信号量还未初始化）</span></span><br><span class="line">    irq_enable_global();  <span class="comment">// 打开全局中断</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;main task: %d&quot;</span>, count++);</span><br><span class="line">        <span class="comment">// task_switch_from_to(task_first_take(), &amp;sub_task);</span></span><br><span class="line">        <span class="comment">// 修改上面这个函数，使得进程主动释放CPU的使用权，但不指定切换到哪个进程运行，实现如下</span></span><br><span class="line">        <span class="comment">// sys_sched_yield();</span></span><br><span class="line">        <span class="comment">// 注释掉上面这个函数，使得执行时间片切片运行的效果</span></span><br><span class="line">        sem_notify(&amp;sem);</span><br><span class="line">        sys_sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时和<code>8.7</code>相比就会先打印<code>main task</code>：<strong>因为此时<code>sub task</code>需要等到<code>main task</code>发信号，接收到信号时才会执行。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162110080.png" alt="image-20240516211037845"></p>
<h2 id="9-4-互斥锁及其初始化"><a href="#9-4-互斥锁及其初始化" class="headerlink" title="9.4 互斥锁及其初始化"></a>9.4 互斥锁及其初始化</h2><p>使用关闭中断的方式实现互斥，简单粗暴，容易造成中断和其它进程长时间得到运行或响应。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162120111.png" alt="image-20240516212005916" style="zoom:50%;" />

<p>类似地，可以为临界区加一把锁(互斥锁)，只有持有锁的进程才能进来，从而实现进程进入临界区的互斥。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162121845.png" alt="image-20240516212129597" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">smutex_t</span>&#123;</span> </span><br><span class="line">    <span class="type">task_t</span> *owner;      <span class="comment">// 当前持有锁的进程</span></span><br><span class="line">    <span class="type">int</span> locked_count;   <span class="comment">// 当前锁的上锁次数</span></span><br><span class="line">    <span class="type">list_t</span> wait_list;   <span class="comment">// 等待队列，存放进程</span></span><br><span class="line">&#125;<span class="type">mutex_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_init</span> <span class="params">(<span class="type">mutex_t</span> *mutex)</span>;  <span class="comment">// 互斥锁初始化</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 互斥锁初始化 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_init</span> <span class="params">(<span class="type">mutex_t</span> *mutex)</span> &#123;</span><br><span class="line">    mutex-&gt;owner = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line">    mutex-&gt;locked_count = <span class="number">0</span>;</span><br><span class="line">    list_init(&amp;mutex-&gt;wait_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-5-互斥锁的加解锁"><a href="#9-5-互斥锁的加解锁" class="headerlink" title="9.5 互斥锁的加解锁"></a>9.5 互斥锁的加解锁</h2><ul>
<li><p>上锁：如果已经上锁，则等待；否则，该进程自己上锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 上锁 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_lock</span> <span class="params">(<span class="type">mutex_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    <span class="comment">// 判断是否已上锁</span></span><br><span class="line">    <span class="keyword">if</span> (mutex-&gt;locked_count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前未上锁</span></span><br><span class="line">        mutex-&gt;locked_count++;  <span class="comment">// 上锁次数加1</span></span><br><span class="line">        mutex-&gt;owner = curr;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutex-&gt;owner == curr) &#123;</span><br><span class="line">        <span class="comment">// 若恰为本进程上锁，上锁次数加1</span></span><br><span class="line">        mutex-&gt;locked_count++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若非本进程上锁，加入等待队列</span></span><br><span class="line">        task_set_block(curr);</span><br><span class="line">        list_insert_last(&amp;mutex-&gt;wait_list, &amp;curr-&gt;wait_node);</span><br><span class="line">        task_dispatch();  <span class="comment">// 进程切换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162128904.png" alt="image-20240516212825736" style="zoom:50%;" />
</li>
<li><p>解锁：如果有进程等待，则唤醒进程继续执行；否则，直接解锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 解锁，注意只有锁的上锁者才能解锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_unlock</span> <span class="params">(<span class="type">mutex_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    <span class="keyword">if</span> (mutex-&gt;owner == curr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--mutex-&gt;locked_count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 若当前锁被上锁者解锁掉，首先释放掉这个锁</span></span><br><span class="line">            mutex-&gt;owner = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其次，若等待队列中仍然有进程等待，则等待队列中的下一个进程进行加锁操作</span></span><br><span class="line">            <span class="keyword">if</span> (list_count(&amp;mutex-&gt;wait_list)) &#123;</span><br><span class="line">                <span class="comment">// 该进程加入就绪队列</span></span><br><span class="line">                <span class="type">list_node_t</span> *node = list_remove_first(&amp;mutex-&gt;wait_list);</span><br><span class="line">                <span class="type">task_t</span> *task = list_node_parent(node, <span class="type">task_t</span>, wait_node);</span><br><span class="line">                task_set_ready(task);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重新加锁</span></span><br><span class="line">                mutex-&gt;locked_count = <span class="number">1</span>;</span><br><span class="line">                mutex-&gt;owner = task;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 任务切换</span></span><br><span class="line">                task_dispatch();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162134988.png" alt="image-20240516213438830" style="zoom:50%;" /></li>
</ul>
<h2 id="9-6-应用互斥锁"><a href="#9-6-应用互斥锁" class="headerlink" title="9.6 应用互斥锁"></a>9.6 应用互斥锁</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpu.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配一个GDT空闲表项 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gdt_alloc_desc</span><span class="params">()</span> &#123;</span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过第0项（保留使用）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; GDT_TABLE_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">segment_desc_t</span> *desc = gdt_table + i;</span><br><span class="line">        <span class="keyword">if</span> (desc-&gt;attr == <span class="number">0</span>) &#123;</span><br><span class="line">            mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">return</span> i * <span class="keyword">sizeof</span>(<span class="type">gate_desc_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置中断门表项 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cpu_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    mutex_init(&amp;mutex);</span><br><span class="line">    init_gdt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// log.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 日志初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    mutex_init(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化串行接口，无需了解细节</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">1</span>, <span class="number">0x00</span>);  <span class="comment">// 关闭串行接口相关中断</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">3</span>, <span class="number">0x80</span>);  <span class="comment">// 数据发送速度</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">0</span>, <span class="number">0x3</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">1</span>, <span class="number">0x00</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">3</span>, <span class="number">0x03</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">2</span>, <span class="number">0xc7</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">4</span>, <span class="number">0x0F</span>);</span><br><span class="line">&#125;                  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数可变的打印模版函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理可变字符串</span></span><br><span class="line">    <span class="type">char</span> str_buf[<span class="number">128</span>];</span><br><span class="line">    va_list args;</span><br><span class="line"></span><br><span class="line">    kernel_memset(str_buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(str_buf));</span><br><span class="line">    va_start(args, fmt);  </span><br><span class="line">    kernel_vsprintf(str_buf, fmt, args);</span><br><span class="line">    va_end(args);  <span class="comment">// 释放args</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界资源保护</span></span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = str_buf;</span><br><span class="line">    <span class="comment">// 打印fmt相关内容</span></span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 串行接口忙检测</span></span><br><span class="line">        <span class="keyword">while</span> ((inb(COM1_PORT + <span class="number">5</span>) &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>)) == <span class="number">0</span>);        </span><br><span class="line">        outb(COM1_PORT, *p++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 退出临界资源保护模式</span></span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>实现效果：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405170816844.png" alt="image-20240517081626731"></p>
<p>可以看到，<code>main task</code>和<code>sub task</code>将轮流执行。</p>
<h1 id="十、虚拟内存管理和保护模式"><a href="#十、虚拟内存管理和保护模式" class="headerlink" title="十、虚拟内存管理和保护模式"></a>十、虚拟内存管理和保护模式</h1><h2 id="10-1-内存管理问题"><a href="#10-1-内存管理问题" class="headerlink" title="10.1 内存管理问题"></a>10.1 内存管理问题</h2><p>操作系统需要决定如何管理计算机中的整块内存。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405170959500.png" alt="image-20240517095902134" style="zoom: 33%;" />

<p>内存中存在多进程时，加载进程时存在一些问题：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171004646.png" alt="image-20240517100444945" style="zoom: 33%;" />

<p>为便于内存管理，<code>x86</code>的虚拟内存管理硬件将内存看做成相同大小的页。后续实际上不是按字节分配，而是按页分配的。 </p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171006887.png" alt="image-20240517100622430" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171007176.png" alt="image-20240517100745545" style="zoom: 33%;" />

<p>进程内部维护了一张表，用于实现这种进程和页之间的转换关系。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171009559.png" alt="image-20240517100935089" style="zoom: 33%;" />

<h2 id="10-2-位图数据结构与初始化"><a href="#10-2-位图数据结构与初始化" class="headerlink" title="10.2 位图数据结构与初始化"></a>10.2 位图数据结构与初始化</h2><ul>
<li><p><strong>问题：用什么样的方法管理内存页的分配与回收？</strong></p>
<ul>
<li><p>标记哪些页被使用了，哪些页没有被使用；</p>
</li>
<li><p>采用<strong>位图方式</strong>实现，如下图所示。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171011883.png" alt="image-20240517101143375" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">bitmap_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> bit_count;  <span class="comment">// 位图中的位总个数</span></span><br><span class="line">    <span class="type">uint8_t</span> *bits;  <span class="comment">// 位图字节数组</span></span><br><span class="line">&#125;<span class="type">bitmap_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools/bitmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools/klib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 计算位总个数所需字节数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_byte_count</span><span class="params">(<span class="type">int</span> bit_count)</span> &#123;</span><br><span class="line">    <span class="comment">// 考虑到6/8=0 &amp; 14/8=1这两种情况，需要进行向上取整</span></span><br><span class="line">    <span class="keyword">return</span> (bit_count + <span class="number">8</span> - <span class="number">1</span>) / <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 位图初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_init</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">uint8_t</span> *bits, <span class="type">int</span> count, <span class="type">int</span> init_bit)</span> &#123;</span><br><span class="line">    bitmap-&gt;bits = bits;</span><br><span class="line">    bitmap-&gt;bit_count = count;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bytes = bitmap_byte_count(bitmap-&gt;bit_count);</span><br><span class="line">    kernel_memset(bitmap-&gt;bits, init_bit ? <span class="number">0xFF</span> : <span class="number">0</span>, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="10-3-位图位的分配"><a href="#10-3-位图位的分配" class="headerlink" title="10.3 位图位的分配"></a>10.3 位图位的分配</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取位图中某一位的状态 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_get_bit</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// index / 8                --&gt; 获取到该位处在哪个字节数组（每个字节数组是8位）</span></span><br><span class="line">    <span class="comment">// index % 8                --&gt; 获取到该位在字节数组内部对应的下标</span></span><br><span class="line">    <span class="comment">// &amp; (1 &lt;&lt; (index % 8))     --&gt; 左移下标位，并相与，即可取得该位的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 17 / 8 = 2  --&gt;  在第2个字节数组中</span></span><br><span class="line">    <span class="comment">// 17 % 8 = 1  --&gt;  第2个字节数组的第1位</span></span><br><span class="line">    <span class="keyword">return</span> bitmap-&gt;bits[index / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置位图中的某一位 </span></span><br><span class="line"><span class="comment"> * @param index 位的索引</span></span><br><span class="line"><span class="comment"> * @param count 要设置的位的总个数</span></span><br><span class="line"><span class="comment"> * @param bit   要设置的位的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_set_bit</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> index, <span class="type">int</span> count, <span class="type">int</span> bit)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; (i &lt; count) &amp;&amp; (index &lt; bitmap-&gt;bit_count); i++, index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bit) &#123;</span><br><span class="line">            <span class="comment">// 若bit为1，则进行置1</span></span><br><span class="line">            bitmap-&gt;bits[index / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，进行清0</span></span><br><span class="line">            bitmap-&gt;bits[index / <span class="number">8</span>] &amp;= (<span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 判断位图中某一位是否已设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_is_set</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bitmap_get_bit(bitmap, index) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在位图中寻找值匹配的连续N个位进行分配 </span></span><br><span class="line"><span class="comment"> * @param bit   要匹配的值</span></span><br><span class="line"><span class="comment"> * @param count 要匹配的位的总个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_alloc_nbits</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> bit, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">int</span> search_idx = <span class="number">0</span>;  <span class="comment">// 从第0位开始找</span></span><br><span class="line">    <span class="type">int</span> ok_idx = <span class="number">-1</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (search_idx &lt; bitmap-&gt;bit_count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bitmap_get_bit(bitmap, search_idx) != bit) &#123;</span><br><span class="line">            search_idx++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;  </span><br><span class="line">        <span class="comment">// 找到第一个值匹配的位</span></span><br><span class="line">        ok_idx = search_idx;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; (i &lt; count) &amp;&amp; (search_idx &lt; bitmap-&gt;bit_count); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bitmap_get_bit(bitmap, search_idx++) != bit) &#123;</span><br><span class="line">                <span class="comment">// 当前位值不匹配</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= count) &#123;</span><br><span class="line">            <span class="comment">// 找到了符合条件的多个位</span></span><br><span class="line">            bitmap_set_bit(bitmap, ok_idx, count, ~bit);  <span class="comment">// bit取反</span></span><br><span class="line">            <span class="keyword">return</span> ok_idx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-4-创建地址分配结构"><a href="#10-4-创建地址分配结构" class="headerlink" title="10.4 创建地址分配结构"></a>10.4 创建地址分配结构</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171101073.png" alt="image-20240517110120785" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">addr_alloc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> start;         <span class="comment">// 位图的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> size;          <span class="comment">// 分配的存储空间[位图]的大小</span></span><br><span class="line">    <span class="type">uint32_t</span> page_size;     <span class="comment">// 内存块大小（内存以页的方式分配，因此又称页大小）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bitmap_t</span> bitmap;    </span><br><span class="line"></span><br><span class="line">    <span class="type">mutex_t</span> mutex;          <span class="comment">// 内存分配时的互斥操作</span></span><br><span class="line">&#125;<span class="type">addr_alloc_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 地址分配器初始化</span></span><br><span class="line"><span class="comment"> * @param bits      位图的字节缓冲区</span></span><br><span class="line"><span class="comment"> * @param start     管理内存的起始地址</span></span><br><span class="line"><span class="comment"> * @param size      管理内存的大小</span></span><br><span class="line"><span class="comment"> * @param page_size 内存块大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">addr_alloc_init</span> <span class="params">(<span class="type">addr_alloc_t</span> *alloc, <span class="type">uint8_t</span> *bits,</span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> start, <span class="type">uint32_t</span> size, <span class="type">uint32_t</span> page_size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 内存分配，从位图中获取相应的位并分配，将对应的位由0-&gt;1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">addr_alloc_page</span> <span class="params">(<span class="type">addr_alloc_t</span> *alloc, <span class="type">int</span> page_count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 内存释放</span></span><br><span class="line"><span class="comment"> * @param addr 释放的内存块的起始地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">addr_free_page</span> <span class="params">(<span class="type">addr_alloc_t</span> *alloc, <span class="type">uint32_t</span> addr, <span class="type">int</span> page_count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 内存初始化 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_init</span> <span class="params">(<span class="type">boot_info_t</span> *boot_info)</span> &#123;</span><br><span class="line">    <span class="type">addr_alloc_t</span> addr_alloc;</span><br><span class="line">    <span class="type">uint8_t</span> bits[<span class="number">9</span>];  <span class="comment">// 支持最多64个内存页的分配和释放</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4096:1KB  0x1000:4KB</span></span><br><span class="line">    addr_alloc_init(&amp;addr_alloc, bits, <span class="number">0x1000</span>, <span class="number">64</span>*<span class="number">4096</span>, <span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> addr = addr_alloc_page(&amp;addr_alloc, <span class="number">2</span>);</span><br><span class="line">        log_printf(<span class="string">&quot;alloc addr: 0x%x&quot;</span>, addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> addr = <span class="number">0x1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> addr = addr_free_page(&amp;addr_alloc, addr, <span class="number">2</span>);</span><br><span class="line">        addr += <span class="number">8192</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171448019.png" alt="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171448019.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">addr_alloc_init(&amp;addr_alloc, bits, <span class="number">0x1000</span>, <span class="number">64</span>*<span class="number">4096</span>, <span class="number">4096</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> addr = addr_alloc_page(&amp;addr_alloc, <span class="number">2</span>);  <span class="comment">// 单步调试此处后，00处的[00]-&gt;[03]</span></span><br><span class="line">    log_printf(<span class="string">&quot;alloc addr: 0x%x&quot;</span>, addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240517145000377.png" alt="image-20240517145000377"></p>
<p>64个内存块分配完毕后：</p>
<p><img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240517144742533.png" alt="image-20240517144742533"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171451064.png" alt="image-20240517145140955"></p>
<p>接下来对这64个内存块进行释放：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171451285.png" alt="image-20240517145130117"></p>
<h2 id="10-5-规划内存空间的分配"><a href="#10-5-规划内存空间的分配" class="headerlink" title="10.5 规划内存空间的分配"></a>10.5 规划内存空间的分配</h2><p>系统内存分两大块：</p>
<ul>
<li><code>1M以内</code>给<strong>操作系统</strong>使用；</li>
<li><code>1M以上</code>给<strong>进程</strong>使用。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171455366.png" alt="image-20240517145539043"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">show_mem_info</span><span class="params">(<span class="type">boot_info_t</span> *boot_info)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;mem region: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boot_info-&gt;ram_region_count; i++) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;[%d]: 0x%x - 0x%x&quot;</span>, i,</span><br><span class="line">            boot_info-&gt;ram_region_cfg[i].start,</span><br><span class="line">            boot_info-&gt;ram_region_cfg[i].size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">total_mem_size</span> <span class="params">(<span class="type">boot_info_t</span> *boot_info)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> mem_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boot_info-&gt;ram_region_count; i++) &#123;</span><br><span class="line">        mem_size += boot_info-&gt;ram_region_cfg[i].size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mem_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 内存初始化 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_init</span> <span class="params">(<span class="type">boot_info_t</span> *boot_info)</span> &#123;</span><br><span class="line">    <span class="comment">// 1MB内存空间起始，在链接脚本中定义</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> *mem_free_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印内存初始信息</span></span><br><span class="line">    log_printf(<span class="string">&quot;mem init&quot;</span>);</span><br><span class="line">    show_mem_info(boot_info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位图缓存的起始地址</span></span><br><span class="line">    <span class="type">uint8_t</span> *mem_free = (<span class="type">uint8_t</span> *)&amp;mem_free_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算1MB以上空间的空闲内存容量，并对齐页边界</span></span><br><span class="line">    <span class="type">uint32_t</span> mem_up1MB_free = total_mem_size(boot_info) - MEM_EXT_START;</span><br><span class="line">    mem_up1MB_free = down2(mem_up1MB_free, MEM_PAGE_SIZE);</span><br><span class="line">    log_printf(<span class="string">&quot;free memory: 0x%x, size: 0x%x&quot;</span>, MEM_EXT_START, mem_up1MB_free);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用地址分配机构对得到的内存进行管理</span></span><br><span class="line">    addr_alloc_init(&amp;paddr_alloc, mem_free, MEM_EXT_START, mem_up1MB_free, MEM_PAGE_SIZE);</span><br><span class="line">    mem_free += bitmap_byte_count(paddr_alloc.size / MEM_PAGE_SIZE);  <span class="comment">// 跳过位图缓存这一块内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，mem_free应该比EBDA地址要小</span></span><br><span class="line">    ASSERT(mem_free &lt; (<span class="type">uint8_t</span> *)MEM_EBDA_START);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>kernel.lds</code>中，取出位图缓存这一部分的起始地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x10000;</span><br><span class="line"></span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text)</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		*(.rodata)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.data : &#123;</span><br><span class="line">		*(.data)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.bss : &#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROVIDE(mem_free_start = . );     &lt;--  这一行就可以取取出.bss之后的内存起始地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存初始信息获取：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171531929.png" alt="image-20240517153147728"></p>
<p>位图缓存的起始地址：</p>
<blockquote>
<p> 0x000129c0 + 0x4f10 &#x3D; 0x17830</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171535529.png" alt="image-20240517153526379"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171534282.png" alt="image-20240517153424161"></p>
<p><code>1MB</code>以上空间的空闲内存容量（对齐页边界）：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171532892.png" alt="image-20240517153243765"></p>
<p>两个技巧函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2 ** n</span></span><br><span class="line"><span class="comment">// size = 0x1010  bound = 0x1000(4KB)</span></span><br><span class="line"><span class="comment">// size &amp; ~(bound - 1) </span></span><br><span class="line"><span class="comment">//  = 0x1010 &amp; ~(0x0FFF) </span></span><br><span class="line"><span class="comment">//  = 0x1010 &amp; 0xFFFFF000    [0x0FFF在取反时会补足为32位]</span></span><br><span class="line"><span class="comment">//  = 0x1000</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">down2</span> <span class="params">(<span class="type">uint32_t</span> size, <span class="type">uint32_t</span> bound)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size &amp; ~(bound - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保留0x1010中最后的两位[10]，使其得到0x2000</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">up2</span> <span class="params">(<span class="type">uint32_t</span> size, <span class="type">uint32_t</span> bound)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (size + bound - <span class="number">1</span>) &amp; ~(bound - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-6-内存分页机制"><a href="#10-6-内存分页机制" class="headerlink" title="10.6 内存分页机制"></a>10.6 内存分页机制</h2><h3 id="1、分页机制理论基础"><a href="#1、分页机制理论基础" class="headerlink" title="1、分页机制理论基础"></a>1、分页机制理论基础</h3><p>对进程而言，它看到的是多段连续的内存空间；而实际上，其可能由不同的内存页组合而成。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171545775.png" alt="image-20240517154528056" style="zoom:50%;" />

<p>在访问特定的内存地址时，虚拟存储管理部件会自动地根据转换表将其转换到物理内存中的特定位置。</p>
<blockquote>
<p>也就是说，对于一个进程来说，它掌握的是属于自己的这套“线性地址”（逻辑地址），而实际上的内存是分布在对应的“物理地址”中。当该进程想访问自己的地址上编号为“0x1000”处的内容时，会经过一个转换表，将其映射到物理地址上的“0x20000”处。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171548139.png" alt="image-20240517154849803" style="zoom:50%;" />



<p>最简单的实现方法是使用一级转换表，表中存储了进程看到的内存页对应的实际物理内存页的起始地址转换关系。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171630549.png" alt="image-20240517163012208" style="zoom:50%;" />

<blockquote>
<p>在32位地址空间中，总共可以表示<code>2^32</code>个地址，即<code>4GB</code>的内存空间。**<code>4GB</code>的地址空间需要的页表大小是<code>4MB</code>**，分析如下：</p>
<ul>
<li><strong>32位地址空间的表示</strong></li>
</ul>
<ol>
<li>32位地址：一个<code>32</code>位的地址可以表示从 <code>0x00000000</code> 到 <code>0xFFFFFFFF</code>，即<code>2^32</code>个地址。</li>
<li>4GB内存：由于<code>2^32 = 4 * 2^30</code>，这就等于<code>4GB</code>的内存空间。</li>
</ol>
<ul>
<li><strong>分页机制</strong></li>
</ul>
<p>在分页机制中，内存被划分成固定大小的页。常见的页大小是<code>4KB</code>（<code>4096</code>字节）。<code>32</code>位地址分成两部分：页目录和页内偏移。</p>
<ul>
<li><strong>页表的结构</strong></li>
</ul>
<ol>
<li>页大小：<code>4KB = 2^12</code>字节。这意味着地址的低<code>12</code>位用于页内偏移。</li>
<li>页数：剩下的<code>20</code>位（32位 - 12位）用于表示页的索引。</li>
</ol>
<ul>
<li><strong>页表计算</strong></li>
</ul>
<ol>
<li>每个页表条目（PTE, Page Table Entry）通常占<code>4</code>字节（32位）</li>
<li>一个页表可以包含<code>2^10 = 1024</code>个条目（因为页大小为4KB，4KB &#x2F; 4Byte &#x3D; 1024条目）。</li>
</ol>
<ul>
<li><strong>一级页表大小</strong>：要映射整个4GB的内存空间，需要多少页表条目和页表呢？</li>
</ul>
<ol>
<li><p>页的数量：需要映射<code>4GB / 4KB = 2^20</code>个页。</p>
</li>
<li><p>页表的数量：</p>
</li>
</ol>
<ul>
<li>每个页表可以包含<code>1024</code>个页表条目（每个条目映射一个4KB的页）。</li>
<li>因此，需要的页表数量为<code>2^20(pages) / 1024(entries) = 1024(tables)</code>个。</li>
</ul>
<ol start="3">
<li>每个页表的大小：</li>
</ol>
<ul>
<li>每个页表有1024个条目，每个条目4字节：<code>1024(entries) * 4(bytes/entry) = 4KB</code>大小。</li>
</ul>
<ol start="4">
<li>总页表大小：</li>
</ol>
<ul>
<li><p>因此，1024个页表，每个4KB，总的页表空间需求为：</p>
<p><code>1024(tables) * 4KB(per table) = 4MB</code>。</p>
</li>
</ul>
<ul>
<li><strong>结论</strong>：为了存储4GB的内存地址空间所需的一级页表大小为 <strong>4MB</strong>。这包括了1024个页表，每个页表4KB。</li>
</ul>
</blockquote>
<p>因此，经过上述计算可以得知，一级转换表占用的4MB空间太大了，所以使用二级转换表。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171650837.png" alt="image-20240517165038676"></p>
<ul>
<li>第1级处理<code>4MB</code>的内存页的地址映射；</li>
<li>第2级处理<code>4KB</code>的内存页的地址映射。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171655736.png" alt="image-20240517165538461" style="zoom:50%;" />

<ul>
<li><strong>最高的10位</strong>保存对二级页表的索引；</li>
<li><strong>中间的10位</strong>保存相应物理内存页的起始地址；</li>
<li><strong>最低的12位</strong>指明在物理地址中的偏移。</li>
</ul>
<h3 id="2、在loader中开启分页机制"><a href="#2、在loader中开启分页机制" class="headerlink" title="2、在loader中开启分页机制"></a>2、在loader中开启分页机制</h3><p>接下来以一级页表为例进行测试，实现分页机制的打开：</p>
<p>直接进行<code>4MB</code>内存页的转换，以节省页表空间。<em>（注意采用该方式时需要打开<code>CR4</code>寄存器中的<code>PSE</code>位）</em></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171703932.png" alt="image-20240517170308820" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171736358.png" alt="image-20240517173645182" style="zoom: 80%;" />

<p>由于虚拟存储的分页机制存在，操作系统和进程不需要过多考虑实际物理内存的有效地址范围。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171717275.png" alt="image-20240517171749065" style="zoom:50%;" />

<p>在<code>loader</code>中开始分页机制时，需要保持<code>loader</code>中线性地址和物理地址相同，才能保证<code>loader</code>正常运行。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171718785.png" alt="image-20240517171857619" style="zoom:50%;" />

<p>具体涉及到<code>CR3</code>寄存，并将设计的表结构信息传给<code>CR3</code>寄存器。</p>
<ul>
<li>低12位无效。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171722017.png" alt="image-20240517172220845" style="zoom:80%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpu_instr.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取cr3</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">read_cr3</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> cr0;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %%cr3, %[v]&quot;</span>:[v]<span class="string">&quot;=r&quot;</span>(cr0));</span><br><span class="line">    <span class="keyword">return</span> cr0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入cr3</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">write_cr3</span> <span class="params">(<span class="type">uint32_t</span> v)</span> &#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %[v], %%cr3&quot;</span>::[v]<span class="string">&quot;r&quot;</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取cr4</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">read_cr4</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> cr0;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %%cr4, %[v]&quot;</span>:[v]<span class="string">&quot;=r&quot;</span>(cr0));</span><br><span class="line">    <span class="keyword">return</span> cr0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入cr4</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">write_cr4</span> <span class="params">(<span class="type">uint32_t</span> v)</span> &#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %[v], %%cr4&quot;</span>::[v]<span class="string">&quot;r&quot;</span>(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// loader.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打开分页机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enable_page_mode</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 页目录表，共1024项，且需对齐到4KB处</span></span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> page_dir[<span class="number">1024</span>] __attribute__((aligned(<span class="number">4096</span>))) = &#123;</span><br><span class="line">        [<span class="number">0</span>] = PDE_P | PDE_W | PDE_PS</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	声明并初始化了一个对齐到4KB边界的页目录表，</span></span><br><span class="line"><span class="comment">        	并设置了第一个页目录项，指向一个4MB的大页，以便实现简单的分页机制。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置CR4 &amp; CR3寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> cr4 = read_cr4(); </span><br><span class="line">    write_cr4(cr4 | CR4_PSE);</span><br><span class="line">    write_cr3((<span class="type">uint32_t</span>)page_dir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置CR0的最高位开启分页机制</span></span><br><span class="line">    write_cr0(read_cr0() | CR0_PG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加载内核</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">load_kernel</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    enable_page_mode();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行调试，可以发现只有第<code>0</code>项当前被设置了。也就是说<code>0-4MB</code>范围的线性地址已经设置好了一个表项，映射到物理地址上的<code>0-4MB</code>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171741544.png" alt="image-20240517174108363" style="zoom:80%;" />

<h2 id="10-7-创建内核页表"><a href="#10-7-创建内核页表" class="headerlink" title="10.7 创建内核页表"></a>10.7 创建内核页表</h2><h3 id="1、代码实现"><a href="#1、代码实现" class="headerlink" title="1、代码实现"></a>1、代码实现</h3><p>分页机制除了能实现地址转换外，还可以实现对内存页的保护。借助这种保护机制，可以实现对操作系统的代码和数据进行保护。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171805215.png" alt="image-20240517180548963" style="zoom:50%;" />



<p>第一级页表的每个表项指向一个二级表，而二级页表的每个表项指向一个真实的物理页。</p>
<ul>
<li><p>二级页表中的第一级页表：</p>
<ul>
<li>注意第<code>1</code>位和第<code>2</code>位。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171807804.png" alt="image-20240517180726661" style="zoom:80%;" />
</li>
<li><p>二级页表中的第二级页表：</p>
<ul>
<li>同样注意第<code>1</code>位和第<code>2</code>位。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171807062.png" alt="image-20240517180747902" style="zoom:80%;" /></li>
</ul>
<p>以下区域设置为可读：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text : &#123;</span><br><span class="line">	*(.text)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">.rodata : &#123;</span><br><span class="line">	*(.rodata)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下区域设置为可读写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.data : &#123;</span><br><span class="line">	*(.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.bss : &#123;</span><br><span class="line">	*(.bss)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROVIDE(mem_free_start = . ); </span><br></pre></td></tr></table></figure>



<ul>
<li><strong>最高的10位</strong>保存对二级页表的索引，获取<code>Page Directory</code>中的对应表项；</li>
<li><strong>中间的10位</strong>保存相应物理内存页的起始地址；</li>
<li><strong>最低的12位</strong>指明在物理地址中的偏移。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171650837.png" alt="image-20240517165038676"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// memory.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建内核页表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_kernel_table</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> s_text[], e_text[], s_data[];</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> kernel_base[];</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">        &#123;kernel_base, s_text, kernel_base, PTE_W&#125;,</span><br><span class="line">        &#123;s_text, e_text, s_text, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;s_data, (<span class="type">void</span> *)MEM_EBDA_START, s_data, PTE_W&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历kernel_map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(kernel_map) / <span class="keyword">sizeof</span>(<span class="type">memory_map_t</span>); i++) &#123;</span><br><span class="line">        <span class="type">memory_map_t</span> *<span class="built_in">map</span> = kernel_map + i;  <span class="comment">// 取出表项</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将map中的虚拟地址和物理地址进行4KB页边界对齐</span></span><br><span class="line">        <span class="type">uint32_t</span> vstart = down2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vstart, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">uint32_t</span> vend = up2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vend, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">uint32_t</span> pstart = down2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;pstart, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算这块虚拟空间包含的页的个数</span></span><br><span class="line">        <span class="type">int</span> page_count = (vend - vstart) / MEM_PAGE_SIZE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 建立vstart和pstart的映射</span></span><br><span class="line">        memory_create_map(kernel_page_dir, vstart, (<span class="type">uint32_t</span>)pstart, page_count, <span class="built_in">map</span>-&gt;perm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在page_dir中寻找vaddr对应的页表项/PTE</span></span><br><span class="line"><span class="comment"> * @param alloc 若PTE对应的Page Table不存在，是否需要进行分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pte_t</span> *<span class="title function_">find_pte</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取pde表项</span></span><br><span class="line">    <span class="type">pde_t</span> *pde = page_dir + pde_index(vaddr);  </span><br><span class="line">    <span class="type">pte_t</span> *page_table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断pde对应的Page Table是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (pde-&gt;present) &#123;</span><br><span class="line">        <span class="comment">// 若存在，直接获取page_table的物理地址</span></span><br><span class="line">        page_table = (<span class="type">pte_t</span> *)pde_paddr(pde);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，判断是否需要进行分配</span></span><br><span class="line">        <span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">pte_t</span> *)<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从物理页中分配一页内存</span></span><br><span class="line">        <span class="type">uint32_t</span> pg_paddr = addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pg_paddr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">pte_t</span> *)<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对新分配的表进行清空，以防止脏数据并保证安全性</span></span><br><span class="line">        page_table = (<span class="type">pte_t</span> *)pg_paddr;</span><br><span class="line">        kernel_memset(page_table, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        pde-&gt;v = pg_paddr | PDE_P | PDE_W | PDE_U;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page_table + pte_index(vaddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 建立虚拟地址和物理地址间的映射</span></span><br><span class="line"><span class="comment"> * @param page_dir  要建立映射的页表 </span></span><br><span class="line"><span class="comment"> * @param vaddr     虚拟空间起始地址 </span></span><br><span class="line"><span class="comment"> * @param paddr     物理空间起始地址</span></span><br><span class="line"><span class="comment"> * @param count     虚拟空间中包含的页个数 </span></span><br><span class="line"><span class="comment"> * @param perm      相关属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memory_create_map</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">uint32_t</span> paddr, <span class="type">int</span> count, <span class="type">uint32_t</span> perm)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历每一个页表项，建立其对应的映射关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;create map: v-0x%x p-0x%x, perm: 0x%x&quot;</span>, vaddr, paddr, perm);</span><br><span class="line"></span><br><span class="line">        <span class="type">pte_t</span> * pte = find_pte(page_dir, vaddr, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pte == (<span class="type">pte_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;create pte failed. pte == 0&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;             </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建映射的时候，这条pte应当是不存在的。</span></span><br><span class="line">        <span class="comment">// 如果存在，说明可能有问题</span></span><br><span class="line">        log_printf(<span class="string">&quot;\tpte addr: 0x%x&quot;</span>, (<span class="type">uint32_t</span>)pte);</span><br><span class="line">        <span class="comment">// 找到了对应的页表项/PTE</span></span><br><span class="line">        ASSERT(pte-&gt;present == <span class="number">0</span>);  <span class="comment">// 此时的present位应为0</span></span><br><span class="line">        pte-&gt;v = paddr | perm | PTE_P;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到下一个地址</span></span><br><span class="line">        vaddr += MEM_PAGE_SIZE;</span><br><span class="line">        paddr += MEM_PAGE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pte_t</span> *<span class="title function_">find_pte</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    page_table = (<span class="type">pte_t</span> *)pg_paddr;</span><br><span class="line">    kernel_memset(page_table, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么要初始化?</li>
</ul>
<ol>
<li><strong>防止脏数据</strong>: 分配新的页表页后，该页表页中的内容可能包含先前分配但未清除的数据。初始化页表页（即清零）确保所有 PTE（页表项）都是空的，没有设置任何标志位或地址。</li>
<li><strong>安全性</strong>: 避免访问到未初始化的内存，防止潜在的安全漏洞。例如，未初始化的 PTE 可能指向随机地址，这会导致页错误或者其他意外行为。</li>
<li><strong>正确性</strong>: 页表页中的每个 PTE 都需要按照预期进行初始化。初始化保证了新分配的页表页在开始时不包含任何有效的映射，只有在后续显式设置时才包含有效映射。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182044761.png" alt="image-20240518204404435"></p>
<h3 id="2、代码调试"><a href="#2、代码调试" class="headerlink" title="2、代码调试"></a>2、代码调试</h3><p>在<code>qemu</code>中执行<code>info mem</code>为空，正确的话应该打印开启分页机制后的虚拟地址与物理地址的映射。此时为空说明分页机制已被打开，但所有的页表全为无效。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182052909.png" alt="image-20240518205244786"></p>
<p>原因分析：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在page_dir中寻找vaddr对应的页表项/PTE</span></span><br><span class="line"><span class="comment"> * @param alloc 若PTE对应的Page Table不存在，是否需要进行分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pte_t</span> *<span class="title function_">find_pte</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    	...</span><br><span class="line">        <span class="comment">// 对新分配的表进行清空，以防止脏数据并保证安全性</span></span><br><span class="line">        page_table = (<span class="type">pte_t</span> *)pg_paddr;</span><br><span class="line">        kernel_memset(page_table, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br><span class="line">    	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是对新分配的表进行清空，并没有建立pde表项，并没有建立<code>pde</code>与<code>page_table</code>之间的关系。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pde-&gt;v = pg_paddr | PDE_P;</span><br></pre></td></tr></table></figure>

<p>加上这一行后重新调试，发现最后两项存在问题。虚拟地址相同，但物理地址并没有实现页边界对齐。</p>
<p>因此需要对物理地址也进行页边界对齐。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182058011.png" alt="image-20240518205852888"></p>
<p>在以下函数中进行修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建内核页表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_kernel_table</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> s_text[], e_text[], s_data[];</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> kernel_base[];</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">        &#123;kernel_base, s_text, kernel_base, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;s_text, e_text, s_text, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;s_data, (<span class="type">void</span> *)MEM_EBDA_START, s_data, <span class="number">0</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历kernel_map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(kernel_map) / <span class="keyword">sizeof</span>(<span class="type">memory_map_t</span>); i++) &#123;</span><br><span class="line">        <span class="type">memory_map_t</span> *<span class="built_in">map</span> = kernel_map + i;  <span class="comment">// 取出表项</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将map中的虚拟地址和物理地址进行4KB页边界对齐</span></span><br><span class="line">        <span class="type">uint32_t</span> vstart = down2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vstart, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">uint32_t</span> vend = up2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vend, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">uint32_t</span> pstart = down2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;pstart, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算这块虚拟空间包含的页的个数</span></span><br><span class="line">        <span class="type">int</span> page_count = (vend - vstart) / MEM_PAGE_SIZE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 建立vstart和pstart的映射</span></span><br><span class="line">        <span class="comment">// memory_create_map(kernel_page_dir, vstart, (uint32_t)map-&gt;pstart, page_count, map-&gt;perm);</span></span><br><span class="line">        memory_create_map(kernel_page_dir, vstart, (<span class="type">uint32_t</span>)pstart, page_count, <span class="built_in">map</span>-&gt;perm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后出现以下结果，发现最后错误地出现了两个相同的项，导致在<code>memory_create_map()</code>中判断<code>ASSERT(pte-&gt;present == 0);</code> 时出错。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182102316.png" alt="image-20240518210246033"></p>
<p>经排查，这个错误和链接脚本的设置有关。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	PROVIDE(kernel_base = .);</span><br><span class="line">    . = <span class="number">0x10000</span>;</span><br><span class="line"></span><br><span class="line">	PROVIDE(s_text = .); </span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text)</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		*(.rodata)</span><br><span class="line">	&#125;</span><br><span class="line">	PROVIDE(e_text = .); </span><br><span class="line"></span><br><span class="line">	PROVIDE(s_data = .);   &lt;==== .data未页边界对齐</span><br><span class="line">	.data : &#123;</span><br><span class="line">		*(.data)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.bss : &#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROVIDE(mem_free_start = . ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在<code>kernel_elf.txt</code>文件中，<code>.data section</code>的起始地址并非是页边界对齐（<code>4KB</code>）的，因此会在后续产生页表项重复的情况。</p>
<p>详细来说，<code>.data</code>段的起始地址未对齐到页边界，会导致两个问题：</p>
<ol>
<li><strong>页表项重复</strong>： 当页表项映射未对齐的数据段时，一个页表项可能会覆盖两个不同的物理页。这会导致映射冲突，页表项出现重复或无效。</li>
<li><strong>访问异常</strong>： 未对齐的数据段会引起内存访问异常，因为在一个页中可能包含多个段的数据，导致不同的页表项映射到同一物理地址。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182107831.png" alt="image-20240518210723714"></p>
<p>因此，对链接脚本修改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">. = ALIGN(<span class="number">4096</span>);   &lt;==== 加入这一行</span><br><span class="line">PROVIDE(s_data = .); </span><br><span class="line">.data : &#123;</span><br><span class="line">	*(.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时重新编译后，<code>.data section</code>的起始地址如下：<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182124084.png" alt="image-20240518212455979"></p>
<p>经过上述修改，<code>info mem</code>就有输出了：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182125920.png" alt="image-20240518212541791"></p>
<h3 id="3、权限设置"><a href="#3、权限设置" class="headerlink" title="3、权限设置"></a>3、权限设置</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">    &#123;kernel_base, s_text, kernel_base, PTE_W&#125;,</span><br><span class="line">    &#123;s_text, e_text, s_text, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;s_data, (<span class="type">void</span> *)MEM_EBDA_START, s_data, PTE_W&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码为操作系统访问的代码，因此第<code>2</code>位权限位设置为<code>0</code>，即<code>supervisor</code>；</p>
</li>
<li><p>此外，还要设置第<code>3</code>位，确定是只读还是可读写。由于采用的结构是二级表，因此每个表都有针对自己这个表的权限设置。对于<code>PTE</code>表项来说，在上述代码中设置<code>PTE_W</code>即可确定可读写；而对于<code>PDE</code>表项来说，在此处（<code>find_pte()</code>中）设置可读写以及用户可访问：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pde-&gt;v = pg_paddr | PDE_P | PDE_W | PDE_U;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>设置完权限后，<code>info mem</code>的信息更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182149317.png" alt="image-20240518214839313"></p>
<h2 id="10-8-为进程创建页表"><a href="#10-8-为进程创建页表" class="headerlink" title="10.8 为进程创建页表"></a>10.8 为进程创建页表</h2><h3 id="1、问题说明"><a href="#1、问题说明" class="headerlink" title="1、问题说明"></a>1、问题说明</h3><p>此时这个程序存在下列问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// init.c </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    task_init(&amp;sub_task, <span class="string">&quot;sub task&quot;</span>, (<span class="type">uint32_t</span>)init_task_entry, (<span class="type">uint32_t</span>)&amp;init_task_stack[<span class="number">1024</span>]);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行到第<code>3</code>行的代码时，CPU会重启。进入这一行代码的内部进行调试，可以发现问题出在切换<code>TSS</code>的时刻。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Task Switch </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_switch_from_to</span> <span class="params">(<span class="type">task_t</span> *from, <span class="type">task_t</span> *to)</span> &#123;</span><br><span class="line">    switch_to_tss(to-&gt;tss_sel);</span><br><span class="line">    <span class="comment">// simple_switch(&amp;from-&gt;stack, to-&gt;stack);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 远跳转</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">far_jump</span> <span class="params">(<span class="type">uint32_t</span> selector, <span class="type">uint32_t</span> offset)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> addr[] = &#123;offset, selector&#125;;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;ljmpl *(%[a])&quot;</span>::[a]<span class="string">&quot;r&quot;</span>(addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为每个进程的TSS结构中均有一个<code>CR3</code>字段，以允许每个进程拥有自己的页表。进程会从这个<code>CR3</code>字段中取出页表的起始地址并加载到实际的<code>CR3</code>寄存器中，也就是说切换到进程实际的页表。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182200116.png" alt="image-20240518220044967" style="zoom:80%;" />

<p>此外，需要借助保护机制来实现对操作系统的代码和数据的保护。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182202640.png" alt="image-20240518220254434" style="zoom:50%;" />

<p>两个进程运行起来之后，会共享<code>0x00000000~0x80000000</code>这部分的空间，也即操作系统代码。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182208681.png" alt="image-20240518220857411" style="zoom:50%;" />



<h3 id="2、代码实现-3"><a href="#2、代码实现-3" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpu.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放GDT表项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gdt_free_sel</span><span class="params">(<span class="type">int</span> sel)</span> &#123;</span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    gdt_table[sel/<span class="keyword">sizeof</span>(<span class="type">segment_desc_t</span>)].attr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建进程自己的页表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">memory_create_uvm</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 分配一页内存给Page Directory</span></span><br><span class="line">    <span class="type">pde_t</span> *page_dir = (<span class="type">pde_t</span> *)addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (page_dir == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对第一级页表进行清空</span></span><br><span class="line">    <span class="comment">// 不需要对第二级页表进行清空是因为loader_32.c中执行了清零操作</span></span><br><span class="line">    kernel_memset((<span class="type">void</span> *)page_dir, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户进程PDE的开始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> user_pde_start = pde_index(MEM_TASK_BASE);</span><br><span class="line">    <span class="comment">// 为了实现多个进程间共享操作进程代码，遍历从低1MB空间的所有页表（操作系统部分）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; user_pde_start; i++) &#123;</span><br><span class="line">        <span class="comment">// 由于多个进程间操作系统部分的映射关系是一致的，如果要为这一部分的每一项都分配一个PTE页表，会造成内存浪费</span></span><br><span class="line">        <span class="comment">// 因此此处直接使用操作系统在0x0-0x7FFFFFFF的空间内配置的PTE表即可，即实现了多个进程间的映射共享</span></span><br><span class="line">        page_dir[i].v = kernel_page_dir[i].v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)page_dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>此时进行调试，会在<code>memory_create_uvm()</code>的这一步出错：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kernel_memset((<span class="type">void</span> *)page_dir, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br></pre></td></tr></table></figure>

<p>通过查看此时<code>QEMU</code>的内存映射关系可以得知，此时仅配置了<code>1MB</code>以下的内存关系的映射，而没有配置<code>1MB</code>以上的内存关系映射，但分配的<code>page_dir</code>的地址为<code>0x101000</code>，也就是说<code>QEMU</code>不知道该写到哪里。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191451190.png" alt="image-20240519145138077"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191451670.png" alt="image-20240519145108455"></p>
<p>因此需要对物理地址<code>0x101000</code>也进行一个映射，以获取其线性地址。</p>
<p>因此，对<code>kernel_map[]</code>进行改写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// memory.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_EXT_START       (1024 * 1024)           <span class="comment">// 扩展内存的起始地址，从1MB（实模式内存限制）开始</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_EXT_END         (128 * 1024 * 1024)     <span class="comment">// 扩展内存的结束地址，目前只给QEMU分配了128M内存</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// memory.c </span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">    &#123;kernel_base, s_text, kernel_base, PTE_W&#125;,</span><br><span class="line">    &#123;s_text, e_text, s_text, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;s_data, (<span class="type">void</span> *)MEM_EBDA_START, s_data, PTE_W&#125;,</span><br><span class="line">    &#123;(<span class="type">void</span> *)MEM_EXT_START, (<span class="type">void</span> *)MEM_EXT_END, (<span class="type">void</span> *)MEM_EXT_START, PTE_W&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="十一、隔离操作系统与进程"><a href="#十一、隔离操作系统与进程" class="headerlink" title="十一、隔离操作系统与进程"></a>十一、隔离操作系统与进程</h1><h2 id="11-1-隔离操作系统与进程"><a href="#11-1-隔离操作系统与进程" class="headerlink" title="11.1 隔离操作系统与进程"></a>11.1 隔离操作系统与进程</h2><p>目前所以进程（共3个）的代码和数据全部位于操作系统中，可以适当进行分离。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191512628.png" alt="image-20240519151246404" style="zoom:50%;" />

<p>主要实现以下三步：</p>
<blockquote>
<ol>
<li>建立进程的运行空间；</li>
<li>代码拷贝至指定区域；</li>
<li>从操作系统跳转至进程运行。</li>
</ol>
</blockquote>
<h3 id="1、代码分离"><a href="#1、代码分离" class="headerlink" title="1、代码分离"></a>1、代码分离</h3><blockquote>
<p><strong>实现方式：</strong>只需要单独新建一个文件把代码放进去，就可以实现代码分离。</p>
</blockquote>
<p>（1）首先，删除前序测试使用的<code>sub_task()</code>，并且为<code>first_task()</code>新建一个单独的<code>.c</code>文件，使得其在编译时在<code>/kernel</code>中得到一个单独的文件，而不是在<code>init.c</code>中一起编译。这样在后续进行代码拷贝时就会方便很多。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// first_task.c</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;core/task.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;first task.&quot;</span>);</span><br><span class="line">        sys_sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// first_task_entry.S</span><br><span class="line"></span><br><span class="line">	.text</span><br><span class="line">	.global first_task_entry</span><br><span class="line">	.extern first_task_main</span><br><span class="line">first_task_entry:</span><br><span class="line">    // 进程运行前，操作系统会为其初始化SS寄存器和CS寄存器</span><br><span class="line">	mov %ss, %ax</span><br><span class="line">	mov %ax, %ds</span><br><span class="line">	mov %ax, %es</span><br><span class="line">	mov %ax, %fs</span><br><span class="line">	mov %ax, %gs</span><br><span class="line">    // 跳转至32位的C环境运行</span><br><span class="line">	jmp first_task_main</span><br></pre></td></tr></table></figure>

<p>（2）更新<code>kernel/CMakeLists.txt</code>文件，在末尾加上<code>*.S</code>，从而完成对<code>first_task_entry.S</code>的编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file(GLOB_RECURSE C_LIST &quot;*.c&quot; &quot;*.h&quot; &quot;*.S&quot;)</span><br></pre></td></tr></table></figure>

<p>（3）更新<code>first_task</code>的页表为自己的页表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置好first_task执行的入口函数，并修改对应的task_init中的entry参数为first_start</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">first_task_entry</span> <span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 声明入口函数</span></span><br><span class="line">    <span class="type">uint32_t</span> first_start = (<span class="type">uint32_t</span>)first_task_entry;  <span class="comment">// 获取入口函数地址</span></span><br><span class="line"></span><br><span class="line">    task_init(&amp;task_manager.first_task, <span class="string">&quot;first task&quot;</span>, first_start, <span class="number">0</span>);  <span class="comment">// Task Initialization</span></span><br><span class="line">    write_tr(task_manager.first_task.tss_sel);  <span class="comment">// 对TR寄存器初始化</span></span><br><span class="line">    task_manager.curr_task = &amp;task_manager.first_task;  <span class="comment">// 设置当前任务为first task </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换页表为进程自己的页表</span></span><br><span class="line">    mmu_set_page_dir(task_manager.first_task.tss.cr3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）实现代码跳转：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// init.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从操作进程跳转到用户进程代码 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_to_first_task</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    ASSERT(curr != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出当前任务的tss中的eip字段，获取入口地址</span></span><br><span class="line">    <span class="type">tss_t</span> *tss = &amp;(curr-&gt;tss);</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        <span class="string">&quot;jmp *%[ip]&quot;</span>::[ip]<span class="string">&quot;r&quot;</span>(tss-&gt;eip)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化first_task，并跳转到进程代码中运行</span></span><br><span class="line">    task_first_init();</span><br><span class="line">    move_to_first_task();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）运行结果：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191559496.png" alt="image-20240519155930343"></p>
<p>从上图可以看到此时<code>first_task</code>的入口地址在<code>0x11b09</code>，依旧在<code>1MB</code>以下。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191556008.png" alt="image-20240519155627657"></p>
<h3 id="2、地址分离"><a href="#2、地址分离" class="headerlink" title="2、地址分离"></a>2、地址分离</h3><blockquote>
<p><strong>目标：</strong></p>
<p>1）告诉<code>first_task</code>应该到<code>0x80000000</code>以上的地址去运行；</p>
<p>2）但在存储时是和操作系统一起存放在<code>0x0-0x7FFFFFFF</code>的地址空间内。</p>
<p><strong>实现方式：</strong>在链接脚本<code>kernel.lds</code>中进行修改。</p>
</blockquote>
<ul>
<li><strong>相关理论基础：</strong></li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191611562.png" alt="image-20240519161104805" style="zoom:50%;" />

<ul>
<li>物理地址为存储地址；</li>
<li>虚拟地址为运行地址。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191611577.png" alt="image-20240519161116895" style="zoom: 50%;" />

<p>而在<code>kernel.lds</code>文件中，<code>. = 0x100000</code>实际上设置的是虚拟地址，也就是运行地址。这样的结果就是<code>paddr</code>和<code>vaddr</code>设置为一样的，因此在加载时kernel也会从这个地址上去加载。</p>
<p><strong>现在要做的就是：</strong></p>
<p><strong>1）告诉<code>first_task</code>应该到<code>0x80000000</code>以上的地址去运行；</strong></p>
<p><strong>2）但在存储时是和操作系统一起存放在<code>0x0-0x7FFFFFFF</code>的地址空间内。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191615645.png" alt="image-20240519161519963"></p>
<p>因此，可在链接脚本中分别指定段的加载地址和运行地址。当仅指定运行地址时，加载地址与运行地址相同。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191616105.png" alt="image-20240519161650286"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data 0x2000: AT(ADDR(.text) +SIZEOF(.text))</span><br></pre></td></tr></table></figure>

<p>这一行的意思就是说：<code>.data</code>的运行地址为<code>0x2000</code>，但其存储的物理地址在（<code>AT</code>）<code>.text</code>的相邻处。</p>
<ul>
<li><strong>代码实现：</strong></li>
</ul>
<p><code>kernel_elf.txt</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191621670.png" alt="image-20240519162150219"></p>
<p>上图中的<code>VirtualAddr</code>和<code>PhysAddr</code>一致，且分别对应<code>.text/.rodata</code>和<code>.data/.bss</code>两部分。</p>
<p>（1）告诉<code>first_task</code>应该到<code>0x80000000</code>以上的地址去运行；</p>
<p>修改链接脚本<code>kernel.lds</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	. = 0x80000000;</span><br><span class="line">	.first_task : &#123;</span><br><span class="line">		*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">		*first_task*(.text .rodata .bss .data)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROVIDE(mem_free_start = . ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，<code>ELF</code>文件的<code>Program Header Table</code>表项会更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191631851.png" alt="image-20240519163152388"></p>
<p>（2）但此时存在一个问题</p>
<p>在<code>loader</code>加载时会扫描上图这个表，并根据每个表项的具体内容进行加载。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Elf32_Phdr *phdr = (Elf32_Phdr *)(file_buffer + elf_hdr-&gt;e_phoff) + i;  <span class="comment">// 偏移量：elf_hdr-&gt;e_phoff</span></span><br></pre></td></tr></table></figure>

<p>也即上图中的<code>Offset</code>和<code>PhysAddr</code>两项。但由于<code>0x80000000</code>这个物理地址是不存在的，因此加载会失败。所以需要将<code>first_task</code>的物理地址修改为比<code>.data/.bss</code>的物理地址大一些的地址即可。</p>
<p>取<code>Segment 01</code>的虚拟地址即可（因为<code>00</code>和<code>01</code>段的虚拟地址与物理地址的映射是对应的）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e_data = .;</span><br><span class="line"></span><br><span class="line">. = 0x80000000;</span><br><span class="line">.first_task : AT(e_data) &#123;</span><br><span class="line">	*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">	*first_task*(.text .rodata .bss .data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时就完成了物理地址的修改：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191648559.png" alt="image-20240519164849109"></p>
<p>（3）此外，对于<code>mem_free_start</code>也需要进行相应的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. = 0x80000000;</span><br><span class="line">.first_task : AT(e_data) &#123;</span><br><span class="line">*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">*first_task*(.text .rodata .bss .data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROVIDE(mem_free_start = . ); </span><br></pre></td></tr></table></figure>

<p>此时它在<code>kernel_elf.txt</code>中显示的物理地址为：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191651929.png" alt="image-20240519165112540"></p>
<p>这是因为加入<code>(2)</code>中的系列修改后，会改变它的地址。但这个地址实际上应该指向位图缓存的起始地址，如下图所示，也就是说应该在<code>1MB以下</code>的范围内：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171455366.png" alt="image-20240517145539043"></p>
<p>所以，进行如下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. = 0x80000000;</span><br><span class="line">.first_task : AT(e_data) &#123;</span><br><span class="line">	*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">	*first_task*(.text .rodata .bss .data)</span><br><span class="line">&#125;</span><br><span class="line">e_first_task = LOADADDR(.first_task) + SIZEOF(.first_task);</span><br><span class="line"></span><br><span class="line">PROVIDE(mem_free_start = e_first_task); </span><br></pre></td></tr></table></figure>

<p>这样位图缓存的地址就修改正确：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191655562.png" alt="image-20240519165543113"></p>
<h3 id="3、代码搬运"><a href="#3、代码搬运" class="headerlink" title="3、代码搬运"></a>3、代码搬运</h3><blockquote>
<p><strong>实现方式：</strong></p>
<p>1）找到first_task在物理空间的起始和结束地址；</p>
<p>2）在虚拟空间分配相应的内存空间；</p>
<p>3）进行代码搬运。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191657728.png" alt="image-20240519165724091" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// memory.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">memory_alloc_page_for_page_dir</span> <span class="params">(<span class="type">uint32_t</span> page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">uint32_t</span> size, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录当前vaddr（运行地址，所以是虚拟地址）</span></span><br><span class="line">    <span class="type">uint32_t</span> curr_vaddr = vaddr;</span><br><span class="line">    <span class="comment">// 计算分配页的数量，注意页边界对齐</span></span><br><span class="line">    <span class="type">int</span> page_count = up2(size, MEM_PAGE_SIZE) / MEM_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐页分配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; page_count; i++) &#123;</span><br><span class="line">        <span class="comment">// 从物理内存中分配一页</span></span><br><span class="line">        <span class="type">uint32_t</span> paddr = addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (paddr == <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;mem alloc failed, no memory!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立物理内存和虚拟内存的映射关系</span></span><br><span class="line">        <span class="type">int</span> err = memory_create_map((<span class="type">pde_t</span> *)page_dir, curr_vaddr, paddr, <span class="number">1</span>, perm);</span><br><span class="line">        <span class="keyword">if</span> (paddr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 若建立当前映射失败，则释放当前已建立映射的页，因此addr_free_page传入vaddr</span></span><br><span class="line">            <span class="comment">// 这里不能传入paddr，因为这个paddr只是当前循环下分配的这一页的起始物理地址</span></span><br><span class="line">            log_printf(<span class="string">&quot;create memory failed, crr = %d.&quot;</span>, err);</span><br><span class="line">            addr_free_page(&amp;paddr_alloc, vaddr, i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 此外，可以实现虚拟和物理映射的断开，此处并未实现</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到下一个虚拟地址</span></span><br><span class="line">        curr_vaddr += MEM_PAGE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">memory_alloc_page_for</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> size, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> memory_alloc_page_for_page_dir(task_current()-&gt;tss.cr3, addr, size, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191729446.png" alt="image-20240519172917244"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191729964.png" alt="image-20240519172948838"></p>
<p>执行代码拷贝后，显示如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配一页内存供代码存放使用，然后将代码复制过去</span></span><br><span class="line">memory_alloc_page_for(first_start, alloc_size, PTE_P | PTE_W);</span><br><span class="line">kernel_memcpy((<span class="type">void</span> *)first_start, (<span class="type">void</span> *)s_first_task, copy_size);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191730041.png" alt="image-20240519173019470"></p>
<p>查看对应的反汇编，和<code>first_task_entry.S</code>中的内容一致：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191731972.png" alt="image-20240519173119400"></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191731182.png" alt="image-20240519173158224" style="zoom: 80%;" />

<h2 id="11-2-调整应用的特权级"><a href="#11-2-调整应用的特权级" class="headerlink" title="11.2 调整应用的特权级"></a>11.2 调整应用的特权级</h2><h3 id="1、x86芯片的特权级定义"><a href="#1、x86芯片的特权级定义" class="headerlink" title="1、x86芯片的特权级定义"></a>1、x86芯片的特权级定义</h3><p>x86芯片支持四种特权级：</p>
<ul>
<li>第0级权限最高，用于运行操作系统；</li>
<li>第3级权限最低，用于运行应用程序；</li>
<li>其它两级用于运行操作系统服务(可选)。</li>
</ul>
<p>对于某个特权级来说：只允许访问相同或更低权限的代码或数据。通过这种特权分级的机制可以防止低特权级代码随意访问敏感数据或代码，如开关中断、写磁盘等。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191916522.png" alt="image-20240519191609991"></p>
<ol>
<li><p>数据段访问相关的3种与权限相关的配置位：</p>
<ul>
<li><p>段描述符<code>DPL</code>(Descriptor privilege level(DPL))，定义哪个特权级别的代码可以访问这个段。</p>
</li>
<li><p>选择子<code>RPL</code>(Requested privilege level(RPL))，表示请求访问段的特权级别。</p>
</li>
<li><p>段寄存器<code>CS</code>中的<code>CPL</code>(Current privilege level)，表示当前执行代码的特权级别。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>访问**数据段(<code>DS,ES,FS,GS</code>)**时，仅当<code>DPL&gt;= Max(CPL,RPL)</code>时才能访问。</p>
<p>当**访问<code>SS</code>**时，要求<code>CPL=DPL=RPL</code>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191919839.png" alt="image-20240519191939329"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191920132.png" alt="image-20240519192009659"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191920272.png" alt="image-20240519192046797"></p>
<p>对于访问权限，要求1）自身的权限要足够高；2）自己不能主动把权限放低。<strong>权限错误将产生段保护异常。</strong></p>
<p>如下图<code>CPL=0, RPL=3, DPL=2</code>这条线，就属于自己主动把权限放低了，因此也无法正确访问。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191931168.png" alt="image-20240519193151363"></p>
<ol start="2">
<li><p>代码段访问相关的3种与权限相关的配置位：</p>
<ul>
<li><p>段描述符<code>DPL</code>(Descriptor privilege level(DPL))和<code>C</code>位，定义哪个特权级别的代码可以访问这个段。</p>
</li>
<li><p>选择子<code>RPL</code>(Requested privilege level(RPL))，表示请求访问段的特权级别。</p>
</li>
<li><p>段寄存器<code>CS</code>中的<code>CPL</code>(Current privilege level)，表示当前执行代码的特权级别。</p>
</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191934137.png" alt="image-20240519193438668"></p>
<ul>
<li><p>访问非一致代码段时(<code>C=0</code>)，<code>CPL=DPL，且RPL&lt;=CPL</code>，即权限要一样。</p>
</li>
<li><p>访问一致性代码段时(<code>C=1</code>)到，要求<code>CPL&gt;=DPL，RPL不检查</code>，即访问者的权限要与被访问的代码权限相等或更低<strong>（但本项目未用到，因为不允许随便访问高权限的代码）</strong>。</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191936035.png" alt="image-20240519193654339" style="zoom: 50%;" />

<h3 id="2、平坦模型如何实现保护"><a href="#2、平坦模型如何实现保护" class="headerlink" title="2、平坦模型如何实现保护"></a>2、平坦模型如何实现保护</h3><p>对于本项目来说，由于采用了平坦模型，因此分段保护做不到真正的保护，实际上都写入了<code>0x0~0xFFFFFFFF</code>的空间。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191938454.png" alt="image-20240519193841332" style="zoom:50%;" />

<p>因此，结合分页机制进行保护。简化处理，操作系统运行于特权级<code>0</code>，应用进程运行于特权级<code>3</code>。全部使用非一致性代码段，<code>CPL=RPL</code>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191940126.png" alt="image-20240519194030428" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191940436.png" alt="image-20240519194056411" style="zoom:50%;" />

<h3 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_manager_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> app_code_sel;   <span class="comment">// 进程的代码段选择子</span></span><br><span class="line">    <span class="type">int</span> app_data_sel;   <span class="comment">// 进程的数据段选择子</span></span><br><span class="line">&#125;<span class="type">task_manager_t</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief TSS Initialization，当有程序/进程第一次运行时会调用tss_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tss_init</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 根据不同的权限选择不同的访问选择子</span></span><br><span class="line">    <span class="type">int</span> code_sel, data_sel;</span><br><span class="line">    code_sel = task_manager.app_code_sel | SEG_CPL3;</span><br><span class="line">    data_sel = task_manager.app_data_sel | SEG_CPL3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置TSS的相关字段</span></span><br><span class="line">    task-&gt;tss.eip = entry;  <span class="comment">// 调用tss_init的函数的入口地址（该函数第一次运行）</span></span><br><span class="line">    task-&gt;tss.esp = task-&gt;tss.esp0 = esp;  <span class="comment">// 指示调用tss_init的函数的栈顶的位置（此时栈为空）</span></span><br><span class="line">    task-&gt;tss.ss = task-&gt;tss.ss0 = data_sel;</span><br><span class="line">    task-&gt;tss.es = task-&gt;tss.ds = task-&gt;tss.fs = task-&gt;tss.gs = data_sel;</span><br><span class="line">    task-&gt;tss.cs = code_sel;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 任务管理器初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 设定任务数据段和代码段的特权级</span></span><br><span class="line">    <span class="type">int</span> sel = gdt_alloc_desc();</span><br><span class="line">    segment_desc_set(sel, <span class="number">0x00000000</span>, <span class="number">0xFFFFFFFF</span>,</span><br><span class="line">        SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D);</span><br><span class="line">    task_manager.app_data_sel = sel;</span><br><span class="line"></span><br><span class="line">    sel = gdt_alloc_desc();</span><br><span class="line">    segment_desc_set(sel, <span class="number">0x00000000</span>, <span class="number">0xFFFFFFFF</span>,</span><br><span class="line">        SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL | SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D);</span><br><span class="line">    task_manager.app_code_sel = sel;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时进行调试，可以看到相应的段寄存器的值：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191955719.png" alt="image-20240519195526886"></p>
<p>这些值实际上的内核初始化时在<code>cpu_init()</code>中通过下面的代码设置的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化GDT表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 设计平坦模式下的代码段与数据段</span></span><br><span class="line">    <span class="comment">// 注意第#0号表项需要保留，不能使用</span></span><br><span class="line">    segment_desc_set(KERNEL_SELECTOR_DS, <span class="number">0</span>, <span class="number">0xFFFFFFFF</span>, </span><br><span class="line">        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA</span><br><span class="line">        | SEG_TYPE_RW | SEG_D</span><br><span class="line">    );</span><br><span class="line">    segment_desc_set(KERNEL_SELECTOR_CS, <span class="number">0</span>, <span class="number">0xFFFFFFFF</span>, </span><br><span class="line">        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE</span><br><span class="line">        | SEG_TYPE_RW | SEG_D</span><br><span class="line">    );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此说明此时<code>first_task</code>依旧是运行在特权级<code>0</code>的状态下。这是因为整个系统从内核加载、解析，一直到运行<code>first_task</code>时并没有对<code>TSS</code>的相关设置，只是对<code>TSS</code>进行了相应的初始化。</p>
<p>当进行第一次任务切换，由于运行了<code>sys_sleep()</code>函数，因此切换到<code>idle_task</code>时，相应的寄存器值就发生了改变。可以看到<code>CS</code>的低<code>2</code>位变成了<code>特权级3</code>，也就是说空闲任务运行在<code>特权级3</code>上。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192010866.png" alt="image-20240519201046181"></p>
<p>此时若按下<code>F11</code>，会发生异常。这是因为<code>idle_task</code>相关的代码是和操作系统代码绑定在一起编译的，存储在<code>1MB以下</code>的内存区域，而根据映射关系可知，这部分的<code>U/S</code>位是设置为<code>0</code>的，也就是用户特权级无法访问，但<code>idle_task</code>又处在用户级特权，相当于这里按照权限3去执行权限0的代码，因此发生了权限错误。</p>
<blockquote>
<p>目前存在的问题：</p>
<p><code>first_task</code>运行在权限级<code>0</code>，而<code>idle_task</code>反而运行在了权限级<code>3</code>，在后续应该对其进行调换。</p>
</blockquote>
<h2 id="11-3-调整异常处理函数"><a href="#11-3-调整异常处理函数" class="headerlink" title="11.3 调整异常处理函数"></a>11.3 调整异常处理函数</h2><h3 id="1、修改TSS字段初始化"><a href="#1、修改TSS字段初始化" class="headerlink" title="1、修改TSS字段初始化"></a>1、修改TSS字段初始化</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192018702.png" alt="image-20240519201803678"></p>
<p>当存在特权级变化时，若特权级<code>3</code>的程序&#x2F;任务发生了异常，则异常处理程序（<code>DPL=0</code>）不应在发生异常的那个栈中压入，而应该单独压入另一个特级为<code>0</code>的栈中。</p>
<p>针对<code>11.2</code>中的最后提出的问题，需要对<code>tss</code>初始化中的相关字段设置进行更改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">task-&gt;tss.ss = task-&gt;tss.ss0 = data_sel;</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">task-&gt;tss.ss0 = KERNEL_SELECTOR_DS;</span><br><span class="line">task-&gt;tss.ss = data_selc;</span><br></pre></td></tr></table></figure>

<p>此时就可以成功的跳转到<code>Page Fault Exception</code>异常中：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192048487.png" alt="image-20240519204839152"></p>
<h3 id="2、修改异常处理函数"><a href="#2、修改异常处理函数" class="headerlink" title="2、修改异常处理函数"></a>2、修改异常处理函数</h3><ul>
<li><p><code>do_handler_page_fault()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_handler_page_fault</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	    log_printf(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;IRQ/Exception happend: Page fault.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_PAGE_P) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tpage-level protection violation: 0x%x.&quot;</span>, read_cr2());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tPage doesn&#x27;t present 0x%x&quot;</span>, read_cr2());</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_PAGE_WR) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tThe access causing the fault was a read.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tThe access causing the fault was a write.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_PAGE_US) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tA supervisor-mode access caused the fault.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tA user-mode access caused the fault.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dump_core_regs(frame);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        hlt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>do_handler_general_protection</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_handler_general_protection</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;IRQ/Exception happend: General Protection.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_EXT) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;the exception occurred during delivery of an &quot;</span></span><br><span class="line">                <span class="string">&quot;event external to the program, such as an interrupt&quot;</span></span><br><span class="line">                <span class="string">&quot;or an earlier exception.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;the exception occurred during delivery of a&quot;</span></span><br><span class="line">                    <span class="string">&quot;software interrupt (INT n, INT3, or INTO).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_IDT) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;the index portion of the error code refers &quot;</span></span><br><span class="line">                    <span class="string">&quot;to a gate descriptor in the IDT&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;the index refers to a descriptor in the GDT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    log_printf(<span class="string">&quot;segment index: %d&quot;</span>, frame-&gt;error_code &amp; <span class="number">0xFFF8</span>);</span><br><span class="line"></span><br><span class="line">    dump_core_regs(frame);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        hlt();</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>修改后打印的异常信息更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192103797.png" alt="image-20240519210348190"></p>
<h2 id="11-4-修改空闲任务的特权级"><a href="#11-4-修改空闲任务的特权级" class="headerlink" title="11.4 修改空闲任务的特权级"></a>11.4 修改空闲任务的特权级</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192104590.png" alt="image-20240519210438905"  />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief TSS Initialization，当有程序/进程第一次运行时会调用tss_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tss_init</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">int</span> flags, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 根据不同的权限选择不同的访问选择子</span></span><br><span class="line">    <span class="type">int</span> code_sel, data_sel;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; TASK_FLAGS_SYSTEM) &#123;</span><br><span class="line">        <span class="comment">// 系统权限</span></span><br><span class="line">        code_sel = KERNEL_SELECTOR_CS;</span><br><span class="line">        data_sel = KERNEL_SELECTOR_DS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用户权限</span></span><br><span class="line">        code_sel = task_manager.app_code_sel | SEG_CPL3;</span><br><span class="line">        data_sel = task_manager.app_data_sel | SEG_CPL3;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 任务管理器初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">// 空闲任务初始化</span></span><br><span class="line">    task_init(&amp;task_manager.idle_task,</span><br><span class="line">        <span class="string">&quot;idle_task&quot;</span>,</span><br><span class="line">        TASK_FLAGS_SYSTEM,</span><br><span class="line">        (<span class="type">uint32_t</span>)idle_task_entry,</span><br><span class="line">        (<span class="type">uint32_t</span>)(idle_task_stack + IDLE_TASK_SIZE));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-5-修改用户任务的特权级"><a href="#11-5-修改用户任务的特权级" class="headerlink" title="11.5 修改用户任务的特权级"></a>11.5 修改用户任务的特权级</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192114720.png" alt="image-20240519211415052"></p>
<p>要实现从高特权级向低特权级的转移，需要使用<code>IRET</code>指令。</p>
<p>可以参考中断切换的操作，在<code>first_task</code>的<code>TSS</code>初始化时，将相应的字段手动压入栈中；然后再执行<code>IRET</code>指令，就可以返回到特权级<code>3</code>的状态。从而实现一种从高到低的特权级切换，并将寄存器的值设置到<code>CPU</code>中。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192115446.png" alt="image-20240519211502898" style="zoom:50%;" />

<p>代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// init.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从操作进程跳转到用户进程代码 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_to_first_task</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    ASSERT(curr != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出当前任务的tss中的eip字段，获取入口地址</span></span><br><span class="line">    <span class="type">tss_t</span> *tss = &amp;(curr-&gt;tss);</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        <span class="comment">// 模拟IRET中断返回，切换入第1个可运行应用进程</span></span><br><span class="line">        <span class="comment">// 不过这里并不直接进入到进程的入口，而是先设置好段寄存器，再跳过去</span></span><br><span class="line">        <span class="string">&quot;push %[ss]\n\t&quot;</span>			<span class="comment">// SS</span></span><br><span class="line">        <span class="string">&quot;push %[esp]\n\t&quot;</span>			<span class="comment">// ESP</span></span><br><span class="line">        <span class="string">&quot;push %[eflags]\n\t&quot;</span>        <span class="comment">// EFLAGS</span></span><br><span class="line">        <span class="string">&quot;push %[cs]\n\t&quot;</span>			<span class="comment">// CS</span></span><br><span class="line">        <span class="string">&quot;push %[eip]\n\t&quot;</span>		    <span class="comment">// ip</span></span><br><span class="line">        <span class="string">&quot;iret\n\t&quot;</span></span><br><span class="line">        ::[ss]<span class="string">&quot;r&quot;</span>(tss-&gt;ss),</span><br><span class="line">          [esp]<span class="string">&quot;r&quot;</span>(tss-&gt;esp),</span><br><span class="line">          [eflags]<span class="string">&quot;r&quot;</span>(tss-&gt;eflags),</span><br><span class="line">          [cs]<span class="string">&quot;r&quot;</span>(tss-&gt;cs),</span><br><span class="line">          [eip]<span class="string">&quot;r&quot;</span>(tss-&gt;eip)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时调试得到的寄存器值如下。可以看到<code>ds/es/fs/gs</code>的值都变成了<code>0x0</code>，这是因为特权级<code>0</code>时这些寄存器存在一些值，而当切换到特权级<code>3</code>时，这些选择子会被清零。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192125386.png" alt="image-20240519212526869"></p>
<p>此时再单步调试<code>F11</code>，会发现<code>CPU</code>发生了复位。查看<code>info mem</code>可以看出，<code>0x800000000以上</code>的地址空间其权限状态，即<code>U/S</code>位依旧需要高特权级才能访问，但此时应该是低特权级程序去访问这段空间。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192128843.png" alt="image-20240519212808376"></p>
<p>因此，需要在内存分配的相关代码中进行修改。</p>
<ul>
<li>在<code>task_first_init</code>加入属性值<code>PTE_U</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 分配一页内存供代码存放使用，然后将代码复制过去</span></span><br><span class="line">    memory_alloc_page_for(first_start, alloc_size, PTE_P | PTE_W | PTE_U);</span><br><span class="line">    kernel_memcpy((<span class="type">void</span> *)first_start, (<span class="type">void</span> *)s_first_task, copy_size);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>find_pte</code>加入属性值<code>PDE_U</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在page_dir中寻找vaddr对应的页表项/PTE</span></span><br><span class="line"><span class="comment"> * @param alloc 若PTE对应的Page Table不存在，是否需要进行分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pte_t</span> *<span class="title function_">find_pte</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    pde-&gt;v = pg_paddr | PDE_P | PDE_W | PDE_U;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时寄存器值的设置更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192135719.png" alt="image-20240519213521035"></p>
<h2 id="11-6-为进程添加特权级0的栈空间"><a href="#11-6-为进程添加特权级0的栈空间" class="headerlink" title="11.6 为进程添加特权级0的栈空间"></a>11.6 为进程添加特权级0的栈空间</h2><p>目前进程<code>特权级0</code>和<code>特权级3</code>使用的是同一个栈，因此需要额外创建一个栈，以便进行不同特权级栈的分享。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192142734.png" alt="image-20240519214216716"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 任务初始化</span></span><br><span class="line">    <span class="comment">// task_init(&amp;task_manager.first_task, &quot;first task&quot;, 0, first_start, 0);  </span></span><br><span class="line">    <span class="comment">// 对first_task的esp进行修改如下：</span></span><br><span class="line">    task_init(&amp;task_manager.first_task, <span class="string">&quot;first task&quot;</span>, <span class="number">0</span>, first_start, first_start + alloc_size);  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief TSS Initialization，当有程序/进程第一次运行时会调用tss_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tss_init</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">int</span> flags, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内核栈，得到的是物理地址</span></span><br><span class="line">    <span class="type">uint32_t</span> kernel_stack = memory_alloc_page();</span><br><span class="line">    <span class="keyword">if</span> (kernel_stack == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> tss_init_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    task-&gt;tss.esp = esp;  <span class="comment">// 指示调用tss_init的函数的栈顶的位置（此时栈为空）</span></span><br><span class="line">    task-&gt;tss.esp0 = kernel_stack + MEM_PAGE_SIZE;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">tss_init_failed:</span><br><span class="line">    gdt_free_sel(tss_sel);</span><br><span class="line">    <span class="keyword">if</span> (kernel_stack) &#123;</span><br><span class="line">        memory_free_page(kernel_stack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// memory.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取当前页表地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">pde_t</span> * <span class="title function_">current_page_dir</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">pde_t</span> *)task_current()-&gt;tss.cr3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 分配一页内存</span></span><br><span class="line"><span class="comment"> * 主要用于内核空间内存的分配，不用于进程内存空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">memory_alloc_page</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 内核空间虚拟地址与物理地址相同，因此可以直接调用</span></span><br><span class="line">    <span class="keyword">return</span> addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放一页内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_free_page</span> <span class="params">(<span class="type">uint32_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (addr &lt; MEM_TASK_BASE) &#123;</span><br><span class="line">        <span class="comment">// 若为内核空间，则直接释放</span></span><br><span class="line">        addr_free_page(&amp;paddr_alloc, addr, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若为进程空间，则还要释放页表</span></span><br><span class="line">        <span class="type">pte_t</span> * pte = find_pte(current_page_dir(), addr, <span class="number">0</span>);</span><br><span class="line">        ASSERT((pte == (<span class="type">pte_t</span> *)<span class="number">0</span>) &amp;&amp; pte-&gt;present);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放内存页</span></span><br><span class="line">        addr_free_page(&amp;paddr_alloc, pte_paddr(pte), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放页表</span></span><br><span class="line">        pte-&gt;v = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时进程就进入了特权级<code>3</code>的自己的栈：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192208389.png" alt="image-20240519220833546"></p>
<p>此时<code>info mem</code>的信息更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192210217.png" alt="image-20240519221009717"></p>
<p>此时继续运行会出现异常：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;first task.&quot;</span>);  <span class="comment">// F11单步调试此处出现异常</span></span><br><span class="line">        sys_sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192210492.png" alt="image-20240519221047950"></p>
<p>这是因为<code>log_printf</code>在操作系统进程（<code>0x00012bcd</code>）中，用户代码是没有权限访问的，因此需要在后续通过系统调用来解决。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192213396.png" alt="image-20240519221354822" style="zoom: 80%;" />

<h1 id="十二、建立系统调用"><a href="#十二、建立系统调用" class="headerlink" title="十二、建立系统调用"></a>十二、建立系统调用</h1><h2 id="12-1-实现系统调用的调用和返回"><a href="#12-1-实现系统调用的调用和返回" class="headerlink" title="12.1 实现系统调用的调用和返回"></a>12.1 实现系统调用的调用和返回</h2><h3 id="1、调用门"><a href="#1、调用门" class="headerlink" title="1、调用门"></a>1、调用门</h3><p>（1）调用门的作用</p>
<p>到目前为此，由于特权级的影响，特权级为<code>3</code>的应用进程无法直接访问特权级为<code>0</code>的操作进程的代码。</p>
<p>切换特权级的几种方法：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201002440.png" alt="image-20240520100207964" style="zoom:50%;" />

<p>应用程序可以通过<strong>调用门接口</strong>，实现在低特权级下对操作系统提供的接口函数进行调用。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201004667.png" alt="image-20240520100431449" style="zoom:50%;" />

<p>（2）调用门的描述符</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201005983.png" alt="image-20240520100512741" style="zoom:50%;" />

<p>（3）调用门的工作流程</p>
<p>调用门描述符实际上存放到<code>GDT</code>表中，应用调用门时需要传入对应的调用门选择子。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201008417.png" alt="image-20240520100843015" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201008739.png" alt="image-20240520100854431" style="zoom:50%;" />

<p>（4）权限检查，设置<code>CPL=3, RPL=0</code>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201010501.png" alt="image-20240520101031276" style="zoom:50%;" />

<h3 id="2、创建调用门"><a href="#2、创建调用门" class="headerlink" title="2、创建调用门"></a>2、创建调用门</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpu.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化GDT表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 添加调用门描述符</span></span><br><span class="line">    <span class="comment">// (SELECTOR_SYSCALL &gt;&gt; 3)  =&gt; 段选择子的低3位用作其他用途，高13为才用于索引index</span></span><br><span class="line">    <span class="comment">// selector                 =&gt; KERNEL_SELECTOR_CS，是因为被调函数是操作系统的代码</span></span><br><span class="line">    <span class="comment">// offset                   =&gt; 由于段基地址为0，因此被调函数的入口地址即为偏移量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当执行call指令时，会取选择子KERNEL_SELECTOR_CS找到代码段的起始地址，</span></span><br><span class="line">    <span class="comment">// 然后根据偏移量(uint32_t)exception_handler_syscall进入函数内部</span></span><br><span class="line">    gate_desc_set((<span class="type">gate_desc_t</span> *)(gdt_table + (SELECTOR_SYSCALL &gt;&gt; <span class="number">3</span>)), </span><br><span class="line">        KERNEL_SELECTOR_CS, </span><br><span class="line">        (<span class="type">uint32_t</span>)exception_handler_syscall, </span><br><span class="line">        GATE_P_PRESENT | GATE_DPL3 | GATE_TYPE_SYSCALL | SYSCALL_PARAM_COUNT</span><br><span class="line">    );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// init.c/start.S</span><br><span class="line"></span><br><span class="line">	.global exception_handler_syscall</span><br><span class="line">exception_handler_syscall:</span><br><span class="line">    retf $(5*4)</span><br></pre></td></tr></table></figure>

<h3 id="3、实现调用和返回"><a href="#3、实现调用和返回" class="headerlink" title="3、实现调用和返回"></a>3、实现调用和返回</h3><p>如果为每一个系统调用都提供一个对应的调用门，会占用较多的描述符表项。<strong>因此，可通过一个或少量几个调用门实现系统调用，从而节省资源。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201032921.png" alt="image-20240520103254777" style="zoom:50%;" />

<p>进入调用门：远跳转；</p>
<p>退出调用门：RET。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201046034.png" alt="image-20240520104642832" style="zoom:50%;" />

<p>代码实现：</p>
<p>通用系统调用结构<code>sys_call()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// applib/libsys.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用参数列表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">syscall_args_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;     <span class="comment">// 被调用函数的ID</span></span><br><span class="line">    <span class="type">int</span> arg0;</span><br><span class="line">    <span class="type">int</span> arg1;</span><br><span class="line">    <span class="type">int</span> arg2;</span><br><span class="line">    <span class="type">int</span> arg3;</span><br><span class="line">&#125;<span class="type">syscall_args_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep       0       <span class="comment">// sys_sleep()的ID</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">sys_call</span> <span class="params">(<span class="type">syscall_args_t</span> * args)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> addr[] = &#123;<span class="number">0</span>, SELECTOR_SYSCALL | <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// far jump</span></span><br><span class="line">    __asm__ __volatile__ (</span><br><span class="line">        <span class="string">&quot;push %[arg3]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg2]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg1]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg0]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[id]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;lcalll *(%[a])&quot;</span></span><br><span class="line">        ::[arg3]<span class="string">&quot;r&quot;</span>(args-&gt;arg3),</span><br><span class="line">          [arg2]<span class="string">&quot;r&quot;</span>(args-&gt;arg2),</span><br><span class="line">          [arg1]<span class="string">&quot;r&quot;</span>(args-&gt;arg1),</span><br><span class="line">          [arg0]<span class="string">&quot;r&quot;</span>(args-&gt;arg0),</span><br><span class="line">          [id]<span class="string">&quot;r&quot;</span>(args-&gt;id),</span><br><span class="line">          [a]<span class="string">&quot;r&quot;</span>(addr)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sys_sleep的系统调用</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">msleep</span> <span class="params">(<span class="type">int</span> ms)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ms &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_sleep;</span><br><span class="line">    args.arg0 = ms;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sys_call(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>lcalll</code>，即远跳转指令需要提供两个参数，段选择子和段内偏移，由<code>addr[]</code>提供。</p>
<ul>
<li><code>addr[0] = 0</code>，表示<strong>段内偏移</strong>，它指向系统调用处理函数的入口点。</li>
<li><code>addr[1] = SELECTOR_SYSCALL | 0</code>表示<strong>段选择子</strong>。<ul>
<li><code>SELECTOR_SYSCALL</code> 是被调用系统函数的段选择子；</li>
<li><code>| 0</code>是因为<code>RPL</code>设置为<code>0</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201109576.png" alt="image-20240520110945445" style="zoom:50%;" />

<ul>
<li><p>在保护模式下，x86架构使用段选择子和段内偏移配合进行内存寻址。例如，远调用指令<code>lcall</code>会使用段选择子和段内偏移来确定调用的目标地址：</p>
<ol>
<li><strong>段选择子</strong>：决定使用哪个段描述符，该描述符提供段的基地址和权限;</li>
<li><strong>段内偏移</strong>：在基地址的基础上加上偏移量，确定最终的内存地址。</li>
</ol>
</li>
<li><p>举例说明</p>
</li>
</ul>
<p>假设有一个段选择子<code>0x08</code>，它指向GDT中的一个代码段描述符，该描述符的基地址是<code>0x40000000</code>。如果段内偏移是<code>0x1000</code>，则最终的线性地址是：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">线性地址 = 段基地址 + 段内偏移</span><br><span class="line"><span class="code">          = 0x40000000 + 0x1000</span></span><br><span class="line"><span class="code">          = 0x40001000</span></span><br></pre></td></tr></table></figure>

<p>这种机制使得程序可以通过改变段选择子访问不同的内存段，同时确保通过权限控制防止未经授权的访问。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201059277.png" alt="image-20240520105948178"></p>
<p><code>far jump</code>将跳转到下图的代码处：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201100500.png" alt="image-20240520110014325" style="zoom: 80%;" />



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201210574.png" alt="image-20240520121051430"></p>
<p><code>ESP</code>指向<code>0x122fdc</code>地址处（<code>1MB空间以下</code>），其内存存储的值如下图所示。也就是说，在用户进程中压入<code>特权级3</code>的对应栈的相关参数已经复制到了<code>特权级0</code>的对应栈中。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201216326.png" alt="image-20240520121643956"></p>
<p>此时存在一些问题，若调用<code>RET</code>指令，不会执行特权级切换，因此需要采用<code>RETF</code>指令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exception_handler_syscall:</span><br><span class="line">    // ret</span><br><span class="line">    retf  // far return，即返回到不同的代码段中</span><br></pre></td></tr></table></figure>

<p>同时要注意，直接调用<code>REFT</code>时，在将<code>EIP/CS</code>弹出到对应的寄存器后，会直接从Parameter的位置开始弹出，这是系统“以为的”<code>ESP/SS</code>，如下图所示。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201221626.png" alt="image-20240520122108506" style="zoom: 50%;" />

<p>因此需要进行如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exception_handler_syscall:</span><br><span class="line">    retf $(5*4)</span><br></pre></td></tr></table></figure>

<h2 id="12-2-具体的调用实现"><a href="#12-2-具体的调用实现" class="headerlink" title="12.2 具体的调用实现"></a>12.2 具体的调用实现</h2><p>在进入系统调用处理程序之前，除了硬件<strong>自动压栈</strong>之外，还需要<strong>手动压栈</strong>一部分寄存器的值，以便后续使用。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201224360.png" alt="image-20240520122430073"></p>
<p>在系统调用内部，使用<strong>系统调用表</strong>来保存所有系统调用处理函数的入口地址。当发生系统调用时，通过查表来获取跳转点。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201251661.png" alt="image-20240520125101409"></p>
<h3 id="1、寄存器出入栈管理"><a href="#1、寄存器出入栈管理" class="headerlink" title="1、寄存器出入栈管理"></a>1、寄存器出入栈管理</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    .global exception_handler_syscall</span><br><span class="line">exception_handler_syscall:</span><br><span class="line">    # 寄存器入栈（此处为手动入栈，有部分由硬件自动入栈）</span><br><span class="line">    pusha</span><br><span class="line">    push %ds</span><br><span class="line">    push %es</span><br><span class="line">    push %fs</span><br><span class="line">    push %gs</span><br><span class="line">    pushf                # 手动压入调用门</span><br><span class="line">        </span><br><span class="line">    mov %esp, %eax</span><br><span class="line">    push %eax</span><br><span class="line">    call do_handler_syscall</span><br><span class="line">    add $<span class="number">4</span>, %esp</span><br><span class="line">        </span><br><span class="line">    # 寄存器出栈</span><br><span class="line">    popf</span><br><span class="line">    pop %gs</span><br><span class="line">    pop %fs</span><br><span class="line">    pop %es</span><br><span class="line">    pop %ds</span><br><span class="line">    popa</span><br><span class="line"></span><br><span class="line">    retf $(<span class="number">5</span>*<span class="number">4</span>) </span><br></pre></td></tr></table></figure>

<blockquote>
<pre><code>    pusha：将所有通用寄存器（EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI）的值压入栈中。
           这样可以保存调用者的寄存器状态。
    pushf：将标志寄存器 EFLAGS 的值压入栈中。
</code></pre>
</blockquote>
<blockquote>
<pre><code>mov %esp, %eax：
    将当前栈指针ESP的值移动到EAX寄存器中。
    这一步保存了当前的栈指针。
push %eax：
    将EAX寄存器（即栈指针ESP的值）压入栈中，作为参数传递给do_handler_syscall。
call do_handler_syscall：
    调用系统调用处理函数do_handler_syscall。
    在调用之前，栈中的ESP值被传递给该函数。
add $4, %esp：
    调整栈指针，移除之前压入的参数。
    由于调用do_handler_syscall后栈中多了一个参数（即EAX的值），需要将ESP增加4字节。
</code></pre>
</blockquote>
<h3 id="2、系统调用结构体"><a href="#2、系统调用结构体" class="headerlink" title="2、系统调用结构体"></a>2、系统调用结构体</h3><p>用于保存系统调用时的处理器状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用结构体，用于保存系统调用时的处理器状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">syscall_frame_t</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> eflags;</span><br><span class="line">	<span class="type">int</span> gs, fs, es, ds;</span><br><span class="line">	<span class="type">int</span> edi, esi, ebp, dummy, ebx, edx, ecx, eax;</span><br><span class="line">	<span class="type">int</span> eip, cs;</span><br><span class="line">	<span class="type">int</span> func_id, arg0, arg1, arg2, arg3;</span><br><span class="line">	<span class="type">int</span> esp, ss;</span><br><span class="line">&#125; <span class="type">syscall_frame_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">sys_call</span> <span class="params">(<span class="type">syscall_args_t</span> * args)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> addr[] = &#123;<span class="number">0</span>, SELECTOR_SYSCALL | <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// far jump</span></span><br><span class="line">    __asm__ __volatile__ (</span><br><span class="line">        <span class="string">&quot;push %[arg3]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg2]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg1]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg0]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[id]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;lcalll *(%[a])&quot;</span></span><br><span class="line">        :<span class="string">&quot;=a&quot;</span>(ret)</span><br><span class="line">        :[arg3]<span class="string">&quot;r&quot;</span>(args-&gt;arg3),</span><br><span class="line">         [arg2]<span class="string">&quot;r&quot;</span>(args-&gt;arg2),</span><br><span class="line">         [arg1]<span class="string">&quot;r&quot;</span>(args-&gt;arg1),</span><br><span class="line">         [arg0]<span class="string">&quot;r&quot;</span>(args-&gt;arg0),</span><br><span class="line">         [id]<span class="string">&quot;r&quot;</span>(args-&gt;id),</span><br><span class="line">         [a]<span class="string">&quot;r&quot;</span>(addr)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、转发表实现系统调用"><a href="#3、转发表实现系统调用" class="headerlink" title="3、转发表实现系统调用"></a>3、转发表实现系统调用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*<span class="type">syscall_handler_t</span>)</span><span class="params">(<span class="type">uint32_t</span> arg0, <span class="type">uint32_t</span> arg1, <span class="type">uint32_t</span> arg2, <span class="type">uint32_t</span> arg3)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用的转发表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">syscall_handler_t</span> sys_table[] = &#123;</span><br><span class="line">    [SYS_sleep] = (<span class="type">syscall_handler_t</span>)sys_sleep,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在调用该函数时，传递的frame参数所指向的内存地址处保存了相关的寄存器信息。在exception_handler_syscall函数中，</span></span><br><span class="line"><span class="comment"> *        相关的寄存器值被保存到栈上，然后ESP寄存器的值（即当前栈顶指针）被传递给do_handler_syscall函数。</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *        这个函数需要进行转发，找到需要调用的相应的系统函数。在frame中包含一个字段func_id，在对应的调用函数中是压入到</span></span><br><span class="line"><span class="comment"> *        syscall_args_t的id字段，并压入特权级3的栈中；在执行系统调用时，会被拷贝到特权级0的栈中（自动入栈），从而对</span></span><br><span class="line"><span class="comment"> *        应到相应的系统函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_syscall</span> <span class="params">(<span class="type">syscall_frame_t</span> *frame)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;func_id &lt; <span class="keyword">sizeof</span>(sys_table) / <span class="keyword">sizeof</span>(sys_table[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="comment">// 查表取得处理函数，然后调用处理</span></span><br><span class="line">        <span class="type">syscall_handler_t</span> handler  = sys_table[frame-&gt;func_id];</span><br><span class="line">        <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">            <span class="type">int</span> ret = handler(frame-&gt;arg0, frame-&gt;arg1, frame-&gt;arg2, frame-&gt;arg3);</span><br><span class="line">            frame-&gt;eax = ret;  <span class="comment">// eax用于存放函数的返回值，因此用ret赋值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数索引超出转发表</span></span><br><span class="line">    <span class="type">task_t</span> *task = task_current();</span><br><span class="line">    log_printf(<span class="string">&quot;task: %s, Unkown syscall: %d&quot;</span>, task-&gt;name, frame-&gt;func_id);</span><br><span class="line">    frame-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释<code>frame-&gt;eax = ret;</code>，从下图可以看出最终的返回值放到了<code>%eax</code>中：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201607868.png" alt="image-20240520160709366" style="zoom: 80%;" />

<blockquote>
<p>在执行<code>lcalll</code>指令时，进入<code>start.S</code>中执行<code>exception_handler_syscall</code>进行寄存器的出入栈操作。1）首先通过<code>pusha</code>将<code>eax</code>压栈；2）再通过<code>sys_getpid()</code>获取到<code>pid</code>作为返回值，并放入<code>frame-&gt;eax</code>中，此时就对<code>eax</code>的值进行了修改；3）最后通过<code>popa</code>将<code>eax</code>出栈，返回到上一层的调用函数<code>sys_call</code>中。</p>
<p>以<code>getpid()</code>为例，调用的函数堆栈顺序如下：</p>
<p><code>getpid()  -&gt;  sys_call()  -&gt;  do_handler_syscall()  -&gt; sys_getpid()</code></p>
<p>也就是说，<code>ret</code>的返回如上述逆序。</p>
</blockquote>
<p>调试运行时<code>frame</code>的相关参数：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201512535.png" alt="image-20240520151212263"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201511396.png" alt="image-20240520151158125"></p>
<h1 id="十三、新进程的加载与创建"><a href="#十三、新进程的加载与创建" class="headerlink" title="十三、新进程的加载与创建"></a>十三、新进程的加载与创建</h1><h2 id="13-1-实现fork系统调用"><a href="#13-1-实现fork系统调用" class="headerlink" title="13.1 实现fork系统调用"></a>13.1 实现fork系统调用</h2><h3 id="1、理论基础-12"><a href="#1、理论基础-12" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>（1）流程</p>
<p>系统调用的流程如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201647344.png" alt="image-20240520164706084"></p>
<p>（2）功能详述</p>
<p><code>fork()</code>系统调用的功能：创建一个进程的副本，并且<strong>继续从调用fork的地址往下运行</strong>。（这一点很重要！）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create child proc failed.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child: %d\n&quot;</span>, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child task id=%d\n&quot;</span>, pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent: %d\n&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201647127.png" alt="image-20240520164718779"></p>
<h3 id="2、任务块的分配和释放"><a href="#2、任务块的分配和释放" class="headerlink" title="2、任务块的分配和释放"></a>2、任务块的分配和释放</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述程序/进程运行状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> *<span class="title">parent</span>;</span>     <span class="comment">// 指明父进程    </span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure>

<p>将多个任务块存储在一个静态分配的进程表<code>task_table</code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> task_table[TASK_NR];                  <span class="comment">// 进程表，静态分配</span></span><br><span class="line"><span class="type">static</span> <span class="type">mutex_t</span> task_table_mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Task Initializtion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> flags, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    task-&gt;parent = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在进程表中进行分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> *<span class="title function_">alloc_task</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *task = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;task_table_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历进程表，找到没有名字的表项</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TASK_NR; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">task_t</span> *curr = task_table + i;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            task = curr;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;task_table_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在进程表中进行释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> *<span class="title function_">free_task</span> <span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    mutex_lock(&amp;task_table_mutex);</span><br><span class="line"></span><br><span class="line">    task-&gt;name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;task_table_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、初始化任务块"><a href="#3、初始化任务块" class="headerlink" title="3、初始化任务块"></a>3、初始化任务块</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建子进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *parent_task = task_current();</span><br><span class="line">    <span class="type">task_t</span> *child_task = alloc_task();</span><br><span class="line">    <span class="keyword">if</span> (child_task == (<span class="type">task_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取父进程执行系统调用时压栈的寄存器信息</span></span><br><span class="line">    <span class="type">syscall_frame_t</span> *frame = (<span class="type">syscall_frame_t</span> *)(parent_task-&gt;tss.esp0 - <span class="keyword">sizeof</span>(<span class="type">syscall_frame_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// frame-&gt;eip                                           ==&gt;  父进程执行系统调用的返回地址</span></span><br><span class="line">    <span class="comment">// frame-&gt;esp + sizeof(uint32_t) * SYSCALL_PARAM_COUNT  ==&gt;  恢复到对寄存器状态压栈之前的esp所指向的地址</span></span><br><span class="line">    <span class="type">int</span> err = task_init(child_task, parent_task-&gt;name, <span class="number">0</span>, </span><br><span class="line">                frame-&gt;eip, frame-&gt;esp + <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * SYSCALL_PARAM_COUNT</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">tss_t</span> *tss = &amp;child_task-&gt;tss;</span><br><span class="line">    tss-&gt;eax = <span class="number">0</span>;  <span class="comment">// 设置子进程的eax的返回值，使得调用fork()后子进程返回0</span></span><br><span class="line">    tss-&gt;ebx = frame-&gt;ebx;</span><br><span class="line">    tss-&gt;edx = frame-&gt;edx;</span><br><span class="line">    tss-&gt;ecx = frame-&gt;ecx;</span><br><span class="line">    tss-&gt;esi = frame-&gt;esi;</span><br><span class="line">    tss-&gt;edi = frame-&gt;edi;</span><br><span class="line">    tss-&gt;ebp = frame-&gt;ebp;</span><br><span class="line"></span><br><span class="line">    tss-&gt;cs = frame-&gt;cs;</span><br><span class="line">    tss-&gt;ds = frame-&gt;ds;</span><br><span class="line">    tss-&gt;es = frame-&gt;es;</span><br><span class="line">    tss-&gt;fs = frame-&gt;fs;</span><br><span class="line">    tss-&gt;fs = frame-&gt;gs;</span><br><span class="line">    tss-&gt;eflags = frame-&gt;eflags;</span><br><span class="line"></span><br><span class="line">    child_task-&gt;parent = parent_task;</span><br><span class="line"></span><br><span class="line">    tss-&gt;cr3 = parent_task-&gt;tss.cr3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child_task-&gt;pid;</span><br><span class="line"></span><br><span class="line">fork_failed:</span><br><span class="line">    <span class="keyword">if</span> (child_task) &#123;</span><br><span class="line">        task_uninit(child_task);</span><br><span class="line">        free_task(child_task);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在<code>sys_call()</code>中，当运行到<code>lcalll</code>指令时，会跳转到<code>start.S</code>的代码中执行压栈操作，也就是说此时保存了父进程相关的寄存器的所有信息。因此子进程只要能够也获取到<code>lcalll</code>指令调用时的内存信息，也即找到父进程的<code>syscall_frame_t</code>的指针，就可以获取到上述状态。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201950719.png" alt="image-20240520195025091"></p>
<p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">syscall_frame_t</span> *frame = (<span class="type">syscall_frame_t</span> *)(parent_task-&gt;tss.esp0 - <span class="keyword">sizeof</span>(<span class="type">syscall_frame_t</span>));</span><br></pre></td></tr></table></figure>



<p>父进程的执行完<code>fork()</code>后，是从特权级为<code>0</code>的代码返回到特权级为<code>3</code>的代码。</p>
<p>但对于子进程来说，只是通过<code>task_init</code>进行了初始化操作，包括对其<code>TSS</code>进行初始化。在父进程执行到<code>return</code>语句时它实际上并未运行，根据<code>first_task.c</code>的逻辑，会在父进程进入<code>msleep(1000);</code>睡眠时，通过任务切换<code>task_dispatch()</code>来切换到子进程中。此时子进程会从自己的<code>TSS</code>中进程对相关的寄存器进行状态恢复。</p>
<p>因此对于子进程来说，初始化子进程时传入的<code>esp</code>参数应该是和父进程的<code>esp</code>一致，但是区别在于子进程没有进行特权级切换，而是直接从特权级<code>3</code>的模式开始运行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    pid = fork();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot;task id= %d&quot;</span>, pid);</span><br><span class="line">        <span class="comment">////======///</span></span><br><span class="line">        msleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">////======///</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、复制进程地址空间"><a href="#4、复制进程地址空间" class="headerlink" title="4、复制进程地址空间"></a>4、复制进程地址空间</h3><p>在为子进程创建用户地址空间时，若共用同一页表，实际所用的存储空间就完全处在一页，当涉及到可读写数据时就可能导致冲突。比如，当涉及到栈空间时，父进程可能在执行时对<code>ESP</code>进行修改，这样当切换到子进程运行时，只能得到被破坏的寄存器状态，可能会造成返回出错，导致<code>Page Fault</code>的发生。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202030623.png" alt="image-20240520203019242"></p>
<p>因此，在为子进程创建用户地址空间时，<strong>只需要扫描父进程中<code>0x800000000</code>以上存在映射的地址区域，进行类似的映射。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202057353.png" alt="image-20240520205735959" style="zoom:50%;" />

<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建子进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为子进程分配单独的页表</span></span><br><span class="line">    <span class="keyword">if</span> ((tss-&gt;cr3 = memory_copy_uvm(parent_task-&gt;tss.cr3)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// memory.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 复制页表及其所有的内存空间 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">memory_copy_uvm</span> <span class="params">(<span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    <span class="comment">// 复制基础页表</span></span><br><span class="line">    <span class="type">uint32_t</span> to_page_dir = memory_create_uvm();</span><br><span class="line">    <span class="keyword">if</span> (to_page_dir == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> copy_uvm_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制页表中用户空间的各项</span></span><br><span class="line">    <span class="type">uint32_t</span> user_pde_start = pde_index(MEM_TASK_BASE);  <span class="comment">// PD表的索引</span></span><br><span class="line">    <span class="type">pde_t</span> *pde = (<span class="type">pde_t</span> *)page_dir + user_pde_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历用户空间页目录项</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = user_pde_start; i &lt; PDE_CNT; i++, pde++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pde-&gt;present) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历页表</span></span><br><span class="line">        <span class="type">pte_t</span> *pte = (<span class="type">pte_t</span> *)pde_paddr(pde);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; PTE_CNT; j++, pte++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pte-&gt;present) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 分配物理内存</span></span><br><span class="line">            <span class="type">uint32_t</span> page = addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (page == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> copy_uvm_failed;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立映射关系</span></span><br><span class="line">            <span class="type">uint32_t</span> vaddr = (i &lt;&lt; <span class="number">22</span>) | (j &lt;&lt; <span class="number">12</span>);</span><br><span class="line">            <span class="type">int</span> err = memory_create_map((<span class="type">pde_t</span> *)to_page_dir, vaddr, page, <span class="number">1</span>, get_pte_perm(pte));</span><br><span class="line">            <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> copy_uvm_failed;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 复制内容</span></span><br><span class="line">            kernel_memcpy((<span class="type">void</span> *)page, (<span class="type">void</span> *)vaddr, MEM_PAGE_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> to_page_dir;</span><br><span class="line"></span><br><span class="line">copy_uvm_failed:</span><br><span class="line">    <span class="keyword">if</span> (to_page_dir) &#123;</span><br><span class="line">        memory_destroy_uvm(to_page_dir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 销毁用户空间内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_destroy_uvm</span> <span class="params">(<span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> user_pde_start = pde_index(MEM_TASK_BASE);</span><br><span class="line">    <span class="type">pde_t</span> * pde = (<span class="type">pde_t</span> *)page_dir + user_pde_start;</span><br><span class="line"></span><br><span class="line">    ASSERT(page_dir != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放页表中对应的各项，不包含映射的内核页面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = user_pde_start; i &lt; PDE_CNT; i++, pde++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pde-&gt;present) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放页表对应的物理页 + 页表</span></span><br><span class="line">        <span class="type">pte_t</span> * pte = (<span class="type">pte_t</span> *)pde_paddr(pde);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; PTE_CNT; j++, pte++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pte-&gt;present) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            addr_free_page(&amp;paddr_alloc, pte_paddr(pte), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addr_free_page(&amp;paddr_alloc, (<span class="type">uint32_t</span>)pde_paddr(pde), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放页目录表</span></span><br><span class="line">    addr_free_page(&amp;paddr_alloc, page_dir, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-2-实现exec系统调用"><a href="#13-2-实现exec系统调用" class="headerlink" title="13.2 实现exec系统调用"></a>13.2 实现exec系统调用</h2><p>创建一个独立的应用程序文件，未来可<strong>单独放在磁盘上，并从磁盘上加载</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202146108.png" alt="image-20240520214639703" style="zoom:50%;" />

<p>对于一个<code>C</code>语言构建的应用程序，其入口地址并不是<code>main()</code>函数，如下图所示。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202148647.png" alt="image-20240520214815394" style="zoom:50%;" />

<h3 id="1、链接脚本设置"><a href="#1、链接脚本设置" class="headerlink" title="1、链接脚本设置"></a>1、链接脚本设置</h3><p>为了避免和<code>first_task</code>在调试时造成内存地址冲突，将起始地址设置为<code>0x81000000</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = 0x81000000; </span><br><span class="line"></span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ENTRY(_start)</code>这一句中的<code>_start</code>是<code>applib/crt0.S</code>文件的程序入口地址。这样做就是为了满足上图中<code>main</code>函数前还包含<code>crt0</code>和<code>clib</code>的框架结构。</p>
<h3 id="2、创建空exec调用"><a href="#2、创建空exec调用" class="headerlink" title="2、创建空exec调用"></a>2、创建空exec调用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib_syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @name 指明进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">execve</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">char</span> * <span class="type">const</span> *argv, <span class="type">char</span> * <span class="type">const</span> *env)</span> &#123;</span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_execve;</span><br><span class="line">    args.arg0 = (<span class="type">int</span>)name;</span><br><span class="line">    args.arg1 = (<span class="type">int</span>)argv;</span><br><span class="line">    args.arg2 = (<span class="type">int</span>)env;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sys_call(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用的转发表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">syscall_handler_t</span> sys_table[] = &#123;</span><br><span class="line">	...</span><br><span class="line">    [SYS_execve] = (<span class="type">syscall_handler_t</span>)sys_execve,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用当前的进程去运行新的程序内容，即加载一个进程，并非创建一个新的进程 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_execve</span> <span class="params">(<span class="type">char</span> *name, <span class="type">char</span> **argv, <span class="type">char</span> **env)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *task = task_current();</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> old_page_dir = task-&gt;tss.cr3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为该进程创建新的页表</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载ELF文件到内存中。要放在开启新页表之后，这样才能对相应的内存区域写</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前进程的页表，并销毁原页表</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">exec_failed:</span><br><span class="line">    <span class="keyword">if</span> (new_page_dir) &#123;</span><br><span class="line">        task-&gt;tss.cr3 = old_page_dir;</span><br><span class="line">        mmu_set_page_dir(old_page_dir);</span><br><span class="line">        memory_destroy_uvm(new_page_dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解析1：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * conts * argv</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>char * const * argv</code> 表示一个指向常量字符指针数组的指针。</li>
<li>用于表示命令行参数的 <code>argv</code>，其中每个参数是一个字符串（<code>char *</code>）。</li>
<li>指针本身是常量（不能改变指向），但指向的内容（字符串）是可以修改的。</li>
</ul>
</blockquote>
<ul>
<li>解析2：为什么执行<code>sys_exec()</code>时，需要创建一个新页表？在<code>fork()</code>时子进程不是已经有了自己的新页表了吗？</li>
</ul>
<blockquote>
<ol>
<li><p>区别解释</p>
</li>
<li><p><code>fork</code> 函数：用于创建一个子进程，这个子进程是当前进程的副本。它会复制当前进程的页表，并在子进程的地址空间中共享同样的物理内存。这样做的目的是让子进程拥有与父进程相同的执行环境。</p>
</li>
</ol>
<ul>
<li><p><strong>页表复制</strong>：<code>fork</code> 时，通过<code>memory_copy_uvm</code>函数为子进程创建一个新的页表，该页表是父进程页表的副本。这使得父子进程各自独立，但初始时共享同样的物理内存。</p>
</li>
<li><p><strong>子进程的返回值</strong>：子进程的<code>eax</code>寄存器被设为0，以便<code>fork</code>系统调用在子进程中返回0，而在父进程中返回子进程的PID。</p>
</li>
</ul>
<ol start="2">
<li><p><code>execve</code> 函数：用于用一个新程序替换当前进程的内容。调用<code>execve</code>后，当前进程的地址空间会被新程序的地址空间替代。</p>
<ul>
<li><p><strong>新页表的创建</strong>：<code>execve</code>需要一个干净的、新的页表，用于加载和运行新的程序。这是因为 <code>execve</code> 的目的是清除当前进程的地址空间并加载新程序，所以必须分配一个新的页表。</p>
</li>
<li><p><strong>加载新程序</strong>：在新页表中加载新的程序，这样可以确保新程序有一个干净的内存环境，不受之前进程状态的影响。</p>
</li>
<li><p><strong>销毁旧页表</strong>：一旦新程序成功加载，旧的页表被销毁，以释放不再需要的资源。</p>
</li>
</ul>
</li>
<li><p>执行流程中的细节</p>
</li>
</ol>
<p> 在<code>sys_execve</code>函数中，以下步骤确保了这一点：</p>
<ol>
<li><p><strong>旧页表的保存</strong>；</p>
</li>
<li><p><strong>新页表的创建</strong>；</p>
</li>
<li><p><strong>加载新程序</strong>；</p>
</li>
<li><p><strong>切换到新页表</strong>。</p>
</li>
<li><p>总结：这种设计方式确保了每个系统调用的预期功能和行为：<code>fork</code> 保留现有执行环境，而 <code>execve</code> 则彻底替换执行环境。</p>
</li>
</ol>
<ul>
<li><p><code>fork</code> 通过复制当前进程的页表，为子进程创建了一个新的、但初始内容相同的地址空间。</p>
</li>
<li><p><code>execve</code> 通过创建一个全新的页表并加载新程序，确保新程序在一个干净的内存环境中运行。</p>
</li>
</ul>
</blockquote>
<h3 id="3、添加虚拟文件访问接口"><a href="#3、添加虚拟文件访问接口" class="headerlink" title="3、添加虚拟文件访问接口"></a>3、添加虚拟文件访问接口</h3><p>为实现应用程序的加载，需要完成两点工作：</p>
<ul>
<li>分配相应的存储空间；</li>
<li>从<code>ELF</code>文件中读取数据并写入内存页中。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211017716.png" alt="image-20240521101728080"></p>
<p>目前仍未实现文件系统，因此采用下图的方式进行简单实现，只针对<code>shell.elf</code>文件进行处理：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211019558.png" alt="image-20240521101905366"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/include/fs/fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FS_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FS_H_</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> flags, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_lseek</span><span class="params">(<span class="type">int</span> file, <span class="type">int</span> ptr, <span class="type">int</span> dir)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_close</span><span class="params">(<span class="type">int</span> file)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _FS_H_</span></span></span><br></pre></td></tr></table></figure>

<h3 id="4、解析并加载ELF文件"><a href="#4、解析并加载ELF文件" class="headerlink" title="4、解析并加载ELF文件"></a>4、解析并加载ELF文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加载一个Phdr的数据到内存中</span></span><br><span class="line"><span class="comment"> * @param phdr      要加载的程序头</span></span><br><span class="line"><span class="comment"> * @param page_dir  程序头加载到的页表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_phdr</span><span class="params">(<span class="type">int</span> file, Elf32_Phdr *phdr, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    <span class="comment">// 生成的ELF文件要求是页边界对齐的</span></span><br><span class="line">    ASSERT((phdr-&gt;p_vaddr &amp; (MEM_PAGE_SIZE - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    <span class="type">int</span> err = memory_alloc_page_for_page_dir(page_dir, phdr-&gt;p_vaddr, phdr-&gt;p_memsz, PTE_P | PTE_U | PTE_W);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;no memory&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整当前的读写位置</span></span><br><span class="line">    <span class="comment">// 具体来说，指针需要从Phdr的位置移动到该Phdr指向的代码/数据段的具体位置，也即p_offset参数</span></span><br><span class="line">    <span class="keyword">if</span> (sys_lseek(file, phdr-&gt;p_offset, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为段分配所有的内存空间，后续操作如果失败将在上层释放</span></span><br><span class="line">    <span class="type">uint32_t</span> vaddr = phdr-&gt;p_vaddr;     <span class="comment">// 内存中的起始地址，只针对传入的新创建的page_dir参数有效</span></span><br><span class="line">    <span class="type">uint32_t</span> size = phdr-&gt;p_filesz;     <span class="comment">// 要拷贝的文件大小</span></span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断当前需要被拷贝的大小，一次最多只能拷贝一页</span></span><br><span class="line">        <span class="type">int</span> curr_size = (size &gt; MEM_PAGE_SIZE) ? MEM_PAGE_SIZE : size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到当前vaddr在page_dir中对应的物理地址</span></span><br><span class="line">        <span class="type">uint32_t</span> paddr = memory_get_paddr(page_dir, vaddr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这里传入(char *)vaddr，会将新页表中对应的内存地址传给当前使用的旧页表中</span></span><br><span class="line">        <span class="keyword">if</span> (sys_read(file, (<span class="type">char</span> *)paddr, curr_size) &lt; curr_size) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size -= curr_size;</span><br><span class="line">        vaddr += curr_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加载elf文件到内存中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">load_elf_file</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    Elf32_Ehdr elf_hdr;</span><br><span class="line">    Elf32_Phdr elf_phdr;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> file = sys_open(name, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (file &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;open failed. %s&quot;</span>, name);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先，读取文件头（ELF Header）</span></span><br><span class="line">    <span class="type">int</span> cnt = sys_read(file, (<span class="type">char</span> *)&amp;elf_hdr, <span class="keyword">sizeof</span>(elf_hdr));</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; <span class="keyword">sizeof</span>(Elf32_Ehdr)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;elf hdr too small. size= %d&quot;</span>, cnt);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做必要性检查</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr.e_ident[<span class="number">0</span>] != <span class="number">0x7F</span>) || (elf_hdr.e_ident[<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">        || (elf_hdr.e_ident[<span class="number">2</span>] != <span class="string">&#x27;L&#x27;</span>) || (elf_hdr.e_ident[<span class="number">3</span>] != <span class="string">&#x27;F&#x27;</span>)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;check elf indent failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须是可执行文件和针对386处理器的类型，且有入口</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr.e_type != ET_EXEC) || (elf_hdr.e_machine != ET_386) || (elf_hdr.e_entry == <span class="number">0</span>)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;check elf type or entry failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须有程序头部</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr.e_phentsize == <span class="number">0</span>) || (elf_hdr.e_phoff == <span class="number">0</span>)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;none programe header&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次，读取程序头（Program Header），将内容拷贝到相应的位置</span></span><br><span class="line">    <span class="type">uint32_t</span> e_phoff = elf_hdr.e_phoff;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elf_hdr.e_phnum; i++, e_phoff += elf_hdr.e_phentsize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sys_lseek(file, e_phoff, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取程序头后解析，这里不用读取到新进程的页表中，因为只是临时使用下</span></span><br><span class="line">        cnt = sys_read(file, (<span class="type">char</span> *)&amp;elf_phdr, <span class="keyword">sizeof</span>(Elf32_Phdr));</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="keyword">sizeof</span>(Elf32_Phdr)) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单做一些检查，主要判断是否是可加载的类型，并且要求加载的地址必须是用户空间</span></span><br><span class="line">        <span class="keyword">if</span> ((elf_phdr.p_type != PT_LOAD) || (elf_phdr.p_vaddr &lt; MEM_TASK_BASE)) &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载当前程序头</span></span><br><span class="line">        <span class="type">int</span> err = load_phdr(file, &amp;elf_phdr, page_dir);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;load program hdr failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    sys_close(file);</span><br><span class="line">    <span class="keyword">return</span> elf_hdr.e_entry;</span><br><span class="line"></span><br><span class="line">load_failed:</span><br><span class="line">    <span class="keyword">if</span> (file &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sys_close(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>有一个要注意的点在于：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211223596.png" alt="image-20240521122318108"></p>
<p>绿色框中框出的这两部分看起来好像是连续的，实际在对其进行拷贝时会发现它并非是连续的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">load_elf_file</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载当前程序头</span></span><br><span class="line">    <span class="comment">// =============================================== //</span></span><br><span class="line">    <span class="type">int</span> err = load_phdr(file, &amp;elf_phdr, page_dir);</span><br><span class="line">    <span class="comment">// =============================================== //</span></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;load program hdr failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_phdr</span><span class="params">(<span class="type">int</span> file, Elf32_Phdr *phdr, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// =============================================== //</span></span><br><span class="line">    <span class="comment">// 为所有的段分配内存空间并复制</span></span><br><span class="line">    <span class="comment">// =============================================== //</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述程序，在<code>21</code>行调用<code>load_phdr()</code>时传入了新建进程时新创建的页表<code>page_dir</code>，但在<code>load_phdr()</code>内部执行到段分配空间并复制时，实际用到的并非是这个新创建的<code>page_dir</code>，而是<code>first_task</code>在运行时创建的那个页表。</p>
<p>由于在<code>page_dir</code>这个页表中包含的映射关系并未被启用，也就是说在这个新页表中连续的一段内存空间在原来的页表中实际上是不连续的。需要将原页表的内容不连续地拷贝到新页表中。</p>
<p>需要像下面这样操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到当前vaddr在page_dir中对应的物理地址</span></span><br><span class="line"><span class="type">uint32_t</span> paddr = memory_get_paddr(page_dir, vaddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这里传入(char *)vaddr，会将新页表中对应的内存地址传给当前使用的旧页表中</span></span><br><span class="line"><span class="keyword">if</span> (sys_read(file, (<span class="type">char</span> *)paddr, curr_size) &lt; curr_size) &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、分配栈并进入进程执行"><a href="#5、分配栈并进入进程执行" class="headerlink" title="5、分配栈并进入进程执行"></a>5、分配栈并进入进程执行</h3><p>新进程的栈分配空间与<code>first_task</code>可能不相同。</p>
<p><code>first_task</code>的栈是紧挨着<code>.bss</code>段放置的，整体的空间不够大，对于<code>shell</code>来说，当后期涉及到堆空间以及一些较大的栈空间需求时很会麻烦，因此需要重新建立。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_TASK_STACK_TOP  0xE0000000              <span class="comment">// shell进程的栈空间起始地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_TASK_STACK_SIZE     (MEM_PAGE_SIZE * 500)   <span class="comment">// shell进程的栈空间大小</span></span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211449653.png" alt="image-20240521144933288" style="zoom:50%;" />

<p>这个新分配的栈是需要返回给<code>shell</code>使用在特权级<code>3</code>的状态下的，但进程在使用时也会涉及到系统调用和中断等处理。因此，对于操作系统相关的代码可以<strong>继续使用原来建立的特权级<code>0</code>的栈</strong>，此处只需要对<strong>新分配属于自己的特权级<code>3</code>的栈</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211451843.png" alt="image-20240521145151527"></p>
<p>特权级<code>0</code>的栈保存了<code>frst_task</code>的相关信息，由于此处对于原来的页表进行了销毁，因此若不做相应的处理，返回到的内存地址处实际上是没有任何有效信息的，会造成错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新当前进程的页表</span></span><br><span class="line">task-&gt;tss.cr3 = new_page_dir;</span><br><span class="line">mmu_set_page_dir(new_page_dir);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁原来的旧页表</span></span><br><span class="line">memory_destroy_uvm(old_page_dir);</span><br></pre></td></tr></table></figure>

<p>因此<strong>在更新页表前（上述代码）</strong>，需要先找到特权级<code>0</code>的栈，并对其中的相关寄存器值进行修改，以便在系统调用返回时能够切换回到<code>shell</code>进程中。</p>
<p>对寄存器值的修改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用当前的进程去运行新的程序内容，即加载一个进程，并非创建一个新的进程 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_execve</span> <span class="params">(<span class="type">char</span> *name, <span class="type">char</span> **argv, <span class="type">char</span> **env)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载完毕，为程序的执行做必要准备</span></span><br><span class="line">    <span class="comment">// 注意，exec的作用是替换掉当前进程，所以只要改变当前进程的执行流即可</span></span><br><span class="line">    <span class="comment">// 当该进程恢复运行时，像完全重新运行一样，所以用户栈要设置成初始模式</span></span><br><span class="line">    <span class="comment">// 运行地址要设备成整个程序的入口地址</span></span><br><span class="line">    <span class="type">syscall_frame_t</span> * frame = (<span class="type">syscall_frame_t</span> *)(task-&gt;tss.esp0 - <span class="keyword">sizeof</span>(<span class="type">syscall_frame_t</span>));</span><br><span class="line">    frame-&gt;eip = entry;  <span class="comment">// 修改为shell进程的入口地址</span></span><br><span class="line">    frame-&gt;eax = frame-&gt;ebx = frame-&gt;ecx = frame-&gt;edx = <span class="number">0</span>;</span><br><span class="line">    frame-&gt;esi = frame-&gt;edi = frame-&gt;ebp = <span class="number">0</span>;</span><br><span class="line">    frame-&gt;eflags = EFLAGS_DEFAULT| EFLAGS_IF;  <span class="comment">// 段寄存器无需修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内核栈不用设置，保持不变，后面调用memory_destroy_uvm并不会销毁内核栈的映射。</span></span><br><span class="line">    <span class="comment">// 但用户栈需要更改, 同样要加上调用门的参数压栈空间</span></span><br><span class="line">    frame-&gt;esp = stack_top - <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * SYSCALL_PARAM_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前进程的页表</span></span><br><span class="line">    task-&gt;tss.cr3 = new_page_dir;</span><br><span class="line">    mmu_set_page_dir(new_page_dir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁原来的旧页表</span></span><br><span class="line">    memory_destroy_uvm(old_page_dir);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、为进程传递参数"><a href="#6、为进程传递参数" class="headerlink" title="6、为进程传递参数"></a>6、为进程传递参数</h3><p><code>cstart.c</code>实际上是有参数的，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cstart</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    main(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// argc 存储参数的总个数，含应用程序的名字</span></span><br><span class="line"><span class="comment">// argv 参数的字符串指针数组</span></span><br></pre></td></tr></table></figure>

<p>在<code>C</code>语言中，如果需要传参的话，会将参数放入栈中。而此时的<code>esp = 0xE0000000</code>，对于当前进程来说，此时的参数保存在<code> 0xE0000000</code>以上的位置，但实际上此处是并未分配内存的，因此会造成异常。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211557399.png" alt="image-20240521155717841" style="zoom:50%;" />

<p>因此，在调用<code>main</code>函数之前，需要先往栈中压入<code>argc/argv</code>参数值：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211620385.png" alt="image-20240521162034894" style="zoom:50%;" />

<p>修改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进程参数结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_args_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> ret_addr;</span><br><span class="line">    <span class="type">uint32_t</span> argc;</span><br><span class="line">    <span class="type">char</span> **argv;</span><br><span class="line">&#125; <span class="type">task_args_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用当前的进程去运行新的程序内容，即加载一个进程，并非创建一个新的进程 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_execve</span> <span class="params">(<span class="type">char</span> *name, <span class="type">char</span> **argv, <span class="type">char</span> **env)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配用户栈空间，预留环境环境及参数的空间</span></span><br><span class="line">    <span class="type">uint32_t</span> stack_top = MEM_TASK_STACK_TOP - MEM_TASK_ARG_SIZE;</span><br><span class="line">    <span class="type">int</span> err = memory_alloc_page_for_page_dir(</span><br><span class="line">        new_page_dir, </span><br><span class="line">        MEM_TASK_STACK_TOP - MEM_TASK_STACK_SIZE,</span><br><span class="line">        MEM_TASK_STACK_SIZE,</span><br><span class="line">        PTE_P | PTE_U | PTE_W</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> exec_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制参数，写入到栈顶的后边</span></span><br><span class="line">    <span class="type">int</span> argc = string_count(argv);</span><br><span class="line">    err = copy_args((<span class="type">char</span> *)stack_top, new_page_dir, argc, argv);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> exec_failed;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）参数拷贝函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 参数拷贝</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param to        要拷贝到何处</span></span><br><span class="line"><span class="comment"> * @param page_dir  对应的页表</span></span><br><span class="line"><span class="comment"> * @param argc      要拷贝的参数个数</span></span><br><span class="line"><span class="comment"> * @param argv      要拷贝的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_args</span><span class="params">(<span class="type">char</span> *to, <span class="type">uint32_t</span> page_dir, <span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// 在stack_top中依次写入argc, argv指针，参数字符串</span></span><br><span class="line">    <span class="type">task_args_t</span> task_args;</span><br><span class="line">    task_args.argc = argc;</span><br><span class="line">    task_args.argv = (<span class="type">char</span> **)(to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制各项参数, 跳过task_args和参数表</span></span><br><span class="line">    <span class="comment">// 定义各argv参数写入的内存空间</span></span><br><span class="line">    <span class="type">char</span> * dest_arg = to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>) + <span class="keyword">sizeof</span>(<span class="type">char</span> *) * (argc);   <span class="comment">// 留出结束符</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// argv表</span></span><br><span class="line">    <span class="type">char</span> ** dest_argv_tb = (<span class="type">char</span> **)memory_get_paddr(page_dir, (<span class="type">uint32_t</span>)(to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>)));</span><br><span class="line">    ASSERT(dest_argv_tb != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="type">char</span> *from = argv[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能用kernel_strcpy，因为to和argv不在一个页表里</span></span><br><span class="line">        <span class="type">int</span> len = kernel_strlen(from) + <span class="number">1</span>;  <span class="comment">// +1是为了加上&#x27;\0&#x27;</span></span><br><span class="line">        <span class="type">int</span> err = memory_copy_uvm_data((<span class="type">uint32_t</span>)dest_arg, page_dir, (<span class="type">uint32_t</span>)from, len);</span><br><span class="line">        ASSERT(err &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关联字符串与对应的字符串指针</span></span><br><span class="line">        dest_argv_tb[i] = dest_arg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录下位置后，复制的位置前移</span></span><br><span class="line">        dest_arg += len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入task_args</span></span><br><span class="line">    <span class="keyword">return</span> memory_copy_uvm_data((<span class="type">uint32_t</span>)to, page_dir, (<span class="type">uint32_t</span>)&amp;task_args, <span class="keyword">sizeof</span>(task_args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">task_args.argv = (<span class="type">char</span> **)(to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>));  <span class="comment">// 得到char **argv的起始地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *dest_arg = to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>) + <span class="keyword">sizeof</span>(<span class="type">char</span> *) * argc;  <span class="comment">// 获取argv中具体的每一个字符串的起始地址</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211649751.png" alt="image-20240521164949480" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">task_args.argv = (<span class="type">char</span> **)(to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>));  <span class="comment">// 得到argv的起始地址</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211641068.png" alt="image-20240521164157766" style="zoom:50%;" />

<p>（2）重要函数：在不同的页表间拷贝数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在不同的页表间拷贝数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param to        要拷贝的目的地址</span></span><br><span class="line"><span class="comment"> * @param page_dir  地址所在的页表</span></span><br><span class="line"><span class="comment"> *                  注意传入的page_dir为新页表，而当前仍在使用旧页表，因此需要结合物理地址来操作</span></span><br><span class="line"><span class="comment"> * @param from      当前地址</span></span><br><span class="line"><span class="comment"> * @param size      拷贝的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memory_copy_uvm_data</span><span class="params">(<span class="type">uint32_t</span> to, <span class="type">uint32_t</span> page_dir, <span class="type">uint32_t</span> from, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取to对应的物理地址</span></span><br><span class="line">        <span class="type">uint32_t</span> to_paddr = memory_get_paddr(page_dir, to);</span><br><span class="line">        <span class="keyword">if</span> (to_paddr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// to_paddr在自己所在物理页的偏移量</span></span><br><span class="line">        <span class="type">uint32_t</span> offset_in_page = to_paddr &amp; (MEM_PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将from的数据拷贝到该偏移量处</span></span><br><span class="line">        <span class="type">uint32_t</span> curr_size = MEM_PAGE_SIZE - offset_in_page;</span><br><span class="line">        <span class="keyword">if</span> (curr_size &gt; size) &#123;</span><br><span class="line">            curr_size = size;</span><br><span class="line">        &#125;</span><br><span class="line">        kernel_memcpy((<span class="type">void</span> *)to_paddr, (<span class="type">void</span> *)from, curr_size);</span><br><span class="line"></span><br><span class="line">        size -= curr_size;</span><br><span class="line">        to += curr_size;</span><br><span class="line">        from += curr_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-3-实现sys-yiled系统调用"><a href="#13-3-实现sys-yiled系统调用" class="headerlink" title="13.3 实现sys_yiled系统调用"></a>13.3 实现sys_yiled系统调用</h2><h3 id="1、解决task-init遗留问题"><a href="#1、解决task-init遗留问题" class="headerlink" title="1、解决task_init遗留问题"></a>1、解决task_init遗留问题</h3><p>在<code>sys_fork()</code>中，创建子进程时会调用<code>task_init()</code>函数，在这个函数中会对进程进行初始化，然后就加入<code>ready_list</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任务加入ready_list</span></span><br><span class="line">task_set_ready(task);</span><br></pre></td></tr></table></figure>

<p>但在<code>sys_fork()</code>中，执行的逻辑是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建子进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 对子进程进行初始化，并对必要的字段进行调整</span></span><br><span class="line">    <span class="type">int</span> err = task_init(child_task, parent_task-&gt;name, <span class="number">0</span>, </span><br><span class="line">                frame-&gt;eip, frame-&gt;esp + <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * SYSCALL_PARAM_COUNT</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从父进程的栈中取部分状态，然后写入子进程的tss</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为子进程分配单独的页表</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child_task-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，在<code>#8</code>行就将这个子进程加入<code>ready_list</code>中了，但此时的子进程仍未初始化完毕，包括对<code>TSS</code>以及对内存空间等的初始化，此时若发生了定时中断，就会发生<code>task_dispatch()</code>，切换到还未初始化完成的子进程中进行，造成错误。如下图所示，在执行完<code>first_task</code>的相关任务后，运行到<code>shell</code>进程的<code>fork()</code>操作时，会出现<code>CPU</code>重启：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shell/main.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot;arg: %s&quot;</span>, (<span class="type">int</span>)argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fork();</span><br><span class="line">    yield();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot;shell pid=%d&quot;</span>, getpid());</span><br><span class="line">        msleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211941992.png" alt="image-20240521194153623"></p>
<p>因此，需要对<code>task_init()</code>进行修改，删除加入就绪队列的部分，并新建一个函数专门用于启动进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 启动任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_start</span><span class="params">(<span class="type">task_t</span> * task)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line">    </span><br><span class="line">    task_set_ready(task);</span><br><span class="line">    </span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、测试sys-yield"><a href="#2、测试sys-yield" class="headerlink" title="2、测试sys_yield()"></a>2、测试sys_yield()</h3><p><code>fork()</code>会调用两次。</p>
<p>出现异常：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221254675.png" alt="image-20240522125434543"></p>
<p>调试结果如下：</p>
<blockquote>
<p>根据提供的信息，故障发生时的关键寄存器和状态如下：</p>
<ul>
<li><strong>CS</strong>: 8 (内核代码段)</li>
<li><strong>EIP</strong>: 0x13757</li>
<li><strong>EAX</strong>: 0x13E000 (发生Page fault时访问的地址)</li>
<li><strong>ESP</strong>: 0x12FF2C</li>
<li><strong>EFLAGS</strong>: 0x206</li>
<li><strong>Error code</strong>: 11 (0000 1011)</li>
</ul>
<ul>
<li>Page fault错误代码分析</li>
</ul>
<ol>
<li>错误代码<code>11</code>（0000 1011）解释如下：</li>
</ol>
<ul>
<li><p>第0位（P）：0，表示该页没有被加载到内存中。</p>
</li>
<li><p>第1位（W&#x2F;R）：1，表示是写操作引起的。</p>
</li>
<li><p>第2位（U&#x2F;S）：1，表示是用户模式访问引起的。</p>
</li>
<li><p>第3位（RSV）：0，保留位。</p>
</li>
</ul>
<ol start="2">
<li>错误原因分析</li>
</ol>
<p>根据错误代码和寄存器值，访问地址0x13E000没有被映射到内存中，导致Page fault。发生Page fault的地方在0x13757，表示发生错误的指令位于该地址。</p>
<ol start="3">
<li><p>可能原因及排查步骤</p>
</li>
<li><p><strong>检查页表和内存管理</strong>：</p>
<ul>
<li>确保在fork过程中，子进程正确地继承和复制了父进程的页表。</li>
<li>在<code>sys_execve</code>过程中，确保新的页表正确创建和切换。</li>
<li>确保<code>memory_copy_uvm</code>函数正确地复制了页表。</li>
</ul>
</li>
<li><p><strong>查看发生异常的代码段</strong>：</p>
<ul>
<li>确定<code>EIP</code>值0x13757处的代码在执行什么操作。可能需要反汇编或调试来了解具体指令。</li>
</ul>
</li>
<li><p><strong>检查栈和寄存器状态</strong>：</p>
<ul>
<li><p>确认栈指针（ESP）和基址指针（EBP）的值是否合理。</p>
</li>
<li><p>检查<code>sys_execve</code>和<code>sys_fork</code>过程中对栈的操作是否正确。</p>
</li>
</ul>
</li>
<li><p><strong>日志和调试信息</strong>：</p>
<ul>
<li>增加更多日志，特别是在切换页表和分配内存时，记录相关操作的详细信息。</li>
</ul>
</li>
</ol>
</blockquote>
<h1 id="十四、使用c标准库中的printf输出"><a href="#十四、使用c标准库中的printf输出" class="headerlink" title="十四、使用c标准库中的printf输出"></a>十四、使用c标准库中的printf输出</h1><p>本章节搭建了文件系统框架，引入了字符设备驱动程序，并引用<code>newlib</code>。</p>
<h2 id="14-1-增加文件系统调用"><a href="#14-1-增加文件系统调用" class="headerlink" title="14.1 增加文件系统调用"></a>14.1 增加文件系统调用</h2><p>整理<code>app</code>库下面的所有文件：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405220934175.png" alt="image-20240522093404627" style="zoom:50%;" />

<p>在<code>libapp.a</code>中包含了<code>lib_syscall.c</code>相关的代码。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405220952365.png" alt="image-20240522095247136"></p>
<p>因此在将<code>lib_syscall.h</code>中的内联函数修改到<code>lib_syscall.c</code>中后，需要将<code>shell</code>工程与<code>applib.a</code>这个库链接起来。</p>
<p>在<code>kernel/CMakeLists.txt</code>中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(LIBS_FLAGS &quot;-L $&#123;CMAKE_BINARY_DIR&#125;/source/applib/ -lapp&quot;)</span><br><span class="line">set(CMAKE_EXE_LINKER_FLAGS &quot;-m elf_i386  -T $&#123;PROJECT_SOURCE_DIR&#125;/kernel.lds $&#123;LIBS_FLAGS&#125;&quot;)</span><br></pre></td></tr></table></figure>



<p>此时调试，会发现进入<code>getpid()</code>内部时出现异常，其中	<code>EIP=0x13D77</code>，说明是在<code>1MB</code>空间内出现了异常。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">3</span>;  <span class="comment">// 父子进程各自拥有一份自己的count</span></span><br><span class="line">    <span class="type">int</span> pid = getpid();  <span class="comment">// here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405220958926.png" alt="image-20240522095820675"></p>
<p>在<code>kernel_dis.txt</code>文件中对<code>getpid()</code>进程搜索，发现其所处的位置即在<code>1MB</code>空间内。但它作为一个系统调用的接口函数，不应该放在操作系统空间内，而应该放在用户进程空间内，即<code>0x80000000</code>以上的位置。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221000006.png" alt="image-20240522100021888"></p>
<p>因此需要对<code>kernel/kernel.lds</code>进行修改，将<code>applib</code>相关的代码和数据放到<code>0x80000000</code>以上的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. = 0x80000000;</span><br><span class="line">PROVIDE(s_first_task = LOADADDR(.first_task));</span><br><span class="line">.first_task : AT(e_data) &#123;</span><br><span class="line">	*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">	*first_task*(.text .rodata .bss .data)</span><br><span class="line">	*lib_syscall*(.text .rodata .bss .data)</span><br><span class="line">&#125;</span><br><span class="line">PROVIDE(e_first_task = LOADADDR(.first_task) + SIZEOF(.first_task));</span><br></pre></td></tr></table></figure>

<p>再次调试，<code>EIP</code>的地址正确：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221007171.png" alt="image-20240522100723076"></p>
<h2 id="14-2-导入newlib-c并引入printf"><a href="#14-2-导入newlib-c并引入printf" class="headerlink" title="14.2 导入newlib c并引入printf"></a>14.2 导入newlib c并引入printf</h2><p><code>newlib</code>库简介：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221022455.png" alt="image-20240522102216196"></p>
<p>引入<code>newlib</code>库之后的整体结构：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221023403.png" alt="image-20240522102346233" style="zoom:50%;" />

<p>在<code>shell</code>工程中引入<code>newlib</code>库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(LIBS_FLAGS &quot;-L $&#123;CMAKE_BINARY_DIR&#125;/source/applib/ -lapp -L $&#123;CMAKE_BINARY_DIR&#125;/../../newlib/i686-elf/lib -lm -lc&quot;)</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221057186.png" alt="image-20240522105741951"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221059676.png" alt="image-20240522105925398"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加载elf文件到内存中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">load_elf_file</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次，读取程序头（Program Header），将内容拷贝到相应的位置</span></span><br><span class="line">    <span class="type">uint32_t</span> e_phoff = elf_hdr.e_phoff;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elf_hdr.e_phnum; i++, e_phoff += elf_hdr.e_phentsize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sys_lseek(file, e_phoff, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取程序头后解析，这里不用读取到新进程的页表中，因为只是临时使用下</span></span><br><span class="line">        cnt = sys_read(file, (<span class="type">char</span> *)&amp;elf_phdr, <span class="keyword">sizeof</span>(Elf32_Phdr));</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="keyword">sizeof</span>(Elf32_Phdr)) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单做一些检查，主要判断是否是可加载的类型，并且要求加载的地址必须是用户空间</span></span><br><span class="line">        <span class="keyword">if</span> ((elf_phdr.p_type != PT_LOAD) || (elf_phdr.p_vaddr &lt; MEM_TASK_BASE)) &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载当前程序头</span></span><br><span class="line">        <span class="type">int</span> err = load_phdr(file, &amp;elf_phdr, page_dir);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;load program hdr failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ========================= 新增 ========================= //</span></span><br><span class="line">        <span class="comment">// 设置first_task的堆起始地址和结束地址</span></span><br><span class="line">        task-&gt;heap_start = elf_phdr.p_vaddr + elf_phdr.p_memsz;  </span><br><span class="line">        	<span class="comment">// 通过循环，最终指向进程地址空间中最后一个表项的末端地址</span></span><br><span class="line">        	<span class="comment">// 也就是指向.bss的末端地址</span></span><br><span class="line">        task-&gt;heap_end = task-&gt;heap_start;</span><br><span class="line">        <span class="comment">// ========================= 新增 ========================= //</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、sbrk"><a href="#1、sbrk" class="headerlink" title="1、sbrk()"></a>1、sbrk()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 调整堆的内存分配，返回堆之前的指针</span></span><br><span class="line"><span class="comment"> *        目前并不处理incr小于0的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">sys_sbrk</span><span class="params">(<span class="type">int</span> incr)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *task = task_current();</span><br><span class="line">    <span class="type">int</span> pre_incr = incr;</span><br><span class="line">    <span class="type">char</span> *pre_heap_end = (<span class="type">char</span> *)task-&gt;heap_end;  <span class="comment">// 获取当前堆的末端地址</span></span><br><span class="line"></span><br><span class="line">    ASSERT(incr &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (incr == <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;sbrk(0): end=0x%x&quot;</span>, pre_heap_end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre_heap_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增长空间的起始地址（即原末端地址），和末端地址</span></span><br><span class="line">    <span class="type">uint32_t</span> start = task-&gt;heap_end;</span><br><span class="line">    <span class="type">uint32_t</span> end = start + incr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x81001024 - 0x81001048      0x81001024并非页边界对齐 ： 0x81001000 </span></span><br><span class="line">    <span class="comment">// 0x81001000 - 0x81001FFF      假定这块内存已经存在</span></span><br><span class="line">    <span class="type">int</span> start_offset = start % MEM_PAGE_SIZE;  <span class="comment">// 0x24，start地址在页中的偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (start_offset) &#123;</span><br><span class="line">        <span class="comment">// 若起始地址并非页边界对齐</span></span><br><span class="line">        <span class="keyword">if</span> (start_offset + incr &lt;= MEM_PAGE_SIZE) &#123;</span><br><span class="line">            <span class="comment">// 0x24 + incr 若并未超过一页，直接在原内存中分配</span></span><br><span class="line">            task-&gt;heap_end = end;  <span class="comment">// 0x81001048</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> pre_heap_end;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若超过一页，则先分配掉一页</span></span><br><span class="line">            <span class="type">uint32_t</span> curr_size = MEM_PAGE_SIZE - start_offset;  <span class="comment">// 当前页可分配内存</span></span><br><span class="line">            start += curr_size;</span><br><span class="line">            incr -= curr_size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若incr还有剩余，则新分配页来处理</span></span><br><span class="line">    <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> curr_size = end - start;</span><br><span class="line">        <span class="type">int</span> err = memory_alloc_page_for(start, curr_size, PTE_P | PTE_U | PTE_W);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;sbrk: alloc mem failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">char</span> *)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_printf(<span class="string">&quot;sbrk(%d): end = 0x%x&quot;</span>, pre_incr, end);</span><br><span class="line">    task-&gt;heap_end = end;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span> * )pre_heap_end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib_syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    sbrk(<span class="number">0</span>);</span><br><span class="line">    sbrk(<span class="number">100</span>);</span><br><span class="line">    sbrk(<span class="number">200</span>);</span><br><span class="line">    sbrk(<span class="number">4096</span> * <span class="number">2</span> + <span class="number">200</span>);</span><br><span class="line">    sbrk(<span class="number">4096</span> * <span class="number">5</span> + <span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from shell\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot; -- arg: %s&quot;</span>, (<span class="type">int</span>)argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fork();</span><br><span class="line">    yield();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot;shell pid=%d&quot;</span>, getpid());</span><br><span class="line">        msleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221251345.png" alt="image-20240522125116933"></p>
<h3 id="2、printf"><a href="#2、printf" class="headerlink" title="2、printf()"></a>2、printf()</h3><p><code>printf()</code>最终会通过文件系统的接口，将格式化好的数据写入标准输出。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221944469.png" alt="image-20240522194431100" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 写文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    ptr[len] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 加入结束符</span></span><br><span class="line">    log_printf(<span class="string">&quot;%s&quot;</span>, ptr);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十五、使用控制台与键盘进行输入输出"><a href="#十五、使用控制台与键盘进行输入输出" class="headerlink" title="十五、使用控制台与键盘进行输入输出"></a>十五、使用控制台与键盘进行输入输出</h1><h2 id="15-1-控制台简介"><a href="#15-1-控制台简介" class="headerlink" title="15.1 控制台简介"></a>15.1 控制台简介</h2><p>操作系统启动后可以分为图形模式和文本模式。但图形界面并不是一个操作系统必须的组件。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230918110.png" alt="image-20240523091843752" style="zoom:50%;" />

<p><strong>每个</strong>显示的字符由<strong>两个</strong>配置字节数据控制：</p>
<ul>
<li>一个字节用于显示的字符；</li>
<li>一个字节用于配置显示属性。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230920616.png" alt="image-20240523092019270" style="zoom: 50%;" />

<p>计算机上电启动后，显示器默认设置成<code>80列x25行</code>的文本显示模式。一屏的显示需要<code>80*25*2=4000</code>字节的显存，因此<code>32KB</code>可以装下<code>8</code>屏幕的显示内容。</p>
<ul>
<li><p>可以同时在几个虚拟屏幕上显示，相当于打开多个命令行窗口并显示相应的内容；<strong>（本项目主要实现）</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230925271.png" alt="image-20240523092543957" style="zoom:50%;" />
</li>
<li><p>也可以将<code>32KB</code>显存分成<code>8</code>块，每块分别用于显示虚拟的控制台界面。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230926563.png" alt="image-20240523092610198" style="zoom:50%;" /></li>
</ul>
<h2 id="15-2-在控制台上显示字符串"><a href="#15-2-在控制台上显示字符串" class="headerlink" title="15.2 在控制台上显示字符串"></a>15.2 在控制台上显示字符串</h2><h3 id="1、控制台结构体定义"><a href="#1、控制台结构体定义" class="headerlink" title="1、控制台结构体定义"></a>1、控制台结构体定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符颜色</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">color_t</span> &#123;</span></span><br><span class="line">    COLOR_Black			= <span class="number">0</span>,</span><br><span class="line">    COLOR_Blue			= <span class="number">1</span>,</span><br><span class="line">    COLOR_Green			= <span class="number">2</span>,</span><br><span class="line">    COLOR_Cyan			= <span class="number">3</span>,</span><br><span class="line">    COLOR_Red			= <span class="number">4</span>,</span><br><span class="line">    COLOR_Magenta		= <span class="number">5</span>,</span><br><span class="line">    COLOR_Brown			= <span class="number">6</span>,</span><br><span class="line">    COLOR_Gray			= <span class="number">7</span>,</span><br><span class="line">    COLOR_Dark_Gray 	= <span class="number">8</span>,</span><br><span class="line">    COLOR_Light_Blue	= <span class="number">9</span>,</span><br><span class="line">    COLOR_Light_Green	= <span class="number">10</span>,</span><br><span class="line">    COLOR_Light_Cyan	= <span class="number">11</span>,</span><br><span class="line">    COLOR_Light_Red		= <span class="number">12</span>,</span><br><span class="line">    COLOR_Light_Magenta	= <span class="number">13</span>,</span><br><span class="line">    COLOR_Yellow		= <span class="number">14</span>,</span><br><span class="line">    COLOR_White			= <span class="number">15</span></span><br><span class="line">&#125;<span class="type">color_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述显存字符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">disp_char_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">char</span> foreground : <span class="number">4</span>;</span><br><span class="line">        <span class="type">char</span> background : <span class="number">3</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint16_t</span> v;  <span class="comment">// 16位，一个字节表示字符；另一个字节表示属性</span></span><br><span class="line">&#125;<span class="type">disp_char_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">console_t</span> &#123;</span></span><br><span class="line">    <span class="type">disp_char_t</span> *disp_base;             <span class="comment">// 控制台基地址</span></span><br><span class="line">    <span class="type">int</span> disp_rows, disp_cols;           <span class="comment">// 总的行列数</span></span><br><span class="line">    <span class="type">int</span> cursor_row, cursor_col;         <span class="comment">// 当前光标所在的行列数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">color_t</span> foreground, background;     <span class="comment">// 字符颜色</span></span><br><span class="line">&#125;<span class="type">console_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、显示字符串"><a href="#2、显示字符串" class="headerlink" title="2、显示字符串"></a>2、显示字符串</h3><p>目前的所有写操作都定向到了<code>fs.c</code>部分，在<code>sys_write()</code>中采用<code>log_printf()</code>来输出，对其进行修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 写文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    console_write(<span class="number">0</span>, ptr, len);</span><br><span class="line">    <span class="comment">// ptr[len] = &#x27;\0&#x27;;</span></span><br><span class="line">    <span class="comment">// log_printf(&quot;%s&quot;, ptr);</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此时调试，进入页异常：<code>Page doesn&#39;t present 0xB80A0</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231017216.png" alt="image-20240523101700997"></p>
<p>这是因为在创建内核页表时，没有加入显存部分的映射：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建内核页表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_kernel_table</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 地址映射表, 用于建立内核级的地址映射</span></span><br><span class="line">    <span class="comment">// 地址不变，但是添加了属性</span></span><br><span class="line">    <span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">        &#123;kernel_base,   s_text,         <span class="number">0</span>,              PTE_W&#125;,                           <span class="comment">// 内核栈区</span></span><br><span class="line">        &#123;s_text,        e_text,         s_text,         <span class="number">0</span>&#125;,                               <span class="comment">// 内核代码区</span></span><br><span class="line">        &#123;s_data,        (<span class="type">void</span> *)(MEM_EBDA_START - <span class="number">1</span>),   s_data,        PTE_W&#125;,            <span class="comment">// 内核数据区</span></span><br><span class="line">        <span class="comment">// ========================================== 新增 ========================================== //</span></span><br><span class="line">        &#123;(<span class="type">void</span> *)CONSOLE_DISP_ADDR, (<span class="type">void</span> *)CONSOLE_DISP_END, (<span class="type">void</span> *)CONSOLE_DISP_ADDR, PTE_W&#125;,  <span class="comment">// 控制台</span></span><br><span class="line">        <span class="comment">// ========================================== 新增 ========================================== //</span></span><br><span class="line">        &#123;(<span class="type">void</span> *)MEM_EXT_START, (<span class="type">void</span> *)MEM_EXT_END,     (<span class="type">void</span> *)MEM_EXT_START, PTE_W&#125;,   <span class="comment">// 扩展存储空间一一映射，方便直接操作</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串显示函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 控制台写内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param console 要写第几块控制台，所以传入int</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 写入的字符数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">console_write</span> <span class="params">(<span class="type">int</span> console, <span class="type">char</span> *data, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> *c = console_buf + console;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; size; len++) &#123;</span><br><span class="line">        <span class="comment">// 依次取出要写入的字符</span></span><br><span class="line">        <span class="type">char</span> ch = *data++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行写入操作，显示字符串</span></span><br><span class="line">        show_char(c, ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的输出结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231024410.png" alt="image-20240523102431257"></p>
<p>对上述函数进行改进：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 控制台写内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param console 要写第几块控制台，所以传入int</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 写入的字符数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">console_write</span> <span class="params">(<span class="type">int</span> console, <span class="type">char</span> *data, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> *c = console_buf + console;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; size; len++) &#123;</span><br><span class="line">        <span class="comment">// 依次取出要写入的字符</span></span><br><span class="line">        <span class="type">char</span> ch = *data++;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">                move_to_col0(console);      <span class="comment">// 行号不变，列号变0</span></span><br><span class="line">                move_next_line(console);    <span class="comment">// 行号下移，列号不变</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:         </span><br><span class="line">            <span class="comment">// 执行写入操作，显示字符串</span></span><br><span class="line">            show_char(c, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、清屏"><a href="#3、清屏" class="headerlink" title="3、清屏"></a>3、清屏</h3><p>只需要将当前屏幕对应的显存显示内容全部用空格符清空，或者用前景色和后景色相同的字符清空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 清屏操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_diaplay</span><span class="params">(<span class="type">console_t</span> *console)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算整个屏幕的字符量</span></span><br><span class="line">    <span class="type">int</span> size = console-&gt;disp_cols * console-&gt;disp_rows;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从基地址开始依次遍历</span></span><br><span class="line">    <span class="type">disp_char_t</span> *start = console-&gt;disp_base;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++, start++) &#123;</span><br><span class="line">        start-&gt;c = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        start-&gt;foreground = console-&gt;foreground;</span><br><span class="line">        start-&gt;background = console-&gt;background;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、滚屏"><a href="#4、滚屏" class="headerlink" title="4、滚屏"></a>4、滚屏</h3><p>注意以下两种情况需要滚屏：</p>
<ul>
<li>1）当光标前移时，若到达行末尾处需要移动到下一行，此时就需要判断当前是否需要滚屏；</li>
<li>2）在控制台写入内容时，若遇到换行操作，也需要判断当前是否需要滚屏。</li>
</ul>
<p>将除最底部的行外全部上移一行，再将最下边一行清空。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231031828.png" alt="image-20240523103159602" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 擦除从start到end的行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">erase_rows</span> <span class="params">(<span class="type">console_t</span> * console, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">disp_char_t</span> * disp_start = console-&gt;disp_base + console-&gt;disp_cols * start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">disp_char_t</span> * disp_end = console-&gt;disp_base + console-&gt;disp_cols * (end + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (disp_start &lt; disp_end) &#123;</span><br><span class="line">        disp_start-&gt;c = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        disp_start-&gt;foreground = console-&gt;foreground;</span><br><span class="line">        disp_start-&gt;background = console-&gt;background;</span><br><span class="line"></span><br><span class="line">        disp_start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 整体屏幕上移若干行</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param lines 上移的行数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">scroll_up</span><span class="params">(<span class="type">console_t</span> * console, <span class="type">int</span> lines)</span> &#123;</span><br><span class="line">    <span class="comment">// 整体上移</span></span><br><span class="line">    <span class="type">disp_char_t</span> * dest = console-&gt;disp_base;</span><br><span class="line">    <span class="type">disp_char_t</span> * src = console-&gt;disp_base + console-&gt;disp_cols * lines;</span><br><span class="line">    <span class="comment">// console-&gt;disp_rows - lines    上移后剩余的行数A</span></span><br><span class="line">    <span class="comment">// A *console-&gt;disp_cols         整体剩余的字符数（也就是上移后需要显示字符数）</span></span><br><span class="line">    <span class="type">uint32_t</span> size = (console-&gt;disp_rows - lines) * console-&gt;disp_cols * <span class="keyword">sizeof</span>(<span class="type">disp_char_t</span>);</span><br><span class="line">    kernel_memcpy(dest, src, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 擦除最后一行</span></span><br><span class="line">    erase_rows(console, console-&gt;disp_rows - lines, console-&gt;disp_rows - <span class="number">1</span>);</span><br><span class="line">    console-&gt;cursor_row -= lines;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-3-设置光标并重定向日志输出到显示器"><a href="#15-3-设置光标并重定向日志输出到显示器" class="headerlink" title="15.3 设置光标并重定向日志输出到显示器"></a>15.3 设置光标并重定向日志输出到显示器</h2><p>光标的位置分<strong>高8位和低8位</strong>两部分来表示，由于当前显示为<code>80*25</code>，共<code>2000</code>个字符，所以位置取值为<code>0~1999</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 读取当前光标的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_cursor_pos</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line"></span><br><span class="line"> 	outb(<span class="number">0x3D4</span>, <span class="number">0x0F</span>);		<span class="comment">// 写低地址</span></span><br><span class="line">	pos = inb(<span class="number">0x3D5</span>);</span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0x0E</span>);		<span class="comment">// 写高地址</span></span><br><span class="line">	pos |= inb(<span class="number">0x3D5</span>) &lt;&lt; <span class="number">8</span>;   </span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 更新鼠标的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_cursor_pos</span> <span class="params">(<span class="type">console_t</span> * console)</span> &#123;</span><br><span class="line">	<span class="type">uint16_t</span> pos = console-&gt;cursor_row *  console-&gt;display_cols + console-&gt;cursor_col;</span><br><span class="line"></span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0x0F</span>);		<span class="comment">// 写低地址</span></span><br><span class="line">	outb(<span class="number">0x3D5</span>, (<span class="type">uint8_t</span>) (pos &amp; <span class="number">0xFF</span>));</span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0x0E</span>);		<span class="comment">// 写高地址</span></span><br><span class="line">	outb(<span class="number">0x3D5</span>, (<span class="type">uint8_t</span>) ((pos &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-4-保存并恢复光标位置"><a href="#15-4-保存并恢复光标位置" class="headerlink" title="15.4 保存并恢复光标位置"></a>15.4 保存并恢复光标位置</h2><p><code>ANSI</code>转义序列(<code>ANSI escape sequences</code>)，可用于控制视频终端上的光标位置、颜色和其他选项。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\0337Hello, world!\0338123\n&quot;</span>);  <span class="comment">// 123lo,world!</span></span><br></pre></td></tr></table></figure>

<p><code>\0337</code>在<code>7</code>的位置保存光标位置，然后在<code>\0338</code>中<code>8</code>的位置用<code>123</code>进行替换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 普通状态下的字符的写入处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_normal</span> <span class="params">(<span class="type">console_t</span> * console, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> ASCII_ESC:</span><br><span class="line">            console-&gt;write_state = CONSOLE_WRITE_ESC;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 写入以ESC开头的序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_esc</span> <span class="params">(<span class="type">console_t</span> * console, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// https://blog.csdn.net/ScilogyHunter/article/details/106874395</span></span><br><span class="line">    <span class="comment">// ESC状态处理, 转义序列模式 ESC 0x20-0x27(0或多个) 0x30-0x7e</span></span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:		<span class="comment">// ESC 7 保存光标</span></span><br><span class="line">            save_cursor(console);</span><br><span class="line">            console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:		<span class="comment">// ESC 8 恢复光标</span></span><br><span class="line">            restore_cursor(console);</span><br><span class="line">            console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 控制台写内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param console 要写第几块控制台，所以传入int</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 写入的字符数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">console_write</span> <span class="params">(<span class="type">int</span> console, <span class="type">char</span> *data, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> *c = console_buf + console;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; size; len++) &#123;</span><br><span class="line">        <span class="comment">// 依次取出要写入的字符</span></span><br><span class="line">        <span class="type">char</span> ch = *data++;</span><br><span class="line">        <span class="keyword">switch</span> (c-&gt;write_state) &#123;</span><br><span class="line">            <span class="keyword">case</span> CONSOLE_WRITE_NORMAL: &#123;</span><br><span class="line">                write_normal(c, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CONSOLE_WRITE_ESC:</span><br><span class="line">                write_esc(c, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update_cursor_pos(c);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-5-更新显示字体的颜色"><a href="#15-5-更新显示字体的颜色" class="headerlink" title="15.5 更新显示字体的颜色"></a>15.5 更新显示字体的颜色</h2><blockquote>
<p>详见《LINUX内核完全剖析：基于0.12内核》附录部分。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231527961.png" alt="image-20240523152720901" style="zoom:50%;" />&#96;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理ESC [Pn;Pn 开头的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_esc_square</span> <span class="params">(<span class="type">console_t</span> * console, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 接收参数</span></span><br><span class="line">    <span class="keyword">if</span> ((c &gt;= <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (c &lt;= <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 解析当前参数</span></span><br><span class="line">        <span class="type">int</span> * param = &amp;console-&gt;esc_param[console-&gt;curr_param_index];</span><br><span class="line">        *param = *param * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c == <span class="string">&#x27;;&#x27;</span>) &amp;&amp; console-&gt;curr_param_index &lt; ESC_PARAM_MAX) &#123;</span><br><span class="line">        <span class="comment">// 参数结束，继续处理下一个参数</span></span><br><span class="line">        console-&gt;curr_param_index++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 结束上一字符的处理</span></span><br><span class="line">        console-&gt;curr_param_index++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已经接收到所有的字符，继续处理</span></span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: <span class="comment">// 设置字符属性</span></span><br><span class="line">            set_font_style(console);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:	<span class="comment">// 光标左移n个位置 ESC [Pn D</span></span><br><span class="line">            move_left(console, console-&gt;esc_param[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            move_right(console, console-&gt;esc_param[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">            move_cursor(console);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>:</span><br><span class="line">            erase_in_display(console);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-6-键盘初始化"><a href="#15-6-键盘初始化" class="headerlink" title="15.6 键盘初始化"></a>15.6 键盘初始化</h2><p>计算机中使用键盘控制器(<code>8042</code>)控制鼠标和键盘。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231600337.png" alt="image-20240523160008317" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231601872.png" alt="image-20240523160123502" style="zoom: 80%;" />

<p><strong>只需要对键盘的中断进行重写设置，而不需要自己去重新初始化键盘。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kbd_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    irq_install(IRQ1_KEYBOARD, (<span class="type">irq_handler_t</span>)exception_handler_kbd);</span><br><span class="line">    irq_enable(IRQ1_KEYBOARD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_kbd</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在<code>init/start.S</code>中进行增加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 硬件中断</span><br><span class="line">exception_handler kbd, 0x21, 0</span><br></pre></td></tr></table></figure>

<h2 id="15-7-借助按键映射表进行键值转换"><a href="#15-7-借助按键映射表进行键值转换" class="headerlink" title="15.7 借助按键映射表进行键值转换"></a>15.7 借助按键映射表进行键值转换</h2><p>当按键按下时和弹出时，都会产生一串扫描码，<strong>其数值并不与键盘上的字符ASCII相同</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231618145.png" alt="image-20240523161852835"></p>
<h1 id="十六、设备管理与文件系统"><a href="#十六、设备管理与文件系统" class="headerlink" title="十六、设备管理与文件系统"></a>十六、设备管理与文件系统</h1><h2 id="16-1-设备管理框架"><a href="#16-1-设备管理框架" class="headerlink" title="16.1 设备管理框架"></a>16.1 设备管理框架</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231934732.png" alt="image-20240523193407466" style="zoom:50%;" />

<p>在计算系统中，往往有很多种不同类型的设备，操作系统需要对这些设备进行统一管理。为每种类型设备都提供一套操作接口并不现实，且操作系统难以处理。因此，需要对设备进行“<strong>抽象</strong>”，得到所谓的“<strong>设备管理层</strong>”，负责对不同类型的设备进行抽象管理。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231936141.png" alt="image-20240523193634814" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231936997.png" alt="image-20240523193649716" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_NAME_SIZE       32</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DEV_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">dev_desc_t</span>;</span></span><br><span class="line"><span class="comment">// 特定设备结构（定义该类设备下特殊设备的特殊性质）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">device_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dev_desc_t</span> *<span class="title">desc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mode;       <span class="comment">// 特殊属性</span></span><br><span class="line">    <span class="type">int</span> minor;      <span class="comment">// 次设备号（主次设备号决定具体是哪个设备）</span></span><br><span class="line">    <span class="type">void</span> *data;     <span class="comment">// 设备相关参数</span></span><br><span class="line">    <span class="type">int</span> open_count; <span class="comment">// 设备打开次数</span></span><br><span class="line">&#125;<span class="type">device_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象设备结构（定义某类设备的一般特性）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">dev_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[DEV_NAME_SIZE];   <span class="comment">// 设备名称</span></span><br><span class="line">    <span class="type">int</span> major;                  <span class="comment">// 主设备号</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="type">device_t</span> *dev);</span><br><span class="line">    <span class="type">int</span> (*read)(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size);</span><br><span class="line">    <span class="type">int</span> (*write)(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size);</span><br><span class="line">    <span class="type">int</span> (*control)(<span class="type">device_t</span> *dev, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="type">device_t</span> *dev);</span><br><span class="line">&#125;<span class="type">dev_desc_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="16-2-增加tty设备"><a href="#16-2-增加tty设备" class="headerlink" title="16.2 增加tty设备"></a>16.2 增加tty设备</h2><h3 id="1、理论-1"><a href="#1、理论-1" class="headerlink" title="1、理论"></a>1、理论</h3><p>由于键盘和显示器密切相关，因此将二者抽象为一种硬件设备<code>tty</code>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231949301.png" alt="image-20240523194931067" style="zoom:50%;" />

<p>操作系统需要提供一套抽象机制，对所有设备进行抽象管理，以向上屏蔽复杂的硬件细节。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231950402.png" alt="image-20240523195038914"></p>
<p>上图中左边的<code>5</code>个函数最终会被注册到<code>_dev_desc_t</code>的<code>5</code>个函数指针中。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232005483.png" alt="image-20240523200517185"  />

<h3 id="2、增加tty设备的过程"><a href="#2、增加tty设备的过程" class="headerlink" title="2、增加tty设备的过程"></a>2、增加<code>tty</code>设备的过程</h3><ol>
<li><p>新增<code>tty.c</code>和<code>tty.h</code>；</p>
</li>
<li><p>在<code>tty.c</code>中实现<code>tty</code>相应的设备管理操作；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_open</span> <span class="params">(<span class="type">device_t</span> *dev)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_write</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_control</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1)</span>;</span><br></pre></td></tr></table></figure>

<p>并将上述操作注册到<code>dev_desc_t</code>中，定义一个<code>dev_tty_desc</code>；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">dev_desc_t</span> dev_tty_desc = &#123;</span><br><span class="line">    .name = <span class="string">&quot;tty&quot;</span>,</span><br><span class="line">    .major = DEV_TTY,</span><br><span class="line">    .open = tty_open,</span><br><span class="line">    .read = tty_read,</span><br><span class="line">    .write = tty_write,</span><br><span class="line">    .control = tty_control,</span><br><span class="line">    .close = tty_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>dev.c</code>中声明外部变量<code>dev_tty_desc</code>；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">dev_desc_t</span> dev_tty_desc;</span><br></pre></td></tr></table></figure>

<p>接下来根据<code>tty</code>相关操作实现上层接口函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dev_open</span> <span class="params">(<span class="type">int</span> major, <span class="type">int</span> minor, <span class="type">void</span> *data)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_read</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_write</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_control</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_close</span> <span class="params">(<span class="type">int</span> dev_id)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为<code>tty</code>设备添加结构描述</p>
<p>根据<code>32KB</code>显存可显示<code>8</code>块屏幕，将键盘与<code>8</code>块（虚拟）屏幕共享：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232032635.png" alt="image-20240523203230358" style="zoom: 67%;" />

<p>因此，为所有设备定义一个<code>tty</code>数组，分别对应一部分显存。但是，由于操作系统的运行速度很快，因此向设备发送指令&#x2F;数据也很快；但设备的速度很慢，所以硬件写指令&#x2F;数据很慢，所以需要在设备驱动中配置缓存，用于解决这种速度不匹配的问题。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232037597.png" alt="image-20240523203716361"></p>
</li>
</ol>
<p>当前在<code>log.c</code>中采用<code>console_write()</code>进行打印操作，但未来也可能有其他的设备需要进行打印操作，因此需要进行修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> log_dev_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化日志输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    mutex_init(&amp;mutex);</span><br><span class="line">    log_dev_id = dev_open(DEV_TTY, <span class="number">0</span>, (<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 日志打印</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// console_write(0, str_buf, kernel_strlen(str_buf));</span></span><br><span class="line">    dev_write(log_dev_id, <span class="number">0</span>, str_buf, kernel_strlen(str_buf));</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">// console_write(0, &amp;c, 1);</span></span><br><span class="line">    dev_write(log_dev_id, <span class="number">0</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样后续修改设备时，只需要在初始化时对<code>dev_open</code>进行改动即可。</p>
<h3 id="3、定义tty设备"><a href="#3、定义tty设备" class="headerlink" title="3、定义tty设备"></a>3、定义tty设备</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_IBUF_SIZE				512		<span class="comment">// tty输入缓存大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_OBUF_SIZE				512		<span class="comment">// tty输出缓存大小</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的 FIFO（First In, First Out）缓冲区，</span></span><br><span class="line"><span class="comment"> * 用于在字符设备（例如终端）中管理数据流。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tty_fifo_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *buf;      <span class="comment">// 指向存储缓冲区数据的指针</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">// 缓冲区的最大字节数</span></span><br><span class="line">    <span class="type">int</span> read;       <span class="comment">// 当前读位置的索引</span></span><br><span class="line">    <span class="type">int</span> write;      <span class="comment">// 当前写位置的索引</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 缓冲区中已有的数据量</span></span><br><span class="line">&#125;<span class="type">tty_fifo_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tty_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> obuf[TTY_OBUF_SIZE];  <span class="comment">// 输出缓冲区</span></span><br><span class="line">    <span class="type">tty_fifo_t</span> ofifo;          <span class="comment">// 输出FIFO队列</span></span><br><span class="line">    <span class="type">char</span> ibuf[TTY_IBUF_SIZE];  <span class="comment">// 输入缓冲区</span></span><br><span class="line">    <span class="type">tty_fifo_t</span> ififo;          <span class="comment">// 输入处理后的FIFO队列</span></span><br><span class="line">&#125;<span class="type">tty_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4、打开tty设备"><a href="#4、打开tty设备" class="headerlink" title="4、打开tty设备"></a>4、打开tty设备</h3><p>当<code>write</code>指向队列尾部时，会重新移到队头的位置，直到整个队列中没有空闲位置。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232051032.png" alt="image-20240523205100776" style="zoom:50%;" />

<p>由于整个系统中存在多个<code>tty</code>设备，因此对于键盘的初始化应该仅设置为一次。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kbd_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> inited = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!inited) &#123;</span><br><span class="line">        irq_install(IRQ1_KEYBOARD, (<span class="type">irq_handler_t</span>)exception_handler_kbd);</span><br><span class="line">        irq_enable(IRQ1_KEYBOARD);</span><br><span class="line"></span><br><span class="line">        inited = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于<code>console</code>的初始化，需要区别第<code>0</code>块还是其他块：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 控制台初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">console_init</span> <span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> *console = console_buf + idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里类型转换为disp_char_t *，那么CONSOLE_COL_MAX * CONSOLE_ROW_MAX就不必再乘以2</span></span><br><span class="line">    <span class="comment">// uint16_t *v = 0x1234;</span></span><br><span class="line">    <span class="comment">// v++;  // v = 0x1236，会按照uint16_t的类型来自增</span></span><br><span class="line">    console-&gt;disp_base = (<span class="type">disp_char_t</span> *)(CONSOLE_DISP_ADDR + idx *(CONSOLE_COL_MAX * CONSOLE_ROW_MAX));</span><br><span class="line"></span><br><span class="line">    console-&gt;disp_cols = CONSOLE_COL_MAX;</span><br><span class="line">    console-&gt;disp_rows = CONSOLE_ROW_MAX;</span><br><span class="line">    console-&gt;foreground = COLOR_White;</span><br><span class="line">    console-&gt;background = COLOR_Black;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console-&gt;cursor_col = 0;  不这样写，避免清空Boot和Loader的信息</span></span><br><span class="line">    <span class="comment">// console-&gt;cursor_row = 0;</span></span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> cursor_pos = read_cursor_pos();</span><br><span class="line">        console-&gt;cursor_row = cursor_pos / console-&gt;disp_cols;</span><br><span class="line">        console-&gt;cursor_col = cursor_pos % console-&gt;disp_cols;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        console-&gt;cursor_row = <span class="number">0</span>;</span><br><span class="line">        console-&gt;cursor_col = <span class="number">0</span>;    </span><br><span class="line">        clear_display(console);</span><br><span class="line">        update_cursor_pos(console);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console-&gt;old_cursor_row = console-&gt;cursor_row;</span><br><span class="line">    console-&gt;old_cursor_col = console-&gt;cursor_col;</span><br><span class="line"></span><br><span class="line">    console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、通过tty设备写显示数据"><a href="#5、通过tty设备写显示数据" class="headerlink" title="5、通过tty设备写显示数据"></a>5、通过tty设备写显示数据</h3><p>下图所示的缓存按字节存储数据，其中<code>write</code>指向下一待写入数据的位置，<code>read</code>指向下一数据读取的位置。</p>
<p>注项目中实际并未涉及到中断部分。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232118966.png" alt="image-20240523211809752" style="zoom:50%;" />

<p>最简单的方式，进程向硬件写入数据，然后等待硬件发送完成，再写入数据，如此反复，直到所有数据发送完毕。整个过程效率很低。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232120477.png" alt="image-20240523212056141"  />

<p>当加入缓存后，整个实现机制就改变了。一般情况下，进程负责向缓存写入数据，然后启动硬件发送机制，之后由硬件自动完成所有数据的发送，从而完成高效率地数据发送机制。</p>
<p>相比查询来说，速度要更快，进程不必等待。也就是说，在要发送的数据量小于缓存区的大小时，进程只需要将数据丢入缓存区即可退出，不需要再去考虑硬件的后续处理。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232122435.png" alt="image-20240523212223213"></p>
<p>当调用到<code>console_write()</code>时的调用堆栈如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232144307.png" alt="image-20240523214408045"></p>
<h2 id="16-3-文件系统初始化"><a href="#16-3-文件系统初始化" class="headerlink" title="16.3 文件系统初始化"></a>16.3 文件系统初始化</h2><p>操作系统使用文件系统对磁盘上的存储进行管理，给应用程序提供以文件组织的视图。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405240932371.png" alt="image-20240524093221478"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405240932986.png" alt="image-20240524093256519"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405240933690.png" alt="image-20240524093348655"></p>
<p>定义相关结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_NAME_SIZE      32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_TABLE_SIZE     2048</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">file_type_t</span> &#123;</span></span><br><span class="line">    FILE_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">    FILE_TTY,</span><br><span class="line">&#125;<span class="type">file_type_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">file_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> file_name[FILE_NAME_SIZE];     <span class="comment">// 文件名称</span></span><br><span class="line">    <span class="type">file_type_t</span> type;                   <span class="comment">// 文件类型</span></span><br><span class="line">    <span class="type">uint32_t</span> size;                      <span class="comment">// 文件大小</span></span><br><span class="line">    <span class="type">int</span> ref;                            <span class="comment">// 文件打开次数</span></span><br><span class="line">    <span class="type">int</span> dev_id;                         <span class="comment">// 文件对应设备号</span></span><br><span class="line">    <span class="type">int</span> pos;                            <span class="comment">// 文件当前读取位置</span></span><br><span class="line">    <span class="type">int</span> mode;                           <span class="comment">// 文件读取模式，只读/读写</span></span><br><span class="line">&#125;<span class="type">file_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">file_table_init</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">file_t</span> *<span class="title function_">file_alloc</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">file_free</span> <span class="params">(<span class="type">file_t</span> *file)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="16-4-为进程添加文件打开表"><a href="#16-4-为进程添加文件打开表" class="headerlink" title="16.4 为进程添加文件打开表"></a>16.4 为进程添加文件打开表</h3><p>在实际应用场合中，往往同时运行着很多应用进程，每个应用进程都可能会进行文件的读写操作。因此，存在下列问题：</p>
<ul>
<li>每个进程需要记录自己打开了哪些文件；</li>
<li>同一件文件可能同时被多个进程同时打开。</li>
</ul>
<p>因此，为了实现文件打开的共享，每个进程只保存一个指针表，其中每项指向自己所打开的文件描述符。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405241450969.png" alt="image-20240524145013782" style="zoom:50%;" />



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_alloc_fd</span> <span class="params">(<span class="type">file_t</span> *file)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">task_remove_fd</span> <span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">file_t</span> *<span class="title function_">task_file</span> <span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="16-4-打开tty设备并向其写入数据"><a href="#16-4-打开tty设备并向其写入数据" class="headerlink" title="16.4 打开tty设备并向其写入数据"></a>16.4 打开tty设备并向其写入数据</h2><p>文件系统是处于设备管理层之上的。如果对文件进行相应的操作，不能直接调用tty相关的代码，因此文件系统调用设备管理相关的代码，其再调用tty相关的代码。</p>
<p>也就是说，调用层级从高到低依次如下：<code>sys-&gt;dev-&gt;tty</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> flags, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_lseek</span><span class="params">(<span class="type">int</span> file, <span class="type">int</span> ptr, <span class="type">int</span> dir)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_close</span><span class="params">(<span class="type">int</span> file)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_isatty</span><span class="params">(<span class="type">int</span> file)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_fstat</span><span class="params">(<span class="type">int</span> file, <span class="keyword">struct</span> stat *st)</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dev.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_open</span> <span class="params">(<span class="type">int</span> major, <span class="type">int</span> minor, <span class="type">void</span> *data)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_read</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_write</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_control</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_close</span> <span class="params">(<span class="type">int</span> dev_id)</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tty.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_open</span> <span class="params">(<span class="type">device_t</span> *dev)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_write</span> <span class="params">(<span class="type">device_t</span> * dev, <span class="type">int</span> addr, <span class="type">char</span> * buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_control</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_close</span> <span class="params">(<span class="type">device_t</span> *dev)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="16-5-从tty读取键值字符串并显示"><a href="#16-5-从tty读取键值字符串并显示" class="headerlink" title="16.5 从tty读取键值字符串并显示"></a>16.5 从tty读取键值字符串并显示</h2><p>原理图如下：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242032828.png" alt="image-20240524203218224" style="zoom:50%;" />

<h3 id="1、向缓冲区写入，并通知硬件数据已到达"><a href="#1、向缓冲区写入，并通知硬件数据已到达" class="headerlink" title="1、向缓冲区写入，并通知硬件数据已到达"></a>1、向缓冲区写入，并通知硬件数据已到达</h3><p>当有按键按下时，调用<code>tty_in()</code>，此时：</p>
<p>1）首先通过信号量判断缓冲区是否有空闲区域；</p>
<p>2）若有，则会将按下的字符<code>ch</code>放入<code>ififo</code>缓冲区，并通过<code>sem_notify()</code>通知硬件有数据到达；</p>
<p>3）否则，进入等待状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kbd.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理单字符的标准键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_normal_key</span> <span class="params">(<span class="type">uint8_t</span> raw_code)</span> &#123;</span><br><span class="line">    <span class="type">char</span> key = get_key(raw_code);		<span class="comment">// 去掉最高位</span></span><br><span class="line">    <span class="type">int</span> is_make = is_make_code(raw_code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂时只处理按键按下的状态</span></span><br><span class="line">	<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (is_make) &#123;</span><br><span class="line">            ...</span><br><span class="line">            tty_in(<span class="number">0</span>, key);  <span class="comment">// important</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tty.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 输入tty字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_in</span> <span class="params">(<span class="type">int</span> idx, <span class="type">char</span> ch)</span> &#123;</span><br><span class="line">	<span class="type">tty_t</span> *tty = tty_devs + idx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将ch放入ififo缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> (sem_count(&amp;tty-&gt;isem) &gt;= TTY_IBUF_SIZE) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写入辅助队列，通知数据到达</span></span><br><span class="line">	tty_fifo_put(&amp;tty-&gt;ififo, ch);</span><br><span class="line">	sem_notify(&amp;tty-&gt;isem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、从缓冲区读取数据"><a href="#2、从缓冲区读取数据" class="headerlink" title="2、从缓冲区读取数据"></a>2、从缓冲区读取数据</h3><p>通过缓存实现进程和中断之间的配合。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *pbuf = buf;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;  <span class="comment">// 当前读取长度</span></span><br><span class="line">	<span class="comment">// 遍历buf读数据</span></span><br><span class="line">	<span class="keyword">while</span> (len &lt; size) &#123;</span><br><span class="line">		sem_wait(&amp;tty-&gt;isem);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> ch;</span><br><span class="line">		<span class="comment">// 从缓冲区取数据</span></span><br><span class="line">		tty_fifo_get(&amp;tty-&gt;ififo, &amp;ch);</span><br><span class="line">       ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-6-打开标准输出及错误输出文件"><a href="#16-6-打开标准输出及错误输出文件" class="headerlink" title="16.6 打开标准输出及错误输出文件"></a>16.6 打开标准输出及错误输出文件</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242035079.png" alt="image-20240524203555183"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242040884.png" alt="image-20240524204007541"></p>
<blockquote>
<p>在操作系统中，TTY设备（终端设备）通常与标准输入输出文件（即 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code>）关联，以便用户能够通过终端设备与系统交互。具体的关联机制可能因操作系统的不同而有所差异，但大致可以分为以下几个步骤和组件：</p>
<ol>
<li><strong>设备驱动与设备文件的关联</strong></li>
</ol>
<p>TTY设备的驱动程序定义了如何与实际的终端硬件进行交互。设备文件（如 <code>/dev/tty</code>）是设备驱动的一个接口，使用户空间程序可以通过文件系统与设备驱动交互。设备文件通常在操作系统启动时由设备驱动创建并注册到文件系统中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// TTY设备驱动的初始化</span></span><br><span class="line">&gt;<span class="type">void</span> <span class="title function_">tty_init</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 注册TTY设备</span></span><br><span class="line">   <span class="type">dev_desc_t</span> dev_tty_desc = &#123;</span><br><span class="line">       .name = <span class="string">&quot;tty&quot;</span>,</span><br><span class="line">       .major = DEV_TTY,</span><br><span class="line">       .open = tty_open,</span><br><span class="line">       .read = tty_read,</span><br><span class="line">       .write = tty_write,</span><br><span class="line">       .control = tty_control,</span><br><span class="line">       .close = tty_close,</span><br><span class="line">   &#125;;</span><br><span class="line">   register_device(&amp;dev_tty_desc);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>设备文件与文件描述符的关联</strong></li>
</ol>
<p>当用户空间的程序打开一个TTY设备文件时，内核会为该设备文件分配一个文件描述符，并将该文件描述符与TTY设备驱动的操作函数（如 <code>open</code>、<code>read</code>、<code>write</code> 等）关联起来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// 打开TTY设备文件</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">tty_open</span><span class="params">(<span class="type">device_t</span> *dev)</span> &#123;</span><br><span class="line">   <span class="comment">// 初始化TTY设备</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 读取TTY设备文件</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">tty_read</span><span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">   <span class="comment">// 从TTY设备读取数据</span></span><br><span class="line">   <span class="keyword">return</span> size;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 写入TTY设备文件</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">tty_write</span><span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">   <span class="comment">// 向TTY设备写入数据</span></span><br><span class="line">   <span class="keyword">return</span> size;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>标准输入输出与文件描述符的关联</strong></li>
</ol>
<p>在程序启动时，操作系统会为标准输入输出（<code>stdin</code>、<code>stdout</code>、<code>stderr</code>）分配文件描述符（通常是 <code>0</code>、<code>1</code> 和 <code>2</code>），并将这些文件描述符与TTY设备文件关联起来。这使得程序可以通过标准输入输出进行与终端设备的交互。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">void</span> <span class="title function_">setup_standard_io</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 打开标准输入</span></span><br><span class="line">   <span class="type">file_t</span> *stdin_file = sys_open(<span class="string">&quot;/dev/tty&quot;</span>, O_RDONLY);</span><br><span class="line">   curr_task-&gt;file_table[<span class="number">0</span>] = stdin_file;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 打开标准输出</span></span><br><span class="line">   <span class="type">file_t</span> *stdout_file = sys_open(<span class="string">&quot;/dev/tty&quot;</span>, O_WRONLY);</span><br><span class="line">   curr_task-&gt;file_table[<span class="number">1</span>] = stdout_file;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 打开标准错误输出</span></span><br><span class="line">   <span class="type">file_t</span> *stderr_file = sys_open(<span class="string">&quot;/dev/tty&quot;</span>, O_WRONLY);</span><br><span class="line">   curr_task-&gt;file_table[<span class="number">2</span>] = stderr_file;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>关联关系图</strong></li>
</ol>
<p>以下是TTY设备与标准输入输出文件关联关系的思维导图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;lua复制代码+----------------------+           +----------------------+</span><br><span class="line">&gt;| 用户空间程序        |           | 操作系统             |</span><br><span class="line">&gt;|                      |           |                      |</span><br><span class="line">&gt;| +------------------+ |           | +------------------+ |</span><br><span class="line">&gt;| | 标准输入（stdin）| |           | | TTY设备文件      | |</span><br><span class="line">&gt;| +------------------+ |           | +------------------+ |</span><br><span class="line">&gt;| | 标准输出（stdout）| |           | | 设备驱动        | |</span><br><span class="line">&gt;| +------------------+ |           | +------------------+ |</span><br><span class="line">&gt;| | 标准错误（stderr）| |           | | 设备文件系统    | |</span><br><span class="line">&gt;| +------------------+ |           | +------------------+ |</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">        | 关联                                  | 关联</span><br><span class="line">        v                                       v</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">&gt;| 文件描述符表        |           | 设备描述符表         |</span><br><span class="line">&gt;| (file_table)        |           | (device_table)       |</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">        | 关联                                  | 关联</span><br><span class="line">        v                                       v</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">&gt;| 设备文件            |           | TTY设备驱动         |</span><br><span class="line">&gt;| (/dev/tty)          |           | (tty_open, tty_read, |</span><br><span class="line">&gt;|                     |           |  tty_write, ...)     |</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">        | 关联</span><br><span class="line">        v</span><br><span class="line">&gt;+----------------------+</span><br><span class="line">&gt;| 硬件设备            |</span><br><span class="line">&gt;| (终端硬件)          |</span><br><span class="line">&gt;+----------------------+</span><br></pre></td></tr></table></figure>

<p>解释每一步的关联</p>
<ol>
<li><strong>用户空间程序</strong>通过标准输入（<code>stdin</code>）、标准输出（<code>stdout</code>）和标准错误（<code>stderr</code>）进行I&#x2F;O操作，这些操作实际上是对文件描述符表（<code>file_table</code>）中的文件描述符进行操作。</li>
<li><strong>文件描述符表</strong>中的文件描述符（如 <code>0</code>, <code>1</code>, <code>2</code>）对应TTY设备文件（如 <code>/dev/tty</code>）。</li>
<li><strong>设备文件</strong>（如 <code>/dev/tty</code>）通过设备描述符表（<code>device_table</code>）与TTY设备驱动（如 <code>tty_open</code>、<code>tty_read</code>、<code>tty_write</code> 等）关联。</li>
<li><strong>TTY设备驱动</strong>负责与实际的硬件设备（终端硬件）进行交互。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 复制文件描述符</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param file 当前文件的fd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_dup</span> <span class="params">(<span class="type">int</span> file)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((file &lt; <span class="number">0</span>) || (file &gt;= TASK_OFILE_NR)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;file(%d) is not valid.&quot;</span>, file);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">file_t</span> *p_file = task_file(file);</span><br><span class="line">    <span class="keyword">if</span> (!p_file) &#123;</span><br><span class="line">		log_printf(<span class="string">&quot;file not opened&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在打开文件表中分配新的表项，同样指向该任务</span></span><br><span class="line">    <span class="type">int</span> fd = task_alloc_fd(p_file);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        p_file-&gt;ref++;</span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log_printf(<span class="string">&quot;No task file avaliable&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-7-允许切换tty窗口"><a href="#16-7-允许切换tty窗口" class="headerlink" title="16.7 允许切换tty窗口"></a>16.7 允许切换tty窗口</h2><h3 id="1、通过快捷键方式切换"><a href="#1、通过快捷键方式切换" class="headerlink" title="1、通过快捷键方式切换"></a>1、通过快捷键方式切换</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kbd.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_fx_key</span> <span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = key - KEY_F1;</span><br><span class="line">    <span class="keyword">if</span> (kbd_state.lctrl_press || kbd_state.rctrl_press) &#123;</span><br><span class="line">        tty_select(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理单字符的标准键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_normal_key</span> <span class="params">(<span class="type">uint8_t</span> raw_code)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 功能键：写入键盘缓冲区，由应用自行决定如何处理</span></span><br><span class="line">    <span class="keyword">case</span> KEY_F1:</span><br><span class="line">    <span class="keyword">case</span> KEY_F2:</span><br><span class="line">    <span class="keyword">case</span> KEY_F3:</span><br><span class="line">    <span class="keyword">case</span> KEY_F4:</span><br><span class="line">    <span class="keyword">case</span> KEY_F5:</span><br><span class="line">    <span class="keyword">case</span> KEY_F6:</span><br><span class="line">    <span class="keyword">case</span> KEY_F7:</span><br><span class="line">    <span class="keyword">case</span> KEY_F8:</span><br><span class="line">        do_fx_key(key);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tty.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 选择tty</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_select</span> <span class="params">(<span class="type">int</span> tty)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (tty != curr_tty) &#123;</span><br><span class="line">		console_select(tty);</span><br><span class="line">		curr_tty = tty;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// console.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_select</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> * console = console_buf + idx;</span><br><span class="line">    <span class="keyword">if</span> (console-&gt;disp_base == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 可能没有初始化，先初始化一下</span></span><br><span class="line">        console_init(idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint16_t</span> pos = idx * console-&gt;display_cols * console-&gt;display_rows;</span><br><span class="line"></span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0xC</span>);		<span class="comment">// 写高地址</span></span><br><span class="line">	outb(<span class="number">0x3D5</span>, (<span class="type">uint8_t</span>) ((pos &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0xD</span>);		<span class="comment">// 写低地址</span></span><br><span class="line">	outb(<span class="number">0x3D5</span>, (<span class="type">uint8_t</span>) (pos &amp; <span class="number">0xFF</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新光标到当前屏幕</span></span><br><span class="line">    update_cursor_pos(console);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试代码</span></span><br><span class="line">    <span class="type">char</span> num = idx + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    show_char(console, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、在first-task中初始化8个窗口"><a href="#2、在first-task中初始化8个窗口" class="headerlink" title="2、在first_task中初始化8个窗口"></a>2、在first_task中初始化8个窗口</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/init/first_task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">    <span class="title function_">for</span> <span class="params">(<span class="type">int</span> i = <span class="number">0</span>; i &lt; TTY_NR; i++)</span> &#123;</span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            print_msg(<span class="string">&quot;create shell proc failed&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            <span class="type">char</span> tty_num[<span class="number">5</span>] = <span class="string">&quot;tty:?&quot;</span>;</span><br><span class="line">            tty_num[<span class="number">4</span>] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">char</span> * argv[] = &#123;tty_num, (<span class="type">char</span> *)<span class="number">0</span>&#125;;</span><br><span class="line">            execve(<span class="string">&quot;/shell.elf&quot;</span>, argv, (<span class="type">char</span> **)<span class="number">0</span>);</span><br><span class="line">            print_msg(<span class="string">&quot;create shell proc failed&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                msleep(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        msleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// open(&quot;tty:0&quot;, 0);            // fd = 0，标准输入</span></span><br><span class="line">    open(argv[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">    dup(<span class="number">0</span>);                   <span class="comment">// fd = 1，标准输出</span></span><br><span class="line">    dup(<span class="number">0</span>);                   <span class="comment">// fd = 2，标准错误输出</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from shell!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;os version: %s\n&quot;</span>, OS_VERSION);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        gets(cmd_buf);</span><br><span class="line">        <span class="built_in">puts</span>(cmd_buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf(&quot;shell pid= %d\n&quot;, getpid());</span></span><br><span class="line">        <span class="comment">// msleep(1000);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，还要在<code>conmsole.c</code>中进行相应的调整。</p>
<h1 id="十七、实现一个命令行解释器"><a href="#十七、实现一个命令行解释器" class="headerlink" title="十七、实现一个命令行解释器"></a>十七、实现一个命令行解释器</h1><h2 id="17-1-初始化命令行解释器"><a href="#17-1-初始化命令行解释器" class="headerlink" title="17.1 初始化命令行解释器"></a>17.1 初始化命令行解释器</h2><p><code>shell</code>俗称壳，即<strong>命令行解释器</strong>，它允许用户交互式的输入命令并解释执行，并且可以调用出相应的应用程序运行，从而让用户能够使用内核的 功能去操作计算机。<code>shell</code>也是一门程序语言，其定义了相应的语法规则，允许用户编写脚本。脚本编写后，由<code>shell</code>解释执行，不需要编译生成可执行程序。除非图形化的<code>shell</code>之外，还有图形化的<code>shell</code>，允许用户用鼠标等进行控制。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242158605.png" alt="image-20240524215849436"></p>
<p>本项目的目标是提供一个命令行的<code>shell</code>，支持执行内置的命令以及加载磁盘上的程序运行。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242232682.png" alt="image-20240524223243130"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command line interface</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLI_INPUT_SIZE     1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置命令结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">cli_cmd_t</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;       <span class="comment">// 命令名称</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *usage;      <span class="comment">// 命令功能</span></span><br><span class="line">    <span class="type">int</span> (*do_func)(<span class="type">int</span> argc, <span class="type">char</span> **argv);</span><br><span class="line">&#125;<span class="type">cli_cmd_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行接口结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">cli_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> curr_input[CLI_INPUT_SIZE];  <span class="comment">// 输入缓冲区</span></span><br><span class="line">    <span class="type">const</span> <span class="type">cli_cmd_t</span> *cmd_start;</span><br><span class="line">    <span class="type">const</span> <span class="type">cli_cmd_t</span> *cmd_end;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *promot;               <span class="comment">// 每次按下回车时显示的提示信息</span></span><br><span class="line">&#125;<span class="type">cli_t</span>;</span><br></pre></td></tr></table></figure>



<h3 id="1、show-promot"><a href="#1、show-promot" class="headerlink" title="1、show_promot()"></a>1、show_promot()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 显示命令行提示符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_promot</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, cli.promot);  <span class="comment">// 注意此处不能使用puts函数</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、为什么不能用 <code>puts</code>？</strong></p>
<ul>
<li><p><code>puts</code> 和 <code>printf</code> 的区别：</p>
<blockquote>
<ul>
<li><strong><code>puts</code>：</strong><ul>
<li><code>puts</code> 函数用于输出字符串，并在末尾自动添加一个换行符 <code>\n</code>。</li>
<li>它的原型是：<code>int puts(const char *str);</code></li>
<li>当你调用 <code>puts(&quot;Hello&quot;);</code> 时，实际输出的是 <code>&quot;Hello\n&quot;</code>。</li>
<li><code>puts</code> 自动刷新输出缓冲区。</li>
</ul>
</li>
<li><strong><code>printf</code>：</strong><ul>
<li><code>printf</code> 函数用于格式化输出，可以输出字符串、整数、浮点数等多种类型的数据。</li>
<li>它的原型是：<code>int printf(const char *format, ...);</code></li>
<li><code>printf(&quot;Hello&quot;);</code> 仅输出 <code>&quot;Hello&quot;</code>，不会自动添加换行符。</li>
<li><code>printf</code> 默认情况下不自动刷新输出缓冲区，除非遇到换行符或手动调用 <code>fflush</code>。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>在 <code>show_promot</code> 函数中不能使用 <code>puts</code> 的原因：</p>
<p><code>show_promot</code> 函数的目的是显示命令行提示符。通常情况下，命令行提示符不需要在末尾自动添加换行符，因为这样会导致用户输入内容出现在下一行，而不是提示符之后。例如：</p>
<ul>
<li><p>使用 <code>printf</code> 和 <code>fflush</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, cli.promot);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>

<p>输出是：<code>cli.promot</code> 直接跟随用户输入。</p>
</li>
<li><p>使用 <code>puts</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(cli.promot);</span><br></pre></td></tr></table></figure>

<p>输出是：<code>cli.promot\n</code>，用户输入会在下一行开始，这不是希望的行为。</p>
</li>
</ul>
</li>
</ul>
<p><strong>2、为什么要加上 <code>fflush</code>？</strong></p>
<ul>
<li><p>缓冲区和 <code>fflush</code>：</p>
<ul>
<li><p><strong>缓冲区</strong>：</p>
<ul>
<li>在标准 I&#x2F;O 库中，输出通常是缓冲的。这意味着输出操作先将数据存储在缓冲区中，只有在缓冲区满、遇到换行符、程序正常结束或手动刷新缓冲区时，数据才会实际输出到终端或文件。</li>
</ul>
</li>
<li><p>**<code>fflush</code>**：</p>
<ul>
<li><code>fflush</code> 函数用于强制刷新输出缓冲区，将缓冲区中的数据立即输出到目标设备。<ul>
<li>它的原型是：<code>int fflush(FILE *stream);</code></li>
<li>当你调用 <code>fflush(stdout);</code> 时，它会刷新标准输出缓冲区，确保所有缓冲的数据立即输出。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在 <code>show_promot</code> 函数中使用 <code>fflush</code> 的原因：</p>
<p>当我们使用 <code>printf</code> 输出命令行提示符时，缓冲区中的数据可能不会立即输出到终端。这意味着用户可能不会立即看到提示符，从而无法开始输入。为了确保提示符立即显示出来，我们需要手动刷新标准输出缓冲区。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, cli.promot);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>

<p>这样可以确保提示符在 <code>printf</code> 调用后立即显示，用户可以看到提示符并开始输入。</p>
</li>
</ul>
<p><strong>3、总结</strong></p>
<p>在 <code>show_promot</code> 函数中：</p>
<ol>
<li>不能使用 <code>puts</code> 是因为 <code>puts</code> 会在字符串末尾自动添加换行符，这不符合命令行提示符的预期行为。</li>
<li>使用 <code>printf</code> 后调用 <code>fflush(stdout)</code> 是为了确保提示符立即显示在终端上，避免缓冲区未被及时刷新导致的显示延迟。</li>
</ol>
<h3 id="2、在shell中按下回退键，回退键也会被写入"><a href="#2、在shell中按下回退键，回退键也会被写入" class="headerlink" title="2、在shell中按下回退键，回退键也会被写入"></a>2、在shell中按下回退键，回退键也会被写入</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405251645958.png" alt="image-20240525164517703"></p>
<p>解决方法：在<code>tty.c/tty_read()</code>中加入相应的处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *pbuf = buf;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;  <span class="comment">// 当前读取长度</span></span><br><span class="line">	<span class="comment">// 遍历buf读数据</span></span><br><span class="line">	<span class="keyword">while</span> (len &lt; size) &#123;</span><br><span class="line">		sem_wait(&amp;tty-&gt;isem);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> ch;</span><br><span class="line">		<span class="comment">// 从缓冲区取数据</span></span><br><span class="line">		tty_fifo_get(&amp;tty-&gt;ififo, &amp;ch);</span><br><span class="line">		<span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">        <span class="comment">// ================ 新增 ================ //</span></span><br><span class="line">		<span class="keyword">case</span> ASCII_DEL:</span><br><span class="line">			<span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			len--;</span><br><span class="line">			pbuf--;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// ================ 新增 ================ //</span></span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-2-进程主动退出exit"><a href="#17-2-进程主动退出exit" class="headerlink" title="17.2 进程主动退出exit()"></a>17.2 进程主动退出exit()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 退出进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数有两个关键步骤：</p>
<h3 id="1、步骤一"><a href="#1、步骤一" class="headerlink" title="1、步骤一"></a>1、<strong>步骤一</strong></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找当前进程（curr_task）所有的子进程，并将其转交给init进程（first_task）</span></span><br><span class="line"><span class="type">int</span> move_child = <span class="number">0</span>;  <span class="comment">// 标志是否需要唤醒first_task</span></span><br><span class="line">mutex_lock(&amp;task_table_mutex);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TASK_OFILE_NR; i++) &#123;</span><br><span class="line">    <span class="type">task_t</span> *task = task_table + i;</span><br><span class="line">    <span class="comment">// 判断当前进程（curr_task）是否有子进程</span></span><br><span class="line">    <span class="keyword">if</span> (task-&gt;parent == curr_task) &#123;</span><br><span class="line">        <span class="comment">// 若有，则转给first_task，由first_task进行处理</span></span><br><span class="line">        task-&gt;parent = &amp;task_manager.first_task;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果子进程中有僵尸进程，将其唤醒并回收资源</span></span><br><span class="line">        <span class="comment">// 但注意并不由当前进程（curr_task）自己回收，因为自己将要退出</span></span><br><span class="line">        <span class="keyword">if</span> (task-&gt;state == TASK_ZOMBIE) &#123;</span><br><span class="line">            move_child = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;task_table_mutex);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>寻找子进程并转交给 <code>first_task</code></strong>:<ul>
<li><strong>目的</strong>: 确保当前进程（<code>curr_task</code>）退出后，其所有的子进程不会成为孤儿进程。孤儿进程需要被重新指定为 <code>first_task</code>（通常是系统的守护进程）的子进程。</li>
<li>操作<ul>
<li>遍历 <code>task_table</code> 中的所有任务。</li>
<li>如果某任务的 <code>parent</code> 是 <code>curr_task</code>，则将该任务的 <code>parent</code> 改为 <code>first_task</code>。</li>
<li>如果该任务是僵尸进程（<code>TASK_ZOMBIE</code>），设置 <code>move_child</code> 标志为1，表示需要唤醒 <code>first_task</code> 来处理这些僵尸进程。</li>
</ul>
</li>
</ul>
</li>
<li><strong>加锁和解锁</strong>:<ul>
<li><strong>目的</strong>: 保证对 <code>task_table</code> 的操作是线程安全的。</li>
<li><strong>操作</strong>: 在遍历和修改 <code>task_table</code> 时，加锁 (<code>mutex_lock</code>) 和解锁 (<code>mutex_unlock</code>) 确保其他线程不能同时修改任务表。</li>
</ul>
</li>
</ol>
<h3 id="2、步骤二"><a href="#2、步骤二" class="headerlink" title="2、步骤二"></a>2、步骤二</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒first_task</span></span><br><span class="line"><span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"><span class="type">task_t</span> * parent = curr_task-&gt;parent;</span><br><span class="line"><span class="comment">// 若需要唤醒first_task，且当前进程（curr_task）的父进程不是first_task，唤醒first_task</span></span><br><span class="line"><span class="keyword">if</span> (move_child &amp;&amp; (parent != &amp;task_manager.first_task)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task_manager.first_task.state == TASK_WAITING) &#123;</span><br><span class="line">        task_set_ready(&amp;task_manager.first_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有父进程在wait，则唤醒父任务进行回收</span></span><br><span class="line"><span class="comment">// 如果父进程没有等待，则一直处理僵死状态？</span></span><br><span class="line"><span class="keyword">if</span> (parent-&gt;state == TASK_WAITING) &#123;</span><br><span class="line">    task_set_ready(curr_task-&gt;parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存返回值，当前进程（curr_task）进入僵尸状态</span></span><br><span class="line">curr_task-&gt;status = status;</span><br><span class="line">curr_task-&gt;state = TASK_ZOMBIE;</span><br><span class="line">task_set_block(curr_task);</span><br><span class="line">task_dispatch();</span><br><span class="line">irq_leave_protection(state);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>唤醒 <code>first_task</code></strong>:<ul>
<li><strong>目的</strong>: 如果有子进程转交给了 <code>first_task</code> 并且这些子进程中有僵尸进程，确保 <code>first_task</code> 可以及时处理这些僵尸进程。</li>
<li>操作<ul>
<li>如果 <code>move_child</code> 标志为<code>1</code>且 <code>curr_task</code> 的父进程不是 <code>first_task</code>，并且 <code>first_task</code> 当前处于等待状态（<code>TASK_WAITING</code>），则将 <code>first_task</code> 设置为就绪状态（<code>task_set_ready</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>唤醒父任务</strong>:<ul>
<li><strong>目的</strong>: 如果 <code>curr_task</code> 的父任务在等待（例如通过 <code>wait</code> 系统调用等待子进程结束），需要唤醒父任务来处理当前进程的退出。</li>
<li>操作<ul>
<li>如果 <code>curr_task</code> 的父任务处于等待状态（<code>TASK_WAITING</code>），将其设置为就绪状态（<code>task_set_ready</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>处理当前进程的退出</strong>:<ul>
<li><strong>目的</strong>: 将当前进程标记为僵尸状态，并阻塞当前任务以等待其父进程回收。</li>
<li>操作<ul>
<li>设置 <code>curr_task</code> 的返回状态（<code>status</code>）。</li>
<li>将 <code>curr_task</code> 的状态设置为僵尸状态（<code>TASK_ZOMBIE</code>）。</li>
<li>阻塞当前任务（<code>task_set_block</code>）。</li>
<li>调度其他任务运行（<code>task_dispatch</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>进入和离开中断保护</strong>:<ul>
<li><strong>目的</strong>: 确保在执行关键部分代码时不会被中断打断。</li>
<li><strong>操作</strong>: 进入中断保护（<code>irq_enter_protection</code>）和离开中断保护（<code>irq_leave_protection</code>）。</li>
</ul>
</li>
</ol>
<h3 id="3、两个步骤对比"><a href="#3、两个步骤对比" class="headerlink" title="3、两个步骤对比"></a>3、两个步骤对比</h3><ul>
<li><strong>第一步</strong>: 处理当前进程的子进程，将其重新分配给 <code>first_task</code>，并标记是否有僵尸进程需要处理。</li>
<li><strong>第二步</strong>: 唤醒 <code>first_task</code> 以处理重新分配的子进程和僵尸进程，同时处理当前进程的父任务和将当前进程设置为僵尸状态。</li>
</ul>
<h2 id="17-3-进程等待wait"><a href="#17-3-进程等待wait" class="headerlink" title="17.3 进程等待wait()"></a>17.3 进程等待wait()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 等待子进程退出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1、遍历任务表，寻找僵尸状态的子进程"><a href="#1、遍历任务表，寻找僵尸状态的子进程" class="headerlink" title="1、遍历任务表，寻找僵尸状态的子进程"></a>1、遍历任务表，寻找僵尸状态的子进程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mutex_lock(&amp;task_table_mutex);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TASK_NR; i++) &#123;</span><br><span class="line">    <span class="type">task_t</span> * task = task_table + i;</span><br><span class="line">    <span class="keyword">if</span> (task-&gt;parent != curr_task) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task-&gt;state == TASK_ZOMBIE) &#123;</span><br><span class="line">        <span class="type">int</span> pid = task-&gt;pid;</span><br><span class="line"></span><br><span class="line">        *status = task-&gt;status;</span><br><span class="line"></span><br><span class="line">        memory_destroy_uvm(task-&gt;tss.cr3);</span><br><span class="line">        memory_free_page(task-&gt;tss.esp0 - MEM_PAGE_SIZE);</span><br><span class="line">        kernel_memset(task, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">task_t</span>));</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;task_table_mutex);</span><br><span class="line">        <span class="keyword">return</span> pid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;task_table_mutex);</span><br></pre></td></tr></table></figure>

<ul>
<li>加锁和解锁<ul>
<li>通过 <code>mutex_lock</code> 和 <code>mutex_unlock</code> 来保护对 <code>task_table</code> 的访问，防止并发修改。</li>
</ul>
</li>
<li>检查子进程<ul>
<li>遍历 <code>task_table</code>，检查每个任务的父进程是否是当前进程（<code>curr_task</code>）。</li>
<li>如果找到一个子进程处于 <code>TASK_ZOMBIE</code> 状态，则准备回收其资源。</li>
</ul>
</li>
</ul>
<h3 id="2、回收僵尸进程"><a href="#2、回收僵尸进程" class="headerlink" title="2、回收僵尸进程"></a>2、回收僵尸进程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pid = task-&gt;pid;</span><br><span class="line">*status = task-&gt;status;</span><br><span class="line"></span><br><span class="line">memory_destroy_uvm(task-&gt;tss.cr3);</span><br><span class="line">memory_free_page(task-&gt;tss.esp0 - MEM_PAGE_SIZE);</span><br><span class="line">kernel_memset(task, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">task_t</span>));</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;task_table_mutex);</span><br><span class="line"><span class="keyword">return</span> pid;</span><br></pre></td></tr></table></figure>

<ul>
<li>保存退出状态<ul>
<li>将子进程的退出状态保存到 <code>status</code> 指向的变量中。</li>
</ul>
</li>
<li>回收资源<ul>
<li>销毁子进程的用户虚拟内存（<code>memory_destroy_uvm</code>）。</li>
<li>释放子进程的内核栈（<code>memory_free_page</code>）。</li>
<li>清空任务结构（<code>kernel_memset</code>）。</li>
</ul>
</li>
<li>解锁并返回<ul>
<li>解锁任务表互斥量，返回子进程的 <code>pid</code>。</li>
</ul>
</li>
</ul>
<h3 id="3、等待子进程退出"><a href="#3、等待子进程退出" class="headerlink" title="3、等待子进程退出"></a>3、等待子进程退出</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line">task_set_block(curr_task);</span><br><span class="line">curr_task-&gt;state = TASK_WAITING;</span><br><span class="line">task_dispatch();</span><br><span class="line">irq_leave_protection(state);</span><br></pre></td></tr></table></figure>

<ul>
<li>进入中断保护<ul>
<li>进入中断保护状态，防止在关键操作期间被中断打断。</li>
</ul>
</li>
<li>设置当前进程为等待状态<ul>
<li>将当前进程的状态设置为 <code>TASK_WAITING</code>，并阻塞当前进程（<code>task_set_block</code>）。</li>
</ul>
</li>
<li>任务调度<ul>
<li>通过 <code>task_dispatch</code> 切换到其他任务运行。</li>
</ul>
</li>
<li>离开中断保护<ul>
<li>离开中断保护状态。</li>
</ul>
</li>
</ul>
<h3 id="4、关键步骤总结"><a href="#4、关键步骤总结" class="headerlink" title="4、关键步骤总结"></a>4、关键步骤总结</h3><ol>
<li><strong>遍历任务表，寻找僵尸状态的子进程</strong>。</li>
<li><strong>回收僵尸进程</strong><ul>
<li>保存退出状态。</li>
<li>销毁子进程资源。</li>
<li>清空任务结构。</li>
</ul>
</li>
<li><strong>等待子进程退出</strong><ul>
<li>进入中断保护。</li>
<li>设置当前进程为等待状态。</li>
<li>任务调度。</li>
<li>离开中断保护。</li>
</ul>
</li>
</ol>
<h2 id="17-4-让子进程继承父进程已打开的文件"><a href="#17-4-让子进程继承父进程已打开的文件" class="headerlink" title="17.4 让子进程继承父进程已打开的文件"></a>17.4 让子进程继承父进程已打开的文件</h2><h3 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252002902.png" alt="image-20240525200208616"></p>
<p>出现<code>file not opened</code>是因为在<code>fork()</code>操作的<code>task_init()</code>中，对于<code>file_table</code>进行了清零操作，因此就使得子进程并未继承父进程已打开的文件，无法调用标准输入输出文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kernel_memset(&amp;task-&gt;file_table, <span class="number">0</span>, <span class="keyword">sizeof</span>(task-&gt;file_table));</span><br></pre></td></tr></table></figure>

<h3 id="2、解决方法"><a href="#2、解决方法" class="headerlink" title="2、解决方法"></a>2、解决方法</h3><p>在<code>sys_fork()</code>中加入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝打开的文件</span></span><br><span class="line">copy_opened_files(child_task);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从当前进程中拷贝已经打开的文件列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">copy_opened_files</span><span class="params">(<span class="type">task_t</span> * child_task)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> * parent = task_current();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TASK_OFILE_NR; i++) &#123;</span><br><span class="line">        <span class="type">file_t</span> * file = parent-&gt;file_table[i];</span><br><span class="line">        <span class="keyword">if</span> (file) &#123;</span><br><span class="line">            file_inc_ref(file);</span><br><span class="line">            child_task-&gt;file_table[i] = parent-&gt;file_table[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252000979.png" alt="image-20240525200053427"></p>
<h1 id="十八、使用文件系统管理硬件设备"><a href="#十八、使用文件系统管理硬件设备" class="headerlink" title="十八、使用文件系统管理硬件设备"></a>十八、使用文件系统管理硬件设备</h1><h2 id="18-1-描述一个文件系统"><a href="#18-1-描述一个文件系统" class="headerlink" title="18.1 描述一个文件系统"></a>18.1 描述一个文件系统</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252046871.png" alt="image-20240525204658527" style="zoom:50%;" />

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252013293.png" alt="image-20240525201314917"></p>
<p> <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252018279.png" alt="image-20240525201853857"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252020223.png" alt="image-20240525202007781"></p>
<h3 id="1、问题1：如何通过路径区分不同的设备"><a href="#1、问题1：如何通过路径区分不同的设备" class="headerlink" title="1、问题1：如何通过路径区分不同的设备"></a>1、问题1：如何通过路径区分不同的设备</h3><p>针对问题一：借鉴设备管理层的方法，针对不同类型的设备，添加相应的文件系统层接口实现。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405261156858.png" alt="image-20240526115647584" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252025262.png" alt="image-20240525202527701" style="zoom:50%;" />

<h2 id="18-2-挂载设备文件系统"><a href="#18-2-挂载设备文件系统" class="headerlink" title="18.2 挂载设备文件系统"></a>18.2 挂载设备文件系统</h2><h3 id="1、挂载原理"><a href="#1、挂载原理" class="headerlink" title="1、挂载原理"></a>1、挂载原理</h3><p>对于不同类型的文件系统，使用统一的链接进行挂载和管理。</p>
<p>在<code>mount_list</code>中存放了所支持的所有类型的文件系统，存放每个文件系统的名称（如<code>/dev</code>）和对应的操作（以函数指针的方式保存）。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252050216.png" alt="image-20240525205036777"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fs_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fs_op_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*mount)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">int</span> major, <span class="type">int</span> minor);   <span class="comment">// mount 挂载</span></span><br><span class="line">    <span class="type">void</span> (*unmount)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs);                      <span class="comment">// unmount 取消挂载</span></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">file_t</span> *file);  <span class="comment">// fs的相关信息会放入file中</span></span><br><span class="line">    <span class="type">int</span> (*read)(<span class="type">char</span> *buf, <span class="type">int</span> size, <span class="type">file_t</span> *file);</span><br><span class="line">    <span class="type">int</span> (*write)(<span class="type">char</span> *buf, <span class="type">int</span> size, <span class="type">file_t</span> *file);</span><br><span class="line">    <span class="type">int</span> (*seek)(<span class="type">file_t</span> *file, <span class="type">uint32_t</span> offset, <span class="type">int</span> dir);</span><br><span class="line">    <span class="type">int</span> (*stat)(<span class="type">file_t</span> *file, <span class="keyword">struct</span> stat *st);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="type">file_t</span> *file);</span><br><span class="line">&#125;<span class="type">fs_op_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载文件系统类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">fs_type_t</span> &#123;</span></span><br><span class="line">    FS_DEVFS,</span><br><span class="line">&#125;<span class="type">fs_type_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象文件结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fs_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> mount_point[FS_MOUNTP_SIZE];   <span class="comment">// 挂载文件系统名称</span></span><br><span class="line">    <span class="type">fs_type_t</span> type;     <span class="comment">// 挂载文件系统类型</span></span><br><span class="line">    <span class="type">fs_op_t</span> *op;        <span class="comment">// 指明该结构对应的文件系统的相关操作</span></span><br><span class="line">    <span class="type">void</span> *data;         <span class="comment">// 底层调用时使用，上层调用不使用</span></span><br><span class="line">    <span class="type">int</span> dev_id;         <span class="comment">// 设备id</span></span><br><span class="line">    <span class="type">list_node_t</span> node;   <span class="comment">// 链表节点</span></span><br><span class="line">    <span class="type">mutex_t</span> *mutex;</span><br><span class="line">&#125;<span class="type">fs_t</span>;</span><br></pre></td></tr></table></figure>



<p>在函数调用方面，从高层到底层依次如下：</p>
<p><code>devfs_func =&gt; dev_func =&gt; tty_func</code></p>
<h3 id="2、具体挂载流程"><a href="#2、具体挂载流程" class="headerlink" title="2、具体挂载流程"></a>2、具体挂载流程</h3><p>在文件系统的挂载过程中，<code>mount</code> 函数调用另一个同名的 <code>mount</code> 函数可能会引起混淆。事实上，这里有两个不同的 <code>mount</code> 函数，分别属于不同的上下文。一个是高层次的文件系统管理函数，另一个是具体文件系统的操作函数。</p>
<p><strong>（1）高层次的 <code>mount</code> 函数</strong></p>
<p>负责管理挂载的总体流程，包括检查是否已经挂载、分配资源、调用具体文件系统的挂载操作等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">fs_t</span> *<span class="title function_">mount</span> <span class="params">(<span class="type">fs_type_t</span> type, <span class="type">char</span> *mount_point, <span class="type">int</span> dev_major, <span class="type">int</span> dev_minor)</span> &#123;</span><br><span class="line">    <span class="type">fs_t</span> *fs = (<span class="type">fs_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    log_printf(<span class="string">&quot;mount file system, name: &amp;s, dev: %x&quot;</span>, mount_point, dev_major);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前文件系统是否已被挂载</span></span><br><span class="line">    <span class="type">list_node_t</span> *curr = list_first(&amp;mounted_list);</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="type">fs_t</span> *fs = list_node_parent(curr, <span class="type">fs_t</span>, node);</span><br><span class="line">        <span class="keyword">if</span> (kernel_strncmp(fs-&gt;mount_point, mount_point, FS_MOUNTP_SIZE) == <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;fs is already mounted&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> mount_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr = list_node_next(curr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到一个free_node对应的文件系统fs</span></span><br><span class="line">    <span class="type">list_node_t</span> *free_node = list_remove_first(&amp;free_list);</span><br><span class="line">    <span class="keyword">if</span> (!free_node) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;no free, mounted failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> mount_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    fs = list_node_parent(free_node, <span class="type">fs_t</span>, node);</span><br><span class="line">    <span class="type">fs_op_t</span> *op = get_fs_op(type, dev_major);</span><br><span class="line">    <span class="keyword">if</span> (!op) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;unsupported fs type: %d&quot;</span>, type);</span><br><span class="line">        <span class="keyword">goto</span> mount_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件系统fs通用初始化</span></span><br><span class="line">    kernel_memset(fs, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">fs_t</span>));</span><br><span class="line">    kernel_strncpy(fs-&gt;mount_point, mount_point, FS_MOUNTP_SIZE);</span><br><span class="line">    fs-&gt;op = op;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂载文件系统</span></span><br><span class="line">    <span class="keyword">if</span> (op-&gt;mount(fs, dev_major, dev_minor) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;mount fs %s failed&quot;</span>, mount_point);</span><br><span class="line">        <span class="keyword">goto</span> mount_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    list_insert_last(&amp;mounted_list, &amp;fs-&gt;node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">mount_failed:</span><br><span class="line">    <span class="keyword">if</span> (fs) &#123;</span><br><span class="line">        <span class="comment">// 回收fs</span></span><br><span class="line">        list_insert_first(&amp;free_list, &amp;fs-&gt;node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">fs_t</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）具体文件系统的 <code>mount</code> 函数</strong></p>
<p>这个 <code>mount</code> 函数是每个具体文件系统实现的一个函数，它被注册到文件系统操作结构（<code>fs_op_t</code>）中。在高层次的 <code>mount</code> 函数中调用 <code>op-&gt;mount</code> 时，实际上是调用具体文件系统的挂载实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fs_op_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*mount)(<span class="type">fs_t</span> *fs, <span class="type">int</span> dev_major, <span class="type">int</span> dev_minor);</span><br><span class="line">    <span class="comment">// 其他操作函数...</span></span><br><span class="line">&#125; <span class="type">fs_op_t</span>;</span><br></pre></td></tr></table></figure>

<p>具体文件系统的挂载函数负责实际的挂载工作，比如初始化文件系统的内部结构、检查设备、加载超级块等。例如，假设我们有一个简单的 <code>devfs</code> 文件系统，它的挂载函数可能是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">devfs_mount</span><span class="params">(<span class="type">fs_t</span> *fs, <span class="type">int</span> dev_major, <span class="type">int</span> dev_minor)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化devfs文件系统的内部结构</span></span><br><span class="line">    <span class="comment">// 检查设备</span></span><br><span class="line">    <span class="comment">// 加载超级块等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0表示成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）挂载流程详解</strong></p>
<ol>
<li><strong>调用高层次的 <code>mount</code> 函数</strong>：在文件系统初始化过程中，调用 <code>mount</code> 函数，例如 <code>fs_t *fs = mount(FS_DEVFS, &quot;/dev&quot;, 0, 0);</code>。</li>
<li><strong>检查是否已经挂载</strong>：高层次的 <code>mount</code> 函数检查指定的挂载点是否已经挂载文件系统。</li>
<li><strong>分配文件系统结构</strong>：从空闲列表中获取一个 <code>fs_t</code> 结构，并初始化。</li>
<li><strong>获取文件系统操作结构</strong>：通过文件系统类型和主设备号找到对应的文件系统操作结构 <code>fs_op_t</code>。</li>
<li><strong>调用具体文件系统的挂载函数</strong>：通过 <code>op-&gt;mount</code> 调用具体文件系统的挂载函数，例如 <code>devfs_mount</code>。</li>
<li><strong>将挂载的文件系统添加到挂载列表</strong>：如果挂载成功，将文件系统结构 <code>fs_t</code> 添加到挂载列表中。</li>
</ol>
<p><strong>（4）思维导图</strong></p>
<p>以下是这个流程的思维导图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yaml复制代码  高层次的 mount 函数</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  检查是否已经挂载</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  分配文件系统结构</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  获取文件系统操作结构 (fs_op_t)</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  调用具体文件系统的 mount 函数 (op-&gt;mount)</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  如果挂载成功，添加到挂载列表</span><br></pre></td></tr></table></figure>

<p>通过这个流程图，可以看到高层次的 <code>mount</code> 函数如何协调和管理整个挂载过程，而具体文件系统的 <code>mount</code> 函数则负责实际的挂载操作。</p>
<h2 id="18-3-打开dev-tty0设备"><a href="#18-3-打开dev-tty0设备" class="headerlink" title="18.3 打开dev&#x2F;tty0设备"></a>18.3 打开dev&#x2F;tty0设备</h2><p>设备文件系统并不对应于某个实际的硬件设备，而是抽象出来的用于管理所有硬件设备的一种文件系统。</p>
<p>修改<code>sys_open()</code>，使其变得比较通用，步骤如下：</p>
<ol>
<li><p>分配文件描述符链接</p>
</li>
<li><p>将分配的file结构和一个fd关联</p>
</li>
<li><p>根据传入的路径解析对应的fs结构</p>
<ul>
<li><p>检查名称是否以挂载点开头，如果没有，则认为name在根目录下</p>
</li>
<li><p>即只允许根目录下的遍历</p>
</li>
</ul>
</li>
<li><p>设置file内部相关字段</p>
</li>
<li><p>调用fs内部特定的open函数进行文件打开操作</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打开文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> flags, ...)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> err = fs-&gt;op-&gt;open(fs, name, file);  <span class="comment">// 就是这一句保证了其通用性</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>后续要增加其他设备时只需要修改此处：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// devfs.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">devfs_open</span> <span class="params">(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">file_t</span> *file)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历所有支持的设备类型列表，根据path中的路径，找到相应的设备类型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(devfs_type_list) / <span class="keyword">sizeof</span>(devfs_type_list[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="type">devfs_type_t</span> *type = devfs_type_list + i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找相同的名称，然后从中提取后续部分，转换成字符串</span></span><br><span class="line">        <span class="type">int</span> type_name_len = kernel_strlen(type-&gt;name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 举例：path:tty0  |  type-&gt;name:tty</span></span><br><span class="line">        <span class="comment">// 如果存在挂载点路径，则跳过该路径，取下级子目录</span></span><br><span class="line">        <span class="keyword">if</span> (kernel_strncmp(path, type-&gt;name, type_name_len) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 转换得到设备子序号</span></span><br><span class="line">            <span class="type">int</span> minor;</span><br><span class="line">            <span class="keyword">if</span> ((kernel_strlen(path) &gt; type_name_len) &amp;&amp; (path_to_num(path + type_name_len, &amp;minor) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                log_printf(<span class="string">&quot;Get device num failed. %s&quot;</span>, path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开设备</span></span><br><span class="line">            <span class="type">int</span> dev_id = dev_open(type-&gt;dev_type, minor, (<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (dev_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                log_printf(<span class="string">&quot;Open device failed:%s&quot;</span>, path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 纪录所在的设备号</span></span><br><span class="line">            file-&gt;dev_id = dev_id;  <span class="comment">// file的设备号指向打开的特定的设备</span></span><br><span class="line">            file-&gt;fs = fs;          <span class="comment">// file所属的文件系统</span></span><br><span class="line">            file-&gt;pos = <span class="number">0</span>;</span><br><span class="line">            file-&gt;size = <span class="number">0</span>;</span><br><span class="line">            file-&gt;type = type-&gt;file_type;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十九、磁盘与fat16文件系统"><a href="#十九、磁盘与fat16文件系统" class="headerlink" title="十九、磁盘与fat16文件系统"></a>十九、磁盘与fat16文件系统</h1><h2 id="19-1-磁盘基本特性简介"><a href="#19-1-磁盘基本特性简介" class="headerlink" title="19.1 磁盘基本特性简介"></a>19.1 磁盘基本特性简介</h2><h3 id="1、MBR是什么"><a href="#1、MBR是什么" class="headerlink" title="1、MBR是什么"></a>1、MBR是什么</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262044874.png" alt="image-20240526204427543"></p>
<h3 id="2、磁盘的分区和扇区有什么区别"><a href="#2、磁盘的分区和扇区有什么区别" class="headerlink" title="2、磁盘的分区和扇区有什么区别"></a>2、磁盘的分区和扇区有什么区别</h3><p>磁盘分区和扇区是磁盘存储管理中的两个基本概念，但它们指的是不同层次的内容。</p>
<p><strong>1、扇区（<code>Sector</code>）</strong></p>
<p><strong>扇区</strong>是硬盘存储的最小单位。硬盘上的数据被划分为一个一个的扇区进行存储和读取。传统上，一个扇区的大小是512字节，但在一些现代硬盘中，这个大小可以是4096字节（4K扇区）。</p>
<ul>
<li><strong>扇区大小</strong>：通常为512字节或4096字节。</li>
<li><strong>位置</strong>：硬盘表面被划分成多个轨道，每个轨道再分成多个扇区。</li>
<li><strong>标识</strong>：每个扇区有一个唯一的地址，传统上使用柱面（Cylinder）、磁头（Head）、扇区（Sector，简称CHS）来标识，现在更多地使用逻辑块地址（LBA，Logical Block Addressing）来标识。</li>
</ul>
<p><strong>2、分区（<code>Partition</code>）</strong></p>
<p><strong>分区</strong>是硬盘上的一段连续的存储区域，可以被操作系统或用户作为一个独立的逻辑磁盘来使用。分区将一个物理硬盘划分为一个或多个独立的部分，每个部分可以包含文件系统、操作系统或其他数据。</p>
<ul>
<li><strong>分区类型</strong><ul>
<li><strong>主分区（Primary Partition）</strong>：硬盘上最多可以有四个主分区。</li>
<li><strong>扩展分区（Extended Partition）</strong>：扩展分区本身不能直接用于存储数据，但可以包含多个逻辑分区。</li>
<li><strong>逻辑分区（Logical Partition）</strong>：位于扩展分区内，可以用于存储数据。</li>
</ul>
</li>
<li><strong>用途</strong>：每个分区可以格式化为不同的文件系统，例如FAT32、NTFS、EXT4等，可以用于安装操作系统或存储数据。</li>
<li><strong>管理</strong>：分区信息存储在硬盘的分区表中，传统的MBR（Master Boot Record）分区表最多支持四个主分区或三个主分区加一个扩展分区，GPT（GUID Partition Table）分区表支持更多的分区和更大的磁盘。</li>
</ul>
<p><strong>3、区别和联系</strong></p>
<p>（1）区别</p>
<ol>
<li><strong>定义和作用</strong>：<ul>
<li><strong>扇区</strong>是硬盘的最小存储单元，具体指硬盘上物理的存储位置。</li>
<li><strong>分区</strong>是硬盘上的逻辑区域，包含多个扇区，可以被操作系统识别和使用。</li>
</ul>
</li>
<li><strong>大小和范围</strong>：<ul>
<li><strong>扇区</strong>的大小通常是固定的（512字节或4096字节）。</li>
<li><strong>分区</strong>的大小可以变化不定，取决于用户或系统的配置，可以包含许多扇区。</li>
</ul>
</li>
<li><strong>管理和用途</strong>：<ul>
<li><strong>扇区</strong>由硬盘控制器直接管理，硬件层面上的数据存储单位。</li>
<li><strong>分区</strong>由操作系统和分区表管理，逻辑层面上的数据管理单位。</li>
</ul>
</li>
</ol>
<p>（2）联系</p>
<ol>
<li><strong>分区包含扇区</strong>：<ul>
<li>一个分区由多个连续的扇区组成，分区的大小和位置通过扇区来确定。</li>
</ul>
</li>
<li><strong>共同作用</strong>：<ul>
<li>分区划分后，操作系统在分区上创建文件系统，文件系统管理扇区上的数据存储。</li>
<li>分区表记录每个分区的起始扇区和大小，操作系统通过分区表来访问和管理硬盘上的数据。</li>
</ul>
</li>
</ol>
<p><strong>4、示例</strong></p>
<p>假设有一个大小为<code>1TB</code>的硬盘，使用传统的<code>512</code>字节扇区：</p>
<ul>
<li><strong>扇区</strong>：整个硬盘包含约<code>2^40 / 2^9 = 2^31</code>个扇区，即大约<code>21亿</code>个扇区。</li>
<li>分区<ul>
<li>第一个分区：从第<code>2048</code>扇区开始，大小为<code>200GB</code>（约400,000,000个扇区）。</li>
<li>第二个分区：从第<code>400,002,048</code>扇区开始，大小为<code>300GB</code>（约600,000,000个扇区）。</li>
<li>其他部分可以划分为更多分区或留作未分区空间。</li>
</ul>
</li>
</ul>
<p>通过分区工具（如fdisk、parted等）可以查看和管理硬盘上的分区信息，每个分区都会有一个对应的起始和结束扇区。文件系统（如NTFS、EXT4等）则进一步管理分区内的数据，决定如何在扇区中存储和检索文件。</p>
<blockquote>
<p>总结来说，<strong>扇区是物理存储单位</strong>，<strong>分区是逻辑存储单位</strong>，分区包含多个扇区，分区表管理和记录分区信息。</p>
</blockquote>
<h3 id="3、初始化磁盘结构和分区结构"><a href="#3、初始化磁盘结构和分区结构" class="headerlink" title="3、初始化磁盘结构和分区结构"></a>3、初始化磁盘结构和分区结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分区结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">disk_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">partinfo_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[PART_NAME_SIZE];  <span class="comment">// 分区名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">disk_t</span> *<span class="title">disk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        FS_INVALID = <span class="number">0x00</span>,</span><br><span class="line">        FS_FAT16_0 = <span class="number">0x6</span>,</span><br><span class="line">        FS_FAT16_1 = <span class="number">0xE</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start_sector;   <span class="comment">// 起始扇区号</span></span><br><span class="line">    <span class="type">int</span> total_sector;   <span class="comment">// 占用的扇区数量</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">partinfo_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述特定磁盘结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">disk_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[DISK_NAME_SIZE];</span><br><span class="line">    <span class="type">int</span> sector_size;    <span class="comment">// 扇区大小</span></span><br><span class="line">    <span class="type">int</span> sector_count;   <span class="comment">// 扇区个数</span></span><br><span class="line">    <span class="type">partinfo_t</span> partinfo[DISK_PRIMARY_PART_CNT];  <span class="comment">// 分区信息</span></span><br><span class="line">&#125;<span class="type">disk_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="19-2-识别系统中已有的磁盘"><a href="#19-2-识别系统中已有的磁盘" class="headerlink" title="19.2 识别系统中已有的磁盘"></a>19.2 识别系统中已有的磁盘</h2><h3 id="1、系统中有多少块硬盘"><a href="#1、系统中有多少块硬盘" class="headerlink" title="1、系统中有多少块硬盘"></a>1、系统中有多少块硬盘</h3><p>两条总线，<code>primary bus</code>和<code>secondary bus</code>，每条总线分别对应两个硬盘。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262111920.png" alt="image-20240526211100606"></p>
<h3 id="2、磁盘检测"><a href="#2、磁盘检测" class="headerlink" title="2、磁盘检测"></a>2、磁盘检测</h3><p>可以通过识别命令来检测硬盘的存在，以及硬盘相关的信息。原始参考资料见:<a href="https://wiki.osdev.org/ATA_PIO_Mode%E3%80%82%E4%BB%A5%E4%B8%8B%E4%BB%85%E5%88%97%E5%87%BA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9">https://wiki.osdev.org/ATA_PIO_Mode。以下仅列出项目中使用的部分内容</a><br>具体流程如下:</p>
<ul>
<li>写<code>Drive/HeadRegster</code>寄存器(地址<code>0x1F6</code>)：<code>0xA0</code>(master drive)或者<code>0xB0</code>(slave driver)</li>
<li>将扇区数量寄存器、<code>LBAlo,LBAmid,和LBAhi10</code>(地址<code>0x1F2-0x1F5</code>)全设置成0</li>
<li>向命令寄存器(地址<code>0x1F7</code>)发送<code>IDENTIFY</code>命令(<code>0xEC</code>)</li>
<li>读取状态寄存器(<code>0x1F7</code>)：如果值为0，则表明该硬盘不存在。如果其它值，等待DRQ置位或者ERR置位</li>
<li>如果<code>ERR</code>清令状态，从<code>0x1F0</code>读取<code>256</code>个<code>16</code>位的数据，其中保存了有关该磁盘相关的信息。</li>
</ul>
<p>返回的256个<code>16</code>位的数据内容：</p>
<ul>
<li>第<code>100-103</code>个数据，共<code>64</code>位：保存了该磁盘总的扇区数量</li>
</ul>
<h3 id="3、代码细节"><a href="#3、代码细节" class="headerlink" title="3、代码细节"></a>3、代码细节</h3><figure class="highlight v"><table><tr><td class="code"><pre><span class="line">#define DISK_NAME_SIZE              <span class="number">32</span></span><br><span class="line">#define PART_NAME_SIZE              <span class="number">32</span></span><br><span class="line">#define DISK_PRIMARY_PART_CNT       (<span class="number">4</span>+<span class="number">1</span>)</span><br><span class="line">#define DISK_CNT                    <span class="number">2</span></span><br><span class="line">#define DISK_PER_CHANNEL            <span class="number">2</span>           <span class="comment">// 每通道磁盘数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://wiki.osdev.org/ATA_PIO_Mode#IDENTIFY_command</span></span><br><span class="line"><span class="comment">// 只考虑支持主总线primary bus</span></span><br><span class="line">#define IOBASE_PRIMARY              <span class="number">0</span>x1F0</span><br><span class="line">#define	DISK_DATA(disk)				(disk-&gt;port_base + <span class="number">0</span>)		<span class="comment">// 数据寄存器</span></span><br><span class="line">#define	DISK_ERROR(disk)			(disk-&gt;port_base + <span class="number">1</span>)		<span class="comment">// 错误寄存器</span></span><br><span class="line">#define	DISK_SECTOR_COUNT(disk)		(disk-&gt;port_base + <span class="number">2</span>)		<span class="comment">// 扇区数量寄存器</span></span><br><span class="line">#define	DISK_LBA_LO(disk)			(disk-&gt;port_base + <span class="number">3</span>)		<span class="comment">// LBA寄存器</span></span><br><span class="line">#define	DISK_LBA_MID(disk)			(disk-&gt;port_base + <span class="number">4</span>)		<span class="comment">// LBA寄存器</span></span><br><span class="line">#define	DISK_LBA_HI(disk)			(disk-&gt;port_base + <span class="number">5</span>)		<span class="comment">// LBA寄存器</span></span><br><span class="line">#define	DISK_DRIVE(disk)			(disk-&gt;port_base + <span class="number">6</span>)		<span class="comment">// 磁盘或磁头</span></span><br><span class="line">#define	DISK_STATUS(disk)			(disk-&gt;port_base + <span class="number">7</span>)		<span class="comment">// 状态寄存器</span></span><br><span class="line">#define	DISK_CMD(disk)				(disk-&gt;port_base + <span class="number">7</span>)		<span class="comment">// 命令寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ATA命令</span></span><br><span class="line">#define	DISK_CMD_IDENTIFY			<span class="number">0</span>xEC	    <span class="comment">// IDENTIFY命令</span></span><br><span class="line">#define	DISK_CMD_READ				<span class="number">0</span>x24	    <span class="comment">// 读命令</span></span><br><span class="line">#define	DISK_CMD_WRITE				<span class="number">0</span>x34	    <span class="comment">// 写命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态寄存器</span></span><br><span class="line">#define DISK_STATUS_ERR             (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)    <span class="comment">// 发生错误</span></span><br><span class="line">#define DISK_STATUS_DRQ             (<span class="number">1</span> &lt;&lt; <span class="number">3</span>)    <span class="comment">// 准备好接受数据或者输出数据</span></span><br><span class="line">#define DISK_STATUS_DF              (<span class="number">1</span> &lt;&lt; <span class="number">5</span>)    <span class="comment">// 驱动错误</span></span><br><span class="line">#define DISK_STATUS_BUSY            (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)    <span class="comment">// 正忙</span></span><br><span class="line"></span><br><span class="line">#define	DISK_DRIVE_BASE		    <span class="number">0</span>xE0		<span class="comment">// 驱动器号基础值:0xA0 + LBA</span></span><br></pre></td></tr></table></figure>

<h3 id="4、结果"><a href="#4、结果" class="headerlink" title="4、结果"></a>4、结果</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262205497.png" alt="image-20240526220510242"></p>
<p>1、<code>sda</code>：放<code>boot/loader/kernel</code>；</p>
<p>2、<code>sdb</code>：放<code>FAT16</code>磁盘文件系统，放置相应的应用程序。</p>
<h2 id="19-3-解析磁盘分区表"><a href="#19-3-解析磁盘分区表" class="headerlink" title="19.3 解析磁盘分区表"></a>19.3 解析磁盘分区表</h2><p>分区表中共<code>4</code>个表项，每个表项包含了起始扇区、总扇区数、文件系统类型等关键性信息。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262212616.png" alt="image-20240526221201306"></p>
<blockquote>
<p><strong>MBR（主引导记录，Master Boot Record）</strong>是传统的磁盘分区表格式之一，用于在硬盘上划分不同的分区。它位于硬盘的第一个扇区（即0柱面、0磁头、1扇区），占用512字节。MBR不仅包含用于启动操作系统的引导代码，还包含分区表，用于描述磁盘上分区的布局。</p>
<p>（1）MBR由三个主要部分组成：</p>
<ol>
<li><strong>引导程序（Bootloader）</strong>：446字节</li>
</ol>
<p>  引导程序包含启动代码，用于引导操作系统。当计算机启动时，BIOS（或UEFI）会加载MBR中的引导代码，并执行它。这个引导代码通常用于查找活动分区，并加载该分区的引导扇区，以便进一步启动操作系统。</p>
<ol start="2">
<li><strong>分区表（Partition Table）</strong>：64字节</li>
</ol>
<p>  分区表包含四个分区项，每个分区项占用16字节。每个分区项描述一个分区的信息。</p>
<p>  一个分区项的格式如下：</p>
<ul>
<li><strong>引导标志（1字节）</strong>：表示该分区是否为活动分区（引导分区），值为0x80表示活动分区，0x00表示非活动分区。</li>
<li><strong>起始CHS地址（3字节）</strong>：分区起始地址，以CHS（柱面、磁头、扇区）格式表示。</li>
<li><strong>分区类型（1字节）</strong>：表示分区类型，例如0x83表示Linux分区，0x07表示NTFS分区。</li>
<li><strong>结束CHS地址（3字节）</strong>：分区结束地址，以CHS格式表示。</li>
<li><strong>起始LBA地址（4字节）</strong>：分区起始地址，以LBA（逻辑块地址）格式表示。</li>
<li><strong>分区大小（4字节）</strong>：分区的大小，以扇区为单位。</li>
</ul>
<ol start="3">
<li><strong>签名（Signature）</strong>：2字节</li>
</ol>
<p>  MBR的最后两个字节是签名，固定为0x55AA，用于标识这是一个有效的MBR。如果这两个字节不匹配，BIOS会认为硬盘上没有有效的MBR，不会继续引导。</p>
<p>（2）示例</p>
<p>假设我们有一个硬盘，其MBR如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">&gt;0000: 33 C0 8E D0 BC 00 7C 8B F4 50 07 50 1F FB FC BE 00 7C ...</span></span><br><span class="line">&gt;...</span><br><span class="line"><span class="section">&gt;01BE: 00 01 01 00 07 FE FF FF 3F 00 00 00 BF 9E 0D 00</span></span><br><span class="line"><span class="section">&gt;01CE: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="section">&gt;01DE: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="section">&gt;01EE: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="section">&gt;01FE: 55 AA</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li><strong>引导程序</strong>：从偏移量<code>0x0000</code>到<code>0x01BD</code>，共<code>446</code>字节。</li>
<li><strong>分区表</strong></li>
<li>第一个分区项从<code>0x01BE</code>到<code>0x01CD</code>。<ul>
<li><strong>引导标志</strong>：0x00，表示非活动分区。</li>
<li><strong>起始CHS地址</strong>：0x010100，表示柱面1，磁头1，扇区1。</li>
<li><strong>分区类型</strong>：0x07，表示NTFS分区。</li>
<li><strong>结束CHS地址</strong>：0xFEFFFF，表示柱面1023，磁头254，扇区63。</li>
<li><strong>起始LBA地址</strong>：0x0000003F，表示LBA地址63。</li>
<li><strong>分区大小</strong>：0x0DBF9EBF，表示分区大小为22934559扇区（约11GB）。</li>
</ul>
</li>
<li>其他三个分区项从<code>0x01CE</code>到<code>0x01ED</code>，当前示例中这些分区项未使用，全为0。</li>
<li><strong>签名</strong>：最后两个字节<code>0x55AA</code>。</li>
</ul>
<p>（3）分区操作</p>
<p>操作系统和磁盘工具通过读写MBR中的分区表来管理硬盘分区。例如，创建、删除、调整分区大小等操作都涉及到修改MBR中的分区表信息。</p>
<p>（4）MBR的局限性</p>
<p>由于MBR使用32位地址来表示分区大小，因此单个分区的最大容量为2^32个扇区（每扇区512字节），即2TB。此外，MBR分区表最多只能有四个主分区或三个主分区和一个扩展分区（扩展分区内可以包含多个逻辑分区）。这些局限性促使了GPT（GUID Partition Table）等更现代的分区表格式的出现，支持更大的磁盘和更多的分区。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 检测分区表信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">detect_part_info</span><span class="params">(<span class="type">disk_t</span> *disk)</span> &#123;</span><br><span class="line">    <span class="type">mbr_t</span> mbr;</span><br><span class="line"></span><br><span class="line">    ata_send_cmd(disk, <span class="number">0</span>, <span class="number">1</span>, DISK_CMD_READ);</span><br><span class="line">    <span class="type">int</span> err = ata_wait_data(disk);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;read mbr failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ata_read_data(disk, &amp;mbr, <span class="keyword">sizeof</span>(mbr));</span><br><span class="line">    <span class="type">part_item_t</span> *item = mbr.part_item;  <span class="comment">// 指向分区表起始位置</span></span><br><span class="line">    <span class="type">partinfo_t</span> *part_info = disk-&gt;partinfo + <span class="number">1</span>;  <span class="comment">// 第0个表项已被使用，所以从第1个表项开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MBR_PRIMARY_PART_NR; i++, item++, part_info++) &#123;</span><br><span class="line">        part_info-&gt;type = item-&gt;system_id;</span><br><span class="line">        <span class="keyword">if</span> (part_info-&gt;type == FS_INVALID) &#123;</span><br><span class="line">            part_info-&gt;total_sector = <span class="number">0</span>;</span><br><span class="line">            part_info-&gt;start_sector = <span class="number">0</span>;</span><br><span class="line">            part_info-&gt;disk = (<span class="type">disk_t</span> *)<span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            kernel_sprintf(part_info-&gt;name, <span class="string">&quot;%s%d&quot;</span>, disk-&gt;name, i+<span class="number">1</span>);</span><br><span class="line">            part_info-&gt;total_sector = item-&gt;total_sectors;</span><br><span class="line">            part_info-&gt;start_sector = item-&gt;relative_sectors;</span><br><span class="line">            part_info-&gt;disk = disk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262245138.png" alt="image-20240526224546950"></p>
<h2 id="19-4-增加磁盘设备管理"><a href="#19-4-增加磁盘设备管理" class="headerlink" title="19.4 增加磁盘设备管理"></a>19.4 增加磁盘设备管理</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270914097.png" alt="image-20240527091359469"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270914740.png" alt="image-20240527091426820"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dev.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DEV_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">    DEV_TTY,</span><br><span class="line">    DEV_DISK,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dev.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">dev_desc_t</span> dev_tty_desc;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">dev_desc_t</span> dev_disk_desc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象设备表（静态注册）</span></span><br><span class="line"><span class="type">static</span> <span class="type">dev_desc_t</span> *dev_desc_tbl[] = &#123;</span><br><span class="line">    &amp;dev_tty_desc,</span><br><span class="line">    &amp;dev_disk_desc,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// disk.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">dev_desc_t</span> dev_disk_desc = &#123;</span><br><span class="line">    .name = <span class="string">&quot;disk&quot;</span>,</span><br><span class="line">    .major = DEV_DISK,</span><br><span class="line">    .open = disk_open,</span><br><span class="line">    .read = disk_read,</span><br><span class="line">    .write = disk_write,</span><br><span class="line">    .control = disk_control,</span><br><span class="line">    .close = disk_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>disk_open()</code></p>
<ol>
<li><p>根据次设备号取磁盘号和分区号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> disk_idx = (*dev*-&gt;minor &gt;&gt; <span class="number">4</span>) - <span class="number">0xa</span>;  *<span class="comment">// 取高4位*</span></span><br><span class="line"><span class="type">int</span> part_idx = *dev*-&gt;minor &amp; <span class="number">0xF</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据磁盘编号取对应磁盘</p>
</li>
<li><p>根据分区号取对应分区</p>
</li>
<li><p>将分区信息保存到data中</p>
</li>
<li><p>打开相应中断</p>
</li>
</ol>
<h2 id="19-5-实现磁盘的读取和写入"><a href="#19-5-实现磁盘的读取和写入" class="headerlink" title="19.5 实现磁盘的读取和写入"></a>19.5 实现磁盘的读取和写入</h2><p>由于每条总线上的<code>2</code>块磁盘<strong>共用相同的中断和IO端口</strong>，考虑到多进程可能同时对磁盘进行读写操作，因此最好是加上锁。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270936751.png" alt="image-20240527093651259"></p>
<p>在<code>identify_disk()</code>中调用了<code>ata_wait_data()</code>来等到数据到达磁盘：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err = ata_wait_data(disk);  <span class="comment">// 在此过程中一直占用CPU，效率较低</span></span><br></pre></td></tr></table></figure>

<p>这个等待过程是一个<code>do-while</code>循环，在此过程中一直占用CPU，效率较低。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">// 等待数据或者有错误</span></span><br><span class="line">       status = inb(DISK_STATUS(disk));</span><br><span class="line">       <span class="keyword">if</span> ((status &amp; (DISK_STATUS_BUSY | DISK_STATUS_DRQ | DISK_STATUS_ERR)) != DISK_STATUS_BUSY) &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;<span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>因此考虑结合<strong>信号量和中断</strong>来进行处理。</p>
<p>当进程向磁盘发送读写请求后，在磁盘准备数据的期间，进程暂时主动放弃CPU，并进入等待队列；当磁盘的数据准备好后，向对应的进程发送中断信号，告知进程。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270948328.png" alt="image-20240527094819093" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">disk_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> start_sector, <span class="type">char</span> *buf, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">partinfo_t</span> *part_info = (<span class="type">partinfo_t</span> *)dev-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (!part_info) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;get part info failed, device: %d&quot;</span>, dev-&gt;minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">disk_t</span> *disk = part_info-&gt;disk;</span><br><span class="line">    <span class="keyword">if</span> (disk == (<span class="type">disk_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;no disk, device: %d&quot;</span>, dev-&gt;minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    task_on_op = <span class="number">1</span>;</span><br><span class="line">    ata_send_cmd(disk, part_info-&gt;start_sector + start_sector, count, DISK_CMD_READ);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; count; cnt++, buf+=disk-&gt;sector_size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task_current()) &#123;</span><br><span class="line">            sem_wait(disk-&gt;op_sem);  <span class="comment">// 避开系统初始化时在此处卡死</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> err = ata_wait_data(disk);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;disk(%s) read error: start sector: %d, count: %d&quot;</span>,</span><br><span class="line">                disk-&gt;name, start_sector, count</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ata_read_data(disk, buf, disk-&gt;sector_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;mutex);  </span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">disk_write</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> start_sector, <span class="type">char</span> *buf, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">partinfo_t</span> *part_info = (<span class="type">partinfo_t</span> *)dev-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (!part_info) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;get part info failed, device: %d&quot;</span>, dev-&gt;minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">disk_t</span> *disk = part_info-&gt;disk;</span><br><span class="line">    <span class="keyword">if</span> (disk == (<span class="type">disk_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;no disk, device: %d&quot;</span>, dev-&gt;minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    task_on_op = <span class="number">1</span>;</span><br><span class="line">    ata_send_cmd(disk, part_info-&gt;start_sector + start_sector, count, DISK_CMD_WRITE);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; count; cnt++, buf+=disk-&gt;sector_size) &#123;</span><br><span class="line">        ata_write_data(disk, buf, disk-&gt;sector_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (task_current()) &#123;</span><br><span class="line">            sem_wait(disk-&gt;op_sem);  <span class="comment">// 避开系统初始化时在此处卡死</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> err = ata_wait_data(disk);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;disk(%s) read error: start sector: %d, count: %d&quot;</span>,</span><br><span class="line">                disk-&gt;name, start_sector, count</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;mutex);  </span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-6-FAT16文件系统"><a href="#19-6-FAT16文件系统" class="headerlink" title="19.6 FAT16文件系统"></a>19.6 FAT16文件系统</h2><h3 id="1、FAT16"><a href="#1、FAT16" class="headerlink" title="1、FAT16"></a>1、FAT16</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271025353.png" alt="image-20240527102544023"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271027930.png" alt="image-20240527102751513"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271028998.png" alt="image-20240527102858618"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271034500.png" alt="image-20240527103442028"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271036205.png" alt="image-20240527103603679"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271038250.png" alt="image-20240527103821885"></p>
<h3 id="2、FAT表项配置"><a href="#2、FAT表项配置" class="headerlink" title="2、FAT表项配置"></a>2、FAT表项配置</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271051879.png" alt="image-20240527105122660"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// 解析DBR参数，解析出有用的参数</span></span><br><span class="line">    <span class="type">fat_t</span> *fat = &amp;fs-&gt;fat_data;</span><br><span class="line">    fat-&gt;fat_buffer = (<span class="type">uint8_t</span> *)dbr;</span><br><span class="line">    fat-&gt;bytes_per_sec = dbr-&gt;BPB_BytsPerSec;</span><br><span class="line">    fat-&gt;tbl_start = dbr-&gt;BPB_RsvdSecCnt;</span><br><span class="line">    fat-&gt;tbl_sectors = dbr-&gt;BPB_FATSz16;</span><br><span class="line">    fat-&gt;tbl_cnt = dbr-&gt;BPB_NumFATs;</span><br><span class="line">    fat-&gt;root_ent_cnt = dbr-&gt;BPB_RootEntCnt;</span><br><span class="line">    fat-&gt;sec_per_cluster = dbr-&gt;BPB_SecPerClus;</span><br><span class="line">    fat-&gt;cluster_byte_size = fat-&gt;sec_per_cluster * dbr-&gt;BPB_BytsPerSec;</span><br><span class="line">	fat-&gt;root_start = fat-&gt;tbl_start + fat-&gt;tbl_sectors * fat-&gt;tbl_cnt;</span><br><span class="line">    fat-&gt;data_start = fat-&gt;root_start + fat-&gt;root_ent_cnt * <span class="number">32</span> / SECTOR_SIZE;</span><br><span class="line">    fat-&gt;curr_sector = <span class="number">-1</span>;</span><br><span class="line">    fat-&gt;fs = fs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 简单检查是否是FAT16文件系统</span></span><br><span class="line">	<span class="keyword">if</span> (fat-&gt;tbl_cnt != <span class="number">2</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;fat table num error, major: %x, minor: %x&quot;</span>, major, minor);</span><br><span class="line">		<span class="keyword">goto</span> mount_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kernel_memcmp(dbr-&gt;BS_FileSysType, <span class="string">&quot;FAT16&quot;</span>, <span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;not a fat16 file system, major: %x, minor: %x&quot;</span>, major, minor);</span><br><span class="line">        <span class="keyword">goto</span> mount_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录相关的打开信息</span></span><br><span class="line">    fs-&gt;type = FS_FAT16;</span><br><span class="line">    fs-&gt;data = &amp;fs-&gt;fat_data;</span><br><span class="line">    fs-&gt;dev_id = dev_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">mount_failed:</span><br><span class="line">    <span class="keyword">if</span> (dbr) &#123;</span><br><span class="line">        memory_free_page((<span class="type">uint32_t</span>)dbr);</span><br><span class="line">    &#125;</span><br><span class="line">    dev_close(dev_id);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatfs_unmount</span> <span class="params">(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs)</span> &#123;</span><br><span class="line">    <span class="type">fat_t</span> * fat = (<span class="type">fat_t</span> *)fs-&gt;data;</span><br><span class="line"></span><br><span class="line">    dev_close(fs-&gt;dev_id);</span><br><span class="line">    memory_free_page((<span class="type">uint32_t</span>)fat-&gt;fat_buffer);  <span class="comment">// 释放FAT表项缓冲</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-7-遍历目录命令ls"><a href="#19-7-遍历目录命令ls" class="headerlink" title="19.7 遍历目录命令ls"></a>19.7 遍历目录命令ls</h2><p>目前的项目有一个问题：</p>
<p>在<code>first_task()</code>中有系统调用相关的工作，因此在<code>kernel.lds</code>中将系统调用相关的代码和数据放到了内核空间中，如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">PROVIDE(s_text = .);</span><br><span class="line">.text : &#123;</span><br><span class="line">	*(EXCLUDE_FILE(*first_task* *lib_syscall*) .text)</span><br><span class="line">&#125;</span><br><span class="line">.rodata : &#123;</span><br><span class="line">	*(EXCLUDE_FILE(*first_task* *lib_syscall*) .rodata)</span><br><span class="line">&#125;</span><br><span class="line">PROVIDE(e_text = .);</span><br><span class="line"></span><br><span class="line">. = ALIGN(4096);</span><br><span class="line">PROVIDE(s_data = .);</span><br><span class="line">.data : &#123;</span><br><span class="line">	*(EXCLUDE_FILE(*first_task* *lib_syscall*) .data)</span><br><span class="line">&#125;</span><br><span class="line">.bss : &#123;</span><br><span class="line">	*(EXCLUDE_FILE(*first_task* *lib_syscall*) .bss)</span><br><span class="line">&#125;</span><br><span class="line">e_data = .;</span><br></pre></td></tr></table></figure>

<p>然而我们在<code>lib_syscall.c</code>的下述函数中调用了<code>newlib</code>库的<code>malloc()/free()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DIR *<span class="title function_">opendir</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span> <span class="params">(DIR *dir)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span> <span class="params">(DIR *dir)</span>;</span><br></pre></td></tr></table></figure>

<p>但是在链接脚本中并没有把内核空间和<code>newlib</code>库链接起来，因此在编译时就找不到<code>malloc()/free()</code>。</p>
<p>有两种解决方法：</p>
<ol>
<li>将<code>newlib</code>库也加入到内核空间中；——不推荐，会使得内核体积膨胀</li>
<li>将<code>lib_syscall.c</code>复制一份到<code>kernel/init</code>中，同时在<code>CMakeLists.txt</code>中去掉<code>-lapp</code>。</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">// set(LIBS_FLAGS <span class="string">&quot;-L $&#123;CMAKE_BINARY_DIR&#125;/source/applib/ -lapp&quot;</span>)</span><br><span class="line">set(LIBS_FLAGS <span class="string">&quot;-L $&#123;CMAKE_BINARY_DIR&#125;/source/applib/&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>增加<code>ls</code>命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 显示目录</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_ls</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span> &#123;</span><br><span class="line">    DIR *p_dir = opendir(<span class="string">&quot;temp&quot;</span>);  <span class="comment">// 本项目暂只支持顶层目录访问</span></span><br><span class="line">    <span class="keyword">if</span> (p_dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open dir failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(p_dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c %s %d&quot;</span>,</span><br><span class="line">            entry-&gt;type = FILE_DIR ? <span class="string">&#x27;d&#x27;</span> : <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">            entry-&gt;name,</span><br><span class="line">            entry-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(p_dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">file_type_t</span> &#123;</span></span><br><span class="line">    FILE_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">    FILE_TTY,</span><br><span class="line">    FILE_DIR,</span><br><span class="line">    FILE_NORMAL,</span><br><span class="line">&#125;<span class="type">file_type_t</span>;</span><br></pre></td></tr></table></figure>

<p>由于对每个类型的文件的遍历方式不同，因此在<code>_fs_op_t</code>中增加相应的接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fs_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fs_op_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*mount)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">int</span> major, <span class="type">int</span> minor);   <span class="comment">// mount 挂载</span></span><br><span class="line">    <span class="type">void</span> (*unmount)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs);                      <span class="comment">// unmount 取消挂载</span></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">file_t</span> *file);  <span class="comment">// fs的相关信息会放入file中</span></span><br><span class="line">    <span class="type">int</span> (*read)(<span class="type">char</span> *buf, <span class="type">int</span> size, <span class="type">file_t</span> *file);</span><br><span class="line">    <span class="type">int</span> (*write)(<span class="type">char</span> *buf, <span class="type">int</span> size, <span class="type">file_t</span> *file);</span><br><span class="line">    <span class="type">int</span> (*seek)(<span class="type">file_t</span> *file, <span class="type">uint32_t</span> offset, <span class="type">int</span> dir);</span><br><span class="line">    <span class="type">int</span> (*stat)(<span class="type">file_t</span> *file, <span class="keyword">struct</span> stat *st);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="type">file_t</span> *file);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*opendir) (<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">const</span> <span class="type">char</span> *name, DIR *dir);</span><br><span class="line">    <span class="type">int</span> (*readdir) (<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, DIR *dir, <span class="keyword">struct</span> dirent *dirent);</span><br><span class="line">    <span class="type">int</span> (*closedir) (<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, DIR *dir);</span><br><span class="line">&#125;<span class="type">fs_op_t</span>;</span><br></pre></td></tr></table></figure>

<p>具体的调用实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name, DIR * dir)</span> &#123;</span><br><span class="line">	fs_protect(root_fs);</span><br><span class="line">	<span class="type">int</span> err = root_fs-&gt;op-&gt;opendir(root_fs, name, dir);</span><br><span class="line">	fs_unprotect(root_fs);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_readdir</span><span class="params">(DIR* dir, <span class="keyword">struct</span> dirent * dirent)</span> &#123;</span><br><span class="line">	fs_protect(root_fs);</span><br><span class="line">	<span class="type">int</span> err = root_fs-&gt;op-&gt;readdir(root_fs, dir, dirent);</span><br><span class="line">	fs_unprotect(root_fs);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_closedir</span><span class="params">(DIR *dir)</span> &#123;</span><br><span class="line">	fs_protect(root_fs);</span><br><span class="line">	<span class="type">int</span> err = root_fs-&gt;op-&gt;closedir(root_fs, dir);</span><br><span class="line">	fs_unprotect(root_fs);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DIR *<span class="title function_">opendir</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    DIR *dir = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DIR));</span><br><span class="line">    <span class="keyword">if</span> (dir == (DIR *)<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (DIR *)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_opendir;</span><br><span class="line">    args.arg0 = (<span class="type">int</span>)path;</span><br><span class="line">    args.arg1 = (<span class="type">int</span>)dir;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err = sys_call(&amp;args);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(dir);</span><br><span class="line">        <span class="keyword">return</span> (DIR *)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span> <span class="params">(DIR *dir)</span> &#123;</span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_readdir;</span><br><span class="line">    args.arg0 = (<span class="type">int</span>)dir;</span><br><span class="line">    args.arg1 = (<span class="type">int</span>)&amp;dir-&gt;dirent;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err = sys_call(&amp;args);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// free(dir);  // 这里不应该free(dir)，否则就会和closedir()中的free重复</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">struct</span> dirent *)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;dir-&gt;dirent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span> <span class="params">(DIR *dir)</span> &#123;</span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_closedir;</span><br><span class="line">    args.arg0 = (<span class="type">int</span>)dir;</span><br><span class="line">    sys_call(&amp;args);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尤其注意<code>readdir()</code>这一行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// free(dir);  // 这里不应该free(dir)，否则就会和closedir()中的free重复</span></span><br></pre></td></tr></table></figure>



<p>FAT16文件系统将顶层目录下的所有文件和目录的信息放在<strong>根目录区</strong>中，因此可以通过读取根目录区中的内容获取根目录下所有的文件和目录信息。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271559579.png" alt="image-20240527155922869"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271559465.png" alt="image-20240527155900689"></p>
<h2 id="19-8-文件查看命令less"><a href="#19-8-文件查看命令less" class="headerlink" title="19.8 文件查看命令less"></a>19.8 文件查看命令less</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271834662.png" alt="image-20240527183438134"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 列出文本文件内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_less</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271856539.png" alt="image-20240527185627202"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271857558.png" alt="image-20240527185722278"></p>
]]></content>
      <categories>
        <category>Project</category>
        <category>diyx86os</category>
      </categories>
  </entry>
  <entry>
    <title>常用STL容器</title>
    <url>/2024/06/11/%E9%9D%A2%E8%AF%95/%E9%9B%B6%E6%95%A3/%E5%B8%B8%E7%94%A8STL%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>[toc]</p>
<span id="more"></span>

<h1 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h1><h2 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a>std::vector</h2><h3 id="1、基本用法"><a href="#1、基本用法" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; c;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; d;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">e</span><span class="params">(n, <span class="number">10</span>)</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; f&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> m = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">g</span><span class="params">(arr, arr+m)</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">h</span><span class="params">(g.begin(), g.end())</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素访问</span></span><br><span class="line">    <span class="comment">// 1. 下标访问</span></span><br><span class="line">    a.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> tmp = a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 迭代器访问</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;::iterator s;</span><br><span class="line">    s = a.begin();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;a.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *(s+i));  <span class="comment">// 常用STL容器中，仅vector和string支持a.begin()+i这种写法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (s=a.begin(); s!=a.end(); s++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常用内置函数</span></span><br><span class="line">    a.reverse(<span class="number">100</span>);		<span class="comment">// 预分配100个元素的内存，注意reserve操作只是预分配内存，并不会改变Vector的大小</span></span><br><span class="line">    a.push_back(<span class="number">4</span>);		<span class="comment">// 时间复杂度为O(1)</span></span><br><span class="line">    a.emplace_back(<span class="number">1</span>);  <span class="comment">// 时间复杂度为O(1)</span></span><br><span class="line">    a.pop_back();		<span class="comment">// 时间复杂度为O(1)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> size = a.size();             <span class="comment">// 时间复杂度为O(1)</span></span><br><span class="line">    a.resize(<span class="number">3</span>);</span><br><span class="line">    a.resize(<span class="number">5</span>, <span class="number">10</span>);  <span class="comment">// 扩容，且新增元素初始化为10</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> first = a.front();</span><br><span class="line">    <span class="type">int</span> last = a.back();</span><br><span class="line"></span><br><span class="line">    a.insert(a.begin(), <span class="number">0</span>);   			<span class="comment">// 时间复杂度为O(N)</span></span><br><span class="line">    a.erase(a.begin());          		<span class="comment">// erase()有两种方法，时间复杂度都为O(N)</span></span><br><span class="line">    a.erase(a.begin(), a.end()<span class="number">-1</span>);  	<span class="comment">// erase(first,last)删除[first, last)内的所有元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> is_empty = a.empty();</span><br><span class="line">    a.clear();        <span class="comment">// 时间复杂度为O(N)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// algorithm常用函数</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">    sort(a.begin(),a.end());  				<span class="comment">// 对[a.begin(), a.end())进行从大到小排序</span></span><br><span class="line">    reverse(a.begin(),a.end());  			<span class="comment">// 对[a.begin(), a.end())进行倒置，但不排序</span></span><br><span class="line">    copy(a.begin(),a.end(),b.begin()+<span class="number">1</span>); 	<span class="comment">// 把[a.begin(), a.end())的元素复制到b中</span></span><br><span class="line">    find(a.begin(),a.end(),<span class="number">10</span>);  			<span class="comment">// 在[a.begin(), a.end())的元素中查找10。并返回其位置（迭代器）</span></span><br><span class="line">    count(a.begin(), a.end(),<span class="number">10</span>);    		<span class="comment">// 在[a.begin(), a.end())的元素中查找10的个数，并返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、内部实现"><a href="#2、内部实现" class="headerlink" title="2、内部实现"></a>2、内部实现</h3><p>vector 的底层是一个动态数组，包含三个迭代器：start、finish 和 end_of_storage。</p>
<ul>
<li>start 和 finish 之间是已经被使用的空间范围；</li>
<li>end_of_storage 是整块连续空间（包括备用空间）的尾部。</li>
</ul>
<p>当<code>push_banck()</code>时发现空间容量不够，会自动申请另一片更大的空间（1.5或2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间【3、vector的扩容机制】。当释放或者删除（<code>vec.clear()</code>）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。因此，对vector的任何操作一旦引起了空间的重新配置，指向原 vector 的所有迭代器会都失效了。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111938752.png" alt="在这里插入图片描述"></p>
<p>vector 维护的是一个连续的线性空间，所以不论其元素类型为何，普通指针都可以作为 vector 的迭代器而满足所以必要条件，如 operator*，operator-&gt;，operator++，operator–，普通指针天生就具备。vector 支持随机存取，而普通指针正有这样的能力。所以底层直接将指针封装成了 iterator。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111939776.png" alt="在这里插入图片描述"></p>
<h3 id="3、vector-的扩容机制"><a href="#3、vector-的扩容机制" class="headerlink" title="3、vector 的扩容机制"></a>3、vector 的扩容机制</h3><h4 id="（1）扩容机制原理"><a href="#（1）扩容机制原理" class="headerlink" title="（1）扩容机制原理"></a>（1）扩容机制原理</h4><p>当向 vector 中插入元素时，如果元素有效个数 size 与空间容量 capacity 相等时，vector 内部会触发扩容机制：</p>
<ol>
<li>开辟新空间；</li>
<li>拷贝元素；</li>
<li>释放旧空间。</li>
</ol>
<h4 id="（2）如何避免动态扩容，导致效率降低"><a href="#（2）如何避免动态扩容，导致效率降低" class="headerlink" title="（2）如何避免动态扩容，导致效率降低"></a>（2）如何避免动态扩容，导致效率降低</h4><p>如果要避免扩容而导致程序效率过低问题，其实非常简单：<strong>如果在插入之前，可以预估vector存储元素的个数，提前将底层容量开辟好即可。</strong>如果插入之前进行 reserve，只要空间给足，则插入时不会扩容，如果没有 reserve，则会边插入边扩容，效率极其低下。</p>
<h4 id="（3）为什么选择1-5倍或者2倍方式扩容，而不是3倍、4倍"><a href="#（3）为什么选择1-5倍或者2倍方式扩容，而不是3倍、4倍" class="headerlink" title="（3）为什么选择1.5倍或者2倍方式扩容，而不是3倍、4倍"></a>（3）为什么选择1.5倍或者2倍方式扩容，而不是3倍、4倍</h4><p>扩容原理为：申请新空间，拷贝元素，释放旧空间。<strong>理想的分配方案是在第N次扩容时能复用之前N-1次释放的空间。</strong>如果按照2倍方式扩容，第i次扩容空间大小如下：<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111947980.png" alt="在这里插入图片描述"><br>可以看到，每次扩容时，前面释放的空间都不能使用。比如：第4次扩容时，前2次空间已经释放，第3次空间还没有释放(开辟新空间、拷贝元素、释放旧空间)，即前面释放的空间只有1 + 2 &#x3D; 3，假设第3次空间已经释放才只有1+2+4&#x3D;7，而第四次需要8个空间，因此无法使用之前已释放的空间，但是<strong>按照小于2倍方式扩容，多次扩容之后就可以复用之前释放的空间了</strong>。<strong>如果倍数超过2倍(包含2倍)方式扩容会存在以下问题</strong>：</p>
<ul>
<li>空间浪费可能会比较高，比如：扩容后申请了64个空间，但只存了33个元素，有接近一半的空间没有使用；</li>
<li>无法使用到前面已释放的内存。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111947476.png" alt="在这里插入图片描述"></p>
<ul>
<li>使用2倍（k&#x3D;2）扩容机制扩容时，每次扩容后的新内存大小必定大于前面的总和；</li>
<li>而使用1.5倍（k&#x3D;1.5）扩容时，在几次扩展以后，可以重用之前的内存空间了。</li>
</ul>
<p>因为 STL 标准并没有严格说明需要按何种方式进行扩容，因此不同的实现厂商都是按照自己的方式扩容的，即：<strong>Linux 下是按照2倍的方式扩容的，而 vs 下是按照1.5倍的方式扩容的</strong>。</p>
<h4 id="（4）Windows-和-Linux-的扩容底层原理"><a href="#（4）Windows-和-Linux-的扩容底层原理" class="headerlink" title="（4）Windows 和 Linux 的扩容底层原理"></a>（4）Windows 和 Linux 的扩容底层原理</h4><ol>
<li><p>Windows 扩容底层</p>
<p>Windows 中堆管理系统会对释放的堆块进行合并，因此 vs 下的 vector 扩容机制选择使用1.5倍的方式扩容，这样多次扩容之后就可以使用之前已经释放的空间。</p>
</li>
<li><p>Linux 的扩容底层</p>
</li>
</ol>
<img src="https://img-blog.csdnimg.cn/4f12d834bac147ee9bcba58e5521a961.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qOu5piO5biu5aSn5LqO6buR6JmO5biu,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:80%;" />

<ul>
<li>Linux 下主要使用 glibc 的 ptmalloc 来进行用户空间申请的<ul>
<li>如果 malloc 的空间小于<code>128KB</code>，其内部通过<code>brk()</code>来扩张；</li>
<li>如果大于<code>128KB</code>且<code>arena</code>中没有足够的空间时，通过<code>mmap()</code>将内存映射到进程地址空间。</li>
</ul>
</li>
<li>Linux 中引入<strong>伙伴系统</strong>（所谓的伙伴系统就是 STL 中通过链表来实现的内存池）为内核提供了一种用于分配连续页的高效的分配策略，实现对固定分区和动态分区方式的折中：固定分区存在内部碎片；动态分区存在外部碎片，而且动态分区回收时的合并以及分配时的切片是比较耗时的。<ul>
<li>伙伴系统是将整个内存区域构建成基本大小<code>basicSize</code>的1倍、2倍、4倍、8倍、16倍等，即要求内存空间分区链均对应2的整次幂倍大小的空间；</li>
<li>在分配和释放空间时，可以通过<code>log2(request/basicSize)</code>向上取整的哈希算法快速找到对应内存块。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111952632.png" alt="img"></p>
<h2 id="std-list"><a href="#std-list" class="headerlink" title="std::list"></a>std::list</h2><h3 id="1、基本用法-1"><a href="#1、基本用法-1" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// for std::accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; list1;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; list2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">list3</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>; <span class="comment">// 5个10</span></span><br><span class="line">    <span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">list4</span><span class="params">(list2.begin(), list2.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素访问</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;list2元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : list2) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    list1.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">    list1.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    list1.<span class="built_in">pop_back</span>();</span><br><span class="line">    list1.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入和删除特定位置的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = list2.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">2</span>); <span class="comment">// 移动迭代器到第三个位置</span></span><br><span class="line">    list2.<span class="built_in">insert</span>(it, <span class="number">10</span>); <span class="comment">// 在第三个位置插入10</span></span><br><span class="line">    it = list2.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">2</span>); <span class="comment">// 再次移动迭代器到第三个位置</span></span><br><span class="line">    list2.<span class="built_in">erase</span>(it); <span class="comment">// 删除第三个位置的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    list2.<span class="built_in">reverse</span>();	<span class="comment">// 反转列表</span></span><br><span class="line">    list2.<span class="built_in">sort</span>();		<span class="comment">// 排序列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// algorithm</span></span><br><span class="line">    it = std::<span class="built_in">find</span>(list2.<span class="built_in">begin</span>(), list2.<span class="built_in">end</span>(), <span class="number">4</span>);  <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(list2.<span class="built_in">begin</span>(), list2.<span class="built_in">end</span>(), <span class="number">0</span>);  <span class="comment">// 求和</span></span><br><span class="line">    std::for_each(list2.<span class="built_in">begin</span>(), list2.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;  <span class="comment">// 遍历</span></span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> count = std::<span class="built_in">count</span>(list2.<span class="built_in">begin</span>(), list2.<span class="built_in">end</span>(), <span class="number">10</span>);  <span class="comment">// 计算元素个数</span></span><br><span class="line">    list2.<span class="built_in">remove</span>(<span class="number">10</span>); <span class="comment">// 删除所有值为10的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、理论基础"><a href="#2、理论基础" class="headerlink" title="2、理论基础"></a>2、理论基础</h3><p>由于 list 拥有一片不连续的内存空间，且 STL list 是一个双向链表，因此其提供的迭代器是 Bidirectional Iterators。对于 list 来说，其插入操作和接合操作不会使得原迭代器失效。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node</span> &#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">	void_pointer prev;</span><br><span class="line">	void_pointer next;</span><br><span class="line">	T data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;  <span class="comment">// 缺省使用 alloc 作为空间配置器</span></span><br><span class="line"><span class="keyword">class</span> list &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* list_type;</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;  <span class="comment">// 专属空间配置器，每次配置一个节点大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    link_type node;</span><br><span class="line">    </span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="std-deque"><a href="#std-deque" class="headerlink" title="std::deque"></a>std::deque</h2><h3 id="1、基本用法-2"><a href="#1、基本用法-2" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// for std::accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化方式1：默认构造</span></span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; deque1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化方式2：用元素初始化</span></span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; deque2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化方式3：使用fill构造</span></span><br><span class="line">    <span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">deque3</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>; <span class="comment">// 5个10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化方式4：使用范围构造</span></span><br><span class="line">    <span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">deque4</span><span class="params">(deque2.begin(), deque2.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素访问</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deque2元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : deque2) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    deque1.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">    deque1.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    deque1.<span class="built_in">pop_back</span>();</span><br><span class="line">    deque1.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入和删除特定位置的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = deque2.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">2</span>); <span class="comment">// 移动迭代器到第三个位置</span></span><br><span class="line">    deque2.<span class="built_in">insert</span>(it, <span class="number">10</span>); <span class="comment">// 在第三个位置插入10</span></span><br><span class="line">    it = deque2.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">2</span>); <span class="comment">// 再次移动迭代器到第三个位置</span></span><br><span class="line">    deque2.<span class="built_in">erase</span>(it); <span class="comment">// 删除第三个位置的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转双端队列</span></span><br><span class="line">    std::<span class="built_in">reverse</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序双端队列</span></span><br><span class="line">    std::<span class="built_in">sort</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用算法函数</span></span><br><span class="line">    <span class="comment">// std::find</span></span><br><span class="line">    it = std::<span class="built_in">find</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != deque2.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;找到元素 4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到元素 4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::accumulate</span></span><br><span class="line">    <span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deque2元素的和：&quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::for_each</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deque2元素：&quot;</span>;</span><br><span class="line">    std::for_each(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::count</span></span><br><span class="line">    <span class="type">int</span> count = std::<span class="built_in">count</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>(), <span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deque2中包含10的个数：&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::remove</span></span><br><span class="line">    <span class="keyword">auto</span> new_end = std::<span class="built_in">remove</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>(), <span class="number">10</span>); <span class="comment">// 删除所有值为10的元素</span></span><br><span class="line">    deque2.<span class="built_in">erase</span>(new_end, deque2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最终的deque2元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : deque2) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、理论基础-1"><a href="#2、理论基础-1" class="headerlink" title="2、理论基础"></a>2、理论基础</h3><p>deque 是双向开口的连续线性空间。</p>
<blockquote>
<p>deque 和 vector 的差别：</p>
<ol>
<li>deque 允许于常数时间内对起头端进行元素的插入或移除操作；</li>
<li>deque 没有所谓容量（capacity）的概念，因为它是<strong>动态地以分段连续空间组合而成</strong>，随时可以增加一段新的空间并链接起来。</li>
<li>deque 虽然也提供 RamdomAccessIterator，但其迭代器并非普通指针，复杂度较高，因此除非必要，应尽量使用 vector 而非 deque。对 deque 进行的排序操作，可以先将 deque 完成复制到一个 vector 中，排序后再复制回 deque。</li>
</ol>
</blockquote>
<p>deque 的迭代器包含两个任务：</p>
<ol>
<li><p>指出分段连续空间（即缓冲区）在哪里；</p>
</li>
<li><p>判断自己是否已经处于所在缓冲区的边缘，若是，则一旦前进或后退时就必须跳跃至下一个或上一个缓冲区:</p>
<ol>
<li><p><strong>最后一个缓冲区只剩下一个备用空间</strong>，则调用 <code>push_back_aux()</code>新建并跳跃至下一个缓冲区；</p>
</li>
<li><p><strong>第一个缓冲区没有备用空间</strong>，则调用 <code>push_front_aux()</code>新建并跳跃至上一个缓冲区。</p>
<blockquote>
<p>由于前端插入操作涉及到现有缓冲区前面的空间，因此需要确保当前缓冲区完全没有空间时，再进行新的缓冲区分配和跳跃操作。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<p>deque 采用一个 “map”（并非 STL 中的 map 容器）来指向其分段连续空间（缓冲区）。map 中的每一个元素 node 为一个指针，指向其对应的缓冲区。对于 deque 来说，主要维护 3 个指针：</p>
<ol>
<li>指向 map 的指针；</li>
<li>start：指向第一缓冲区的第一个元素；</li>
<li>finish：指向最后缓冲区的最后一个元素。</li>
</ol>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406201720123.png" alt="image-20240620172003136" style="zoom: 25%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406201720621.png" alt="image-20240620172045147" style="zoom: 25%;" />

<h2 id="std-stack"><a href="#std-stack" class="headerlink" title="std::stack"></a>std::stack</h2><h3 id="1、基本用法-3"><a href="#1、基本用法-3" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">empty</span>();			<span class="comment">// 栈为空时返回1，非空返回0</span></span><br><span class="line">st.<span class="built_in">size</span>();			<span class="comment">// 返回栈中元素数量，size_type size() const;</span></span><br><span class="line">st.<span class="built_in">top</span>();			<span class="comment">// 返回栈顶元素，value_type&amp; top();</span></span><br><span class="line">st.<span class="built_in">push</span>(value);		<span class="comment">// 在栈顶插入一个元素，void push( const value_tyoe&amp; val );</span></span><br><span class="line">st.<span class="built_in">emplace</span>(value);	<span class="comment">// 在栈顶增加一个元素，void emplace( args&amp;&amp; args );</span></span><br><span class="line">st.<span class="built_in">pop</span>();			<span class="comment">// 栈顶元素出栈，即删除栈顶元素，void pop(); </span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st2;</span><br><span class="line">st1.<span class="built_in">swap</span>( st2 );	<span class="comment">// 交换两个栈中的内容，void swap( stack&amp; x );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与vector一样，重载了运算符：== != &lt; &lt;= &gt; &gt;=</span></span><br></pre></td></tr></table></figure>

<h3 id="2、理论相关"><a href="#2、理论相关" class="headerlink" title="2、理论相关"></a>2、理论相关</h3><p>STL 中 stack 往往不被归类为容器，而被归类为容器适配器（container adapter）。因为<strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p>
<p>栈的底层实现可以是 vector、deque或list 等， 主要就是数组和链表的底层实现。常用的 SGI STL ，如果没有指定底层实现的话，<strong>默认是以 deque 为缺省情况下栈的底层结构</strong>。此外，SGI STL 中队列一样是以 deque 为缺省情况下的底部结构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242029774.png" alt="栈与队列理论3" style="zoom:50%;" />

<blockquote>
<p>三个最为普遍的 STL 版本：</p>
<ol>
<li>HP STL 其他版本的 C++ STL，一般是以 HP STL 为蓝本实现出来的，HP STL 是 C++ STL 的第一个实现版本，而且开放源代码。</li>
<li>P.J.Plauger STL 由 P.J.Plauger 参照 HP STL 实现出来的，被 Visual C++ 编译器所采用，不是开源的。</li>
<li>SGI STL 由 Silicon Graphics Computer Systems 公司参照HP STL 实现，被 Linux 的 C++ 编译器 GCC 所采用，SGI STL 是开源软件，源码可读性甚高。</li>
</ol>
</blockquote>
<h2 id="std-queue"><a href="#std-queue" class="headerlink" title="std::queue"></a>std::queue</h2><h3 id="1、基本用法-4"><a href="#1、基本用法-4" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">queue&lt;<span class="type">double</span>&gt; d;</span><br><span class="line">queue&lt;node&gt; n;  <span class="comment">// node是一个结构体</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">size</span>();		<span class="comment">// 返回q里元素个数</span></span><br><span class="line">q.<span class="built_in">empty</span>();		<span class="comment">// 返回q是否为空，空则返回1，否则返回0</span></span><br><span class="line">q.<span class="built_in">push</span>(k);		<span class="comment">// 在q的末尾插入k</span></span><br><span class="line">q.<span class="built_in">pop</span>();		<span class="comment">// 删掉q的第一个元素</span></span><br><span class="line">q.<span class="built_in">front</span>();		<span class="comment">// 返回q的第一个元素</span></span><br><span class="line">q.<span class="built_in">back</span>();		<span class="comment">// 返回q的末尾元素</span></span><br></pre></td></tr></table></figure>

<h2 id="std-priority-queue"><a href="#std-priority-queue" class="headerlink" title="std::priority_queue"></a>std::priority_queue</h2><h3 id="1、基本用法-5"><a href="#1、基本用法-5" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><h4 id="（1）声明"><a href="#（1）声明" class="headerlink" title="（1）声明"></a>（1）声明</h4>   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = vector&lt;T&gt;, <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Container::value_type&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：优先队列中的元素类型；</li>
<li><code>Container</code>：底层容器的类型；</li>
<li><code>Compare</code>：比较函数对象，决定了优先队列的排序方式。</li>
</ul>
<h4 id="（2）基本操作"><a href="#（2）基本操作" class="headerlink" title="（2）基本操作"></a>（2）基本操作</h4>   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">q.<span class="built_in">size</span>();	<span class="comment">// 返回q里元素个数</span></span><br><span class="line">q.<span class="built_in">empty</span>();	<span class="comment">// 返回q是否为空，空则返回1，否则返回0</span></span><br><span class="line">q.<span class="built_in">push</span>(k);	<span class="comment">// 在q的末尾插入k</span></span><br><span class="line">q.<span class="built_in">pop</span>();	<span class="comment">// 删掉q的第一个元素</span></span><br><span class="line">q.<span class="built_in">top</span>();	<span class="comment">// 返回q的第一个元素</span></span><br></pre></td></tr></table></figure>

<h4 id="（3）排序实现"><a href="#（3）排序实现" class="headerlink" title="（3）排序实现"></a>（3）排序实现</h4><ol>
<li><p><code>less</code>和<code>greater</code>优先队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt; p;</span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// less&lt;int&gt;:14 12 10 8 6（大顶堆）</span></span><br><span class="line"><span class="comment">// greater&lt;int&gt;:6 8 10 12 14（小顶堆）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义仿函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义仿函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareByAge</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person&amp; p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.age &gt; p2.age;  <span class="comment">// 按照年龄从小到大排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2、理论相关-1"><a href="#2、理论相关-1" class="headerlink" title="2、理论相关"></a>2、理论相关</h3><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>优先级队列（<code>priority_queue</code>）是C++标准库中的一个<strong>容器适配器（container adapter）</strong>，其中的元素按照一定的优先级进行排序，每次取出的元素都是优先级最高的。其底层实现通常使用堆<strong>（heap）</strong>数据结构。</p>
<p>定义在<code>&lt;queue&gt;</code>头文件中。</p>
<p>默认情况下，<code>priority_queue</code>使用<code>std::less</code>作为比较函数，即元素的优先级按照从大到小的顺序排列。</p>
<h4 id="（2）特点"><a href="#（2）特点" class="headerlink" title="（2）特点"></a>（2）特点</h4><ul>
<li><strong>优先级排序</strong>：priority_queue中的元素按照一定的优先级进行排序。默认情况下，元素的优先级按照从大到小的顺序排列，也可以通过自定义的比较函数来指定不同的排序方式。</li>
<li><strong>自动排序</strong>：在插入元素时，priority_queue会根据元素的优先级自动进行排序。每次插入新元素时，都会将新元素放置在正确的位置上。</li>
<li><strong>取出优先级最高元素</strong>：priority_queue提供了一种方便的方式来取出优先级最高的元素。使用top()函数可以访问优先级最高的元素，而使用pop()函数可以将该元素从队列中移除。</li>
<li><strong>底层实现采用堆</strong>：priority_queue通常使用堆（heap）数据结构来实现。堆是一种具有特定性质的二叉树，可以高效地插入新元素和取出优先级最高的元素。</li>
<li><strong>动态大小</strong>：priority_queue的大小可以根据需要进行动态调整。可以随时插入新元素和删除已有元素，并在必要时自动重新排序。</li>
</ul>
<h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1><h2 id="std-unordered-set"><a href="#std-unordered-set" class="headerlink" title="std::unordered_set"></a>std::unordered_set</h2><h3 id="1、基本用法-6"><a href="#1、基本用法-6" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before add elements......&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 获取或设置允许的最大装载因子</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max load facotr: &quot;</span> &lt;&lt; mySet.<span class="built_in">max_load_factor</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 返回当前装载因子</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Load factor: &quot;</span> &lt;&lt; mySet.<span class="built_in">load_factor</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 返回当前bucket的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bucket count: &quot;</span> &lt;&lt; mySet.<span class="built_in">bucket_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">2</span>); <span class="comment">// 重复插入，不会有任何效果</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Is the set empty ? &quot;</span> &lt;&lt; mySet.<span class="built_in">empty</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">if</span> (mySet.<span class="built_in">find</span>(<span class="number">2</span>) != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Found 2 in the set.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历集合</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements in mySet: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : mySet) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    mySet.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After erasing 2, size of mySet: &quot;</span> &lt;&lt; mySet.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After add elements......&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max load facotr: &quot;</span> &lt;&lt; mySet.<span class="built_in">max_load_factor</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Load factor: &quot;</span> &lt;&lt; mySet.<span class="built_in">load_factor</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bucket count: &quot;</span> &lt;&lt; mySet.<span class="built_in">bucket_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    mySet.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Before add elements......</span><br><span class="line">Max load facotr: 1</span><br><span class="line">Load <span class="built_in">factor</span>: 0</span><br><span class="line">Bucket count: 1</span><br><span class="line"></span><br><span class="line">Is the <span class="built_in">set</span> empty ? 0</span><br><span class="line">Found 2 <span class="keyword">in</span> the <span class="built_in">set</span>.</span><br><span class="line">Elements <span class="keyword">in</span> mySet: 3 2 1 </span><br><span class="line">After erasing 2, size of mySet: 2</span><br><span class="line"></span><br><span class="line">After add elements......</span><br><span class="line">Max load facotr: 1</span><br><span class="line">Load <span class="built_in">factor</span>: 0.153846</span><br><span class="line">Bucket count: 13</span><br></pre></td></tr></table></figure>

<h3 id="2、内部实现-1"><a href="#2、内部实现-1" class="headerlink" title="2、内部实现"></a>2、内部实现</h3><p><code>std::unordered_set</code> 的内部实现基于哈希表，哈希表是一个数组，数组的每个元素称为一个 <code>bucket</code>。这点和 <code>std::unordered_map</code> 是一样的。</p>
<p>同样的，每个 <code>bucket</code> 维护一个链表（或其他容器，例如小型向量），用于解决哈希冲突（即不同元素的哈希值相同的情况）。</p>
<ul>
<li>哈希函数：<code>std::unordered_set</code>通过哈希函数将元素映射到一个 <code>bucket</code>。哈希函数的质量决定了元素在哈希表中的分布，影响容器的性能。</li>
<li>哈希冲突：当两个元素的哈希值相同时，它们会被存储在同一个 <code>bucket</code> 的链表中，这种情况称为哈希冲突。<code>std::unordered_set</code>通过链地址法来解决哈希冲突。</li>
<li>装载因子和重哈希：装载因子是<code>元素数量 / bucket数量</code>。当装载因子超过某个阈值时（默认为<code>1.0</code>），<code>std::unordered_set</code>会进行重哈希操作，即增加 <code>bucket</code> 数量并重新分配所有元素，以保持操作的高效性。</li>
</ul>
<p>适用场景</p>
<ul>
<li>需要快速查找的场景：当需要存储一组唯一元素，并且频繁地进行查找操作时；</li>
<li>不关心元素顺序：<code>std::unordered_set</code>不保证元素的顺序；</li>
<li>大量数据的去重：当需要从大量数据中去除重复项时。</li>
</ul>
<h2 id="std-unordered-map"><a href="#std-unordered-map" class="headerlink" title="std::unordered_map"></a>std::unordered_map</h2><h3 id="1、基本用法-7"><a href="#1、基本用法-7" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    map.<span class="built_in">insert</span>(&#123;<span class="string">&quot;apple&quot;</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    map[<span class="string">&quot;banana&quot;</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;apple has &quot;</span> &lt;&lt; map[<span class="string">&quot;apple&quot;</span>] &lt;&lt; <span class="string">&quot; units.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用find查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> search = map.<span class="built_in">find</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (search != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Found banana, count = &quot;</span> &lt;&lt; search-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Banana not found.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : map) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; has &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot; units.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    map.<span class="built_in">erase</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The map has &quot;</span> &lt;&lt; map.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; elements.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    map.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apple has 5 units.</span><br><span class="line">Found banana, count = 3</span><br><span class="line">banana has 3 units.</span><br><span class="line">apple has 5 units.</span><br><span class="line">The map has 1 elements.</span><br></pre></td></tr></table></figure>

<h3 id="2、内部实现-2"><a href="#2、内部实现-2" class="headerlink" title="2、内部实现"></a>2、内部实现</h3><p><code>std::unordered_map</code>内部使用哈希表实现，因此它支持平均常数时间复杂度的查找、插入和删除操作，而<code>std::map</code>使用红黑树实现，提供对数时间复杂度的操作。</p>
<p><code>std::unordered_map</code>内部主要是通过一个动态数组（通常称为 <code>bucket</code> 数组）来维护元素，每个数组元素（或称为 <code>bucket</code>）包含一个指向链表（或其他形式的容器，如小型向量）的指针。</p>
<p>这些链表用于存储具有相同哈希值的元素（键值对）。当发生哈希冲突时（即不同的键产生相同的哈希值），<code>std::unordered_map</code>会将具有相同哈希值的元素存储在同一个 <code>bucket</code> 的链表中。</p>
<ul>
<li>哈希函数：<code>std::unordered_map</code>使用一个哈希函数将键映射到 bucket 的索引。哈希函数的质量直接影响到容器的性能，理想情况下，哈希函数应该将键均匀分布到所有的 <code>buckets</code> 上，以减少哈希冲突。</li>
<li>哈希表：内部数据结构，通常是一个动态数组，其中的每个元素指向一个链表（或其他容器），用于解决哈希冲突。</li>
<li>键值对：存储在链表中的元素，每个元素包含一个键和一个值。</li>
<li>装载因子：<code>std::unordered_map</code>的装载因子是一个浮点数，定义为<code>元素个数 / bucket数量</code>。当装载因子超过特定阈值（默认为<code>1.0</code>）时，哈希表会进行重新哈希（<code>rehashing</code>），即增加 <code>bucket</code> 数量并重新分配所有元素，以保持操作的效率。</li>
</ul>
<p>适用场景</p>
<ul>
<li><p><strong>需要快速查找的场景；</strong></p>
</li>
<li><p><strong>不关心元素顺序的场景；</strong></p>
</li>
<li><p><strong>键值对存储。</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
        <category>零散</category>
      </categories>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2024/06/12/%E9%9D%A2%E8%AF%95/%E9%9B%B6%E6%95%A3/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="一、shared-ptr-weak-ptr"><a href="#一、shared-ptr-weak-ptr" class="headerlink" title="一、shared_ptr &amp; weak_ptr"></a>一、shared_ptr &amp; weak_ptr</h1><p><a href="https://blog.csdn.net/ithiker/article/details/51532484">C++ 智能指针（shared_ptr&#x2F;weak_ptr）源码分析</a></p>
<h2 id="1、类关系图"><a href="#1、类关系图" class="headerlink" title="1、类关系图"></a>1、类关系图</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406121430079.png" alt="img"></p>
<p>shared_ptr内部包含：</p>
<ul>
<li>1）指向被管理对象(managed object)T的指针</li>
<li>2）__shared_count对象，其内部包含：<ul>
<li>a. 指向管理对象(manager object)的基类指针。</li>
</ul>
</li>
</ul>
<p>管理对象(manager object)内部包含：</p>
<ul>
<li>1）具有原子属性(_Atomic_word)的use_count&#x2F;weak_count</li>
<li>2）指向被管理对象(managed object)T的指针</li>
<li>3）用来销毁被管理对象的deleter</li>
</ul>
<p>被管理对象和管理对象的划分如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406121436387.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406121436029.png" alt="img"></p>
<p>可以看出，shared_ptr与weak_ptr的差异主要是由__shared_ptr与__weak_ptr体现出来的，而__shared_ptr与__weak_ptr的差异则主要是由__shared_count与__weak_count体现出来。</p>
<h2 id="2、详细分析"><a href="#2、详细分析" class="headerlink" title="2、详细分析"></a>2、详细分析</h2><h3 id="（1）shared-ptr的构造函数"><a href="#（1）shared-ptr的构造函数" class="headerlink" title="（1）shared_ptr的构造函数"></a>（1）shared_ptr的构造函数</h3><p>在创建一个<code>shared_ptr</code>的时候需要通过被管理对象的地址来初始化<code>shared_ptr</code>, <code>shared_ptr</code>在内部会构建一个<code>__shared_count</code>对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt; <span class="keyword">explicit</span> __shared_ptr(_Tp1* __p)</span><br><span class="line">: _M_ptr(__p), _M_refcount(__p) &#123;</span><br><span class="line">    <span class="comment">// 静态断言，确保 _Tp1* 可以转换为 _Tp*，用于类型安全检查</span></span><br><span class="line">    __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)</span><br><span class="line">    <span class="comment">// 确保 _Tp1 类型是完整的</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> _IsComplete[<span class="built_in">sizeof</span>(_Tp1)];</span><br><span class="line">    <span class="comment">// 启用 shared_from_this 的辅助功能，允许被管理对象在不知道其自身被管理的情况下创建其他 shared_ptr 实例</span></span><br><span class="line">    __enable_shared_from_this_helper(_M_refcount, __p, __p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>explicit __shared_ptr(_Tp1* __p)</code>：显式构造函数，接受一个 <code>_Tp1*</code> 类型的指针 <code>__p</code>，该指针通常是通过 <code>new</code> 操作符分配的。</li>
<li><code>: _M_ptr(__p), _M_refcount(__p)</code>：初始化列表，负责初始化 <code>__shared_ptr</code> 的成员变量。<ul>
<li><code>_M_ptr</code> 是一个<strong>指向被管理对象的指针</strong>，初始化为 <code>__p</code>。</li>
<li><code>_M_refcount</code> 是一个<strong>引用计数控制块</strong>，通常包含引用计数和自定义删除器等信息，也被初始化为 <code>__p</code>。</li>
</ul>
</li>
</ul>
<p>由<code>__shared_count</code>对象的构造函数可知，创建<code>shared_ptr</code>的时候也动态的创建了一个管理对象<code>_Sp_counted_base_impl</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line">__shared_count(_Ptr __p) : _M_pi(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    __try</span><br><span class="line">   &#123;</span><br><span class="line">	  <span class="keyword">typedef</span> <span class="keyword">typename</span> std::tr1::remove_pointer&lt;_Ptr&gt;::type _Tp;</span><br><span class="line">	  _M_pi = <span class="keyword">new</span> _Sp_counted_base_impl&lt;_Ptr, _Sp_deleter&lt;_Tp&gt;, _Lp&gt;(__p, _Sp_deleter&lt;_Tp&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    __catch(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> __p;</span><br><span class="line">	__throw_exception_again;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>shared_ptr</code>内部包含一个指向被管理对象的指针<code>_M_ptr</code>， <code>_Sp_counted_base_impl</code>内部也含有一个指向被管理对象的指针<code>_M_ptr</code>， 它们是不是重复多余了呢？</p>
</blockquote>
<p>实际上不多余，它们有各自的功能。首先给出结论：</p>
<blockquote>
<p><code>__shared_ptr</code>直接包含的裸指针是为了实现一般指针的<code>-&gt;</code>和<code>*</code>等操作；通过<code>__shared_count</code>间接包含的指针是为了管理对象的生命周期，回收相关资源。</p>
<p>换句话说，<code>__shared_count</code>内部的<code>use_count</code>主要用来标记被管理对象的生命周期，<code>weak_count</code>主要用来标记管理对象的生命周期。</p>
<p>当一个<code>shared_ptr</code>超出作用域被销毁时，它会调用其<code>_share_count</code>的<code>_M_release()</code>对<code>use_count</code>和<code>weak_count</code>进行自减并判断是否需要释放管理对象和被管理对象，这是<code>RAII</code>原理的核心体现。</p>
</blockquote>
<p>这首先要从<code>shared_ptr</code>的拷贝构造或者赋值构造说起。当一个<code>shared_ptr</code>对象<code>sp2</code>是由<code>sp1</code>拷贝构造或者赋值构造得来的时候，实际上<strong>构造完成后<code>sp1</code>内部的<code>__shared_count</code>对象包含的指向管理对象的指针与<code>sp2</code>内部的<code>__shared_count</code>对象包含的指向管理对象的指针是相等的</strong>，也就是说当多个<code>shared_ptr</code>对象来管理同一个对象时，它们共同使用同一个动态分配的管理对象。</p>
<p>这可以从下面的<code>__share_ptr</code>的构造函数和<code>__shared_count</code>的构造函数清楚地看出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line"> __shared_ptr(<span class="type">const</span> __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r)</span><br><span class="line"> : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) <span class="comment">// never throws</span></span><br><span class="line">&#123; __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;) &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">__shared_count&amp;</span><br><span class="line">    <span class="keyword">operator</span>=(<span class="type">const</span> __shared_count&amp; __r) <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">    <span class="keyword">if</span> (__tmp != _M_pi)  <span class="comment">// 避免自我赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__tmp != <span class="number">0</span>)</span><br><span class="line">            __tmp-&gt;_M_add_ref_copy();  <span class="comment">// 增加目标控制块的引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (_M_pi != <span class="number">0</span>)  </span><br><span class="line">            _M_pi-&gt;_M_release();  <span class="comment">// 减少当前控制块的引用计数</span></span><br><span class="line">        _M_pi = __tmp;   <span class="comment">// 更新当前实例的控制块指针 _M_pi，使其指向目标控制块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对<code>if (_M_pi != 0)</code>，考虑以下两种情况：</p>
<ul>
<li><pre><code class="c++">std::shared_ptr&lt;int&gt; sp1(new int(10));
std::shared_ptr&lt;int&gt; sp2;

// sp2 此时未初始化，_M_pi == 0
sp2 = sp1;  // 调用赋值运算符
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ ```c++</span><br><span class="line">  std::shared_ptr&lt;int&gt; sp1(new int(10));  // sp1指向new int(10)，其引用计数为1</span><br><span class="line">  std::shared_ptr&lt;int&gt; sp2(new int(11));  // sp2指向new int(11)，其引用计数为1</span><br><span class="line">  </span><br><span class="line">  // sp2已初始化，_M_pi != 0</span><br><span class="line">  sp2 = sp1;  // 调用赋值运算符，注意此处sp2指向的new int(11)引用计数减1，因此sp2和其指向的对象均被析构</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>针对<code>_M_add_ref_copy()</code>和<code>_M_release()</code>做进一步分析：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//************_Sp_counted_base*****************//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_M_add_ref_copy()</span><br><span class="line">&#123; __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, <span class="number">1</span>); &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//************_Sp_counted_base*****************//</span></span><br><span class="line"><span class="type">void</span> _M_release() <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">    <span class="comment">// 用于告知数据竞赛检测工具（如 ThreadSanitizer），在这行代码之前发生了内存同步事件</span></span><br><span class="line">    <span class="comment">// 确保线程间正确通信</span></span><br><span class="line">    _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 减少引用计数，并检查是否是最后一个引用</span></span><br><span class="line">    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, <span class="number">-1</span>) == <span class="number">1</span>)  <span class="comment">// 减少引用计数 _M_use_count，并返回减少前的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 另一个内存同步事件，通知数据竞赛检测工具此时的引用计数减少操作已经完成</span></span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);</span><br><span class="line">      </span><br><span class="line">        _M_dispose();  <span class="comment">// 释放对象资源</span></span><br><span class="line">        <span class="comment">// There must be a memory barrier between dispose() and destroy()</span></span><br><span class="line">        <span class="comment">// to ensure that the effects of dispose() are observed in the</span></span><br><span class="line">        <span class="comment">// thread that runs destroy().</span></span><br><span class="line">        <span class="comment">// See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html</span></span><br><span class="line">        <span class="comment">// 确保在 _M_dispose() 和 _M_destroy() 之间有一个内存屏障，</span></span><br><span class="line">        <span class="comment">// 以确保所有 _M_dispose() 的效果对调用 _M_destroy() 的线程可见</span></span><br><span class="line">        <span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)</span><br><span class="line">        &#123;</span><br><span class="line">            __atomic_thread_fence (__ATOMIC_ACQ_REL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">        <span class="comment">// 通知数据竞赛检测工具弱引用计数的操作即将开始</span></span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 减少弱引用计数，并检查是否是最后一个弱引用</span></span><br><span class="line">        <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 另一个内存同步事件，通知数据竞赛检测工具此时的弱引用计数减少操作已经完成</span></span><br><span class="line">            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">                        </span><br><span class="line">            _M_destroy();  <span class="comment">// 释放控制块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//************_Sp_counted_base*****************//</span></span><br><span class="line"><span class="comment">// Called when _M_use_count drops to zero, to release the resources</span></span><br><span class="line"><span class="comment">// managed by *this.</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="type">void</span></span><br><span class="line">_M_dispose() = <span class="number">0</span>; <span class="comment">// nothrow</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Called when _M_weak_count drops to zero.</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="type">void</span></span><br><span class="line">_M_destroy() <span class="comment">// nothrow</span></span><br><span class="line">&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//************_Sp_counted_base_impl*************//</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="type">void</span></span><br><span class="line">_M_dispose() <span class="comment">// nothrow</span></span><br><span class="line">&#123; _M_del(_M_ptr); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）weak-ptr对应的-weak-count的拷贝构造函数"><a href="#（2）weak-ptr对应的-weak-count的拷贝构造函数" class="headerlink" title="（2）weak_ptr对应的__weak_count的拷贝构造函数"></a>（2）weak_ptr对应的__weak_count的拷贝构造函数</h3><ul>
<li><code>__weak_count</code>相关的赋值拷贝以及析构函数均只会影响到<code>weak_count</code>的值，对<code>use_count</code>没有影响；当<code>weak_count</code>为0时，释放管理对象。也就是说<code>__weak_ptr</code>不影响被管理对象的生命周期。同时由于<code>__weak_ptr</code>没有像<code>__shared_ptr</code>那样实现<code>*</code>，<code>-&gt;</code>等常见指针相关操作符，<code>__weak_ptr</code>不能直接操作被管理对象；</li>
<li><code>__weak_count</code>自身间的赋值以及<code>__shared_count</code>对<code>__weak_count</code>的赋值时，它们都具有同样的指向管理对象的指针；也就是说当多个<code>__weak_ptr</code>和<code>__shared_ptr</code>指向同一个被管理对象时，它们共享同一个管理对象，这就保证了可以通过<code>__weak_ptr</code>可以判断<code>__shared_ptr</code>指向的被管理对象是否存在以及获取到被管理对象的指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//************_Sp_counted_base*****************//</span></span><br><span class="line"> <span class="type">void</span></span><br><span class="line"> _M_weak_add_ref() <span class="comment">// nothrow</span></span><br><span class="line">&#123; __gnu_cxx::__atomic_add_dispatch(&amp;_M_weak_count, <span class="number">1</span>); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//************_Sp_counted_base*****************//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_M_weak_release() <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Be race-detector-friendly. For more info see bits/c++config.</span></span><br><span class="line">    _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);</span><br><span class="line">    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">	<span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">// See _M_release(),</span></span><br><span class="line">	    <span class="comment">// destroy() must observe results of dispose()</span></span><br><span class="line">            __atomic_thread_fence (__ATOMIC_ACQ_REL);</span><br><span class="line">	&#125;</span><br><span class="line">	_M_destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">__weak_count&lt;_Lp&gt;&amp;</span><br><span class="line">operator=(<span class="type">const</span> __shared_count&lt;_Lp&gt;&amp; __r) <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">    <span class="keyword">if</span> (__tmp != <span class="number">0</span>)</span><br><span class="line">        __tmp-&gt;_M_weak_add_ref();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">        _M_pi-&gt;_M_weak_release();</span><br><span class="line">  </span><br><span class="line">    _M_pi = __tmp;  </span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> *this;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">__weak_count&lt;_Lp&gt;&amp;</span><br><span class="line">operator=(<span class="type">const</span> __weak_count&lt;_Lp&gt;&amp; __r) <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">    <span class="keyword">if</span> (__tmp != <span class="number">0</span>)</span><br><span class="line">        __tmp-&gt;_M_weak_add_ref();</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">        _M_pi-&gt;_M_weak_release();</span><br><span class="line">    _M_pi = __tmp;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> *this;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">__weak_count&lt;_Lp&gt;&amp;</span><br><span class="line">operator=(<span class="type">const</span> __shared_count&lt;_Lp&gt;&amp; __r) <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">    <span class="keyword">if</span> (__tmp != <span class="number">0</span>)</span><br><span class="line">      __tmp-&gt;_M_weak_add_ref();</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">      _M_pi-&gt;_M_weak_release();</span><br><span class="line">    _M_pi = __tmp;  </span><br><span class="line">    <span class="keyword">return</span> *this;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">~__weak_count() <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">        _M_pi-&gt;_M_weak_release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）-shared-ptr与-weak-ptr管理同一对象"><a href="#（3）-shared-ptr与-weak-ptr管理同一对象" class="headerlink" title="（3）__shared_ptr与__weak_ptr管理同一对象"></a>（3）__shared_ptr与__weak_ptr管理同一对象</h3><p>关系图如下所示：</p>
<p>其中<code>weak_ptr</code>不能直接操作被管理对象，但其仍然持有指向被管理对象的指针（用来初始化内部的<code>__weak_count</code>对象），<code>weak_ptr</code>与被管理对象用虚线联接。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406121521900.png" alt="img"></p>
<h3 id="（4）shared-ptr的两个“大坑”"><a href="#（4）shared-ptr的两个“大坑”" class="headerlink" title="（4）shared_ptr的两个“大坑”"></a>（4）shared_ptr的两个“大坑”</h3><h4 id="A-当一个对象M创建后，如果一个函数f（另一个类的成员函数或是其它自由函数）的形参为M类型的智能指针，如何在对象M内部将对象M的指针作为实参传递给该函数f"><a href="#A-当一个对象M创建后，如果一个函数f（另一个类的成员函数或是其它自由函数）的形参为M类型的智能指针，如何在对象M内部将对象M的指针作为实参传递给该函数f" class="headerlink" title="A. 当一个对象M创建后，如果一个函数f（另一个类的成员函数或是其它自由函数）的形参为M类型的智能指针，如何在对象M内部将对象M的指针作为实参传递给该函数f ?"></a>A. 当一个对象M创建后，如果一个函数f（另一个类的成员函数或是其它自由函数）的形参为M类型的智能指针，如何在对象M内部将对象M的指针作为实参传递给该函数f ?</h4><blockquote>
<p><code>shared_ptr</code>能够管理对象的生命周期，负责对象资源释放，其前提条件是所有<code>shared_ptr</code>共用同一个管理对象。如果<strong>多个<code>shared_ptr</code>使用多个管理对象来管理同一个被管理对象</strong>，这些管理对象在<code>use_count</code>为<code>0</code>时均会释放被管理对象，将会造成多个管理对象多次释放被管理对象，造成<code>twice delete</code>的堆错误。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">defrangulate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transmogrify</span><span class="params">(Thing *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Thing * t1 = <span class="keyword">new</span> Thing;</span><br><span class="line">	t1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">delete</span> t1; <span class="comment">// done with the object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thing::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// we need to transmogrify this object</span></span><br><span class="line">	<span class="built_in">transmogrify</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transmogrify</span><span class="params">(Thing * ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ptr-&gt;<span class="built_in">defrangulate</span>();</span><br><span class="line">	<span class="comment">/* etc. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***** Use shared_ptr***************************//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">defrangulate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transmogrify</span><span class="params">(shared_ptr&lt;Thing&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;Thing&gt; <span class="title">t1</span><span class="params">(<span class="keyword">new</span> Thing)</span></span>; <span class="comment">// create manager object A for the Thing</span></span><br><span class="line">	t1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Thing is supposed to get deleted when t1 goes out of scope</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thing::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// we need to transmogrify this object</span></span><br><span class="line">	<span class="function">shared_ptr&lt;Thing&gt; <span class="title">sp_for_this</span><span class="params">(<span class="keyword">this</span>)</span></span>; <span class="comment">//  create manager object B for the Thing</span></span><br><span class="line">	<span class="built_in">transmogrify</span>(sp_for_this);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Thing is supposed to get deleted when sp_for_this and other shared_ptr goes out of scope</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transmogrify</span><span class="params">(shared_ptr&lt;Thing&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ptr-&gt;<span class="built_in">defrangulate</span>();</span><br><span class="line">	<span class="comment">/* etc. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++引入了<code>enable_shared_from_this</code>，利用<code>weak_ptr</code>的特性解决了这一问题。</p>
<p>其基本思想是：通过<code>M</code>继承模板类<code>enable_shared_from_this</code>，这样对象<code>M</code>内部将会有一个<code>__weak_ptr</code>指针<code>_M_weak_this</code>，在第一次创建指向<code>M</code>的<code>shared_ptr</code>时，通过模板特化，将会初始化<code>_M_weak_this</code>。这样<code>M</code>内部也会产生一个指向自身的<code>weak_ptr</code>，并且该<code>weak_ptr</code>内部的管理对象与Pt的管理对象是相同的（这可以从<code>weak_ptr</code>内部的<code>_M_assign</code>函数看出）。</p>
<p>这样，在<code>M</code>内部，当需要传递指向<code>M</code>的智能指针时，可以通过继承而来的<code>shared_from_this</code>方法获取到指向<code>M</code>的智能指针而不会发生内存泄漏。上面示例中改写后的正确代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span> : <span class="keyword">public</span> enable_shared_from_this&lt;Thing&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">defrangulate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// The following starts a manager object for the Thing and also</span></span><br><span class="line">	<span class="comment">// initializes the weak_ptr member that is now part of the Thing and share same manager object.</span></span><br><span class="line">	<span class="function">shared_ptr&lt;Thing&gt; <span class="title">t1</span><span class="params">(<span class="keyword">new</span> Thing)</span></span>;</span><br><span class="line">	t1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thing::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// get a shared_ptr from the weak_ptr in this object</span></span><br><span class="line">	shared_ptr&lt;Thing&gt; sp_this = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	<span class="built_in">transmogrify</span>(sp_this);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transmogrify</span><span class="params">(shared_ptr&lt;Thing&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ptr-&gt;<span class="built_in">defrangulate</span>();</span><br><span class="line">	<span class="comment">/* etc. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="B-在采用shared-ptr-p-new-M-形式创建p来管理M时，这中间有两次的动态内存分配：一次为创建被管理对象M，一次为创建管理对象；而内存分配通常是比较昂贵的操作"><a href="#B-在采用shared-ptr-p-new-M-形式创建p来管理M时，这中间有两次的动态内存分配：一次为创建被管理对象M，一次为创建管理对象；而内存分配通常是比较昂贵的操作" class="headerlink" title="B. 在采用shared_ptr&lt;M&gt; p(new M)形式创建p来管理M时，这中间有两次的动态内存分配：一次为创建被管理对象M，一次为创建管理对象；而内存分配通常是比较昂贵的操作"></a>B. 在采用<code>shared_ptr&lt;M&gt; p(new M)</code>形式创建p来管理M时，这中间有两次的动态内存分配：一次为创建被管理对象M，一次为创建管理对象；而内存分配通常是比较昂贵的操作</h4><p>如果频繁的需要创建指向多个不同对象的智能指针，可以采用<code>shared_ptr&lt;M&gt; p(make_shared&lt;M&gt;)</code>的方式，采用这种方式<strong>系统将会分配一大块内存同时存放管理对象和被管理对象</strong>，这就避免了上面所说的二次内存分配的问题，同时程序中也不会出现<code>new</code>操作符，符合<code>&quot;no naked new!&quot;</code>的编程倡导。</p>
<p>当然这也有缺点，如果所有指向该对象的智能指针都销毁了，尽管对象的析构函数会被调用，析构被管理对象，但是<strong>如果还有<code>weak_ptr</code>指向该块对象所在的内存，存放管理对象的部分内存仍将不会被释放</strong>，因而导致在所有其他<code>weak_ptr</code>销毁前整块内存（尽管被管理对象已经析构了）将不会进入系统的内存池循环使用。</p>
<h1 id="二、unique-ptr"><a href="#二、unique-ptr" class="headerlink" title="二、unique_ptr"></a>二、unique_ptr</h1><p><code>unique_ptr</code>是智能指针的一种，他<strong>只可移动不可复制</strong>，即一个指针的所有权只能由一个智能指针所占有。</p>
<p><code>unique_ptr</code>内部靠一个<code>tuple</code>来维护<code>raw pointer</code>和<code>deleter</code>。<code>unique_ptr</code>相当于一个对<code>RAII</code>的封装，他在栈上有一个指针，指针指向堆中实际分配的内存，当栈上指针生命周期结束时，自动调用<code>deleter</code>去释放堆上内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _Tp为管理对象的类型，_Dp为析构器的类型</span></span><br><span class="line"><span class="comment">// default_delete是默认析构器，默认析构器中使用delete运算符实现对象的析构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用__uniq_ptr_impl管理要管理的heap对象</span></span><br><span class="line">    <span class="comment">// _Tp为管理对象类型，_Dp为析构器</span></span><br><span class="line">    __uniq_ptr_impl&lt;_Tp, _Dp&gt; _M_t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> pointer    = <span class="keyword">typename</span> __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer;</span><br><span class="line">    <span class="keyword">using</span> element_type  = _Tp;</span><br><span class="line">    <span class="keyword">using</span> deleter_type  = _Dp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1、-uniq-ptr-impl"><a href="#1、-uniq-ptr-impl" class="headerlink" title="1、__uniq_ptr_impl"></a>1、__uniq_ptr_impl</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _Tp为管理对象的类型，_Dp为析构器的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__uniq_ptr_impl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> _Ptr</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> type = _Up*;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// pointer实际上就是_Tp*</span></span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="keyword">typename</span> _Ptr&lt;_Tp, _Dp&gt;::type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 使用tuple管理指针和析构器，通过get&lt;0&gt;获取_Tp*，get&lt;1&gt;获取析构器</span></span><br><span class="line">    tuple&lt;pointer, _Dp&gt; _M_t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    __uniq_ptr_impl() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 先通过_M_t()获取指针，再赋值</span></span><br><span class="line">    __uniq_ptr_impl(pointer __p) : _M_t() &#123; _M_ptr() = __p; &#125;</span><br><span class="line">    <span class="comment">// 自定义析构器</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Del&gt;</span><br><span class="line">    __uniq_ptr_impl(pointer __p, _Del&amp;&amp; __d) : _M_t(__p, std::forward&lt;_Del&gt;(__d)) &#123; &#125;</span><br><span class="line">    <span class="comment">// 获取所管理的对象</span></span><br><span class="line">    pointer&amp;   _M_ptr() &#123; <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(_M_t); &#125;</span><br><span class="line">    <span class="comment">// 获取析构器</span></span><br><span class="line">    _Dp&amp;       _M_deleter() &#123; <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(_M_t); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、构造函数和析构函数"><a href="#2、构造函数和析构函数" class="headerlink" title="2、构造函数和析构函数"></a>2、构造函数和析构函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数，显式创建一个空的unique_ptr对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Up = _Dp, <span class="keyword">typename</span> = _DeleterConstraint&lt;_Up&gt;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span> : _M_t() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指针__p构造一个unique_ptr对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Up = _Dp, <span class="keyword">typename</span> = _DeleterConstraint&lt;_Up&gt;&gt;</span><br><span class="line"><span class="keyword">explicit</span> <span class="built_in">unique_ptr</span>(pointer __p) <span class="keyword">noexcept</span> : _M_t(__p) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指针__p和自定义析构器__d构造一个unique_ptr对象</span></span><br><span class="line"><span class="built_in">unique_ptr</span>(pointer __p,</span><br><span class="line">    <span class="keyword">typename</span> conditional&lt;is_reference&lt;deleter_type&gt;::value,</span><br><span class="line">      deleter_type, <span class="type">const</span> deleter_type&amp;&gt;::type __d) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__p, __d) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Disable copy from lvalue.不允许复制，体现专属所有权语义</span></span><br><span class="line"><span class="comment">// 使用了C++11特性delete</span></span><br><span class="line"><span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move constructor.体现专属所有权语义和只移型别</span></span><br><span class="line"><span class="comment">// 只允许使用移动拷贝构造函数</span></span><br><span class="line"><span class="comment">// 如果复制一个unique_ptr对象，会将源unique_ptr对象管理的资源release掉</span></span><br><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__u.<span class="built_in">release</span>(), std::forward&lt;deleter_type&gt;(__u.<span class="built_in">get_deleter</span>())) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个也是移动拷贝构造函数</span></span><br><span class="line"><span class="comment">// 只是使用的类型是可以隐式转换的其他unique_ptr对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep, <span class="keyword">typename</span> = _Require&lt;</span><br><span class="line">         __safe_conversion_up&lt;_Up, _Ep&gt;,</span><br><span class="line">   <span class="keyword">typename</span> conditional&lt;is_reference&lt;_Dp&gt;::value,</span><br><span class="line">      is_same&lt;_Ep, _Dp&gt;,</span><br><span class="line">      is_convertible&lt;_Ep, _Dp&gt;&gt;::type&gt;&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__u.<span class="built_in">release</span>(), std::forward&lt;_Ep&gt;(__u.<span class="built_in">get_deleter</span>()))</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assignment，也可以说明是专属所有权语义和只移型别</span></span><br><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// __u.release()释放并返回源unique_ptr对象管理的资源</span></span><br><span class="line">    <span class="comment">// reset是将__u.release()返回的资源赋给目标（当前）unique_ptr对象</span></span><br><span class="line">    <span class="built_in">reset</span>(__u.<span class="built_in">release</span>());</span><br><span class="line">    <span class="built_in">get_deleter</span>() = std::forward&lt;deleter_type&gt;(__u.<span class="built_in">get_deleter</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数，调用析构器析构掉管理的资源，并将__ptr指向nullptr</span></span><br><span class="line">~<span class="built_in">unique_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; __ptr = _M_t._M_ptr();</span><br><span class="line">    <span class="keyword">if</span> (__ptr != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">get_deleter</span>()(__ptr);</span><br><span class="line">    __ptr = <span class="built_in">pointer</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get_deleter()(__ptr);的解读</span></span><br><span class="line"><span class="comment">// get_deleter()返回的是析构器，默认的析构器为struct default_delete&lt;_Tp&gt;</span></span><br><span class="line"><span class="comment">// struct default_delete&lt;_Tp&gt;有一个operator()操作符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp* __ptr)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> __ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所以get_deleter()(__ptr);实际上就是delete __ptr;</span></span><br></pre></td></tr></table></figure>

<h2 id="3、成员函数"><a href="#3、成员函数" class="headerlink" title="3、成员函数"></a>3、成员函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以像raw pointer一样，解引用</span></span><br><span class="line"><span class="keyword">typename</span> add_lvalue_reference&lt;element_type&gt;::type <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    __glibcxx_assert(<span class="built_in">get</span>() != <span class="built_in">pointer</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像raw pointer一样获取保存的指针，调用get方法</span></span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    _GLIBCXX_DEBUG_PEDASSERT(<span class="built_in">get</span>() != <span class="built_in">pointer</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> _M_t._M_ptr(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放对所管理资源的所有权</span></span><br><span class="line"><span class="function">pointer <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pointer __p = <span class="built_in">get</span>();</span><br><span class="line">    _M_t._M_ptr() = <span class="built_in">pointer</span>();</span><br><span class="line">    <span class="keyword">return</span> __p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置所管理的资源</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(pointer __p = pointer())</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(_M_t._M_ptr(), __p);</span><br><span class="line">    <span class="keyword">if</span> (__p != <span class="built_in">pointer</span>() <span class="built_in">get_deleter</span>()(__p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、unique-ptr的使用"><a href="#4、unique-ptr的使用" class="headerlink" title="4、unique_ptr的使用"></a>4、unique_ptr的使用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Investment</span> &#123;&#125;; <span class="comment">// 待管理对象</span></span><br><span class="line"><span class="comment">// 默认的析构器struct default_delete&lt;_Tp&gt;实际上是一个仿函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们就可以定义一个lambd作为析构器</span></span><br><span class="line"><span class="keyword">auto</span> delInvmt = [](Investment* pInvestment)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">makeLogEntry</span>(pInvestment); <span class="comment">// 做一些删除前的工作</span></span><br><span class="line">                    <span class="keyword">delete</span> pInvestment;</span><br><span class="line">                &#125;;</span><br><span class="line"><span class="comment">// 使用decltype推到出自定义析构器的类型</span></span><br><span class="line"><span class="function">unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmt)</span>&gt; <span class="title">pInv</span><span class="params">((<span class="keyword">new</span> Investment), delInvmt)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果要自定义析构器，就必须使用构造函数，而无法通过C++14提供的make_unique函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Investment</span></span><br><span class="line">&#123;</span><br><span class="line">  ~<span class="built_in">Investment</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;called ~Investment()...&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> ivmt = [](Investment* pInvestment)</span><br><span class="line">        &#123;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;user-defined delete...&quot;</span> &lt;&lt; endl;</span><br><span class="line">          <span class="keyword">delete</span> pInvestment;</span><br><span class="line">        &#125;;</span><br><span class="line">  <span class="comment">// 包在括号中，方便观察结果</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(ivmt)</span>&gt; <span class="title">pInvestment</span><span class="params">((<span class="keyword">new</span> Investment), ivmt)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">user-defined <span class="keyword">delete</span>...</span><br><span class="line">called ~<span class="built_in">Investment</span>()...</span><br></pre></td></tr></table></figure>

<p>另外<code>unique_ptr</code>不允许以赋值语法将一个<code>raw pointer</code>当作初值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unipue_ptr&lt;<span class="type">int</span>&gt; pInt = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>); <span class="comment">// error</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pInt</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">2</span>))</span></span>;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>不能使用普通的拷贝或者赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pInt1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">2</span>))</span></span>; <span class="comment">// pInt1现在为左值</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pInt2</span><span class="params">(pInt1)</span></span>;      <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要使用移动语义，使用move将左值转为右值</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pInt2</span><span class="params">(std::move(pInt1))</span></span>;</span><br><span class="line"></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; pInt2;</span><br><span class="line">pInt2 = pInt1; <span class="comment">// error</span></span><br><span class="line">pInt2 = std::<span class="built_in">move</span>(pInt1);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面试</category>
        <category>零散</category>
      </categories>
  </entry>
  <entry>
    <title>C/C++</title>
    <url>/2024/04/07/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/C&amp;C++/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h2 id="一、C-C"><a href="#一、C-C" class="headerlink" title="一、C&#x2F;C++"></a>一、C&#x2F;C++</h2><h3 id="1、在main执行之前和之后执行的代码可能是什么？"><a href="#1、在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="1、在main执行之前和之后执行的代码可能是什么？"></a>1、在main执行之前和之后执行的代码可能是什么？</h3><p><strong>main函数执行之前</strong>，主要就是初始化系统相关资源：</p>
<ul>
<li>设置栈指针</li>
<li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li>
<li>将未初始化部分的全局变量赋初值：数值型<code>short</code>，<code>int</code>，<code>long</code>等为<code>0</code>，<code>bool</code>为<code>FALSE</code>，指针为<code>NULL</code>等等，即<code>.bss</code>段的内容</li>
<li>全局对象初始化，在<code>main</code>之前调用构造函数，这是可能会执行前的一些代码</li>
<li>将main函数的参数<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li>
<li><code>__attribute__((constructor))</code></li>
</ul>
<p><strong>main函数执行之后</strong>：</p>
<ul>
<li>全局对象的析构函数会在main函数之后执行；</li>
<li>可以用 <strong><code>atexit</code></strong> 注册一个函数，它会在main 之后执行;</li>
<li><code>__attribute__((destructor))</code></li>
</ul>
<h3 id="2、如何看待-C-和-C-的关系？"><a href="#2、如何看待-C-和-C-的关系？" class="headerlink" title="2、如何看待 C++ 和 C 的关系？"></a>2、如何看待 C++ 和 C 的关系？</h3><p>C++最初只是在C的基础上增加了面向对象的特性，后来随着C++的发展，其灵活性不断增加，现在C++已经成为了一个语言联邦，他包含了C语言，但也延伸出许多其他特性。<br>(1)面向对象：C++包含封装、继承、多态的特性；<br>(2)C++支持泛型编程；<br>(3)C++包含了STL部分。</p>
<h3 id="3、结构体和联合体"><a href="#3、结构体和联合体" class="headerlink" title="3、结构体和联合体"></a>3、结构体和联合体</h3><p>(1)结构体(Struct)</p>
<ol>
<li><strong>存储</strong>：结构体可以包含多个不同类型的数据成员，每个成员各自独立拥有内存空间。</li>
<li><strong>内存占用</strong>：结构体的总大小至少等于所有成员大小的总和(还需要考虑对齐)。</li>
<li><strong>用途</strong>：常用于存储具有逻辑关系但数据类型不同的数据集合。</li>
<li><strong>访问</strong>：每个成员都可以同时被独立访问，并且对一个成员的修改不会影响到其他成员。</li>
</ol>
<p>(2)联合体(Union)</p>
<ol>
<li><strong>存储</strong>：联合体的所有成员共享同一块内存区域。</li>
<li><strong>内存占用</strong>：联合体的大小等于其最大成员的大小。</li>
<li><strong>用途</strong>：常用于节省空间，或用于实现对同一内存区域的不同解释(例如，可以存储一个整数和一个浮点数，但只能使用其中一个值)。</li>
<li><strong>访问</strong>：对联合体中的一个成员赋值可能会影响到其他成员的值(因为内存共享)。</li>
</ol>
<h3 id="4、平时用哪个版本的C-？为什么用-C-11，说一下"><a href="#4、平时用哪个版本的C-？为什么用-C-11，说一下" class="headerlink" title="4、平时用哪个版本的C++？为什么用 C++11，说一下"></a>4、平时用哪个版本的C++？为什么用 C++11，说一下</h3><p>  （从三个方面答，线程支持，泛化编程，简化使用）</p>
<h3 id="5、面向对象设计的主要的原则"><a href="#5、面向对象设计的主要的原则" class="headerlink" title="5、面向对象设计的主要的原则"></a>5、面向对象设计的主要的原则</h3><ol>
<li><strong>依赖倒置原则(DIP)：</strong></li>
</ol>
<p>⾼层模块(稳定)不应该依赖于底层模式(变化)，⼆者都应该依赖于抽象。抽象(稳定)不应该依赖于实现细节(变化)，实现细节应该依赖于抽象(稳定)。(所说的依赖都是编译时依赖。A 依赖 B，意味着 A 编译的时候 B 需要存在 A 才能编译通过)</p>
<ol start="2">
<li><strong>开放封闭原则(OCP):</strong></li>
</ol>
<p>对扩展开放，对更改封闭。(尽可能地去扩展，而不要修改)类模块应该是可扩展的，但是不可修改。</p>
<ol start="3">
<li><strong>单⼀职责原则：</strong></li>
</ol>
<p>⼀个类应该仅有⼀个引起它变化的原因，变化的方向隐含着类的责任。</p>
<ol start="4">
<li><strong>Liskov 替换原则：</strong></li>
</ol>
<p>子类必须能够替换他们的基类(is-a)。</p>
<ol start="5">
<li><strong>接口隔离原则：</strong></li>
</ol>
<p>不应该强迫客户依赖它们不用的方法。接口应该小而完备。</p>
<ol start="6">
<li><strong>优先使用对象组合，而不是使用类继承：</strong></li>
</ol>
<p>类继承通常为白箱复用，对象组合通常为黑箱复用。继承在某种程度上破坏了封装性，子类父类的耦合度⾼。而对象组合则只要求被组合的对象具有良好的外部接口，耦合度相对更低。</p>
<ol start="7">
<li><strong>封装变化点</strong></li>
</ol>
<p>使用封装来创建对象之间的分界层，让设计者在⼀侧进行修改，而不会对另⼀侧产生不良的影响，从而实现层次的直接耦合。</p>
<ol start="8">
<li><strong>针对接口编程，而不是针对实现编程</strong></li>
</ol>
<p>不将变量类型声明为某个特定的具体类，而是声明为某个接口。客户无需获知对象的具体类型，而是只需要知道对象所具有的接口。</p>
<h3 id="6、面向对象的三大特性，并举例说明"><a href="#6、面向对象的三大特性，并举例说明" class="headerlink" title="6、面向对象的三大特性，并举例说明"></a>6、<strong>面向对象的三大特性，并举例说明</strong></h3><p>C++ 面向对象的三大特征是：封装、继承、多态。</p>
<ol>
<li><p><strong>所谓封装</strong></p>
<p>就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让信任的类或者对象操作，对不可信的进行信息隐藏。⼀个类就是⼀个封装了数据以及操作这些数据的代码的逻辑实体。</p>
<p>在⼀个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中⽆关的部分意外的改变或错误的使用了对象的私有部分。</p>
</li>
<li><p><strong>所谓继承</strong></p>
<p>是指可以让某个类型的对象获得另⼀个类型的对象的属性的方法。它⽀持按级分类的概念。继承是指这样⼀种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p>
<p>通过继承创建的新类称为“子类”或者“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从⼀般到特殊的过程。要实现继承，可以通过“继承”和“组合”来实现。</p>
<p>继承概念的实现方式有两类：</p>
<p>(1)实现继承：实现继承是指直接使用于基类的属性和方法而无需额外编码的能力；</p>
<p>(2)接口继承：接口继承是指仅使用属性和方法的名称、但是子类必需提供实现的能力。</p>
</li>
<li><p><strong>所谓多态</strong></p>
<p>就是向不同的对象发送同⼀个消息，不同对象在接收时会产生不同的行为(即方法)。即⼀个接口，可以实现多种方法。多态与非多态的实质区别就是函数地址是早绑定还是晚绑定的。</p>
<p>如果函数的调用在编译器编译期间就可以确定函数的调用地址并产生代码，则是静态的，即地址早绑定。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。</p>
</li>
</ol>
<h2 id="二、智能指针相关"><a href="#二、智能指针相关" class="headerlink" title="二、智能指针相关"></a>二、智能指针相关</h2><h3 id="7、野指针是什么？"><a href="#7、野指针是什么？" class="headerlink" title="7、野指针是什么？"></a>7、野指针是什么？</h3><p>野指针是指向未知内存位置的指针。在编程中，特别是在使用C或C++这类允许直接内存操作的语言时，野指针问题是常见的错误来源之一。野指针的出现通常是由于以下几种情况：</p>
<ol>
<li><strong>未初始化的指针</strong>：声明指针变量但未给其赋予一个明确的初始地址。</li>
<li><strong>已释放的内存</strong>：指针指向的内存通过<code>free</code>或<code>delete</code>被释放，但指针没有被置为<code>NULL</code>，之后再次使用这个指针时，它指向的是已经回收的内存。</li>
<li><strong>越界的指针</strong>：指针超出了其原本指向的数据结构的边界。</li>
</ol>
<h3 id="8、讲一下什么是智能指针？"><a href="#8、讲一下什么是智能指针？" class="headerlink" title="8、讲一下什么是智能指针？"></a>8、讲一下什么是智能指针？</h3><p>智能指针是对裸指针的封装，其实质上是一个类，在离开类的作用范围后会自动调用析构函数释放资源，因此避免了程序员手动操作时忘记释放资源导致的内存泄漏问题。<br>智能指针包含4类：<br>(1)<strong>auto_ptr</strong>：在C++11中已经被废弃使用。它提供独占所有权，但没有复制语义，存在潜在的危险，例如当它被复制后原始指针可能被意外释放。<br>(2)<strong>unique_ptr</strong>：实现了对资源的独占访问，同一时刻只能有一个指针对资源进行访问。<strong>大小通常为一个指针的大小(在大多数系统上为8字节)。</strong><br>(3)<strong>shared_ptr</strong>：当有多个对象需要共享资源时，则使用shared_ptr。其内部维护了一个引用计数器，当引用计数减少为0时调用delete释放资源。<strong>大小通常是两个指针的大小(在大多数系统上为16字节)。</strong><br>当存在下列情况时会使得引用计数增加：1)新建一个shared_ptr指向对象；2)拷贝构造函数复制一个shared_ptr；3)复制操作将一个shared_ptr复制给另一个shared_ptr。<br>当存在下列操作时会使得引用计数减少：1)当一个shared_ptr被销毁时，如离开作用域，或调用了析构函数；2)当一个shared_ptr不再指向某个资源，如调用reset方法。<br>(4)<strong>weak_ptr</strong>：指向一个shared_ptr对象，并不会增加其引用计数，而只是提供一种访问方式。可以解决shared_ptr中存在的循环引用问题。<strong>大小通常是两个指针的大小(在大多数系统上为16字节)。</strong></p>
<h3 id="9、weak-ptr-如何获得-shared-ptr？"><a href="#9、weak-ptr-如何获得-shared-ptr？" class="headerlink" title="9、weak_ptr 如何获得 shared_ptr？"></a>9、weak_ptr 如何获得 shared_ptr？</h3><p>使用 <code>std::weak_ptr</code> 的成员函数 <code>lock()</code>。这个函数尝试从 <code>std::weak_ptr</code> 创建一个 <code>std::shared_ptr</code> 实例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">  std::weak_ptr&lt;<span class="type">int</span>&gt; wp = sp;</span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; sp2 = wp.<span class="built_in">lock</span>();</span><br><span class="line">  </span><br><span class="line">  sp.<span class="built_in">reset</span>();</span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; sp3 = wp.<span class="built_in">lock</span>();  <span class="comment">// sp3仍有效</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10、循环引用是如何发生的？如何解决？"><a href="#10、循环引用是如何发生的？如何解决？" class="headerlink" title="10、循环引用是如何发生的？如何解决？"></a>10、循环引用是如何发生的？如何解决？</h3><p>当多个 shared_ptr 对象互相引用，或是在某些比较复杂的数据结构中存在多条引用路径时，可能存在循环引用问题，导致资源无法被释放。此时就可以使用 weak_ptr 来打破循环，因为 weak_ptr 不会增加引用计数。</p>
<blockquote>
<p>详细背诵 weak_ptr 和 shared_ptr 的内部实现。</p>
</blockquote>
<h3 id="11、shared-ptr-是线程安全的吗？多线程使用时需要注意什么问题？"><a href="#11、shared-ptr-是线程安全的吗？多线程使用时需要注意什么问题？" class="headerlink" title="11、shared_ptr 是线程安全的吗？多线程使用时需要注意什么问题？"></a>11、shared_ptr 是线程安全的吗？多线程使用时需要注意什么问题？</h3><p><code>shared_ptr</code>的引用计数是线程安全的，即引用计数的增加和减少操作是原子操作，保证了多个线程能够安全地共享同一个<code>shared_ptr</code>对象。但是，<code>shared_ptr</code>本身并不对其所管理的对象提供线程安全性。如果多个线程需要同时访问或修改共享对象，用户需要自己管理对象的同步(例如使用<code>mutex</code>)。</p>
<h3 id="12、引用计数的线程安全性怎么实现的？"><a href="#12、引用计数的线程安全性怎么实现的？" class="headerlink" title="12、引用计数的线程安全性怎么实现的？"></a>12、引用计数的线程安全性怎么实现的？</h3><p>为了保证引用计数在多线程中的线程安全，<code>shared_ptr</code> 通常采用原子操作来修改引用计数。原子操作是不可分割的，这意味着在任何时间点上，只有一个线程能够修改引用计数。这样可以避免在并发环境中发生竞争条件，确保引用计数的正确性不会因为多线程访问而被破坏。</p>
<p><strong>对于增加引用计数来说，只需要通过简单的原子递增操作</strong>。因为其本质上是一种写操作，其主要目的是确保引用计数值的一致性，并不涉及对共享对象的状态读取或修改，所以递增操作不需要立刻在多个线程之间可见，而是只需要保证在计数值递增时的原子性。</p>
<p><strong>对于减少引用计数来说，则需要利用到内存同步事件和内存屏障，来结合原子操作减少引用计数。</strong>因为当引用计数减少到<code>0</code>时，需要执行资源释放操作，涉及到对共享对象状态的修改和删除，因此需要保证内存的正确同步和可见性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加引用计数</span></span><br><span class="line"><span class="type">void</span> _M_add_ref_copy() &#123;</span><br><span class="line">    <span class="comment">// 原子操作</span></span><br><span class="line">    __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count， <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减少引用计数</span></span><br><span class="line"><span class="type">void</span> _M_release() &#123;</span><br><span class="line">    <span class="comment">// 内存同步事件，与数据竞赛检测工具(如ThreadSanitizer)协同工作，确保内存操作的可见性</span></span><br><span class="line">    _GLIBXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子操作，减少引用计数，并检查是否是最后一个引用</span></span><br><span class="line">    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count， <span class="number">-1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 另一个内存同步事件，通知数据竞赛检测工具此时的引用计数减少操作已经完成</span></span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);</span><br><span class="line">        _M_dispose();  <span class="comment">// 释放对象资源</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保在 _M_dispose() 和 _M_destroy() 之间有一个内存屏障，</span></span><br><span class="line">        <span class="comment">// 以确保所有 _M_dispose() 的效果对调用 _M_destroy() 的线程可见</span></span><br><span class="line">        <span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barries) &#123;</span><br><span class="line">            __atomic_thread_fence (__ATOMIC_ACQ_REL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减少弱引用计数，并检查是否是最后一个弱引用</span></span><br><span class="line">        <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count， <span class="number">-1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 另一个内存同步事件，通知数据竞赛检测工具此时的弱引用计数减少操作已经完成</span></span><br><span class="line">            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">            _M_destroy();  <span class="comment">// 释放控制块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13、引用计数是普通成员变量还是指针变量？"><a href="#13、引用计数是普通成员变量还是指针变量？" class="headerlink" title="13、引用计数是普通成员变量还是指针变量？"></a>13、引用计数是普通成员变量还是指针变量？</h3><p>引用计数是智能指针的成员变量，而不是指针变量。在<code>shared_ptr</code>等智能指针中，引用计数是一个普通的整数型成员变量，用于跟踪当前有多少个指针共享了同一个对象。</p>
<h3 id="14、如果有一个场景需要用到线程安全的-shared-ptr-，一般你会怎么做？"><a href="#14、如果有一个场景需要用到线程安全的-shared-ptr-，一般你会怎么做？" class="headerlink" title="14、如果有一个场景需要用到线程安全的 shared_ptr ，一般你会怎么做？"></a>14、如果有一个场景需要用到线程安全的 shared_ptr ，一般你会怎么做？</h3><p>如果需要在多线程环境下使用线程安全的 shared_ptr，通常会使用 std::atomic 或者 std::mutex 来保护对 shared_ptr 的访问。</p>
<h3 id="15、以传引用的形式传递-shared-ptr-有什么问题？"><a href="#15、以传引用的形式传递-shared-ptr-有什么问题？" class="headerlink" title="15、以传引用的形式传递 shared_ptr 有什么问题？"></a>15、以传引用的形式传递 shared_ptr 有什么问题？</h3><p>将<code>shared_ptr</code>以引用形式传递不会增加对象的引用计数，这可能会导致以下问题：</p>
<ol>
<li>若函数内部存储或复制了这个引用，而在函数外部原<code>shared_ptr</code>已经被销毁，那么这个存储的引用将成为悬空引用，导致未定义的行为。</li>
<li>函数调用者可能会期望传递的<code>shared_ptr</code>对象会因函数调用而共享其所有权，但实际上却没有发生。</li>
</ol>
<h3 id="16、通过-make-shared-构造，与先-new-再用裸指针构造-shared-ptr-相比有什么好处？"><a href="#16、通过-make-shared-构造，与先-new-再用裸指针构造-shared-ptr-相比有什么好处？" class="headerlink" title="16、通过 make_shared 构造，与先 new 再用裸指针构造 shared_ptr 相比有什么好处？"></a>16、通过 make_shared 构造，与先 new 再用裸指针构造 shared_ptr 相比有什么好处？</h3><p>使用<code>make_shared</code>构造<code>shared_ptr</code>有以下几个好处：</p>
<ul>
<li><strong>性能优化</strong>：<code>make_shared</code>在单一的内存分配中同时分配了对象和控制块，减少了内存分配次数。而先<code>new</code>再用裸指针构造<code>shared_ptr</code>会进行两次内存分配，一次给对象，一次给控制块。</li>
<li><strong>安全性</strong>：<code>make_shared</code>避免了内存泄漏的风险。如果在<code>shared_ptr</code>构造过程中抛出异常，使用裸指针的方式可能导致内存泄漏，而<code>make_shared</code>会确保所有资源都被正确管理。</li>
<li><strong>代码简洁</strong>：<code>make_shared</code>使代码更简洁，更易读。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// make_shared</span></span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; sp1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;value = &quot;</span> &lt;&lt; *sp1 &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;use count = &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 先new再构造</span></span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;value = &quot;</span> &lt;&lt; *sp2 &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;use count = &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17、如果构造函数传入同一裸指针构造两个-shared-ptr-对象，会发生什么现象？"><a href="#17、如果构造函数传入同一裸指针构造两个-shared-ptr-对象，会发生什么现象？" class="headerlink" title="17、如果构造函数传入同一裸指针构造两个 shared_ptr 对象，会发生什么现象？"></a>17、如果构造函数传入同一裸指针构造两个 shared_ptr 对象，会发生什么现象？</h3><p>虽然 <code>sp1</code> 和 <code>sp2</code> 都指向同一个 <code>int</code> 对象，但是它们在构造时并不知道彼此存在，因此各自的引用计数是独立计算的。当程序结束时，会首先销毁 <code>sp2</code>，此时引用计数减少为 <code>0</code>，释放原裸指针。接着，当销毁 <code>sp1</code> 时，由于引用计数已经为 <code>0</code>，再次尝试释放原裸指针，导致错误发生。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *p1 = &amp;x;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value = &quot;</span> &lt;&lt; *sp1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count = &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value = &quot;</span> &lt;&lt; *sp2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count = &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">value = 1</span><br><span class="line">use count = 1</span><br><span class="line">value = 1</span><br><span class="line">use count = 1</span><br><span class="line">munmap_chunk(): invalid pointer</span><br></pre></td></tr></table></figure>

<h3 id="18、还是上面的问题，你觉得对于所谓的智能指针，为什么会出现这样的现象？"><a href="#18、还是上面的问题，你觉得对于所谓的智能指针，为什么会出现这样的现象？" class="headerlink" title="18、还是上面的问题，你觉得对于所谓的智能指针，为什么会出现这样的现象？"></a>18、还是上面的问题，你觉得对于所谓的智能指针，为什么会出现这样的现象？</h3><p>两个 <code>shared_ptr</code> 对象 <code>sp1</code> 和 <code>sp2</code> 分别使用相同的裸指针 <code>p1</code> 进行构造。智能指针在构造时会管理裸指针所指向的内存，并跟踪这段内存的引用计数。但是，<code>shared_ptr</code> 并不会检查裸指针是否已经由其他 <code>shared_ptr</code> 对象管理，它们只会简单地增加引用计数。</p>
<p>因此，当 <code>sp1</code> 和 <code>sp2</code> 分别使用相同的裸指针构造时，它们实际上管理的是同一块内存，引用计数的增加会导致该块内存的引用计数变为 2。这就解释了为什么 <code>use_count</code> 为 1 而不是 2。</p>
<h3 id="19、很多人说到-weak-ptr-就会说是为了解决循环引用，你觉得这是关键的因素吗？"><a href="#19、很多人说到-weak-ptr-就会说是为了解决循环引用，你觉得这是关键的因素吗？" class="headerlink" title="19、很多人说到 weak_ptr 就会说是为了解决循环引用，你觉得这是关键的因素吗？"></a>19、很多人说到 weak_ptr 就会说是为了解决循环引用，你觉得这是关键的因素吗？</h3><p><code>std::weak_ptr</code> 的主要作用是提供一种非拥有性的智能指针，用于解决共享指针的循环引用问题，避免内存泄漏和资源泄露。它不会增加对象的引用计数，也不会影响对象的生命周期，因此适用于表示临时性的对象引用或者避免循环引用的情况。</p>
<p>除了解决循环引用之外，<code>std::weak_ptr</code> 还具有其他用途，例如：</p>
<ol>
<li><strong>观察者模式(Observer Pattern)：</strong> <code>std::weak_ptr</code> 可用于实现观察者模式，其中观察者持有被观察者对象的弱引用，以避免循环引用和对象生命周期管理的问题。</li>
<li><strong>缓存：</strong> 在缓存系统中，可以使用 <code>std::weak_ptr</code> 来保存对象的缓存项，以避免对对象的强引用导致缓存项无法被释放。</li>
<li><strong>延迟初始化：</strong> <code>std::weak_ptr</code> 可用于实现延迟初始化(Lazy Initialization)，只有在需要时才创建对象，以提高性能和资源利用率。</li>
</ol>
<h3 id="20、如果传给-shared-ptr-一个引用，那么引用计数会不会加1？"><a href="#20、如果传给-shared-ptr-一个引用，那么引用计数会不会加1？" class="headerlink" title="20、如果传给 shared_ptr 一个引用，那么引用计数会不会加1？"></a>20、如果传给 shared_ptr 一个引用，那么引用计数会不会加1？</h3><p>只有在<code>std::shared_ptr</code>发生<strong>值传递</strong>时，计数才会增加，而在<strong>传递引用(<code>&amp;</code>)类型</strong>的 shared_ptr 的时，计数不会增加。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printUseCount</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;<span class="type">int</span>&gt;&amp; sp， <span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; use_count: &quot;</span> &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传copy</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">passByVal</span><span class="params">(std::shared_ptr&lt;<span class="type">int</span>&gt; sp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printUseCount</span>(sp， <span class="string">&quot;sp (pass by value)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">passByRef</span><span class="params">(std::shared_ptr&lt;<span class="type">int</span>&gt;&amp; sp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printUseCount</span>(sp， <span class="string">&quot;sp (pass by reference)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="built_in">printUseCount</span>(sp1， <span class="string">&quot;sp1 (initial)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">passByVal</span>(sp1);</span><br><span class="line">    <span class="built_in">printUseCount</span>(sp1， <span class="string">&quot;sp1 (after passByValue)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">passByRef</span>(sp1);</span><br><span class="line">    <span class="built_in">printUseCount</span>(sp1， <span class="string">&quot;sp1 (after passByReference)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sp1 (initial) use_count: 1</span><br><span class="line">sp (pass by value) use_count: 2</span><br><span class="line">sp1 (after passByValue) use_count: 1</span><br><span class="line">sp (pass by reference) use_count: 1</span><br><span class="line">sp1 (after passByReference) use_count: 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释<code>sp1 (after passByValue) use_count: 1</code>：</strong></p>
<p>在使用 <code>std::shared_ptr</code> 时，当一个函数以值传递(copy)的方式接收一个 <code>std::shared_ptr</code>，该函数内部会创建一个新的 <code>std::shared_ptr</code> 实例，并将引用计数增加。当函数返回时，局部的 <code>std::shared_ptr</code> 对象会被销毁，其引用计数会随之减少。</p>
</blockquote>
<h3 id="21、unique-ptr-主要为了解决什么问题？"><a href="#21、unique-ptr-主要为了解决什么问题？" class="headerlink" title="21、unique_ptr 主要为了解决什么问题？"></a>21、unique_ptr 主要为了解决什么问题？</h3><p><code>unique_ptr</code>主要用于解决以下问题：</p>
<ul>
<li><strong>独占所有权</strong>：<code>unique_ptr</code>保证一个指针在任一时刻只有一个拥有者，避免了多重删除(double delete)的问题。</li>
<li><strong>自动释放资源</strong>：当<code>unique_ptr</code>超出其作用域时，会自动释放其管理的资源，防止内存泄漏。</li>
<li><strong>移动语义</strong>：<code>unique_ptr</code>可以移动而不是复制，这使得所有权可以安全地从一个对象转移到另一个对象。</li>
</ul>
<h3 id="22、unique-ptr-指向一个对象，普通指针可以指向那个对象吗？"><a href="#22、unique-ptr-指向一个对象，普通指针可以指向那个对象吗？" class="headerlink" title="22、unique_ptr 指向一个对象，普通指针可以指向那个对象吗？"></a>22、unique_ptr 指向一个对象，普通指针可以指向那个对象吗？</h3><p>是的，<code>unique_ptr</code>指向一个对象时，普通指针可以指向那个对象。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span>* raw_ptr = uptr.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *raw_ptr &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>raw_ptr</code>指向了<code>unique_ptr</code>管理的对象。不过需要注意的是，普通指针指向<code>unique_ptr</code>管理的对象时，不能改变或释放对象的内存，否则会破坏<code>unique_ptr</code>的内存管理，导致未定义行为。</p>
<blockquote>
<p> 注意这样做并未破坏unique_ptr的独占性，理由如下：</p>
</blockquote>
<p>虽然<code>unique_ptr</code>设计为独占所有权的智能指针，但这并不意味着其他普通指针不能指向它管理的对象。<code>unique_ptr</code>的独占所有权意味着它是唯一一个负责管理和释放该对象的智能指针。换句话说，没有其他<code>unique_ptr</code>或<code>shared_ptr</code>可以共享这个对象的所有权。</p>
<p>然而，使用裸指针指向<code>unique_ptr</code>管理的对象是允许的，并且在某些情况下是有用的。例如，当需要暂时访问对象而不需要改变其生命周期时，裸指针是一个方便的工具。</p>
<p>需要注意以下几点来确保安全性和不破坏<code>unique_ptr</code>的独占性：</p>
<ol>
<li><strong>只读访问</strong>：使用裸指针访问<code>unique_ptr</code>管理的对象时，应当只进行只读操作，避免对对象进行任何可能改变其状态的操作。</li>
<li><strong>不改变生命周期</strong>：绝对不能通过裸指针删除对象或试图手动管理其生命周期。对象的生命周期完全由<code>unique_ptr</code>管理。</li>
<li><strong>短期使用</strong>：裸指针的使用应当是短期的，避免长期持有裸指针，以防<code>unique_ptr</code>被销毁后裸指针成为悬空指针。</li>
</ol>
<h3 id="23、指针解引用性能"><a href="#23、指针解引用性能" class="headerlink" title="23、指针解引用性能"></a>23、指针解引用性能</h3><p>智能指针的解引用性能基本与原生指针相同，因为解引用操作只需访问内存地址。</p>
<p>然而，智能指针在生命周期管理上有额外的开销。例如，<code>std::shared_ptr</code>在每次构造、赋值和销毁时需要更新引用计数，这比<code>std::unique_ptr</code>和原生指针的开销要大。</p>
<h2 id="三、变量-关键字"><a href="#三、变量-关键字" class="headerlink" title="三、变量&#x2F;关键字"></a>三、变量&#x2F;关键字</h2><h3 id="24、string-的-size-类型为什么是-string-size-t-而不是-int？"><a href="#24、string-的-size-类型为什么是-string-size-t-而不是-int？" class="headerlink" title="24、string 的 size 类型为什么是 string::size_t 而不是 int？"></a>24、string 的 size 类型为什么是 string::size_t 而不是 int？</h3><p>使用 <code>string::size_t</code> 而不是 <code>int</code> 有以下几个好处：</p>
<ol>
<li><strong>能够表示更大的字符串：</strong> 无符号整数类型 <code>size_t</code> 可以容纳比 <code>int</code> 更大的值，这对于处理非常大的字符串是必要的。</li>
<li><strong>提高可移植性：</strong> 使用 <code>string::size_t</code> 可以确保代码在不同的平台上具有相同的行为，因为 <code>size_t</code> 的大小会根据平台而变化，而不是固定的。</li>
<li><strong>避免符号问题：</strong> <code>size_t</code> 是无符号类型，避免了符号整数的问题，如溢出等。</li>
</ol>
<h3 id="25、介绍一下-static-和-const？"><a href="#25、介绍一下-static-和-const？" class="headerlink" title="25、介绍一下 static 和 const？"></a>25、介绍一下 static 和 const？</h3><p><code>const</code>允许我们指定一个语义约束，告诉编译器某个变量不应该被修改。<strong>const可以用于修饰普通变量、函数、类等</strong>。比如在重载解引用操作符时，就可以用const来修饰，因为在解引用操作前后指针所指向的值是不应该被改变的。<br><code>static</code>则修改存储方式和可见范围。主要包含4类：<br>(1)静态成员变量：静态成员变量不属于类的任何一个对象，而只属于类本身，所有对象共享一个静态成员变量。<br>(2)静态成员函数：静态成员函数同理。<br>(3)静态局部变量：定义在函数内部，和普通局部变量不同，在函数整个运行期间只会初始化一次，即使函数被多次调用也是如此。<br>(4)静态全局变量：静态全局变量在某个源文件中被定义后则只能在该源文件中被使用，而不能在其他文件中使用，有助于封装和避免命名冲突。</p>
<h3 id="26、extern-关键字的作用？"><a href="#26、extern-关键字的作用？" class="headerlink" title="26、extern 关键字的作用？"></a>26、extern 关键字的作用？</h3><p><code>extern</code>关键字用于声明一个变量或函数，其定义可能在另一个文件或同一文件的不同位置。使用<code>extern</code>的主要目的是在多个文件之间共享变量或函数。</p>
<ol>
<li><strong>声明外部变量</strong>：<ul>
<li>当在多个源文件中使用同一个全局变量时，你可以在一个文件中不使用<code>extern</code>定义该变量，并在其他文件中使用<code>extern</code>关键字来声明它们。这告诉编译器变量在其他地方定义，避免了多重定义的错误。</li>
</ul>
</li>
<li><strong>声明外部函数</strong>：<ul>
<li>使用<code>extern</code>可以明确表示函数可以被其他文件调用。</li>
</ul>
</li>
<li><strong>链接不同编程语言</strong>：<ul>
<li>在C++中，<code>extern &quot;C&quot;</code>用于告诉C++编译器某个函数或变量应该以C语言的方式进行链接。</li>
</ul>
</li>
</ol>
<h3 id="27、extern-声明全局变量的内部实现是怎样的？"><a href="#27、extern-声明全局变量的内部实现是怎样的？" class="headerlink" title="27、extern 声明全局变量的内部实现是怎样的？"></a>27、extern 声明全局变量的内部实现是怎样的？</h3><p>被extern修饰的全局变量，在编译期不会分配空间，而是在链接的时候通过索引去别的文件中查找索引对应的地址。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404170950469.jpeg" alt="IMG_183F6F3B95EC-1"></p>
<h3 id="28、在-C-程序中调用被-C-编译器编译后的函数，为什么要加-extern-“C”？"><a href="#28、在-C-程序中调用被-C-编译器编译后的函数，为什么要加-extern-“C”？" class="headerlink" title="28、在 C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”？"></a>28、在 C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”？</h3><p>extern “C”是连接申明，被其修饰的变量和函数是按照类C的编译和连接规约来编译和连接，这样在类C的代码中就可以调用C++的函数or变量等。</p>
<p><strong>由于C++有重载的特性而C没有</strong>，因此函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：<code>void foo(int x，int y);</code>该函数被C编译器编译后在符号库中的名字为<code>_foo</code>，而C++编译器则会产生像<code>_foo_int_int</code>之类的名字。 因此，<strong>extern “C”这个声明的真实目的：解决名字匹配问题，实现C++与C的混合编程</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404170951735.jpeg" alt="IMG_EC64DA9B254B-1"></p>
<h3 id="29、explicit-关键字用在什么情况下？"><a href="#29、explicit-关键字用在什么情况下？" class="headerlink" title="29、explicit 关键字用在什么情况下？"></a>29、explicit 关键字用在什么情况下？</h3><p>explicit关键用于声明一个单参数的构造函数，阻止该构造函数隐式转换为该类的类型。</p>
<h3 id="30、inline-关键字遇到过吗？作用是什么？和-define-有什么区别？"><a href="#30、inline-关键字遇到过吗？作用是什么？和-define-有什么区别？" class="headerlink" title="30、inline 关键字遇到过吗？作用是什么？和 #define 有什么区别？"></a>30、inline 关键字遇到过吗？作用是什么？和 #define 有什么区别？</h3><p><code>inline</code>关键字作为函数定义的关键字，说明该函数是内联函数。内联函数会将代码块嵌入到每个调用该函数的地方，减少函数调用的开销，但增加了代码量。同时要注意inline只是对编译器的一个建议，真正能否内联还是要看编译器自己的判断。</p>
<p>C++17 引入了内联变量，允许在头文件中定义全局变量，而不会导致重复定义错误。使用 <code>inline</code> 关键字修饰的变量可以在多个翻译单元中定义，但会被视为同一个变量。</p>
<p><strong>和 #define 的区别在于：</strong></p>
<p>(1)宏定义，在预处理阶段进行文本替换，<code>inline</code>函数在编译时进行替换。</p>
<p>(2)<code>inline</code>有类型检查，相对于<code>#define</code>较安全。</p>
<h3 id="31、-define、const-和-constexpr-的区別和应用场景？"><a href="#31、-define、const-和-constexpr-的区別和应用场景？" class="headerlink" title="31、#define、const 和 constexpr 的区別和应用场景？"></a>31、#define、const 和 constexpr 的区別和应用场景？</h3><p>(1)<code>#define</code>是预处理指令，用于定义常量宏。它<strong>在预处理阶段将标识符替换为指定的文本</strong>。不包含类型检查。</p>
<p>(2)<code>const</code>用于定义类型安全的常量，<strong>在编译时被创建，并且会占用内存，可以在运行时被初始化</strong>。之所以说其是类型安全的，是因为声明为const的常量在编译期间会检查程序是否对其进行了修改，避免意外修改；同时会对其进行类型检查，因此是安全的。</p>
<p>(3)<code>constexpr</code>用于声明常量表达式，在编译时被求值。因此<strong>适用于在编译时期就能确定初始值，并且在整个程序生命周期内都不会改变的常量</strong>。</p>
<h3 id="32、简单说说-lambda-表达式？"><a href="#32、简单说说-lambda-表达式？" class="headerlink" title="32、简单说说 lambda 表达式？"></a>32、简单说说 lambda 表达式？</h3><p><code>Lambda</code> 表达式是 C++11 引入的一种新特性，允许在代码中<strong>定义匿名函数</strong>。Lambda 表达式提供了一种简洁的方式来创建内联函数，特别适用于需要短小函数的场景，如排序、自定义算法或回调函数等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda表达式的具体形式： [capture](parameter)-&gt;retrun_type&#123;body&#125;</span></span><br><span class="line"><span class="comment">// capture     要用到的外部变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="comment">// bool cmp(int a， int b) &#123; return a &gt; b;&#125;</span></span><br><span class="line"><span class="comment">// 可改写为：</span></span><br><span class="line"><span class="comment">// std::sort(arr， arr+len， [](int a， int b) &#123; return a &gt; b; &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> add_n              = [n](<span class="type">int</span> a) &#123; <span class="keyword">return</span> a + n; &#125;;</span><br><span class="line">    <span class="keyword">auto</span> add_and_modify_n   = [n](<span class="type">int</span> a) <span class="keyword">mutable</span> &#123; n += a; <span class="keyword">return</span> n;&#125;;  <span class="comment">// 只在lambda的内部生效，不会改变外部变量n的值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add_n(5): &quot;</span> &lt;&lt; <span class="built_in">add_n</span>(<span class="number">5</span>) &lt;&lt; std::endl;  <span class="comment">// 15</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add_and_modify_n(5): &quot;</span> &lt;&lt; <span class="built_in">add_and_modify_n</span>(<span class="number">5</span>) &lt;&lt; std::endl;  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;n: &quot;</span> &lt;&lt; n &lt;&lt; std::endl;  <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="33、使用-lambda-表达式，捕获局部变量时有什么规则？"><a href="#33、使用-lambda-表达式，捕获局部变量时有什么规则？" class="headerlink" title="33、使用 lambda 表达式，捕获局部变量时有什么规则？"></a>33、使用 lambda 表达式，捕获局部变量时有什么规则？</h3><p>Lambada表达式的捕获规则主要有：<strong>值捕获</strong>，<strong>引用捕获</strong>，<strong>隐式捕获</strong>和<strong>显示捕获</strong>。</p>
<ol>
<li><strong>值捕获</strong>：使用值捕获时，lambda 表达式会复制外部作用域的局部变量，并在 lambda 表达式内部使用它们的副本。这意味着捕获的变量在 lambda 表达式创建时就被复制，lambda 表达式内部的操作不会影响原始变量的值。</li>
<li><strong>引用捕获</strong>：使用引用捕获时，lambda 表达式会获取外部作用域的局部变量的引用。这意味着 lambda 表达式内部对变量的操作会影响到原始变量。</li>
<li><strong>隐式捕获</strong>：通过在捕获列表中使用 &#x3D; 或 &amp; 符号，可以实现隐式捕获。使用 &#x3D; 捕获外部作用域的所有变量的副本，而使用 &amp; 捕获所有变量的引用。</li>
<li><strong>显式捕获</strong>：在捕获列表中，可以指定要捕获的特定变量，并且可以同时使用值捕获和引用捕获。</li>
</ol>
<h3 id="34、virtual-和-override-的区别和应用场景？"><a href="#34、virtual-和-override-的区别和应用场景？" class="headerlink" title="34、virtual 和 override 的区别和应用场景？"></a>34、virtual 和 override 的区别和应用场景？</h3><p>(1)virtual 用于声明虚函数，即在基类中声明一个函数为虚函数，以便在派生类中进行覆盖或重写。</p>
<p>(2)override 用于显式地告诉编辑器，当前函数是基类中虚函数的重写版本。</p>
<h3 id="35、volatile-关键字的作用？应用场景如何？"><a href="#35、volatile-关键字的作用？应用场景如何？" class="headerlink" title="35、volatile 关键字的作用？应用场景如何？"></a>35、volatile 关键字的作用？应用场景如何？</h3><p>使用<code>volatile</code>关键字则提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，告诉编译器对该变量不做优化，而总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据，而且读取的数据立刻被保存。</p>
<p><code>volatile</code>有以下应用场景：</p>
<p><strong>(1)中断服务程序中修改的供其它程序检测的变量，需要加 volatile</strong></p>
<p>当变量在触发某中断程序后修改，而编译器判断主函数里面没有修改该变量，因此可能只执行一次从内存到某寄存器的读操作，而后每次只会从该寄存器中读取变量副本，使得中断程序的操作被短路。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span> (i) &#123; dosomething();&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Interrupt service routine. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ISR_2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">      i=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)多任务环境下各任务间共享的标志，应该加 volatile</strong></p>
<p>在本次线程内，当读取一个变量时，为提高存取速度，编译器优化时可能会先把变量读取到一个寄存器中，之后再取变量值时，就直接从寄存器中取值。当变量值在本线程里改变时，会同时把变量的新值copy到该寄存器中，以便保持一致。此时，当变量因其它线程改变了值时，该寄存器的值不会改变，从而造成应用程序读取的值和实际的变量值不一致。</p>
<p><strong>(3)存储器映射的硬件寄存器通常也要加 volatile，因为每次对它的读写都可能有不同意义</strong></p>
<p>例如，在做按键检测时是如下流程：</p>
<ul>
<li>设置 GPIO 对应的寄存器配置成输入模式；</li>
<li>不断地去访问 GPIO 电平标志寄存器(或者是一个寄存器的标志位)；</li>
<li>根据寄存器值的某个二进制位确定当前引脚电平</li>
</ul>
<p>硬件寄存器上的值的是和底层电路相关的，硬件寄存器的值会影响电路，电路也会反过来影响硬件寄存器的值。所以在这种情况下，编译器更不应该拷贝副本，而应该每次读写都从内存中读写，保证数据正确，声明成volatile可以防止出现数据出错问题。</p>
<p>假设要对一个设备进行初始化，此设备的某一个寄存器为 0xff800000：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  *output = (<span class="type">unsigned</span>  <span class="type">int</span> *)<span class="number">0xff800000</span>;<span class="comment">//定义一个IO端口；</span></span><br><span class="line"><span class="type">int</span>   <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> i;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; <span class="number">10</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">      *output = i;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为9，所以编译器最后给你编译编译的代码结果相当于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">      *output = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="36、sizeof-和-strlen-之间的区别是什么？"><a href="#36、sizeof-和-strlen-之间的区别是什么？" class="headerlink" title="36、sizeof 和 strlen 之间的区别是什么？"></a>36、sizeof 和 strlen 之间的区别是什么？</h3><p>(1)sizeof 是一个运算符而不是函数，用于获取指定类型或变量在内存中占用的字节数，在编译时进行计算，不会对实际的内存内容进行操作，返回类型是 <code>size_t</code>。</p>
<p>(2)strlen 是一个函数，用于获取以 null 结尾的 C 风格字符串的长度，即字符串中有效字符的数量，不包含结尾的null字符。在运行时进行遍历计算，返回类型是 <code>size_t</code>。</p>
<blockquote>
<ul>
<li>下面的函数有什么错误？</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *ptr)</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="keyword">return</span> *ptr * *ptr;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的目的是用来返指针<code>*ptr</code>指向值的平方，但是，由于<code>*ptr</code>指向一个volatile型参数，编译器将产生类似下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *ptr)</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="type">int</span> a，b;</span><br><span class="line">   a = *ptr;</span><br><span class="line">   b = *ptr;</span><br><span class="line">   <span class="keyword">return</span> a * b;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>*ptr</code>的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值</p>
</blockquote>
<h3 id="37、scanf-和-std-cin-有什么区别？"><a href="#37、scanf-和-std-cin-有什么区别？" class="headerlink" title="37、scanf() 和 std::cin 有什么区别？"></a>37、scanf() 和 std::cin 有什么区别？</h3><p>(1)<code>scanf()</code> 是 C 标准库中的一个函数，用于<strong>从标准输入(通常是键盘)读取格式化输入</strong>；<code>std::cin</code> 是 C++ 标准库中的一个对象，用于<strong>从标准输入流读取数据，可以链式输入多个变量</strong>，格式更加灵活；同时<strong>自动跳过空白字符</strong>(如空格、换行符等)。</p>
<p>(2)<code>scanf()</code> <strong>对输入的类型不进行类型检查</strong>，可能会导致类型不匹配或溢出等问题，相对于 <code>std::cin</code>通常更高效，因为它直接操作输入缓冲区；<code>std::cin</code> 是 C+ 中的<strong>类型安全输入方式</strong>；</p>
<h3 id="38、struct-和-class-的区别是什么？"><a href="#38、struct-和-class-的区别是什么？" class="headerlink" title="38、struct 和 class 的区别是什么？"></a>38、struct 和 class 的区别是什么？</h3><p>struct 和 class 是用于定义自定义数据类型的关键字。其中：</p>
<p><strong>(1)struct 默认的访问类型是 <code>public</code> ，而class默认的访问类型是 <code>private</code>；</strong></p>
<p><strong>(2)struct 的继承是 <code>public</code> 的，而class的继承默认是 <code>private</code>的；</strong></p>
<p>(3)struct 用于较为简单的结构，而 class 用于更加复杂的结构。</p>
<blockquote>
<p><strong>为什么有了 class 还要有 struct?</strong> </p>
<p>原因是 C++ 需要保留对 C 的兼容性，C 中有 struct，所以 C++ 也保留。</p>
</blockquote>
<h3 id="39、C-中-delete-一个对象和数组有什么区别？"><a href="#39、C-中-delete-一个对象和数组有什么区别？" class="headerlink" title="39、C++ 中 delete 一个对象和数组有什么区别？"></a>39、C++ 中 delete 一个对象和数组有什么区别？</h3><p>使用<code>delete</code>释放单个对象时只调用一次析构函数，而使用<code>delete[]</code>释放对象数组时需要为数组中的每个对象调用析构函数。</p>
<p><code>delete</code>数组要用<code>delete[]</code>，数组头部有一块内存空间记录数组长度，调用<code>delete[]</code>才能析构每个对象。</p>
<h3 id="40、如何防止重复引用头文件？"><a href="#40、如何防止重复引用头文件？" class="headerlink" title="40、如何防止重复引用头文件？"></a>40、如何防止重复引用头文件？</h3><p>(1)使用<code>#ifndef</code>、<code>#define</code>和<code>#endif</code>；</p>
<p>(2)使用<code>#pragma once</code></p>
<h3 id="41、如何预防变量的重定义？"><a href="#41、如何预防变量的重定义？" class="headerlink" title="41、如何预防变量的重定义？"></a>41、如何预防变量的重定义？</h3><p>(1)使用命名空间</p>
<p>(2)使用<code>static</code>关键字或匿名命名空间来限制变量的作用域至单个文件</p>
<p>(3)使用<code>extern</code>关键字确保全局变量只有一个定义</p>
<p>(4)避免在头文件中定义变量，将定义放在源文件(<code>.cpp</code>)中</p>
<h3 id="42、virtual-和-static-为什么不能修饰同一个成员函数？"><a href="#42、virtual-和-static-为什么不能修饰同一个成员函数？" class="headerlink" title="42、virtual 和 static 为什么不能修饰同一个成员函数？"></a>42、virtual 和 static 为什么不能修饰同一个成员函数？</h3><p>因为它们的语义和用途在本质上是互相冲突的。</p>
<p>(1)<code>virtual</code> 关键字</p>
<ul>
<li><code>virtual</code> 关键字用于支持多态性。一个虚函数允许在派生类中重写，并通过基类的指针或引用在运行时调用派生类的实现。</li>
<li>虚函数的调用需要对象的实例，并且是通过虚函数表(vtable)实现的。虚函数表是每个对象的一部分，用于在运行时解析函数调用。</li>
</ul>
<p>(2)<code>static</code> 关键字</p>
<ul>
<li><code>static</code> 关键字用于声明类的静态成员函数。静态成员函数属于类，而不是类的实例。也就是说，静态成员函数可以在没有任何对象实例的情况下调用。</li>
<li>静态成员函数不依赖于具体的对象实例，因此它们不能访问非静态成员变量或调用非静态成员函数(因为它们没有 <code>this</code> 指针)。</li>
</ul>
<h3 id="43、sizeof-一个-std-string-变量的结果？"><a href="#43、sizeof-一个-std-string-变量的结果？" class="headerlink" title="43、sizeof 一个 std::string 变量的结果？"></a>43、sizeof 一个 std::string 变量的结果？</h3><p>当对一个 <code>std::string</code> 类型的变量使用 <code>sizeof</code> 时，得到的结果是该 <code>std::string</code> 对象本身在栈上所占的大小，而不是它所管理的字符串数据的大小。</p>
<p><code>std::string</code> 通常由以下成员组成：</p>
<ul>
<li>一个<strong>指向存储实际字符数据的指针</strong>。</li>
<li>一个<strong>表示字符串长度</strong>的整数。</li>
<li>一个<strong>表示分配容量</strong>的整数。</li>
</ul>
<p>在 64 位系统上，每个指针通常占用 8 字节(64 位)，而每个整数通常占用 4 或 8 字节(32 或 64 位)，所以总大小通常为 24 或 32 字节。</p>
<h3 id="44、空类的-sizeof-结果是多少？为什么？"><a href="#44、空类的-sizeof-结果是多少？为什么？" class="headerlink" title="44、空类的 sizeof 结果是多少？为什么？"></a>44、空类的 sizeof 结果是多少？为什么？</h3><p>空类会占用至少一个字节的内存空间。 <code>sizeof</code> 结果通常是 1，但也可能会更大，这取决于编译器和平台的实现。</p>
<p><strong>-为什么？</strong></p>
<p>因为编译器需要区分空类的实例，而我们区分的方法就是看其在内存中的地址是不是相同的。所以编译器强制给它分配了冗余的空间，这样创建空类实例时返回的地址才会不一样。</p>
<h3 id="45、只包含虚函数的类-sizeof-的结果是多少？"><a href="#45、只包含虚函数的类-sizeof-的结果是多少？" class="headerlink" title="45、只包含虚函数的类 sizeof 的结果是多少？"></a>45、只包含虚函数的类 sizeof 的结果是多少？</h3><p>类中包含一个指向虚函数表的指针，结果是<code>8</code>(64位系统)。</p>
<h3 id="46、decltype"><a href="#46、decltype" class="headerlink" title="46、decltype"></a>46、decltype</h3><p><code>decltype(declare type)</code>关键字在C++11中引入，它可以在<strong>编译</strong>时获取<strong>表达式</strong>的类型，包括变量、函数调用、表达式等。</p>
<p>decltype 的一些关键点解读如下：</p>
<ul>
<li>表达式类型的推导：decltype 可以用来推导几乎任何表达式的类型，包括变量、函数调用、解引用操作符、成员访问等。它推导的类型是表达式的静态类型，而不是运行时类型。</li>
<li>保留 cv-限定词：与 auto 不同，decltype 在推导类型时会保留表达式的 const 和 volatile 属性。这意味着 decltype 可以推导出更精确的类型。</li>
<li>不推导表达式的值：decltype 只关注表达的类型，而不关心表达式的值。因此，它可以用来推导不产生值的表达式（如函数调用或对象创建）的类型。</li>
<li>decltype 与 decltype specifier：decltype 还可以用作模板参数的 specifier，这允许模板根据其参数的类型来推导其他模板参数的类型。</li>
<li>推导 Lambda 表达式的类型：decltype 可以用来推导 Lambda 表达式的类型，这在泛型编程中非常有用。</li>
</ul>
<h3 id="47、static-在-C-与-C-中的差别？"><a href="#47、static-在-C-与-C-中的差别？" class="headerlink" title="47、static 在 C++与 C 中的差别？"></a>47、static 在 C++与 C 中的差别？</h3><p>在C中：</p>
<ol>
<li>在函数内部，<code>static</code> 修饰的局部变量意味着该变量的生命周期扩展到整个程序运行期间，并且只初始化一次。</li>
<li>在全局范围内，<code>static</code> 修饰的全局变量或函数只在声明它们的文件中可见，无法被其他文件访问。</li>
</ol>
<p>在C++中：</p>
<ol>
<li>在函数内部，<code>static</code> 修饰的局部变量与C中的含义相同，生命周期扩展到整个程序运行期间，并且只初始化一次。</li>
<li>在类中，<code>static</code> 修饰的成员变量属于类，而不是属于类的任何特定实例。这意味着，所有该类的实例共享同一静态成员变量的内存空间，而不是每个实例都有自己的副本。静态成员变量可以通过类名直接访问，也可以通过对象访问，但推荐使用类名访问。</li>
<li>在类中，<code>static</code> 修饰的成员函数是类的静态成员函数，它不属于类的任何特定实例，可以通过类名直接调用，不需要创建类的实例对象。</li>
</ol>
<h3 id="48、静态变量什么时候初始化"><a href="#48、静态变量什么时候初始化" class="headerlink" title="48、静态变量什么时候初始化?"></a>48、静态变量什么时候初始化?</h3><ol>
<li>初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。</li>
<li>静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在 C 和 C++ 中静态局部变量的初始化节点又有点不太一样。在 C 中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在 C 语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。</li>
<li>而在 C++ 中，初始化时在执行相关代码时才会进行初始化，主要是由于 C++ 引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以 C++ 标准定为全局或静态对象是有首次用到时才会进行构造，并通过 atexit() 来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在 C++ 中是可以使用变量对静态局部变量进行初始化的。</li>
</ol>
<h3 id="49、C-中新增了-string，它与-C-语言中的-char-有什么区别吗？如何实现？"><a href="#49、C-中新增了-string，它与-C-语言中的-char-有什么区别吗？如何实现？" class="headerlink" title="49、C++ 中新增了 string，它与 C 语言中的 char * 有什么区别吗？如何实现？"></a>49、C++ 中新增了 string，它与 C 语言中的 char * 有什么区别吗？如何实现？</h3><ol>
<li><code>string</code> 继承自 <code>basic_string</code>，其实是对 <code>char*</code>进行了封装，封装的 <code>string</code> 包含了 <code>char*</code> 数组，容量，长度等等属性。</li>
<li><code>string</code> 可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。</li>
</ol>
<h2 id="四、左值引用和右值引用"><a href="#四、左值引用和右值引用" class="headerlink" title="四、左值引用和右值引用"></a>四、左值引用和右值引用</h2><h3 id="50、什么是左值，什么是右值？"><a href="#50、什么是左值，什么是右值？" class="headerlink" title="50、什么是左值，什么是右值？"></a>50、什么是左值，什么是右值？</h3><ul>
<li>左值(<code>lvalue， localtor value</code>)是指一段指向内存的，具有名称的值，通常有较长的声明周期；左值引用即常见的定义引用的方式，引用相当于变量的别名。</li>
<li>右值(<code>rvalue， read value</code>)是指向不稳定内存的匿名值，声明周期较短。</li>
</ul>
<p>可以通过取址符号来进行判断，能取到地址的是左值，取不到的是右值。</p>
<h3 id="51、前置c-后置c-字符串字面量是左值还是右值？"><a href="#51、前置c-后置c-字符串字面量是左值还是右值？" class="headerlink" title="51、前置c++&#x2F;后置c++&#x2F;字符串字面量是左值还是右值？"></a>51、前置c++&#x2F;后置c++&#x2F;字符串字面量是左值还是右值？</h3><ul>
<li>前置C++的实现是直接对传入的变量进行自增，然后返回这个对象，即一个具有名称的稳定的值，因此返回的是左值。</li>
<li>后置C++是创建一个临时对象，然后对对象自增，再返回这个临时对象，因此返回的是右值。</li>
<li>字符串字面量也是左值。他会将字符串变量存放在程序的数据段中，程序加载时为其分配一段内存。</li>
</ul>
<blockquote>
<p>字面量(Literal)是编程语言中的一个概念，代表着源代码中的常量值，可以直接使用而不需要经过计算或处理。在 C++ 中，常见的字面量包括整数字面量、浮点数字面量、字符字面量、字符串字面量等。</p>
</blockquote>
<h3 id="52、什么是左值引用和右值引用？"><a href="#52、什么是左值引用和右值引用？" class="headerlink" title="52、什么是左值引用和右值引用？"></a>52、什么是左值引用和右值引用？</h3><p>左值引用是指向左值的引用，用单个&amp;表示。常量左值引用可以绑定左值，也可以绑定右值。非常量左值引用只能绑定左值。<br>右值引用是指向右值的引用，用两个&amp;&amp;表示。右值引用主要用于移动语义。通过移动语义，可以避免不必要的拷贝操作，从而提升性能。</p>
<h3 id="53、右值引用是如何提高性能的？"><a href="#53、右值引用是如何提高性能的？" class="headerlink" title="53、右值引用是如何提高性能的？"></a>53、右值引用是如何提高性能的？</h3><p>右值引用主要是通过避免不必要的拷贝操作来提升性能的。<br>举两个例子：<br>(1)当使用右值引用接收函数返回的局部变量时，可以延长该局部变量的声明周期，使得右值引用直接利用该局部变量的内存，而不是创建一个临时对象，从而避免了不必要的开销。<br>(2)当使用一个临时对象来创建一个新对象时，可以使用移动构造函数，直接将资源从一个对象复制到另一个对象上，避免了不必要的复制操作。</p>
<h3 id="54、指针和引用的区别？"><a href="#54、指针和引用的区别？" class="headerlink" title="54、指针和引用的区别？"></a>54、指针和引用的区别？</h3><p>指针和引用都是⼀种内存地址的概念，区别在于指针是⼀个实体，而引用只是⼀个别名。</p>
<ul>
<li><p><strong>(1)在程序编译时：</strong></p>
<ul>
<li>指针指向⼀块内存，指针的内容是所指向的内存的地址，在编译的时候，则是将<strong>“指针变量名-指针变量的地址”</strong>添加到符号表中，所以说，指针包含的内容是可以改变的，允许拷贝和赋值，有 const 和非 const 区别，甚至可以为空。</li>
<li>而对于引用来说，它只是⼀块内存的别名，在添加到符号表的时候，是将<strong>“引用变量名-引用对象的地址”</strong>添加到符号表中，符号表⼀经完成不能改变，所以引用必须而且只能在定义时被绑定到⼀块内存上，后续不能更改，也不能为空，也没有 const 和非 const 区别。</li>
</ul>
</li>
<li><p><strong>(2)sizeof：</strong></p>
<ul>
<li>sizeof 引用得到代表对象的大小；</li>
<li>sizeof 指针得到的是指针本身的大小。</li>
</ul>
</li>
<li><p><strong>(3)在参数传递中：</strong></p>
<ul>
<li>指针需要被解引用后才可以对对象进行操作；</li>
<li>而对引用进行的修改会直接作用到引用对象上。</li>
</ul>
</li>
<li><p><strong>(4)作为参数时：</strong></p>
<ul>
<li>传指针的实质是传值，传递的值是指针的地址；</li>
<li>传引用的实质是传地址，传递的是变量的地址。</li>
</ul>
</li>
</ul>
<h3 id="55、push-back-和-emplace-back-的区别？"><a href="#55、push-back-和-emplace-back-的区别？" class="headerlink" title="55、push_back() 和 emplace_back() 的区别？"></a>55、push_back() 和 emplace_back() 的区别？</h3><p><code>push_back()</code> 和 <code>emplace_back()</code> 都是用于向容器(比如 std::vector)尾部添加新元素的成员函数，但它们在</p>
<p>背后执行的动作略有不同。</p>
<p>区别如下：</p>
<p>(1)<code>push_back()</code>接收一个元素的拷贝或移动作为参数，并将其复制或移动到容器的末端。</p>
<p>(2)<code>emplace_back()</code>则直接在向量的尾部构造元素，而不是先构造一个临时对象然后再进行拷贝或移动。</p>
<blockquote>
<p><code>push_back</code>一定是模板，但是模板的类型一定是与vector的模板一致，因此无法进行类型推导，一定不能是通用引用；2)能够区分左值和右值，所以重载2个函数分别接收左值和右值。</p>
<p><code>emplace_back</code> 1)可以接收任意参数，一定是可变参数模板；2)能够区分左值和右值。因此一定是通用引用。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a) : <span class="built_in">x</span>(a) &#123; std::cout &lt;&lt; <span class="string">&quot;Constructing MyClass with &quot;</span> &lt;&lt; x &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// emplace_back</span></span><br><span class="line">    std::vector&lt;MyClass&gt; vec;</span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="number">42</span>);            <span class="comment">// 直接在 vec 末尾构造 MyClass 对象</span></span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; v.x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push_back</span></span><br><span class="line">    std::vector&lt;MyClass&gt; vec1;</span><br><span class="line">    <span class="function">MyClass <span class="title">my</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    vec1.<span class="built_in">push_back</span>(my);              <span class="comment">// 复制 my 到 vec1 末尾</span></span><br><span class="line">    vec1.<span class="built_in">push_back</span>(<span class="built_in">MyClass</span>(<span class="number">11</span>));     <span class="comment">// 直接构造临时对象并移动到 vec1 末尾</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v1 : vec1) &#123;</span><br><span class="line">        std::cout &lt;&lt; v1.x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="56、push-back-可以传入-std-move-的变量吗？"><a href="#56、push-back-可以传入-std-move-的变量吗？" class="headerlink" title="56、push_back() 可以传入 std::move() 的变量吗？"></a>56、push_back() 可以传入 std::move() 的变量吗？</h3><p><code>push_back</code> 可以接受通过 <code>std::move</code> 传递的变量，这样可以将变量的资源移动到容器中，而不是复制。</p>
<p>这样做和直接使用<code>emplace_back</code>的性能是相似的。因为它们都是在进行移动操作，而非复制操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// push_back</span></span><br><span class="line">std::vector&lt;MyClass&gt; vec1;</span><br><span class="line">vec1.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(<span class="built_in">MyClass</span>(<span class="number">11</span>)));</span><br></pre></td></tr></table></figure>

<h3 id="57、std-move-的实现？"><a href="#57、std-move-的实现？" class="headerlink" title="57、std::move() 的实现？"></a>57、std::move() 的实现？</h3><p>(1)通过类型萃取移除引用属性，获取传入参数的类型；</p>
<p>(2)将传入的参数显式转换为右值引用类型，确保返回的值是一个右值引用，从而启用移动语义；</p>
<p>(3)注意加上<code>noexcept</code> 关键字，表示此函数不会抛出异常。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * std::move 的本质总是将左值转换为右值</span></span><br><span class="line"><span class="comment"> * 对一个对象是用std::move就是告诉编译器，这个对象很适合被移动，但是实际移动的操作是由类自己完成的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="comment">// std::move()的实现 C++11</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态断言：确保 T 不是左值引用类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::move()的实现 C++14</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move2</span><span class="params">(T &amp;&amp;param)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> ReturnType = std::<span class="type">remove_reference_t</span>&lt;T&gt; &amp;&amp;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>

<h3 id="58、std-move-的应用场景？"><a href="#58、std-move-的应用场景？" class="headerlink" title="58、std::move() 的应用场景？"></a>58、std::move() 的应用场景？</h3><p>通常来说，主要是使用 move 操作来优化性能，避免不必要的开销。比如使用 move 来在容器间转移元素，而不是复制。当我们确定一个对象不再使用了时，当你有一个临时对象或者你确定你不再需要一个对象的内容时，使用 move 可以将对象的内容转移到另一个对象，最典型场景是使用 unique_ptr 来改变资源所有权的时候。</p>
<h3 id="59、如果一个对象被使用-std-move-了，再使用它，会产生什么问题？"><a href="#59、如果一个对象被使用-std-move-了，再使用它，会产生什么问题？" class="headerlink" title="59、如果一个对象被使用 std::move 了，再使用它，会产生什么问题？"></a>59、如果一个对象被使用 std::move 了，再使用它，会产生什么问题？</h3><p>被移动的对象进入一个<strong>合法但未定义状态</strong>，它是合法的数据，它可以被正常析构，可以被重新赋值。但是它又是未定义的，使用它的数据后可能会导致崩溃，数据损坏等其它错误的行为。</p>
<h3 id="60、std-move-究竟移动了什么？"><a href="#60、std-move-究竟移动了什么？" class="headerlink" title="60、std::move 究竟移动了什么？"></a>60、std::move 究竟移动了什么？</h3><p>移动的是对象的所有权。通常来说 std::move 做了以下事情：</p>
<ol>
<li>将参数(对象)转换为右值引用，这意味着该对象可以被移动。</li>
<li>将对象的状态转移到另一个对象，通常是通过移动构造函数或移动赋值运算符来完成的。这个过程涉及将资源的所有权从一个对象转移到另一个对象，而不是复制资源。</li>
<li>将源对象的状态置为有效但未指定的状态，以避免重复释放资源或访问已移动的资源</li>
</ol>
<h3 id="61、区别-std-move-和-std-forward"><a href="#61、区别-std-move-和-std-forward" class="headerlink" title="61、区别 std::move() 和 std::forward()"></a>61、区别 std::move() 和 std::forward()</h3><p>(1)<code>std::move</code>将一个对象显式地转换为右值引用，从而启用移动语义；</p>
<p>(2)<code>std::forward</code>完美转发参数，保持参数的值类别；根据传入参数的类型和值类别，返回左值引用或右值引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span> (<span class="type">int</span> value) : <span class="built_in">b</span>(value) &#123; &#125;</span><br><span class="line">    <span class="built_in">A</span> (<span class="type">const</span> A &amp;value) &#123; b = value.b; &#125;</span><br><span class="line">    <span class="built_in">A</span>(A &amp;&amp;value) &#123;</span><br><span class="line">        b = value.b;</span><br><span class="line">        value.b = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * std::forward&lt;T&gt; 的本质是有条件的move，只有当实参用右值初始化时才转换为右值</span></span><br><span class="line"><span class="comment"> * 对一个对象是用std::move就是告诉编译器，这个对象很适合被移动，但是实际移动的操作是由类自己完成的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> A &amp;lvalArg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deal lvalArg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(A &amp;&amp;lvalArg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deal rvalArg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndProcess</span><span class="params">(T &amp;&amp;param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无论param是左值还是右值，只会被认为是左值</span></span><br><span class="line">    <span class="comment">// 为param是一个具有名称的变量，即使它是通过右值引用(T&amp;&amp;)传递进来的，</span></span><br><span class="line">    <span class="comment">// 当我们直接使用它时，它都会被视为左值</span></span><br><span class="line">    <span class="built_in">process</span>(param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无论param是左值还是右值，都会被转换成右值</span></span><br><span class="line">    <span class="built_in">process</span>(std::<span class="built_in">move</span>(param));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅当实参用右值初始化时，转换为一个右值</span></span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="62、什么是引用折叠？"><a href="#62、什么是引用折叠？" class="headerlink" title="62、什么是引用折叠？"></a>62、什么是引用折叠？</h3><p>**引用折叠(Reference Collapsing)**用于处理在模板中出现的多重引用情况，定义了在模板实例化和类型推导过程中，如何将多个引用折叠成一个最终的引用类型。具体规则如下：</p>
<ol>
<li><code>T&amp; &amp;</code> -&gt; <code>T&amp;</code></li>
<li><code>T&amp; &amp;&amp;</code> -&gt; <code>T&amp;</code></li>
<li><code>T&amp;&amp; &amp;</code> -&gt; <code>T&amp;</code></li>
<li><code>T&amp;&amp; &amp;&amp;</code> -&gt; <code>T&amp;&amp;</code></li>
</ol>
<p>换句话说：</p>
<ul>
<li>如果任何一个引用是左值引用，则结果是左值引用。</li>
<li>只有当两个都是右值引用时，结果才是右值引用。</li>
</ul>
<h3 id="63、为什么要引入引用折叠？"><a href="#63、为什么要引入引用折叠？" class="headerlink" title="63、为什么要引入引用折叠？"></a>63、为什么要引入引用折叠？</h3><p>引用折叠的引入主要是为了支持**完美转发(perfect forwarding)**。完美转发使得函数模板能够将参数完全按原样传递给另一个函数，而不会丢失信息。</p>
<h3 id="64、什么是通用引用？如何表示通用引用？"><a href="#64、什么是通用引用？如何表示通用引用？" class="headerlink" title="64、什么是通用引用？如何表示通用引用？"></a>64、什么是通用引用？如何表示通用引用？</h3><p>**通用引用(Universal Reference)<strong>是 C++11 引入的一种概念，用于描述一种特殊的引用类型。通过</strong>在类型推导的上下文中使用 <code>T&amp;&amp;</code>(此处共提到了两个条件，类型推导和T &amp;&amp;)**来实现，既可以绑定到左值，也可以绑定到右值，并且结合<code>std::forward</code>可以实现完美转发。</p>
<p>对右值引用使用 std::move()，对通用引用使用 std::forward()。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这种实现方式存在两个问题：1)不够高效；2)如果有n个参数，则需要2^n个重载函数</span></span><br><span class="line">    <span class="comment">// void setName(const std::string &amp;name) &#123; _name = name; &#125;</span></span><br><span class="line">    <span class="comment">// void setName(std::string &amp;&amp;name) &#123; _name = std::move(name); &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用通用引用来改写</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">setName</span><span class="params">(T &amp;&amp;name)</span> </span>&#123; _name = std::forward&lt;T&gt;(name); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及多个参数时</span></span><br><span class="line">    <span class="comment">// template&lt;typename T， typename... Args&gt;</span></span><br><span class="line">    <span class="comment">// std::shared_ptr&lt;T&gt; make_shared(Args &amp;&amp;... args) &#123;</span></span><br><span class="line">    <span class="comment">//   return std::make_shared&lt;T&gt;(std::forward&lt;Args&gt;(args)...);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通用引用的表示方式：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通用引用既可以表示左值引用，也可以表示右值引用</span></span><br><span class="line"><span class="comment"> * 要求 1)T &amp;&amp;； 2)类型推导</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// T &amp;&amp;param 是通用引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T &amp;&amp;param)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;T&amp;&amp;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// param是右值引用，因为 std::vector&lt;T&gt; &amp;&amp; 和 T &amp;&amp; 形式不一样</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(std::vector&lt;T&gt; &amp;&amp;param)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// param是右值引用，因为 const T &amp;&amp; 和 T &amp;&amp; 形式不一样</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> T &amp;&amp;param)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// x是右值引用</span></span><br><span class="line"><span class="comment">// 因为push_back在有一个特定的vector实例之前不可能存在</span></span><br><span class="line"><span class="comment">// 而实例化vector时，T的类型已经决定了</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>， <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line">    <span class="keyword">class</span> vector&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">void</span> <span class="built_in">push_back</span>(T &amp;&amp; x);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// std::vector&lt;int&gt; vec&#123;1， 2， 3&#125;;</span></span><br><span class="line"><span class="comment">// vec.push_back(4);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 可变参数模版的通用引用</span></span><br><span class="line"><span class="comment"> * 要求：Args &amp;&amp;... + 类型推导</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>， <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line">    <span class="keyword">class</span> vector&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Args&gt;</span><br><span class="line">        <span class="type">void</span> <span class="built_in">emplace_back</span>(Args &amp;&amp;... args);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="65、为什么要避免在通用引用上重载？"><a href="#65、为什么要避免在通用引用上重载？" class="headerlink" title="65、为什么要避免在通用引用上重载？"></a>65、为什么要避免在通用引用上重载？</h3><p>在<strong>通用引用(universal reference)<strong>上进行重载可能会导致函数匹配问题。因为通用引用是通过引用折叠实现的，它可以同时绑定到左值和右值，因此当</strong>同时定义了一个接受通用引用的函数和另一个接受值的函数</strong>时，编译器可能会无法确定应该调用哪个函数，从而导致编译错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板1：接受通用引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T &amp;&amp;arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing generic argument&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板2：接受整数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing integer argument&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">process</span>(<span class="number">5</span>);  <span class="comment">// 调用 process&lt;int&gt;(int)</span></span><br><span class="line">    <span class="built_in">process</span>(x);  <span class="comment">// 调用 process&lt;int&amp;&gt;(int&amp;)，但是可能会与 process(int) 重载冲突</span></span><br><span class="line">    <span class="built_in">process</span>(std::<span class="built_in">move</span>(x));  <span class="comment">// 调用 process&lt;int&gt;(int&amp;&amp;)，但也可能与 process(int) 重载冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="66、通用引用的重载有什么替代方法？"><a href="#66、通用引用的重载有什么替代方法？" class="headerlink" title="66、通用引用的重载有什么替代方法？"></a>66、通用引用的重载有什么替代方法？</h3><p>(1)使用传值来替代通用引用；</p>
<p>(2)使用 tag dispatch；</p>
<p>(3)使用 enable_if 实现真正的重载。enable_if 可以用来实现函数模板的 SFINAE(Substitution Failure Is Not An Error)机制，从而实现通用引用的重载。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* tag dispatch */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(T &amp;&amp;name， std::false_type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    names.<span class="built_in">emplace_back</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(<span class="type">int</span> idx， std::true_type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    names.<span class="built_in">emplace_back</span>(std::forward&lt;T&gt;(idx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T &amp;&amp;name)</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    logAndAddImpl(std::forward&lt;T&gt;(name)，</span></span></span><br><span class="line"><span class="params"><span class="function">                  std::is_integral&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;()))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* enable_if */</span></span><br><span class="line"><span class="comment">// 通用引用的基本模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; t， <span class="keyword">typename</span> std::enable_if&lt;!std::is_lvalue_reference&lt;T&gt;::value&gt;::type* = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Called with rvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 专门用于左值引用的模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; t， <span class="keyword">typename</span> std::enable_if&lt;std::is_lvalue_reference&lt;T&gt;::value&gt;::type* = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Called with lvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="67、什么时候使用按值传递？"><a href="#67、什么时候使用按值传递？" class="headerlink" title="67、什么时候使用按值传递？"></a>67、什么时候使用按值传递？</h3><p>当<strong>参数是可拷贝的且移动成本较低</strong>时，按值传递通常是一个不错的选择。例如，对于小型的类或结构体，按值传递可以减少额外的开销。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406141533639.png" alt="image-20240614153356184"  />

<h3 id="68、什么是返回值优化？"><a href="#68、什么是返回值优化？" class="headerlink" title="68、什么是返回值优化？"></a>68、什么是返回值优化？</h3><p><strong>返回值优化(Return Value Optimization，RVO)<strong>是一种编译器优化技术，在返回一个局部对象时，通过在调用函数的上下文中</strong>直接构造返回的对象</strong>来<strong>避免多次调用构造函数</strong>，从而减少拷贝或移动构造的开销。</p>
<ol>
<li>**匿名返回值优化(Unnamed RVO，URVO)**：这是最常见的一种返回值优化，针对返回匿名对象的情况。</li>
<li>**命名返回值优化(Named RVO，NRVO)**：针对返回具名对象的情况。</li>
</ol>
<p>举例分析： </p>
<p><strong>(1)函数返回一个未具名对象</strong></p>
<p>函数返回一个未具名对象时，执行匿名返回值优化(Unknown Return Value Optimization，URVO)，其本质是将返回值函数的原型进行调整。</p>
<p>注意在C++17之前可以通过设置 <code>-fno-elide-constructors</code>来禁用URVO；从C++17开始，编译器要求强制URVO无法去掉。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 自己写的代码，执行两次移动构造：</span></span><br><span class="line"><span class="comment"> *    1) 创建一个临时对象 Test(1)</span></span><br><span class="line"><span class="comment"> *    2) Test(1) 移动到返回值的位置</span></span><br><span class="line"><span class="comment"> *    2) 返回的临时对象会被再次移动构造到 result</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Test <span class="title">getTest</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Test</span>(<span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; Test result = <span class="built_in">getTest</span>(); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执行URVO后，编译器生成的代码</span></span><br><span class="line"><span class="comment"> *  1. 将函数返回值更改为 void</span></span><br><span class="line"><span class="comment"> *  2. 将要返回的类型定义为 引用类型 的传入参数：Test &amp;t</span></span><br><span class="line"><span class="comment"> *  3. placement new：new(&amp;T) Test(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getTest</span><span class="params">(Test &amp;t)</span> </span>&#123; <span class="keyword">new</span>(&amp;T) <span class="built_in">Test</span>(<span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buff[<span class="built_in">sizeof</span>(Test)];                     <span class="comment">// 栈上开辟4个字节</span></span><br><span class="line">    Test *ptr = <span class="built_in">reinterpret_cast</span>&lt;Test *&gt;(buff);  <span class="comment">// 数据类型转换，标准写法</span></span><br><span class="line">    <span class="built_in">getTest</span>(*ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)函数返回一个具名对象</strong></p>
<p>函数返回一个具名对象时，将同时执行匿名返回值优化(Unknown Return Value Optimization，URVO)和命名返回值优化(Named Return Value Optimization， NRVO)。</p>
<p>设置<code>-fno-elide-constructors</code>可以禁止NRVO。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自己写的代码，执行两次移动构造：</span></span><br><span class="line"><span class="comment"> *    1) 创建一个对象 a</span></span><br><span class="line"><span class="comment"> *    2) a 移动到返回值的位置</span></span><br><span class="line"><span class="comment"> *    2) 返回的临时对象会被再次移动构造到 result</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Test <span class="title">getTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Test <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test result = <span class="built_in">getTest</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对于Test result = getTest(); */</span></span><br><span class="line"><span class="comment">/* 1. 先执行一次URVO，优化 Test result = getTest(); */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getTest</span><span class="params">(Test &amp;t)</span> </span>&#123;</span><br><span class="line">  <span class="function">Test <span class="title">tt</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">new</span>(&amp;tt) <span class="built_in">Test</span>(std::<span class="built_in">move</span>(tt));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 2. 再执行一次NRVO，优化 return t; */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getTest</span><span class="params">(Test &amp;t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">new</span>(&amp;t) <span class="built_in">Test</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buff[<span class="built_in">sizeof</span>(Test)];                     <span class="comment">// 栈上开辟4个字节</span></span><br><span class="line">  Test *ptr = <span class="built_in">reinterpret_cast</span>&lt;Test *&gt;(buff);  <span class="comment">// 数据类型转换，标准写法</span></span><br><span class="line">  <span class="built_in">getTest</span>(*ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、构造-析构相关"><a href="#五、构造-析构相关" class="headerlink" title="五、构造&#x2F;析构相关"></a>五、构造&#x2F;析构相关</h2><h3 id="69、空类中有什么？"><a href="#69、空类中有什么？" class="headerlink" title="69、空类中有什么？"></a>69、空类中有什么？</h3><p>简单来说，当类中一个成员变量也没有时为空类。</p>
<p>但要注意，以下几种情况也为空类：</p>
<ol>
<li><p>类中<strong>有成员函数，但不涉及成员变量</strong>；</p>
</li>
<li><p>类中<strong>有静态成员变量、静态成员函数</strong>；</p>
</li>
<li><p>类中<strong>有 typedef 语句</strong>；</p>
</li>
<li><p>类中<strong>默认生成的6个成员函数</strong>。</p>
<ul>
<li><p>(1)默认构造函数</p>
</li>
<li><p>(2)析构函数</p>
</li>
<li><p>(3)拷贝构造函数</p>
</li>
<li><p>(4)赋值运算符</p>
</li>
<li><p>(5)取址运算符</p>
</li>
<li><p>(6)const取址运算符</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>可以下面这个代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmptyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认的6个成员函数</span></span><br><span class="line">    <span class="built_in">EmptyClass</span>();  <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">EmptyClass</span>();  <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="built_in">EmptyClass</span>(EmptyClass&amp; h);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    EmptyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> EmptyClass&amp; a);  <span class="comment">// 赋值运算符</span></span><br><span class="line">    EmptyClass* <span class="keyword">operator</span>&amp;();  <span class="comment">// 取址运算符</span></span><br><span class="line">    <span class="type">const</span> EmptyClass* <span class="keyword">operator</span>&amp;() <span class="type">const</span>; <span class="comment">// const取址运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// typedef并没有给类增加成员或者函数</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> INT_NUM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不涉及到内部成员变量的内部函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> a)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setStr</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="type">static</span> std::string str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> is_empty = std::is_empty&lt;EmptyClass&gt;::value;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;是否是空类：&quot;</span> &lt;&lt; is_empty &lt;&lt; std::endl;  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="70、深拷贝和浅拷贝指什么？"><a href="#70、深拷贝和浅拷贝指什么？" class="headerlink" title="70、深拷贝和浅拷贝指什么？"></a>70、深拷贝和浅拷贝指什么？</h3><p>(1)<strong>深拷贝</strong>创建一个新的对象，并且复制对象的所有内容，包括对象的指针成员变量所指向的内存空间。深拷贝后的新对象和原对象之间是彼此独立的。</p>
<p>(2)<strong>浅拷贝</strong>只复制对象的引用，而不复制对象的内容。也就是说，浅拷贝创建一个新的对象，但是其新对象的指针成员变量指向的是原对象的指针成员变量所指向的内存空间。</p>
<h3 id="71、拷贝构造函数与拷贝赋值运算符的区别是什么？"><a href="#71、拷贝构造函数与拷贝赋值运算符的区别是什么？" class="headerlink" title="71、拷贝构造函数与拷贝赋值运算符的区别是什么？"></a>71、拷贝构造函数与拷贝赋值运算符的区别是什么？</h3><p>(1)<strong>拷贝构造函数</strong>用于创建新对象，不需要检查自赋值，没有返回值。</p>
<p>(2)而<strong>拷贝赋值运算符</strong>用于更新已经存在的对象的值，需要检查自赋值，以防止对象自身赋值给自己，返回一个引用到当前对象。</p>
<blockquote>
<p>拷贝赋值的步骤：</p>
<ol>
<li><strong>判断是否为自我赋值</strong>(important)</li>
<li>删除自己本来的指针及内存</li>
<li>根据要赋值进来的内容大小开辟一块新的内存</li>
<li>复制新的内容</li>
<li>返回<code>*this</code></li>
</ol>
</blockquote>
<h3 id="72、如果一个类要支持std-move操作，要完成哪些工作呢？"><a href="#72、如果一个类要支持std-move操作，要完成哪些工作呢？" class="headerlink" title="72、如果一个类要支持std::move操作，要完成哪些工作呢？"></a>72、如果一个类要支持std::move操作，要完成哪些工作呢？</h3><p>需要在类中实现移动构造函数和移动赋值函数。</p>
<p>(1)移动构造函数接受一个右值引用到同类型的对象，通常声明为 <code>T(T&amp;&amp; other)</code>，其中 <code>T</code> 是类名。</p>
<p>(2)移动赋值运算符通常被定义为返回类的引用，并接受一个右值引用到同类型的对象，声明为 <code>T&amp; operator=(T&amp;&amp; other)</code>。</p>
<p>(3)为了确保移动动作不会抛出异常，添加<code>noexcept</code>关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">        : <span class="built_in">resource</span>(other.resource) &#123;</span><br><span class="line">        other.resource = <span class="literal">nullptr</span>; 		<span class="comment">// 窃取资源后，将原对象的指针设为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123; 			<span class="comment">// 防止自赋值</span></span><br><span class="line">            <span class="keyword">delete</span> resource;  			<span class="comment">// 释放当前对象的资源</span></span><br><span class="line">            resource = other.resource; 	<span class="comment">// 窃取资源</span></span><br><span class="line">            other.resource = <span class="literal">nullptr</span>; 	<span class="comment">// 将原对象的指针设为空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ResourceType* resource;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="73、移动构造函数可能会有什么问题？"><a href="#73、移动构造函数可能会有什么问题？" class="headerlink" title="73、移动构造函数可能会有什么问题？"></a>73、移动构造函数可能会有什么问题？</h3><p>在使用移动构造函数时，如果当一个对象的资源移动到另一个对象上时发生了异常，此时就会造成有一部分资源转移了，而另一部分没有，从而使得源对象和目标对象上的资源都不完整。因此在使用移动构造函数时应该避免发生异常。</p>
<p>如果无法确保移动构造函数不会发生异常，应该用<code>noexcept</code>进行修饰。这样函数如果发生异常时不会继续执行，而是抛出<code>std::terminate</code>并停止。</p>
<h3 id="74、构造函数能否为虚函数？"><a href="#74、构造函数能否为虚函数？" class="headerlink" title="74、构造函数能否为虚函数？"></a>74、构造函数能否为虚函数？</h3><p><strong>构造函数不能是虚函数。</strong>这是因为在C++中，虚函数依赖于对象中的虚函数表(vtable)来进行动态绑定，而虚函数表是在对象的内存分配后构造函数开始执行之前设置好的。在构造函数执行之前，对象还未完全构建完成，因此不存在可以指向的虚函数表。</p>
<p>如果构造函数是虚的，那么在对象创建时还无法确定调用哪一个构造函数，因为虚函数机制尚未建立，所以构造函数无法实现虚调用。</p>
<h3 id="75、析构函数是什么？"><a href="#75、析构函数是什么？" class="headerlink" title="75、析构函数是什么？"></a>75、析构函数是什么？</h3><p><strong>析构函数</strong>是类的一个成员函数，名字由波浪号接类名构成，没有返回值，不接受参数，一个类只有一个析构函数。</p>
<p>创建对象时系统会自动调用构造函数进行初始化工作，同样，销毁对象时系统也会自动调用析构函数来进行清理工作，例如释放分配的内存、关闭打开的文件等。</p>
<h3 id="76、如果在类的析构函数中调用-delete-this-会发生什么？"><a href="#76、如果在类的析构函数中调用-delete-this-会发生什么？" class="headerlink" title="76、如果在类的析构函数中调用 delete this 会发生什么？"></a>76、如果在类的析构函数中调用 delete this 会发生什么？</h3><p>会导致堆栈溢出。</p>
<p>delete 的本质是“为将被释放的内存调用一个或多个析构函数，然后释放内存”。因此，delete this 会去调用本对象的析构函数，而析构函数内部又会调用 delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p>
<h3 id="77、一个类可以没有析构函数吗？"><a href="#77、一个类可以没有析构函数吗？" class="headerlink" title="77、一个类可以没有析构函数吗？"></a>77、一个类可以没有析构函数吗？</h3><ol>
<li><p><strong>无需编写析构函数的情况</strong>：构造函数仅做简单的成员变量初始化，且成员变量是<strong>内置类型或自动管理的资源</strong>；</p>
</li>
<li><p><strong>需要编写析构函数的情况</strong>：构造函数<strong>分配了动态内存、打开了文件或分配了其他需手动管理的资源</strong>，需在析构函数中进行资源释放；</p>
</li>
</ol>
<h3 id="78、析构函数能否为虚函数？"><a href="#78、析构函数能否为虚函数？" class="headerlink" title="78、析构函数能否为虚函数？"></a>78、析构函数能否为虚函数？</h3><ol>
<li><p><strong>不作为基类</strong>：如果类不会被继承或不会通过基类指针删除派生类对象，则不需要虚析构函数。</p>
</li>
<li><p><strong>作为基类</strong>：如果类可能被继承，并且可能通过基类指针删除派生类对象，则应将析构函数定义为虚函数，以确保正确的析构行为。否则，若基类的析构函数不是虚函数，那么调用基类指针删除派生类对象时只会调用基类的析构函数，而不会调用派生类的析构函数。</p>
</li>
</ol>
<h3 id="79、C-的类中可以定义引用的数据成员吗？"><a href="#79、C-的类中可以定义引用的数据成员吗？" class="headerlink" title="79、C++ 的类中可以定义引用的数据成员吗？"></a>79、C++ 的类中可以定义引用的数据成员吗？</h3><p>可以使用，但要注意以下几点：</p>
<ol>
<li><strong>初始化必须在构造函数初始化列表中进行</strong>：引用成员必须在构造函数的初始化列表中进行初始化，因为引用必须在声明时绑定到一个对象，不能在构造函数体内进行赋值。</li>
<li><strong>不能重新绑定</strong>：一旦引用成员被初始化，它就不能被重新绑定到另一个对象。引用成员在对象的生命周期内一直指向同一个对象。</li>
<li><strong>默认构造函数和赋值运算符可能存在错误</strong>：如果类中有引用成员，那么默认的默认构造函数(无参构造函数)就不能使用，因为引用成员需要在初始化时绑定到一个对象。同样，默认的赋值运算符也可能不能正确工作，因为引用成员不能被重新赋值。</li>
</ol>
<h3 id="80、什么情况下编译器必须为未声明构造函数的类合成一个-default-constructor？"><a href="#80、什么情况下编译器必须为未声明构造函数的类合成一个-default-constructor？" class="headerlink" title="80、什么情况下编译器必须为未声明构造函数的类合成一个 default constructor？"></a>80、什么情况下编译器必须为未声明构造函数的类合成一个 default constructor？</h3><ol>
<li><p>如果一个类没有声明构造函数，但它内部包含声明了构造函数的成员类，那么编译器需要为这个类合成一个默认构造函数。但要注意以下几点：</p>
<ol>
<li><p>只有在构造函数真正需要被调用时才会执行合成操作；</p>
</li>
<li><p>为避免在不同的编译模块中合成多个 default constructor，采用 inline 的方式完成；</p>
</li>
<li><p>被合成的 default constructor 只是编译器的需要，而不是程序的需要，因此合成时不会对类本身的数据成员进行初始化；而若是程序员已经手动编写了 default constructor，但仅初始化了数据成员，此时编译器会扩张已存在的 constructors，在用户初始化代码前安插必要的 constructors。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; <span class="keyword">public</span>: <span class="built_in">Foo</span>(); <span class="built_in">Foo</span>(<span class="type">int</span>); ...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123; <span class="keyword">public</span>: Foo foo; <span class="type">char</span> *str; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> foo_bar &#123;</span><br><span class="line">    Bar bar;  <span class="comment">// Bar::foo必须在此处进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (str) ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设程序员定义的 default constructor 如下</span></span><br><span class="line">Bar::<span class="built_in">Bar</span>() &#123; str = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么，编译器会在编译时会进行相应扩充</span></span><br><span class="line"><span class="comment">// C++ 伪代码</span></span><br><span class="line">Bar::<span class="built_in">Bar</span>() &#123;</span><br><span class="line">    foo.Foo::<span class="built_in">Foo</span>();  <span class="comment">// 编译器扩充</span></span><br><span class="line">    str = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果包含多个类成员，那么将按照其声明顺序来调用各自的 constructors。</p>
</li>
</ol>
</li>
<li><p>如果一个没有任何 constructors 的类派生自一个带有 default constructor 的基类，那么这个 derived class 也需要合成一个 default constructor。注意如果该派生类中同时包含类成员(同情况1)，那么会在所有基类的 default constructor 被调用之后调用这些类成员的 default constructor。</p>
</li>
<li><p>如果类声明或继承了一个 virtual function，或类派生自一个继承串链，其中有一个或多个 virtual base classes，那么也需要为其合成一个 default constructor。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">flip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(<span class="type">const</span> Widget&amp; widget)</span> </span>&#123; </span><br><span class="line">    widget.<span class="built_in">flip</span>(); </span><br><span class="line">    <span class="comment">// widget.flip(); 的虚拟调用操作为： (*widget.vptr[1])(&amp;widget);</span></span><br><span class="line">    <span class="comment">//  1: flip()在vtbl中的索引</span></span><br><span class="line">    <span class="comment">//  &amp;widget: 某个实例的this指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bell b;</span><br><span class="line">    Whistle w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">flip</span>(b);</span><br><span class="line">    <span class="built_in">flip</span>(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要对 Bell 和 Whistle 合成 default constructor，为其 vptr 设定初值，指向 vtbl，这样调用 <code>flip(b)</code> 时才能够在虚表中找到对应的虚函数实现。</p>
</li>
<li><p>对于一个带有虚继承类的类，也需要合成其 default constructor。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123; <span class="keyword">public</span>: <span class="type">int</span> i; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;<span class="keyword">public</span>: <span class="type">int</span> j; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法在编译时期决定出 pa-&gt;X::i 的位置，因为 pa 的真正类型可以改变</span></span><br><span class="line"><span class="comment">// 因此编译器需要在派生类对象的每一个虚基类中安插一个指针，</span></span><br><span class="line"><span class="comment">// 所有经由引用或指针来存取一个虚基类的操作都可以通过相关指针完成</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A* pa)</span> </span>&#123; pa-&gt;i = <span class="number">1024</span>; &#125;;</span><br><span class="line"><span class="comment">// 此处编译器可能会执行： pa-&gt;__vbcX-&gt;i = 1024;</span></span><br><span class="line"><span class="comment">// 其中__vbcX 表示编译器产生的指针，指向 virtual base class X</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="keyword">new</span> A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="81、类成员的初始化方式有哪些？"><a href="#81、类成员的初始化方式有哪些？" class="headerlink" title="81、类成员的初始化方式有哪些？"></a>81、类成员的初始化方式有哪些？</h3><p><strong>赋值初始化</strong>，通过在函数体内进行赋值初始化；<strong>列表初始化</strong>，在冒号后使用初始化列表进行初始化。</p>
<p>这两种方式的<strong>主要区别</strong>在于：</p>
<ol>
<li>赋值初始化是在所有的数据成员被分配内存空间后才进行的；</li>
<li>列表初始化是给数据成员分配内存空间时就进行初始化，也就是说分配一个数据成员时，只要冒号后有此数据成员的赋值表达式，那么在进入函数体之前就会给该数据成员赋值；</li>
<li>列表初始化快于赋值初始化，因为 C++ 的赋值操作是会产生临时对象的。临时对象的出现会降低程序的效率。</li>
</ol>
<h3 id="82、有哪些情况必须用到成员列表初始化？作用是什么？"><a href="#82、有哪些情况必须用到成员列表初始化？作用是什么？" class="headerlink" title="82、有哪些情况必须用到成员列表初始化？作用是什么？"></a>82、有哪些情况必须用到成员列表初始化？作用是什么？</h3><ol>
<li>必须使用成员初始化的四种情况：</li>
</ol>
<p>① 当初始化一个<strong>引用成员</strong>时；</p>
<p>② 当初始化一个<strong>常量成员</strong>时；</p>
<p>③ 当调用一个<strong>基类的构造函数</strong>，而它拥有一组参数时；</p>
<p>④ 当调用一个<strong>类成员的构造函数</strong>，而它拥有一组参数时；</p>
<ol start="2">
<li>成员初始化列表做了什么</li>
</ol>
<p>① 编译器以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；</p>
<p>② list 中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；</p>
<h3 id="83、定义一个-class-的object-时，编译器对其构造函数的扩充操作如何？"><a href="#83、定义一个-class-的object-时，编译器对其构造函数的扩充操作如何？" class="headerlink" title="83、定义一个 class 的object 时，编译器对其构造函数的扩充操作如何？"></a>83、定义一个 class 的object 时，编译器对其构造函数的扩充操作如何？</h3><p>按照顺序，依次进行如下扩充：</p>
<ol>
<li>所有<strong>虚拟基类构造函数</strong>被调用；</li>
<li>所有<strong>上一层的基类构造函数</strong>被调用；</li>
<li>为<strong>虚表指针设定初值</strong>，指向适当的虚表；</li>
<li>调用<strong>类成员的构造函数</strong>；</li>
<li>对记录<strong>在列表初始化中的数据成员</strong>进行初始化操作；</li>
<li>派生类<strong>自己的构造函数</strong>函数体。</li>
</ol>
<blockquote>
<p>根据上述扩充顺序可知：<strong>在 constructor 的 member initialization list 中调用该 class 的一个虚函数，是安全行为。</strong>因为 vptr 在 member initialization list 被扩展之前已经由编译器设定好了。只是在语境上这可能是不安全的，因为函数本身可能还得依赖未被设立初值的 members。</p>
</blockquote>
<h2 id="六、多态-虚函数相关"><a href="#六、多态-虚函数相关" class="headerlink" title="六、多态&#x2F;虚函数相关"></a>六、多态&#x2F;虚函数相关</h2><h3 id="84、多态的实现原理是什么？"><a href="#84、多态的实现原理是什么？" class="headerlink" title="84、多态的实现原理是什么？"></a>84、多态的实现原理是什么？</h3><p><code>c++</code>的多态包括**静态多态(编译器多态)<strong>和</strong>动态多态(运行期多态)**。</p>
<p>(1)<strong>静态多态</strong>是指编译器的多态，主要由<strong>函数重载和函数模板</strong>实现。函数重载是指在同一作用域内，一组函数具有相同的函数名和不同的参数列表，编译器根据函数调用时传递的参数数量和类型选择调用哪个函数执行。函数模板允许编写通用的代码，编译器根据模板实例化的内容生成代码。</p>
<p>(2)<strong>动态多态</strong>则是在运行时实现，主要由<strong>虚函数和继承</strong>实现。其核心思想是类的对象会根据其属性来确定究竟调用哪一个类的函数。具体来说，每一个包含虚函数的类都分配了一个虚函数指针，这个虚函数指针指向一个虚函数表。当需要调用对应的函数时，首先根据虚函数指针找到对应的虚函数表，然后根据这个函数在表中的下标位置找到对应的函数。</p>
<blockquote>
<p>多态(polymorphism)表示“<strong>以一个 public base class 的指针或引用，寻址出一个 derived class object</strong>”。</p>
</blockquote>
<blockquote>
<p><strong>base class 和 derived class 都从相同的地址开始，确保类型转换的安全性和多态性的正确实现。</strong></p>
<p>虽然基类和派生类对象从相同的地址开始，但它们的内存布局是严格按照类的成员声明顺序进行的。当创建派生类对象时，内存分配器会为整个对象分配足够的内存，包括基类和派生类的所有成员。基类的成员会先在内存中布局，然后是派生类的成员。因此，基类的成员和派生类的成员在内存中是连续的，不会重叠。</p>
</blockquote>
<h3 id="85、子类的构造与析构过程？"><a href="#85、子类的构造与析构过程？" class="headerlink" title="85、子类的构造与析构过程？"></a>85、子类的构造与析构过程？</h3><ul>
<li><p>构造：先调用父类——&gt;再调用子类</p>
</li>
<li><p>析构：先调用子类——&gt;再调用父类</p>
</li>
</ul>
<h3 id="86、虚函数和纯虚函数有什么区别？"><a href="#86、虚函数和纯虚函数有什么区别？" class="headerlink" title="86、虚函数和纯虚函数有什么区别？"></a>86、虚函数和纯虚函数有什么区别？</h3><p>(1)<strong>虚函数</strong>是一种<strong>在基类中声明</strong>的函数，它可以在派生类中被重写。虚函数<strong>可以有自己的实现</strong>，也就是说，即使派生类没有重写该函数，也有一个默认的行为可供执行。</p>
<p>(2)<strong>纯虚函数</strong>是一种<strong>在基类中声明但不实现</strong>的虚函数。通过在函数声明的末尾加上<code>= 0</code>，可以将函数声明为纯虚函数。一个包含纯虚函数的类称为抽象类，这意味着它不能被实例化。纯虚函数的主要目的是强制派生类提供自己的函数实现。</p>
<h3 id="87、什么样的函数适合声明成虚函数？"><a href="#87、什么样的函数适合声明成虚函数？" class="headerlink" title="87、什么样的函数适合声明成虚函数？"></a>87、什么样的函数适合声明成虚函数？</h3><ul>
<li><strong>基类中的函数</strong>：如果函数在基类中定义，并且子类可能需要重写该函数以提供特定实现，那么该函数通常应该声明为虚函数。这样，在运行时可以根据对象的实际类型来调用适当的函数版本。</li>
<li><strong>用于多态行为</strong>：虚函数为多态提供了支持。当通过基类指针或引用调用虚函数时，实际上调用的是相应派生类的重写版本。这种多态行为使得代码更加灵活和可扩展。</li>
<li><strong>用于接口定义</strong>：在设计接口时，通常将接口中的函数声明为虚函数。这样，派生类可以根据自己的需求来实现这些接口函数，同时保持统一的接口定义。</li>
<li><strong>需要动态绑定</strong>：虚函数可以在运行时动态绑定到适当的函数版本。这种动态绑定对于实现运行时多态非常重要。</li>
</ul>
<h3 id="88、模板类能不能有虚函数？类能不能模板成员函数为虚函数？"><a href="#88、模板类能不能有虚函数？类能不能模板成员函数为虚函数？" class="headerlink" title="88、模板类能不能有虚函数？类能不能模板成员函数为虚函数？"></a>88、模板类能不能有虚函数？类能不能模板成员函数为虚函数？</h3><p><strong>模板类</strong>可以有虚函数。虽然单个模板类的实例化是静态的，但模板类本身可以包含虚函数。这样，在实例化特定类型的模板类时，这些虚函数将成为实例化类的一部分，并且可以通过基类指针进行多态调用。</p>
<p><strong>类</strong>不能有模板成员函数为虚函数。这是因为<strong>虚函数表需要在编译时确定，而模板成员函数是在实例化时生成代码的</strong>，因此编译器无法在编译时确定模板成员函数的虚函数表条目。</p>
<h3 id="89、虚函数可以内联吗？"><a href="#89、虚函数可以内联吗？" class="headerlink" title="89、虚函数可以内联吗？"></a>89、虚函数可以内联吗？</h3><ol>
<li><p>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时不可以内联。 </p>
</li>
<li><p><strong>inline virtual 唯一可以内联的时候</strong>是：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚函数静态调用</span></span><br><span class="line">pclass-&gt;<span class="keyword">class</span>::<span class="built_in">vf</span>()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 或者在类体内调用class::vf()，相当于this-&gt;class::vf()</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="90、虚函数表是一个-map-还是一个数组？"><a href="#90、虚函数表是一个-map-还是一个数组？" class="headerlink" title="90、虚函数表是一个 map 还是一个数组？"></a>90、虚函数表是一个 map 还是一个数组？</h3><p>虚函数表(vtable，虚方法表)在实现上通常是一个<strong>数组</strong>。这个表是一个编译时构建的数组，其中存储了指向类中所有虚函数的指针。</p>
<p><strong>为什么是数组，不是map？</strong></p>
<ol>
<li><p><strong>性能</strong>：数组**通过索引直接访问元素，访问时间为O(1)**，而map(通常实现为红黑树或哈希表)的访问时间可能是O(log n)或更复杂，取决于实现。因此，数组访问速度更快，适合频繁访问的场景，如虚函数的调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">flip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(<span class="type">const</span> Widget&amp; widget)</span> </span>&#123; </span><br><span class="line">    widget.<span class="built_in">flip</span>(); </span><br><span class="line">    <span class="comment">// widget.flip(); 的虚拟调用操作为： (*widget.vptr[1])(&amp;widget);</span></span><br><span class="line">    <span class="comment">//  1: flip()在vtbl中的索引</span></span><br><span class="line">    <span class="comment">//  &amp;widget: 某个实例的this指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内存布局</strong>：由于数组具有连续的内存布局特性，这有助于提高缓存的效率，从而加速虚函数的调用过程。</p>
</li>
</ol>
<h3 id="91、虚表里除了可能有虚函数，还可能有什么？"><a href="#91、虚表里除了可能有虚函数，还可能有什么？" class="headerlink" title="91、虚表里除了可能有虚函数，还可能有什么？"></a>91、虚表里除了可能有虚函数，还可能有什么？</h3><p>虚表中除了包含虚函数的指针外，还可能包含以下内容：</p>
<ol>
<li><strong>析构函数指针</strong>：如果类有虚析构函数，那么虚表中会包含析构函数的指针。这样，当删除基类指针时，能够正确地调用派生类的析构函数。</li>
<li><strong>RTTI信息</strong>：虚表中可能包含与运行时类型信息(RTTI)相关的数据，比如类的类型信息。RTTI使得在运行时能够进行类型识别和转换，主要通过<code>dynamic_cast</code>和<code>typeid</code>运算符来实现。这些信息有时存储在与虚表相关的其他表格中，而不是直接在虚表中。</li>
</ol>
<h3 id="92、一个类中有几个虚函数表？一个类的对象有几个虚函数指针？"><a href="#92、一个类中有几个虚函数表？一个类的对象有几个虚函数指针？" class="headerlink" title="92、一个类中有几个虚函数表？一个类的对象有几个虚函数指针？"></a>92、一个类中有几个虚函数表？一个类的对象有几个虚函数指针？</h3><p>**每个类只有一个虚函数表(vtable)**，不管这个类有多少个虚函数。虚函数表存储了该类所有虚函数的地址。</p>
<p>**一个类的每个对象都有一个虚表指针(vptr)**，用于指向该类的虚函数表。这个指针位于对象的内存布局的最开始位置，即使没有声明任何虚函数，编译器也会为其分配空间。</p>
<h3 id="93、现在一个类在构造函数初始化的时候初始化了虚函数表，若通过-memset-将这个类全部赋值为-0，那这个虚表指针会被损坏，有什么办法恢复它吗？"><a href="#93、现在一个类在构造函数初始化的时候初始化了虚函数表，若通过-memset-将这个类全部赋值为-0，那这个虚表指针会被损坏，有什么办法恢复它吗？" class="headerlink" title="93、现在一个类在构造函数初始化的时候初始化了虚函数表，若通过 memset() 将这个类全部赋值为 0，那这个虚表指针会被损坏，有什么办法恢复它吗？"></a>93、现在一个类在构造函数初始化的时候初始化了虚函数表，若通过 memset() 将这个类全部赋值为 0，那这个虚表指针会被损坏，有什么办法恢复它吗？</h3><p><strong>没有直接的、安全的方法来恢复虚表指针</strong>。一旦虚表指针被覆盖或破坏，这个对象基本上就已经损坏，无法保证其后续行为的正确性。</p>
<p>可考虑<strong>重新构造对象</strong>。即，如果确实需要重置对象的状态，考虑使用对象的构造函数和析构函数来正确地构建和销毁对象。例如，<strong>可以先显式调用析构函数，然后使用 <code>placement new</code> 重新在原地构造一个新对象</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">obj.~<span class="built_in">ClassName</span>();</span><br><span class="line"><span class="keyword">new</span> (&amp;obj) <span class="built_in">ClassName</span>();</span><br></pre></td></tr></table></figure>

<h3 id="94、一个类的虚表指针在类中的内存分布是怎样的？"><a href="#94、一个类的虚表指针在类中的内存分布是怎样的？" class="headerlink" title="94、一个类的虚表指针在类中的内存分布是怎样的？"></a>94、一个类的虚表指针在类中的内存分布是怎样的？</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Base object memory layout:</span><br><span class="line">-----------------------------</span><br><span class="line">| vptr (pointer to vtable) |</span><br><span class="line">-----------------------------</span><br><span class="line">| base_data                |</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Derived object memory layout:</span><br><span class="line">-----------------------------</span><br><span class="line">| vptr (pointer to vtable)  |  &lt;- Points to the `Derived` class vtable</span><br><span class="line">-----------------------------</span><br><span class="line">| base_data                 |</span><br><span class="line">-----------------------------</span><br><span class="line">| derived_data              |</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<blockquote>
<p>程序代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base foo&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base bar&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNum_Base</span> <span class="params">(<span class="type">int</span> a)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="type">int</span> base_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived foo&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived bar&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123; std::cout &lt;&lt; <span class="string">&quot;Derived destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNum_derived</span> <span class="params">(<span class="type">int</span> a)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="type">int</span> derived_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">bar</span>();</span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意：</p>
<p>出现在 dervied class 中的 base class subobject 有其完整原样性。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406191022541.png" alt="image-20240619102242541" style="zoom: 25%;" />
</blockquote>
<h3 id="95、虚表指针在什么时候创建？虚函数表在什么时候创建、存在在什么位置？"><a href="#95、虚表指针在什么时候创建？虚函数表在什么时候创建、存在在什么位置？" class="headerlink" title="95、虚表指针在什么时候创建？虚函数表在什么时候创建、存在在什么位置？"></a>95、虚表指针在什么时候创建？虚函数表在什么时候创建、存在在什么位置？</h3><p><strong>(1)虚表指针在什么时候创建？</strong></p>
<ul>
<li><p>当对象被实例化时(即调用构造函数时)，编译器会在对象内存中插入一个<strong>指向虚函数表的指针(vptr)<strong>。具体来说，会</strong>在 base class constructors 调用操作之后，但是在程序员供应的代码或是 member initialization list 中所列的 members 初始化操作之前</strong>。</p>
</li>
<li><p>基类和派生类的<strong>构造函数负责设置 vptr 指向相应类的虚函数表</strong>。如果对象是派生类的实例，派生类的构造函数将确保 vptr 指向派生类的虚函数表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含虚函数时的 copy constructor 操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZooAnimal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZooAnimal</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ZooAnimal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">animate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> ZooAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bear</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">animate</span><span class="params">()</span></span>;  <span class="comment">// virtual</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// yogihui被default Bear contructor初始化，</span></span><br><span class="line">    <span class="comment">// 其vptr设定指向Bear class的vtbl</span></span><br><span class="line">    Bear yogi;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// franny被copy Bear constructor初始化，</span></span><br><span class="line">    <span class="comment">// 但其vptr会被设定指向ZooAnimal class的vtbl，而不是Bear class</span></span><br><span class="line">    ZooAnimal franny = yogi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>(2)虚函数表在什么时候创建、存在在什么位置？</strong></p>
<ul>
<li><p>编译器在<strong>编译期间</strong>生成虚函数表(vtable)，虚函数表包含类的所有虚函数的地址。每个定义了虚函数的类都有一个虚函数表，派生类可能会覆盖基类中的虚函数。如果派生类覆盖了基类的虚函数，派生类的虚函数表中对应的条目会被更新为指向派生类中的虚函数。否则，派生类的虚函数表中会保留一个指向基类虚函数的指针。</p>
</li>
<li><p>虚函数表存储在程序的**只读数据段(.rodata)<strong>，这是因为虚函数表在编译时就已经确定，运行时不会修改。虚表中的指针再指向</strong>代码段(.text)**的函数代码。</p>
</li>
</ul>
<h3 id="96、抽象类和普通虚函数类的区别是什么？"><a href="#96、抽象类和普通虚函数类的区别是什么？" class="headerlink" title="96、抽象类和普通虚函数类的区别是什么？"></a>96、抽象类和普通虚函数类的区别是什么？</h3><p>(1)抽象类<strong>至少包含一个纯虚函数</strong>，其不能被直接实例化，必须让派生类继承并实现其纯虚函数；</p>
<p>(2)普通虚函数类<strong>可以包含一个或多个虚函数</strong>，这些虚函数在基类中有具体的实现，但可以在派生类中被重写。可以被直接实例化。</p>
<h3 id="97、如何设计一个不能继承的类？"><a href="#97、如何设计一个不能继承的类？" class="headerlink" title="97、如何设计一个不能继承的类？"></a>97、如何设计一个不能继承的类？</h3><p>(1)在C++11及更高版本中，可以在类声明中<strong>使用<code>final</code>关键字</strong>来防止类被继承；</p>
<p>(2)在C++11之前，一个常用的技巧是<strong>将构造函数声明为私有或受保护的，并通过静态方法返回实例</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数，禁止直接实例化</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance created.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一的实例指针</span></span><br><span class="line">    <span class="type">static</span> std::unique_ptr&lt;Singleton&gt; instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态方法，用于获取单例实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Singleton</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="98、父类用-private-修饰的变量，使用多态后能不能访问到这个变量呢？"><a href="#98、父类用-private-修饰的变量，使用多态后能不能访问到这个变量呢？" class="headerlink" title="98、父类用 private 修饰的变量，使用多态后能不能访问到这个变量呢？"></a>98、父类用 private 修饰的变量，使用多态后能不能访问到这个变量呢？</h3><p>在 C++ 中，如果父类中的变量被声明为 <code>private</code>，那么这些变量只能被该父类自己的成员函数、友元函数或者同一个类的其他实例访问。即使在继承的情况下，子类是无法直接访问父类的私有成员变量的。</p>
<h3 id="99、假设一个类继承了有虚函数的类，父类会存在在子类中吗？"><a href="#99、假设一个类继承了有虚函数的类，父类会存在在子类中吗？" class="headerlink" title="99、假设一个类继承了有虚函数的类，父类会存在在子类中吗？"></a>99、假设一个类继承了有虚函数的类，父类会存在在子类中吗？</h3><ol>
<li>子类中包含父类的数据成员；</li>
<li>如果子类没有父类的虚函数进行重写，那么子类的虚表指针所指向的虚表中，会存在父类的虚函数；否则，会用子类重写后虚函数进行替代。</li>
</ol>
<h3 id="100、虚拟继承是什么？"><a href="#100、虚拟继承是什么？" class="headerlink" title="100、虚拟继承是什么？"></a>100、虚拟继承是什么？</h3><p>虚继承是一种特殊的继承方式，用于解决菱形继承中的问题。在菱形继承结构中，一个基类通过多个路径被继承多次，可能导致该基类的成员在最终派生类中出现多份拷贝。虚基类的引入可以保证基类子对象在最终派生类中只有一份，从而避免这种重复。</p>
<p>一般的实现方法如下所述。class 如果内含一个或多个 虚基类子对象(virtual base class subobject)，将被分割为两部分：一个<strong>不变区域</strong>和一个<strong>共享区域</strong>。不变区域中的数据，不管后继如何衍化，总是拥有固定的 offset，所以这一部分数据可以被直接存储；<strong>至于共享区域，所表现的就是 virtual base class subobject，其位置会因为派生的操作而变化，所以只能间接存取</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B， <span class="keyword">public</span> C &#123;</span><br><span class="line">    <span class="comment">// D中只有一份A的成员data</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="101、说一下重载，覆盖和隐藏的区别？"><a href="#101、说一下重载，覆盖和隐藏的区别？" class="headerlink" title="101、说一下重载，覆盖和隐藏的区别？"></a>101、说一下重载，覆盖和隐藏的区别？</h3><p>(1)<strong>重载(Overloading)<strong>发生</strong>在同一个作用域内</strong>，当两个或更多具有相同名称但参数列表不同的函数共存时，这些函数被称为重载函数。</p>
<p>(2)<strong>覆盖(Overriding)<strong>是面向对象编程中的一个特性，指的是</strong>在派生类中重新定义基类中的虚函数</strong>。覆盖的主要目的是实现多态。派生类的函数覆盖了基类的函数，当通过基类的指针或引用调用该函数时，会根据对象的实际类型来调用相应的函数。</p>
<p>(3)**隐藏(Hiding)<strong>发生在继承关系中，当</strong>派生类中声明了与基类同名的成员(函数或变量)**时，无论参数列表是否相同，基类中的同名成员都会被派生类中的成员隐藏。</p>
<h3 id="102、函数重载在编译期间的实现原理-（符号重命名，加上类型）？"><a href="#102、函数重载在编译期间的实现原理-（符号重命名，加上类型）？" class="headerlink" title="102、函数重载在编译期间的实现原理 （符号重命名，加上类型）？"></a>102、函数重载在编译期间的实现原理 （符号重命名，加上类型）？</h3><p>函数重载在编译期间的实现原理主要依靠“名称改编”（name mangling）。具体过程如下：</p>
<ol>
<li><strong>名称改编</strong>：编译器将函数名与其参数类型组合成一个唯一的标识符。这解决了多个同名函数的问题，使得编译器可以区分不同的重载版本。</li>
<li><strong>符号表</strong>：编译器在符号表中记录这些唯一标识符。当调用函数时，编译器根据参数类型查找匹配的标识符。</li>
<li><strong>类型检查</strong>：编译器在调用函数时，会检查传递的参数类型与符号表中的记录，以确保调用正确的函数版本。</li>
</ol>
<h3 id="103、多继承问题，如果有公共父类时调用函数产生二义性的情况下，怎么办？"><a href="#103、多继承问题，如果有公共父类时调用函数产生二义性的情况下，怎么办？" class="headerlink" title="103、多继承问题，如果有公共父类时调用函数产生二义性的情况下，怎么办？"></a>103、多继承问题，如果有公共父类时调用函数产生二义性的情况下，怎么办？</h3><p>在多继承中，如果有公共父类并调用函数时产生二义性，可以通过以下方法解决：</p>
<ol>
<li><strong>作用域解析运算符</strong>：使用类名和作用域解析运算符 (<code>::</code>) 指定调用哪个父类的函数。例如，<code>Base1::function()</code>。</li>
<li><strong>虚继承</strong>：使用虚继承（<code>virtual</code> 关键字）来确保公共父类只在派生类中存在一个实例，避免二义性。</li>
</ol>
<h3 id="104、多重继承下的内存分布如何？"><a href="#104、多重继承下的内存分布如何？" class="headerlink" title="104、多重继承下的内存分布如何？"></a>104、多重继承下的内存分布如何？</h3><p>对于一个多重派生对象：</p>
<ol>
<li>将其地址指定给<strong>第一个 base class</strong> 的指针，情况将和单一继承时相同，因为二者都指向相同的起始地址。</li>
<li>至于<strong>第二个或后继的 base class</strong> 的地址指定操作，则需要对地址进行修改：加上或减去位于中间的 base class subobject(s) 的大小。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 考虑将 vptr 放在 class object 的起始处</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point2d</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 包含virtual接口，因此Point2的对象中包含vptr</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3d</span> : <span class="keyword">public</span> Point2d &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 包含virtual接口，因此Vertex的对象中包含vptr</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex3d</span> : <span class="keyword">public</span> Point3d， <span class="keyword">public</span> Vertex &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vertex3d v3d;</span><br><span class="line">    Vertex *pv;     </span><br><span class="line">    Point2d *p2d;   </span><br><span class="line">    Point3d *p3d;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    pv = &amp;v3d;      <span class="comment">// 内部转化：pv = (Vertex*)(((char*)&amp;v3d) + sizeof(Point3d));</span></span><br><span class="line">    p2d = &amp;v3d;     <span class="comment">// 无需内部转化</span></span><br><span class="line">    p3d = &amp;v3d;     <span class="comment">// 无需内部转化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    Vertex3d *pv3d;</span><br><span class="line">    Vertex *pv1;</span><br><span class="line"></span><br><span class="line">    pv1 = pv3d;     <span class="comment">// 内部转化：pv1 = pv3d ? (Vertex*)(((char*)&amp;pv3d) + sizeof(Point3d)) : 0;</span></span><br><span class="line">                    <span class="comment">// 对于指针，内部需要有一个条件测试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="105、多重继承下，如果其中有继承一个虚基类，构造函数的调用情况如何？"><a href="#105、多重继承下，如果其中有继承一个虚基类，构造函数的调用情况如何？" class="headerlink" title="105、多重继承下，如果其中有继承一个虚基类，构造函数的调用情况如何？"></a>105、多重继承下，如果其中有继承一个虚基类，构造函数的调用情况如何？</h3><p><strong>只有当一个完整的 class object 被定义出来时，虚基类的构造函数才会被调用；如果 object 只是某个完整 object 的一个 subobject，就不会被调用(即相当于下方例子中 A 的构造函数不会在B 和 C 的实例化过程中被重复调用)。</strong></p>
<p>虚基类的构造函数仅在创建最派生类(即最终实例化的类)对象时才会被调用，而不会在创建其间接派生类对象时重复调用。</p>
<ul>
<li>完整对象(Complete Object)：指一个通过某个类直接实例化出来的对象。</li>
<li>子对象(Subobject)：指一个对象中的组成部分，可能是一个基类子对象或者是一个成员对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123; <span class="keyword">public</span>: <span class="built_in">B</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123; <span class="keyword">public</span>: <span class="built_in">C</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B， <span class="keyword">public</span> C &#123; <span class="keyword">public</span>: <span class="built_in">D</span>() &#123;&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   D d;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>main</code> 函数中创建一个 <strong>D</strong> 类的对象时，会发生以下调用顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A&#x27;s constructor</span><br><span class="line">B&#x27;s constructor</span><br><span class="line">C&#x27;s constructor</span><br><span class="line">D&#x27;s constructor</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A’s constructor：</strong>A 的构造函数首先被调用，因为 A 是一个虚基类。虚基类的构造函数只会在最派生类(即 D)实例化时调用一次。</li>
<li><strong>B’s constructor 和 C’s constructor：</strong>接下来，调用 B 和 C 的构造函数。尽管 B 和 C 都继承自 A，由于虚继承机制，A 的构造函数不会在每个子对象实例化时被重复调用。</li>
<li><strong>D’s constructor：</strong>最后，调用 D 的构造函数。</li>
</ul>
<h3 id="106、public，protect，private-在访问和继承时？"><a href="#106、public，protect，private-在访问和继承时？" class="headerlink" title="106、public，protect，private 在访问和继承时？"></a>106、public，protect，private 在访问和继承时？</h3><ul>
<li><p>在<strong>访问</strong>时：</p>
<ul>
<li><p>public 在类内部和外部均可访问；</p>
</li>
<li><p>protected 在内部可以被访问，外部不可访问；</p>
</li>
<li><p>private 在内部可以被访问，外部不可访问；</p>
</li>
</ul>
</li>
<li><p>在<strong>继承</strong>时：</p>
<ul>
<li>**公有继承(public inheritance)**：<ul>
<li>派生类继承了基类的公有成员和保护成员，但基类的私有成员对派生类不可见。</li>
<li>基类的公有成员在派生类中仍然是公有的。</li>
<li>基类的保护成员在派生类中仍然是保护的。</li>
</ul>
</li>
<li>**保护继承(protected inheritance)**：<ul>
<li>派生类继承了基类的公有成员和保护成员，但基类的私有成员对派生类不可见。</li>
<li>基类的公有成员在派生类中变为保护的。</li>
<li>基类的保护成员在派生类中仍然是保护的。</li>
</ul>
</li>
<li>**私有继承(private inheritance)**：<ul>
<li>派生类继承了基类的公有成员和保护成员，但基类的私有成员对派生类不可见。</li>
<li>基类的公有成员在派生类中变为私有的。</li>
<li>基类的保护成员在派生类中变为私有的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="107、继承的三种方式？"><a href="#107、继承的三种方式？" class="headerlink" title="107、继承的三种方式？"></a>107、继承的三种方式？</h3><ol>
<li><p>**公有继承(public inheritance)**：</p>
<ul>
<li><p>在公有继承中，基类的公有成员和保护成员都会成为派生类的公有成员和保护成员，而基类的私有成员仍然是私有的，不能被派生类直接访问。</p>
</li>
<li><p>公有继承实现了基类到派生类的接口继承，派生类可以使用基类的接口。</p>
</li>
</ul>
</li>
<li><p>**保护继承(protected inheritance)**：</p>
<ul>
<li>在保护继承中，基类的公有成员和保护成员都会成为派生类的保护成员，而基类的私有成员仍然是私有的，不能被派生类直接访问。</li>
<li>保护继承一般用于实现 is-a 关系，但不希望外部直接访问基类的接口，而是通过派生类进行访问。</li>
</ul>
</li>
<li><p>**私有继承(private inheritance)**：</p>
<ul>
<li>在私有继承中，基类的公有成员和保护成员都会成为派生类的私有成员，而基类的私有成员仍然是私有的，不能被派生类直接访问。</li>
<li>私有继承一般用于实现 has-a 关系，派生类可以访问基类的接口，但外部无法直接访问派生类。</li>
</ul>
</li>
</ol>
<h2 id="七、STL相关"><a href="#七、STL相关" class="headerlink" title="七、STL相关"></a>七、STL相关</h2><h3 id="108、C-的-STL-介绍"><a href="#108、C-的-STL-介绍" class="headerlink" title="108、C++ 的 STL 介绍"></a>108、C++ 的 STL 介绍</h3><p>STL ⼀共提供六大组件，包括容器，算法，迭代器，仿函数，配接器和配置器，彼此可以组合套用。容器通过配置</p>
<p>器取得数据存储空间，算法通过迭代器存取容器内容，仿函数可以协助算法完成不同的策略变化，配接器可以应用</p>
<p>于容器、 仿函数和迭代器。</p>
<ul>
<li><strong>容器：</strong>各种数据结构，如 vector，list，deque，set，map，用来存放数据， 从实现的角度来讲是⼀种类模板。</li>
<li><strong>算法：</strong>各种常用的算法，如 sort(插⼊，快排，堆排序)，search(⼆分查找)， 从实现的角度来讲是⼀种方法模板。</li>
<li><strong>迭代器：</strong>从实现的角度来看，迭代器是⼀种将 operator*、operator-&gt;、operator++ 和 operator– 等指针相关操作赋予重载的类模板，所有的 STL 容器都有⾃⼰的迭代器。</li>
<li><strong>仿函数：</strong>从实现的角度看，仿函数是⼀种重载了 operator() 的类或者类模板。 可以帮助算法实现不同的策略。</li>
<li><strong>配接器：</strong>⼀种用来修饰容器或者仿函数或迭代器接口的东⻄。</li>
<li><strong>配置器：</strong>负责空间配置与管理，从实现的角度讲，配置器是⼀个实现了动态空间配置、空间管理，空间释放的类模板。</li>
</ul>
<h3 id="109、STL-中序列式容器的实现"><a href="#109、STL-中序列式容器的实现" class="headerlink" title="109、STL 中序列式容器的实现"></a>109、<strong>STL</strong> <strong>中序列式容器的实现</strong></h3><p>(1)<strong>vector</strong>是动态空间，随着元素的加⼊，它的内部机制会⾃行扩充空间以容纳新元素。vector 维护的是⼀个连续的线性空间，而且普通指针就可以满⾜要求作为 vector 的迭代器(RandomAccessIterator)。vector 的数据结构中其实就是三个迭代器构成的，<strong>⼀个指向目前使用空间头的 iterator，⼀个指向目前使用空间尾的 iterator，⼀个指向目前可用空间尾的 iterator</strong>。当有新的元素插⼊时，如果目前容量够用则直接插⼊，如果容量不够，则容量扩充至两倍，如果两倍容量不⾜， 就扩张至⾜够大的容量。扩充的过程并不是直接在原有空间后⾯追加容量，而是重新申请⼀块连续空间，将原有的数据拷贝到新空间中，再释放原有空间，完成⼀次扩充。需要注意的是，每次扩充是重新开辟的空间，所以扩充后，原有的迭代器将会失效。</p>
<p>(2)<strong>list</strong>，与 vector 相比，list 的好处就是每次插⼊或删除⼀个元素，就配置或释放⼀个空间，而且原有的迭代器也不会失效。STL list 是⼀个双向链表，普通指针已经不能满⾜ list 迭代器的需求，因为 list 的存储空间是不连续的。list 的迭代器必需具备前移和后退功能，所以 list 提供的是 BidirectionalIterator。list 的数据结构中只要⼀个指向 node 节点的指针就可以了。</p>
<p>(3)<strong>deque</strong>，vector 是单向开口的连续线性空间，deque 则是⼀种双向开口的连续线性空间。所谓双向开口，就是说 deque ⽀持从头尾两端进行元素的插⼊和删除操作。相比于 vector 的扩充空间的方式，deque 实际上更加贴切的实现了动态空间的概念。deque 没有容量的概念，因为它是动态地以分段连续空间组合而成，随时可以增加⼀段新的空间并连接起来。由于要维护这种整体连续的假象，并提供随机存取的接口(即也提供 RandomAccessIterator)，避开了“重新配置，复制，释放”的轮回，代价是复杂的迭代器结构。也就是说除⾮必要，我们应该尽可能的使用 vector，而不是 deque。</p>
<p>(4)<strong>stack</strong>是⼀种先进后出的数据结构，只有⼀个出口，stack 允许从最顶端新增元素，移除最顶端元素，取得最顶端元素。deque 是双向开口的数据结构，所以使用 deque 作为底部结构并封闭其头端开口，就形成了⼀个 stack。</p>
<p>(5)<strong>queue</strong>是⼀种先进先出的数据结构，有两个出口，允许从最底端加⼊元素，取得最顶端元素，从最底端新增元素，从最顶端移除元素。deque 是双向开口的数据结构，若以 deque 为底部结构并封闭其底端的出口，和头端的⼊口，就形成了⼀个 queue。(其实 list 也可以实现 deque)</p>
<p>(6)<strong>heap</strong>，堆并不属于 STL 容器组件，它是个幕后英雄，扮演 priority_queue 的助⼿，priority_queue 允许用户以任何次序将任何元素推⼊容器内，但取出时⼀定是从优先权最⾼(数值最⾼)的元素开始取。大根堆(binary max heap)正具有这样的性质，适合作为 priority_queue 的底层机制。</p>
<h3 id="110、vector-使用的注意点及其原因，频繁对-vector-调用-push-back-性能影响"><a href="#110、vector-使用的注意点及其原因，频繁对-vector-调用-push-back-性能影响" class="headerlink" title="110、vector **使用的注意点及其原因，频繁对 **vector 调用 push_back() 性能影响"></a>110、vector **使用的注意点及其原因，频繁对 **vector 调用 push_back() 性能影响</h3><p><strong>（1）使用注意点：</strong></p>
<p>注意插⼊和删除元素后迭代器失效的问题；</p>
<p>清空 vector 数据时，如果保存的数据项是指针类型，需要逐项 delete，否则会造成内存泄漏。</p>
<p><strong>（2）频繁调用 push_back() 的影响：</strong></p>
<p>向 vector 的尾部添加元素，很有可能引起整个对象 存储空间的重新分配，重新分配更大的内存，再将原数据拷贝到新空间中，再释 放原有内存，这个过程是耗时耗⼒的，频繁对 vector 调用 push_back()会导致性能的下降。</p>
<p>在 C++11 之后， vector 容器中添加了新的方法： emplace_back() ，和 push_back() ⼀样的是都是在容器末尾添加⼀个新的元素进去，不同的是 emplace_back() 在效率上相比较于 push_back() 有了⼀定的提升。</p>
<p>emplace_back() 函数在原理上比 push_back() 有了⼀定的改进，包括在内存优化方⾯和运行效率方⾯。内存优化主要体现在使用了<strong>就地构造(直接在容器内构造对象，不用拷贝⼀个复制品再使用)+ 强制类型转换</strong>的方法来实现，在运行效率方⾯，由于省去了拷贝构造过程，因此也有⼀定的提升。</p>
<h3 id="111、map-和-set-有什么区别，分别又是怎么实现的？"><a href="#111、map-和-set-有什么区别，分别又是怎么实现的？" class="headerlink" title="111、map 和 set 有什么区别，分别又是怎么实现的？"></a><strong>111、map</strong> <strong>和</strong> <strong>set</strong> <strong>有什么区别，分别又是怎么实现的？</strong></h3><p>map 和 set 都是 C++ 的关联容器，其底层实现都是红⿊树(RB-Tree)。由于 map 和 set 所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和 set 的操作行为，都只是转调 RB-tree 的操作行为。</p>
<p>map 和 set 区别在于：</p>
<p>(1)map 中的元素是 key-value(关键字—值)对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set 中每个元素只包含⼀个关键字。</p>
<p>(2)set 的迭代器是 const 的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么⾸先需要删除该键，然后调节平衡，再插⼊修改后的键值，调节平衡，如此⼀来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</p>
<p>(3)map⽀持下标操作，set不⽀持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插⼊⼀个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某⼀个关键值是否存在而不希望插⼊元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。</p>
<h3 id="112、STL-中迭代器失效的情况有哪些？"><a href="#112、STL-中迭代器失效的情况有哪些？" class="headerlink" title="112、STL 中迭代器失效的情况有哪些？"></a>112、STL 中迭代器失效的情况有哪些？</h3><p>以 vector 为例：</p>
<p><strong>插入元素：</strong></p>
<p>1、尾后插入：</p>
<ul>
<li>size &lt; capacity时，首迭代器不失效，但尾迭代失效（未重新分配空间）；</li>
<li>size &#x3D;&#x3D; capacity时，所有迭代器均失效（需要重新分配空间）。</li>
</ul>
<p>2、中间插入：</p>
<ul>
<li>size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效；</li>
<li>size &#x3D;&#x3D; capacity时，所有迭代器均失效。</li>
</ul>
<p><strong>删除元素：</strong></p>
<p>1、尾后删除：只有尾迭代失效。</p>
<p>2、中间删除：删除位置之后所有迭代失效。</p>
<blockquote>
<p>deque 和 vector 的情况类似。</p>
<p>而 list 中节点内存不连续，删除节点仅当前迭代器失效，因此 erase 返回下一个有效迭代器;</p>
<p>map&#x2F;set 等关联容器的底层是红黑树，删除节点不会影响其他节点的迭代器，因此使用递增方法获取下一个迭代器 mmp.erase(iter++);</p>
<p>unordered_(hash) 迭代器意义不大，rehash之后，迭代器应该也是全部失效。</p>
</blockquote>
<h3 id="113、请你来说⼀下-STL-中迭代器的作用，有指针为何还要迭代器？"><a href="#113、请你来说⼀下-STL-中迭代器的作用，有指针为何还要迭代器？" class="headerlink" title="113、请你来说⼀下 STL 中迭代器的作用，有指针为何还要迭代器？"></a>113、请你来说⼀下 <strong>STL</strong> <strong>中迭代器的作用，有指针为何还要迭代器</strong>？</h3><p>（1）<strong>迭代器</strong></p>
<p>Iterator(迭代器)模式又称 Cursor(游标)模式，用于提供⼀种方法顺序访问⼀个聚合对象中各个元素，而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator 模式是运用于聚合对象的⼀种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照⼀定顺序(由 iterator 提供的方法)访问聚合对象中的各个元素。</p>
<p>由于 Iterator 模式的以上特性：与聚合对象耦合，在⼀定程度上限制了它的⼴泛运用，⼀般仅用于底层聚合⽀持类，如 STL 的 list、vector、stack 等容器类及 ostream_iterator 等扩展 iterator。</p>
<p>（2）<strong>迭代器和指针的区别</strong></p>
<p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的⼀些功能，通过重载了指针的⼀些操作符<code>-&gt; 、*、++、-- </code>等。迭代器封装了指针，是⼀个“可遍历STL( Standard Template Library)容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的⼀种提升(lift)，提供了比指针更⾼级的行为，相当于⼀种智能指针，他可以根据不同类型的数据结构来实现不同的 ++，– 等操作。迭代器返回的是对象引用而不是对象的值，所以 cout 只能输出迭代器使用<code>*</code>取值后的值而不能直接输出其⾃身。</p>
<p>（3）<strong>迭代器产生原因</strong></p>
<p>Iterator 类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p>
<h3 id="115、STL-里-resize-和-reserve-的区别"><a href="#115、STL-里-resize-和-reserve-的区别" class="headerlink" title="115、STL 里 resize 和 reserve 的区别"></a>115、STL 里 <strong>resize</strong> <strong>和</strong> <strong>reserve</strong> 的区别</h3><p>**resize()**：改变当前容器内含有元素的数量(size())，eg: <code>vectorv; v.resize(len);</code>v 的 size 变为 len，如果原来 v 的 size ⼩于len，那么容器新增(len-size)个元素，元素的值为默认为0.当 <code>v.push_back(3);</code> 之后，则是 3 是放在了 v 的末尾，即下标为 len，此时容器是 size 为 len+1；</p>
<p>**reserve()**：改变当前容器的最大容量(capacity)，它不会生成元素，只是确定这个容器允许放⼊多少对象，如果 reserve(len) 的值大于当前的 capacity()，那么会重新分配⼀块能存 len 个对象的空间，然后把之前 v.size() 个对象通过 copy construtor 复制过来，销毁之前的内存；</p>
<h3 id="116、vector-的扩容原理是怎样的？"><a href="#116、vector-的扩容原理是怎样的？" class="headerlink" title="116、vector 的扩容原理是怎样的？"></a>116、vector 的扩容原理是怎样的？</h3><p>当向 vector 中插入元素时，如果元素有效个数 size 与空间容量 capacity 相等时，vector 内部会触发扩容机制：</p>
<ol>
<li>开辟新空间；</li>
<li>拷贝元素；</li>
<li>释放旧空间。</li>
</ol>
<p>如果要避免扩容而导致程序效率过低问题，其实非常简单：<strong>如果在插入之前，可以预估vector存储元素的个数，提前将底层容量开辟好即可。</strong>如果插入之前进行 reserve，只要空间给足，则插入时不会扩容，如果没有 reserve，则会边插入边扩容，效率极其低下。</p>
<p>一般采用 1.5 倍的方式扩容，这是因为<strong>理想的分配方案是在第 N 次扩容时能复用之前 N-1 次释放的空间。</strong></p>
<ul>
<li>如果倍数<strong>超过2倍(包含2倍)方式</strong>扩容会存在以下问题：1)空间浪费可能会比较高，比如：扩容后申请了64个空间，但只存了33个元素，有接近一半的空间没有使用；2)无法使用到前面已释放的内存；</li>
<li>但是按照<strong>小于2倍方式</strong>扩容，多次扩容之后就可以复用之前释放的空间了**。</li>
</ul>
<p>综上所述，使用 1.5 倍的方式扩容时，在几次扩展以后，可以重用之前的内存空间了。<strong>Linux 下是按照2倍的方式扩容的，而 vs 下是按照1.5倍的方式扩容的</strong>。</p>
<h3 id="117、vector-最大的缺点是什么？"><a href="#117、vector-最大的缺点是什么？" class="headerlink" title="117、vector 最大的缺点是什么？"></a>117、vector 最大的缺点是什么？</h3><p>当 <code>std::vector</code> 的元素数量超过其当前容量时，它需要进行扩容，这通常涉及到申请一个更大的内存块，将现有元素复制到新的内存块中，然后释放原来的内存块。1)在扩容过程中，<strong>新旧两块内存会暂时同时存在</strong>，这可能导致内存使用翻倍，对于内存敏感的应用或在内存受限的环境中，这可能成为一个问题，尤其是当 <code>vector</code> 中存储的对象较大或复制开销较大时；2)同时，<strong>频繁的增加和删除操作可能导致内存碎片</strong>。</p>
<h3 id="118、vector、array-和普通数组的区别是什么？"><a href="#118、vector、array-和普通数组的区别是什么？" class="headerlink" title="118、vector、array 和普通数组的区别是什么？"></a>118、vector、array 和普通数组的区别是什么？</h3><p>(1)<strong>vector</strong> 是动态数组，在进行删除和插入操作时可能需要移动其他元素，内存连续存储，且支持随机访问；</p>
<p>(2)<strong>array</strong> 是静态数组，在编译时确定大小，内存连续存储，且支持随机访问；</p>
<p>(4)<strong>普通数组</strong>在编译时确定大小，且不能直接获取数组的长度，传递数组时，实际上是传递指向数组首元素的指针。</p>
<p>(5)对于一个含有 n 个 int 类型元素的数组 a：</p>
<ul>
<li>如果 <code>a</code> 是一个普通数组，则 <code>sizeof(a)</code> 将返回整个数组的大小，即 <code>n * sizeof(int)</code> 字节。</li>
<li>如果 <code>a</code> 是 <code>std::array&lt;int， n&gt;</code> 类型的对象，则 <code>sizeof(a)</code> 将返回整个 <code>std::array</code> 对象的大小，包括数组的大小信息等。通常情况下，<code>sizeof(std::array&lt;int， n&gt;)</code> 将等于 <code>n * sizeof(int)</code> 字节加上额外的固定大小开销。</li>
</ul>
<h3 id="119、数组和链表的区别是什么？"><a href="#119、数组和链表的区别是什么？" class="headerlink" title="119、数组和链表的区别是什么？"></a>119、数组和链表的区别是什么？</h3><p>(1)数组元素的<strong>个数</strong>是固定的，而链表结点的<strong>个数</strong>可按需增减；</p>
<p>(2)数组元素的<strong>存储单元</strong>在数组定义时分配，而链表结点的<strong>存储单元</strong>在程序执行时动态申请；</p>
<p>(3)数组元素的<strong>顺序关系</strong>由下标确定，而链表结点的<strong>顺序关系</strong>由结点所包含的指针确定；</p>
<p>(4)对于<strong>元素频繁操作的处理场合</strong>，用链表实现会比数组实现更加有效率。比如在数组中删除一个元素时，需要将删除处之后的所有元素全部前移一个位置；但对于链表来说，只需要改变删除处相关结点的指针指向，而与结点实际的存储位置无关。</p>
<h3 id="120、为什么-list-不能用-sort-，而要用自己的-sort-？"><a href="#120、为什么-list-不能用-sort-，而要用自己的-sort-？" class="headerlink" title="120、为什么 list 不能用 ::sort()，而要用自己的 sort()？"></a>120、为什么 list 不能用 ::sort()，而要用自己的 sort()？</h3><p>因为全局 sort() 函数只接受 RandomAccessIterator，但对于 list 来说，由于在 STL 中它是双向链表，指向一块不连续的内存空间，因此其迭代器是 BidirectionIterator，因此必须要用自己的 sort()。</p>
<h3 id="121、数组通过外部声明为指针时，数组和指针是不能互换使用的；那么请思考一下，在-A-文件中定义数组-char-a-100-；在-B-文件中声明为指针：extern-char-a；此时访问-a-i-，会发生什么；"><a href="#121、数组通过外部声明为指针时，数组和指针是不能互换使用的；那么请思考一下，在-A-文件中定义数组-char-a-100-；在-B-文件中声明为指针：extern-char-a；此时访问-a-i-，会发生什么；" class="headerlink" title="121、数组通过外部声明为指针时，数组和指针是不能互换使用的；那么请思考一下，在 A 文件中定义数组 char a[100]；在 B 文件中声明为指针：extern char *a；此时访问 a[i]，会发生什么；"></a>121、数组通过外部声明为指针时，数组和指针是不能互换使用的；那么请思考一下，在 A 文件中定义数组 char a[100]；在 B 文件中声明为指针：extern char *a；此时访问 a[i]，会发生什么；</h3><p>会引起 <strong>segmentation fault</strong> 报错。链接器实际上将数组的首地址赋给了指针本身，而不是我们所希望的把数组的首地址赋予指针 a 所指向的内容。原因在于<strong>使用 extern 修饰的变量在链接的时候只找寻同名的标号，不检查类型，在链接时才进行定位，所以会导致编译通过，运行时出错</strong>。</p>
<p>首先涉及到数组和指针的区别：<strong>可以将数组名看做是右值，而指针作为变量，只能看作为左值。</strong> <strong>右值永远不等于左值，所以将指针赋予数组名是不合法的。即</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>&#125;;  <span class="comment">// 声明一个包含三个整数的数组</span></span><br><span class="line">    <span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]; <span class="comment">// 分配一个新的整数数组，并将其地址赋值给指针</span></span><br><span class="line">    <span class="comment">// 尝试将指针赋值给数组名(不合法)</span></span><br><span class="line">    arr = ptr;</span><br><span class="line">    <span class="keyword">delete</span>[] ptr; <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="122、map-的实现包含哪些方式？具体应该如何选择？"><a href="#122、map-的实现包含哪些方式？具体应该如何选择？" class="headerlink" title="122、map 的实现包含哪些方式？具体应该如何选择？"></a>122、map 的实现包含哪些方式？具体应该如何选择？</h3><ul>
<li><code>std::map</code>：通常使用<strong>红黑树</strong>实现，保证了元素按照键的排序，适合需要有序数据的场景。</li>
<li><code>std::unordered_map</code>：使用<strong>哈希表</strong>实现，不保证元素的有序性，但在许多操作上提供了较快的执行时间。</li>
</ul>
<p>因此，(1)如果应用中需要一个<strong>通过键快速访问数据项且不关心元素间的顺序</strong>的关联容器，<code>std::unordered_map</code> 是一个更好的选择；(2)而如果<strong>需要有序的键值对</strong>，维护元素的插入顺序，或需要进行范围查询，那么 <code>std::map</code> 是更合适的选择。</p>
<h3 id="123、map-的插入方式有几种？"><a href="#123、map-的插入方式有几种？" class="headerlink" title="123、map 的插入方式有几种？"></a>123、map 的插入方式有几种？</h3><ol>
<li>用 insert 函数插入 pair 数据，</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>)); </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>用 insert 函数插入 value_type 数据</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mapStudent.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 insert 函数中使用 make_pair() 函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>)); </span><br></pre></td></tr></table></figure>

<ol start="4">
<li>用数组方式插入数据</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mapStudent[<span class="number">1</span>] = <span class="string">&quot;student_one&quot;</span>; </span><br></pre></td></tr></table></figure>

<h3 id="124、C-常见的容器有哪些，可以分成几大类？"><a href="#124、C-常见的容器有哪些，可以分成几大类？" class="headerlink" title="124、C++ 常见的容器有哪些，可以分成几大类？"></a>124、C++ 常见的容器有哪些，可以分成几大类？</h3><ol>
<li>**顺序容器(Sequence Containers)**：元素按照它们在容器中的位置顺序排列，包括：vector、deque、list、forward_list 和 array。</li>
<li>**关联容器(Associative Containers)**：元素按照某种顺序存储，并且支持高效的查找操作，包括：set、multiset、map 和 multimap。</li>
<li>**无序容器(Unordered Containers)**：元素无特定顺序排列，但支持快速的插入、删除和查找操作，包括：unordered_set、unordered_multiset、unordered_map 和 unordered_multimap。</li>
<li>**容器适配器(Container Adapters)**：容器适配器是在底层容器基础上提供了不同接口的封装，包括：stack、queue 和 priority_queue。</li>
</ol>
<h3 id="125、STL-的两级空间配置器相关"><a href="#125、STL-的两级空间配置器相关" class="headerlink" title="125、STL 的两级空间配置器相关"></a>125、STL 的两级空间配置器相关</h3><p><strong>1、为什么需要二级空间配置器？</strong></p>
<p>动态开辟内存时要在堆上申请，但若是我们需要频繁的在堆开辟释放内存，则就会<strong>在堆上造成很多外部碎片</strong>，浪费了内存空间；每次都要进行调用<strong>malloc、free</strong>函数等操作，使空间就会增加一些附加信息，降低了空间利用率；随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。于是就设置了二级空间配置器，<strong>当开辟内存&lt;&#x3D;128bytes时，即视为开辟小块内存，则调用二级空间配置器。</strong></p>
<p>关于STL中一级空间配置器和二级空间配置器的选择上，一般默认<strong>选择的为二级空间配置器</strong>。 如果大于128字节再转去一级配置器器。</p>
<p>（1）一级配置器</p>
<p><strong>一级空间配置器</strong>中重要的函数就是 allocate、deallocate、reallocate。 一级空间配置器是以 malloc()，free()，realloc() 等 C 函数执行实际的内存配置 。</p>
<img src="http://oss.interviewguide.cn/img/202205220035143.png" alt="img" style="zoom: 67%;" />

<p>（2）二级配置器</p>
<img src="http://oss.interviewguide.cn/img/202205220035104.png" alt="img" style="zoom:67%;" />

<h2 id="八、类-设计模式"><a href="#八、类-设计模式" class="headerlink" title="八、类&#x2F;设计模式"></a>八、类&#x2F;设计模式</h2><h3 id="126、传值和传引用应该如何选择？"><a href="#126、传值和传引用应该如何选择？" class="headerlink" title="126、传值和传引用应该如何选择？"></a>126、传值和传引用应该如何选择？</h3><ol>
<li><p>从执行效率上来讲，传引用要优于传值，原因在于传值的时候可能会调用传参类型的构造函数，造成额外开销；</p>
</li>
<li><p>此外，当一个派生类对象被以传值的方式传递且被视为基类对象时，基类的拷贝函数会被调用，此时派生类的一些特异功能会被切割。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBase</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;CBase::func1&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSon1</span> : <span class="keyword">public</span> CBase &#123;</span><br><span class="line">    ......</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;CSon1::func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hostFunc</span><span class="params">(CBase exp)</span> </span>&#123; exp.<span class="built_in">func1</span>(); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CSon1 son1;</span><br><span class="line">    <span class="built_in">hostFunc</span>(son1);  <span class="comment">// CBase::func1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="127、什么是单例模式？"><a href="#127、什么是单例模式？" class="headerlink" title="127、什么是单例模式？"></a>127、什么是单例模式？</h3><p>单例模式指在整个系统生命周期里，保证一个类只能产生一个实例，确保该类的<strong>唯一性</strong>。</p>
<ol>
<li><p><strong>分类：</strong>单例模式可以分为<strong>懒汉式和饿汉式</strong>，两者之间的区别在于<strong>创建实例的时间不同</strong>：</p>
<ul>
<li><p>懒汉式：指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。(这种方式要考虑线程安全)</p>
</li>
<li><p>饿汉式：指系统一运行，就初始化创建实例，当需要时，直接调用即可。(本身就线程安全，没有多线程的问题)</p>
</li>
</ul>
</li>
<li><p><strong>特点：</strong></p>
<ul>
<li>构造函数和析构函数为 <strong>private</strong> 类型，<strong>禁止</strong>外部构造和析构；</li>
<li>拷贝构造和赋值构造函数为 <strong>private</strong> 类型，<strong>禁止</strong>外部拷贝和赋值，确保实例的唯一性；</li>
<li>类里有个获取实例的<strong>静态函数</strong>，可以全局访问。</li>
</ul>
</li>
</ol>
<h3 id="128、怎么保证单例线程安全？"><a href="#128、怎么保证单例线程安全？" class="headerlink" title="128、怎么保证单例线程安全？"></a>128、怎么保证单例线程安全？</h3><ol>
<li><strong>懒汉式进行加锁处理</strong>，在第一次使用单例实例时进行初始化，并通过加锁保证线程安全。这种方法虽然线程安全，但每次获取实例时都需要加锁，效率较低。<ul>
<li>可以通过减少加锁的次数来提高效率，即<strong>双重检查锁定</strong>。在第一次检查时，如果实例已经创建，直接返回实例；如果实例尚未创建，再加锁并进行第二次检查，防止在加锁之前有其他线程已经创建了实例。<ul>
<li>在 C++11 及以上版本中是安全的，但在早期的 C++ 版本中可能会有问题：<ul>
<li>(1)内存模型问题。早期的C++标准中，没有定义明确的内存模型，不同的编译器和平台可能会有不同的内存访问顺序。这意味着在多线程环境中，某个线程在没有获取锁的情况下，可能会看到一个未完全构造的对象；</li>
<li>(2)编译器优化问题。编译器可能会对代码进行优化，导致指令重排。例如，编译器可能会将对象的指针赋值操作和对象的构造操作重排，使得其他线程在对象完全构造之前就能看到非空指针。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>直接采用饿汉式</strong>，其本身就是线程安全的，在程序启动时就创建单例实例，这样可以避免线程同步问题，但可能会导致程序启动时间增加。</li>
<li><strong>C++11 局部静态变量</strong><ul>
<li>C++11 之后，可以利用函数内的静态变量的线程安全特性来实现单例模式。</li>
</ul>
</li>
</ol>
<h3 id="129、写一个线程安全的单例模式"><a href="#129、写一个线程安全的单例模式" class="headerlink" title="129、写一个线程安全的单例模式"></a>129、写一个线程安全的单例模式</h3><p>详见文档。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406252102208.png" alt="image-20240625210242913"></p>
<h3 id="130、组合是什么概念？"><a href="#130、组合是什么概念？" class="headerlink" title="130、组合是什么概念？"></a>130、组合是什么概念？</h3><p>**组合(Composition)**是指一个类包含另一个类的对象作为其成员，表示“拥有”的关系。</p>
<h3 id="131、C-11-中比较安全的类型转换有哪些？四种类型转换用于哪些场合？dnaymic-cast-用在什么地方？父类向子类转换还是子类向父类转换？"><a href="#131、C-11-中比较安全的类型转换有哪些？四种类型转换用于哪些场合？dnaymic-cast-用在什么地方？父类向子类转换还是子类向父类转换？" class="headerlink" title="131、C++11 中比较安全的类型转换有哪些？四种类型转换用于哪些场合？dnaymic_cast 用在什么地方？父类向子类转换还是子类向父类转换？"></a>131、<strong>C++11 中比较安全的类型转换有哪些？四种类型转换用于哪些场合？dnaymic_cast 用在什么地方？父类向子类转换还是子类向父类转换？</strong></h3><p>C++11 中四种强制转换 reinterpret_cast &#x2F; const_cast &#x2F; static_cast &#x2F; dynamic_cast。</p>
<ol>
<li><p><strong>reinterpret_cast：</strong><code>reinterpret_cast&lt;type-id&gt; (expression)</code></p>
<p>reinterpret 是“重新诠释”的意思，reinterpret_cast整体的意思就是 “重新解释的转型”。type-id 必须是一个指针、引用、算术类型、函数指针或成员指针。它可以用于类型之间进行类型转换。</p>
</li>
<li><p><strong>const_cast</strong>：<code>const_cast&lt;type-id&gt;(expression)</code></p>
<p>该运算符用来修改类型的 const 或 volatile 属性。除了 const 和 volatile 修饰之外，type-id 和 expression 的类型是一样的。用法如下：</p>
<ul>
<li>常量指针被转化成非常量的指针，并且仍然指向原来的对象。</li>
<li>常量指针被转换成非常量的引用，并且仍然指向原来的对象。</li>
<li>const_cast 一般用于修改底指针，如 const char* p 形式。</li>
</ul>
</li>
<li><p><strong>static_cast</strong>：<code>static_cast&lt;type-id&gt;(expression)</code></p>
<p>该运算符把 expression 转换成 type-id 类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几个用法：</p>
<ul>
<li>用于类层次结构中基类和派生类之间指针或引用的转换。<ul>
<li>进行上行转换(把派生类的指针或引用转换成基类表示)是安全的。</li>
<li>进行下行转换(把基类指针或引用转换成派生类表示)时，由于没有动态类型检查，所以是不安全的。</li>
</ul>
</li>
<li>用于基本类型数据之间的转换，如把 int 转换成 char，把 int 转换成 enum。这种转换也要开发人员进行保证。</li>
<li>把空指针转换成目标类型的空指针。</li>
<li>把任何类型的表达式转换成 void 类型。</li>
</ul>
</li>
</ol>
<p><strong>注意：static_cast 不能转换成 experssion 的 const、volatile、或者 __unaligned 属性。</strong></p>
<ol start="4">
<li><p><strong>dynamic_cast：</strong><code>dynamic_cast(expression)</code></p>
<p>有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全。该运算符把 expression 转换成 type-id 类型的对象。type-id 必须是类的指针、类的引用或者 void*。如果 type-id 是类指针类型，那么 expression 也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用。</p>
<p>dynamic_cast 运算符可以在执行期间决定真正的类型，也就是说 experssion 必须是多态类型。如果下行转换是安全的(也就是说，如果基类指针或引用确实指向一个派生类对象)这个运算符会传回适当转型过的指针。如果下行转换不安全，这个运算符会传回空指针(就是说，基类指针或者引用没有指向一个派生类对象。)</p>
<p>在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的。在进行下行转换时，dynamic_cast 具有类型检查功能，比 static_cast 更安全。</p>
</li>
</ol>
<h2 id="九、内存相关"><a href="#九、内存相关" class="headerlink" title="九、内存相关"></a>九、内存相关</h2><h3 id="132、简要说明-C-的内存分区？"><a href="#132、简要说明-C-的内存分区？" class="headerlink" title="132、简要说明 C++ 的内存分区？"></a>132、简要说明 C++ 的内存分区？</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301608580.png" alt="image-20240630160851505"></p>
<p><strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</p>
<p><strong>堆</strong>：就是那些由 <code>new</code>分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个<code>new</code>就要对应一个 <code>delete</code>。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</p>
<p><strong>自由存储区</strong>：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，自由存储区和堆比较像，但不等价。</p>
<p><strong>全局&#x2F;静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</p>
<p><strong>常量存储区</strong>：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改</p>
<p><strong>代码区</strong>：存放函数体的二进制代码、</p>
<blockquote>
<p>对于一个类来说，类对象的大小和对象中数据成员的大小一致。也就是说，成员函数不占用对象的内存，而是存放在<strong>代码区</strong>。并且注意：<strong>静态成员函数与一般成员函数的唯一区别就是没有 this 指针，其同样存在在代码区</strong>。</p>
</blockquote>
<h3 id="133、什么是内存泄漏-内存溢出？"><a href="#133、什么是内存泄漏-内存溢出？" class="headerlink" title="133、什么是内存泄漏&#x2F;内存溢出？"></a>133、什么是内存泄漏&#x2F;内存溢出？</h3><ol>
<li><strong>内存溢出(Memory Overflow)</strong></li>
</ol>
<p>(1)指程序在执行过程中，请求分配的内存超过了系统所能提供的内存大小或者进程所能使用的内存大小。这通常会导致程序崩溃或异常终止。内存溢出的原因可能包括：</p>
<ul>
<li><strong>申请内存过多：</strong> 程序中申请了大量的动态内存，但未正确释放，导致内存耗尽；<ul>
<li>要解决这个问题，需要在动态内存分配后适时释放已申请的内存。可以使用<code>delete</code>或<code>delete[]</code>来释放单个对象或数组，或者考虑使用智能指针等RAII(资源获取即初始化)的技术来自动管理内存。</li>
</ul>
</li>
<li><strong>递归调用导致栈溢出：</strong> 如果递归调用的层数过深，会导致函数调用栈溢出；<ul>
<li>可以考虑使用迭代替代递归，或者优化算法以减少递归的深度。另外，可以通过增加栈空间的方式来缓解栈溢出的问题，但这种方法并不是根本性的解决办法，因为栈空间是有限的。在实际开发中，需要注意避免递归调用的层数过深，以及使用合适的算法和数据结构来避免栈溢出问题。</li>
</ul>
</li>
<li><strong>数据结构设计不当：</strong> 如果数据结构设计不合理，可能会导致内存的过度分配或者冗余分配；</li>
</ul>
<p>(2)分类：</p>
<ul>
<li><p><strong>堆内存泄漏</strong>：堆内存是指通过 malloc，new 等从堆中分配出来的内存，如果这部分内存没有通过 free 或者 delete 进行释放，那么就会造成堆内存泄漏；</p>
</li>
<li><p><strong>系统资源泄漏</strong>：主要是指系统分配的资源，比如套接字，文件描述符等，没有使用相应的函数释放掉，导致系统资源的浪费。</p>
</li>
</ul>
<p>(3)解决方法：</p>
<ul>
<li><p><strong>仔细管理内存分配和释放：</strong> 确保每次申请内存后都有相应的释放操作；</p>
</li>
<li><p><strong>使用静态分析工具：</strong> 使用工具来检测代码中潜在的内存泄漏或者内存溢出问题。</p>
<ul>
<li><p>Cppcheck </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cppcheck --<span class="built_in">enable</span>=all --inconclusive your_file.cpp</span><br></pre></td></tr></table></figure>
</li>
<li><p>Valgrind </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -g your_file.cpp -o your_program</span><br><span class="line">valgrind --leak-check=full ./your_program</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>优化算法和数据结构：</strong> 确保使用高效的算法和数据结构，避免不必要的内存占用。</p>
</li>
<li><p><strong>限制资源使用：</strong> 设置适当的资源使用限制，防止程序过度消耗内存。</p>
</li>
</ul>
<ol start="2">
<li><strong>内存泄漏(Memory Leak)</strong></li>
</ol>
<p>(1)指程序中分配的内存未能被释放，导致系统中有大量无法访问的内存块，最终耗尽系统内存资源。</p>
<ul>
<li><strong>未释放动态分配的内存：</strong> 程序中分配的内存未被释放，导致内存泄漏；</li>
<li><strong>循环引用：</strong> 对象之间存在循环引用，导致垃圾回收器无法释放内存；</li>
</ul>
<p>(2)解决方法：</p>
<ul>
<li><strong>使用智能指针</strong>： 智能指针通过自动管理对象的生命周期来解决内存泄漏问题。</li>
<li><strong>使用内存分析工具</strong>： 使用内存分析工具来检测程序中的内存泄漏问题，并定位到具体的代码位置。</li>
<li><strong>合理设计数据结构</strong>： 避免循环引用等设计上的问题，确保对象能够被垃圾回收器正确释放。</li>
<li><strong>及时清理缓存</strong>： 确保缓存中的对象在不再需要时能够及时清理，防止对象长时间占用内存。</li>
</ul>
<h3 id="134、智能指针怎么解决内存泄漏？"><a href="#134、智能指针怎么解决内存泄漏？" class="headerlink" title="134、智能指针怎么解决内存泄漏？"></a>134、智能指针怎么解决内存泄漏？</h3><p>智能指针通过自动管理对象的生命周期来解决内存泄漏问题。</p>
<ul>
<li><strong>自动释放资源</strong>：智能指针在超出作用域或被重置时，会自动调用其管理对象的析构函数，释放内存。</li>
<li><strong>防止悬挂指针</strong>：通过确保对象在指针超出作用域时销毁，智能指针防止了悬挂指针的产生。</li>
<li><strong>引用计数管理</strong>：<code>std::shared_ptr</code>使用引用计数来跟踪所有权，确保对象只有在最后一个<code>shared_ptr</code>销毁时才会被释放。</li>
</ul>
<h3 id="135、C-对象的大小由哪些因素决定？"><a href="#135、C-对象的大小由哪些因素决定？" class="headerlink" title="135、C++ 对象的大小由哪些因素决定？"></a>135、C++ 对象的大小由哪些因素决定？</h3><p>(1)变量的类型和大小；</p>
<p>(2)内存对齐和填充；</p>
<p>(3)虚函数所带来的开销；</p>
<p>(4)空类优化。</p>
<h3 id="136、说一下你对于内存对齐的理解？"><a href="#136、说一下你对于内存对齐的理解？" class="headerlink" title="136、说一下你对于内存对齐的理解？"></a>136、说一下你对于内存对齐的理解？</h3><p>内存对齐是指对于特定类型的数据规定了其应该位于内存的哪个位置上。比如，对于int类型的数据，在32系统上要求其内存对齐为4个字节，也就是说其起始地址应该为4的倍数。</p>
<p>内存对齐的目的是为了提高内存访问的效率。因为在许多硬件平台上，访问对齐的内存要比访问不对齐的内存更快。</p>
<h3 id="137、内存对齐可能会带来哪些问题？"><a href="#137、内存对齐可能会带来哪些问题？" class="headerlink" title="137、内存对齐可能会带来哪些问题？"></a>137、内存对齐可能会带来哪些问题？</h3><p>(1)可能会造成内存浪费问题。虽然内存对齐后其内存访问速度会大幅提升，但随之而来的可能会造成一些内存浪费现象。</p>
<p>(2)可能存在平台不兼容的问题。不同类型的数据在不同的平台上可能有不能的内存对齐规则。</p>
<h3 id="138、什么方式可以不对齐内存，什么方式可以指定内存对齐大小？"><a href="#138、什么方式可以不对齐内存，什么方式可以指定内存对齐大小？" class="headerlink" title="138、什么方式可以不对齐内存，什么方式可以指定内存对齐大小？"></a>138、什么方式可以不对齐内存，什么方式可以指定内存对齐大小？</h3><p>(1)在C语言中，可以通过指针类型转换实现对任意内存地址的访问，从而实现不对齐的内存访问。例如，可以将一个地址强制转换为一个指针类型，然后通过该指针访问数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> data[] = &#123;<span class="number">0x00</span>， <span class="number">0x01</span>， <span class="number">0x02</span>， <span class="number">0x03</span>， <span class="number">0x04</span>&#125;;</span><br><span class="line">    <span class="comment">// 假设我们需要访问从地址 &amp;data[1] 开始的一个整数，不考虑对齐</span></span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)(data + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>， *p); <span class="comment">// 可能会导致性能下降或在某些硬件上引发错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)GCC和Clang等编译器支持<code>__attribute__((aligned(N)))</code>来指定内存对齐。</p>
<p>(3)#pragma pack(1)</p>
<p>但要注意，即使使用了 <code>#pragma pack(1)</code>，在多重继承的情况下，仍然需要进行对齐填充以满足基类的对齐要求。</p>
<h3 id="139、C-内存同步方式？"><a href="#139、C-内存同步方式？" class="headerlink" title="139、C++ 内存同步方式？"></a>139、C++ 内存同步方式？</h3><ol>
<li>**互斥锁(Mutex)**：互斥锁用于保护临界区，确保同一时间只有一个线程可以访问共享资源。当一个线程获取了互斥锁后，其他线程需要等待锁被释放才能继续执行。常见的互斥锁有 std::mutex、std::lock_guard 和 std::unique_lock。</li>
<li>**信号量(Semaphore)**：信号量是一个计数器，用于控制多个线程对共享资源的访问。信号量包括两种类型：二进制信号量(只能取值 0 或 1)和计数信号量(可以取任意非负整数值)。常见的信号量有 std::binary_semaphore(C++20 中引入)和操作系统提供的信号量。</li>
<li>**条件变量(Condition Variable)**：条件变量允许线程在满足特定条件时挂起等待，在条件满足时被唤醒继续执行。条件变量通常与互斥锁一起使用，以确保在修改共享数据时不会出现竞态条件。常见的条件变量有 std::condition_variable 和 std::condition_variable_any。</li>
<li>**屏障(Barrier)**：屏障用于在多个线程中的所有线程都到达某个点时进行同步，然后继续执行。一旦所有线程都到达屏障点，它们就会全部释放，继续执行后续操作。常见的屏障有 std::barrier(C++20 中引入)。</li>
<li>**原子操作(Atomic Operation)**：原子操作是一种保证不会被中断的操作，可以确保多个线程同时对共享变量进行读取、修改和写入操作时的一致性。常见的原子操作有 std::atomic 和 C++11 中引入的原子操作函数。</li>
<li>**读写锁(Reader-Writer Lock)**：读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。当有线程在写入时，其他线程无法读取或写入，但可以等待。常见的读写锁有 std::shared_mutex(C++17 中引入)。</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
        <category>八股</category>
      </categories>
  </entry>
  <entry>
    <title>数据库1_MySQL数据库</title>
    <url>/2024/04/06/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%931_MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="1、MySQL简介"><a href="#1、MySQL简介" class="headerlink" title="1、MySQL简介"></a>1、MySQL简介</h1><p>MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
<p><strong>其数据通常存储在磁盘中，但也会使用缓存将一部分数据存储在内存中，以提高访问速度。</strong></p>
<h2 id="（1）架构逻辑"><a href="#（1）架构逻辑" class="headerlink" title="（1）架构逻辑"></a>（1）架构逻辑</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404061034387.png" alt="MySQL逻辑架构"></p>
<p>MySQL的逻辑架构大致可以分为三层：客户端、Server层和存储引擎层。</p>
<ul>
<li><p>客户端（服务器层）：主要做连接处理、授权认证和安全保障等。</p>
</li>
<li><p>Server层：涵盖了 MySQL 大多数核心服务功能，包括查询解析、分析、优化、缓存以及所有内置函数（例如：日期，时间，数学和加密函数等）。存储过程，触发器，视图等跨存储引擎的功能也都在这一层实现。</p>
</li>
<li><p>Server 层基本组件：</p>
<ul>
<li><p><strong>连接器</strong>：我们使用数据库，第一步是连接到数据库。而连接器负责跟客户端建立连接、获取权限、维持和管理连接；</p>
</li>
<li><p><strong>查询缓存</strong>：执行查询语句的时候，会先查询缓存，校验 SQL 是否执行过，如果有 SQL 的缓存，直接返回给客户端，如果没有命中，执行后续的操作；（MySQL 8.0 版本删除）</p>
</li>
<li><p><strong>分析器</strong>：没有命中缓存的话，SQL 语句就会经过分析器，主要分为两步，词法分析和语法分析，先看 SQL 语句要做什么，再检查 SQL 语句语法是否正确；</p>
</li>
<li><p><strong>优化器</strong>：优化器对查询进行优化，包括重写查询、决定表的读写顺序以及选择合适的索引等，生成执行计划，优化器主要做的操作包括：</p>
<ul>
<li>表里面有多个索引的时候，决定使用哪个索引；</li>
<li>一个语句有多表关联（join）的时候，决定各个表的连接顺序；</li>
</ul>
</li>
<li><p><strong>执行器</strong>：首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会根据执行计划去调用引擎的接口，返回结果。</p>
</li>
</ul>
</li>
<li><p><strong>存储引擎层</strong>：主要负责数据的存储和提取，Server层通过 API 与存储引擎层进行交互。服务器通过 API 与存储引擎通信，这些接口屏蔽了不同存储引擎的差异，使得差异对上层查询过程透明。除了会解析外键定义的 InnoDB 外，存储引擎不会解析 SQL，不同存储引擎之间也不会相互通信，只是简单响应上层服务器请求。</p>
</li>
</ul>
<h1 id="2、面试提问"><a href="#2、面试提问" class="headerlink" title="2、面试提问"></a>2、面试提问</h1><h2 id="（1）为什么MySQL使用B-树索引？"><a href="#（1）为什么MySQL使用B-树索引？" class="headerlink" title="（1）为什么MySQL使用B+树索引？"></a>（1）为什么MySQL使用B+树索引？</h2><p>B树是一种自平衡的多路搜索树，每个节点可以包含多个关键字和对应的指针，即B树的每个节点都会存储数据，B树的叶子节点之间是无指针相连接的。因此当读取叶子节点的数据时，只能通过父节点进行多次磁盘I&#x2F;O才能实现。</p>
<p>B+树也是一种自平衡的多路搜索树，所有关键字都存储在叶子节点上，非叶子节点只存储索引列和指向子节点的指针。叶子节点通过指针连接起来，形成一个有序的链表，可以支持顺序访问和范围查询。这样就带来了以下好处：</p>
<ul>
<li>范围查询效率高；</li>
<li>顺序访问性能好；</li>
<li>更少的磁盘I&#x2F;O；</li>
<li>内存友好。</li>
</ul>
<h2 id="（2）MySQL的慢查询如何优化"><a href="#（2）MySQL的慢查询如何优化" class="headerlink" title="（2）MySQL的慢查询如何优化"></a>（2）MySQL的慢查询如何优化</h2><p>针对SQL慢查询，可以考虑以下一些优化措施：</p>
<ol>
<li><strong>优化查询语句结构：</strong>检查是否存在冗余的操作、重复的子查询、不必要的排序、大量的JOIN操作等。优化查询语句的结构和逻辑，减少不必要的数据读取和计算。</li>
<li><strong>添加合适的索引：</strong>确保查询中涉及的列都有适当的索引，并且查询条件能够充分利用索引。通过使用适当的索引，提高查询的性能。但是要避免过多的索引，因为过多的索引会增加写入操作的开销。</li>
<li><strong>数据库表优化：</strong>对于频繁查询的表，考虑进行分库或分表操作，将数据分散存储，提高查询效率。</li>
<li><strong>优化数据库配置：</strong>根据服务器的硬件资源和应用需求，调整MySQL的配置参数，如缓冲区大小、并发连接树、查询缓存等。</li>
<li><strong>使用缓存技术：</strong>对于一些相对稳定的查询结果，考虑使用缓存技术，如Redis、Memcached等，减少对数据库的访问。</li>
</ol>
<h2 id="（3）索引的设计原则"><a href="#（3）索引的设计原则" class="headerlink" title="（3）索引的设计原则"></a>（3）索引的设计原则</h2><ol>
<li>选择适当的列进行索引：选择那些经常被用于查询条件、连接操作和排序的列进行索引；</li>
<li><strong>考虑查询类型：</strong>根据常见的查询模式和性能需求，选择合适的索引类型。如范围查询选择B树索引；全文搜索选择全文索引；</li>
<li><strong>避免过多的索引：</strong>过多的索引会增加写操作的开销，占用存储空间；</li>
<li><strong>注意索引的维护成本：</strong></li>
<li><strong>联合索引的使用：</strong>联合索引可以包含多个列，通过多个列的组合来创建索引。在创建联合索引时，需要根据查询的频率和顺序选择合适的列顺序，将最常用的列放在前面可以提高索引的效果。</li>
</ol>
<h2 id="（4）什么是索引？索引有哪些优缺点？"><a href="#（4）什么是索引？索引有哪些优缺点？" class="headerlink" title="（4）什么是索引？索引有哪些优缺点？"></a>（4）什么是索引？索引有哪些优缺点？</h2><p>索引是数据库中用于提高数据检索性能的排好序的数据结构。它类似于书籍的目录，通过建立特定的数据结构将列或多个列的值与它们在数据表中对应的行关联起来，以加快查询速度。</p>
<p>索引的优点包括：</p>
<ol>
<li>提高查询性能：索引可以加快数据库查找数据的速度，通过快速定位到符合查询条件的数据行，减少了数据库进行全表扫描的开销，从而显著提高查询效率。</li>
<li>唯一性约束：通过在索引上设置唯一性约束，可以确保数据的唯一性，防止重复数据的插入。</li>
</ol>
<p>然而，索引也有一些缺点：</p>
<ol>
<li>占用存储空间：索引通常需要占用一定的磁盘空间。过多的索引可能会增加存储成本。</li>
<li>索引维护的开销：当对数据表进行插入、更新或删除操作时，索引也需要进行相应的维护操作，这可能导致数据写入的性能下降，更新缓慢。</li>
</ol>
<h2 id="（5）索引分类"><a href="#（5）索引分类" class="headerlink" title="（5）索引分类"></a>（5）索引分类</h2><p>在MySQL中，索引按照索引列的类型可以分为以下几种：</p>
<ul>
<li><strong>主键索引：</strong>用于唯一标识每一条记录，主键索引的值不允许重复且不能为空，并且一个表只能有一个主键索引。</li>
<li><strong>唯一索引：</strong>用于保证索引列的值唯一，允许为空值，但是一个表可以有多个唯一索引。</li>
<li><strong>普通索引：</strong>没有唯一性限制，允许重复值和空值，是最基本的索引类型。</li>
<li><strong>组合索引：</strong>在多个字段上创建的索引，可以包含多个列。组合索引可以提高多列查询的性能，但查询条件必须符合最左前缀原则，即查询从左到右使用组合索引中的列。</li>
</ul>
<h2 id="（6）什么是最左前缀原则？"><a href="#（6）什么是最左前缀原则？" class="headerlink" title="（6）什么是最左前缀原则？"></a>（6）什么是最左前缀原则？</h2><p><strong>最左前缀原则（Leftmost Prefix Rule）</strong>是索引在数据库查询中的一种使用规则。它指的是在使用复合索引时，索引的最左边的连续几个列会被用于查询过滤条件的匹配。</p>
<p>具体来说，如果在表中创建了一个复合索引，包含多个列 A、B、C，那么最左前缀原则要求查询中的过滤条件必须从索引的最左边开始，并且不能跳过中间的列。只有当查询中的过滤条件与索引的最左前缀完全匹配时，索引才能被充分利用。</p>
<p>例如，考虑以下复合索引 (A, B, C) 和查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> A <span class="operator">=</span> <span class="string">&#x27;value1&#x27;</span> <span class="keyword">AND</span> C <span class="operator">=</span> <span class="string">&#x27;value2&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，最左前缀原则要求查询条件中必须包含列 A，而不能直接使用列 C 进行过滤。因为只有满足最左前缀条件，索引 (A, B, C) 才能被有效地使用。</p>
<p>遵循最左前缀原则的好处包括：</p>
<ol>
<li><p>提高查询性能：通过使用索引的最左前缀，可以最大限度地减少索引扫描的数据量，提高查询的效率和响应时间。</p>
</li>
<li><p>减少索引占用空间：在某些情况下，使用最左前缀原则可以减少创建多个索引的需求，节省磁盘空间和索引维护的开销。</p>
</li>
</ol>
<h2 id="（7）什么是索引覆盖？"><a href="#（7）什么是索引覆盖？" class="headerlink" title="（7）什么是索引覆盖？"></a>（7）什么是索引覆盖？</h2><p>覆盖索引是指一个索引包含了查询所需的所有列，而无需访问表的实际数据页。</p>
<p>当数据库系统执行查询时，通常需要从磁盘中读取数据页到内存中才能进行处理。而如果使用了覆盖索引，由于索引已经包含了查询所需的所有列的值，数据库系统可以直接通过索引来获取这些值，而不需要额外地读取数据页。这样可以减少磁盘 I&#x2F;O 的次数和数据在内存中的占用，提高查询的效率。</p>
<p>覆盖索引通常适用于以下场景：</p>
<ol>
<li><p>查询语句只需要返回索引列中的数据，而不需要访问其他列的值。</p>
</li>
<li><p>查询语句中的条件过滤、排序或分组的列都在同一个索引上。</p>
</li>
</ol>
<h2 id="（8）聚簇索引和非聚簇索引的区别是什么？"><a href="#（8）聚簇索引和非聚簇索引的区别是什么？" class="headerlink" title="（8）聚簇索引和非聚簇索引的区别是什么？"></a>（8）聚簇索引和非聚簇索引的区别是什么？</h2><p><strong>聚簇索引</strong>也被成为主键索引，它是一种特殊类型的索引，用于存储表中的数据记录。</p>
<p><strong>非聚簇索引</strong>用于存储对表中数据记录的引用地址。</p>
<p>区别：</p>
<ol>
<li>存储方式不同：聚簇索引存储数据记录，非聚簇索引存储对数据记录的引用地址；</li>
<li>查询速度不同：聚簇索引的查询速度快于非聚簇索引；</li>
<li>内存占用不同：聚簇索引占用更多的内存；</li>
<li>索引更新速度不同：由于聚簇索引存储的是数据记录，因此当数据记录发生变化时，需要重构整个索引，更新速度相对较慢；而非聚簇索引只需要修改对数据记录的引用地址，因此更苏速度较快。</li>
</ol>
<h2 id="（9）索引失效的场景有哪些？"><a href="#（9）索引失效的场景有哪些？" class="headerlink" title="（9）索引失效的场景有哪些？"></a>（9）索引失效的场景有哪些？</h2><ol>
<li>当查询中涉及的列<strong>没有被索引</strong>时，索引将不会被使用。</li>
</ol>
<ul>
<li><ul>
<li>例如，<code>SELECT * FROM users WHERE age = 25</code>，如果<code>age</code>列没有被索引，索引就不会被使用。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>在索引列上<strong>使用函数或表达式</strong>会导致索引失效。</li>
</ol>
<ul>
<li><ul>
<li>例如，<code>SELECT * FROM users WHERE YEAR(birth_date) = 1990</code>，即使<code>birth_date</code>被索引，使用<code>YEAR()</code>函数也会使索引失效。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>当使用<code>LIKE</code>操作符，并且<strong>模式以通配符开始</strong>时，索引将不被使用。</li>
</ol>
<ul>
<li><ul>
<li>例如，<code>SELECT * FROM users WHERE name LIKE &#39;%Smith&#39;</code>；但<code>LIKE &#39;Smith%&#39;</code>可以使用索引。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>如果查询中有<strong>隐式类型转换</strong>，可能导致索引失效。</li>
</ol>
<ul>
<li><ul>
<li>例如，<code>SELECT * FROM users WHERE string_column = 123</code>，即使<code>string_column</code>被索引，但由于隐式将数字转换为字符串，索引可能失效。</li>
</ul>
</li>
</ul>
<ol start="5">
<li>当查询使用<code>OR</code>条件，并且<strong>条件中的某些字段没有被索引</strong>时，整个索引可能不会被使用。</li>
</ol>
<ul>
<li><ul>
<li>例如，<code>SELECT * FROM users WHERE last_name = &#39;Smith&#39; OR age = 30</code>，如果<code>last_name</code>被索引而<code>age</code>没有，整个索引可能不会被使用。</li>
</ul>
</li>
</ul>
<ol start="6">
<li>如果索引列的值分布非常不均匀，或者索引列大多数值都是相同的，优化器可能认为使用全表扫描更有效。</li>
</ol>
<ul>
<li><ul>
<li>例如，在一个大多数用户都来自同一城市的用户表中，对城市进行索引可能不会提高查询效率。</li>
</ul>
</li>
</ul>
<h2 id="（10）事务的基本特性和隔离级别？"><a href="#（10）事务的基本特性和隔离级别？" class="headerlink" title="（10）事务的基本特性和隔离级别？"></a>（10）事务的基本特性和隔离级别？</h2><p>事务具备4大特性，<strong>即原子性、一致性、隔离性和持久性</strong>。</p>
<ol>
<li><p><strong>原子性：</strong>事务中的所有操作要么全部执行成功，要么全部回滚到事务开始前的状态。如果在事务执行期间发生错误，系统将回滚所有已执行的操作，以保持数据的一致性。</p>
</li>
<li><p><strong>一致性：</strong>事务的执行不会破坏数据库的完整性约束。在事务开始和结束时，数据库必须处于一致的状态。 如小李转账100元给小白，不管操作是否成功，小李和小白的账户总额是不变的。 </p>
</li>
<li><p><strong>隔离性：</strong>事务的执行是相互隔离的，即每个事务对其他事务是透明的。并发执行的多个事务不会相互干扰，每个事务感知不到其他事务的存在。</p>
</li>
<li><p><strong>持久性：</strong>一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。</p>
</li>
</ol>
<p>MySQL支持以下四个事务隔离级别：</p>
<ol>
<li><strong>读未提交</strong>：最低的隔离级别。事务可以读取到其他事务尚未提交的数据，可能会出现脏读、不可重复读和幻读问题。</li>
<li><strong>读已提交</strong>：事务只能读取到已经提交的数据。但在同一事务中，多次读取同一行的数据结果可能会不一致，可能会出现不可重复读和幻读问题。</li>
<li><strong>可重复读</strong>：在同一个事务内，多次读取同一行的数据结果始终保持一致。MySQL的<strong>默认隔离级别就是可重复读</strong>。通过使用MVCC机制来实现，在读操作期间不会看到其他事务的修改，有效地解决了不可重复读问题。</li>
<li><strong>串行化</strong>：最高的隔离级别。事务串行执行，避免了脏读、不可重复读和幻读等问题。但是并发性能较差，可能导致大量的锁竞争和资源争用。</li>
</ol>
<h2 id="（11）什么是脏读、幻读和不可重复读？"><a href="#（11）什么是脏读、幻读和不可重复读？" class="headerlink" title="（11）什么是脏读、幻读和不可重复读？"></a>（11）什么是脏读、幻读和不可重复读？</h2><ol>
<li>脏读（Dirty Reads）：事务A读取到了事务B已经修改但尚未提交的数据。</li>
<li>幻读（Phantom Reads）：事务A读取到了事务B提交的新增数据。</li>
<li>不可重读（Non-Repeatable Reads）：事务A内部的相同查询语句在不同时刻读出的结果不一致。</li>
</ol>
<h2 id="（12）MySQL中in和exist的区别"><a href="#（12）MySQL中in和exist的区别" class="headerlink" title="（12）MySQL中in和exist的区别"></a>（12）MySQL中in和exist的区别</h2><p> MySQL 中的 IN 和 EXISTS都是用于查询和筛选数据的条件语句，区别在于：</p>
<ol>
<li><strong>IN关键字：</strong>使用 IN 条件时，我们提供一个固定的值列表，然后将其与指定列的值进行比较。如果列中的值与列表中的任何一个值匹配，就会返回结果。IN 条件适合用于确定某个字段的值是否在给定的值列表中。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (value1, value2, value3); </span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 如果 column_name 的值与 value1、value2 或 value3 中的任何一个相匹配</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 那么这条记录将会被返回</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>EXISTS关键字：</strong>使用 EXISTS 条件时，我们需要指定一个子查询。查询的结果并不重要，而是判断子查询是否返回了至少一行结果。如果子查询返回了结果，EXISTS 条件就会被认为是满足的。EXISTS 条件适合用于判断某个条件是否至少存在于子查询的结果中。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE EXISTS (SELECT * FROM another_table WHERE condition); </span><br><span class="line"></span><br><span class="line">// 如果子查询(SELECT * FROM another_table WHERE condition)返回了至少一行结果</span><br><span class="line">//那么主查询中的记录将会被返回。</span><br></pre></td></tr></table></figure>

<p><strong>总结来说：</strong></p>
<ul>
<li>使用 IN 条件时，比较的是指定列的值是否在给定的值列表中。</li>
<li>使用 EXISTS 条件时，判断的是子查询是否返回了至少一行结果。</li>
</ul>
<h2 id="（13）DATETIME和TIMESTAMP的异同"><a href="#（13）DATETIME和TIMESTAMP的异同" class="headerlink" title="（13）DATETIME和TIMESTAMP的异同"></a>（13）DATETIME和TIMESTAMP的异同</h2><p>DATETIME 和 TIMESTAMP 是 MySQL 中用于存储日期和时间的数据类型，它们之间有一些异同点：</p>
<ol>
<li><strong>存储范围</strong>：<ul>
<li>DATETIME 类型可以存储的范围是 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’。</li>
<li>TIMESTAMP 类型可以存储的范围是 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC（32 位系统的最大时间戳限制）。</li>
</ul>
</li>
<li><strong>存储空间</strong>：<ul>
<li>DATETIME 类型在存储时需要占用 8 个字节。</li>
<li>TIMESTAMP 类型在存储时通常只需要占用 4 个字节，因为它存储的是从 UNIX 纪元开始以来的秒数，但是在一些情况下可能会占用 5 个字节，取决于时区的支持和配置。</li>
</ul>
</li>
<li><strong>时区处理</strong>：<ul>
<li>DATETIME 类型不涉及时区转换，存储的时间是按照指定的时区直接存储的。</li>
<li>TIMESTAMP 类型存储的时间是自动转换为 UTC 时间并存储的，但在检索时会再次转换为当前会话时区的时间。</li>
</ul>
</li>
<li><strong>自动更新功能</strong>：<ul>
<li>TIMESTAMP 类型可以设置为自动更新当前时间戳，即在插入或更新记录时会自动更新为当前时间。</li>
<li>DATETIME 类型不具备自动更新功能，需要手动在插入或更新时指定时间。</li>
</ul>
</li>
<li><strong>索引性能</strong>：<ul>
<li>在创建索引时，TIMESTAMP 类型的字段因为只占用了 4 个字节，通常会比 DATETIME 类型的字段占用的索引空间更小，因此在一些情况下查询性能可能会更好。</li>
</ul>
</li>
</ol>
<h2 id="（14）数据库的三大范式是什么？"><a href="#（14）数据库的三大范式是什么？" class="headerlink" title="（14）数据库的三大范式是什么？"></a>（14）数据库的三大范式是什么？</h2><ol>
<li><p><strong>第一范式（1NF）</strong>：确保数据库中的每个列都是原子性的，即每个列都不可再分。</p>
</li>
<li><p><strong>第二范式（2NF）</strong>：在满足第一范式的基础上，确保数据库中的每个非主键列完全依赖于主键。</p>
</li>
<li><p><strong>第三范式（3NF）</strong>：在满足第二范式的基础上，确保数据库中的每个非主键列之间不存在传递依赖。</p>
</li>
</ol>
<h2 id="（15）数据库表的连接方式"><a href="#（15）数据库表的连接方式" class="headerlink" title="（15）数据库表的连接方式"></a>（15）数据库表的连接方式</h2><ol>
<li>内连接（INNER JOIN）：返回两个表中匹配的行，只有当左表和右表中都存在匹配的行时才会返回结果。</li>
<li>左连接（LEFT JOIN）：左连接返回左表中的所有行，以及与右边匹配的行。若右表中无匹配行，则返回NULL值。</li>
<li>右连接（RIGHT JOIN）：右连接返回右表中的所有行，以及与左表匹配的行。若左表中无匹配行，则返回NULL值。</li>
<li>全连接（FULL OUTER JOIN）：全连接返回左表和右边中的所有行，如果某个表中没有匹配的行，则返回NULL值。</li>
<li>自连接（SELF JOIN）：自连接是指在同一个表中进行连接操作，可以用于查找表中某些数据的关联信息。</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
        <category>八股</category>
      </categories>
  </entry>
  <entry>
    <title>数据库2_Redis数据库</title>
    <url>/2024/04/06/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%932_Redis%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="1、Redis简介"><a href="#1、Redis简介" class="headerlink" title="1、Redis简介"></a>1、Redis简介</h1><p>Redis是一个基于内存的数据存储系统，它<strong>将数据完全存储在内存中</strong>，通过使用<strong>持久化机制</strong>来将数据定期写入磁盘以保证数据的持久性。</p>
<h2 id="（1）内存淘汰机制-过期策略"><a href="#（1）内存淘汰机制-过期策略" class="headerlink" title="（1）内存淘汰机制&#x2F;过期策略"></a>（1）内存淘汰机制&#x2F;过期策略</h2><p><strong>MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？</strong></p>
<p>redis 提供 6种数据淘汰策略：</p>
<ul>
<li>volatile-lru： 从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl： 从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li>volatile-random： 从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li>allkeys-lru： 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）.</li>
<li>allkeys-random： 从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-eviction： 禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</li>
</ul>
<h2 id="（2）持久化机制"><a href="#（2）持久化机制" class="headerlink" title="（2）持久化机制"></a>（2）持久化机制</h2><p><strong>怎么保证 redis 挂掉之后再重启数据可以进行恢复？</strong></p>
<p><strong>持久化数据</strong>：也就是将内存中的数据写入磁盘。</p>
<ul>
<li><p>目的：</p>
<ul>
<li>为了之后重用数据（比如重启机器、机器故障之后恢复数据），</li>
<li>为了防止系统故障而将数据备份到一个远程位置。</li>
</ul>
</li>
<li><p><strong>快照（snapshotting，RDB）</strong></p>
<ul>
<li>在指定的时间间隔内将内存中的数据集快照写入磁盘，RDB是内存快照（内存数据的二进制序列化形式）的方式持久化，每次都是从Redis中生成一个快照进行数据的全量备份。</li>
<li>Redis持久化<strong>默认开启为RDB持久化</strong>。<ul>
<li>指定的时间间隔：体现在主进程fork子进程的阶段。</li>
<li>触发规则：<ul>
<li><strong>手动触发</strong><ul>
<li><strong>save</strong>：阻塞当前Redis进程，直到RDB持久化完成（尽量不使用）</li>
<li><strong>bgsave</strong>：Redis主进程fork子进程，由子进程完成持久化</li>
</ul>
</li>
<li><strong>自动触发</strong>：<ul>
<li><strong>配置触发</strong>：redis.conf——&#x2F;snapshot即可定位到触发的配置位置<ul>
<li>save 3600 1 300 100 600 60 10000<ul>
<li>save 3600 1：3600秒内有1个key被修改，触发RDB</li>
<li>save 300 100：300秒内有100个key被修改，触发RDB</li>
<li>save 60 10000：60秒内有10000个key被修改，触发RDB</li>
</ul>
</li>
</ul>
</li>
<li><strong>shutdown触发</strong></li>
<li><strong>flushall触发</strong>：清空Redis数据的同时清空dump.rdb文件，等同于删库跑路</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>优点<ul>
<li>性能高：RDB持久化通过生成一个快照文件来保存数据，因此在恢复数据时速度非常快；</li>
<li>文件紧凑：RDB文件是二进制格式的数据库文件，相较于AOF文件来说，文件体积小。</li>
</ul>
</li>
<li>缺点<ul>
<li>可能丢失数据：由于RDB是定期生成的快照文件，如果Redis意外宕机，最近一次的修改可能会丢失。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>只追加文件（append-only file，AOF）</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404061114362.png" alt="image-20240406111403297"></p>
<ul>
<li>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。</li>
<li><strong>同步策略</strong>：<ul>
<li><code>appendfsync always</code>：每次有数据修改发生时都会写入AOF文件，但会严重降低Redis的速度；</li>
<li><code>appendfsync everysec</code>：每秒刷新一次缓冲区中的数据到AOF文件，显式地将多个写命令同步到硬盘；</li>
<li><code>appendfsync no</code>：Redis进程不会主动地去刷新缓冲区的数据到AOF文件，让操作系统决定何时进行同步。</li>
</ul>
</li>
<li><strong>重写策略</strong><ul>
<li><code>auto-aof-rewrite-percentage 100</code>：当AOF文件体积达到上次重写之后的体积的100%时，触发AOF重写；</li>
<li><code>auto-aof-rewrite-min-size 64mb</code>：当AOF文件体积超过该阈值时，触发AOF重写。</li>
</ul>
</li>
<li><strong>优点</strong><ul>
<li>数据更加可靠：AOF持久化记录了每个写命令的操作，因此在出现故障时，可以通过重新执行AOF文件来保证数据的完整性；</li>
<li>可以保留写命令历史：AOF文件是一个追加日志文件，可以用于回放过去的写操作。</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>文件较大：由于记录了每个写命令，AOF文件体积通常比RDB文件要大；</li>
<li>恢复速度较慢：当AOF文件较大时，Redis重启时需要重新执行整个AOF文件，恢复速度相对较慢。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="（3）缓存击穿、缓存雪崩和缓存穿透"><a href="#（3）缓存击穿、缓存雪崩和缓存穿透" class="headerlink" title="（3）缓存击穿、缓存雪崩和缓存穿透"></a>（3）缓存击穿、缓存雪崩和缓存穿透</h2><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>在高并发的访问下，一个热点数据失效时，大量请求会直接绕过缓存，直接查询数据库，导致数据库压力剧增。</p>
<p>解决方案：</p>
<ul>
<li><strong>设置热点数据永不过期</strong>：对于一些热点数据，可以设置不过期，或者设置较长的过期时间，以保证这部分数据在缓存中一直可用，减少因数据过期引起的击穿问题；</li>
<li><strong>设置互斥锁</strong>：在缓存失效时，只允许一个请求访问数据库，其他请求需要等待该请求执行完毕后再从缓存中获取数据，可以减少并发请求对数据库的冲击；</li>
<li><strong>采用布隆过滤器（Bloom Filter）</strong>：使用布隆过滤器判断请求的数据是否存在，如果不存在，可以直接返回避免对数据库的查询，缓解击穿压力。</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>在高并发的访问下，大规模缓存失效同时失效或者缓存宕机，大量请求同时涌入数据库，导致数据库负载过大甚至崩溃的情况。 </p>
<p>解决方案：</p>
<ul>
<li><strong>随机分布过期时间</strong>：在设置缓存数据的过期时间时，可以随机分布过期时间，避免缓存数据同时大规模失效；</li>
<li><strong>使用多级缓存</strong>：引入多级缓存架构，将请求分散到不同的缓存层，即使一个缓存层发生雪崩，也能够有其他缓存层提供服务。</li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指恶意请求或者大量查询不存在于缓存中的数据，导致请求直接绕过缓存层，直接访问后端存储系统（如数据库），从而给后端系统造成巨大压力的现象。</p>
<p>解决方法主要包括：</p>
<ul>
<li><strong>空值缓存</strong>：对于查询数据库返回空结果的情况，也将其缓存起来，但设置一个较短的过期时间，防止缓存穿透的请求直接击穿数据库；</li>
<li><strong>采用布隆过滤器（Bloom Filter）</strong>：使用布隆过滤器判断请求的数据是否存在，如果数据不存在，则直接拒绝访问，从而避免了对后端系统的查询请求，减轻了后端压力；</li>
<li><strong>数据预热</strong>：在系统启动或者定时任务中，预先将热点数据加载到缓存中，避免缓存穿透带来的大量请求直接击穿数据库；</li>
<li><strong>合法性校验</strong>：在接收到请求后，首先进行参数的合法性校验，对非法请求直接拒绝，从而减少无效请求对后端系统的压力。</li>
</ul>
<h2 id="（4）Redis的哨兵机制是怎样的？"><a href="#（4）Redis的哨兵机制是怎样的？" class="headerlink" title="（4）Redis的哨兵机制是怎样的？"></a>（4）Redis的哨兵机制是怎样的？</h2><p>设置多个哨兵监视Master节点。只有当多个哨兵都认为Master节点宕掉时，才进行主从切换；同时，针对由哪一个哨兵来进行主从切换的问题，进行哨兵选举，通过选举选出一个主导的哨兵进行主从切换。</p>
<h2 id="（5）Redis数据类型"><a href="#（5）Redis数据类型" class="headerlink" title="（5）Redis数据类型"></a>（5）Redis数据类型</h2><ul>
<li>String：String是最常用的数据类型，在Redis中以二进制安全的方式存储字符串值。它可以包含任何类型的数据，比如文本、整数或二进制数据。</li>
</ul>
<ol start="2">
<li>Hash：Hash是一个键值对的集合，其中每个键都与一个值相关联。在Redis中，Hash可以用于存储和操作对象，每个键值对相当于对象的字段和值。</li>
<li>List：List是一个按照插入顺序排序的字符串元素集合。集合中的元素可以重复，可以从列表的两端进行插入和删除操作，可用于实现队列、栈等数据结构。</li>
<li>Set：Set是一个无序、唯一的字符串集合，不允许重复的成员。可以对集合执行添加、删除和判断成员是否存在等操作，也支持集合间的交集、并集和差集运算。</li>
<li>Sorted Set：Sorted Set是一个有序的字符串集合，每个成员都关联着一个分数。集合中的成员根据分数的大小进行排序，可以进行范围查询和按分数排名操作。</li>
</ol>
<h2 id="（6）Redis是单线程的，为什么还会这么快呢？"><a href="#（6）Redis是单线程的，为什么还会这么快呢？" class="headerlink" title="（6）Redis是单线程的，为什么还会这么快呢？"></a>（6）Redis是单线程的，为什么还会这么快呢？</h2><ul>
<li>首先Redis是基于内存的nosql数据库，基于内存的读写效率本身就非常高；</li>
<li>Redis内部对应核心命令的执行采用了单线程模型，并且给予内存模型，单条命令的执行速度远小于线程上下文的开销，所以使用单线程能够大大提升我们Redis的吞吐量；</li>
<li>内部提供了高效查询和操作的数据结构；</li>
<li>采用IO多路复用模型，能够同时处理大量连接，并且使用reator模型，能够并发的处理连接以及对连接进行响应，但是内部命令执行还是单线程的；</li>
<li>对Redis常用操作进行旅游化，提供了管道技术和批量操作技术，能够减少单次Redis操作的网络开销</li>
</ul>
<h2 id="（7）使用缓存的好处？"><a href="#（7）使用缓存的好处？" class="headerlink" title="（7）使用缓存的好处？"></a>（7）使用缓存的好处？</h2><ul>
<li>高性能</li>
<li>高并发</li>
</ul>
<h2 id="（8）对Redis的理解"><a href="#（8）对Redis的理解" class="headerlink" title="（8）对Redis的理解"></a>（8）对Redis的理解</h2><p>首先，Redis本质上是一个nosql数据库，内部提供了非常多的数据结构，帮助我们满足各种场景的需求实现。</p>
<p>并且内部使用了IO多路复用的模型，使得Redis能够处理大量的连接，并且内部对于核心命令的执行部分使用了单线程，使得我们的不需要考虑线程安全的问题。</p>
<p>Redis完全是基于内存操作，速度很快，他的并发读写性能非常高，并且Redis6之后，对于协议解析和响应使用率了多线程模型，进一步降低核心单线程处理任务的复杂度，使得我们Redis的性能又提升了一个量级。</p>
<p>Redis本身提供了非常多的高可用机制，帮助我们实现Redis的高可用集群，目前企业中已经大量使用Redis作为我们缓存 等场景</p>
<h2 id="（7）一个Redis实例最多能存放多少Keys？"><a href="#（7）一个Redis实例最多能存放多少Keys？" class="headerlink" title="（7）一个Redis实例最多能存放多少Keys？"></a>（7）一个Redis实例最多能存放多少Keys？</h2><p>Redis 的每个实例最多可以存放约 2^32 - 1 个keys，即大约 42 亿个keys。</p>
<p>这是由 Redis 内部使用的哈希表实现决定的，它使用 32 位有符号整数作为索引。Redis 使用的哈希函数和负载因子等因素也会影响实际可存放键的数量。</p>
<h2 id="（8）说说你对缓存双写不一致的理解？"><a href="#（8）说说你对缓存双写不一致的理解？" class="headerlink" title="（8）说说你对缓存双写不一致的理解？"></a>（8）说说你对缓存双写不一致的理解？</h2><p>缓存不一致主要是指我们的业务系统里面引入了缓存提生我们查询性能，但是当我们数据库数据发生变更的时候，我们如何去保证缓存和数据库中数据的一致性问题，主要有两大种方案首先是异步通知，可以利用canal监听我们mysql的数据变化，然后发送变更缓存消息到mq，让业务系统去对缓存进行更新，由于我们一般监听binlog都是在从mysql上进行，而主从同步有一定的延时，监听完消息发送到mq又存在一定的延时，所以他的实时性不是很好，比较适合用在一致性要求不是很高的缓存场景，并且异步通知最大的优点就是解耦，对于更新缓存的逻辑不需要耦合在代码中</p>
<p>第二种方案也是得物使用规范的中最推荐的同步双写，之所以使用这种方案，就是非常多的业务中都涉及到钱相关，如果缓存长时间不一致容易造成大量的资损，比如：我们商品中心大量商品数据进行了缓存，此时我们管理员修改了价格，这个缓存怎么同步，其实就是缓存一致性的问题，对于这种一致性比较高的业务，我们推荐最佳方案是采用延时双删，先删缓存，然后写数据库，然后过500ms再删一次缓存，这种方案能够尽可能避免出现缓存不一致的问题，但是也是无法完全避免，因为可能出现一些极端情况，比如出现了慢SQL，查了半天还是旧数据，结果我们双删也删完了，他又走了旧数据的逻辑，但是这种都可以通过监控来进行优化，尽最大可能不出现问题，如果想要保证强一致性，其实方案就是使用读写锁来保证了，但是一般C端业务，优先考虑用户体验性，如果不是直接操作钱一般不使用这种方案</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>八股</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2024/06/12/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h2 id="一、线程与进程"><a href="#一、线程与进程" class="headerlink" title="一、线程与进程"></a>一、线程与进程</h2><h3 id="1、进程和线程以及并发和并行的概念是什么？"><a href="#1、进程和线程以及并发和并行的概念是什么？" class="headerlink" title="1、进程和线程以及并发和并行的概念是什么？"></a>1、进程和线程以及并发和并行的概念是什么？</h3><p>（1）线程是操作系统中的最小执行单元，进程是程序的一次执行过程，是系统资源分配的最小单位。</p>
<p>（2）并发是在单个处理器上多个任务交替执行，实现多个线程同时执行的假象；而并行是在多个处理器上实现多个线程同时执行。</p>
<p>在 Linux 中，<strong>线程不会拥有独立的内存空间。所有线程共享进程的虚拟地址空间，但每个线程拥有自己独立的栈空间和寄存器集合。</strong>共享内存空间使得线程之间的通信比进程间通信更加高效，但也意味着需要通过同步机制（如互斥锁）来保护共享资源，防止竞态条件。Linux中进程和线程的区别如下：</p>
<p><strong>进程</strong>：</p>
<ul>
<li>进程在 Linux 中通过 <code>fork</code> 系统调用创建，子进程拥有独立的内存空间（地址空间）。</li>
<li>每个进程有独立的进程控制块（PCB），包含进程状态、寄存器、内存管理信息等。</li>
</ul>
<p><strong>线程</strong>：</p>
<ul>
<li>线程在 Linux 中通过 <code>pthread_create</code> 创建，所有线程共享进程的地址空间和全局变量。</li>
<li>线程在 Linux 内核中被实现为轻量级进程（LWP），每个线程都有独立的线程控制块（TCB），但共享进程的资源。</li>
</ul>
<blockquote>
<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。<strong>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</strong></p>
</blockquote>
<h3 id="2、线程比进程具有哪些优势？"><a href="#2、线程比进程具有哪些优势？" class="headerlink" title="2、线程比进程具有哪些优势？"></a>2、线程比进程具有哪些优势？</h3><ol>
<li>线程在程序中是独立的，并发的执行流，但是，进程中的线程之间的隔离程度要小；</li>
<li>线程比进程更具有更⾼的性能，这是由于同⼀个进程中的线程都有共性：多个线程将共享同⼀个进程虚拟空间；</li>
<li>当操作系统创建⼀个进程时，必须为进程分配独立的内存空间，并分配大量相关资源。</li>
</ol>
<h3 id="3、什么时候用多进程？什么时候用多线程？"><a href="#3、什么时候用多进程？什么时候用多线程？" class="headerlink" title="3、什么时候用多进程？什么时候用多线程？"></a>3、什么时候用多进程？什么时候用多线程？</h3><ol>
<li>需要频繁创建销毁的优先用线程；</li>
<li>需要进行大量计算的优先使用线程；</li>
<li>强相关的处理用线程，弱相关的处理用进程；</li>
<li>可能要扩展到多机分布的用进程，多核分布的用线程。</li>
</ol>
<h3 id="4、线程内存存储在哪里？"><a href="#4、线程内存存储在哪里？" class="headerlink" title="4、线程内存存储在哪里？"></a>4、线程内存存储在哪里？</h3><ol>
<li><strong>线程栈</strong>（Thread Stack）：每个线程都有自己的栈空间，这是线程存储本地变量、函数参数和返回地址的地方。线程栈通常有固定的大小，这个大小可以在创建线程时指定，也可能由操作系统预设。这部分内存通常位于用户空间的栈内存中。</li>
<li><strong>线程堆</strong>（Thread Heap）：虽然线程可以访问进程级的堆（共享资源），但它们通常不拥有私有的堆空间。然而，线程可以通过特定的内存分配策略（如使用线程局部存储）在堆上分配数据，这些数据只对分配它的线程可见。</li>
<li><strong>寄存器集</strong>：包括程序计数器、堆栈指针和其他必要的硬件寄存器。这些通常是在处理器内部维护的，并且每个线程都有自己的寄存器状态。</li>
<li><strong>线程局部存储（TLS）</strong>：这是一种允许数据在多个线程之间被隔离的机制。每个线程可以访问自己的专用数据副本，对其他线程不可见。这在编程中用于保持数据的线程安全性。</li>
<li><strong>线程控制块（TCB）</strong>：这是一个内核数据结构，包含了管理线程所需的所有信息，如线程的状态、优先级、调度信息等。线程控制块通常存储在操作系统内核的内存中。</li>
</ol>
<p>这些部分合在一起定义了一个线程的运行环境。每个线程的栈是独立的，但它们共享进程的堆和其他全局资源。</p>
<h3 id="5、线程中的锁包含哪些？"><a href="#5、线程中的锁包含哪些？" class="headerlink" title="5、线程中的锁包含哪些？"></a>5、线程中的锁包含哪些？</h3><p>（1）互斥锁：用于对共享资源的互斥访问。当有线程对该资源加了互斥锁后，其他线程尝试加锁时会被阻塞，直至锁被释放。</p>
<p>（2）递归锁：是一种特殊的互斥锁，当有同一个线程尝试对同一个线程不断加锁时，不会被阻塞。</p>
<p>（3）读写锁：允许多个线程同时进行读操作，但仅允许一个线程进行写操作，使用在读多于写的场景。</p>
<p>（4）自旋锁：当有线程对资源加了自旋锁后，其他线程尝试加锁时将忙等待，而非被阻塞。</p>
<h3 id="6、什么是死锁？"><a href="#6、什么是死锁？" class="headerlink" title="6、什么是死锁？"></a>6、什么是死锁？</h3><p>死锁（Deadlock）是指在多线程或多进程的环境中，两个或多个执行单元因为争夺资源而造成的一种相互等待的现象，如果没有外力干涉，这些进程将无法向前推进。</p>
<h3 id="7、死锁产生的原因"><a href="#7、死锁产生的原因" class="headerlink" title="7、死锁产生的原因"></a>7、死锁产生的原因</h3><p>死锁产生主要有以下几个条件，这些条件同时满足时，就可能发生死锁：</p>
<ol>
<li><strong>互斥条件</strong>：资源不能被多个线程（或进程）共享，只能被一个线程（或进程）所占用。</li>
<li><strong>请求与保持条件</strong>：线程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他线程占有。</li>
<li><strong>不剥夺条件</strong>：线程所获得的资源在未使用完之前，不能被其他线程强行剥夺。</li>
<li><strong>循环等待条件</strong>：存在一种线程资源循环等待链，每个线程占有一种资源并等待另一种被下一个线程占有的资源。</li>
</ol>
<h3 id="8、如何避免死锁？"><a href="#8、如何避免死锁？" class="headerlink" title="8、如何避免死锁？"></a>8、如何避免死锁？</h3><ol>
<li>系统对进程发出每一个系统能够满足的资源申请进行动态检查,并根据检查结果决定是否分配资源,如果分配后系统可能发生死锁,则不予分配,否则予以分配。这是一种保证系统不进入死锁状态的动态策略。</li>
<li>在系统设计、进程调度等方面注意如何让这四个必要条件不成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</li>
</ol>
<h3 id="9、如果有两个线程-1、2-去访问同一个资源-C-，并且二者必须同时获取锁-A-和-B-才可以访问-C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？"><a href="#9、如果有两个线程-1、2-去访问同一个资源-C-，并且二者必须同时获取锁-A-和-B-才可以访问-C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？" class="headerlink" title="9、如果有两个线程 1、2 去访问同一个资源 C ，并且二者必须同时获取锁 A 和 B 才可以访问 C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？"></a>9、如果有两个线程 1、2 去访问同一个资源 C ，并且二者必须同时获取锁 A 和 B 才可以访问 C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？</h3><ol>
<li>分情况讨论：第一如果两个线程同时去分别先获取不同的锁就会出现死锁，比如线程 1 先获得锁 A 而线程 2 先获得锁 B，然后二者都会等待</li>
<li>正确的顺序应该是二者同时竞争同一个锁</li>
<li>正确的顺序都可以：<ol>
<li>先释放 A，由于对方正在等待A 那么对方接下来会等待B，而此时释放 B 是没有阻碍的</li>
<li>先释放 B，由于对方等待A而我们释放过程中没有阻碍，仍然可以完成</li>
</ol>
</li>
</ol>
<h3 id="10、从锁的粒度来说，有哪些？"><a href="#10、从锁的粒度来说，有哪些？" class="headerlink" title="10、从锁的粒度来说，有哪些？"></a>10、从锁的粒度来说，有哪些？</h3><p><strong>粗粒度锁</strong>：</p>
<ul>
<li><strong>全局锁</strong>：对整个应用程序或系统加锁，通常用于单个进程或单个应用实例中。这种锁的开销大，但实现简单。</li>
<li><strong>模块级锁</strong>：对某个模块或组件加锁，通常用于大型系统中，锁的范围缩小，提高了并发性。</li>
</ul>
<p><strong>细粒度锁</strong>：</p>
<ul>
<li><strong>对象锁</strong>：对单个对象加锁，通常用于面向对象编程中。</li>
<li><strong>方法锁</strong>：对单个方法加锁，确保方法执行的线程安全。</li>
<li><strong>变量锁</strong>：对单个变量或数据结构加锁，提供最小粒度的锁定范围，最大化并发性。</li>
</ul>
<h3 id="11、悲观锁和乐观锁？"><a href="#11、悲观锁和乐观锁？" class="headerlink" title="11、悲观锁和乐观锁？"></a>11、悲观锁和乐观锁？</h3><p>对于互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。</p>
<p>相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p>
<h3 id="12、忙等待和阻塞的区别是什么？"><a href="#12、忙等待和阻塞的区别是什么？" class="headerlink" title="12、忙等待和阻塞的区别是什么？"></a>12、忙等待和阻塞的区别是什么？</h3><p><strong>（1）忙等待（Busy Waiting）</strong></p>
<p>忙等待指线程在等待锁或资源可用期间<strong>不断地检查锁的状态，而不进行任何上下文切换</strong>，因而具有低延迟的特点。这种等待方式会使线程保持活跃状态，占用 CPU 时间。适用于1）短时间的等待或预计锁很快会释放的情况2）高并发、低延迟需求的实时系统；3）多核处理器环境下，减少锁竞争延迟。</p>
<p>如果锁等待时间较长，忙等待会导致大量的 CPU 资源浪费。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">try_lock</span>()) &#123;</span><br><span class="line">    <span class="comment">// Busy-wait</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）阻塞（Blocking）</strong></p>
<p>阻塞指线程在等待锁或资源可用期间会<strong>被挂起，进入睡眠状态，直到条件满足或锁可用时被唤醒</strong>。这种机制需要操作系统的线程调度和上下文切换支持，但释放了 CPU 资源，以便被其他线程使用。适用于1）长时间等待或锁持有时间较长的情况，避免了 CPU 资源的浪费；2）系统资源有限，希望最大化 CPU 资源利用率的场景；3）一般的多线程编程，避免不必要的 CPU 资源浪费。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">condition_variable.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> <span class="built_in">condition_met</span>(); &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="13、一个进程可以创建多少线程？和什么有关？"><a href="#13、一个进程可以创建多少线程？和什么有关？" class="headerlink" title="13、一个进程可以创建多少线程？和什么有关？"></a>13、一个进程可以创建多少线程？和什么有关？</h3><p>分不同系统去看。</p>
<ul>
<li>如果是 <code>32</code> 位系统，用户态的虚拟空间只有 <code>3G</code>，如果创建线程时分配的栈空间是 <code>10M</code>，那么一个进程最多只能创建 <code> 300 (3G/10M)</code> 个左右的线程。</li>
<li>如果是 <code>64</code> 位系统，用户态的虚拟空间大到有 <code>128T</code>，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制，比如以下三个内核参数：<ul>
<li><code>/proc/sys/kernel/threads-max</code>，表示系统支持的最大线程数，默认值是 <code>14553</code>；</li>
<li><code>/proc/sys/kernel/pid_max</code>，表示系统全局的 PID 号数值的限制，每一个进程或线程都有 ID，ID 的值超过这个数，进程或线程就会创建失败，默认值是 <code>32768</code>；</li>
<li><code>/proc/sys/vm/max_map_count</code>，表示限制一个进程可以拥有的VMA(虚拟内存区域)的数量，默认值是 <code>65530</code>。</li>
</ul>
</li>
</ul>
<h3 id="14、多线程如何保证线程安全？"><a href="#14、多线程如何保证线程安全？" class="headerlink" title="14、多线程如何保证线程安全？"></a>14、多线程如何保证线程安全？</h3><ol>
<li>使用<strong>互斥锁（Mutex）</strong>保护共享资源。</li>
<li>使用<strong>自旋锁（Spinlock）</strong>在短时间锁定的场景。</li>
<li>使用<strong>条件变量（Condition Variable）</strong>进行线程间通信。</li>
<li>使用<strong>原子操作（Atomic Operations）</strong>进行无锁编程。</li>
<li>使用<strong>读写锁（Reader-Writer Lock）</strong>优化读多写少的场景。</li>
<li>使用<strong>线程局部存储（Thread-Local Storage）</strong>确保每个线程独立的数据。</li>
</ol>
<h3 id="15、多线程环境下对变量的读写操作是否是原子的？"><a href="#15、多线程环境下对变量的读写操作是否是原子的？" class="headerlink" title="15、多线程环境下对变量的读写操作是否是原子的？"></a>15、多线程环境下对变量的读写操作是否是原子的？</h3><p>在多线程环境中，对变量的读写操作不一定是原子的，需要使用特定的技术和机制来确保线程安全。</p>
<p>在现代的 CPU 架构中，对基本数据类型的赋值操作通常被认为是原子的，即在单个指令周期内完成。对于<code>Intel</code>处理器来说，一般规定一个字节的读写或者对齐的读写操作等提供原子性保障；而对于那些被总线带宽、cache line以及page大小给分隔开的内存地址的访问不是原子性的。</p>
<p>以下是举例说明：</p>
<p>1）对于<code>x=1</code>来说，因为x是 int 类型，32 位 CPU 上占 32 位，在 x86 上由硬件直接提供了原子性支持。在进行这样的赋值操作时，CPU 会将整个 32 位的值一次性写入到内存中，而不是分开写入。因此，即使有多个线程同时执行类似 <code>x=1</code> 的赋值语句，也不会出现损坏 x 值的情况。</p>
<p>2）对于<code>x++</code>和<code>++x</code>来说，这样的操作在多线程环境下是需要同步的。因为 x86 会按三条指令的形式来处理这种语句：从内存中读 x 的值到寄存器中，对寄存器加 1 ，再把新值写回 x 所处的内存地址。</p>
<blockquote>
<p>（1）一些基本的内存读写操作本身已经被硬件提供了原子性保证（例如读写单个字节的操作）；</p>
<p>（2）一些需要保证原子性但是没有被第（1）条机制提供支持的操作（例如read-modify-write）可以通过使用”LOCK#”来锁定总线，从而保证操作的原子性；</p>
<p>（3）因为很多内存数据是已经存放在L1&#x2F;L2 cache中了，对这些数据的原子操作只需要与本地的cache打交道，而不需要与总线打交道，所以CPU就提供了cache  coherency机制来保证其它的那些也cache了这些数据的processor能读到最新的值（关于cache coherency可以参加我的<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/">一篇博文</a>）。</p>
</blockquote>
<blockquote>
<p>从Intel486 processor开始，<strong>以下的基本内存操作是原子的</strong>：<br>• Reading or writing a byte（<strong>一个字节的读写</strong>）<br>• Reading or writing a word aligned on a 16-bit boundary（<strong>对齐到16位边界的字的读写</strong>）<br>• Reading or writing a doubleword aligned on a 32-bit boundary（<strong>对齐到32位边界的双字的读写</strong>）</p>
<p>从Pentium processor开始，除了之前支持的原子操作外又新增了以下原子操作：<br>• Reading or writing a quadword aligned on a 64-bit boundary（<strong>对齐到64位边界的四字的读写</strong>）<br>• 16-bit accesses to uncached memory locations that fit within a 32-bit data bus（<strong>未缓存且在32位数据总线范围之内的内存地址的访问</strong>）</p>
<p>从P6 family processors开始，除了之前支持的原子操作又新增了以下原子操作：<br>• Unaligned 16-, 32-, and 64-bit accesses to cached memory that fit within a cache line（<strong>对单个cache line中缓存地址的未对齐的16&#x2F;32&#x2F;64位访问</strong>）</p>
<p><strong>那么哪些操作是非原子的呢？</strong><br>Accesses to cacheable memory that are split across bus widths, cache lines, and page boundaries are not guaranteed to be atomic by the Intel Core 2 Duo, Intel® Atom™, Intel Core Duo, Pentium M, Pentium 4, Intel Xeon, P6 family, Pentium, and Intel486 processors.（说点简单点，<strong>那些被总线带宽、cache line以及page大小给分隔开了的内存地址的访问不是原子的</strong>，你如果想保证这些操作是原子的，你就得求助于机制（2），对总线发出相应的控制信号才行）。</p>
</blockquote>
<h3 id="16、为什么线程的开销要小于进程的开销？"><a href="#16、为什么线程的开销要小于进程的开销？" class="headerlink" title="16、为什么线程的开销要小于进程的开销？"></a>16、为什么线程的开销要小于进程的开销？</h3><p>线程相比进程能减少开销，体现在：</p>
<ul>
<li>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li>
<li>线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</li>
<li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，缺页中断的命中率提高，因此页表的切换过程开销是比较大的；</li>
<li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</li>
</ul>
<h3 id="17、线程池中的线程数如何确定？"><a href="#17、线程池中的线程数如何确定？" class="headerlink" title="17、线程池中的线程数如何确定？"></a>17、线程池中的线程数如何确定？</h3><ol>
<li><p>根据硬件资源决定线程数</p>
<p>一般的经验法则是根据系统的硬件资源，特别是CPU的核心数来确定线程数。</p>
<ul>
<li><p><strong>计算密集型任务</strong>（CPU-bound tasks）：对于计算密集型任务，线程数通常设置为等于或稍大于CPU核心数。这样可以最大化CPU利用率，避免上下文切换的开销。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> numThreads = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br></pre></td></tr></table></figure>

<p><code>std::thread::hardware_concurrency()</code> 返回可用的并发线程数（通常等于CPU核心数）。</p>
</li>
<li><p><strong>I&#x2F;O密集型任务</strong>（I&#x2F;O-bound tasks）：对于I&#x2F;O密集型任务，由于这些任务在执行过程中经常会等待I&#x2F;O操作完成，线程数可以设置为高于CPU核心数，以隐藏I&#x2F;O等待时间，提高整体吞吐量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> numThreads = std::thread::<span class="built_in">hardware_concurrency</span>() * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>这个倍数可以根据实际情况调整，通常在2到4之间。</p>
</li>
</ul>
</li>
<li><p>动态调整线程数</p>
<p>在一些高级场景中，可以根据运行时的负载情况动态调整线程数。这种方法需要监控线程池的负载和任务执行情况，并根据实际需求增加或减少线程。</p>
</li>
</ol>
<h3 id="18、为什么线程池可以提高吞吐量？"><a href="#18、为什么线程池可以提高吞吐量？" class="headerlink" title="18、为什么线程池可以提高吞吐量？"></a>18、为什么线程池可以提高吞吐量？</h3><ul>
<li><strong>减少线程创建和销毁的开销</strong>：线程池在初始化时会创建一定数量的线程，并将它们保存在池中。当任务到达时，线程池会分配一个空闲线程来执行任务，而不是每次都创建新线程。这样可以减少线程创建和销毁的开销，提高了任务处理的效率。</li>
<li><strong>复用线程资源</strong>：线程池中的线程是可以重复利用的，执行完一个任务后不会立即销毁，而是继续等待新的任务。这样可以避免频繁地创建和销毁线程，减少了系统资源的消耗。</li>
<li><strong>控制并发线程数量</strong>：线程池可以限制同时执行的线程数量，防止因过多线程竞争资源导致系统性能下降的情况发生。通过调整线程池的大小和任务队列的长度，可以更好地控制系统的并发度，避免过载。</li>
</ul>
<h3 id="19、现在让你来涉及一个支持最大并发数的线程池你可能会怎么设计呢？"><a href="#19、现在让你来涉及一个支持最大并发数的线程池你可能会怎么设计呢？" class="headerlink" title="19、现在让你来涉及一个支持最大并发数的线程池你可能会怎么设计呢？"></a>19、现在让你来涉及一个支持最大并发数的线程池你可能会怎么设计呢？</h3><p>要设计一个支持最大并发数的线程池，可以考虑以下两方面：</p>
<ol>
<li><p>任务管理</p>
<ul>
<li><p><strong>任务队列</strong>：使用一个线程安全的队列存储待执行的任务。任务按照提交的顺序执行。</p>
</li>
<li><p><strong>调度机制</strong>：当线程池有空闲线程时，从任务队列中取出任务执行。如果任务队列为空，线程可以进入等待状态。</p>
</li>
</ul>
</li>
<li><p>线程池管理</p>
<ul>
<li><p><strong>固定数量线程池</strong>：初始化时创建固定数量的线程（如3个），每个线程从任务队列中获取任务并执行。线程池的线程数量保持不变。</p>
</li>
<li><p><strong>动态管理</strong>：如果采用动态管理策略，可以根据负载调整线程数量，但在最大并发数内。</p>
</li>
<li><p><strong>同步机制</strong>：使用信号量或条件变量控制最大并发数。线程执行任务时减少计数，完成后增加计数，确保同时运行的线程不超过最大并发数。</p>
</li>
<li><p><strong>停止和清理</strong>：提供接口用于优雅地停止线程池，并确保所有任务完成后释放资源。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>假设队列里边的任务是按时间顺序管理的，那么如果有个高优先级的事件你怎么处理，比如说我移动了一下鼠标它不可能等待所有线程执行完去执行，那怎么处理这样的事件？</p>
<p>如果任务队列的任务之间有依赖关系要怎么处理呢？如果采用同步是不是就死锁了？</p>
</blockquote>
<h3 id="20、C-多线程编程时要链接什么库，怎么找到对应的动态库？"><a href="#20、C-多线程编程时要链接什么库，怎么找到对应的动态库？" class="headerlink" title="20、C++ 多线程编程时要链接什么库，怎么找到对应的动态库？"></a>20、C++ 多线程编程时要链接什么库，怎么找到对应的动态库？</h3><p>在C++中进行多线程编程时，常用的库是<code>pthread</code>（POSIX threads）库或C++11标准库提供的线程支持库。如果使用<code>pthread</code>库，需要在编译时链接<code>pthread</code>库，并且明确指定动态库的路径。而如果使用C++11标准库，编译器会自动处理所需的链接和路径问题。</p>
<ol>
<li><p>使用<code>pthread</code>库</p>
<ol>
<li><p>链接<code>pthread</code>库</p>
<p>在Linux系统中，使用<code>pthread</code>库时需要在编译时加上<code>-pthread</code>选项。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">g++ -o my_program my_program.cpp -pthread</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找和链接动态库</p>
<p>动态库一般位于系统的标准库路径中，如<code>/usr/lib</code>或<code>/usr/local/lib</code>。在运行时，操作系统会自动从这些路径中查找所需的动态库。如果动态库位于非标准路径，可以通过设置<code>LD_LIBRARY_PATH</code>环境变量来指定动态库路径。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/path/to/your/library:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>pthread</code>库进行多线程编程</p>
</li>
</ol>
</li>
<li><p>使用C++11标准库</p>
<ol>
<li><p>使用C++11线程库</p>
<p>使用C++11的线程库时，不需要额外链接任何库，编译器会自动处理。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">g++ -o my_program my_program.cpp -std=c++11</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="21、多线程切换，CPU-和内存会做一些什么处理"><a href="#21、多线程切换，CPU-和内存会做一些什么处理" class="headerlink" title="21、多线程切换，CPU 和内存会做一些什么处理"></a>21、多线程切换，CPU 和内存会做一些什么处理</h3><p>在多线程环境下，当操作系统进行线程切换时，CPU 和内存会做一些处理：</p>
<ol>
<li><strong>保存当前线程的上下文：</strong> 当一个线程被抢占时，CPU 会保存当前线程的上下文信息，包括程序计数器（PC）、寄存器状态、栈指针（SP）等。这样做是为了在之后恢复线程时能够继续执行。</li>
<li><strong>加载下一个线程的上下文：</strong> CPU 根据调度算法选择下一个需要执行的线程，然后加载其上下文信息到寄存器和其他硬件状态中。</li>
<li><strong>切换内存空间：</strong> 在多线程环境下，不同线程可能会访问不同的内存区域。因此，在线程切换时，操作系统需要更新页表（Page Table）等内存映射表，以确保下一个线程能够访问到正确的内存空间。</li>
<li><strong>处理器流水线的清空和填充：</strong> 在 CPU 进行线程切换时，可能存在流水线（Pipeline）中的指令未执行完毕。在切换时，CPU 可能需要将流水线清空，以避免对新线程执行的指令产生影响。</li>
<li><strong>更新调度器信息：</strong> 操作系统需要更新线程的调度信息，包括线程的状态（就绪、运行、阻塞等），以及相关的时间片（Time Slice）等调度参数。</li>
</ol>
<h3 id="22、如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？"><a href="#22、如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？" class="headerlink" title="22、如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？"></a>22、如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？</h3><p>首先判断这个请求数量远远多于线程是常态吗，如果是常态则先要考虑是不是线程数量设置有问题，然后判断机器是否能力不足以处理这些数据。</p>
<p>假如说硬件软件都没有问题，那么考虑这个问题为什么会产生，是不是我们的高计算密集型任务太多了，如果说我们的请求任务比较复杂，那么考虑进行一个分类，将处理特别慢的请求作为一个特定类，将一些线程固定给他们使用，而不是所有线程都用来处理这种任务，因为既然很慢，那么慢1个和慢10个点区别就没有那么大了，将其他线程用来处理能够快速处理完的请求。</p>
<h3 id="23、线程间的通信包括哪些方式？"><a href="#23、线程间的通信包括哪些方式？" class="headerlink" title="23、线程间的通信包括哪些方式？"></a>23、线程间的通信包括哪些方式？</h3><ol>
<li><p><strong>互斥锁（Mutex）</strong>：用于控制多个线程对共享资源的访问，保证同一时间只有一个线程可以访问资源。</p>
</li>
<li><p><strong>条件变量</strong>：利用线程间共享全局变量进行同步的一种机制。允许一个或多个线程在某些条件下暂停执行并等待，直到另一个线程通知它们条件已经满足，从而避免了线程不断轮询检查该条件是否成立而降低效率的情况。</p>
<blockquote>
<p><strong>条件变量为什么要和互斥锁一起使用？</strong></p>
<p>这是为了应对线程<code>1</code>在调用<code>pthread_cond_wait()</code>但线程<code>1</code>还没有进入<code>wait cond</code>的状态时，线程<code>2</code>调用了<code>cond_singal</code>的情况。 </p>
<p>如果不用互斥锁的话，这个<code>cond_singal</code>就丢失了。加了锁的情况下，线程<code>2</code>必须等到<code>mutex</code>被释放（也就是<code>pthread_cond_wait()</code>释放锁并进入<code>wait_cond</code>状态 ，此时线程<code>2</code>上锁） 的时候才能调用<code>cond_singal</code>。</p>
</blockquote>
<ol>
<li><p>包含两种等待方式，无条件等待<code>pthread_cond_wait()</code>和计时等待<code>pthread_cond_timewait()</code>两种。注意无论哪种等待方式，都必须和一个互斥锁配合，以防止多个线程同时请求竞争条件；</p>
<blockquote>
<p><strong><code>pthread_cond_wait()</code> 和 <code>pthread_cond_timewait()</code> 函数为什么需要互斥锁？</strong></p>
<p>条件变量是线程同步的一种方法，这两个函数又是等待信号的函数，函数内部一定有须要同步保护的数据。</p>
</blockquote>
</li>
<li><p>互斥锁必须是普通锁或者适应锁；</p>
</li>
<li><p>在调用<code>pthread_cond_wait()</code>前必须由本线程加锁，而在更新条件等待队列以前，<code>mutex</code>保持锁定状态，并<strong>在线程挂起进入等待前解锁</strong>；</p>
<blockquote>
<p><strong>为什么必须由本线程加锁，而不在函数内部定义？</strong></p>
<p>无法确定会有多少用户使用条件变量，所以每个互斥锁都须要动态定义，而且管理大量互斥锁的开销太大，使用用户定义的锁会更加灵活又方便。</p>
</blockquote>
</li>
<li><p>在条件满足从而离开<code>pthread_cond_wait()</code>之前，<code>mutex</code>将被重新加锁，以与进入<code>pthread_cond_wait()</code>前的加锁动作对应。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">thread2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);  <span class="comment">// 调用前由本线程加锁</span></span><br><span class="line">        pthread_cond_wait(&amp;cond,&amp;mutex);  <span class="comment">// 无条件等待（经历了解锁-&gt;加锁的过程）</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>信号量（Semaphores）</strong>：如同进程一样，线程也可以通过信号量来实现通信，虽然是轻量级的。 </p>
<ol>
<li><p>初始化信号量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span> <span class="params">(<span class="type">sem_t</span> *sem , <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// sem 		- 指定要初始化的信号量； </span></span><br><span class="line"><span class="comment">// pshared 	- 信号量 sem 的共享选项，linux只支持0，表示它是当前进程的局部信号量； </span></span><br><span class="line"><span class="comment">// value 	- 信号量 sem 的初始值。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>信号量值加<code>1 </code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>信号量值减<code>1 </code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>

<p>如果<code>sem</code>所指的信号量的数值为<code>0</code>，函数将会等待直到有其它线程使它不再是<code>0</code>为止，此时相当于获取到该信号。</p>
</li>
<li><p>销毁信号量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>事件（Event）</strong>：类似于条件变量，用于通知一个或多个正在等待的线程某个事件已经发生。</p>
</li>
<li><p><strong>消息队列</strong>：线程可以发送和接收消息，消息以队列的形式管理。消息队列允许线程以异步的方式进行数据交换和事件通知。</p>
</li>
<li><p><strong>屏障（Barriers）</strong>：用于多个线程同步到某一点，当所有线程都达到屏障点后，它们再同时开始执行后续操作。常用于并行计算，确保所有线程在进行下一步操作前已完成当前操作。</p>
</li>
</ol>
<h3 id="24、线程同步是什么？从底层原理分析一下为什么会出现线程同步？"><a href="#24、线程同步是什么？从底层原理分析一下为什么会出现线程同步？" class="headerlink" title="24、线程同步是什么？从底层原理分析一下为什么会出现线程同步？"></a>24、线程同步是什么？从底层原理分析一下为什么会出现线程同步？</h3><p>（1）<strong>线程同步</strong>是多线程编程中保证多个线程安全访问共享资源或协调工作的一种机制。它确保在任何给定时刻，只有一个线程可以访问特定的数据或代码块，以防止数据损坏或不一致性。线程同步通常通过使用各种同步原语（如互斥锁、信号量、条件变量等）来实现。</p>
<p>（2）底层原理上，线程同步问题主要是由于以下几个因素导致的：</p>
<ol>
<li>并发性：多个线程同时执行，导致对共享资源的访问不可控。</li>
<li>不确定性：线程的执行顺序和执行时间不确定，可能导致对共享资源的交叉访问。</li>
<li>原子性：对共享资源的操作可能不是原子操作，而是由多条指令组成，这会导致中间状态的出现，从而引发问题。</li>
</ol>
<h3 id="25、处理多线程同步问题有哪些机制？如果想等待线程-a-执行完任务后再去执行-b，这种情况要怎么处理？"><a href="#25、处理多线程同步问题有哪些机制？如果想等待线程-a-执行完任务后再去执行-b，这种情况要怎么处理？" class="headerlink" title="25、处理多线程同步问题有哪些机制？如果想等待线程 a 执行完任务后再去执行 b，这种情况要怎么处理？"></a>25、处理多线程同步问题有哪些机制？如果想等待线程 a 执行完任务后再去执行 b，这种情况要怎么处理？</h3><p>在处理多线程同步问题时，常用的机制包括<strong>互斥锁（Mutex）、条件变量（Condition Variable）、信号量（Semaphore）</strong>等。下面简要介绍一下信号量的实现和处理方式，并举例说明如何使用。</p>
<p><strong>等待线程A执行完任务后再执行线程B的处理方式</strong></p>
<p><strong>（1）使用信号量：</strong></p>
<ul>
<li><p>可以采用C++20标准库中的<code>std::binary_semaphore</code>；</p>
<ul>
<li><p><strong>创建信号量</strong>：<code>std::binary_semaphore sem(0);</code> 初始化二元信号量，初始值为0。</p>
</li>
<li><p><strong>线程A的任务</strong>：执行完任务后调用<code>sem.release()</code>释放信号量，通知线程B可以继续执行。</p>
<p><strong>线程B的任务</strong>：调用<code>sem.acquire()</code>等待信号量被释放，然后继续执行。</p>
</li>
</ul>
</li>
<li><p>也可以用<code>POSIX</code>信号量，如<code>sem_t</code></p>
<ul>
<li><p><strong>创建信号量</strong>：<code>sem_init(&amp;sem, 0, 0);</code> 初始化POSIX信号量，初始值为0。</p>
<p><strong>线程A的任务</strong>：执行完任务后调用<code>sem_post(&amp;sem)</code>释放信号量，通知线程B可以继续执行。</p>
<p><strong>线程B的任务</strong>：调用<code>sem_wait(&amp;sem)</code>等待信号量被释放，然后继续执行。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">// For sleep function</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem;  <span class="comment">// 信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task A is running.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>); <span class="comment">// 模拟任务A执行时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task A is finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sem);  <span class="comment">// 释放信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sem);  <span class="comment">// 等待信号量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task B is running.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// 模拟任务B执行时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task B is finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 初始化信号量，初始值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">threadA</span><span class="params">(taskA)</span></span>;  <span class="comment">// 创建并启动线程A</span></span><br><span class="line">    <span class="function">std::thread <span class="title">threadB</span><span class="params">(taskB)</span></span>;  <span class="comment">// 创建并启动线程B</span></span><br><span class="line"></span><br><span class="line">    threadA.<span class="built_in">join</span>();  <span class="comment">// 等待线程A完成</span></span><br><span class="line">    threadB.<span class="built_in">join</span>();  <span class="comment">// 等待线程B完成</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;sem);  <span class="comment">// 销毁信号量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::binary_semaphore <span class="title">sem</span><span class="params">(<span class="number">0</span>)</span></span>;  <span class="comment">// 初始值为0的二元信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task A is running.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟任务A执行时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task A is finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    sem.<span class="built_in">release</span>();  <span class="comment">// 释放信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sem.<span class="built_in">acquire</span>();  <span class="comment">// 等待信号量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task B is running.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// 模拟任务B执行时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task B is finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">threadA</span><span class="params">(taskA)</span></span>;  <span class="comment">// 创建并启动线程A</span></span><br><span class="line">    <span class="function">std::thread <span class="title">threadB</span><span class="params">(taskB)</span></span>;  <span class="comment">// 创建并启动线程B</span></span><br><span class="line"></span><br><span class="line">    threadA.<span class="built_in">join</span>();  <span class="comment">// 等待线程A完成</span></span><br><span class="line">    threadB.<span class="built_in">join</span>();  <span class="comment">// 等待线程B完成</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）使用条件变量：</strong></p>
<ul>
<li><strong>创建互斥锁和条件变量</strong>，互斥锁用于保护共享数据的访问；条件变量用于阻塞一个或多个线程，直到接收到其他线程的通知。</li>
<li><strong>线程A</strong>执行完其任务后，修改共享状态变量，通知等待线程任务已完成。</li>
<li><strong>线程B</strong>等待线程A完成任务，收到通知后继续执行。</li>
</ul>
<p>其中，<code>std::condition_variable</code>用于线程间的等待和通知机制。</p>
<ul>
<li><code>std::condition_variable::wait</code>用于等待条件变量的通知，同时释放锁。</li>
<li><code>std::condition_variable::notify_one</code>或<code>notify_all</code>用于通知等待的线程条件已满足。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;  <span class="comment">// 互斥锁</span></span><br><span class="line">std::condition_variable cv;  <span class="comment">// 条件变量</span></span><br><span class="line"><span class="type">bool</span> taskA_completed = <span class="literal">false</span>;  <span class="comment">// 任务A是否完成的标志</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task A is running.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟任务A执行时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task A is finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        taskA_completed = <span class="literal">true</span>;  <span class="comment">// 设置任务A完成的标志</span></span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();  <span class="comment">// 通知一个等待线程任务A已完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> taskA_completed; &#125;); <span class="comment">// 等待任务A完成</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task B is running.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// 模拟任务B执行时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task B is finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">threadA</span><span class="params">(taskA)</span></span>;  <span class="comment">// 创建并启动线程A</span></span><br><span class="line">    <span class="function">std::thread <span class="title">threadB</span><span class="params">(taskB)</span></span>;  <span class="comment">// 创建并启动线程B</span></span><br><span class="line"></span><br><span class="line">    threadA.<span class="built_in">join</span>();  <span class="comment">// 等待线程A完成</span></span><br><span class="line">    threadB.<span class="built_in">join</span>();  <span class="comment">// 等待线程B完成</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="26、进程的五种状态分别是？"><a href="#26、进程的五种状态分别是？" class="headerlink" title="26、进程的五种状态分别是？"></a>26、进程的五种状态分别是？</h3><p>进程一共有5种状态，分别是<strong>创建、就绪、运行（执行）、终止、阻塞</strong>。</p>
<ul>
<li>运行状态就是进程正在CPU上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。</li>
<li>就绪状态就是说进程已处于准备运行的状态，即进程获得了除CPU之外的一切所需资源，一旦得到CPU即可运行。</li>
<li>阻塞状态就是进程正在等待某一事件而暂停运行，比如等待某资源为可用或等待I&#x2F;O完成。即使CPU空闲，该进程也不能运行。</li>
</ul>
<h3 id="27、进程不同状态转换的关系？"><a href="#27、进程不同状态转换的关系？" class="headerlink" title="27、进程不同状态转换的关系？"></a>27、进程不同状态转换的关系？</h3><p>进程在不同状态之间的转换过程如下：</p>
<ul>
<li><strong>创建态到就绪态</strong>：当进程创建完成并且准备好执行时，进程从创建态转换到就绪态，等待被调度执行。</li>
<li><strong>就绪态到运行态</strong>：当操作系统调度到了进程并且为其分配了CPU资源时，进程从就绪态转换到运行态，开始执行。</li>
<li><strong>运行态到阻塞态</strong>：当进程等待某些事件发生时，比如等待I&#x2F;O操作完成或者等待信号量的通知，进程从运行态转换到阻塞态。</li>
<li><strong>阻塞态到就绪态</strong>：当等待的事件发生并且进程重新具备执行条件时，进程从阻塞态转换到就绪态，等待被重新调度执行。</li>
<li><strong>运行态到终止态</strong>：当进程执行完成或者被操作系统终止时，进程从运行态转换到终止态，等待被清理和回收。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406131948229.png" alt="在这里插入图片描述"></p>
<h3 id="28、孤儿进程和僵尸进程是什么，怎么处理？"><a href="#28、孤儿进程和僵尸进程是什么，怎么处理？" class="headerlink" title="28、孤儿进程和僵尸进程是什么，怎么处理？"></a>28、孤儿进程和僵尸进程是什么，怎么处理？</h3><p>（1）<strong>孤儿进程</strong>：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被<code>init</code>进程（进程号为<code>1</code>）所收养，并由 <code>init</code> 进程对它们完成状态收集工作。</p>
<p>（2）<strong>僵尸进程</strong>：一个进程使用<code>fork</code>创建子进程，如果子进程退出，而父进程并没有调用<code>wait</code>或<code>waitpid</code>获取子进程的状态信息，那么<strong>子进程的进程描述符</strong>仍然保存在系统中。这种进程称之为僵尸进程。</p>
<p>（3）<strong>解决方案</strong>：</p>
<ul>
<li><p><strong>1）kill 杀死元凶父进程（一般不用）</strong></p>
<p>严格的说，僵尸进程并不是问题的根源，罪魁祸首是产生大量僵死进程的父进程。因此：</p>
<p>​	A. 可以直接除掉元凶，通过<code>kill</code>发送<code>SIGTERM</code>或者<code>SIGKILL</code>信号。元凶死后，僵尸进程进程变成孤儿进程，由<code>init</code>充当父进程，并回收资源；</p>
<p>​	B. 或者运行<code>kill -9 父进程的pid值</code></p>
</li>
<li><p><strong>2）父进程用 wait 或 waitpid 去回收资源（方案不好）</strong></p>
<p>父进程通过<code>wait</code>或<code>waitpid</code>等函数去等待子进程结束，但是不好，会导致父进程一直等待被挂起，相当于一个进程在干活，没有起到多进程的作用。</p>
</li>
<li><p><strong>3）通过信号机制，在处理函数中调用 wait，回收资源</strong></p>
<p>通过信号机制，子进程退出时向父进程发送<code>SIGCHLD</code>信号，父进程调用<code>signal(SIGCHLD,sig_child)</code>去处理<code>SIGCHLD</code>信号，在信号处理函数<code>sig_child()</code>中调用<code>wait</code>进行处理僵尸进程。什么时候得到子进程信号，什么时候进行信号处理，父进程可以继续做其他工作，不用去阻塞等待。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_child</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> stat;</span><br><span class="line">    <span class="comment">// 使用循环回收所有已经结束的子进程</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Child &quot;</span> &lt;&lt; pid &lt;&lt; <span class="string">&quot; terminated&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGCHLD, sig_child); <span class="comment">// 设置信号处理程序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Child process &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; started&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">2</span>); <span class="comment">// 模拟子进程工作</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">// 子进程结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程可以继续做其他工作，不会被阻塞</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parent process doing work...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="29、两个进程的内核空间是共享的吗？"><a href="#29、两个进程的内核空间是共享的吗？" class="headerlink" title="29、两个进程的内核空间是共享的吗？"></a>29、两个进程的内核空间是共享的吗？</h3><p>在大多数现代操作系统中，包括Linux和Windows，内核空间是在所有进程之间共享的。这意味着内核空间中的代码和数据结构对所有进程来说都是相同的，并且在任何时候都位于相同的物理内存位置。</p>
<h3 id="30、进程间的通信包括哪些方式？"><a href="#30、进程间的通信包括哪些方式？" class="headerlink" title="30、进程间的通信包括哪些方式？"></a>30、进程间的通信包括哪些方式？</h3><ol>
<li><p><strong>管道</strong>，半双工的通信方式，通常用于具有亲缘关系的进程之间的通信。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建管道</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>命名管道</strong>，与普通管道类似，但可以在无亲缘关系的进程之间使用。命名管道通过文件系统进行通信。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FILE <span class="string">&quot;/tmp/my_fifo&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;&#x27;hi midori&#x27; from writer(fifo)&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    fd = open(FIFO_FILE, O_WRONLY);  <span class="comment">// 打开命名管道</span></span><br><span class="line">    write(fd, message, <span class="built_in">strlen</span>(message) + <span class="number">1</span>);      <span class="comment">// 向命名管道写入数据</span></span><br><span class="line">    close(fd);      <span class="comment">// 关闭命名管道</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>消息队列</strong>，允许一个或多个进程向队列中发送消息，并从队列中接收消息。消息队列通常用于在不同进程之间传递结构化的数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_buffer</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> msg_type;</span><br><span class="line">    <span class="type">char</span> msg_text[MSG_SIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建消息队列或获取现有消息队列的标识符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向消息队列发送消息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从消息队列接收消息</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对消息队列进行控制操作，如获取信息、修改权限、删除消息队列等</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>信号量</strong>，控制进程间访问共享资源的机制，可以用来解决进程同步和互斥的问题，防止竞态条件的发生。</p>
</li>
<li><p><strong>共享内存</strong>：</p>
<ul>
<li><p><strong>效率</strong>最高，允许多个进程共享同一块内存区域，没有数据复制的开销，进程可以直接读写共享内存中的数据。</p>
</li>
<li><p>不过，1）需要额外的同步机制（如信号量或互斥锁）来防止并发访问问题；2）同时，共享内存的数据一旦被破坏，所有依赖于该数据的进程都会受到影响，容错性较差；3）需要注意临界变量的保护。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建共享内存段或获取现有共享内存段的标识符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将共享内存连接到当前进程的地址空间，返回共享内存段的首地址</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将共享内存段从当前进程的地址空间中分离，即解除映射</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对共享内存段进行控制操作，如获取信息、修改权限、删除共享内存段等</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>套接字</strong>，适用于在不同主机和不同进程之间进行通信，通常用于网络编程。</p>
</li>
</ol>
<h3 id="31、进程调度算法"><a href="#31、进程调度算法" class="headerlink" title="31、进程调度算法"></a>31、进程调度算法</h3><ol>
<li><p><strong>先来先服务 first-come first-serverd(FCFS)</strong></p>
<p><strong>非抢占式的调度算法，</strong>按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
</li>
<li><p><strong>短作业优先 shortest job first(SJF)</strong></p>
<p><strong>非抢占式的调度算法，</strong>按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
</li>
<li><p><strong>最短剩余时间优先 shortest remaining time next(SRTN)</strong></p>
<p><strong>最短作业优先的抢占式版本</strong>，按剩余运行时间的顺序进行调度。 </p>
<p>当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
</li>
<li><p><strong>时间片轮转</strong></p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li><p>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间；</p>
</li>
<li><p>而如果时间片过长，那么实时性就不能得到保证。</p>
</li>
</ul>
</li>
<li><p><strong>优先级调度</strong></p>
<p>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
</li>
<li><p><strong>多级反馈队列</strong></p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如1,2,4,8..。进程在第一个队列没执行完，就会被移到下一个队列。</p>
<p>这种方式下，之前的进程只需要交换7次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队烈上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
</li>
</ol>
<h3 id="32、进程同步的方式？"><a href="#32、进程同步的方式？" class="headerlink" title="32、进程同步的方式？"></a>32、进程同步的方式？</h3><ul>
<li><strong>互斥锁（Mutex）</strong>：互斥锁用于保护临界区，确保在同一时间只有一个线程可以进入临界区，防止多个线程同时访问共享资源，从而避免多个线程同时修改共享资源而导致的数据竞争问题。</li>
<li><strong>信号量（Semaphore）</strong>：用于实现多进程&#x2F;线程的同步，可以限制对资源的访问数量。例如，限制最多N个线程同时访问某个资源。有两种类型：计数信号量（Counting Semaphore）和二进制信号量（Binary Semaphore，类似于互斥锁）。可以用于线程之间的协调与信号传递。</li>
<li><strong>条件变量（Condition Variable）</strong>：条件变量用于在多线程之间进行条件等待和通知。它通常与互斥锁一起使用，用于等待某个条件的发生，当条件满足时，通知等待的线程可以继续执行。</li>
<li><strong>屏障（Barrier）</strong>：屏障用于同步多个线程的执行，确保它们在某个点上达到同步状态。当所有线程都到达屏障点时，屏障才会打开，允许所有线程继续执行。</li>
<li><strong>事件（Event）</strong>：事件是一种同步原语，用于线程之间的通信和同步。它允许一个线程等待另一个线程触发的事件，并且可以通过设置和清除事件来通知其他线程。</li>
<li><strong>自旋锁（Spin Lock）</strong>：自旋锁是一种基于忙等待的同步原语，它通过不停地循环检查锁的状态来等待锁的释放。在多核处理器上，自旋锁通常比较适用于短期的临界区保护。</li>
<li><strong>读写锁（Read-Write Lock）</strong>：读写锁允许多个线程同时读取共享资源，但是只允许一个线程写入共享资源。它在读取操作频繁而写入操作较少的场景中表现出色。</li>
</ul>
<h3 id="33、信号量和互斥锁解决父子线程同时阻塞的区别？"><a href="#33、信号量和互斥锁解决父子线程同时阻塞的区别？" class="headerlink" title="33、信号量和互斥锁解决父子线程同时阻塞的区别？"></a>33、信号量和互斥锁解决父子线程同时阻塞的区别？</h3><p>假设有一个场景，其中父线程和子线程需要按特定顺序访问某个资源（例如，父线程需要等待子线程完成某个任务后才能继续执行）。</p>
<ul>
<li><strong>使用互斥锁</strong>：如果使用互斥锁，需要<strong>配合条件变量</strong>来实现这种顺序控制。<strong>互斥锁本身只能保证互斥，不能控制线程之间的执行顺序</strong>。父线程需要在条件变量上等待一个特定条件（通常由子线程设置）。</li>
<li><strong>使用信号量</strong>：信号量可以更直接地控制执行顺序。父线程等待子线程释放某个信号后才能继续执行，这样就实现了对资源的访问顺序。</li>
</ul>
<h3 id="34、windows-下-thread-create-会有什么问题？"><a href="#34、windows-下-thread-create-会有什么问题？" class="headerlink" title="34、windows 下 thread_create 会有什么问题？"></a>34、windows 下 thread_create 会有什么问题？</h3><p>在 Windows 下使用 <code>CreateThread</code> 可能会有以下问题：</p>
<ol>
<li><strong>资源泄漏</strong>：没有适当关闭线程句柄会导致句柄泄漏。</li>
<li><strong>安全性</strong>：<code>CreateThread</code> 不会初始化 C 运行时，可能导致与 C++ 库的兼容性问题。</li>
<li><strong>不一致的 TLS</strong>：使用 <code>CreateThread</code> 时，线程局部存储 (TLS) 的初始化可能不正确。</li>
<li><strong>异常处理</strong>：与 <code>std::thread</code> 的异常处理机制不同，可能导致异常未被捕获。</li>
</ol>
<p>建议使用 C++ 标准库的 <code>std::thread</code>，以避免这些潜在问题。</p>
<h3 id="35、知道哪些信号的含义？SIGALRM-SIGSEGV-SIGINT"><a href="#35、知道哪些信号的含义？SIGALRM-SIGSEGV-SIGINT" class="headerlink" title="35、知道哪些信号的含义？SIGALRM, SIGSEGV, SIGINT?"></a>35、知道哪些信号的含义？SIGALRM, SIGSEGV, SIGINT?</h3><p><strong>SIGALRM</strong>：时钟定时器超时信号，通常用于定时操作。</p>
<p><strong>SIGSEGV</strong>：非法内存访问信号，通常由无效的指针或越界访问引发。</p>
<p><strong>SIGINT</strong>：中断信号，通常由用户通过 Ctrl+C 发出，用于中断程序执行。</p>
<h3 id="36、Ctrl-C-后发生了什么？"><a href="#36、Ctrl-C-后发生了什么？" class="headerlink" title="36、Ctrl+C 后发生了什么？"></a>36、Ctrl+C 后发生了什么？</h3><p>按下 Ctrl+C 后，会向前台运行的进程发送 SIGINT 信号。这个信号通常用于中断和终止正在运行的程序。如果程序捕获并处理了 SIGINT 信号，它可以执行清理操作或选择忽略信号；否则，默认行为是终止程序。</p>
<h3 id="37、sigaction-可以干哪些事情？解释一下屏蔽集？"><a href="#37、sigaction-可以干哪些事情？解释一下屏蔽集？" class="headerlink" title="37、sigaction 可以干哪些事情？解释一下屏蔽集？"></a>37、sigaction 可以干哪些事情？解释一下屏蔽集？</h3><p><code>sigaction</code> 是一个用于设置和检测信号处理方式的系统调用，在处理信号时比较灵活，它可以完成以下几个主要的功能：</p>
<ol>
<li><strong>设置信号处理函数</strong>：可以用于指定一个函数，用来处理特定信号发生时的行为。</li>
<li><strong>指定信号的处理方式</strong>：可以指定信号的处理方式，比如忽略信号、执行默认操作、或者调用指定的处理函数。</li>
<li><strong>检查和修改信号的屏蔽集</strong>：可以检查当前对信号的屏蔽状态，也可以修改进程对信号的屏蔽集。</li>
</ol>
<p><strong>屏蔽集（Signal Mask）</strong> 是一个用来管理信号处理的机制，它决定了在特定时间点一个进程可以接收哪些信号。当信号被屏蔽时，进程在收到该信号时不会立即处理，而是被加入到未决信号集中，直到信号被解除屏蔽后才会处理。</p>
<p>屏蔽集可以通过 <code>sigprocmask</code> 系统调用来设置和修改，主要有以下几个操作：</p>
<ul>
<li><strong>阻塞信号</strong>：将某些信号添加到屏蔽集中，使得进程在屏蔽集中的信号处于阻塞状态，不会被处理。</li>
<li><strong>解除信号阻塞</strong>：从屏蔽集中移除某些信号，使得进程可以处理这些信号。</li>
<li><strong>查询当前屏蔽集</strong>：获取当前进程的信号屏蔽状态。</li>
</ul>
<p>屏蔽集在多线程环境中尤为重要，可以帮助控制每个线程对信号的响应方式，从而避免因信号处理不当而导致的竞态条件或者其他问题。</p>
<h3 id="38、线程崩溃，进程一定会崩溃吗？"><a href="#38、线程崩溃，进程一定会崩溃吗？" class="headerlink" title="38、线程崩溃，进程一定会崩溃吗？"></a>38、线程崩溃，进程一定会崩溃吗？</h3><p>一般来说，如果线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃，为什么系统要让进程崩溃呢，这主要是因为在进程中，<strong>各个线程的地址空间是共享的</strong>，既然是共享，那么某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程，这种操作是危险的，操作系统会认为这很可能导致一系列严重的后果，于是干脆让整个进程崩溃。</p>
<h2 id="二、内存模型-虚拟内存"><a href="#二、内存模型-虚拟内存" class="headerlink" title="二、内存模型&#x2F;虚拟内存"></a>二、内存模型&#x2F;虚拟内存</h2><h3 id="39、什么是虚拟内存？"><a href="#39、什么是虚拟内存？" class="headerlink" title="39、什么是虚拟内存？"></a>39、什么是虚拟内存？</h3><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301943905.png" alt="img" style="zoom: 67%;" />

<h3 id="40、为什么操作系统要使用虚拟内存？"><a href="#40、为什么操作系统要使用虚拟内存？" class="headerlink" title="40、为什么操作系统要使用虚拟内存？"></a>40、为什么操作系统要使用虚拟内存？</h3><ol>
<li>第一，虚拟内存可以<strong>使得进程对运行内存超过物理内存大小</strong>，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li>
<li>第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就<strong>解决了多进程之间地址冲突的问题</strong>。</li>
<li>第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统<strong>提供了更好的安全性</strong>。</li>
</ol>
<h3 id="41、虚拟内存有没有大小的限制？"><a href="#41、虚拟内存有没有大小的限制？" class="headerlink" title="41、虚拟内存有没有大小的限制？"></a>41、虚拟内存有没有大小的限制？</h3><ol>
<li><p>虚拟内存的大小<strong>受到地址线的限制</strong>：</p>
<ul>
<li><p><code>32</code>位系统下虚拟内存空间的大小为2^32^字节（约4GB）；</p>
</li>
<li><p><code>64</code>位系统下虚拟内存空间的大小为2^64^字节。</p>
</li>
</ul>
</li>
<li><p>另外，操作系统还可以通过配置来限制每个进程能够使用的虚拟内存大小。</p>
</li>
</ol>
<h3 id="42、虚拟内存中分页算法是为了解决什么样的问题？"><a href="#42、虚拟内存中分页算法是为了解决什么样的问题？" class="headerlink" title="42、虚拟内存中分页算法是为了解决什么样的问题？"></a>42、虚拟内存中分页算法是为了解决什么样的问题？</h3><p>虚拟内存中的分页算法是为了解决<strong>连续长内存分配时物理内存不足</strong>的问题。它通过<strong>将内存分成固定大小的页面（page），并将页面映射到物理内存或者存储在磁盘上的页面文件</strong>中，来提供更大的地址空间。</p>
<h3 id="43、虚拟内存的内存模型如何？"><a href="#43、虚拟内存的内存模型如何？" class="headerlink" title="43、虚拟内存的内存模型如何？"></a>43、虚拟内存的内存模型如何？</h3><p>其内存分布或内存模型实际上就是虚拟内存。主要分为以下几个部分，分别是：<code>.text</code>段，<code>.rodata</code>段，<code>.data</code>段，<code>.bss</code>段，堆，内存映射区，栈，内核空间。其中，各项主要内容如下：</p>
<p>（1）**.text段** ：主要存在程序编译后的机器指令；</p>
<p>（2）**.rodata段 **：主要存放程序中的各种只读变量；</p>
<p>（3）**.data段**：主要存放指定了初始值的全局变量和静态变量；</p>
<p>（4）**.bss段**：主要存放没有指定初始值的全局变量和静态变量，这些未初始化的全局变量被加载进内存之后会被初始化为 0 值；</p>
<p>（5）<strong>堆</strong>：由程序员进行动态分配，如调用 malloc 或 new；</p>
<p>（6）<strong>文件映射与匿名映射区</strong>：存放动态链接库中的代码段，数据段，BSS 段，以及通过 mmap 系统调用映射的共享内存区；</p>
<p>（7）<strong>栈</strong>：由编译器自动分配释放，存放调用函数过程中使用到的局部变量和函数参数等；</p>
<p>（8）<strong>内核空间</strong>：存放操作系统的一些内核数据和代码。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/ffb6e1727e2289f142f6a2a6291cd68c.png" alt="image.png" style="zoom: 50%;" />

<img src="https://cdn.xiaolincoding.com//mysql/other/532e6cdf4899588f8b873b6435cba2d8.png" alt="image.png" style="zoom: 33%;" />

<h3 id="44、为什么要区分代码段和数据段？"><a href="#44、为什么要区分代码段和数据段？" class="headerlink" title="44、为什么要区分代码段和数据段？"></a>44、为什么要区分代码段和数据段？</h3><ul>
<li><strong>访问权限控制</strong>：<strong>代码段通常设置为只读</strong>，以防止程序代码被意外或恶意修改，这可能导致程序行为不正确或系统安全受到威胁。<strong>数据段则通常需要读写权限</strong>，因为程序在运行时需要修改数据。</li>
<li><strong>分页策略</strong>：代码段和数据段可能会<strong>采用不同的分页和交换策略</strong>。例如，代码页可能较少交换出内存，因为它们被频繁访问；而数据段的某些部分<strong>如果使用不频繁可以被交换出去</strong>以节约资源。</li>
</ul>
<h3 id="45、堆和栈有什么样的区别？"><a href="#45、堆和栈有什么样的区别？" class="headerlink" title="45、堆和栈有什么样的区别？"></a>45、堆和栈有什么样的区别？</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301519980.png" alt="image-20240630151957779"></p>
<h3 id="46、什么时候用栈，什么时候用堆？"><a href="#46、什么时候用栈，什么时候用堆？" class="headerlink" title="46、什么时候用栈，什么时候用堆？"></a>46、什么时候用栈，什么时候用堆？</h3><ol>
<li><p>与堆相比，栈不会导致内存碎片，分配效率高。<strong>函数返回地址，函数的局部变量，调用参数以及使用的寄存器</strong>等信息都采取栈的形式存放，如果<strong>少量数据需要频繁的操作</strong>，那么在程序中动态申请少量栈内存会获得很好的性能提升。</p>
</li>
<li><p>堆可以申请的内存大很多，与堆相比，栈的使用没那么灵活，如果<strong>分配大量的内存空间</strong>，推荐使用堆内存，保存着程序运行时使用new, malloc等动态分配的内存。</p>
</li>
</ol>
<h3 id="47、不同段上的对象的生命周期是怎样的？"><a href="#47、不同段上的对象的生命周期是怎样的？" class="headerlink" title="47、不同段上的对象的生命周期是怎样的？"></a>47、不同段上的对象的生命周期是怎样的？</h3><ol>
<li><p><code>.data/.bss</code>段的生命周期<strong>和程序的生命周期一致</strong>，在程序加载到内存时被分配，程序结束时被销毁；</p>
</li>
<li><p><code>堆</code>上的对象<strong>由程序员进行动态分配</strong>；</p>
</li>
<li><p><code>栈</code>上的对象由编译器进行分配，当<strong>离开作用域范围时被编译器销毁</strong>。</p>
</li>
</ol>
<h3 id="48、如何让对象只能存在于栈-堆中？"><a href="#48、如何让对象只能存在于栈-堆中？" class="headerlink" title="48、如何让对象只能存在于栈&#x2F;堆中？"></a>48、如何让对象只能存在于栈&#x2F;堆中？</h3><ol>
<li>如果<strong>将<code>operator new</code>设置为私有的</strong>，此时尝试在堆上分配内存失败，对象就会<strong>存在于栈中</strong>。</li>
<li>由于编译器在栈上分配内存时会自动调用其构造函数和析构函数，因此如果<strong>将析构函数设置为私有的</strong>，在栈上分配内存失败，对象就会<strong>存在于堆中</strong>。</li>
</ol>
<h3 id="49、栈的速度为什么比堆上的要快？"><a href="#49、栈的速度为什么比堆上的要快？" class="headerlink" title="49、栈的速度为什么比堆上的要快？"></a>49、<strong>栈的速度为什么比堆上的要快？</strong></h3><p>栈的读取速度比堆上的要快，主要是由于以下几个原因：</p>
<ol>
<li><strong>数据结构的特点</strong>：栈是一种线性数据结构，其操作是基于栈顶的，因此可以通过简单的指针操作来读取栈上的数据。相比之下，堆是一种树形数据结构，要读取堆上的数据可能需要进行指针的跳转和内存的查找操作，因此相对更为复杂和耗时。</li>
<li><strong>内存布局的连续性</strong>：栈上的内存分配是连续的，数据项之间存储的地址是相邻的，这使得栈上的数据读取更为高效，因为可以通过栈指针进行连续的内存读取操作。而堆上的内存分配是动态的，可能是分散的，需要通过指针跳转来访问不同的内存块，导致读取速度较慢。 </li>
<li><strong>硬件优化</strong>：由于栈的读取操作频繁且简单，因此处理器和编译器通常会对栈上的操作进行优化，例如采用特定的指令集或硬件机制来提高栈操作的执行效率。相比之下，堆上的内存操作较为复杂，难以进行同样程度的优化。</li>
</ol>
<h3 id="50、栈何时会溢出？"><a href="#50、栈何时会溢出？" class="headerlink" title="50、栈何时会溢出？"></a>50、<strong>栈何时会溢出</strong>？</h3><ol>
<li><p>递归调用层次过深：如果一个程序中存在递归调用，而递归调用的层次过深，会导致栈空间不足，从而发生栈溢出。</p>
</li>
<li><p>局部变量占用过多空间：当一个函数中声明了过多的局部变量，或者某个局部变量占用的内存空间过大时，会导致栈空间快速耗尽，从而发生栈溢出。</p>
</li>
<li><p>大量函数调用嵌套：如果程序中存在大量的函数调用嵌套，而栈空间不足以容纳所有的函数调用信息，也会导致栈溢出。</p>
</li>
</ol>
<blockquote>
<p>在 C&#x2F;C++ 中，可以使用编译器选项 <code>-Wl,--stack,&lt;size&gt;</code> 来设置栈的大小。</p>
</blockquote>
<h3 id="51、new-和-malloc-的区别？"><a href="#51、new-和-malloc-的区别？" class="headerlink" title="51、new 和 malloc 的区别？"></a>51、new 和 malloc 的区别？</h3><p>主要包含以下区别：</p>
<ol>
<li>malloc 是 C 中的函数，但可以同时在 C&#x2F;C++ 中使用；new 是 C++ 特有的操作符，只能在 C++ 中使用；</li>
<li>malloc 在使用时需要指定分配内存的大小，如 <code>malloc(sizeof(int))</code>，但 new 的使用则比较简洁，如 <code>new int</code>；</li>
<li>malloc 分配的内存是未定义的，而 new 在分配内存时还会调用构造函数进行初始化；</li>
<li>malloc 返回的是 void * 类型的指针，需要进行强制类型转换以得到需要的指针类型，而 new 会自动转换为响应的指针类型；</li>
<li>malloc 调用 free 进行释放， new 调用 delete 进行释放。</li>
<li>若内存分配失败，malloc 调用会返回 nullptr，而 new 调用会返回 <code>std::bad_alloc</code>。</li>
</ol>
<h3 id="52、既然有了-malloc-free，为什么还需要-new-delete-呢？"><a href="#52、既然有了-malloc-free，为什么还需要-new-delete-呢？" class="headerlink" title="52、既然有了 malloc&#x2F;free，为什么还需要 new&#x2F;delete 呢？"></a>52、既然有了 malloc&#x2F;free，为什么还需要 new&#x2F;delete 呢？</h3><ul>
<li>malloc&#x2F;free 和 new&#x2F;delete 都是用来申请内存和回收内存的。</li>
<li>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而 malloc&#x2F;free 是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给 malloc&#x2F;free，所以 new&#x2F;delete 是必不可少的。</li>
</ul>
<h3 id="53、malloc-函数的底层实现是什么？"><a href="#53、malloc-函数的底层实现是什么？" class="headerlink" title="53、malloc() 函数的底层实现是什么？"></a>53、malloc() 函数的底层实现是什么？</h3><ol>
<li>当开辟的空间<strong>小于 128kb</strong> 时，调用 <code>brk()</code> 函数，先遍历空闲内存链表，如果有已释放且空间足够的内存块就拿来用。如果找不到就移动指针 <code>_enddata</code>，即堆区的末尾地址，将「堆顶」指针往高地址推。</li>
<li>当开辟的空间<strong>大于 128kb</strong>  时，系统调用 <code>mmap()</code> 在堆和栈之间找一块空闲内存分配.</li>
<li><code>malloc()</code> 在分配用户传入大小的内存时，还<strong>额外分配一个用于管理的内存</strong>，大小为 8 字节。因此，free() 函数只传入一个内存地址却能知道要释放多大的内存。而由于堆中的内存是成块分配的，与内存对齐有关，在 64 位系统中，内存对齐为 16 字节，因此<strong>实际分配的内存大小还要考虑 8 字节的管理内存和内存对齐</strong>。</li>
</ol>
<blockquote>
<p>brk() 是将「堆顶」指针向高地址移动，获得新的内存空间；mmap() 是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</p>
<p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mem_control_block</span> &#123;</span><br><span class="line">    <span class="type">int</span> is_available;      <span class="comment">// 1表可用，0表不可用</span></span><br><span class="line">    <span class="type">int</span> size;                 <span class="comment">// 总大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="54、mmap-的原理"><a href="#54、mmap-的原理" class="headerlink" title="54、mmap() 的原理"></a>54、mmap() 的原理</h3><p><code>mmap()</code> 是一个系统调用，用于在进程的地址空间中创建一个新的映射区域（mapping）。</p>
<ol>
<li><strong>创建映射区域</strong>：<ul>
<li><code>mmap()</code> 可以将一个文件或者其它对象（如设备内存）映射到调用进程的地址空间中。这个映射区域可以是文件的一部分或者整个文件，也可以是一个设备的内存区域。</li>
<li>映射的区域可以是只读的、可读写的、或者私有的（写时复制）。</li>
</ul>
</li>
<li><strong>映射对象类型</strong>：<ul>
<li>文件映射：<code>mmap()</code> 可以将一个文件映射到进程的地址空间中，这样可以通过内存操作来读写文件，而不需要使用标准的文件 I&#x2F;O 操作函数（如 <code>read()</code> 和 <code>write()</code>）。</li>
<li>匿名映射：<code>mmap()</code> 还可以用于创建一个不与文件关联的映射区域，通常用于进程间通信或者动态内存分配。</li>
</ul>
</li>
<li><strong>映射区域的使用</strong>：<ul>
<li>映射区域创建后，进程可以像访问普通内存一样访问这些区域。读写映射区域的内容会直接影响到原始文件或者设备。</li>
</ul>
</li>
</ol>
<h3 id="55、假设分配一块内存-int-p-int-malloc-100-那么-free-p-50-可不可以，为什么；如果想把这块内存扩充到200字节，应该怎么做？"><a href="#55、假设分配一块内存-int-p-int-malloc-100-那么-free-p-50-可不可以，为什么；如果想把这块内存扩充到200字节，应该怎么做？" class="headerlink" title="55、假设分配一块内存 int* p &#x3D; (int*)malloc(100); 那么 free(p+50) 可不可以，为什么；如果想把这块内存扩充到200字节，应该怎么做？"></a>55、假设分配一块内存 int* p &#x3D; (int*)malloc(100); 那么 free(p+50) 可不可以，为什么；如果想把这块内存扩充到200字节，应该怎么做？</h3><p>（1）<strong>free(p+50) 是否有效？</strong></p>
<ul>
<li><code>malloc(100)</code> 分配了一个可以容纳 100 个字节的内存块，并返回一个指向该内存块起始位置的指针 <code>p</code>。</li>
<li>表达式 <code>p + 50</code> 实际上是将指针 <code>p</code> 向后移动了 50 个 <code>int</code> 类型大小的位置，因为 <code>p</code> 是指向 <code>int</code> 的指针。</li>
<li>因此，<code>free(p + 50)</code> 将会尝试释放 <code>p</code> 指向的内存块的中间部分，这不符合内存分配和释放的规范，可能会导致未定义的行为或者程序崩溃。</li>
<li>正确的做法是只能通过 <code>free(p)</code> 来释放整个内存块，因为 <code>malloc</code> 返回的指针必须是 <code>free</code> 所接受的完整块的起始地址。</li>
</ul>
<p>（2）<strong>将内存扩充到 200 字节应该如何操作？</strong></p>
<ul>
<li><p>在 C 语言中，<code>malloc</code> 分配的内存是固定大小的，一旦分配完成后，大小不能直接更改。要将内存扩充到 200 字节，可以使用 <code>realloc</code> 函数。</p>
</li>
<li><p><code>realloc</code> 函数可以重新分配先前通过 <code>malloc</code> 或 <code>calloc</code> 分配的内存块，将其大小调整为新的字节数。</p>
</li>
<li><p>例如，要将 <code>p</code> 指向的内存块扩充到 200 字节，可以使用以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* q = (<span class="type">int</span>*)<span class="built_in">realloc</span>(p, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">if</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    p = q; <span class="comment">// 更新 p，因为 realloc 可能会返回新的地址</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>realloc(p, 200)</code> 将尝试将原始分配的内存块大小调整为 200 字节。如果内存块成功扩展，<code>realloc</code> 返回一个指向新分配区域的指针，并且原来的 <code>p</code> 指针仍然有效（或者更新为新的地址）。如果失败，返回 <code>NULL</code>，并且原来的 <code>p</code> 指针仍然有效。</p>
</li>
</ul>
<h3 id="56、malloc、realloc、calloc的区别"><a href="#56、malloc、realloc、calloc的区别" class="headerlink" title="56、malloc、realloc、calloc的区别"></a>56、malloc、realloc、calloc的区别</h3><ol>
<li>malloc函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_size)</span></span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">20</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));申请<span class="number">20</span>个<span class="type">int</span>类型的空间；</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>calloc函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">calloc</span><span class="params">(<span class="type">size_t</span> n,<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">calloc</span>(<span class="number">20</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</p>
<ol start="3">
<li>realloc函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">realloc</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></table></figure>

<p>给动态分配的空间分配额外的空间，用于扩充容量。</p>
<h3 id="57、对于-malloc-分配的内存，调用-free-后立即释放吗？"><a href="#57、对于-malloc-分配的内存，调用-free-后立即释放吗？" class="headerlink" title="57、对于 malloc() 分配的内存，调用 free() 后立即释放吗？"></a>57、对于 malloc() 分配的内存，调用 free() 后立即释放吗？</h3><p>在使用 <code>brk()</code> 或 <code>sbrk()</code> 分配的情况下，这块内存并不会立即返还给操作系统，而是标记为<strong>可再利用状态</strong>，并被 <code>ptmalloc</code> 使用双链表保存起来。当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时 <code>ptmalloc</code> 也会尝试对小块内存进行合并，避免过多的内存碎片。如果释放的是堆末端的内存，程序的断点可能会被回退，从而实际上将内存返还给操作系统。</p>
<p>而对于使用 <code>mmap()</code> 分配的较大内存块，在调用 <code>free()</code> 后通常会通过 <code>munmap()</code> 立即返还给操作系统。</p>
<h3 id="58、既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么-malloc-不全部使用-mmap-来实现，而是仅仅对于大于-128k-的大块内存才使用-mmap-？"><a href="#58、既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么-malloc-不全部使用-mmap-来实现，而是仅仅对于大于-128k-的大块内存才使用-mmap-？" class="headerlink" title="58、既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么 malloc() 不全部使用 mmap() 来实现，而是仅仅对于大于 128k 的大块内存才使用 mmap()？"></a>58、既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么 malloc() 不全部使用 mmap() 来实现，而是仅仅对于大于 128k 的大块内存才使用 mmap()？</h3><p>因为向操作系统申请内存，是要通过系统调用的，执行系统调用是要进入内核态的，然后在回到用户态，运行态的切换会耗费不少时间。所以，申请内存的操作应该避免频繁的系统调用，如果都用 mmap 来分配内存，等于每次都要执行系统调用。</p>
<p>另外，因为 mmap 分配的内存每次释放的时候，都会归还给操作系统，于是每次  mmap 分配的虚拟地址都是缺页状态的，然后在第一次访问该虚拟地址的时候，就会触发缺页中断。也就是说，<strong>频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大</strong>。</p>
<p>为了改进这两个问题，malloc 通过 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。等下次在申请内存的时候，就直接从内存池取出对应的内存块就行了，而且可能这个内存块的虚拟地址与物理地址的映射关系还存在，这样不仅减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低 CPU 的消耗。</p>
<h3 id="59、kmalloc-和用户态的-malloc-有什么区别。"><a href="#59、kmalloc-和用户态的-malloc-有什么区别。" class="headerlink" title="59、kmalloc() 和用户态的 malloc() 有什么区别。"></a>59、kmalloc() 和用户态的 malloc() 有什么区别。</h3><ul>
<li><code>kmalloc()</code> 是在<strong>内核空间</strong>中使用的内存分配函数，主要用于为内核模块或驱动程序分配内存，直接从操作系统的内核内存池中分配内存，这部分内存通常是预先保留给内核的，不会被用户空间的应用程序直接访问。</li>
<li><code>malloc()</code> 是在<strong>用户空间</strong>中使用的内存分配函数，用于应用程序分配内存，分配的内存来自于用户空间的堆区，这部分内存是由操作系统管理，供所有用户程序共享使用。</li>
</ul>
<h3 id="60、在已申请的内存中构造对象如何实现？"><a href="#60、在已申请的内存中构造对象如何实现？" class="headerlink" title="60、在已申请的内存中构造对象如何实现？"></a>60、在已申请的内存中构造对象如何实现？</h3><p>使用<code>placement new</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="built_in">sizeof</span>(MyClass)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在buffer指定的地址上构造MyClass对象</span></span><br><span class="line">MyClass* pMyClass = <span class="built_in">new</span> (buffer) <span class="built_in">MyClass</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动调用析构函数</span></span><br><span class="line">pMyClass-&gt;~<span class="built_in">MyClass</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>构造和析构</strong>：使用 placement new 构造对象后，必须手动调用该对象的析构函数来确保正确的资源释放。因为普通的 delete 操作符会尝试释放内存，这在使用 placement new 时是不适用的。</li>
<li><strong>对齐要求</strong>：需要确保传递给 placement new 的内存地址满足对象的对齐要求。</li>
<li><strong>内存管理</strong>：使用 placement new 的代码需要格外注意内存的管理，以避免内存泄露或重复析构等问题。</li>
</ul>
<h3 id="61、new-、operator-new-和-placement-new-区别"><a href="#61、new-、operator-new-和-placement-new-区别" class="headerlink" title="61、new 、operator new 和 placement new 区别"></a>61、new 、operator new 和 placement new 区别</h3><p>（1）<code>new</code>：不能被重载，其行为总是一致的。它先调用 operator new 分配内存，然后调用构造函数初始化那段内存。</p>
<p>（2）<code>operator new</code>：要实现不同的内存分配行为，应该重载 operator new，而不是 new。</p>
<ul>
<li>operator new 就像 operator + 一样，是可以重载的。<strong>如果类中没有重载 operator new，那么调用的就是全局的 ::operator  new 来完成堆的分配。</strong>同理，operator new[]、operator delete、operator delete[] 也是可以重载的。</li>
<li>重载时，返回类型必须声明为 void*，第一个参数类型必须为表达要求分配空间的大小（字节），类型为 size_t，可以带其它参数。</li>
</ul>
<p>（3）<code>placement new</code>：<strong>只是 operator new 重载的一个标准、全局的版本</strong>。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。因此不能删除它，但需要调用对象的析构函数。placement new 允许在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。原型中 void* p 实际上就是指向一个已经分配好的内存缓冲区的的首地址。</p>
<h3 id="62、对于-delete-parray，编译器怎么知道-parray-这个指针实际指向的是数组还是单个元素？"><a href="#62、对于-delete-parray，编译器怎么知道-parray-这个指针实际指向的是数组还是单个元素？" class="headerlink" title="62、对于 delete[] parray，编译器怎么知道 parray 这个指针实际指向的是数组还是单个元素？"></a>62、对于 delete[] parray，编译器怎么知道 parray 这个指针实际指向的是数组还是单个元素？</h3><p>对象在分配时分配器会自动写一个日志（即在分配的内存之前有一个结构），用于记录分配的大小，分配内容的 <code>sizeof</code> 等等。直观来说，<code>delete</code>和<code>delete[]</code>都是传入一个<code>void*</code>，因此如果不保存日志就无法知道分配时到底是分配了一个还是多个单元。所以虽然<code>delete</code>和<code>delete[]</code>不同，但是分配器在执行释放过程中都会读取这个日志，从而了解到底应该释放多少内存。</p>
<p>但是有个前提：对象类型（或其基类）有显式析构函数。换句话说，析构函数是<code>non-virtual</code>的。否则的话，数组前面是没有这个日志的。对于析构函数是<code>virtual</code>的情况，<code>delete[]</code>时无需调用其析构函数，因此此时<code>VC</code>把<code>delete[]</code>当做<code>delete</code>同样处理。</p>
<h3 id="63、比如有一个-1G-的数据，频繁调用-new-malloc-以及-delete-free，如何优化性能？"><a href="#63、比如有一个-1G-的数据，频繁调用-new-malloc-以及-delete-free，如何优化性能？" class="headerlink" title="63、比如有一个 1G 的数据，频繁调用 new&#x2F;malloc 以及 delete&#x2F;free，如何优化性能？"></a>63、比如有一个 1G 的数据，频繁调用 new&#x2F;malloc 以及 delete&#x2F;free，如何优化性能？</h3><p>频繁调用 <code>new</code>&#x2F;<code>malloc</code> 和 <code>delete</code>&#x2F;<code>free</code> 可能导致内存分配和释放的开销增加，从而影响系统性能。针对这种情况，可以考虑以下优化策略：</p>
<ol>
<li><strong>内存池管理</strong>：<ul>
<li>实现自定义的内存池，预先分配一定大小的内存块，而不是每次调用 <code>new</code>&#x2F;<code>malloc</code> 时都向系统请求内存。这样可以减少系统调用次数和内存碎片化。内存池可以是固定大小的块，也可以是根据需要动态增长或缩减的块。它们可以通过链表或者数组来管理。</li>
</ul>
</li>
<li><strong>对象池技术</strong>：<ul>
<li>如果频繁创建和销毁对象，可以使用对象池技术。对象池在程序启动时预先创建一定数量的对象，并在需要时从池中获取对象，使用完毕后再放回池中。这样可以避免对象的重复创建和销毁，减少内存分配和释放的开销。</li>
</ul>
</li>
<li><strong>重用机制</strong>：<ul>
<li>尽可能重用已分配的内存块。在需要释放内存时，不立即释放，而是放入一个空闲链表或者空闲对象池中，以便下次分配时能够快速重用。</li>
<li>对于频繁分配相同大小的内存，可以采用内存池的方式进行管理，避免反复请求和释放系统内存。</li>
</ul>
</li>
<li><strong>内存分配策略优化</strong>：<ul>
<li>对于需要频繁分配和释放的小对象，可以考虑使用更高效的分配策略，如 <code>std::allocator</code> 或者专门优化的内存分配器（如 tcmalloc 或 jemalloc）。</li>
<li>这些分配器通常比标准库的 <code>malloc</code> 和 <code>free</code> 实现更加高效，能够降低内存碎片化和系统调用次数。</li>
</ul>
</li>
<li><strong>避免内存泄漏和悬空指针</strong>：<ul>
<li>确保每次分配的内存均能在适当的时候释放，避免内存泄漏。</li>
<li>使用智能指针（如 <code>std::shared_ptr</code>、<code>std::unique_ptr</code>）等 RAII 技术管理资源，可以有效避免悬空指针和内存泄漏问题。</li>
</ul>
</li>
<li><strong>内存分配的时机和位置</strong>：<ul>
<li>在程序设计阶段，合理规划和设计内存的分配和释放时机，尽量避免频繁的动态内存分配和释放。可以考虑在初始化阶段预分配一部分内存，减少后续的动态内存操作频率。</li>
</ul>
</li>
</ol>
<h3 id="64、内存分配的过程是怎样的？"><a href="#64、内存分配的过程是怎样的？" class="headerlink" title="64、内存分配的过程是怎样的？"></a>64、内存分配的过程是怎样的？</h3><p>应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。</p>
<p>当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存， 这时会发现这个虚拟内存没有映射到物理内存， CPU 就会产生<strong>缺页中断</strong>，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler （缺页中断函数）处理。缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。</p>
<h3 id="65、内存紧张-没有空闲物理内存时有哪些操作？"><a href="#65、内存紧张-没有空闲物理内存时有哪些操作？" class="headerlink" title="65、内存紧张&#x2F;没有空闲物理内存时有哪些操作？"></a>65、内存紧张&#x2F;没有空闲物理内存时有哪些操作？</h3><p>如果没有空闲的物理内存，那么内核就会开始进行<strong>回收内存</strong>的工作，回收的方式主要是两种：直接内存回收和后台内存回收。</p>
<ul>
<li><strong>后台内存回收</strong>（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程<strong>异步</strong>的，不会阻塞进程的执行。</li>
<li><strong>直接内存回收</strong>（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是<strong>同步</strong>的，会阻塞进程的执行。</li>
</ul>
<p>如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，内核触发 <strong>OOM （Out of Memory）机制</strong>。OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406302002710.png" alt="img"></p>
<h3 id="66、哪些内存可以被回收？"><a href="#66、哪些内存可以被回收？" class="headerlink" title="66、哪些内存可以被回收？"></a>66、哪些内存可以被回收？</h3><p>主要有两类内存可以被回收，而且它们的回收方式也不同。</p>
<ul>
<li><strong>文件页</strong>（File-backed  Page）：内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）都叫作文件页。大部分文件页，都可以直接释放内存，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。所以，<strong>回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存</strong>。</li>
<li><strong>匿名页</strong>（Anonymous Page）：这部分内存没有实际载体，不像文件缓存有硬盘文件这样一个载体，比如堆、栈数据等。这部分内存很可能还要再次被访问，所以不能直接释放内存，它们<strong>回收的方式是通过 Linux 的 Swap 机制</strong>，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。</li>
</ul>
<p>文件页和匿名页的回收都是基于 LRU 算法，也就是优先回收不常访问的内存。LRU 回收算法，实际上维护着 active 和 inactive 两个双向链表，其中：</p>
<ul>
<li><strong>active_list</strong> 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；</li>
<li><strong>inactive_list</strong> 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</li>
</ul>
<p>越接近链表尾部，就表示内存页越不常访问。这样，在回收内存时，系统就可以根据活跃程度，优先回收不活跃的内存。</p>
<h3 id="67、针对回收内存页导致的性能影响，有哪些解决方式？"><a href="#67、针对回收内存页导致的性能影响，有哪些解决方式？" class="headerlink" title="67、针对回收内存页导致的性能影响，有哪些解决方式？"></a>67、针对回收内存页导致的性能影响，有哪些解决方式？</h3><ol>
<li><p><strong>设置 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness，调整文件页和匿名页的回收倾向，尽量倾向于回收文件页；</strong></p>
<p>从文件页和匿名页的回收操作来看，文件页的回收操作对系统的影响相比匿名页的回收操作会少一点，因为文件页对于干净页回收是不会发生磁盘 I&#x2F;O 的，而匿名页的 Swap 换入换出这两个操作都会发生磁盘 I&#x2F;O。</p>
<p>Linux 提供了一个 <code>/proc/sys/vm/swappiness</code> 选项，用来调整文件页和匿名页的回收倾向。</p>
<p>swappiness 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@xiaolin ~]# cat /proc/sys/vm/swappiness</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>一般建议 swappiness 设置为 0（默认值是 60），这样在回收内存的时候，会更倾向于文件页的回收，但是并不代表不会回收匿名页。</p>
</li>
<li><p><strong>设置 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;min_free_kbytes，调整 kswapd 内核线程异步回收内存的时机；</strong></p>
<p>如果系统时不时发生抖动，并且在抖动的时间段里如果通过 sar -B 观察到 pgscand 数值很大，那大概率是因为「直接内存回收」导致的。针对这个问题，解决的办法就是，可以通过尽早的触发「后台内存回收」来避免应用程序进行直接内存回收。</p>
<p>kswapd 会定期扫描内存的使用情况，根据剩余内存（pages_free）的情况来进行内存回收的工作。如果剩余内存（pages_free）在页低阈值（pages_low）和页最小阈值（pages_min）之间，说明内存压力比较大，剩余内存不多了。<strong>这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值（pages_high）为止</strong>。虽然会触发内存回收，但是不会阻塞应用程序，因为两者关系是异步的。</p>
</li>
<li><p><strong>设置  &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;zone_reclaim_mode，调整 NUMA 架构下内存回收策略，建议设置为  0，这样在回收本地内存之前，会在其他 Node 寻找空闲内存，从而避免在系统还有很多空闲内存的情况下，因本地 Node  的本地内存不足，发生频繁直接内存回收导致性能下降的问题。</strong></p>
</li>
</ol>
<h3 id="68、在-4GB-物理内存的机器上，申请-8GB-内存，会怎么样？"><a href="#68、在-4GB-物理内存的机器上，申请-8GB-内存，会怎么样？" class="headerlink" title="68、在 4GB 物理内存的机器上，申请 8GB 内存，会怎么样？"></a>68、在 4GB 物理内存的机器上，申请 8GB 内存，会怎么样？</h3><ul>
<li>在 32 位操作系统，因为进程理论上最大能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。</li>
<li>在 64位 位操作系统，因为进程理论上最大能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：<ul>
<li>如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；</li>
<li>如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；</li>
</ul>
</li>
</ul>
<h3 id="69、函数进栈退栈原理，esp、ebp、实参怎么传递？怎么退栈之类的过程？"><a href="#69、函数进栈退栈原理，esp、ebp、实参怎么传递？怎么退栈之类的过程？" class="headerlink" title="69、函数进栈退栈原理，esp、ebp、实参怎么传递？怎么退栈之类的过程？"></a>69、函数进栈退栈原理，esp、ebp、实参怎么传递？怎么退栈之类的过程？</h3><p>在一个函数中，调用另外一个函数，往往有以下几个步骤：</p>
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>指令归属函数</th>
<th>SP 变化</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>push arg2</td>
<td>主函数</td>
<td>sp-4</td>
<td></td>
</tr>
<tr>
<td>push arg1</td>
<td>主函数</td>
<td>sp-4</td>
<td></td>
</tr>
<tr>
<td>call function</td>
<td>主函数</td>
<td>sp-4</td>
<td>开始调用子程序，同时保存返回地址</td>
</tr>
<tr>
<td>push ebp</td>
<td>子函数</td>
<td>sp-4</td>
<td></td>
</tr>
<tr>
<td>push ebp, esp</td>
<td>子函数</td>
<td>sp-4</td>
<td>将当前 sp 存入 bp，目的是定位函数参数</td>
</tr>
<tr>
<td>sub sp, #num</td>
<td>子函数</td>
<td>sp-num</td>
<td>为子程序分配栈空间</td>
</tr>
<tr>
<td>…</td>
<td>子函数</td>
<td>…</td>
<td>函数的具体实现逻辑</td>
</tr>
<tr>
<td>pop ebp</td>
<td>子函数</td>
<td>sp+4</td>
<td></td>
</tr>
<tr>
<td>ret</td>
<td>子函数</td>
<td>sp+4</td>
<td></td>
</tr>
</tbody></table>
<p>说明：</p>
<ul>
<li><code>push arg</code> 在调用一个函数之前，通过 push 把传递的参数压栈。每次 push 之后，栈多了一个字长（32 位系统 –&gt; 4 字节），因此栈顶需要往上移动 4 字节，该指令暗含 sub sp, #4</li>
<li><code>call</code> call 指令用来调用某个函数，该指令有两个操作（1）将返回地址压入栈；（2）同时 sp &#x3D; sp - 4</li>
<li><code>push ebp</code> <code>push ebp, esp</code> 用于保存上一个函数栈的基址，并更新本函数的基址</li>
<li><code>ret</code>，即 return，此时 sp 指向 call 指令刚刚压入的返回地址；执行 ret 其实就是（1）将此时栈中的数据弹出，存至 eip 寄存器，eip 存放的是下一条即将执行的指令的地址；（2）同时 sp &#x3D; sp + 4</li>
<li><code>ret</code> 指令相当于 <code>pop eip; esp = esp + 4</code></li>
<li><code>call</code> 指令相当于 <code>push eip; esp = esp - 4</code></li>
</ul>
<blockquote>
<p>主函数调用子函数</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301556491.png" alt="在这里插入图片描述"></p>
<p>子函数返回主函数</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301556054.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="70、分段为什么会产生内存碎片的问题？"><a href="#70、分段为什么会产生内存碎片的问题？" class="headerlink" title="70、分段为什么会产生内存碎片的问题？"></a>70、分段为什么会产生内存碎片的问题？</h3><ol>
<li>当程序动态分配内存时，如果请求的内存大小比当前空闲块大，但分配的内存不是连续的，就会在已有的空闲块中留下未被利用的空间。</li>
<li>当程序释放内存时，如果释放的内存顺序不是按照申请的顺序释放，会导致内存空闲块的分布变得不连续。这样在后续再次分配内存时，可能无法利用之前释放的碎片空间，从而导致更多的碎片产生。</li>
<li>某些内存分配算法（如首次适应、最佳适应）会根据当前的空闲内存块选择最合适的块分配给请求的内存大小。如果空闲块的分布不合理或者已分配的内存块大小和释放的大小不匹配，就容易产生碎片。</li>
</ol>
<h3 id="71、分段为什么会导致内存交换效率低的问题？"><a href="#71、分段为什么会导致内存交换效率低的问题？" class="headerlink" title="71、分段为什么会导致内存交换效率低的问题？"></a>71、分段为什么会导致内存交换效率低的问题？</h3><p>对于多进程的系统来说，用分段的方式，外部内存碎片是很容易产生的，产生了外部内存碎片时就不得不重新 <code>Swap</code> 内存区域，这个过程会产生性能瓶颈。</p>
<p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong>为了解决内存分段的「外部内存碎片和内存交换效率低」的问题，就出现了内存分页（<code>Paging</code>）。</p>
<h3 id="72、Swap-分区"><a href="#72、Swap-分区" class="headerlink" title="72、Swap 分区"></a>72、Swap 分区</h3><p>Swap 就是把一块磁盘空间或者本地文件，当成内存来使用，它包含换出和换入两个过程：</p>
<ul>
<li><strong>换出（Swap Out）</strong> ，是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存；</li>
<li><strong>换入（Swap In）</strong>，是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来。</li>
</ul>
<p>Linux 中的 Swap 机制会在内存不足和内存闲置的场景下触发：</p>
<ul>
<li><strong>内存不足</strong>：当系统需要的内存超过了可用的物理内存时，内核会将内存中不常使用的内存页交换到磁盘上为当前进程让出内存，保证正在执行的进程的可用性，这个内存回收的过程是强制的直接内存回收（Direct Page Reclaim）。直接内存回收是同步的过程，会阻塞当前申请内存的进程。</li>
<li><strong>内存闲置</strong>：应用程序在启动阶段使用的大量内存在启动后往往都不会使用，通过后台运行的守护进程（kSwapd），我们可以将这部分只使用一次的内存交换到磁盘上为其他内存的申请预留空间。kSwapd 是 Linux 负责页面置换（Page replacement）的守护进程，它也是负责交换闲置内存的主要进程，它会在空闲内存低于一定水位时，回收内存页中的空闲内存保证系统中的其他进程可以尽快获得申请的内存。kSwapd 是后台进程，所以回收内存的过程是异步的，不会阻塞当前申请内存的进程。</li>
</ul>
<h3 id="73、分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？"><a href="#73、分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？" class="headerlink" title="73、分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？"></a>73、分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？</h3><p>内存分页由于内存空间都是预先划分好的，也就不会像内存分段一样，在段与段之间会产生间隙非常小的内存，这正是分段会产生外部内存碎片的原因。而<strong>采用了分页，页与页之间是紧密排列的，所以不会有外部碎片。</strong></p>
<p>但是，因为内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以针对<strong>内存分页机制会有内部内存碎片</strong>的现象。</p>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<strong>内存交换的效率就相对比较高。</strong></p>
<p>更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是<strong>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</strong></p>
<h3 id="74、页表是什么，页多大，为什么是-4KB？"><a href="#74、页表是什么，页多大，为什么是-4KB？" class="headerlink" title="74、页表是什么，页多大，为什么是 4KB？"></a>74、页表是什么，页多大，为什么是 4KB？</h3><p>页表是操作系统中用于实现虚拟内存管理的一种数据结构，它用于将虚拟地址映射到物理地址。这种机制允许计算机的操作系统为每个运行的程序提供一种看似连续的内存地址空间，即使物理内存是分散存储的。</p>
<p>每个页表条目存储着虚拟页面到物理页面的映射信息，通常包括物理页帧的基地址和一些状态位（如访问权限、是否已加载到物理内存中等）。由于地址空间的扩大，单级页表的大小会非常庞大，因此现代操作系统通常使用多级页表结构来减少内存占用，如x86架构常用的二级或三级页表。</p>
<p>在多数现代操作系统中，标准的页面大小是4KB（4096字节）。linux 会以页面为单位对内存进行管理。不论是将磁盘中的数据加载到内存中，还是将内存中的数据写回磁盘中，操作系统都会以页面为单位进行操作，这也意味着如果我们只向磁盘中写入一个字节的数据，操作系统也需要将整个页面中的全部数据刷入磁盘中。过小的页面大小会带来较大的页表项增加寻址时 TLB（Translation lookaside buffer）的查找速度和额外开销；过大的页面大小会浪费内存空间，造成内存碎片，降低内存的利用率；上个世纪在设计内存页大小时充分考虑了上述的两个因素，最终选择了 4KB 的内存页作为操作系统最常见的页大小，这个大小也就沿用至今。</p>
<h3 id="75、分页机制下，虚拟地址和物理地址是如何映射的？"><a href="#75、分页机制下，虚拟地址和物理地址是如何映射的？" class="headerlink" title="75、分页机制下，虚拟地址和物理地址是如何映射的？"></a>75、分页机制下，虚拟地址和物理地址是如何映射的？</h3><p>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，页表是存储在内存里的，<strong>内存管理单元</strong> （MMU）就做将虚拟内存地址转换成物理地址的工作。而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>
<p>在分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址。</p>
<p>对于一个内存地址转换，其实就是这样三个步骤：</p>
<ul>
<li>把虚拟内存地址，切分成页号和偏移量；</li>
<li>根据页号，从页表里面，查询对应的物理页号；</li>
<li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li>
</ul>
<blockquote>
<p>64 位虚拟地址的格式为：全局页目录项（9位）+ 上层页目录项（9位）+ 中间页目录项（9位）+ 页表项（9位）+ 页内偏移（12位）。共 48 位组成的虚拟内存地址。</p>
<p>32 位虚拟地址的格式为：页目录项（10位）+ 页表项（10位） + 页内偏移（12位）。共 32 位组成的虚拟内存地址。</p>
</blockquote>
<h3 id="76、为什么会产生多级页表？"><a href="#76、为什么会产生多级页表？" class="headerlink" title="76、为什么会产生多级页表？"></a>76、为什么会产生多级页表？</h3><p>对于单页表的实现方式，在 32 位和页大小 <code>4KB</code> 的环境下，一个进程的页表需要装下 100 多万个「页表项」，并且每个页表项是占用 4 字节大小的，于是相当于每个页表需占用 4MB 大小的空间。</p>
<p>我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 <code>1024</code> 个页表（二级页表），每个表（二级页表）中包含 <code>1024</code> 个「页表项」，形成<strong>二级分页</strong>。</p>
<p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。</p>
<p>利用这一特性，可以把最常访问的几个页表项存储到访问速度更快的硬件，于是在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（Translation Lookaside Buffer） ，通常称为页表缓存、转址旁路缓存、快表等。</p>
<h3 id="77、缺页中断什么时候发生？"><a href="#77、缺页中断什么时候发生？" class="headerlink" title="77、缺页中断什么时候发生？"></a>77、缺页中断什么时候发生？</h3><p>（1）当程序要访问的页面不在物理内存中时，会触发缺页中断。这通常发生在虚拟内存中，即当前只有部分的页面写入了物理内存。</p>
<p>（2）当程序尝试进行一个违反内存规则的操作时，也会触发缺页中断。比如，当程序试图对一个只读页面进行写操作，或是访问一个不允许被访问的页面。</p>
<h3 id="78、常见的缺页中断算法-页面置换算法有哪些？"><a href="#78、常见的缺页中断算法-页面置换算法有哪些？" class="headerlink" title="78、常见的缺页中断算法&#x2F;页面置换算法有哪些？"></a>78、常见的缺页中断算法&#x2F;页面置换算法有哪些？</h3><ul>
<li><p>最佳页面置换算法（<em>OPT</em>）</p>
<p>最佳页面置换算法基本思路是，<strong>置换在「未来」最长时间不访问的页面</strong>。</p>
</li>
<li><p>先进先出置换算法（<em>FIFO</em>）</p>
<p><strong>选择在内存驻留时间很长的页面进行中置换</strong>，这个就是「先进先出置换」算法的思想。</p>
</li>
<li><p>最近最久未使用的置换算法（<em>LRU</em>）</p>
<p>发生缺页时，<strong>选择最长时间没有被访问的页面进行置换</strong>，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。</p>
</li>
<li><p>时钟页面置换算法（<em>Lock</em>）</p>
<p>该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。</p>
<p>当发生缺页中断时，算法首先检查表针指向的页面：</p>
<ul>
<li>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li>
<li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止。</li>
</ul>
</li>
<li><p>最不常用置换算法（<em>LFU</em>）</p>
<p><strong>当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰</strong>。</p>
</li>
</ul>
<h3 id="79、写时拷贝在操作系统中有哪些应用？"><a href="#79、写时拷贝在操作系统中有哪些应用？" class="headerlink" title="79、写时拷贝在操作系统中有哪些应用？"></a>79、写时拷贝在操作系统中有哪些应用？</h3><ol>
<li><strong>内存管理</strong>：<ul>
<li><strong>分页系统</strong>：在许多操作系统中，写时拷贝技术常用于内存管理。当进程执行 fork 操作创建子进程时，操作系统并不立即为子进程复制父进程的整个地址空间。相反，它让父子进程共享同一物理内存页面，只有当其中一个进程尝试修改这些共享页面时，操作系统才会复制这些页面（COW），从而实现了资源的有效利用和快速的进程创建。</li>
<li><strong>虚拟内存系统</strong>：在虚拟内存系统中，写时拷贝技术可以减少不必要的数据复制，提高内存使用效率，只有在需要写入时才进行物理内存的分配和数据复制。</li>
</ul>
</li>
<li><strong>文件系统</strong>：<ul>
<li><strong>快照功能</strong>：在支持快照的文件系统（如 ZFS 或 Btrfs ）中，写时拷贝用于实现文件系统的版本控制。当文件系统状态需要保存为历史快照时，原始数据保持不变，任何对数据的修改都通过复制修改前的数据块来实现，从而快速创建快照并节省空间。</li>
</ul>
</li>
</ol>
<h2 id="三、编译程序相关"><a href="#三、编译程序相关" class="headerlink" title="三、编译程序相关"></a>三、编译程序相关</h2><h3 id="80、从-C-文件到可执行文件经过了哪几个阶段？具体描述。"><a href="#80、从-C-文件到可执行文件经过了哪几个阶段？具体描述。" class="headerlink" title="80、从 C++ 文件到可执行文件经过了哪几个阶段？具体描述。"></a>80、从 C++ 文件到可执行文件经过了哪几个阶段？具体描述。</h3><blockquote>
<p>预处理、编译、汇编、链接，最后生成可执行文件。</p>
</blockquote>
<ol>
<li><p><strong>预处理阶段</strong>：对伪指令和特殊符号进行处理，将<code>.c</code>文件转为<code>.i</code>文件；</p>
<ol>
<li>处理包含指令 <code>#include</code></li>
<li>进行宏展开；</li>
<li>进行条件编译，如 <code>#if</code>、<code>#endif</code>、<code>#ifdef</code> 等；</li>
<li>处理 <code>#include</code> 预编译指令；</li>
<li>删除所有的注释 <code>//</code> 和 <code>/**/</code>；</li>
<li>保留所有的 <code>#pragma</code> 编译器指令，编译器需要使用它们；</li>
<li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息。</li>
</ol>
</li>
<li><p><strong>编译阶段</strong>：将编译文件转换成汇编代码，生成相应的汇编代码<code>.s</code>文件；</p>
</li>
<li><p><strong>汇编阶段</strong>：将汇编文件转化成机器码，将 <code>.s</code> 文件转为 <code>.o</code> 文件，即可重定位目标文件</p>
</li>
<li><p><strong>链接阶段</strong>：将多个目标文件及所需要的库连接成最终的可执行目标文件。链接分为<strong>静态链接</strong>和<strong>动态链接</strong>，静态链接和动态链接的最大区别就是链接的时机不一样，静态链接是在形成可执行文件之前，动态链接是在程序执行时。</p>
<ol>
<li><strong>主要工作</strong>：<ul>
<li>符号解析。在目标文件和库中存在许多符号（如函数名或变量名等），需要在其他的目标文件或库中找到相应的定义，并将它们连接起来，使得程序在运行时可以找到正确的内存地址。</li>
<li>地址分配。给目标文件和库分配内存地址，并确定其在程序中的内存布局。同时需要完成重定位的工作，用实际的内存地址去替换其中的地址引用。</li>
<li>库依赖管理。链接器处理程序和库之间的依赖关系，确保所有库都被正确地包含在目标文件中。同时要处理库与库之间的依赖关系。</li>
</ul>
</li>
<li><strong>静态链接</strong><ul>
<li>源文件中的函数和数据预处理、编译、汇编形成目标文件，而静态链接库就是多个目标文件的集合。使用静态链接库时，链接器直接从库中复制这些函数和数据，并将它们和应用程序的其他模块组合起来，创建最终的可执行文件；链接是以目标文件为单位的，若多个函数都放在了一个目标文件中，可能很多没有的函数也会被一起链接进入了输出结果中。</li>
<li>缺点：<ul>
<li>每一个可执行文件中对所有需要的目标文件都需要一份副本，如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本</li>
<li>更新困难，每当库函数的代码发生改动，需要重新进行编译、连接形成可执行程序</li>
</ul>
</li>
<li>优点：可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度更快</li>
</ul>
</li>
<li><strong>动态链接</strong><ul>
<li>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接那样运行前就把所有程序模块都链接成一个单独的可执行文件。</li>
<li>动态链接的过程：假定程序 p1.o 和 p2.o 都依赖于库 lib.o，并且假定先运行 p1.o，系统首先会加载 p1.o，发现p1.o 用到了 lib.o，于是将 lib.o 加载到内存；当运行 p2.o 时，发现 p2.o 依赖于 lib.o，而此时 lib.o 已经加载到内存中了，因此不需要重新加载，此时会将已经存在的 lib.o 映射到 p2.o 的虚拟地址空间中，从而进行链接，形成可执行文件。</li>
<li>优点：<ul>
<li>即使多个程序依赖于同一个库，在执行时也共享同一份副本；</li>
<li>更新时只需要替换原来的目标文件，而无需将所有程序都重新链接一遍，当程序下次运行时，新版本的目标文件会自动被加载到内存中并连接起来，完成了程序的更新。</li>
</ul>
</li>
<li>缺点：由于链接过程从编译阶段推迟到了程序运行时，所以运行速度相对于静态链接更慢。</li>
<li><strong>动态链接如何实现重定位的：</strong>在形成可执行文件时，发现引用了一个外部的函数，此时会检查动态链接库，发现函数名时一个动态链接符号，此时在可执行程序就不对这个符号进行重定位，就把这个过程留到装载时在进行</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="81、在-terminal-输入-main-out-是怎么运行起来的？"><a href="#81、在-terminal-输入-main-out-是怎么运行起来的？" class="headerlink" title="81、在 terminal 输入 .&#x2F;main.out 是怎么运行起来的？"></a>81、在 terminal 输入 .&#x2F;main.out 是怎么运行起来的？</h3><p>在终端输入 <code>./main.out</code> 实际上是在运行名为 <code>main.out</code> 的可执行文件。这个过程涉及了操作系统的执行文件路径解析和进程创建：</p>
<ol>
<li><strong>路径解析</strong>: 终端会根据当前工作目录（或者通过绝对路径指定的位置）找到 <code>main.out</code> 可执行文件的位置。</li>
<li><strong>权限检查</strong>: 操作系统会检查当前用户是否有权限执行这个文件。如果没有权限，会提示权限不足的错误。</li>
<li><strong>进程创建</strong>: 如果权限允许，操作系统会为 <code>main.out</code> 创建一个新的进程，并加载到内存中执行。这个过程包括但不限于：<ul>
<li>将程序代码和静态数据加载到内存。</li>
<li>为程序分配堆空间和栈空间。</li>
<li>设置程序的初始状态，如传递命令行参数、环境变量等。</li>
<li>开始执行程序的 <code>main</code> 函数或者入口函数。</li>
</ul>
</li>
<li><strong>程序执行</strong>: <code>main.out</code> 开始执行，根据程序中的逻辑进行各种操作，直至程序结束或者被终止。</li>
<li><strong>退出</strong>: 程序执行完毕后，操作系统会回收分配给该程序的资源，并返回到终端或者调用者。</li>
</ol>
<h3 id="82、为什么需要有链接的过程？"><a href="#82、为什么需要有链接的过程？" class="headerlink" title="82、为什么需要有链接的过程？"></a>82、为什么需要有链接的过程？</h3><p>因为软件开发的规模很大，不可能将它们都放在同一个模块中。因此按照层次化以及模块化的视线方法，将代码分成多个部分，每个部分分别开发。因此就需要在最后将它们组装起来，这就是链接的过程。通过链接，实现符号解析、地址分配和库依赖管理等工作。</p>
<h3 id="83、假设有一个-A-dll-和-B-dll，A-dll-调用了-B-dll-的方法，A-dll-是如何找到-B-dll-中的方法的？"><a href="#83、假设有一个-A-dll-和-B-dll，A-dll-调用了-B-dll-的方法，A-dll-是如何找到-B-dll-中的方法的？" class="headerlink" title="83、假设有一个 A.dll 和 B.dll，A.dll 调用了 B.dll 的方法，A.dll 是如何找到 B.dll 中的方法的？"></a>83、假设有一个 A.dll 和 B.dll，A.dll 调用了 B.dll 的方法，A.dll 是如何找到 B.dll 中的方法的？</h3><p>在使用动态库时，链接器会将动态库的相关信息，包括动态库的名字、符号表以及可重定位信息存储到相应的可执行文件中。在可执行文件运行时，链接器会根据这些信息找到动态库是否存在、在哪里、符号引用的内存地址是哪里，也就是说找到 A.dll 引用的 B.dll 的相关方法，并通过重定位找到其物理内存地址。</p>
<h3 id="84、假设有一个-A-cpp-和-B-cpp，A-cpp-调用了-B-cpp-的方法，A-cpp-是如何找到-B-cpp-中的方法的？"><a href="#84、假设有一个-A-cpp-和-B-cpp，A-cpp-调用了-B-cpp-的方法，A-cpp-是如何找到-B-cpp-中的方法的？" class="headerlink" title="84、假设有一个 A.cpp 和 B.cpp，A.cpp 调用了 B.cpp 的方法，A.cpp 是如何找到 B.cpp 中的方法的？"></a>84、假设有一个 A.cpp 和 B.cpp，A.cpp 调用了 B.cpp 的方法，A.cpp 是如何找到 B.cpp 中的方法的？</h3><p>在汇编后，A.cpp 生成了 A.o 文件，B.cpp 生成了 B.o 的文件，A.o 和 B.o 文件都有着自己的符号表。在链接的过程，链接器会根据两者的符号表来做符号决议，判断是否能够找到引用的外部的符号，如果找到外部唯一的符号，就会进行重定位操作，来修正这一符号的地址，从而完成调用。</p>
<h3 id="85、函数调用中堆和栈的变化情况是怎样的？"><a href="#85、函数调用中堆和栈的变化情况是怎样的？" class="headerlink" title="85、函数调用中堆和栈的变化情况是怎样的？"></a>85、函数调用中堆和栈的变化情况是怎样的？</h3><p>函数调用时主要影响的是<strong>栈（stack）</strong>的变化，而不直接影响<strong>堆（heap）</strong>的变化。</p>
<ul>
<li><strong>函数进栈</strong>：<ul>
<li>调用函数时，会先将函数的参数压入栈中，参数的顺序通常是从右向左依次压入。</li>
<li>接着将当前函数的返回地址压入栈中，这个返回地址指向了调用该函数的下一条指令，用于函数执行结束后返回到调用处继续执行。</li>
<li>如果函数中有局部变量，则会在栈上为这些变量分配空间，并进行初始化。</li>
<li>最后，将当前栈指针（ESP）的值赋给基址指针（EBP），建立当前函数的栈帧。</li>
</ul>
</li>
<li><strong>函数退栈</strong>：<ul>
<li>当函数执行结束时，首先会将局部变量的值从栈中弹出，释放局部变量所占用的空间。</li>
<li>接着会将基址指针（EBP）的值赋给栈指针（ESP），恢复到函数调用之前的栈状态。</li>
</ul>
</li>
</ul>
<p>在这个过程中，函数的参数传递通常是通过栈来完成的。对于一般的函数调用，在调用函数前，调用者会将参数压入栈中；而在函数内部，被调用函数通过栈指针（ESP）来访问这些参数。在 x86 架构中，通常采用栈来传递函数参数，参数从右向左依次入栈。</p>
<h3 id="86、代码崩溃怎么解决，常见的原因是什么？"><a href="#86、代码崩溃怎么解决，常见的原因是什么？" class="headerlink" title="86、代码崩溃怎么解决，常见的原因是什么？"></a>86、代码崩溃怎么解决，常见的原因是什么？</h3><p><strong>（1）常见的崩溃原因</strong></p>
<ol>
<li><strong>访问非法内存</strong>，如已释放的内存（悬挂指针）、未初始化的指针或越界访问数组或字符串</li>
<li><strong>资源管理错误</strong>，如内存泄露，或文件或网络句柄未正确关闭</li>
<li><strong>并发错误</strong>：1）竞态条件：多个线程或进程争用数据，未正确同步；2）死锁：多个线程或进程相互等待对方持有的资源</li>
<li><strong>栈溢出</strong>：递归调用过深，或大量局部变量分配</li>
<li><strong>除零错误</strong>：整数或浮点数除以零</li>
</ol>
<p><strong>（2）解决方法</strong></p>
<ol>
<li><strong>调试工具</strong>：使用调试器（如 GDB）检查崩溃时的栈跟踪（stack trace）</li>
<li><strong>代码审查</strong></li>
<li><strong>增加日志记录</strong>：在关键操作前后添加日志记录，以追踪崩溃前的程序状态和行为；使用断言检查程序运行时的预期状态</li>
<li><strong>单元测试</strong>：编写和维护单元测试</li>
<li><strong>优化设计</strong>，避免过深的递归调用，考虑使用循环或其他算法策略；为并发操作设计合理的锁策略和线程同步机制</li>
</ol>
<h3 id="87、什么时候会发生段错误？"><a href="#87、什么时候会发生段错误？" class="headerlink" title="87、什么时候会发生段错误？"></a>87、<strong>什么时候会发生段错误？</strong></h3><p>段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况： </p>
<p>（1）使用野指针</p>
<p>（2）试图修改字符串常量的内容</p>
<h3 id="88、程序崩溃产生-core-dump一般怎么处理？"><a href="#88、程序崩溃产生-core-dump一般怎么处理？" class="headerlink" title="88、程序崩溃产生 core dump一般怎么处理？"></a>88、程序崩溃产生 core dump一般怎么处理？</h3><p>core dump 是程序由于异常在运行时异常退出或者终止，在一定的条件下生成的一个叫做 core 的文件，这个 core 文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对其进行分析可以定位到程序异常发生时对应的堆栈调用信息。</p>
<p>一般采用使用 gdb 命令对 core 文件进行调试。</p>
<h3 id="89、当程序运行时，如何将其加载到进程地址空间？"><a href="#89、当程序运行时，如何将其加载到进程地址空间？" class="headerlink" title="89、当程序运行时，如何将其加载到进程地址空间？"></a>89、当程序运行时，如何将其加载到进程地址空间？</h3><p>首先 cpu 找到程序的入口地址，入口地址在 exe 中代码段中保存，接着操作系统将进程的虚拟地址转换成物理地址，然后在内存中运行。运行完后执行代码段的下一条代码，执行过程类似，直至程序结束。</p>
<h3 id="90、-执行一个系统调用时，OS-发生的过程，越详细越好"><a href="#90、-执行一个系统调用时，OS-发生的过程，越详细越好" class="headerlink" title="90、**执行一个系统调用时，OS **发生的过程，越详细越好"></a>90、**执行一个系统调用时，OS **发生的过程，越详细越好</h3><ol>
<li><p>执行用户程序(如: fork)</p>
</li>
<li><p>根据 glibc 中的函数实现，取得系统调用号并执行<code>int $0x80</code>产生中断。</p>
</li>
<li><p>进行地址空间的转换和堆栈的切换，执行 SAVE_ALL。（进行内核模式）</p>
</li>
<li><p>进行中断处理，根据系统调用表调用内核函数。</p>
</li>
<li><p>执行内核函数。</p>
</li>
<li><p>执行 RESTORE_ALL 并返回用户模式</p>
</li>
</ol>
<h3 id="91、动态链接和静态链接的区别？"><a href="#91、动态链接和静态链接的区别？" class="headerlink" title="91、动态链接和静态链接的区别？"></a>91、动态链接和静态链接的区别？</h3><p>（1）静态链接</p>
<p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库 中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p>
<p>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个 目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p>
<p>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
<p>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西， 在执行的时候运行速度快。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301606610.png" alt="image-20240630160655511"></p>
<p>（2）动态链接</p>
<p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形 成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副 本，而是这多个程序在执行时共享同一份副本；</p>
<p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运 行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
<p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损 失。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301607955.png" alt="image-20240630160706843"></p>
<h2 id="四、Linux相关"><a href="#四、Linux相关" class="headerlink" title="四、Linux相关"></a>四、Linux相关</h2><h3 id="92、Linux-常用命令"><a href="#92、Linux-常用命令" class="headerlink" title="92、Linux 常用命令"></a>92、Linux 常用命令</h3><ol>
<li><p>切换目录：<code>cd</code></p>
</li>
<li><p>查看端口绑定情况：<code>lsof -i : [端口号]</code>或<code>netstat -tuln</code>（列出所有监听端口）</p>
</li>
<li><p>查看CPU利用率：<code>top</code>或<code>htop</code></p>
</li>
<li><p>查看进程状态：<code>ps</code>，其中进程的状态码如下：</p>
</li>
</ol>
<ul>
<li>**R (Running)**：进程正在运行或在运行队列中等待</li>
<li>**S (Sleeping)**：进程处于睡眠状态，等待某个事件或资源。</li>
<li>**D (Uninterruptible Sleep)**：进程处于不可中断的睡眠状态，通常是在等待I&#x2F;O操作</li>
<li>**T (Stopped)**：进程已停止运行，通常是因为它正在被调试或已经收到停止信号</li>
<li>**Z (Zombie)**：进程已完成执行，但仍在进程表中等待父进程读取其退出状态</li>
<li>**I (Idle)**：这是一个空闲的内核线程，这个状态在某些版本的ps输出中可能不会显示</li>
</ul>
<ol start="5">
<li>查询网络状态：<code>ifconfig</code>、<code>netstat -r # 显示路由表</code></li>
<li>查看磁盘：<code>df -h</code>、<code>lsblk</code></li>
<li>查看是哪个进程的内存占用最大：<code>top</code>+<code>M</code>键、<code>ps aux --sort=-%mem | head -10</code></li>
<li>查找文件：<code>find</code>、<code>locate</code></li>
<li>查找文件内容：<code>grep -r &quot;hello&quot; /path/to/directory</code></li>
<li>查找系统命令的位置：<code>which ls</code></li>
</ol>
<h3 id="93、0、1、2-的文件描述符是什么含义？指向什么类型的文件？"><a href="#93、0、1、2-的文件描述符是什么含义？指向什么类型的文件？" class="headerlink" title="93、0、1、2 的文件描述符是什么含义？指向什么类型的文件？"></a>93、0、1、2 的文件描述符是什么含义？指向什么类型的文件？</h3><ol>
<li>文件描述符0（标准输入）：指向标准输入设备，通常是终端（键盘）。</li>
<li>文件描述符1（标准输出）：指向标准输出设备，通常是终端（屏幕）。</li>
<li>文件描述符2（标准错误）：指向标准错误设备，通常也是终端（屏幕）。</li>
</ol>
<h3 id="94、Linux-系统中的中断为什么分为上下两个部分？"><a href="#94、Linux-系统中的中断为什么分为上下两个部分？" class="headerlink" title="94、Linux 系统中的中断为什么分为上下两个部分？"></a>94、Linux 系统中的中断为什么分为上下两个部分？</h3><p>在 Linux 系统中，中断处理通常被分为上半部（Top Half）和下半部（Bottom Half）：</p>
<ol>
<li><strong>上半部</strong>：<ul>
<li>上半部是中断处理的第一阶段，它在 CPU 接收到中断信号后立即执行。</li>
<li>在这一阶段中，中断和调度器通常被禁用，以避免在处理中断时发生新的中断，从而保证处理的原子性。</li>
<li>上半部的代码通常包含处理中断的关键代码，这部分代码的执行时间应尽可能短，以快速释放CPU资源，处理更多的中断或其他任务。</li>
</ul>
</li>
<li><strong>下半部</strong>：<ul>
<li>下半部处理的是中断处理的后续部分，通常在上半部完成后，通过添加工作项到工作队列中来延后执行。</li>
<li>在下半部执行时，中断通常是被允许的，这样可以在处理较长时间的任务时不阻塞其他中断的处理。</li>
<li>下半部负责完成数据处理、复制等操作，这些操作不需要立即完成，可以稍后处理。</li>
</ul>
</li>
</ol>
<p>这种分割方法的主要优点是能够快速响应中断，同时又不会因为长时间的数据处理而阻塞 CPU，影响系统的整体性能。通过这种方式，Linux 系统能够在保证响应速度的同时，也能有效地处理大量的数据。</p>
<h3 id="95、Linux-用户态如何进入内核态？"><a href="#95、Linux-用户态如何进入内核态？" class="headerlink" title="95、Linux 用户态如何进入内核态？"></a>95、Linux 用户态如何进入内核态？</h3><ol>
<li><strong>系统调用（System Call）</strong>:<ul>
<li>系统调用是最常见的从用户态切换到内核态的方式。</li>
<li>程序在需要执行诸如文件操作、网络通信、进程控制等操作时，会通过系统调用请求操作系统提供服务。</li>
<li>Linux 提供了大量的系统调用，例如<code>read()</code>, <code>write()</code>, <code>open()</code>, <code>fork()</code>等。</li>
<li>系统调用通过软件中断（通常是中断指令<code>int 0x80</code>或<code>syscall</code>指令）来实现，这导致处理器从用户态切换到内核态，并跳转到预定义的内核入口点执行相应的内核代码。</li>
</ul>
</li>
<li><strong>异常（Exception）</strong>:<ul>
<li>当程序执行出现错误时（如除零、访问非法内存等），会触发异常。</li>
<li>处理器会自动从用户态切换到内核态，并调用相应的异常处理程序。</li>
<li>异常处理程序在内核中定义，负责处理这些错误并决定如何恢复程序执行或终止出错的程序。</li>
</ul>
</li>
<li><strong>中断（Interrupt）</strong>:<ul>
<li>当外部设备（如键盘、鼠标、网络接口等）需要处理时，它们会向处理器发送中断信号。</li>
<li>中断信号会导致当前正在执行的用户态程序被挂起，处理器切换到内核态处理这些外部事件。</li>
<li>中断处理程序在内核中定义，用于响应和处理这些外部事件。</li>
</ul>
</li>
</ol>
<h3 id="96、如何用-gbd-调试发现线程阻塞？"><a href="#96、如何用-gbd-调试发现线程阻塞？" class="headerlink" title="96、如何用 gbd 调试发现线程阻塞？"></a>96、如何用 gbd 调试发现线程阻塞？</h3><ol>
<li><strong>启动GDB并附加到进程</strong></li>
</ol>
<p>从 GDB 启动程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb ./your_program</span><br><span class="line">run [arguments]</span><br></pre></td></tr></table></figure>

<p>附加到已经运行的程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb -p [pid]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>列出所有线程</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">info threads</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>切换线程</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">thread [thread-id]</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>检查线程的栈帧</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">backtrace</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>检查锁的状态。如果怀疑是死锁或资源竞争引起的阻塞，你可以检查锁的状态。这通常需要一些对应用程序逻辑的理解，以及可能需要查看源码来确定哪些锁可能涉及阻塞。</strong></li>
</ol>
<h3 id="97、gdb-查看所有线程线程栈的命令是什么？"><a href="#97、gdb-查看所有线程线程栈的命令是什么？" class="headerlink" title="97、gdb 查看所有线程线程栈的命令是什么？"></a>97、gdb 查看所有线程线程栈的命令是什么？</h3><ol>
<li>查看所有线程： <code>info threads</code></li>
<li>查看所有线程的栈信息： <code>thread apply all bt</code></li>
</ol>
<h3 id="98、gdb-查看内存地址的命令是什么？"><a href="#98、gdb-查看内存地址的命令是什么？" class="headerlink" title="98、gdb 查看内存地址的命令是什么？"></a>98、gdb 查看内存地址的命令是什么？</h3><p><code>x/NFU address</code></p>
<ul>
<li><code>N</code> 表示要检查的单元格的数量。</li>
<li><code>F</code> 表示显示格式，例如 <code>x</code>（十六进制）、<code>d</code>（十进制）、<code>u</code>（无符号十进制）、<code>t</code>（二进制）、<code>a</code>（地址）、<code>i</code>（机器指令）、<code>c</code>（字符）等。</li>
<li><code>U</code> 表示单位大小，例如 <code>b</code>（字节）、<code>h</code>（半字，2字节）、<code>w</code>（字，4字节）、<code>g</code>（双字，8字节）。</li>
</ul>
<h2 id="处理器相关"><a href="#处理器相关" class="headerlink" title="处理器相关"></a>处理器相关</h2><h3 id="99、浮点数在计算机中怎么存储？"><a href="#99、浮点数在计算机中怎么存储？" class="headerlink" title="99、浮点数在计算机中怎么存储？"></a>99、浮点数在计算机中怎么存储？</h3><p>浮点数在计算机中的存储通常采用IEEE 754标准，这是一种广泛使用的浮点数表示方法，具体如下：</p>
<ol>
<li><strong>符号位（Sign）</strong>：用一个位来表示数值的正负，0表示正数，1表示负数。</li>
<li><strong>指数位（Exponent）</strong>：用来表示数值的指数部分，以二进制补码表示。指数部分确定了浮点数的大小范围。</li>
<li><strong>尾数位（Fraction&#x2F;Mantissa）</strong>：也称为尾数或者系数，用来表示浮点数的小数部分。通常为带有隐含的整数1的小数分数。</li>
</ol>
<p>根据IEEE 754标准，浮点数可以分为单精度（32位）和双精度（64位）两种格式：</p>
<ul>
<li><strong>单精度浮点数（float）</strong>：由32位组成，其中1位符号位，8位指数位，23位尾数位。</li>
<li><strong>双精度浮点数（double）</strong>：由64位组成，其中1位符号位，11位指数位，52位尾数位。</li>
</ul>
<p>浮点数的存储过程如下：</p>
<ul>
<li><strong>规格化（Normalization）</strong>：尾数部分总是以某个基数（通常为2）的形式表示，例如1.xxxxxx形式。尾数的最高位总是1，且不存储在浮点数中，称为隐含位。</li>
<li><strong>指数偏移（Exponent Biasing）</strong>：指数部分采用偏移值来表示，这个偏移值是为了能够表示负数指数和正数指数，避免使用纯粹的补码表示。</li>
<li><strong>特殊值和溢出（Special Values and Overflow）</strong>：IEEE 754定义了一些特殊的浮点数值，如正无穷大、负无穷大、NaN（Not a Number）等，以及处理溢出情况。</li>
</ul>
<p>浮点数的存储和计算是通过这些位字段来实现的，具体的运算和精度受到硬件支持和IEEE 754标准的限制。</p>
<h3 id="100、怎么判断两个浮点数是否相等？"><a href="#100、怎么判断两个浮点数是否相等？" class="headerlink" title="100、怎么判断两个浮点数是否相等？"></a>100、怎么判断两个浮点数是否相等？</h3><p>相减，并与预先设定的精度进行比较。不能采用 <code>==</code> 来判断。</p>
<h3 id="101、什么是大小端？如何区分？有几种方法？网络通信一般是什么字节序？"><a href="#101、什么是大小端？如何区分？有几种方法？网络通信一般是什么字节序？" class="headerlink" title="101、什么是大小端？如何区分？有几种方法？网络通信一般是什么字节序？"></a>101、什么是大小端？如何区分？有几种方法？网络通信一般是什么字节序？</h3><ol>
<li><p>大端字节序是指高位字节存储在内存的低地址端，低位字节存储在内存的高地址端；小端字节序则与之相反。</p>
</li>
<li><p>区分的方法如下：</p>
<p>（1）通过检查整数的首个字节来确定字节序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">char</span> *c = (<span class="type">char</span>*)&amp;x;</span><br><span class="line">    <span class="keyword">if</span> (*c == <span class="number">0x78</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Little Endian\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big Endian\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）<code>htons()</code>和<code>ntohs()</code></p>
<ul>
<li><code>htons(host_port)</code>：将端口号从主机字节序转换为网络字节序</li>
<li><code>ntohs(net_port)</code>：将端口号从网络字节序转换回主机字节序</li>
</ul>
</li>
<li><p>网络通信一般是大端字节序，即无论发送和接收的系统是大端还是小端，数据在通过网络传输时都必须转换为网络字节序。</p>
</li>
</ol>
<h3 id="102、什么是-qps-和-tps-，如何计算？"><a href="#102、什么是-qps-和-tps-，如何计算？" class="headerlink" title="102、什么是 qps 和 tps ，如何计算？"></a>102、什么是 qps 和 tps ，如何计算？</h3><p>（1）<strong>QPS（Queries Per Second）</strong>：每秒查询率，是衡量每秒能处理多少个查询请求的指标。它通常用于评估搜索引擎、数据库服务器和 Web 服务器的性能。QPS 可以通过将总查询数除以时间（秒）来计算。</p>
<p>（2）<strong>TPS（Transactions Per Second）</strong>：每秒事务数，是衡量系统每秒能处理多少个事务的指标。一个事务是指一个完整的业务操作，可能包含多个查询和更新。TPS 是数据库操作和商业应用（如在线支付平台）的常用性能指标。TPS 的计算方法与 QPS 类似，将总事务数除以时间（秒）。</p>
<h3 id="103、CPU-利用率拉满的时候在线程池中增加线程是否能提高-qps？"><a href="#103、CPU-利用率拉满的时候在线程池中增加线程是否能提高-qps？" class="headerlink" title="103、CPU 利用率拉满的时候在线程池中增加线程是否能提高 qps？"></a>103、CPU 利用率拉满的时候在线程池中增加线程是否能提高 qps？</h3><p>（1）对于 CPU 密集型应用，CPU 是性能瓶颈。如果 CPU 利用率已经达到 100%，这意味着 CPU 资源已经被完全使用。在这种情况下，增加更多的线程实际上会导致线程之间的竞争更加激烈，因为更多的线程需要共享有限的 CPU 资源。这可能导致上下文切换增加，反而降低了程序的效率和 QPS。</p>
<p>（2）对于 IO 密集型应用，主要的瓶颈在于 IO 操作，如磁盘读写或网络通信等。即使 CPU 利用率很高，增加线程数仍然可能提高 QPS，因为当一部分线程在等待 IO 操作完成时，其他线程可以继续执行，从而提高整体的吞吐量。在这种情况下，增加线程数可以有效利用 CPU 在等待 IO 时的空闲周期，提高 QPS。</p>
<p>（3）混合型应用同时包含 CPU 密集型和 IO 密集型的操作。在这种情况下，是否增加线程以提高 QPS 取决于应用中 CPU 密集型和 IO 密集型操作的比例。如果 IO 操作占主导，增加线程可能有助于提高 QPS；但如果 CPU 密集型操作占主导，增加线程可能不会带来预期的效果，甚至可能因为线程竞争导致性能下降。</p>
<h3 id="104、什么是-CPU-密集型应用和-I-O-密集型应用？"><a href="#104、什么是-CPU-密集型应用和-I-O-密集型应用？" class="headerlink" title="104、什么是 CPU 密集型应用和 I&#x2F;O 密集型应用？"></a>104、什么是 CPU 密集型应用和 I&#x2F;O 密集型应用？</h3><p>（1）CPU 密集型应用是指那些需要进行大量计算，消耗大量 CPU 资源的应用。这类应用的特点是 CPU 使用率很高，因为它们主要进行数学计算、逻辑判断或者数据处理等操作，这些操作需要大量的 CPU 周期来完成。CPU 密集型应用的性能很大程度上依赖于 CPU 的处理能力。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>科学计算软件</li>
<li>图像处理和视频编码</li>
<li>大数据处理应用</li>
<li>游戏服务器的游戏逻辑处理</li>
<li>加密和解密操作</li>
</ul>
<p>（2）IO 密集型应用是指那些主要时间花费在输入输出操作上，而不是 CPU 计算上的应用。这类应用的特点是频繁地进行磁盘操作或网络通信，CPU 使用率不高，但是需要等待 IO 操作的完成，因此对 IO 性能的依赖很高。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>Web 服务器</li>
<li>数据库服务器</li>
<li>文件服务器</li>
<li>客户端&#x2F;服务器应用</li>
<li>大规模日志处理系统</li>
</ul>
<h3 id="105、I-O-密集型任务把-I-O-和业务逻辑分离有什么好处？"><a href="#105、I-O-密集型任务把-I-O-和业务逻辑分离有什么好处？" class="headerlink" title="105、I&#x2F;O 密集型任务把 I&#x2F;O 和业务逻辑分离有什么好处？"></a>105、I&#x2F;O 密集型任务把 I&#x2F;O 和业务逻辑分离有什么好处？</h3><p>（1）在 IO 密集型应用中，IO 操作（如文件读写、网络数据传输等）往往是性能瓶颈。通过异步 IO 或使用专门的线程&#x2F;进程处理 IO 操作，主业务逻辑不需要等待 IO 操作的完成，从而减少等待时间，提高整体应用的响应速度和吞吐量。</p>
<p>（2）分离 IO 和业务逻辑可以使系统更有效地使用 CPU 和 IO 资源。当 IO 操作在执行时，通常涉及等待外部设备响应，这段时间CPU可以处理其他任务，从而提高资源的利用率。</p>
<p>（3）当 IO 操作与业务逻辑分开后，更易于对系统进行扩展。例如，可以根据需要增加处理 IO 的线程或进程，或者改用更高效的 IO 处理模式（如使用更高级的异步 IO 库），而不需要重大修改应用的业务逻辑部分。</p>
<p>（4）分离 IO 和业务逻辑可以使测试变得更加简单。可以独立地对 IO 部分和业务逻辑部分进行测试，例如使用模拟的 IO 操作来测试业务逻辑，确保业务逻辑的正确性而不受 IO 影响。</p>
<h3 id="106、CPU-流水线技术是什么？"><a href="#106、CPU-流水线技术是什么？" class="headerlink" title="106、CPU 流水线技术是什么？"></a>106、CPU 流水线技术是什么？</h3><p>CPU 流水线技术是一种将指令分解为多步骤并让这些步骤并行执行的技术，从而提高 CPU 的执行效率。<strong>流水线技术通过将指令执行过程分解为取指令、译码、执行、访存和写回等阶段</strong>，每个阶段由不同的硬件单元处理，使得<strong>多条指令能够重叠执行</strong>，提高了处理速度。</p>
<h3 id="107、流水线技术中的分支预测的实现和意义？"><a href="#107、流水线技术中的分支预测的实现和意义？" class="headerlink" title="107、流水线技术中的分支预测的实现和意义？"></a>107、流水线技术中的分支预测的实现和意义？</h3><p>（1） 分支预测是流水线技术中用来<strong>处理指令跳转（如条件分支）带来的中断问题</strong>。现代 CPU 使用复杂的算法来预测程序中的分支跳转是否会发生，以及跳转到哪里。常见的分支预测技术包括静态分支预测（如始终预测跳转或不跳转）和动态分支预测（如基于历史信息的预测）。</p>
<p>（2）分支预测的主要目的是减少由于分支指令导致的流水线中断，从而提高程序执行的效率。正确的分支预测可以使 CPU 继续填充流水线而不必等待分支决定，错误的预测则会导致已经进入流水线的指令被撤销，降低效率。</p>
<h3 id="108、内核和应用进行数据交互的方法有哪些？"><a href="#108、内核和应用进行数据交互的方法有哪些？" class="headerlink" title="108、内核和应用进行数据交互的方法有哪些？"></a>108、内核和应用进行数据交互的方法有哪些？</h3><ol>
<li><strong>系统调用</strong> (System Calls):<ul>
<li>系统调用是应用程序与操作系统内核之间进行交互的主要方式。应用程序通过系统调用请求内核提供服务，如文件操作、进程控制、网络通信等。系统调用提供了一种安全的机制来执行硬件操作或访问内核级资源。</li>
</ul>
</li>
<li><strong>中断和异常</strong> (Interrupts and Exceptions):<ul>
<li>中断是外部设备或条件触发的，用于通知内核需要处理某些事件。异常则是程序执行错误时的一种特殊类型的中断，如除零错误或访问违规。</li>
<li>应用程序可以通过处理这些中断和异常来与内核交互，响应外部事件或错误。</li>
</ul>
</li>
<li><strong>共享内存</strong> (Shared Memory):<ul>
<li>共享内存是一种高效的数据交换方式，允许内核和一个或多个进程之间共享一段内存区域。这种方法可以避免复制数据，提高性能。</li>
</ul>
</li>
<li><strong>信号</strong> (Signals):<ul>
<li>信号是一种通知机制，用于通知进程发生了某些事件。内核可以向进程发送信号，以响应外部事件或内部错误，进程也可以发送信号给其他进程。</li>
</ul>
</li>
<li><strong>管道和套接字</strong> (Pipes and Sockets):<ul>
<li>管道提供了一种进程间通信的方法，允许数据在进程之间单向流动。套接字则支持更复杂的网络通信，包括进程间和网络间的数据交换。</li>
</ul>
</li>
<li><strong>文件系统操作</strong>:<ul>
<li>文件系统提供了一种存储和检索数据的方法，应用程序可以通过文件操作API与内核交互，进行数据的读写、查询和管理。</li>
</ul>
</li>
</ol>
<h3 id="109、系统调用从用户到内核的底层实现是什么？"><a href="#109、系统调用从用户到内核的底层实现是什么？" class="headerlink" title="109、系统调用从用户到内核的底层实现是什么？"></a>109、系统调用从用户到内核的底层实现是什么？</h3><ol>
<li><strong>系统调用接口</strong>：用户程序通常通过一个库（如 C 标准库）提供的封装函数来发起系统调用。这些库函数会设置好所有必要的参数供系统调用使用。</li>
<li><strong>陷入指令（Trap）</strong>：库函数内部会执行一个特殊的指令，通常是<code>syscall</code>（在 x86-64 架构中）或<code>int 0x80</code>（在较老的 x86 架构中）。这个指令会生成一个软件中断，将处理器从用户模式切换到内核模式。</li>
<li><strong>系统调用编号</strong>：每个系统调用都有一个唯一的编号。这个编号由用户程序设置在一个特定的寄存器（如 x86 中的 EAX）中，内核通过这个编号来识别具体执行哪一个系统调用。</li>
<li><strong>上下文切换</strong>：执行系统调用指令后，CPU 进入内核模式，操作系统接管控制权。此时，操作系统会保存用户程序的状态（如寄存器等），并准备执行相应的内核函数。</li>
<li><strong>执行系统调用</strong>：内核根据寄存器中的系统调用编号，通过查找系统调用表来找到对应的处理函数，并执行之。</li>
<li><strong>返回用户态</strong>：系统调用完成后，操作系统将结果返回给用户程序，恢复用户程序的上下文，并将CPU控制权返回给用户程序。</li>
<li><strong>结果传递</strong>：系统调用的结果通常通过寄存器或用户空间的内存位置返回给用户程序。</li>
</ol>
<h3 id="110、内核的调度方式是什么？"><a href="#110、内核的调度方式是什么？" class="headerlink" title="110、内核的调度方式是什么？"></a>110、内核的调度方式是什么？</h3><p>在 Linux 操作系统中，内核的调度方式是指如何管理和调度系统中的进程和线程，以优化性能和响应时间。Linux 内核使用多种调度策略和算法，主要包括以下几种：</p>
<ol>
<li><strong>完全公平调度器（Completely Fair Scheduler, CFS）</strong></li>
<li><strong>实时调度器</strong>，Linux 提供了两种实时调度策略：<code>SCHED_FIFO</code>（先进先出）和 <code>SCHED_RR</code>（时间片轮转）。</li>
<li><strong>Deadline 调度器（SCHED_DEADLINE）</strong>，这是一种较新的调度策略，用于确保任务在指定的截止时间之前完成。</li>
<li><strong>Cgroups 和任务组</strong>，Linux 还支持通过控制组（cgroups）对进程进行分组管理，这允许系统管理员根据需要对不同组的资源使用进行限制和监控。</li>
</ol>
<h3 id="111、为什么要设计用户态和内核态两种状态？"><a href="#111、为什么要设计用户态和内核态两种状态？" class="headerlink" title="111、为什么要设计用户态和内核态两种状态？"></a>111、为什么要设计用户态和内核态两种状态？</h3><p>这样做是为了保护操作系统的核心部分不被用户程序直接访问和修改，从而增加系统的稳定性和安全性。</p>
<p>（1）内核态主要允许操作系统访问受保护的硬件资源和内存区域，而用户态的控制程序则限制执行一些会影响系统稳定性和安全性的操作。</p>
<p>（2）如果用户态程序崩溃，它通常不会影响运行在内核态的系统核心部分，因此整个操作系统可以继续稳定运行。</p>
<p>（3）同时用户态程序也可能因为一些错误而尝试执行非法操作，此时操作系统可以拦截这些操作，避免对核心部分造成影响。</p>
<h3 id="112、单片机启动程序，在执行-main-之前的是什么"><a href="#112、单片机启动程序，在执行-main-之前的是什么" class="headerlink" title="112、单片机启动程序，在执行 main 之前的是什么"></a>112、单片机启动程序，在执行 main 之前的是什么</h3><p>在单片机启动程序中，执行main函数之前的过程主要包括以下几个步骤：</p>
<ol>
<li><strong>硬件设置</strong>：单片机上电后，首先进行的是硬件的初始化，包括设置堆栈指针（SP）和程序计数器（PC）。</li>
<li><strong>启动文件执行</strong>：接下来，单片机会执行启动文件，通常是名为 <code>startup_xxxxx.s</code> 的汇编语言文件。这个文件负责设置单片机的初始环境和配置，为 main 函数的执行做准备。</li>
<li><strong>初始化代码</strong>：在启动文件执行后，可能还会有一些初始化代码，这些代码用于初始化单片机的硬件和软件环境，比如设置时钟、配置中断等。</li>
<li><strong>跳转到main函数</strong>：所有的初始化和设置完成后，单片机最终会跳转到 main 函数开始执行用户的程序。</li>
</ol>
<p>这个过程确保了单片机在执行用户代码之前，硬件和系统环境已经被正确地设置和初始化，从而可以正确地运行用户程序。</p>
<h3 id="113、怎么在-main-函数执行之前打印字符串？"><a href="#113、怎么在-main-函数执行之前打印字符串？" class="headerlink" title="113、怎么在 main 函数执行之前打印字符串？"></a>113、怎么在 main 函数执行之前打印字符串？</h3><p>使用全局对象的构造函数。全局对象的构造函数在程序开始执行之前被调用，因此可以在这里进行一些初始化操作，包括打印字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GlobalPrinter</span> &#123;</span><br><span class="line">    <span class="comment">// 在构造函数中打印字符串</span></span><br><span class="line">    <span class="built_in">GlobalPrinter</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Printed before main starts!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局对象，其构造函数会在 main 函数之前执行</span></span><br><span class="line">GlobalPrinter printer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside main function.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>GlobalPrinter</code> 结构体是一个全局对象，其构造函数在程序启动时执行，因此会在 <code>main</code> 函数执行之前打印 <code>&quot;Printed before main starts!&quot;</code>。</p>
<h3 id="114、cpu-怎么从内存中获取数据的，要经过哪些模块（比如执行-load-指令时）？"><a href="#114、cpu-怎么从内存中获取数据的，要经过哪些模块（比如执行-load-指令时）？" class="headerlink" title="114、cpu 怎么从内存中获取数据的，要经过哪些模块（比如执行 load 指令时）？"></a>114、cpu 怎么从内存中获取数据的，要经过哪些模块（比如执行 load 指令时）？</h3><p>当 CPU 执行 load 指令从内存中获取数据时，通常会经过以下几个主要阶段和模块：</p>
<ol>
<li><strong>地址计算</strong>：CPU 根据 load 指令中的内存地址计算要访问的物理地址。这个地址通常是通过将逻辑地址（由程序中指定的地址）转换为物理地址来完成的。</li>
<li><strong>地址总线传输</strong>：CPU 使用地址总线将计算得到的物理地址发送到内存控制器（Memory Controller）。</li>
<li><strong>内存寻址</strong>：内存控制器接收到地址后，根据地址在物理内存中定位要访问的数据块。</li>
<li><strong>数据传输</strong>：内存控制器根据地址访问内存中的数据，并通过数据总线将数据传输回 CPU。</li>
<li><strong>数据接收</strong>：CPU 接收到数据，并将其存储到指定的寄存器或者目的地。</li>
</ol>
<h3 id="115、arm-和-x86-比较明显的区别是什么？"><a href="#115、arm-和-x86-比较明显的区别是什么？" class="headerlink" title="115、arm 和 x86 比较明显的区别是什么？"></a>115、arm 和 x86 比较明显的区别是什么？</h3><p><strong>指令集架构：</strong></p>
<ul>
<li><strong>x86 架构</strong>：主要用于个人电脑和服务器，采用复杂的指令集（CISC），例如 Intel 的 x86 和 x86-64（即64位扩展）架构。x86 架构的特点是指令集较为复杂，包含大量的指令和寄存器，能够执行复杂的操作，但功耗较高。</li>
<li><strong>ARM 架构</strong>：最初设计用于低功耗和嵌入式系统，采用精简指令集（RISC）。ARM 架构的特点是指令集简洁高效，适合于低功耗和嵌入式设备，如智能手机、平板电脑、嵌入式系统等。</li>
</ul>
<h3 id="116、如果发现系统变慢，linux-会怎么考虑怎么排查这个问题？"><a href="#116、如果发现系统变慢，linux-会怎么考虑怎么排查这个问题？" class="headerlink" title="116、如果发现系统变慢，linux 会怎么考虑怎么排查这个问题？"></a>116、如果发现系统变慢，linux 会怎么考虑怎么排查这个问题？</h3><ol>
<li><p><strong>观察系统资源使用情况</strong>：</p>
<p>使用命令 <code>top</code> 或 <code>htop</code> 查看当前系统的 CPU 使用率、内存使用情况、进程状态以及各个进程的资源消耗情况。特别关注是否有某个进程消耗过多的 CPU 或内存。</p>
</li>
<li><p><strong>检查系统负载情况</strong>：使用 <code>uptime</code> 命令或者查看 <code>/proc/loadavg</code> 文件，检查系统的负载情况。如果负载过高（load average 高于 CPU 核心数），说明系统可能存在过多的并发任务或者进程阻塞。</p>
</li>
<li><p><strong>查看日志文件</strong>：检查系统日志文件（如 <code>/var/log/messages</code>、<code>/var/log/syslog</code>）以及特定服务的日志（如 Apache、MySQL 等），寻找异常或者错误信息。日志文件通常会记录系统的各种事件和错误情况。</p>
</li>
<li><p><strong>检测磁盘使用情况</strong>：使用 <code>df</code> 命令查看磁盘分区的使用情况，尤其是是否出现磁盘空间不足或者磁盘 I&#x2F;O 瓶颈的情况。</p>
</li>
<li><p><strong>网络流量分析</strong>：使用 <code>netstat</code> 或者 <code>iftop</code> 查看网络连接和流量情况，检查是否有异常的网络活动或者网络流量过高。</p>
</li>
<li><p><strong>检查系统进程</strong>：使用 <code>ps</code> 命令查看当前运行的进程，并检查是否有异常或者不必要的进程占用资源。</p>
</li>
<li><p><strong>性能分析工具</strong>：使用工具如 <code>sar</code>、<code>vmstat</code>、<code>iostat</code> 等进行系统性能分析，查看 CPU、内存、磁盘和网络的详细使用情况，帮助定位性能瓶颈。</p>
</li>
<li><p><strong>检查硬件问题</strong>：如果排查软件问题后仍未找到原因，可能需要考虑硬件问题。通过检查硬件状态和日志（如 <code>/var/log/dmesg</code>）来排除硬件故障的可能性。</p>
</li>
</ol>
<h2 id="六、Linux-命令相关"><a href="#六、Linux-命令相关" class="headerlink" title="六、Linux 命令相关"></a>六、Linux 命令相关</h2><h3 id="117、哪些状态的进程无法被-kill？"><a href="#117、哪些状态的进程无法被-kill？" class="headerlink" title="117、哪些状态的进程无法被 kill？"></a>117、哪些状态的进程无法被 kill？</h3><p><strong>内核线程（Kernel Threads）</strong>：内核线程是在内核空间中执行的线程，通常由操作系统内核创建和管理。这些线程通常处于内核态，而不是用户态，因此无法通过kill命令来终止。</p>
<p><strong>僵尸进程（Zombie Processes）</strong>：僵尸进程是已经结束但是父进程尚未对其进行处理的子进程，这种进程处于僵尸状态。虽然它们已经结束了执行，但是它们的进程描述符仍然存在于系统中，直到父进程调用 wait 或 waitpid 等系统调用来获取它们的退出状态。在僵尸状态下，进程通常是无法通过kill命令来终止的。</p>
<p><strong>被内核保护的进程</strong>：一些特殊的进程可能受到内核的保护，例如一些关键的系统服务或者核心进程。这些进程通常由操作系统内核管理，并且可能受到权限限制，无法被普通用户通过kill命令终止。</p>
<h3 id="118、kill-是怎么实现终止进程的？"><a href="#118、kill-是怎么实现终止进程的？" class="headerlink" title="118、kill 是怎么实现终止进程的？"></a>118、kill 是怎么实现终止进程的？</h3><p>在 Linux 系统中，kill 命令用于向指定进程发送信号，其中包括终止进程的 SIGKILL 信号（信号编号为 9）和其他各种信号。终止进程的实现涉及操作系统内核的功能和进程管理机制。</p>
<p>当用户使用 kill 命令向某个进程发送 SIGKILL 信号时，操作系统内核会首先验证当前用户是否具有足够的权限来发送信号给目标进程。如果具有足够的权限，则内核会查找目标进程的进程描述符，并向其发送指定的信号。</p>
<p>接收到信号的进程会根据信号的类型采取不同的行动。对于 SIGKILL 信号，目标进程会被立即终止，无法进行信号处理或者捕获。此外，进程终止时，内核会对其进行一系列清理工作，包括释放该进程所占用的资源、解除与其他进程的关联等。</p>
<h3 id="119、常见命令合集"><a href="#119、常见命令合集" class="headerlink" title="119、常见命令合集"></a>119、常见命令合集</h3><h4 id="（1）查看哪个进程的内存占用最大？"><a href="#（1）查看哪个进程的内存占用最大？" class="headerlink" title="（1）查看哪个进程的内存占用最大？"></a>（1）查看哪个进程的内存占用最大？</h4><ol>
<li><p><code>top</code>+<code>M</code>键</p>
</li>
<li><p><code>ps</code>结合<code>sort</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps aux --<span class="built_in">sort</span>=-%mem | <span class="built_in">head</span> -n 10</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>htop</code></p>
</li>
</ol>
<h4 id="（2）查看进程打开了什么端口？"><a href="#（2）查看进程打开了什么端口？" class="headerlink" title="（2）查看进程打开了什么端口？"></a>（2）查看进程打开了什么端口？</h4><p> <code>netstat -tulnp</code> ，列出当前系统中所有正在监听的 TCP 和 UDP 端口以及对应的进程信息。</p>
<h4 id="（3）查看进程是否存活？"><a href="#（3）查看进程是否存活？" class="headerlink" title="（3）查看进程是否存活？"></a>（3）查看进程是否存活？</h4><p><code>ps -p &lt;PID&gt;</code>，查看指定 PID 的进程信息，如果返回了进程信息，则表示该进程存活。</p>
<h4 id="（4）查看进程-id-？"><a href="#（4）查看进程-id-？" class="headerlink" title="（4）查看进程 id ？"></a>（4）查看进程 id ？</h4><p> <code>ps aux | grep &lt;进程名&gt;</code> ，查看指定进程名的所有进程，并显示它们的进程 ID。</p>
<h4 id="（5）查看进程状态？"><a href="#（5）查看进程状态？" class="headerlink" title="（5）查看进程状态？"></a>（5）查看进程状态？</h4><p><code>ps</code> ，查看进程的状态。</p>
<p><code>ps aux</code> 命令可以列出系统中所有进程的详细信息，包括状态、PID、CPU 利用率等。</p>
<h4 id="（6）lsof-指令主要是干什么的？"><a href="#（6）lsof-指令主要是干什么的？" class="headerlink" title="（6）lsof 指令主要是干什么的？"></a>（6）lsof 指令主要是干什么的？</h4><p><code>lsof（list open files）</code>主要用于显示当前系统中打开的文件列表，包括文件、目录、网络套接字等。通过 lsof 命令可以查看某个进程打开了哪些文件、网络连接等信息，用于定位进程问题、分析系统资源利用等。</p>
<h4 id="（7）-如何让进程后台运行？"><a href="#（7）-如何让进程后台运行？" class="headerlink" title="（7） 如何让进程后台运行？"></a>（7） 如何让进程后台运行？</h4><ol>
<li><p><strong>使用 &amp; 符号</strong>：</p>
<ul>
<li><p>在命令行中，在命令的末尾加上 <code>&amp;</code> 符号，可以让该命令在后台执行。</p>
</li>
<li><p>例如，要让 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python script.py</span><br></pre></td></tr></table></figure>

<p> 在后台运行，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python script.py &amp;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用 nohup 命令</strong>：</p>
<ul>
<li><p><code>nohup</code> 命令用于将程序以忽略挂断信号的方式运行，这样即使终端关闭，程序也会继续在后台运行。</p>
</li>
<li><p>使用方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> python script.py &amp;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="（8）查看一个进程可以打开多少文件描述符？"><a href="#（8）查看一个进程可以打开多少文件描述符？" class="headerlink" title="（8）查看一个进程可以打开多少文件描述符？"></a>（8）查看一个进程可以打开多少文件描述符？</h4><p>在大多数 Linux 系统中，一个进程最多可以同时打开 1024 个文件。</p>
<p>不过，可以通过修改系统配置来增加： </p>
<ul>
<li><code>ulimit -n</code>：查看当前进程的文件描述符限制；</li>
<li><code>ulimit -n 4096</code>：将文件描述符限制增加到 4096。注意的是，文件描述符限制是系统范围的，而不是针对单个进程的。因此，对文件描述符限制的修改将影响到所有正在运行的进程。</li>
</ul>
<h4 id="（9）查看-CPU-核心数？"><a href="#（9）查看-CPU-核心数？" class="headerlink" title="（9）查看 CPU 核心数？"></a>（9）查看 CPU 核心数？</h4><p><strong>方法一</strong>：<code>lscpu</code> 命令，在输出中查找 <code>CPU(s):</code> 字段。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong>：读取 <code>/proc/cpuinfo</code> 文件可以，统计 <code>processor</code> 字段的行数，等于逻辑 CPU 核心的数量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep <span class="string">&quot;processor&quot;</span> | <span class="built_in">wc</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /proc/cpuinfo：这个命令用于打印 CPU 信息到标准输出。</span></span><br><span class="line"><span class="comment"># grep &quot;processor&quot;：通过管道 | 将 cat 命令的输出传递给 grep 命令，</span></span><br><span class="line"><span class="comment">#				    然后使用 grep 进行筛选，只保留包含 &quot;processor&quot; 字符串的行，</span></span><br><span class="line"><span class="comment">#					这些行包含了每个 CPU 核心的信息。</span></span><br><span class="line"><span class="comment"># wc -l：</span></span><br><span class="line"><span class="comment">#	wc 命令用于统计文件的行数，参数 -l 表示只统计行数。</span></span><br><span class="line"><span class="comment">#   通过 | 管道将 grep 命令的输出传递给 wc 命令，然后 wc 统计行数。</span></span><br><span class="line"><span class="comment">#	因为每个 CPU 核心的信息占据一行，所以统计出来的行数就是 CPU 的核心数。</span></span><br></pre></td></tr></table></figure>

<p><strong>方法三</strong>：<code>nproc</code> 命令，直接显示可用的处理器数量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nproc</span></span><br></pre></td></tr></table></figure>

<p><strong>方法四</strong>：<code>top</code> 和 <code>htop</code> 命令也可以显示 CPU 信息。在 <code>htop</code> 中，可以在界面顶部看到 CPU 核心的数量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">htop</span><br></pre></td></tr></table></figure>

<p><strong>方法五</strong>：<code>dmesg</code> 命令，查看启动日志，可以找到 CPU 信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dmesg | grep -i cpu</span><br></pre></td></tr></table></figure>

<h4 id="（10）如何按照内存使用情况对进程排序查看？"><a href="#（10）如何按照内存使用情况对进程排序查看？" class="headerlink" title="（10）如何按照内存使用情况对进程排序查看？"></a>（10）如何按照内存使用情况对进程排序查看？</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -o %MEM</span><br></pre></td></tr></table></figure>

<h4 id="（11）查看磁盘状态？"><a href="#（11）查看磁盘状态？" class="headerlink" title="（11）查看磁盘状态？"></a>（11）查看磁盘状态？</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">df</span> -sh &lt;目录名&gt;</span><br></pre></td></tr></table></figure>

<h4 id="（12）查看日志文件的前一百行？"><a href="#（12）查看日志文件的前一百行？" class="headerlink" title="（12）查看日志文件的前一百行？"></a>（12）查看日志文件的前一百行？</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 100 &lt;日志文件&gt;</span><br></pre></td></tr></table></figure>

<h4 id="（13）-ps-aux-，-aux-是干什么的？"><a href="#（13）-ps-aux-，-aux-是干什么的？" class="headerlink" title="（13） ps -aux ， aux 是干什么的？"></a>（13） ps -aux ， aux 是干什么的？</h4><p>在 <code>ps -aux</code> 命令中，<code>aux</code> 是选项，用于指定显示所有进程的详细信息。其中：</p>
<ul>
<li><code>a</code> 选项表示显示所有进程，包括与终端无关的进程。</li>
<li><code>u</code> 选项表示显示用户及与进程相关的详细信息，如用户 ID、CPU 占用率、内存占用等。</li>
<li><code>x</code> 选项表示显示与终端无关的进程。</li>
</ul>
<p>因此，<code>ps -aux</code> 命令用于显示系统中所有进程的详细信息，包括与终端无关的进程。</p>
<h4 id="（14）本地和远程服务器之间传输文件的是什么？"><a href="#（14）本地和远程服务器之间传输文件的是什么？" class="headerlink" title="（14）本地和远程服务器之间传输文件的是什么？"></a>（14）本地和远程服务器之间传输文件的是什么？</h4><p><code>scp</code></p>
<h4 id="（15）查找文件名包含某个关键字的文件"><a href="#（15）查找文件名包含某个关键字的文件" class="headerlink" title="（15）查找文件名包含某个关键字的文件"></a>（15）查找文件名包含某个关键字的文件</h4><p><code>find 目录 -name &quot;特定字符串&quot;</code></p>
<h3 id="120、Linux-包含哪些部分？"><a href="#120、Linux-包含哪些部分？" class="headerlink" title="120、Linux 包含哪些部分？"></a>120、Linux 包含哪些部分？</h3><ol>
<li>内核，操作系统的核心部分，负责管理计算机的硬件资源，包括处理器、内存、设备驱动程序等。它提供了系统调用接口，允许用户程序与硬件交互；</li>
<li>Shell，用户与操作系统交互的界面，它可以解释用户输入的命令并将其转换为操作系统能够理解的形式，常见的 Shell 包括 Bash、Zsh、Korn 等；</li>
<li>文件系统，指文件和目录在存储设备上的组织方式，它提供了对文件和目录的创建、读取、写入和删除等操作。常见的文件系统包括 ext4、NTFS、FAT32 等；</li>
<li>GNU 工具，一组用于开发和管理 Linux 系统的软件工具，包括编译器、调试器、文本编辑器等。常见的 GNU 工具包括 GCC、GDB、Emacs 等；</li>
<li>图形用户界面 GUI</li>
<li>应用程序。</li>
</ol>
<h3 id="121、操作系统包含哪些部分？"><a href="#121、操作系统包含哪些部分？" class="headerlink" title="121、操作系统包含哪些部分？"></a>121、操作系统包含哪些部分？</h3><ol>
<li><strong>内核（Kernel）</strong>：操作系统的核心部分，负责管理计算机的硬件资源，包括处理器、内存、设备驱动程序等。内核提供了系统调用接口，允许用户程序与硬件交互；</li>
<li><strong>文件系统（File System）</strong>：用于组织和管理计算机存储设备上的文件和目录。文件系统提供了文件的创建、读取、写入、删除等操作，以及对文件和目录的权限管理；</li>
<li><strong>进程管理（Process Management）</strong>：负责创建、调度和管理进程。进程是程序的执行实例，进程管理器控制着进程的创建、调度、终止等操作，并提供了进程间通信的机制；</li>
<li><strong>内存管理（Memory Management）</strong>：管理计算机的内存资源，包括内存的分配、释放、页面交换等操作。内存管理器负责为进程分配内存空间，并确保不同进程之间的内存地址空间互相隔离；</li>
<li><strong>文件系统（File System）</strong>：用于组织和管理计算机存储设备上的文件和目录。文件系统提供了文件的创建、读取、写入、删除等操作，以及对文件和目录的权限管理；</li>
<li><strong>设备驱动程序（Device Drivers）</strong>：负责与计算机的硬件设备进行通信，控制设备的操作和数据传输。设备驱动程序允许操作系统与硬件设备之间进行交互，以实现对硬件的控制和管理；</li>
<li><strong>用户界面（User Interface）</strong>：提供用户与操作系统交互的界面，包括命令行界面（CLI）和图形用户界面（GUI）。用户界面使用户能够通过输入命令或使用图形化界面来操作计算机；</li>
<li><strong>网络管理（Networking）</strong>：管理计算机与网络之间的通信和连接。网络管理器负责配置网络参数、管理网络接口、处理数据传输等操作，以确保计算机能够与其他设备进行通信。</li>
</ol>
<h2 id="七、文件系统"><a href="#七、文件系统" class="headerlink" title="七、文件系统"></a>七、文件系统</h2><h3 id="122、文件系统的基本组成"><a href="#122、文件系统的基本组成" class="headerlink" title="122、文件系统的基本组成"></a>122、文件系统的基本组成</h3><h3 id="123、虚拟文件系统"><a href="#123、虚拟文件系统" class="headerlink" title="123、虚拟文件系统"></a>123、虚拟文件系统</h3><h3 id="124、文件的存储"><a href="#124、文件的存储" class="headerlink" title="124、文件的存储"></a>124、文件的存储</h3><h3 id="125、空闲空间管理"><a href="#125、空闲空间管理" class="headerlink" title="125、空闲空间管理"></a>125、空闲空间管理</h3><h3 id="126、文件系统的结构"><a href="#126、文件系统的结构" class="headerlink" title="126、文件系统的结构"></a>126、文件系统的结构</h3><h3 id="127、目录的存储"><a href="#127、目录的存储" class="headerlink" title="127、目录的存储"></a>127、目录的存储</h3><h3 id="128、软链接和硬链接"><a href="#128、软链接和硬链接" class="headerlink" title="128、软链接和硬链接"></a>128、软链接和硬链接</h3><h3 id="129、文件I-O"><a href="#129、文件I-O" class="headerlink" title="129、文件I&#x2F;O"></a>129、文件I&#x2F;O</h3><h3 id="130、进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？"><a href="#130、进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？" class="headerlink" title="130、进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？"></a>130、进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？</h3><h2 id="八、设备管理"><a href="#八、设备管理" class="headerlink" title="八、设备管理"></a>八、设备管理</h2><h3 id="131、键盘敲入-A-字母时，操作系统期间发生了什么？"><a href="#131、键盘敲入-A-字母时，操作系统期间发生了什么？" class="headerlink" title="131、键盘敲入 A 字母时，操作系统期间发生了什么？"></a>131、键盘敲入 A 字母时，操作系统期间发生了什么？</h3><h2 id="九、网络系统"><a href="#九、网络系统" class="headerlink" title="九、网络系统"></a>九、网络系统</h2><h3 id="132、什么是零拷贝？"><a href="#132、什么是零拷贝？" class="headerlink" title="132、什么是零拷贝？"></a>132、什么是零拷贝？</h3><h3 id="133、I-O-多路复用：select-poll-epoll"><a href="#133、I-O-多路复用：select-poll-epoll" class="headerlink" title="133、I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll"></a>133、I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll</h3><h3 id="134、高性能网络模式：Reactor-和-Proactor"><a href="#134、高性能网络模式：Reactor-和-Proactor" class="headerlink" title="134、高性能网络模式：Reactor 和 Proactor"></a>134、高性能网络模式：Reactor 和 Proactor</h3><h3 id="135、什么是一致性哈希？"><a href="#135、什么是一致性哈希？" class="headerlink" title="135、什么是一致性哈希？"></a>135、什么是一致性哈希？</h3>]]></content>
      <categories>
        <category>面试</category>
        <category>八股</category>
      </categories>
  </entry>
  <entry>
    <title>毕设项目</title>
    <url>/2024/04/08/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E6%AF%95%E8%AE%BE%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h2 id="一、项目介绍"><a href="#一、项目介绍" class="headerlink" title="一、项目介绍"></a>一、项目介绍</h2><p>名称：<strong>多用户智能家居控制系统设计</strong>。</p>
<p><strong>设计了一个多用户智能家居控制系统。基于Qt平台开发Android客户端，同时基于MySQL数据库及多线程编程技术完成多用户操作，并利用MQTT通信协议实现了Android客户端与嵌入式控制终端之间的信息交互。、在此系统下Android 客户端的不同用户，可以通过Mosquitto云服务器转发的控制信息实现对iTop4412开发板的照明、警报及温度设备的实时控制。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404142132653.png" alt="image-20240414213213414"></p>
<p>1、 基于Linux多线程编程，结合MQTT协议的订阅-发布模式，完成多用户智能控制；</p>
<p>2、 在用户端设计双模式。共享模式：多个用户同时控制，且共享当前设备的状态；私人模式：被控制端的某一功能同一时间只能由一个用户控制；</p>
<p>3、 采用MQTT协议进行数据传送。通过实验对比HTTP协议和MQTT协议在智能家居领域的应用，结果表明MQTT在降低功耗和推送功能开发上优势明显，其即便是在资源有限的环境中也能易于使用。</p>
<p><strong>本项目的重点与核心在实现客户端的多用户控制。</strong></p>
<p>1、 针对发布者，利用Qt开发平台设计手机App作为客户端，它有两个特点，分别是多用户和双模式。多用户指不同的客户端均可进行控制操作；双模式指针对客户端本身，有共享模式和私人模式两种，在共享模式下可实现多个用户同时控制，且共享当前设备的状态；在私人模式下被控制端的某一功能同一时间只能由一个用户控制；</p>
<p>2、 针对消息代理者，选择在阿里云上部署mosquitto。选用MQTT协议的原因已在前述加以说明，而由于mosquitto是一种流行的mqtt服务器，且易于安装和配置，因此选用mosquitto进行部署；</p>
<p>3、 针对订阅者，主要以iTop4412开发板作为功能实现端。同时基于Linux多线程来配合实现多用户控制。</p>
<p><strong>本项目的数据转发过程如下。</strong></p>
<p>每个用户在该客户端程序中都对应操作两个线程：</p>
<p>（1）发送控制指令时的发布者身份，代表用户从Android客户端向嵌入式控制终端发送照明及警报的控制指令；<br>用户可自主规定订阅主题为“home&#x2F;*”格式。</p>
<p>（2）接收控制指令时的订阅者身份，代表开发板向用户发送温度数据；统一规定“temp”为传送温度数据的主题。</p>
<p><strong>发布者发出的控制指令将以json数据的格式被封装，经mosquitto云服务器转发后送至开发板侧，订阅者读取json包，解析出对应的命令行指令，对相应的硬件进行控制。</strong></p>
<h2 id="二、相关问题"><a href="#二、相关问题" class="headerlink" title="二、相关问题"></a>二、相关问题</h2><ol>
<li><p><strong>在项目中做了哪些工作，遇到了哪些困难，是怎么解决的？</strong></p>
<ul>
<li>工作：设计并实现了一个多用户智能家居控制系统，包括Android客户端、服务器软件和嵌入式控制终端。</li>
<li>困难：处理多用户操作的并发控制，确保数据一致性和系统稳定性。</li>
<li>解决方法：利用多线程编程技术和锁机制，以及基于MQTT的消息订阅和发布来处理并发控制问题。</li>
</ul>
</li>
<li><p><strong>整个项目包含哪几端之间的的通信？</strong></p>
<p>项目包含（1）Android客户端与服务器的通信；（2）服务器与嵌入式控制终端的通信；以及（3）客户端之间的间接通信（通过服务器转发）。</p>
</li>
<li><p><strong>客户端与客户端之间的通信是基于自己实现的协议吗？</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404142133602.png" alt="image-20240414213314541"></p>
</li>
<li><p><strong>是在客户端上面跑的MySQL吗？</strong></p>
<p>不是，MySQL数据库运行在服务器端，用于存储用户数据和状态信息，客户端通过网络与之通信。</p>
</li>
<li><p><strong>Qt可以直接打包安卓客户端吗？</strong>、</p>
<p>是的，Qt提供了支持Android的工具和库，可以直接将应用打包为Android客户端。</p>
</li>
<li><p><strong>Qt中做多线程的编程，有哪一些是线程同步的技术？</strong></p>
<p>Qt支持多种线程同步技术，包括互斥锁（QMutex）、读写锁（QReadWriteLock）、信号量（QSemaphore）、条件变量（QWaitCondition）等。</p>
</li>
<li><p><strong>为什么用多线程能解决冲突问题？</strong></p>
<p>程序通过 <code>pthread_create</code> 函数创建了两个线程，多线程主要用于处理订阅和发布MQTT消息的任务。</p>
<ol>
<li><code>sub_thread</code> 用于订阅 MQTT 消息并处理接收到的消息，涉及到订阅者之间的状态共享或者资源竞争，因此使用互斥锁来保护共享资源的访问，确保线程安全。</li>
<li><code>pub_thread</code> 用于发布 MQTT 消息。操作和<code>sub_thread</code>类似，但不需要对其进行加锁操作。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404142139031.png" alt="image-20240414213944988"></p>
</li>
<li><p><strong>锁是放在哪里的？</strong></p>
<p>互斥锁放在嵌入式控制终端中。</p>
</li>
<li><p><strong>比如说你有多个客户端，你怎么知道对面锁住了呢？</strong></p>
<p>客户端设计了共享模式和私人模式两种，当一个用户选择进入私人模式时，会通过Qt的信号与槽机制在客户端进行更新，告诉其他用户已经有用户进入了私人模式，本客户端无法再进入。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404142136791.png" alt="image-20240414213614733"></p>
</li>
<li><p><strong>在做技术选型的时候，什么时候选多线程，什么时候选多进程？</strong></p>
<ul>
<li><strong>选择多线程</strong>：当应用需要共享大量数据时，多线程是一种更合适的选择。多线程同一进程内的线程共享内存和资源，上下文切换成本较低，适用于对性能要求较高的场景，如实时计算、游戏开发等。</li>
<li><strong>选择多进程</strong>：多进程则适用于需要增强应用稳定性和安全性的场景，因为各进程间相互独立，一个进程的崩溃不会直接影响到其他进程。此外，多进程可以利用多核CPU的优势，实现真正的并行执行，适用于需要大量并行计算的应用，如视频处理、大规模数据分析等。</li>
</ul>
</li>
<li><p><strong>在Android客户端中，如何实现界面的实时更新和数据同步？</strong></p>
<ul>
<li>使用信号与槽机制： 在Qt中，通过信号与槽机制实现对象之间的通信。当数据发生变化时，可以通过信号发送变化的消息，然后在界面组件中连接相应的槽函数来更新界面。</li>
</ul>
</li>
<li><p><strong>如何通过mosquitto服务器将客户端的控制指令转发给iTop4412开发板？</strong></p>
<ul>
<li>在mosquitto服务器上配置相应的主题和订阅关系，客户端发布控制指令到对应的主题，mosquitto服务器将控制指令转发给iTop4412开发板的订阅者。</li>
</ul>
</li>
<li><p><strong>MQTT协议与HTTP协议相比，有何优势？为什么选择MQTT协议进行数据传送？</strong></p>
<ul>
<li>MQTT协议相比HTTP协议在降低功耗和推送功能开发上具有明显优势，适合于资源有限的环境和实时数据传输的场景。因此选择MQTT协议进行数据传送。</li>
</ul>
</li>
<li><p><strong>介绍一下阿里云上部署mosquitto的过程。</strong></p>
<ul>
<li><p>在阿里云上安装mosquitto，配置mosquitto的配置文件，设置端口号和用户名密码等参数，启动mosquitto服务，配置防火墙规则允许外部访问。</p>
</li>
<li><p>MQTT服务器的端口号通常是1883。</p>
</li>
</ul>
</li>
<li><p><strong>如何在iTop4412开发板上实现对控制指令的接收和执行？</strong></p>
<ul>
<li>通过Linux多线程编程，在iTop4412开发板上创建一个线程来监听MQTT服务器发送的控制指令，接收到指令后解析并执行对应的命令。</li>
</ul>
</li>
<li><p><strong>在Android客户端中，如何使用JSON格式封装控制指令？</strong></p>
<ul>
<li>使用 <code>cJSON_CreateObject()</code> 函数创建一个空的JSON对象。</li>
<li>使用 <code>cJSON_AddNumberToObject()</code> 函数向JSON对象中添加一个键值对，键为 “temp”，值为一个随机生成的温度值 <code>a</code>。</li>
<li>使用 <code>cJSON_Print()</code> 函数将JSON对象打印成JSON格式的字符串，并将其赋值给 <code>json_buf</code>。</li>
<li>使用 <code>mosquitto_publish()</code> 函数将JSON字符串发布到MQTT服务器上的主题为 “temp” 的通道中。</li>
</ul>
</li>
<li><p><strong>在iTop4412开发板上，如何解析JSON格式的控制指令并执行相应的功能操作？</strong></p>
<ul>
<li>使用第三方JSON库cJSON在Linux环境下解析JSON格式的控制指令，提取出对应的命令参数，然后调用相应的系统调用或执行命令行来控制硬件设备。</li>
</ul>
</li>
<li><p><strong>在多用户智能家居控制系统中，如何实现用户认证和权限管理？</strong></p>
<ul>
<li>在安卓客户端上实现用户登录和注册功能。将用户信息存储在MySQL数据库上，在登陆查询当前用户是否属于该数据库，以及用户名与密码是否匹配；若不存在，可进行注册操作。</li>
<li>由于本设计要访问特定公网的阿里云服务器上的数据库，因此在Qt开发平台上需要首先提供所需要的驱动插件之后，再利用QSqlDatabase来处理与数据库的连接，利用QSqlQuery类来执行底层数据库支持的任何SQL语句。</li>
</ul>
</li>
<li><p><strong>在iTop4412开发板上，如何实现硬件设备的驱动和控制？</strong></p>
<ul>
<li>通过 MQTT 实现硬件设备的驱动和控制：<ul>
<li>当用户在 UI 上进行操作时，比如点击 LED 开关按钮，UI 触发对应的槽函数，如 <code>on_ledBt_ON_1_clicked()</code>。</li>
<li>在槽函数中构造一个JSON 数据包，其中包含了需要控制的硬件设备信息，比如 LED 的状态。然后将这个 JSON 数据包发布到 MQTT 主题上，通过 MQTT 协议发送给 MQTT 服务器。</li>
<li>在硬件设备端，通过订阅相应的 MQTT 主题，监听来自 MQTT 服务器的消息。</li>
<li>当硬件设备端接收到相应的消息后，解析 JSON 数据包，获取到控制指令，并执行相应的操作，例如打开或关闭 LED。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>该项目还有哪些可以改进的地方？</strong></p>
<ul>
<li><p>可以在mosquitto服务器上配置TLS&#x2F;SSL加密通信，客户端和服务器之间通过证书验证进行安全连接，防止数据被窃取或篡改。确保安卓客户端与mosquitto服务器之间的通信安全性。</p>
</li>
<li><p>此外，对于多线程部分我觉得还可以再考虑细化锁的粒度，以及进行RAII技术管理互斥锁，避免在某些异常情况下未释放锁导致资源泄露问题。</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>C++面向对象高级编程</title>
    <url>/2024/05/06/Computer/C++/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://lishizheng.blog.csdn.net/article/details/135360282">C++面向对象高级编程（侯捷）笔记1</a></p>
<p>2 头文件和类的声明<br>3 构造函数<br>4 参数传递与返回值<br>5 操作符重载与临时对象<br>    操作符重载1——成员函数<br>    操作符重载2——非成员函数<br>6 复习Complex类的实现过程</p>
<span id="more"></span>


<p><a href="https://lishizheng.blog.csdn.net/article/details/135360334">C++面向对象高级编程（侯捷）笔记2</a></p>
<p>7 三大函数：拷贝构造、拷贝赋值、析构<br>8 堆 栈和内存管理<br>9 复习String类的实现过程<br>10 扩展补充：类模板，函数模板及其他<br>11 组合与继承<br>​		Composition复合，表示has-a<br>​		Delegation委托. Composition by reference<br>​		Inheritance（继承），表示is-a<br>12 虚函数和多态<br>13 委托相关设计</p>
<p><a href="https://lishizheng.blog.csdn.net/article/details/135388444">C++程序设计兼谈对象模型（侯捷）笔记</a></p>
<p>2 conversion function 转换函数<br>3 non-explicit-one-argument constructor<br>4 pointer-like classes<br>5 function-like classes<br>6 namespace经验谈<br>7 class template 类模板<br>8 function template 函数模板<br>9 member template 成员模板<br>10 specialization 模板特化<br>11 模板偏特化<br>12 模板模板参数<br>13 关于C++标准库<br>14 三个主题 variadic templates等<br>15 reference<br>16 复合&amp;继承关系下的构造和析构<br>17 （对象模型）关于vptr和vtbl，虚指针和虚表<br>18 （对象模型）关于this<br>19 （对象模型）关于Dynamic Binding</p>
]]></content>
      <categories>
        <category>Computer</category>
        <category>C++</category>
        <category>侯捷C++系列</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2024/05/28/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h2 id="1-1-TCP-IP网络模型"><a href="#1-1-TCP-IP网络模型" class="headerlink" title="1.1 TCP&#x2F;IP网络模型"></a>1.1 TCP&#x2F;IP网络模型</h2><h3 id="1、为什么要有TCP-IP网络模型？"><a href="#1、为什么要有TCP-IP网络模型？" class="headerlink" title="1、为什么要有TCP&#x2F;IP网络模型？"></a>1、为什么要有TCP&#x2F;IP网络模型？</h3><p>为了实现不同设备间的通信，需要网络通信。又由于需要兼容多样性的设备，因此需要一套通用的网络协议。</p>
<h3 id="2、TCP-IP网络模型概述"><a href="#2、TCP-IP网络模型概述" class="headerlink" title="2、TCP&#x2F;IP网络模型概述"></a>2、TCP&#x2F;IP网络模型概述</h3><p><strong>1、应用层</strong></p>
<p>应用层工作在操作系统的用户态，不关心数据如何传输，只需要为用户提供应用功能，如HTTP、FTP、Telent、DNS和SMTP等。</p>
<p><strong>2、传输层</strong></p>
<p>传输层为应用层提供网络支持，包含两个传输协议，TCP（可靠）和UDP（不可靠）。由于应用需要传输的数据可能会非常大，因此当传输层的数据包超过MSS（TCP 最大报文段长度）时 ，就要将数据包分块（即TCP段）。</p>
<p>当设备作为接收方时，传输层则要负责把数据包传给应用，根据传输层报文中携带的端口号，应用层识别出该报文发送给哪个应用。</p>
<p><strong>3、网络层</strong></p>
<p>网络层负责将数据从一个设备传输到另一个设备（与此相比，传输层只负责作为应用间数据传输的媒介）。</p>
<p>网络层最常使用的是 IP 协议（Internet Protocol），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg" alt="img" style="zoom:50%;" />

<p>用IP地址作为区分不同设备的编号。一个IP地址包括两部分：</p>
<ul>
<li>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；</li>
<li>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405280946647.jpeg" alt="img" style="zoom:50%;" />

<p>除了寻址能力， IP 协议还有另一个重要的能力就是<strong>路由</strong>。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</p>
<p>路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/17.jpg" alt="IP地址的网络号" style="zoom:50%;" />

<p>所以，<strong>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</strong>。</p>
<p><strong>4、网络接口层</strong></p>
<p>网络接口层主要为网络层提供链路级别传输的服务，负责在以太网、WiFi这样的底层网络上发送原始数据包，工作在网卡这个层次，使用MAC地址来标识网络上的设备。</p>
<p>什么是以太网呢？电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。</p>
<p>以太网在判断网络包目的地时必须采用相匹配的方式才能在以太网中将包发往目的地，MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</p>
<p><strong>5、总结</strong></p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png" alt="img" style="zoom: 50%;" />

<p>每一层的封装格式：</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img" style="zoom: 50%;" />

<h2 id="1-2-键入网址到网页显示，期间发生了什么？"><a href="#1-2-键入网址到网页显示，期间发生了什么？" class="headerlink" title="1.2 键入网址到网页显示，期间发生了什么？"></a>1.2 键入网址到网页显示，期间发生了什么？</h2><blockquote>
<p><strong>第一步</strong>，浏览器对URL进行解析，确定Web服务器和文件名；</p>
<p><strong>第二步</strong>，生成发送给Web服务器的HTTP请求信息；</p>
<p><strong>第三步</strong>，通过DNS查询与服务器域名对应的IP地址；</p>
<p><strong>第四步</strong>，将HTTP的传输工作交给操作系统中的协议栈；</p>
<p><strong>第五步</strong>，将请求信息封装为TCP报文，交给下面的网络层处理；</p>
<p><strong>第六步</strong>，根据查询到的IP信息将TCP报文封装为IP报文；</p>
<p><strong>第七步</strong>，根据自己的网络获取源MAC地址，根据ARP协议找到目的IP地址对应的MAC地址，从而封装好MAC报文，生成最终的网络包；</p>
<p><strong>第八步</strong>，通过网卡将网络包这串数字信号转为电信号，通过网线发送出去；</p>
<p><strong>第九步</strong>，通过交换机和路由器的转发，最终到达Web服务器；</p>
<p><strong>第十步</strong>，Web服务器的HTTP进程接收到请求报文后，将请求的网页封装在HTTP响应报文里，根据类似的步骤发送至客户端。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405280953095.png" alt="简单的网络模型"></p>
<h3 id="1、第一步，浏览器对URL进行解析，确定Web服务器和文件名；"><a href="#1、第一步，浏览器对URL进行解析，确定Web服务器和文件名；" class="headerlink" title="1、第一步，浏览器对URL进行解析，确定Web服务器和文件名；"></a>1、第一步，浏览器对URL进行解析，确定Web服务器和文件名；</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281022515.jpeg" alt="URL 解析"></p>
<ul>
<li><strong>当URL中并未给出表示数据源&#x2F;文件的路径名时，请求的是哪个文件？</strong></li>
</ul>
<p>当没有路径名时，就代表访问根目录下事先设置的<strong>默认文件</strong>，也就是 &#x2F;index.html 或者 &#x2F;default.html 等这些文件。</p>
<h3 id="2、第二步，生成发送给Web服务器的HTTP请求信息；"><a href="#2、第二步，生成发送给Web服务器的HTTP请求信息；" class="headerlink" title="2、第二步，生成发送给Web服务器的HTTP请求信息；"></a>2、第二步，生成发送给Web服务器的HTTP请求信息；</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281022489.png" alt="HTTP 的消息格式" style="zoom:50%;" />

<h3 id="3、第三步：通过DNS查询与服务器域名对应的IP地址；"><a href="#3、第三步：通过DNS查询与服务器域名对应的IP地址；" class="headerlink" title="3、第三步：通过DNS查询与服务器域名对应的IP地址；"></a>3、<strong>第三步：通过DNS查询与服务器域名对应的IP地址；</strong></h3><p>DNS服务器负责保存Web服务器域名与IP的对应关系。当然，首先会考虑是否能在缓存中直接找到，因此总的寻找顺序如下：</p>
<p>1、浏览器自身的缓存；</p>
<p>2、操作系统自身的缓存；</p>
<p>3、hosts文件；</p>
<p>4、本地DNS服务器。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281023787.png" alt="域名解析的工作流程"></p>
<h3 id="4、第四步，将HTTP的传输工作交给操作系统中的协议栈；"><a href="#4、第四步，将HTTP的传输工作交给操作系统中的协议栈；" class="headerlink" title="4、第四步，将HTTP的传输工作交给操作系统中的协议栈；"></a>4、第四步，将HTTP的传输工作交给操作系统中的协议栈；</h3><ul>
<li>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作；</li>
<li>TCP&#x2F;UDP接受应用层的委托，执行收发数据的操作；</li>
<li>IP协议控制网络包的收发操作；</li>
<li>网卡驱动程序负责控制网卡硬件；</li>
<li>网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</li>
</ul>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg" alt="img" style="zoom:50%;" />

<h3 id="5、第五步，将请求信息封装为TCP报文，交给下面的网络层处理；"><a href="#5、第五步，将请求信息封装为TCP报文，交给下面的网络层处理；" class="headerlink" title="5、第五步，将请求信息封装为TCP报文，交给下面的网络层处理；"></a>5、第五步，将请求信息封装为TCP报文，交给下面的网络层处理；</h3><ul>
<li>根据三次握手建立连接；</li>
<li>将HTTP信息以 <code>MSS</code> 的长度为单位进行拆分；</li>
<li>封装TCP报文。</li>
</ul>
<h3 id="6、第六步，根据查询到的IP信息将TCP报文封装为IP报文；"><a href="#6、第六步，根据查询到的IP信息将TCP报文封装为IP报文；" class="headerlink" title="6、第六步，根据查询到的IP信息将TCP报文封装为IP报文；"></a>6、第六步，根据查询到的IP信息将TCP报文封装为IP报文；</h3><ul>
<li><strong>假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？</strong></li>
</ul>
<p>当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。这个时候就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址 IP。</p>
<h3 id="7、第七步，根据自己的网络获取源MAC地址，根据ARP协议找到目的IP地址对应的MAC地址，从而封装好MAC报文，生成最终的网络包；"><a href="#7、第七步，根据自己的网络获取源MAC地址，根据ARP协议找到目的IP地址对应的MAC地址，从而封装好MAC报文，生成最终的网络包；" class="headerlink" title="7、第七步，根据自己的网络获取源MAC地址，根据ARP协议找到目的IP地址对应的MAC地址，从而封装好MAC报文，生成最终的网络包；"></a>7、第七步，根据自己的网络获取源MAC地址，根据ARP协议找到目的IP地址对应的MAC地址，从而封装好MAC报文，生成最终的网络包；</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281111484.jpeg" alt="MAC 层报文" style="zoom:50%;" />

<h3 id="8、第八步，通过网卡将网络包这串数字信号转为电信号，通过网线发送出去；"><a href="#8、第八步，通过网卡将网络包这串数字信号转为电信号，通过网线发送出去；" class="headerlink" title="8、第八步，通过网卡将网络包这串数字信号转为电信号，通过网线发送出去；"></a>8、第八步，通过网卡将网络包这串数字信号转为电信号，通过网线发送出去；</h3><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png" alt="数据包" style="zoom: 67%;" />

<h3 id="9、第九步，通过交换机和路由器的转发，最终到达Web服务器；"><a href="#9、第九步，通过交换机和路由器的转发，最终到达Web服务器；" class="headerlink" title="9、第九步，通过交换机和路由器的转发，最终到达Web服务器；"></a>9、第九步，通过交换机和路由器的转发，最终到达Web服务器；</h3><p><strong>交换机的工作方式和网卡不同：</strong></p>
<p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p>
<h3 id="10、第十步，Web服务器的HTTP进程接收到请求报文后，将请求的网页封装在HTTP相应报文里，根据类似的步骤发送至客户端。"><a href="#10、第十步，Web服务器的HTTP进程接收到请求报文后，将请求的网页封装在HTTP相应报文里，根据类似的步骤发送至客户端。" class="headerlink" title="10、第十步，Web服务器的HTTP进程接收到请求报文后，将请求的网页封装在HTTP相应报文里，根据类似的步骤发送至客户端。"></a>10、第十步，Web服务器的HTTP进程接收到请求报文后，将请求的网页封装在HTTP相应报文里，根据类似的步骤发送至客户端。</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/25.jpg" alt="网络分层模型" style="zoom:50%;" />

<blockquote>
<ul>
<li>读者问：“请问公网服务器的 Mac 地址是在什么时机通过什么方式获取到的？我看 arp 获取Mac地址只能获取到内网机器的 Mac 地址吧？”</li>
</ul>
<p>在发送数据包时，如果目标主机不是本地局域网，填入的MAC地址是路由器，也就是把数据包转发给路由器，路由器一直转发下一个路由器，直到转发到目标主机的路由器，发现 IP 地址是自己局域网内的主机，就会 ARP 请求获取目标主机的 MAC 地址，从而转发到这个服务器主机。</p>
<p>转发的过程中，源IP地址和目标IP地址是不会变的（前提：没有使用 NAT 网络的），源 MAC 地址和目标 MAC 地址是会变化的。</p>
</blockquote>
<h2 id="1-3-Linux-系统是如何收发网络包的？"><a href="#1-3-Linux-系统是如何收发网络包的？" class="headerlink" title="1.3 Linux 系统是如何收发网络包的？"></a>1.3 Linux 系统是如何收发网络包的？</h2><p>Linux 网络协议栈：</p>
<ul>
<li>应用程序需要通过系统调用，来跟 Socket 层进行数据交互；</li>
<li>Socket 层的下面就是传输层、网络层和网络接口层；</li>
<li>最下面的一层，则是网卡驱动程序和硬件网卡设备；</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281119851.png" alt="img" style="zoom: 50%;" />





<p>一个网络包的收发流程：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281124646.png" alt="img"></p>
<h3 id="1、Linux接收网络包的流程"><a href="#1、Linux接收网络包的流程" class="headerlink" title="1、Linux接收网络包的流程"></a>1、Linux接收网络包的流程</h3><blockquote>
<p>当网卡接收到网络包后，通过DMA将网络包写入Ring Buffer中，并通过中断和轮询的方式告诉操作系统该网络包已到达。</p>
<p>操作系统首先调用硬件中断处理函数表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以，不需要再通知CPU了，接着发起软中断，恢复刚才屏蔽的中断。软中断则从Ring Buffer中获取一个数据帧，即<code>sk_buff</code>，作为网络包交给网络协议栈进行逐层处理。</p>
<p>逐层处理的过程是（1）先进入网络接口层，检查报文的合法性，并并找出上层协议的类型；（2）交给网络层，取出IP包，判断是要转发出去还是交给本机上层处理；（3）传输层取出TCP&#x2F;UDP头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的Socket，将数据放入Socket对应的接收缓冲区；（4）最后，应用进程调用Socket接口，将内核的Socket接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。</p>
</blockquote>
<p>（1）网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。</p>
<p>（2）通过触发中断的方式来告诉操作系统这个网络包已到达，但为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 <strong>NAPI 机制</strong>，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是<strong>不采用中断的方式读取数据</strong>，而是首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据。</p>
<ul>
<li>硬件中断处理函数：<ul>
<li>需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。</li>
<li>接着，发起「软中断」，然后恢复刚才屏蔽的中断。</li>
</ul>
</li>
<li>软件中断处理函数：<ul>
<li>内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，轮询处理数据。</li>
<li>ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 <code>sk_buff</code> 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</li>
</ul>
</li>
</ul>
<p>（3）逐层处理的流程如下。</p>
<ul>
<li>首先，会先进入到网络接口层，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给网络层。</li>
<li>到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。</li>
<li>传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。</li>
<li>最后，应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。</li>
</ul>
<p>至此，一个网络包的接收过程就已经结束了。</p>
<h3 id="2、Linux发送网络包的流程"><a href="#2、Linux发送网络包的流程" class="headerlink" title="2、Linux发送网络包的流程"></a>2、Linux发送网络包的流程</h3><blockquote>
<p>首先，应用进程调用Socket发送数据的接口，从用户态进入内核态，内核申请一个<code>sk_buff</code>内存，将用户待发送的数据拷贝到<code>sk_buff</code>内存，并将其加入到发送缓冲区。</p>
<p>其次，网络协议栈从Socket发送缓冲区取出<code>sk_buff</code>，<code>sk_buff</code>通过调整其data的指针，可以表示各个层的数据包。因此按照TCP&#x2F;IP协议栈从上到下逐层处理，最终将<code>sk_buff</code>放到网卡的发送队列中。注意如果使用的是 TCP 传输协议发送数据，需要先拷贝一个新的 <code>sk_buff</code> 副本。</p>
<p>此时，会触发「软中断」告诉网卡驱动程序有新的网络包需要发送。驱动程序从发送队列中读取<code>sk_buff</code>并挂到<code>Ring Buffer</code>中，并将<code>sk_buff</code>的数据映射到网卡可访问的内存DMA区域，并触发真实的发送。</p>
<p>当数据发送完成后，网卡设备会触发硬中断释放内存，主要是释放<code>sk_buff</code> 内存和清理<code>Ring Buffer</code>内存。并且，当收到这个 TCP 报文的 ACK 应答时，传输层会释放原始的<code>sk_buff</code>。</p>
</blockquote>
<p>（1）首先，应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 <code>sk_buff</code>内存，<strong>将用户待发送的数据拷贝到 <code>sk_buff</code> 内存，并将其加入到发送缓冲区</strong>。</p>
<p>（2）接下来，网络协议栈从 Socket 发送缓冲区中取出<code>sk_buff</code>，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理。</p>
<p><strong>（3）如果使用的是 TCP 传输协议发送数据，那么先拷贝一个新的 <code>sk_buff</code> 副本 ，这是因为 <code>sk_buff</code>后续在调用网络层，最后到达网卡发送完成的时候，这个<code>sk_buff</code>会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK  之前，这个<code>sk_buff</code>不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是<code>sk_buff</code>的一个拷贝，等收到 ACK 再真正删除。</strong></p>
<p>（4）接着，对<code>sk_buff</code> 填充 TCP 头。这里提一下，<code>sk_buff</code>可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。</p>
<blockquote>
<p>为了在层级之间传递数据时不发生拷贝，只用<code>sk_buff</code> 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 <code>sk_buff</code> 中 <code>data</code> 的指针，比如：</p>
<ul>
<li>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb-&gt;data 的值，来逐步剥离协议首部。</li>
<li>当要发送报文时，创建 <code>sk_buff</code> 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb-&gt;data 的值来增加协议首部。</li>
</ul>
</blockquote>
<p>（5）然后交给网络层，在网络层里会做这些工作：选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。处理完这些工作后会交给网络接口层处理。</p>
<p>（6）网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对<code>sk_buff</code> 填充帧头和帧尾，接着将 <code>sk_buff</code> 放到网卡的发送队列中。</p>
<p>（7）这一些工作准备好后，会触发「软中断」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取<code>sk_buff</code>，将这个<code>sk_buff</code>挂到 RingBuffer 中，接着将<code>sk_buff</code>数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。</p>
<p>（8）当数据发送完成以后，其实工作并没有结束，因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存，主要是释放<code>sk_buff</code> 内存和清理 RingBuffer 内存。</p>
<p>（9）最后，当收到这个 TCP 报文的 ACK 应答时，传输层就会释放原始的<code>sk_buff</code>。</p>
<blockquote>
<ul>
<li>发送网络数据的时候，涉及几次内存拷贝操作？</li>
</ul>
<p>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 <code>sk_buff</code> 内存，将用户待发送的数据拷贝到 <code>sk_buff</code> 内存，并将其加入到发送缓冲区。</p>
<p>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 <code>sk_buff</code> 都会被克隆一个新的副本出来。副本 <code>sk_buff</code>  会被送往网络层，等它发送完的时候就会释放掉，然后原始的 <code>sk_buff</code> 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的  ACK 时，才会释放原始的 <code>sk_buff</code> 。</p>
<p>第三次，当 IP 层发现 <code>sk_buff</code> 大于 MTU 时才需要进行。会再申请额外的 <code>sk_buff</code>，并将原来的 <code>sk_buff</code> 拷贝为多个小的 <code>sk_buff</code>。</p>
</blockquote>
<h3 id="3、技术补充"><a href="#3、技术补充" class="headerlink" title="3、技术补充"></a>3、技术补充</h3><h4 id="（1）DMA（Direct-Memory-Access）"><a href="#（1）DMA（Direct-Memory-Access）" class="headerlink" title="（1）DMA（Direct Memory Access）"></a>（1）DMA（Direct Memory Access）</h4><p>一种内存访问技术，允许某些电脑内部的硬件子系统（电脑外设）可以独立地直接读写系统内存，而不需要中央处理器（CPU）介入处理。</p>
<ol>
<li>传统CPU存取数据</li>
</ol>
<p>CPU 不直接存取外设的原因：</p>
<ul>
<li>CPU 的工作速度和外设的工作速度差距太大；</li>
<li>外设格式种类繁多，无法直接存取，需要经过转换</li>
</ul>
<p>基于上述原因，CPU 不能直接从外设获取或者向外设写入内容。传统CPU 获取数据的步骤如下：</p>
<blockquote>
<p>1、CPU 将外设数据加载到内存（和CPU的处理速度最接近）</p>
<p>2、CPU 检查 cache 是否有自己需要的数据（是否命中）</p>
<p>3、如果命中，直接返回数据；如未命中，继续从内存获取（这里暂时不考虑MMU）</p>
<p>4、返回数据</p>
</blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281501833.png" alt="img" style="zoom:50%;" />

<ol start="2">
<li>DMA</li>
</ol>
<p>由上面CPU 读取数据来看，无论是将外设数据搬移到内存，还是从内存读取数据，都需要CPU 的参与。为了让 CPU 能够专注于处理手中事务，DMA 将负责数据的搬移工作。</p>
<p>DMA（Direct Memory Access）即直接存储器访问，借助内部的控制器来实现内存和外设之间的数据传输。有了DMA，CPU 可以专注于内存数据的存取；数据的搬运过程完全可以交由DMA硬件完成。有了DMA以后，不代表完全不需要CPU了，只是不会像中断那样频繁向CPU发送请求。</p>
<img src="https://img-blog.csdnimg.cn/57fc82764f3c4ca9b45bef7d402a083a.png" alt="img" style="zoom:50%;" />

<h4 id="（2）ksoftirqd内核线程"><a href="#（2）ksoftirqd内核线程" class="headerlink" title="（2）ksoftirqd内核线程"></a>（2）ksoftirqd内核线程</h4><p><a href="https://www.kerneltravel.net/blog/2020/ksoftirqd_ljr/">Linux内核网络中的软中断ksoftirqd</a></p>
<p>当执行到网卡通过硬件中断（IRQ）通知CPU，告诉它有数据来了，CPU会根据中断表，调用已经注册的中断函数，这个中断函数会调到驱动程序（NIC Driver）中相应的函数。驱动先禁用网卡的中断，表示驱动程序已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知CPU了，这样可以提高效率，避免CPU不停的被中断。</p>
<p>由于硬中断处理程序执行的过程中不能被中断，所以如果它执行时间过长，会导致CPU没法响应其它硬件的中断，于是内核引入软中断，这样可以将硬中断处理函数中耗时的部分移到软中断处理函数里面来慢慢处理。内核中的<code>ksoftirqd</code>进程专门负责软中断的处理，当它收到软中断后，就会调用相应软中断所对应的处理函数，网卡驱动模块抛出的软中断，<code>ksoftirqd</code>会调用网络模块的<code>net_rx_action</code>函数。</p>
<p>中断是一种异步的事件处理机制，用来提高系统的并发处理能力。中断事件发生，会触发执行中断处理程序，而中断处理程序被分为上半部和下半部这两个部分。上半部对应硬中断，用来快速处理中断；下半部对应软中断，用来异步处理上半部未完成的工作。Linux 中的软中断包括网络收发、定时、调度、RCU 锁等各种类型，我们可以查看 proc 文件系统中的 <code>/proc/softirqs</code>  ，观察软中断的运行情况。在 Linux 中，每个 CPU 都对应一个软中断内核线程，名字是 <code>ksoftirqd/CPU </code>编号。当软中断事件的频率过高时，内核线程也会因为 CPU 使用率过高而导致软中断处理不及时，进而引发网络收发延迟、调度缓慢等性能问题。</p>
<h4 id="（3）NAPI机制分析"><a href="#（3）NAPI机制分析" class="headerlink" title="（3）NAPI机制分析"></a>（3）NAPI机制分析</h4><h1 id="二、HTTP篇"><a href="#二、HTTP篇" class="headerlink" title="二、HTTP篇"></a>二、HTTP篇</h1><h2 id="2-1-HTTP-基本概念"><a href="#2-1-HTTP-基本概念" class="headerlink" title="2.1 HTTP 基本概念"></a>2.1 HTTP 基本概念</h2><blockquote>
<p>HTTP 是一个用于在<strong>服务器和服务器之间</strong>，或<strong>服务器和本地浏览器之间</strong>传输文字、图片、音频和视频等超文本数据的规范和约定。</p>
</blockquote>
<h3 id="1、HTTP是什么？"><a href="#1、HTTP是什么？" class="headerlink" title="1、HTTP是什么？"></a>1、HTTP是什么？</h3><p>HTTP是超文本传输协议，也就是<code>HyperText Transfer Protocol</code>。</p>
<p>「超文本」：文字、图片和视频等的混合体。其本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现出来的就是一个有文字、有画面的网页了。</p>
<h3 id="2、HTTP的常见状态码有哪些？"><a href="#2、HTTP的常见状态码有哪些？" class="headerlink" title="2、HTTP的常见状态码有哪些？"></a>2、HTTP的常见状态码有哪些？</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291014235.png" alt="HTTP常见状态码"></p>
<h3 id="3、HTTP的常见字段有哪些？"><a href="#3、HTTP的常见字段有哪些？" class="headerlink" title="3、HTTP的常见字段有哪些？"></a>3、HTTP的常见字段有哪些？</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291021674.png" alt="HTTP常见字段"></p>
<h2 id="2-2-Get-与-Post"><a href="#2-2-Get-与-Post" class="headerlink" title="2.2 Get 与 Post"></a>2.2 Get 与 Post</h2><p><strong>GET 的语义是从服务器获取指定的资源</strong>。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。GET 方法是安全、幂等、可被缓存的。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291431547.png" alt="GET 请求"></p>
<p><strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>。POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。POST 不安全，不幂等，（大部分实现）不可缓存。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291431269.png" alt="POST 请求"></p>
<h2 id="2-3-HTTP缓存技术"><a href="#2-3-HTTP缓存技术" class="headerlink" title="2.3 HTTP缓存技术"></a>2.3 HTTP缓存技术</h2><blockquote>
<p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p>
<p>强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存。决定是否使用缓存的主动性在于浏览器这边。基于两个HTTP响应头部字段实现：Cache-Control和Expires。</p>
<p>协商缓存指的是与服务端协商之后，通过协商结果来判断是否使用本地缓存。涉及304状态码。基于两种头部来实现，一种是请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段，另一种是请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段。注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p>
</blockquote>
<h3 id="1、强制缓存"><a href="#1、强制缓存" class="headerlink" title="1、强制缓存"></a>1、强制缓存</h3><p>下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291035054.png" alt="img"></p>
<p>强缓存利用下面两个HTTP响应头部字段实现：</p>
<ul>
<li><code>Cache-Control</code>， 是一个相对时间，优先级较高；</li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
<h3 id="2、协商缓存"><a href="#2、协商缓存" class="headerlink" title="2、协商缓存"></a>2、协商缓存</h3><p>当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 <code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</p>
<p>协商缓存的过程如下：</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png" alt="img" style="zoom:50%;" />

<p>协商缓存可以基于两种头部来实现。</p>
<p>第一种：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现，这两个字段的意思是：</p>
<ul>
<li>响应头部中的 <code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li>
<li>请求头部中的 <code>If-Modified-Since</code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有  If-Modified-Since，则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP  200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li>
</ul>
<p>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段，这两个字段的意思是：</p>
<ul>
<li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li>
<li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li>
</ul>
<p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291109906.png" alt="img"></p>
<p><strong>当使用 ETag 字段实现的协商缓存的过程：</strong></p>
<ul>
<li><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</p>
</li>
<li><p>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：</p>
<ul>
<li>如果没有过期，则直接使用本地缓存；</li>
<li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</li>
</ul>
</li>
<li><p>服务器再次收到请求后，</p>
<p>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：</p>
<ul>
<li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li>
<li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>
</ul>
</li>
<li><p>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</p>
</li>
</ul>
<h2 id="2-4-HTTP与HTTPS"><a href="#2-4-HTTP与HTTPS" class="headerlink" title="2.4 HTTP与HTTPS"></a>2.4 HTTP与HTTPS</h2><h3 id="1、HTTP-与-HTTPS-有哪些区别？"><a href="#1、HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="1、HTTP 与 HTTPS 有哪些区别？"></a>1、HTTP 与 HTTPS 有哪些区别？</h3><blockquote>
<ul>
<li>TTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li>两者的默认端口不一样，HTTP 默认端口号是 <code>80</code>，HTTPS 默认端口号是 <code>443</code>。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
</blockquote>
<h3 id="2、HTTPS-解决了-HTTP-的哪些问题？"><a href="#2、HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="2、HTTPS 解决了 HTTP 的哪些问题？"></a>2、HTTPS 解决了 HTTP 的哪些问题？</h3><blockquote>
<p>HTTP 存在三个风险：1）窃听风险；2）篡改风险；3）冒充风险。</p>
<p>HTTPS 通过在 HTTP 与 TCP 之间加入<code>SLL/TLS</code>协议，解决上述风险，具体实现如下：</p>
<p>1、<strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</p>
<p>2、<strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</p>
<p>3、将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</p>
</blockquote>
<p>HTTP 存在三个风险：<strong>1）窃听风险；2）篡改风险；3）冒充风险。</strong></p>
<p>HTTPS 通过在 HTTP 与 TCP 之间加入<code>SLL/TLS</code>协议，解决上述风险，具体实现如下：</p>
<blockquote>
<p>1、<strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291122854.png" alt="混合加密" style="zoom:80%;" />

<blockquote>
<ol>
<li><strong>对称加密 vs. 非对称加密：</strong></li>
</ol>
<ul>
<li><strong>对称加密：</strong> 在对称加密中，加密和解密使用相同的密钥。发送方和接收方必须共享同一个密钥，这种密钥的管理相对简单，但存在密钥分发和安全性的挑战。</li>
<li><strong>非对称加密：</strong> 非对称加密使用一对密钥，公钥和私钥。公钥用于加密数据，私钥用于解密数据。发送方可以使用接收方的公钥加密数据，只有接收方拥有相应的私钥才能解密数据。</li>
</ul>
<ol start="2">
<li><strong>哈希散列算法：</strong></li>
</ol>
<ul>
<li><strong>哈希散列算法不是加密算法：</strong> 哈希散列算法是一种单向函数，它将任意长度的输入转换为固定长度的输出，称为哈希值。哈希算法是不可逆的，即无法从哈希值还原出原始输入。因此，哈希散列算法不属于加密算法，而是用于数据完整性验证、数字签名等领域。</li>
</ul>
</blockquote>
<p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p>
<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」方式加密明文数据。</li>
</ul>
<p>采用「混合加密」的方式的原因：</p>
<ul>
<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>
</ul>
<blockquote>
<p>2、<strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291125568.png" alt="img"></p>
<p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。为了避免这种情况，计算机里会用<strong>非对称加密算法</strong>来解决，共有两个密钥：</p>
<ul>
<li>一个是公钥，这个是可以公开给所有人的；</li>
<li>一个是私钥，这个必须由本人管理，不可泄露。</li>
</ul>
<p>这两个密钥可以<strong>双向加解密</strong>的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。</p>
<p>流程的不同，意味着目的也不相同：</p>
<ul>
<li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li>
<li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li>
</ul>
<p>一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。</p>
<p>所以非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p>
<blockquote>
<p>3、将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</p>
</blockquote>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="数子证书工作流程" style="zoom: 80%;" />

<h3 id="3、HTTPS-是如何建立连接的？其间交互了什么？"><a href="#3、HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="3、HTTPS  是如何建立连接的？其间交互了什么？"></a>3、HTTPS  是如何建立连接的？其间交互了什么？</h3><p>SSL&#x2F;TLS协议基本流程：</p>
<ol>
<li><p>TLS 的「握手阶段」（根据不同的密钥算法，有不同的握手流程）</p>
<ul>
<li><p>客户端向服务器索要并验证服务器的公钥；</p>
</li>
<li><p>双方协商产生「会话秘钥」；</p>
</li>
</ul>
</li>
<li><p>通信阶段</p>
<ul>
<li>采用「会话秘钥」进行通信。</li>
</ul>
</li>
</ol>
<p>常见的密钥交换算法：<code>RSA</code>算法和<code>ECDHE</code>算法。</p>
<p>以<code>RSA</code>算法为例，展示TLS握手流程（<strong>四次握手</strong>）：</p>
<p>注意：<strong>服务器和客户端通过三个随机数（Client Random、Server Random、pre-master key），以及双方协商的加密算法，<em>各自</em>生成本次通信的「会话秘钥」</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405301058385.jpeg" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p>
<h3 id="4、HTTPS-一定安全可靠吗？"><a href="#4、HTTPS-一定安全可靠吗？" class="headerlink" title="4、HTTPS 一定安全可靠吗？"></a>4、HTTPS 一定安全可靠吗？</h3><h4 id="（1）HTTPS一定安全可靠吗，如果有假基站获取了转发全部信息的作用，这样是不是假基站就获取到了全部信息，从而造成信息泄露？"><a href="#（1）HTTPS一定安全可靠吗，如果有假基站获取了转发全部信息的作用，这样是不是假基站就获取到了全部信息，从而造成信息泄露？" class="headerlink" title="（1）HTTPS一定安全可靠吗，如果有假基站获取了转发全部信息的作用，这样是不是假基站就获取到了全部信息，从而造成信息泄露？"></a>（1）HTTPS一定安全可靠吗，如果有假基站获取了转发全部信息的作用，这样是不是假基站就获取到了全部信息，从而造成信息泄露？</h4><blockquote>
<p>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。</p>
</blockquote>
<p>这个问题的场景是这样的：客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.png" alt="img" style="zoom:50%;" />



<p>从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。那么中间人就可以解开浏览器发起的 HTTPS  请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS  请求和响应的数据。</p>
<p>但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291132705.png" alt="img"></p>
<p>所以，<strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p>
<h4 id="（2）为什么抓包工具能截取-HTTPS-数据？"><a href="#（2）为什么抓包工具能截取-HTTPS-数据？" class="headerlink" title="（2）为什么抓包工具能截取 HTTPS 数据？"></a>（2）为什么抓包工具能截取 HTTPS 数据？</h4><blockquote>
<p>抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，就会认为这个证书是有效的。</p>
</blockquote>
<p>很多抓包工具 之所以可以明文看到 HTTPS 数据，工作原理与中间人一致。</p>
<p>对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:</p>
<ol>
<li>中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；</li>
<li>中间人，作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；</li>
</ol>
<p>中间人要拿到私钥只能通过如下方式：</p>
<ol>
<li>去网站服务端拿到私钥；</li>
<li>去CA处拿域名签发私钥；</li>
<li>自己签发证书，切要被浏览器信任；</li>
</ol>
<p>不用解释，抓包工具只能使用第三种方式取得中间人的身份。使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。</p>
<p>抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。</p>
<h4 id="（3）如何避免被中间人抓取数据？"><a href="#（3）如何避免被中间人抓取数据？" class="headerlink" title="（3）如何避免被中间人抓取数据？"></a>（3）如何避免被中间人抓取数据？</h4><blockquote>
<p>1、不要点击任务证书非法的网站；</p>
<p>2、通过 HTTPS 双向认证来避免，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</p>
</blockquote>
<p>我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样 HTTPS 数据就不会被中间人截取到了。</p>
<p>当然，我们还可以通过 <strong>HTTPS 双向认证</strong>来避免这种问题。一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。<strong>如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291145819.png" alt="img"></p>
<h2 id="2-5-HTTP-1-1、HTTP-2、HTPP-3的演变"><a href="#2-5-HTTP-1-1、HTTP-2、HTPP-3的演变" class="headerlink" title="2.5 HTTP&#x2F;1.1、HTTP&#x2F;2、HTPP&#x2F;3的演变"></a>2.5 HTTP&#x2F;1.1、HTTP&#x2F;2、HTPP&#x2F;3的演变</h2><h3 id="1、HTTP-1-1"><a href="#1、HTTP-1-1" class="headerlink" title="1、HTTP&#x2F;1.1"></a>1、HTTP&#x2F;1.1</h3><blockquote>
<p>优点：</p>
<ol>
<li>简单</li>
<li>灵活和易于拓展</li>
<li>应用广泛和跨平台</li>
</ol>
<p>缺点：</p>
<ol>
<li>无状态</li>
<li>明文传输</li>
<li>不安全</li>
</ol>
<p>性能：</p>
<ol>
<li>长连接</li>
<li>管道网络传输</li>
</ol>
</blockquote>
<p><strong>优点：</strong></p>
<ol>
<li><p>简单</p>
<p>基本的报文格式是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式。</p>
</li>
<li><p>灵活和易于拓展</p>
<p>HTTP 协议里的各类请求方法、URI&#x2F;URL、状态码和头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</p>
<p>同时 HTTP 由于是工作在应用层（ <code>OSI</code> 第七层），其<strong>下层可以随意变化</strong>，比如：</p>
<ul>
<li>HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL&#x2F;TLS 安全传输层；</li>
<li>HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 传输协议使用的是 TCP 协议，而到了 HTTP&#x2F;3.0 传输协议改用了 UDP 协议。</li>
</ul>
</li>
<li><p>应用广泛和跨平台</p>
</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><p>无状态</p>
<p>HTTP协议本身是无状态的，也就是说每个请求之间是相互独立的，服务器不会在不同请求之间保留任何关于客户端请求的状态信息。这意味着<strong>每个HTTP请求都是独立的，服务器不会记住之前的请求或会话信息。</strong></p>
<p>对于无状态的问题，解法方案有很多种，其中比较简单的方式用 <strong>Cookie</strong> 技术。</p>
<p><code>Cookie</code> 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291443907.png" alt="Cookie 技术"></p>
</li>
<li><p>明文传输</p>
</li>
<li><p>不安全</p>
</li>
</ol>
<p><strong>性能：</strong></p>
<ol>
<li><p>长连接：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。如果某个 HTTP 长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291444931.png" alt="短连接与长连接"></p>
</li>
<li><p>管道网络传输：在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong>但是<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。所以，<strong>HTTP&#x2F;1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291445813.png" alt="管道网络传输"></p>
</li>
</ol>
<blockquote>
<p><strong>注意</strong></p>
<p>实际上 HTTP&#x2F;1.1 管道化技术不是默认开启，而且浏览器基本都没有支持，所以<strong>后面所有文章讨论 HTTP&#x2F;1.1 都是建立在没有使用管道化的前提</strong>。大家知道有这个功能，但是没有被使用就行了。</p>
</blockquote>
<ol start="3">
<li><p>队头阻塞：当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291447597.png" alt="队头阻塞"></p>
</li>
</ol>
<h3 id="2、HTTP-2"><a href="#2、HTTP-2" class="headerlink" title="2、HTTP&#x2F;2"></a>2、HTTP&#x2F;2</h3><blockquote>
<p>HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p>
<ol>
<li>头部压缩</li>
<li>二进制格式</li>
<li>并发传输</li>
<li>服务器主动推送资源</li>
</ol>
<p>但其缺陷在于：HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</p>
</blockquote>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/25-HTTP2.png" alt="HTT/1 ~ HTTP/2" style="zoom:80%;" />

<ol>
<li><p>头部压缩</p>
<p>HTTP&#x2F;2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p>
<p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p>
</li>
<li><p>二进制格式</p>
<p>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291449629.png" alt="HTTP/1 与 HTTP/2 "></p>
<p>比如状态码 200 ，在 HTTP&#x2F;1.1 是用 ‘2’’0’’0’ 三个字符来表示（二进制：00110010 00110000 00110000），共用了 3 个字节，如下图</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291450660.png" alt="img"></p>
<p>在 HTTP&#x2F;2 对于状态码 200 的二进制编码是 10001000，只用了 1 字节就能表示，相比于 HTTP&#x2F;1.1 节省了 2 个字节，如下图：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291450575.png" alt="img"></p>
</li>
<li><p>并发传输</p>
<p>引入了 Stream 概念，多个 Stream 复用在一条 TCP 连接。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291452845.png" alt="img"></p>
<p>1 个 TCP 连接包含多个 Stream，1个Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP&#x2F;1  中的请求或响应，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP&#x2F;2  最小单位，以二进制压缩格式存放 HTTP&#x2F;1 中的内容（头部和包体）。</p>
<p><strong>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP  消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应</strong>。</p>
<p>比如下图，服务端<strong>并行交错地</strong>发送了两个响应： Stream 1 和 Stream 3，这两个 Stream 都是跑在一个 TCP 连接上，客户端收到后，会根据相同的 Stream ID 有序组装成 HTTP 消息。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291453175.jpeg" alt="img"></p>
</li>
<li><p>服务器主动推送资源</p>
<p>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p>
<p>比如下图，Stream 1 是客户端向服务端请求的资源，属于客户端建立的 Stream，所以该 Stream 的 ID 是奇数（数字  1）；Stream 2 和 4 都是服务端主动向客户端推送的资源，属于服务端建立的 Stream，所以这两个 Stream 的 ID  是偶数（数字 2 和 4）。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291453212.png" alt="img"></p>
<p>HTTP&#x2F;2的仍旧存在“队头阻塞”问题，但是问题不是在HTTP层面，而是在TCP层面。</p>
<p><strong>HTTP&#x2F;2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP  层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1  个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2  应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291455599.jpeg" alt="img" style="zoom:67%;" />

<p>举个例子，如下图：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291455330.gif" alt="img"></p>
</li>
</ol>
<h3 id="3、HTTP-3"><a href="#3、HTTP-3" class="headerlink" title="3、HTTP&#x2F;3"></a>3、HTTP&#x2F;3</h3><blockquote>
<p>为了解决HTTP&#x2F;2的队头阻塞问题，HTTP&#x2F;3将下层的TCP协议修改成了UDP协议。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291456442.jpeg" alt="HTTP/1 ~ HTTP/3"></p>
<p>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP&#x2F;2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p>
<p>QUIC 有以下 3 个特点。</p>
<ul>
<li>无队头阻塞</li>
<li>更快的连接建立</li>
<li>连接迁移</li>
</ul>
<p>1、无队头阻塞</p>
<p>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p>
<p>QUIC 有自己的一套机制可以保证传输的可靠性的。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>，这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/quic%E6%97%A0%E9%98%BB%E5%A1%9E.jpeg" alt="img" style="zoom: 67%;" />

<p>2、更快的连接建立</p>
<p>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p>
<p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。此外，HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS&#x2F;1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.png" alt="TCP HTTPS（TLS/1.3） 和 QUIC HTTPS "></p>
<p>3、连接迁移</p>
<p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309231026577.png" alt="TCP 四元组" style="zoom:50%;" />

<p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p>
<p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p>
<p><strong>所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</strong></p>
<p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而  QUIC 是基于 UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。HTTP&#x2F;3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。</p>
<h2 id="2-6-HTTP-1-1-该如何优化？"><a href="#2-6-HTTP-1-1-该如何优化？" class="headerlink" title="2.6 HTTP&#x2F;1.1 该如何优化？"></a>2.6 HTTP&#x2F;1.1 该如何优化？</h2><blockquote>
<p><strong>HTTP&#x2F;1.1 如何优化&#x2F;大量网络请求如何优化？</strong></p>
<p>第一个思路是，通过缓存技术来避免具有重复性的 HTTP 请求。客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带资源的 304 响应，告诉客户端缓存的响应仍然有效。</p>
<p>第二个思路是，减少 HTTP 请求的次数，有以下方法：</p>
<ol>
<li>将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数；</li>
<li>将多个小资源合并成一个大资源再传输，减少 HTTP 请求次数以及头部的重复传输，以及减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗；</li>
<li>按需访问资源，只访问当前用户看得到&#x2F;用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数。</li>
</ol>
<p>第三个思路是，通过压缩响应资源，降低传输资源的大小，从而提高传输效率，所以应当选择更优秀的压缩算法。</p>
</blockquote>
<ol>
<li><p>对于一些具有重复性的HTTP请求，可以考虑将这对「请求-响应」的数据<strong>缓存在本地</strong>，这样在下一次就可以直接读取本地的数据，不必再通过网络获取服务器响应了。</p>
<ul>
<li>具体来说，客户端会把第一次请求以及响应的数据以key-value的形式保存在本地磁盘上，其中请求的URL为key，响应为数据。当后续发起相同请求时，就可以先在本地磁盘上进行查询和读取。</li>
<li>客户端在重新发送请求时，会在请求的<code>Etag</code>头部带上第一次请求的响应头部中的摘要，作为唯一标识响应的资源。服务器收到该请求时，会将本地资源的摘要与请求中的摘要进行对比：<ul>
<li>若相同，则返回<code>304</code>状态码，告诉客户端该缓存仍有效；</li>
<li>若不同，则返回最新的资源。</li>
</ul>
</li>
</ul>
</li>
<li><p>减少HTTP请求可以从以下三方面入手：</p>
<ol>
<li>减少重定向请求次数。<ul>
<li>重定向请求是指当服务器的某个资源从url1转移到url2后，对于不知情的客户端来说，它将继续请求url1，这时服务器将返回<code>302</code>状态码和<code>Location</code>头部，告诉客户端资源已经转移到url2了，于是客户端再重新发送url2请求以获取资源。</li>
<li>重定向请求越多，客户端发起的HTTP请求就越多；此外，若通过「客户端-代理服务器-服务器」来传送资源，客户端与服务器之间需要进行2次消息传递。以上做法无疑将大大降低网络性能。</li>
<li>因此，如果<strong>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了</strong>。</li>
</ul>
</li>
<li>合并请求。<ul>
<li>将多个访问小文件的请求合并成一个大的请求。这样虽然传输的总资源大小不变，但减少了重复发送的HTTP头部。</li>
<li>此外，由于HTTP&#x2F;1.1是请求响应模型，为了防止单个请求的阻塞，一般浏览器会同时发送5-6个请求，每个请求都是不同的TCP连接。若能够合并请求，将减少TCP连接的数量，并省去TCP握手和慢启动过程耗费的时间。</li>
</ul>
</li>
<li>延迟发送请求。<ul>
<li>对于资源进行<strong>按需获取</strong>。比如请求网页时，没必要一次性获取全部资源，而是只获取用户所看到的页面资源，当用户向下滑动页面时再向服务器接着获取，从而达到延迟发送请求的效果。</li>
</ul>
</li>
</ol>
</li>
<li><p>通过压缩的方式减少HTTP响应的数据大小。</p>
<ul>
<li><p>无损压缩。</p>
<ul>
<li>指资源经过压缩后信息不被破坏，还能完全恢复到压缩前的原样。适用于文本文件、程序可执行文件和程序源代码等。</li>
<li>在请求字段中通过<code>Accept-Encoding</code>告知服务器客户端支持的压缩算法；在响应头部中通过<code>Content-Encoding</code>字段告诉客户端服务器采用的压缩算法。</li>
<li>常见算法：<code>gzip</code>、<code>Brotli</code></li>
</ul>
</li>
<li><p>有损压缩。</p>
<ul>
<li><p>将次要的数据合并，牺牲一些质量来减少数据量、提高压缩比。适用于多媒体数据，如音频、视频和图片等。</p>
</li>
<li><p>在请求字段中通过<code>Accept</code>字段里的「 q 质量因子」，告诉服务器期望的资源质量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept: audio/*; q=0.2, audio/basic</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="2-7-HTTPS-RSA-握手解析"><a href="#2-7-HTTPS-RSA-握手解析" class="headerlink" title="2.7 HTTPS RSA 握手解析"></a>2.7 HTTPS RSA 握手解析</h2><blockquote>
<p>传统的TLS握手采用RSA算法实现密钥交换。在将TLS证书部署服务器端时，证书文件其实就是服务器端的公钥，会在TLS握手阶段传递给客户端。而服务器端的私钥则一直留在服务器端，并确保其不被窃取。</p>
<p>在RSA密钥协商算法中，客户端会生成随机密钥，并使用服务器端的公钥加密后传给服务器端。根据非对称加密算法，公钥加密的信息仅能通过similarity解密，这样服务器端解密后，双方就得到了相同的密钥，再用这个密钥来加密应用信息。</p>
<p><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。为了解决这个问题，后面就出现了 ECDHE 密钥协商算法。</p>
<p>包含四次握手过程：</p>
<ul>
<li><strong>第一次握手</strong></li>
<li>客户端发送「<strong>Client Hello</strong>」，包含<ul>
<li>1）LS版本号；</li>
<li>2）支持的密码套件列表；</li>
<li>3）生成的随机数<strong>Client Random</strong>。</li>
</ul>
</li>
<li><strong>第二次握手</strong></li>
<li>服务器端返回「<strong>Server Hello</strong>」，包含<ul>
<li>1）确认的TLS版本号；</li>
<li>2）从密码套件列表中选择的密码套件；</li>
<li>3）生成的随机数<strong>Server Random</strong>。</li>
</ul>
</li>
<li>服务器端发送「<strong>Server Certificate</strong>」，包含数字证书；</li>
<li>服务器端发送「<strong>Server Hello Done</strong>」，表明自己本次发送完毕。</li>
<li><strong>第三次握手</strong></li>
<li>客户端发送「<strong>Client Key Exchange</strong>」；</li>
<li>双方根据已经得到的三个随机数（<strong>Client Random、Server Random、pre-master</strong>），生成<strong>会话密钥（Master Secret）</strong>；</li>
<li>客户端发送「<strong>Change Cipher Spec</strong>」，告诉服务器端开始使用加密方式发送消息；</li>
<li>客户端再发送「<strong>Encrypted Handshake Message（Finishd）</strong>」；</li>
<li><strong>第四次握手</strong>：</li>
<li>服务器也是同样的操作，发送「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」；如果双方都验证加密和解密没问题，那么握手正式完成。</li>
</ul>
</blockquote>
<p><code>RSA</code>算法需要经过四次握手，也就是<code>2</code>个RTT的时延。由于HTTPS是应用层协议，因此需要先完成TCP连接建立，再完成TLS握手过程，才能建立通信安全的连接。</p>
<ul>
<li><p><strong>第一次握手</strong></p>
<ul>
<li>客户端发送「<strong>Client Hello</strong>」，包含<ul>
<li>1）LS版本号；</li>
<li>2）支持的密码套件列表；</li>
<li>3）生成的随机数<strong>Client Random</strong>；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>第二次握手</strong></p>
<ul>
<li><p>服务器端返回「<strong>Server Hello</strong>」，包含</p>
<ul>
<li>1）确认的TLS版本号；</li>
<li>2）从密码套件列表中选择的密码套件；</li>
<li>3）生成的随机数<strong>Server Random</strong>；</li>
</ul>
</li>
<li><p>服务器端发送「<strong>Server Certificate</strong>」，包含数字证书</p>
<ul>
<li><p>数字证书中包含以下信息：公钥、持有者信息、证书认证机构（CA）的信息、CA 对这份文件的数字签名及使用的算法、证书有效期，以及一些其他的额外信息；</p>
</li>
<li><p>证书由CA（Certificate Authority，证书认证机构）签名，签发和认证流程如下，主要涉及1）Hash算法；2）CA私钥加密，CA公钥解密：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405301235768.png" alt="img"></p>
</li>
</ul>
<blockquote>
<p><strong>CA 签发证书</strong>的过程，如上图左边部分：</p>
<ul>
<li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li>
<li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li>
<li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li>
</ul>
<p><strong>客户端校验服务端的数字证书</strong>的过程，如上图右边部分：</p>
<ul>
<li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li>
<li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li>
<li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li>
</ul>
</blockquote>
</li>
<li><p>服务器端发送「<strong>Server Hello Done</strong>」，表明自己本次发送完毕</p>
</li>
</ul>
</li>
<li><p><strong>第三次握手</strong></p>
<ul>
<li>客户端发送「<strong>Client Key Exchange</strong>」，包含新生成的随机数<strong>pre-master</strong>，并由服务器的 RSA 公钥加密；</li>
<li>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (<strong>pre-master</strong>)；</li>
<li>双方根据已经得到的三个随机数（<strong>Client Random、Server Random、pre-master</strong>），生成<strong>会话密钥（Master Secret）</strong>，它是对称密钥，用于对后续的 HTTP 请求&#x2F;响应的数据加解密；</li>
<li>客户端发送「<strong>Change Cipher Spec</strong>」，告诉服务器端开始使用加密方式发送消息；</li>
<li>客户端再发送「<strong>Encrypted Handshake Message（Finishd）</strong>」消息，把之前所有发送的数据做个<strong>摘要</strong>，再用会话密钥（<strong>Master Secret</strong>）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。</li>
</ul>
</li>
<li><p><strong>第四次握手</strong></p>
<ul>
<li>服务器也是同样的操作，发送「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息；</li>
<li>如果双方都验证加密和解密没问题，那么握手正式完成。</li>
</ul>
</li>
</ul>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/tls%E6%8F%A1%E6%89%8B.png" alt="img" style="zoom: 67%;" />

<h2 id="2-8-HTTPS-ECDHE-握手解析"><a href="#2-8-HTTPS-ECDHE-握手解析" class="headerlink" title="2.8 HTTPS ECDHE 握手解析"></a>2.8 HTTPS ECDHE 握手解析</h2><blockquote>
<p>算法演进：DH -&gt; DHE -&gt; DCDHE</p>
</blockquote>
<p>（1）DH算法</p>
<p>核心数学思想：离散对数。离散对数的概念如下图：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405301449682.png" alt="img" style="zoom:67%;" />

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405301537291.png" alt="image-20240530153742715"></p>
<p>四次握手过程：</p>
<ul>
<li><strong>第一次握手</strong><ul>
<li>客户端发送「<strong>Client Hello</strong>」，包含<ul>
<li>1）LS版本号；</li>
<li>2）支持的密码套件列表；</li>
<li>3）生成的随机数<strong>Client Random</strong>；</li>
</ul>
</li>
</ul>
</li>
<li><strong>第二次握手</strong><ul>
<li>服务器端返回「<strong>Server Hello</strong>」，包含<ul>
<li>1）确认的TLS版本号；</li>
<li>2）从密码套件列表中选择的密码套件；</li>
<li>3）生成的随机数<strong>Server Random</strong>；</li>
</ul>
</li>
<li>服务器端发送「<strong>Server Certificate</strong>」，包含数字证书</li>
<li>服务器端发送「<strong>Server Hello Done</strong>」，包含<ul>
<li>选择<strong>椭圆曲线</strong>，选好了椭圆曲线相当于椭圆曲线<strong>基点 G</strong> 也定好了，这些都会公开给客户端；</li>
<li>生成随机数作为服务端椭圆曲线的私钥，保留到本地；</li>
<li>根据基点 G 和私钥计算出<strong>服务端的椭圆曲线公钥</strong>，这个会公开给客户端。</li>
</ul>
</li>
<li>服务器端发送「<strong>Server Key Exchange</strong>」，表明自己本次发送完毕</li>
</ul>
</li>
<li><strong>第三次握手</strong><ul>
<li>客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成<strong>客户端的椭圆曲线公钥；</strong></li>
<li>客户端发送「<strong>Client Key Exchange</strong>」；</li>
<li>双方根据已经得到的<strong>对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G</strong>，计算出点(x, y)；<strong>最终的会话密钥，就是用「客户端随机数 + 服务端随机数 +  x 」三个材料生成的</strong>。</li>
<li>客户端发送「<strong>Change Cipher Spec</strong>」，告诉服务器端开始使用加密方式发送消息；</li>
<li>客户端再发送「<strong>Encrypted Handshake Message（Finishd）</strong>」消息，把之前所有发送的数据做个<strong>摘要</strong>，再用会话密钥（<strong>Master Secret</strong>）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。</li>
</ul>
</li>
<li><strong>第四次握手</strong><ul>
<li>服务器也是同样的操作，发送「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息；</li>
<li>如果双方都验证加密和解密没问题，那么握手正式完成。</li>
</ul>
</li>
</ul>
<h2 id="2-9-HTTPS-如何优化？"><a href="#2-9-HTTPS-如何优化？" class="headerlink" title="2.9 HTTPS 如何优化？"></a>2.9 HTTPS 如何优化？</h2><blockquote>
<p>产生性能消耗的两个环节：</p>
<ul>
<li>第一个环节， TLS 协议握手过程；</li>
<li>第二个环节，握手后的对称加密报文传输。</li>
</ul>
<p>主要针对第一个环节进行优化，考虑以下方面：</p>
<ul>
<li><strong>硬件优化</strong><ul>
<li>由于HTTPS 协议是计算密集型，而不是 I&#x2F;O 密集型，因此对CPU性能进行提升，选择可以支持 AES-NI 特性的 CPU；</li>
</ul>
</li>
<li><strong>协议优化</strong><ul>
<li>用ECDHE算法替代RSA算法；</li>
<li>椭圆曲线尽量选择x25519曲线；</li>
<li>对称加密算法方面，如果对安全性需求不是特别高，可以选用 AES_128_GCM，由于密钥长度较短，比 AES_256_GCM 速度更快；</li>
</ul>
</li>
<li><strong>证书优化</strong><ul>
<li><strong>证书传输</strong>方面，选择椭圆曲线（ECDSA）证书而不是 RSA 证书，因为在相同安全强度下， ECC 密钥长度比 RSA 短的多；</li>
<li><strong>证书验证</strong>方面，采用OSCP Stapling；</li>
</ul>
</li>
<li><strong>会话复用：</strong>把首次 TLS 握手协商的对称加密密钥缓存起来，待下次需要建立 HTTPS 连接时，直接「复用」这个密钥<ul>
<li><strong>Session ID</strong>：客户端和服务器首次  TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识，Session ID 和会话密钥相当于 key-value 的关系。</li>
<li><strong>Session Ticket</strong>：服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端，类似于 HTTP 的 Cookie。客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信。</li>
</ul>
</li>
</ul>
</blockquote>
<p>TLS 协议握手过程的性能消耗：</p>
<ul>
<li>对于 ECDHE 密钥协商算法，握手过程中会客户端和服务端都需要临时生成椭圆曲线公私钥；</li>
<li>客户端验证证书时，会访问 CA 获取 CRL 或者 OCSP，目的是验证服务器的证书是否有被吊销；</li>
<li>双方计算 Pre-Master，也就是对称加密密钥；</li>
</ul>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/tls%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97.png" alt="img" style="zoom:67%;" />

<h1 id="三、TCP篇"><a href="#三、TCP篇" class="headerlink" title="三、TCP篇"></a>三、TCP篇</h1><h2 id="3-1-TCP头格式"><a href="#3-1-TCP头格式" class="headerlink" title="3.1 TCP头格式"></a>3.1 TCP头格式</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101258417.png" alt="TCP 头格式" style="zoom:50%;" />

<p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p>
<p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p>
<p><strong>控制位：</strong></p>
<ul>
<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li>
</ul>
<h2 id="3-2-什么是-TCP-？"><a href="#3-2-什么是-TCP-？" class="headerlink" title="3.2 什么是 TCP ？"></a>3.2 什么是 TCP ？</h2><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p>
<ul>
<li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP  报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP  报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li>
</ul>
<h2 id="3-3-如何唯一确定一个TCP连接？"><a href="#3-3-如何唯一确定一个TCP连接？" class="headerlink" title="3.3 如何唯一确定一个TCP连接？"></a>3.3 如何唯一确定一个TCP连接？</h2><p>通过TCP四元组确定：源地址、源端口、目的地址和目的端口。</p>
<blockquote>
<p>有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？</p>
</blockquote>
<p>服务端通常固定在某个本地端口上监听，等待客户端的连接请求。因此，客户端 IP 和端口是可变的，其理论值计算公式如下:</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230436594.png" alt="img" style="zoom: 67%;" />

<p>对 IPv4，客户端的 IP 数最多为 <code>2</code> 的 <code>32</code> 次方，客户端的端口数最多为 <code>2</code> 的 <code>16</code> 次方，也就是服务端单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方。</p>
<p>当然，服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：</p>
<ul>
<li>文件描述符限制，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：<ul>
<li><strong>系统级</strong>：当前系统可打开的最大数量，通过 <code>cat /proc/sys/fs/file-max</code> 查看；</li>
<li><strong>用户级</strong>：指定用户可打开的最大数量，通过 <code>cat /etc/security/limits.conf</code> 查看；</li>
<li><strong>进程级</strong>：单个进程可打开的最大数量，通过 <code>cat /proc/sys/fs/nr_open</code> 查看；</li>
</ul>
</li>
<li><strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。</li>
</ul>
<h2 id="3-4-TCP和UDP的区别，分别的应用场景？"><a href="#3-4-TCP和UDP的区别，分别的应用场景？" class="headerlink" title="3.4 TCP和UDP的区别，分别的应用场景？"></a>3.4 TCP和UDP的区别，分别的应用场景？</h2><h3 id="1、TCP-和-UDP-区别"><a href="#1、TCP-和-UDP-区别" class="headerlink" title="1、TCP 和 UDP 区别"></a>1、TCP 和 UDP 区别</h3><p><em><strong>1. 连接</strong></em></p>
<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p><em><strong>2. 服务对象</strong></em></p>
<ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<p><em><strong>3. 可靠性</strong></em></p>
<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP 协议实现可靠传输？</a></li>
</ul>
<p><em><strong>4. 拥塞控制、流量控制</strong></em></p>
<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<p><em><strong>5. 首部开销</strong></em></p>
<ul>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
<p><em><strong>6. 传输方式</strong></em></p>
<ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
<p><em><strong>7. 分片不同</strong></em></p>
<ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>
<h3 id="2、TCP-和-UDP-应用场景"><a href="#2、TCP-和-UDP-应用场景" class="headerlink" title="2、TCP 和 UDP 应用场景"></a>2、TCP 和 UDP 应用场景</h3><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<ul>
<li><code>FTP</code> 文件传输；</li>
<li><code>HTTP</code> &#x2F; <code>HTTPS</code>；</li>
</ul>
<p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li>
<li>视频、音频等多媒体通信；</li>
<li>广播通信；</li>
</ul>
<blockquote>
<p>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</p>
</blockquote>
<p>原因是 TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p>
<blockquote>
<p>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</p>
</blockquote>
<p>先说说 TCP 是如何计算负载数据长度：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230445811.png" alt="img" style="zoom:50%;" />

<p>其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。</p>
<p>大家这时就奇怪了问：“UDP 也是基于 IP 层的呀，那 UDP 的数据长度也可以通过这个公式计算呀？ 为何还要有「包长度」呢？”</p>
<p>这么一问，确实感觉 UDP 的「包长度」是冗余的。</p>
<p>我查阅了很多资料，我觉得有两个比较靠谱的说法：</p>
<ul>
<li>第一种说法：因为为了网络设备硬件设计和处理方便，首部长度需要是 <code>4</code> 字节的整数倍。如果去掉 UDP 的「包长度」字段，那 UDP 首部长度就不是 <code>4</code> 字节的整数倍了，所以我觉得这可能是为了补全 UDP 首部长度是  <code>4</code> 字节的整数倍，才补充了「包长度」字段。</li>
<li>第二种说法：如今的 UDP 协议是基于 IP 协议发展的，而当年可能并非如此，依赖的可能是别的不提供自身报文长度或首部长度的网络层协议，因此 UDP 报文首部需要有长度字段以供计算。</li>
</ul>
<h2 id="3-5-三次握手相关"><a href="#3-5-三次握手相关" class="headerlink" title="3.5 三次握手相关"></a>3.5 三次握手相关</h2><h3 id="1、详细说明三次握手"><a href="#1、详细说明三次握手" class="headerlink" title="1、详细说明三次握手"></a>1、详细说明三次握手</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手" style="zoom:50%;" />

<ol>
<li>服务端主动监听某个端口，处于 <code>LISTEN</code> 状态，等待客户端的连接请求；</li>
<li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态；</li>
<li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态；</li>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED</code> 状态；</li>
<li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li>
</ol>
<blockquote>
<p><strong>TIP：客户端发送三次握手（ack 报文）后就可以发送数据了，而被动方此时还是 syn_received 状态，如果 ack 丢了，那客户端发的数据是不是也白白浪费了？</strong></p>
<p>不是的，即使服务端还是在 syn_received 状态，收到了客户端发送的数据，还是可以建立连接的，并且还可以正常收到这个数据包。这是因为数据报文中是有 ack 标识位，也有确认号，这个确认号就是确认收到了第二次握手。如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%9B%B8%E5%90%8Cack.png" alt="img"></p>
<p>所以，服务端收到这个数据报文，是可以正常建立连接的，然后就可以正常接收这个数据包了。</p>
</blockquote>
<h3 id="2、为什么是三次握手？不是两次、四次？"><a href="#2、为什么是三次握手？不是两次、四次？" class="headerlink" title="2、为什么是三次握手？不是两次、四次？"></a>2、为什么是三次握手？不是两次、四次？</h3><blockquote>
<p>不使用「两次握手」和「四次握手」的原因：</p>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
<p>从以下两个原因进行分析：</p>
<p>原因一：避免历史连接，造成资源浪费；</p>
<p>原因二：同步双方初始序列号。</p>
</blockquote>
<p><strong>（1）原因一：避免历史连接，造成资源浪费</strong></p>
<p>防止已经失效的连接请求报文段突然又传到服务端，因而产生错误。</p>
<p>这种情况是：<strong>客户端发出的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到下一个连接释放以后的某个时间才到达服务器端。</strong>当服务器端收到此失效报文后，会误认为是客户端发出的一个新连接请求，于是客户端又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要服务器端发出确认报文就会认为新的连接已经建立了，但此时客户端并没有发出建立连接的请求，因此不会向服务器端发送数据。服务器端没有收到数据就会一直等待，这样就会白白浪费掉很多资源。</p>
<blockquote>
<p><strong>TIP：如果服务端在收到 RST 报文之前，先收到了「新 SYN 报文」，也就是服务端收到客户端报文的顺序是：「旧 SYN 报文」-&gt;「新 SYN 报文」，此时会发生什么?</strong></p>
<p>当服务端第一次收到 SYN 报文，也就是收到 「旧 SYN 报文」时，就会回复 <code>SYN + ACK</code> 报文给客户端，此报文中的确认号是 91（90+1）。</p>
<p>然后这时再收到「新 SYN 报文」时，就会回 <a href="https://xiaolincoding.com/network/3_tcp/challenge_ack.html">Challenge Ack</a>报文给客户端，<strong>这个 ack 报文并不是确认收到「新 SYN 报文」的，而是上一次的 ack 确认号</strong>，也就是91（90+1）。所以客户端收到此 ACK 报文时，发现自己期望收到的确认号应该是 101，而不是 91，于是就会回 RST 报文。</p>
</blockquote>
<p><strong>（2）原因二：同步双方初始序列号</strong></p>
<p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li>
</ul>
<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p>
<p>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<h3 id="3、为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#3、为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="3、为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>3、为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h3><blockquote>
<p>主要原因有两个方面：</p>
<ul>
<li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li>
<li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收。</li>
</ul>
</blockquote>
<p><strong>详述方面一：为了防止历史报文被下一个相同四元组的连接接收</strong></p>
<p>如果每次建立连接客户端和服务端的初始化序列号都「不一样」，就有大概率因为历史报文的序列号「不在」对方接收窗口，从而很大程度上避免了历史报文，相反，如果每次建立连接客户端和服务端的初始化序列号都「一样」，就有大概率遇到历史报文的序列号刚「好在」对方的接收窗口内，从而导致历史报文被新连接成功接收。</p>
<p>所以，每次初始化序列号不一样很大程度上能够避免历史报文被下一个相同四元组的连接接收，注意是很大程度上，并不是完全避免了，<strong>因为序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据</strong>，所以需要用时间戳的机制来判断历史报文。</p>
<h3 id="4、初始序列号-ISN-是如何随机产生的？"><a href="#4、初始序列号-ISN-是如何随机产生的？" class="headerlink" title="4、初始序列号 ISN 是如何随机产生的？"></a>4、初始序列号 ISN 是如何随机产生的？</h3><p>起始 <code>ISN</code> 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时。</p>
<p>RFC793 提到初始化序列号 ISN 随机生成算法：ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)。</p>
<ul>
<li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li>
<li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li>
</ul>
<p>可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。</p>
<h3 id="5、既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#5、既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="5、既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>5、既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h3><blockquote>
<p>如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，此时，<strong>如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP  层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 +  数据）」。</p>
<p>所以，为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。经过 TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片，大大增加了重传的效率。</p>
</blockquote>
<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230633447.png" alt="MTU 与 MSS" style="zoom: 67%;" />

<ul>
<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li>
<li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li>
</ul>
<p>如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，当 IP 层有一个超过 <code>MTU</code> 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上一层 TCP 传输层。</p>
<p>此时，<strong>如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP  层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 +  数据）」。</p>
<p>因此，可以得知由 IP 层进行分片传输，是非常没有效率的。</p>
<p>所以，为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230628926.png" alt="握手阶段协商 MSS"></p>
<p>经过 TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片，大大增加了重传的效率。</p>
<h3 id="6、第一次握手丢失了，会发生什么？"><a href="#6、第一次握手丢失了，会发生什么？" class="headerlink" title="6、第一次握手丢失了，会发生什么？"></a>6、第一次握手丢失了，会发生什么？</h3><blockquote>
<p>当第一次握手丢失了（SYN 丢失），客户端会重传 SYN 报文。</p>
<p>若重传 SYN 报文达到最大重传次数，还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</p>
</blockquote>
<p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 <code>SYN_SENT</code> 状态。</p>
<p>若第一次握手丢失，导致客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</p>
<p>根据不同内核的设定，超时时间也有所不同。当客户端在超时时间后依旧没收到服务端的 SYN-ACK 报文时，客户端就会重发 SYN 报文N次，在 Linux 里，客户端的 SYN 报文最大重传次数N由 <code>tcp_syn_retries</code>内核参数控制，这个参数是可以自定义的，默认值一般是 5。</p>
<p>若重发N次后还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</p>
<h3 id="7、第二次握手丢失了，会发生什么？"><a href="#7、第二次握手丢失了，会发生什么？" class="headerlink" title="7、第二次握手丢失了，会发生什么？"></a>7、第二次握手丢失了，会发生什么？</h3><blockquote>
<p>当第二次握手丢失了（SYN, ACK 报文丢失），客户端和服务端都会重传：</p>
<ul>
<li>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 <code>tcp_syn_retries</code>内核参数决定；</li>
<li>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定。</li>
</ul>
<p>当客户端超时重传 SYN 报文达到最大重传次数，再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</p>
<p>同理，当服务端超时重传 SYN-ACK 报文达到最大重传次数，再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。</p>
</blockquote>
<p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 <code>SYN_RCVD</code> 状态。</p>
<p>第二次握手的 <code>SYN-ACK</code> 报文其实有两个目的 ：</p>
<ul>
<li>第二次握手里的 ACK， 是对第一次握手的确认报文；</li>
<li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</li>
</ul>
<p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。</p>
<p>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p>
<h3 id="8、第三次握手丢失了，会发生什么？"><a href="#8、第三次握手丢失了，会发生什么？" class="headerlink" title="8、第三次握手丢失了，会发生什么？"></a>8、第三次握手丢失了，会发生什么？</h3><blockquote>
<p>当第三次握手丢失了（ACK 报文丢失），服务器端会重传 SYN-ACK 报文。</p>
<p>当服务端超时重传 SYN-ACK 报文达到最大重传次数时，再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接</p>
</blockquote>
<p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 <code>ESTABLISH</code> 状态。</p>
<p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p>
<h3 id="9、为什么ACK信号是SYN信号值-1？"><a href="#9、为什么ACK信号是SYN信号值-1？" class="headerlink" title="9、为什么ACK信号是SYN信号值+1？"></a>9、为什么ACK信号是SYN信号值+1？</h3><p>TCP（传输控制协议）的三次握手过程是建立一个可靠的连接会话的关键步骤。在这个过程中，ACK（确认）信号的值为SYN（同步）信号的值加1的原因主要是为了确认双方的接收能力和确保序列号的同步。</p>
<h3 id="10、三次握手的过程中可以携带数据吗"><a href="#10、三次握手的过程中可以携带数据吗" class="headerlink" title="10、三次握手的过程中可以携带数据吗"></a>10、三次握手的过程中可以携带数据吗</h3><p>第三次握手的时候可以携带数据，第一次和第二次握手不可以。</p>
<h3 id="11、什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#11、什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="11、什么是 SYN 攻击？如何避免 SYN 攻击？"></a>11、什么是 SYN 攻击？如何避免 SYN 攻击？</h3><p><strong>（1）什么是SYN攻击？</strong></p>
<p><strong>什么是 TCP 半连接和全连接队列。</strong></p>
<p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<ul>
<li>半连接队列，也称 SYN 队列；</li>
<li>全连接队列，也称 accept 队列；</li>
</ul>
<p>我们先来看下 Linux 内核的 <code>SYN</code> 队列（半连接队列）与 <code>Accpet</code> 队列（全连接队列）是如何工作的？</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101543018.png" alt="正常流程" style="zoom:50%;" />

<p>正常流程：</p>
<ul>
<li>当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；</li>
<li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li>
<li>服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；</li>
<li>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出连接对象。</li>
</ul>
<p>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文。</p>
<p> TCP 连接建立需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，<strong>当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃，导致客户端无法和服务端建立连接</strong>，使得服务端不能为正常用户服务。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101541969.png" alt="SYN 攻击" style="zoom: 80%;" />

<p><strong>（2）如何避免 SYN 攻击？</strong></p>
<blockquote>
<p>避免 SYN 攻击方式，可以有以下四种方法：</p>
<ul>
<li>调大 netdev_max_backlog；</li>
<li>增大 TCP 半连接队列；</li>
<li>开启 tcp_syncookies；</li>
<li>减少 SYN+ACK 重传次数</li>
</ul>
</blockquote>
<h2 id="3-6-四次挥手相关"><a href="#3-6-四次挥手相关" class="headerlink" title="3.6 四次挥手相关"></a>3.6 四次挥手相关</h2><h3 id="1、详细说明四次挥手"><a href="#1、详细说明四次挥手" class="headerlink" title="1、详细说明四次挥手"></a>1、详细说明四次挥手</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101556792.png" alt="客户端主动关闭连接 —— TCP 四次挥手" style="zoom: 67%;" />

<ul>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<p>可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p>
<h3 id="2、为什么挥手需要四次？"><a href="#2、为什么挥手需要四次？" class="headerlink" title="2、为什么挥手需要四次？"></a>2、为什么挥手需要四次？</h3><p>再来回顾下四次挥手双方发 <code>FIN</code> 包的过程，就能理解为什么需要四次了。</p>
<ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，因此是需要四次挥手。</p>
<h3 id="3、第一次挥手丢失了，会发生什么？"><a href="#3、第一次挥手丢失了，会发生什么？" class="headerlink" title="3、第一次挥手丢失了，会发生什么？"></a>3、第一次挥手丢失了，会发生什么？</h3><p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 <code>FIN_WAIT_1</code> 状态。</p>
<p>正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 <code>FIN_WAIT2</code>状态。如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 <code>tcp_orphan_retries</code> 参数控制。</p>
<p>当客户端重传 FIN 报文的次数超过 <code>tcp_orphan_retries</code> 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么直接进入到 <code>close</code> 状态。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.png" alt="img" style="zoom:50%;" />

<h3 id="4、第二次挥手丢失了，会发生什么？"><a href="#4、第二次挥手丢失了，会发生什么？" class="headerlink" title="4、第二次挥手丢失了，会发生什么？"></a>4、第二次挥手丢失了，会发生什么？</h3><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 <code>CLOSE_WAIT</code> 状态。</p>
<p>在前面我们也提了，<strong>ACK 报文是不会重传的</strong>，所以如果服务端的第二次挥手丢失了，<strong>客户端就会触发超时重传机制，重传 FIN 报文</strong>，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.png" alt="img" style="zoom:50%;" />

<p>这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 <code>FIN_WAIT2</code> 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。</p>
<p>对于 <strong>close 函数</strong>关闭的连接，由于无法再发送和接收数据，所以<code>FIN_WAIT2</code> 状态不可以持续太久，而 <code>tcp_fin_timeout</code> 控制了这个状态下连接的持续时长，默认值是 60 秒。这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/fin_wait_2.drawio.png" alt="img" style="zoom:50%;" />

<p>但是注意，如果主动关闭方使用 <strong>shutdown 函数</strong>关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 <code>FIN_WAIT2</code> 状态（<code>tcp_fin_timeout</code> 无法控制 shutdown 关闭的连接）。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/fin_wait_2%E6%AD%BB%E7%AD%89.drawio.png" alt="img" style="zoom:50%;" />

<h3 id="5、第三次挥手丢失了，会发生什么？"><a href="#5、第三次挥手丢失了，会发生什么？" class="headerlink" title="5、第三次挥手丢失了，会发生什么？"></a>5、第三次挥手丢失了，会发生什么？</h3><p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 <code>CLOSE_WAIT</code> 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。</p>
<p>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 <code>tcp_orphan_retries</code> 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101604609.png" alt="img" style="zoom:50%;" />

<h3 id="6、第四次挥手丢失了，会发生什么？"><a href="#6、第四次挥手丢失了，会发生什么？" class="headerlink" title="6、第四次挥手丢失了，会发生什么？"></a>6、第四次挥手丢失了，会发生什么？</h3><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 <code>TIME_WAIT</code> 状态。</p>
<p>在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 <code>tcp_orphan_retries</code> 参数控制。</p>
<p>举个例子，假设 tcp_orphan_retries 为 2，当第四次挥手一直丢失时，发生的过程如下：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101603186.png" alt="img" style="zoom:50%;" />

<h3 id="7、为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#7、为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="7、为什么 TIME_WAIT 等待的时间是 2MSL？"></a>7、为什么 TIME_WAIT 等待的时间是 2MSL？</h3><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 <code>TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。<strong>TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</strong>。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p>
<p>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 <code>FIN</code> 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。可以看到 <strong>2MSL时长</strong> 这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。<code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p>
<p><strong>Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。其定义在 Linux 内核代码里的名称为 TCP_TIMEWAIT_LEN：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_TIMEWAIT_LEN (60*HZ) <span class="comment">/* how long to wait to destroy TIME-WAIT </span></span></span><br><span class="line"><span class="comment"><span class="meta">                                    state, about 60 seconds  */</span></span></span><br></pre></td></tr></table></figure>

<p>如果要修改 TIME_WAIT 的时间长度，只能修改 Linux 内核代码里 TCP_TIMEWAIT_LEN 的值，并重新编译 Linux 内核。</p>
<h3 id="8、为什么需要-TIME-WAIT-状态？"><a href="#8、为什么需要-TIME-WAIT-状态？" class="headerlink" title="8、为什么需要 TIME_WAIT 状态？"></a>8、为什么需要 TIME_WAIT 状态？</h3><blockquote>
<p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p>
<p>需要 TIME-WAIT 状态，主要是两个原因：</p>
<ul>
<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li>
<li>保证「被动关闭连接」的一方，能被正确的关闭；</li>
</ul>
</blockquote>
<p><strong>（1）原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收</strong></p>
<p>为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 <code>2MSL</code> 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p>
<p><strong>（2）原因二：保证「被动关闭连接」的一方，能被正确的关闭</strong></p>
<p>TIME-WAIT 的另一个作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p>
<p>如果客户端（主动关闭方）最后一次 ACK 报文（第四次挥手）在网络中丢失了，那么按照 TCP 可靠性原则，服务端（被动关闭方）会重发 FIN 报文。</p>
<p>假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSE 状态，如果该  ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说不是一个优雅的终止方式。</p>
<p>为了防止这种情况出现，客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TIME-WAIT%E8%BF%9E%E6%8E%A5%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%AD.drawio.png" alt="TIME-WAIT 时间正常，确保了连接正常关闭" style="zoom:50%;" />

<p>客户端在收到服务端重传的 FIN 报文时，TIME_WAIT 状态的等待时间，会重置回 2MSL。</p>
<h3 id="9、TIME-WAIT-过多有什么危害？"><a href="#9、TIME-WAIT-过多有什么危害？" class="headerlink" title="9、TIME_WAIT 过多有什么危害？"></a>9、TIME_WAIT 过多有什么危害？</h3><p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ul>
<li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li>
<li>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</li>
</ul>
<p>客户端和服务端 TIME_WAIT 过多，造成的影响是不同的。</p>
<p><strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的。因此，客户端（发起连接方）都是和「目的 IP+ 目的 PORT 」都一样的服务端建立连接的话，当客户端的 TIME_WAIT  状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的 IP+ 目的 PORT」都一样的服务端建立连接了。不过，即使是在这种场景下，只要连接的是不同的服务端，端口是可以重复使用的，所以客户端还是可以向其他服务端发起连接的，这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。</p>
<p><strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。</p>
<h3 id="10、如何优化-TIME-WAIT？"><a href="#10、如何优化-TIME-WAIT？" class="headerlink" title="10、如何优化 TIME_WAIT？"></a>10、如何优化 TIME_WAIT？</h3><blockquote>
<p>这里给出优化 TIME-WAIT 的几个方式，都是有利有弊：</p>
<ul>
<li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li>
<li>net.ipv4.tcp_max_tw_buckets</li>
<li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li>
</ul>
</blockquote>
<h3 id="11、服务器出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#11、服务器出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="11、服务器出现大量 TIME_WAIT 状态的原因有哪些？"></a>11、服务器出现大量 TIME_WAIT 状态的原因有哪些？</h3><blockquote>
<p>首先要知道 TIME_WAIT 状态是主动关闭连接方才会出现的状态，所以<strong>如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接</strong>。</p>
<p>问题来了，<strong>什么场景下服务端会主动断开连接呢？</strong></p>
<ul>
<li>第一个场景：HTTP 没有使用长连接</li>
<li>第二个场景：HTTP 长连接超时</li>
<li>第三个场景：HTTP 长连接的请求数量达到上限</li>
</ul>
</blockquote>
<p>接下来，分别介绍下。</p>
<p><strong>（1）第一个场景：HTTP 没有使用长连接</strong></p>
<p>只要任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，就无法使用 HTTP 长连接机制，这样在完成一次 HTTP 请求&#x2F;处理后，就会关闭连接。<strong>根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<blockquote>
<p>客户端禁用了 HTTP Keep-Alive，服务端开启 HTTP Keep-Alive，谁是主动关闭方？</p>
</blockquote>
<p>当客户端禁用了 HTTP Keep-Alive，这时候 HTTP 请求的 header 就会有 <code>Connection:close</code> 信息，这时服务端在发完 HTTP 响应后，就会主动关闭连接。</p>
<p>为什么要这么设计呢？HTTP 是请求-响应模型，发起方一直是客户端，HTTP Keep-Alive 的初衷是<strong>为客户端后续的请求重用连接</strong>，如果我们<strong>在某次 HTTP 请求-响应模型中，请求的 header 定义了 <code>connection：close</code> 信息，那不再重用这个连接的时机就只有在服务端了</strong>，所以我们在 HTTP 请求-响应这个周期的「末端」关闭连接是合理的。</p>
<blockquote>
<p>客户端开启了 HTTP Keep-Alive，服务端禁用了 HTTP Keep-Alive，谁是主动关闭方？</p>
</blockquote>
<p>当客户端开启了 HTTP Keep-Alive，而服务端禁用了 HTTP Keep-Alive，这时服务端在发完 HTTP 响应后，服务端也会主动关闭连接。</p>
<p><strong>因此，当服务端出现大量的 TIME_WAIT 状态连接的时候，可以排查下是否客户端和服务端都开启了 HTTP Keep-Alive，因为任意一方没有开启  HTTP Keep-Alive，都会导致服务端在处理完一个 HTTP 请求后，就主动关闭连接，此时服务端上就会出现大量的 TIME_WAIT 状态的连接。</strong></p>
<p>针对这个场景下，解决的方式也很简单，让客户端和服务端都开启 HTTP Keep-Alive 机制。</p>
<p><strong>（2）第二个场景：HTTP 长连接超时</strong></p>
<p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。HTTP 长连接可以在同一个 TCP 连接上接收和发送多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销。</p>
<p>为了避免资源浪费的情况，web 服务软件一般都会提供一个参数，用来指定 HTTP 长连接的超时时间，比如 nginx 提供的 keepalive_timeout 参数。假设设置了 HTTP 长连接的超时时间是 60 秒，nginx 就会启动一个「定时器」，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<p><strong>当服务端出现大量 TIME_WAIT 状态的连接时，如果现象是有大量的客户端建立完 TCP 连接后，很长一段时间没有发送数据，那么大概率就是因为 HTTP 长连接超时，导致服务端主动关闭连接，产生大量处于 TIME_WAIT 状态的连接。可以往网络问题的方向排查，比如是否是因为网络问题，导致客户端发送的数据一直没有被服务端接收到，以至于 HTTP 长连接超时。</strong></p>
<p><strong>（3）第三个场景：HTTP 长连接的请求数量达到上限</strong></p>
<p>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。比如 nginx 的 keepalive_requests 这个参数，这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个 HTTP 长连接上已经接收并处理的客户端请求的数量。<strong>如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<p>keepalive_requests 参数的默认值是 100 ，意味着每个 HTTP 长连接最多只能跑 100  次请求，这个参数往往被大多数人忽略，因为当 QPS (每秒请求数) 不是很高时，默认值 100 凑合够用。</p>
<p>但是，<strong>对于一些 QPS 比较高的场景，比如超过 10000 QPS，甚至达到 30000 , 50000 甚至更高，如果 keepalive_requests 参数值是 100，这时候就 nginx 就会很频繁地关闭连接，那么此时服务端上就会出大量的 TIME_WAIT 状态</strong>。</p>
<p>针对这个场景下，解决的方式也很简单，调大 nginx 的 keepalive_requests 参数就行。</p>
<h3 id="12、服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#12、服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="12、服务器出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>12、服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h3><p>CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p>
<p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p>
<p>那什么情况会导致服务端的程序没有调用 close 函数关闭连接？这时候通常需要排查代码。</p>
<p>我们先来分析一个普通的 TCP 服务端的流程：</p>
<ol>
<li>创建服务端 socket，bind 绑定端口、listen 监听端口</li>
<li>将服务端 socket 注册到 epoll</li>
<li>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</li>
<li>将已连接的 socket 注册到 epoll</li>
<li>epoll_wait 等待事件发生</li>
<li>对方连接关闭时，我方调用 close</li>
</ol>
<p>可能导致服务端没有调用 close 函数的原因，如下。</p>
<p><strong>第一个原因</strong>：第 2 步没有做，没有将服务端 socket 注册到 epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了。</p>
<p>不过这种原因发生的概率比较小，这种属于明显的代码逻辑 bug，在前期 read view 阶段就能发现的了。</p>
<p><strong>第二个原因</strong>： 第 3 步没有做，有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。</p>
<p>发生这种情况可能是因为服务端在执行 accpet  函数之前，代码卡在某一个逻辑或者提前抛出了异常。</p>
<p><strong>第三个原因</strong>：第 4 步没有做，通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。发生这种情况可能是因为服务端在将已连接的 socket 注册到 epoll 之前，代码卡在某一个逻辑或者提前抛出了异常。</p>
<p><strong>第四个原因</strong>：第 6 步没有做，当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。</p>
<p>可以发现，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。</p>
<h3 id="13、如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#13、如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="13、如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>13、如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于   <code>ESTABLISH</code> 状态，占用着系统资源。</p>
<p>为了避免这种情况，TCP 设置了<strong>保活机制</strong>。这个机制的原理是这样的：</p>
<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP  连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<h3 id="14、如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a href="#14、如果已经建立了连接，但是服务端的进程崩溃会发生什么？" class="headerlink" title="14、如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a>14、如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h3><p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN  报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p>
<blockquote>
<p>我自己做了个实验，使用 kill -9 来模拟进程崩溃的情况，发现<strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。</p>
</blockquote>
<h2 id="3-7-Socket编程"><a href="#3-7-Socket编程" class="headerlink" title="3.7 Socket编程"></a>3.7 Socket编程</h2><h3 id="1、针对-TCP-应该如何-Socket-编程？"><a href="#1、针对-TCP-应该如何-Socket-编程？" class="headerlink" title="1、针对 TCP 应该如何 Socket 编程？"></a>1、针对 TCP 应该如何 Socket 编程？</h3><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230545997.png" alt="基于 TCP 协议的客户端和服务端工作"></p>
<ul>
<li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li>
<li>服务端调用 <code>bind</code>，将 socket 绑定在指定的 IP 地址和端口;</li>
<li>服务端调用 <code>listen</code>，进行监听；</li>
<li>服务端调用 <code>accept</code>，等待客户端连接；</li>
<li>客户端调用 <code>connect</code>，向服务端的地址和端口发起连接请求；</li>
<li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li>
<li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li>
<li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li>
</ul>
<p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p>
<p>所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p>
<p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>
<h3 id="2、accept-发生在三次握手的哪一步？"><a href="#2、accept-发生在三次握手的哪一步？" class="headerlink" title="2、accept 发生在三次握手的哪一步？"></a>2、accept 发生在三次握手的哪一步？</h3><p>我们先看看客户端连接服务端时，发送了什么？</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/socket%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="socket 三次握手" style="zoom:50%;" />

<ul>
<li>客户端的协议栈向服务端发送了 SYN 包，并告诉服务端当前发送序列号 client_isn，客户端进入 SYN_SENT 状态；</li>
<li>服务端的协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 client_isn+1，表示对 SYN 包 client_isn 的确认，同时服务端也发送一个 SYN  包，告诉客户端当前我的发送序列号为 server_isn，服务端进入 SYN_RCVD 状态；</li>
<li>客户端协议栈收到 ACK 之后，使得应用程序从 <code>connect</code> 调用返回，表示客户端到服务端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务端的 SYN 包进行应答，应答数据为 server_isn+1；</li>
<li>ACK 应答包到达服务端后，服务端的 TCP 连接进入 ESTABLISHED 状态，同时服务端协议栈使得 <code>accept</code> 阻塞调用返回，这个时候服务端到客户端的单向连接也建立成功。至此，客户端与服务端两个方向的连接都建立成功。</li>
</ul>
<p>从上面的描述过程，我们可以得知<strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。</strong></p>
<h2 id="3-8-TCP可靠性相关"><a href="#3-8-TCP可靠性相关" class="headerlink" title="3.8 TCP可靠性相关"></a>3.8 TCP可靠性相关</h2><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/3.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="img" style="zoom:50%;" />

<h3 id="1、重传机制"><a href="#1、重传机制" class="headerlink" title="1、重传机制"></a>1、重传机制</h3><blockquote>
<p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p>
<p>常见的重传机制：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
<li>SACK</li>
<li>D-SACK</li>
</ul>
</blockquote>
<p><strong>（1）超时重传</strong></p>
<p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p>
<p>TCP 会在以下两种情况发生超时重传：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<p><strong>超时重传时间 RTO 的值应该略大于报文往返  RTT 的值</strong>。如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是<strong>超时间隔加倍。</strong>也就是<strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p>
<blockquote>
<p>超时时间应该设置为多少呢？</p>
</blockquote>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/6.jpg?" alt="RTT" style="zoom:50%;" />

<p><code>RTT</code>（Round-Trip Time 往返时延）指的是<strong>数据发送时刻到接收到确认的时刻的差值</strong>，也就是包的往返时间。实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个<strong>动态变化的值</strong>。</p>
<p>超时重传时间是以 <code>RTO</code> （Retransmission Timeout 超时重传时间）表示。假设在重传的情况下，超时时间 <code>RTO</code> 「较长或较短」时的表现如下：</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/7.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="超时时间较长与较短" style="zoom:50%;" />

<p>因此，<strong>超时重传时间 RTO 的值应该略大于报文往返  RTT 的值</strong>。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/8.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="RTO 应略大于 RTT" style="zoom: 67%;" />

<p><strong>（2）快速重传</strong></p>
<p>TCP 还有另外一种<strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
<p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<strong>重传的时候，是重传一个，还是重传所有的问题。</strong></p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传机制" style="zoom: 80%;" />



<p>为了解决不知道该重传哪些 TCP 报文，于是就有 <code>SACK</code> 方法。</p>
<p><strong>（3）SACK 方法</strong></p>
<p><code>SACK</code>（ Selective Acknowledgment）， <strong>选择性确认</strong>。</p>
<p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<p>如果要支持 <code>SACK</code>，必须双方都要支持。在 Linux 下，可以通过 <code>net.ipv4.tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）。</p>
<p><strong>（4）Duplicate SACK</strong></p>
<p>Duplicate SACK 又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</strong></p>
<p><code>D-SACK</code> 有这么几个好处：</p>
<ol>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了;</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了;</li>
</ol>
<p>在 Linux 下可以通过 <code>net.ipv4.tcp_dsack</code> 参数开启&#x2F;关闭这个功能（Linux 2.4 后默认打开）。</p>
<h3 id="2、滑动窗口"><a href="#2、滑动窗口" class="headerlink" title="2、滑动窗口"></a>2、滑动窗口</h3><blockquote>
<p>引入窗口概念的原因</p>
</blockquote>
<p>TCP 每发送一个数据，都要进行一次确认应答。这样的传输方式有一个缺点：数据包的<strong>往返时间越长，通信的效率就越低</strong>。为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。窗口大小是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p>
<p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/15.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="用滑动窗口方式并行处理" style="zoom: 67%;" />

<p>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p>
<blockquote>
<p>窗口大小由哪一方决定？</p>
</blockquote>
<p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</p>
<p><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong></p>
<p>所以，通常窗口的大小是由接收方的窗口大小来决定的。</p>
<p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>
<blockquote>
<p>接收窗口和发送窗口的大小是相等的吗？</p>
</blockquote>
<p>并不是完全相等，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。</p>
<p>因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</p>
<h3 id="3、流量控制"><a href="#3、流量控制" class="headerlink" title="3、流量控制"></a>3、流量控制</h3><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p>
<p>为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p>
<p><strong>（1）窗口关闭</strong></p>
<p>TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。<strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</strong></p>
<blockquote>
<p>窗口关闭潜在的危险</p>
</blockquote>
<p>接收方向发送方通告窗口大小时，是通过 <code>ACK</code> 报文来通告的。那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/24.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="窗口关闭潜在的危险" style="zoom:50%;" />

<blockquote>
<p>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</p>
</blockquote>
<p>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/25.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="窗口探测" style="zoom: 50%;" />

<ul>
<li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；</li>
<li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li>
</ul>
<p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code>RST</code> 报文来中断连接。</p>
<h3 id="4、拥塞控制"><a href="#4、拥塞控制" class="headerlink" title="4、拥塞控制"></a>4、拥塞控制</h3><blockquote>
<p>为什么要有拥塞控制呀，不是有流量控制了吗？</p>
</blockquote>
<p>前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p>
<p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。<strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p>
<p>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。</p>
<blockquote>
<p>什么是拥塞窗口？和发送窗口有什么关系呢？</p>
</blockquote>
<p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p>
<p>我们在前面提到过发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p>
<p>拥塞窗口 <code>cwnd</code> 变化的规则：</p>
<ul>
<li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li>
<li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li>
</ul>
<blockquote>
<p>那么怎么知道当前网络是否出现了拥塞呢？</p>
</blockquote>
<p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p>
<blockquote>
<p>拥塞控制有哪些控制算法？</p>
</blockquote>
<p>拥塞控制主要是四个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<h2 id="3-9-如何理解是-TCP-面向字节流协议？"><a href="#3-9-如何理解是-TCP-面向字节流协议？" class="headerlink" title="3.9 如何理解是 TCP 面向字节流协议？"></a>3.9 如何理解是 TCP 面向字节流协议？</h2><p>之所以会说 TCP 是面向字节流的协议，UDP 是面向报文的协议，是因为操作系统对 TCP 和 UDP 协议的<strong>发送方的机制不同</strong>，也就是问题原因在发送方。</p>
<blockquote>
<p>先来说说为什么 UDP 是面向报文的协议？</p>
</blockquote>
<p>当用户消息通过 UDP 协议传输时，<strong>操作系统不会对消息进行拆分</strong>，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是<strong>每个 UDP 报文就是一个用户消息的边界</strong>，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。</p>
<p>操作系统在收到 UDP 报文后，会将其插入到队列里，<strong>队列里的每一个元素就是一个 UDP 报文</strong>，这样当用户调用 recvfrom() 系统调用读数据的时候，就会从队列里取出一个数据，然后从内核里拷贝给用户缓冲区。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101710378.png" alt="图片" style="zoom: 67%;" />

<blockquote>
<p>再来说说为什么 TCP 是面向字节流的协议？</p>
</blockquote>
<p>当用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。这时，接收方的程序如果不知道发送方发送的消息的长度，也就是不知道消息的边界时，是无法读出一个有效的用户消息的，因为用户消息被拆分成多个 TCP 报文后，并不能像 UDP 那样，一个 UDP 报文就能代表一个完整的用户消息。</p>
<p>举个实际的例子来说明。</p>
<p>发送方准备发送 「Hi.」和「I am Xiaolin」这两个消息。</p>
<p>在发送端，当我们调用 send 函数完成数据“发送”以后，数据并没有被真正从网络上发送出去，只是从应用程序拷贝到了操作系统内核协议栈中。至于什么时候真正被发送，<strong>取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件</strong>。也就是说，我们不能认为每次 send 调用发送的数据，都会作为一个整体完整地消息被发送出去。</p>
<p>如果我们考虑实际网络传输过程中的各种影响，假设发送端陆续调用 send 函数先后发送 「Hi.」和「I am Xiaolin」 报文，那么实际的发送很有可能是这几种情况。</p>
<p>第一种情况，这两个消息被分到同一个 TCP 报文，像这样：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/02dce678f870c8c70482b6e37dbb5574.png" alt="图片" style="zoom:67%;" />

<p>第二种情况，「I am Xiaolin」的部分随 「Hi」 在一个 TCP 报文中发送出去，像这样：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/f58b70cde860188b8f95a433e2f5293b.png" alt="图片" style="zoom: 67%;" />

<p>第三种情况，「Hi.」 的一部分随 TCP 报文被发送出去，另一部分和 「I am Xiaolin」 一起随另一个 TCP 报文发送出去，像这样。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/68080e783d7acc842fa254e4f9ec5630.png" alt="图片" style="zoom:67%;" />

<p>类似的情况还能举例很多种，因此，<strong>我们不能认为一个用户消息对应一个 TCP 报文，正因为这样，所以 TCP 是面向字节流的协议</strong>。当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 TCP 粘包问题，这时接收方不知道消息的边界的话，是无法读出有效的消息。要解决这个问题，要交给<strong>应用程序</strong>。</p>
<h2 id="3-10-如何解决粘包？"><a href="#3-10-如何解决粘包？" class="headerlink" title="3.10 如何解决粘包？"></a>3.10 如何解决粘包？</h2><blockquote>
<p>粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。</p>
<p>一般有三种方式分包的方式：</p>
<ul>
<li>固定长度的消息；</li>
<li>特殊字符作为边界；</li>
<li>自定义消息结构。</li>
</ul>
</blockquote>
<p><strong>（1）固定长度的消息</strong></p>
<p>这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。</p>
<p><strong>（2）特殊字符作为边界</strong></p>
<p>在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。</p>
<p>HTTP 是一个非常好的例子。HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/a49a6bb8cd38ae1738d9c00aec68b444.png" alt="图片" style="zoom:50%;" />

<p>有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。</p>
<p><strong>（3）自定义消息结构</strong></p>
<p>自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。</p>
<p>比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    <span class="type">u_int32_t</span> message_length; </span><br><span class="line">    <span class="type">char</span> message_data[]; </span><br><span class="line">&#125; message;</span><br></pre></td></tr></table></figure>

<p>当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。</p>
<h2 id="3-11-已建立连接的TCP，收到SYN会发生什么？"><a href="#3-11-已建立连接的TCP，收到SYN会发生什么？" class="headerlink" title="3.11 已建立连接的TCP，收到SYN会发生什么？"></a>3.11 已建立连接的TCP，收到SYN会发生什么？</h2><p><strong>1. 客户端的 SYN 报文里的端口号与历史连接不相同</strong></p>
<p>如果客户端恢复后发送的 SYN 报文中的源端口号跟上一次连接的源端口号不一样，此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。</p>
<p>那旧连接里处于 Established 状态的服务端最后会怎么样呢？</p>
<ul>
<li>如果服务端发送了数据包给客户端，由于客户端的连接已经被关闭了，此时客户的内核就会回 RST 报文，服务端收到后就会释放连接；</li>
<li>如果服务端一直没有发送数据包给客户端，在超过一段时间后，TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。</li>
</ul>
<p><strong>2. 客户端的 SYN 报文里的端口号与历史连接相同</strong></p>
<p>如果客户端恢复后，发送的 SYN 报文中的源端口号跟上一次连接的源端口号一样，也就是处于 Established 状态的服务端收到了这个 SYN 报文。</p>
<p><strong>处于 Established 状态的服务端，如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN  报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。</strong></p>
<p><strong>接着，客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。</strong></p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/est_syn.png" alt="img" style="zoom:50%;" />

<h2 id="3-12-四次挥手中收到乱序的-FIN-包会如何处理？"><a href="#3-12-四次挥手中收到乱序的-FIN-包会如何处理？" class="headerlink" title="3.12 四次挥手中收到乱序的 FIN 包会如何处理？"></a>3.12 四次挥手中收到乱序的 FIN 包会如何处理？</h2><blockquote>
<p><strong>在 FIN_WAIT_2 状态下，是如何处理收到的乱序到 FIN 报文，然后 TCP 连接又是什么时候才进入到 TIME_WAIT 状态?</strong></p>
</blockquote>
<p><strong>在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文，那么就被会加入到「乱序队列」，并不会进入到 TIME_WAIT 状态。</strong></p>
<p><strong>等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，然后会检测乱序队列中是否有可用的数据，如果能在乱序队列中找到与当前报文的序列号保持的顺序的报文，就会看该报文是否有 FIN 标志，如果发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。</strong></p>
<img src="https://cdn.xiaolincoding.com//mysql/other/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5p6XY29kaW5n,size_20,color_FFFFFF,t_70,g_se,x_16-20230309230147654.png" alt="img" style="zoom: 67%;" />

<h2 id="3-13-在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？"><a href="#3-13-在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？" class="headerlink" title="3.13 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？"></a>3.13 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？</h2><blockquote>
<p><strong>1、收到合法 SYN</strong></p>
<p>如果处于 TIME_WAIT 状态的连接收到「合法的 SYN 」后，<strong>就会重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程</strong>。</p>
<p><strong>2、收到非法的 SYN</strong></p>
<p>如果处于 TIME_WAIT 状态的连接收到「非法的 SYN 」后，就会<strong>再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号（ack num），就回 RST 报文给服务端</strong>。</p>
</blockquote>
<img src="https://cdn.xiaolincoding.com//mysql/other/74b53919396dcda634cfd5b5795cbf16.png" alt="图片" style="zoom: 67%;" />

<p>针对这个问题，<strong>关键是要看 SYN 的「序列号和时间戳」是否合法</strong>，因为处于 TIME_WAIT 状态的连接收到 SYN 后，会判断 SYN 的「序列号和时间戳」是否合法，然后根据判断结果的不同做不同的处理。</p>
<ul>
<li><strong>合法 SYN</strong>：客户端的  SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>，<strong>并且</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>大</strong>。</li>
<li><strong>非法 SYN</strong>：客户端的  SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>，<strong>或者</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>小</strong>。</li>
</ul>
<p>上面 SYN 合法判断是基于双方都开启了 TCP 时间戳机制的场景，如果双方都没有开启 TCP 时间戳机制，则 SYN 合法判断如下：</p>
<ul>
<li><strong>合法 SYN</strong>：客户端的  SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>。</li>
<li><strong>非法 SYN</strong>：客户端的  SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>。</li>
</ul>
<h2 id="3-14-在-TIME-WAIT-状态，收到-RST-会断开连接吗？"><a href="#3-14-在-TIME-WAIT-状态，收到-RST-会断开连接吗？" class="headerlink" title="3.14 在 TIME_WAIT 状态，收到 RST 会断开连接吗？"></a>3.14 在 TIME_WAIT 状态，收到 RST 会断开连接吗？</h2><p>在前面我留了一个疑问，处于 TIME_WAIT 状态的连接，收到 RST 会断开连接吗？</p>
<p>会不会断开，关键看 <code>net.ipv4.tcp_rfc1337</code> 这个内核参数（默认情况是为 0）：</p>
<ul>
<li>如果这个参数设置为 0， 收到 RST 报文会提前结束 TIME_WAIT 状态，释放连接。</li>
<li>如果这个参数设置为 1， 就会丢掉 RST 报文。</li>
</ul>
<h2 id="3-15-针对某个TCP-连接，一端断电和进程崩溃有什么区别？"><a href="#3-15-针对某个TCP-连接，一端断电和进程崩溃有什么区别？" class="headerlink" title="3.15  针对某个TCP 连接，一端断电和进程崩溃有什么区别？"></a>3.15  针对某个TCP 连接，一端断电和进程崩溃有什么区别？</h2><blockquote>
<p>如果是「<strong>客户端进程崩溃</strong>」，那么内核会发送 FIN 报文，与服务端进行四次挥手。</p>
<p>但是，「<strong>客户端主机宕机</strong>」，后续还要看服务端会不会发送数据：</p>
<ul>
<li>如果服务端有发送数据，由于客户端已经不存在，收不到数据报文的响应报文，服务端的数据报文会超时重传，当重传总间隔时长达到一定阈值（内核会根据 tcp_retries2 设置的值计算出一个阈值）后，会断开 TCP 连接；</li>
<li>如果服务端一直不会发送数据，再看服务端有没有开启 TCP keepalive 机制？</li>
<li>如果有开启，服务端在一段时间没有进行数据交互时，会触发 TCP keepalive 机制，探测对方是否存在，如果探测到对方已经消亡，则会断开自身的 TCP 连接；</li>
<li>如果没有开启，服务端的 TCP 连接会一直存在，并且一直保持在 ESTABLISHED 状态。</li>
</ul>
</blockquote>
<h3 id="1、没有数据传输的情况"><a href="#1、没有数据传输的情况" class="headerlink" title="1、没有数据传输的情况"></a>1、没有数据传输的情况</h3><blockquote>
<p>一个TCP连接，没有打开keepalive，没有数据交互，现在一端突然掉电和一端的进程crush了，这两种情况有什么区别呢？</p>
</blockquote>
<ul>
<li><p>TCP keepalive实际上就是 <strong>TCP 的保活机制</strong>：</p>
<p>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</p>
<ul>
<li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li>
<li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li>
</ul>
<p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。</p>
</li>
</ul>
<h4 id="（1）主机崩溃"><a href="#（1）主机崩溃" class="headerlink" title="（1）主机崩溃"></a>（1）主机崩溃</h4><p>知道了 TCP keepalive 作用，我们再回过头看题目中的「主机崩溃」这种情况。</p>
<blockquote>
<p>在没有开启 TCP keepalive，且双方一直没有数据交互的情况下，如果客户端的「主机崩溃」了，会发生什么？</p>
</blockquote>
<p>客户端主机崩溃了，服务端是<strong>无法感知到的</strong>，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程。</p>
<p>所以，我们可以得知一个点，<strong>在没有使用 TCP 保活机制且双方不传输数据的情况下</strong>，一方的 TCP 连接处在 ESTABLISHED 状态，并不代表另一方的连接还一定正常。</p>
<h4 id="（2）进程崩溃"><a href="#（2）进程崩溃" class="headerlink" title="（2）进程崩溃"></a>（2）进程崩溃</h4><blockquote>
<p>那题目中的「进程崩溃」的情况呢？</p>
</blockquote>
<p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN  报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP四次挥手的过程。</p>
<p>使用 kill -9 来模拟进程崩溃的情况，发现<strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</p>
<h3 id="2、有数据传输的情况"><a href="#2、有数据传输的情况" class="headerlink" title="2、有数据传输的情况"></a>2、有数据传输的情况</h3><h4 id="（1）客户端主机宕机，又迅速重启"><a href="#（1）客户端主机宕机，又迅速重启" class="headerlink" title="（1）客户端主机宕机，又迅速重启"></a>（1）客户端主机宕机，又迅速重启</h4><p>在客户端主机宕机后，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的报文。服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：</p>
<ul>
<li>如果客户端主机上<strong>没有</strong>进程绑定该 TCP 报文的目标端口号，那么客户端内核就会<strong>回复 RST 报文，重置该 TCP 连接</strong>；</li>
<li>如果客户端主机上<strong>有</strong>进程绑定该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会<strong>回复 RST 报文，重置该 TCP 连接</strong>。</li>
</ul>
<p>所以，<strong>只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接</strong>。</p>
<h4 id="（2）客户端主机宕机，一直没有重启"><a href="#（2）客户端主机宕机，一直没有重启" class="headerlink" title="（2）客户端主机宕机，一直没有重启"></a>（2）客户端主机宕机，一直没有重启</h4><p>这种情况，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。</p>
<blockquote>
<p>那 TCP 的数据报文具体重传几次呢？</p>
</blockquote>
<p>在 Linux 系统中，提供一个叫 tcp_retries2 配置项，默认值是 15，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/20210615134059647.png" alt="在这里插入图片描述"></p>
<p>这个内核参数是控制在 TCP 连接建立的情况下，超时重传的最大次数。</p>
<p>不过 tcp_retries2 设置了 15 次，并不代表 TCP 超时重传了 15 次才会通知应用程序终止该 TCP 连接，<strong>内核会根据 tcp_retries2 设置的值，计算出一个 timeout</strong>（<em>如果 tcp_retries2 &#x3D;15，那么计算得到的 timeout &#x3D; 924600 ms</em>），<strong>如果重传间隔超过这个 timeout，则认为超过了阈值，就会停止重传，然后就会断开 TCP 连接</strong>。</p>
<p>在发生超时重传的过程中，每一轮的超时时间（RTO）都是<strong>倍数增长</strong>的，比如如果第一轮 RTO 是 200 毫秒，那么第二轮 RTO 是 400 毫秒，第三轮 RTO 是 800 毫秒，以此类推。而 RTO 是基于 RTT（一个包的往返时间） 来计算的，如果 RTT 较大，那么计算出来的 RTO 就越大，那么经过几轮重传后，很快就达到了上面的 timeout 值了。</p>
<p>最小 RTO 和最大 RTO 是在 Linux 内核中定义好了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_RTO_MAX ((unsigned)(120*HZ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_RTO_MIN ((unsigned)(HZ/5))</span></span><br></pre></td></tr></table></figure>

<p>Linux 2.6+ 使用 1000 毫秒的 HZ，因此<code>TCP_RTO_MIN</code>约为 200 毫秒，<code>TCP_RTO_MAX</code>约为 120 秒。</p>
<h2 id="3-16-拔掉网线后，-原本的-TCP-连接还存在吗？"><a href="#3-16-拔掉网线后，-原本的-TCP-连接还存在吗？" class="headerlink" title="3.16 拔掉网线后， 原本的 TCP 连接还存在吗？"></a>3.16 拔掉网线后， 原本的 TCP 连接还存在吗？</h2><p>实际上，TCP 连接在 Linux 内核中是一个名为 <code>struct socket</code> 的结构体，该结构体的内容包含 TCP 连接的状态等信息。当拔掉网线的时候，操作系统并不会变更该结构体的任何内容，所以 TCP 连接的状态也不会发生改变。</p>
<p><strong>因此，拔掉网线这个动作并不会影响 TCP 连接的状态。</strong>接下来，要看拔掉网线后，双方做了什么动作，此问题需要分场景来讨论：</p>
<ul>
<li>拔掉网线后，有数据传输；</li>
<li>拔掉网线后，没有数据传输。</li>
</ul>
<h3 id="1、拔掉网线后，有数据传输"><a href="#1、拔掉网线后，有数据传输" class="headerlink" title="1、拔掉网线后，有数据传输"></a>1、拔掉网线后，有数据传输</h3><p>在客户端拔掉网线后，服务端向客户端发送的数据报文会得不到任何的响应，在等待一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的数据报文。</p>
<ul>
<li><p><strong>如果在服务端重传报文的过程中，客户端刚好把网线插回去了</strong>，由于拔掉网线并不会改变客户端的 TCP 连接状态，并且还是处于 ESTABLISHED 状态，所以这时客户端是可以正常接收服务端发来的数据报文的，然后客户端就会回 ACK 响应报文。</p>
<p>此时，客户端和服务端的 TCP 连接依然存在的，就感觉什么事情都没有发生；</p>
</li>
<li><p>但是，<strong>如果如果在服务端重传报文的过程中，客户端一直没有将网线插回去</strong>，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。</p>
<p>而等客户端插回网线后，如果客户端向服务端发送了数据，由于服务端已经没有与客户端相同四元祖的 TCP 连接了，因此服务端内核就会回复 RST 报文，客户端收到后就会释放该 TCP 连接。</p>
<p>此时，客户端和服务端的 TCP 连接都已经断开了。</p>
</li>
</ul>
<h3 id="2、拔掉网线后，没有数据传输"><a href="#2、拔掉网线后，没有数据传输" class="headerlink" title="2、拔掉网线后，没有数据传输"></a>2、拔掉网线后，没有数据传输</h3><p>针对拔掉网线后，没有数据传输的场景，还得看是否开启了 TCP keepalive 机制 （TCP 保活机制）。</p>
<ul>
<li><p>如果<strong>没有开启</strong> TCP keepalive 机制，在客户端拔掉网线后，并且双方都没有进行数据传输，那么客户端和服务端的 TCP 连接将会一直保持存在。</p>
</li>
<li><p>而如果<strong>开启</strong>了 TCP keepalive 机制，在客户端拔掉网线后，即使双方都没有进行数据传输，在持续一段时间后，TCP 就会发送探测报文：</p>
<ul>
<li><p>如果<strong>对端是正常工作</strong>的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</p>
</li>
<li><p>如果<strong>对端主机宕机</strong>（<em>注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机</em>），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</p>
</li>
</ul>
<p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。</p>
</li>
</ul>
<h2 id="3-17-tcp-tw-reuse-为什么默认是关闭的？"><a href="#3-17-tcp-tw-reuse-为什么默认是关闭的？" class="headerlink" title="3.17 tcp_tw_reuse 为什么默认是关闭的？"></a>3.17 tcp_tw_reuse 为什么默认是关闭的？</h2><blockquote>
<p>其实这题在变相问「<strong>如果 TIME_WAIT 状态持续时间过短或者没有，会有什么问题？</strong>」因为开启 tcp_tw_reuse 参数可以快速复用处于 TIME_WAIT 状态的 TCP 连接时，相当于缩短了 TIME_WAIT 状态的持续时间。</p>
</blockquote>
<blockquote>
<p>tcp_tw_reuse 的作用是让客户端快速复用处于 TIME_WAIT 状态的端口，相当于跳过了 TIME_WAIT 状态，这可能会出现这样的两个问题：</p>
<ul>
<li>历史 RST 报文可能会终止后面相同四元组的连接，因为 PAWS 检查到即使 RST 是过期的，也不会丢弃。</li>
<li>如果第四次挥手的 ACK 报文丢失了，有可能被动关闭连接的一方不能被正常的关闭;</li>
</ul>
</blockquote>
<h3 id="1、tcp-tw-reuse-是什么？"><a href="#1、tcp-tw-reuse-是什么？" class="headerlink" title="1、tcp_tw_reuse 是什么？"></a>1、tcp_tw_reuse 是什么？</h3><p>在 Linux  操作系统下，TIME_WAIT 状态的持续时间是 60 秒，这意味着这 60 秒内，客户端一直会占用着这个端口。要知道，端口资源也是有限的，一般可以开启的端口为 32768~61000 ，也可以通过如下参数设置指定范围：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">net.ipv4.ip_local_port_range</span><br></pre></td></tr></table></figure>

<p><strong>如果客户端（主动关闭连接方）的 TIME_WAIT 状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务器发起连接了，但是被使用的端口，还是可以继续对另外一个服务器发起连接的。这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。</p>
<p>好在，Linux 操作系统提供了两个可以系统参数来快速回收处于 TIME_WAIT 状态的连接，这两个参数都是默认关闭的：</p>
<ul>
<li>net.ipv4.tcp_tw_reuse，如果开启该选项的话，客户端（连接发起方） 在调用 connect() 函数时，<strong>如果内核选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了</strong>。所以该选项只适用于连接发起方。</li>
<li>net.ipv4.tcp_tw_recycle，如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收，该参数在 <strong>NAT 的网络下是不安全的</strong>！详细见这篇文章介绍：<a href="https://xiaolincoding.com/network/3_tcp/syn_drop.html">SYN 报文什么时候情况下会被丢弃？</a></li>
</ul>
<p>要使得上面这两个参数生效，有一个前提条件，就是要打开 TCP 时间戳，即 net.ipv4.tcp_timestamps&#x3D;1（默认即为 1）。开启了 tcp_timestamps 参数，TCP 头部就会使用时间戳选项，它有两个好处，<strong>一个是便于精确计算 RTT ，另一个是能防止序列号回绕（PAWS）</strong>。</p>
<p>序列号是一个 32 位的无符号整型，上限值是 4GB，超过 4GB  后就需要将序列号回绕进行重用。这在以前网速慢的年代不会造成什么问题，但在一个速度足够快的网络中传输大量数据时，序列号的回绕时间就会变短。如果序列号回绕的时间极短，我们就会再次面临之前延迟的报文抵达后序列号依然有效的问题。</p>
<p>为了解决这个问题，就需要有 TCP 时间戳。</p>
<p>试看下面的示例，假设 TCP 的发送窗口是 1 GB，并且使用了时间戳选项，发送方会为每个 TCP 报文分配时间戳数值，我们假设每个报文时间加 1，然后使用这个连接传输一个 6GB 大小的数据流。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/bf004909d9e44c3bc740737ced6731a0.png" alt="图片"></p>
<p>32 位的序列号在时刻 D 和 E 之间回绕。假设在时刻B有一个报文丢失并被重传，又假设这个报文段在网络上绕了远路并在时刻 F 重新出现。如果 TCP 无法识别这个绕回的报文，那么数据完整性就会遭到破坏。</p>
<p>使用时间戳选项能够有效的防止上述问题，如果丢失的报文会在时刻 F 重新出现，由于它的时间戳为 2，小于最近的有效时间戳（5 或 6），因此防回绕序列号算法（PAWS）会将其丢弃。</p>
<p>防回绕序列号算法要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，<strong>如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包</strong>。</p>
<h3 id="2、为什么-tcp-tw-reuse-默认是关闭的？"><a href="#2、为什么-tcp-tw-reuse-默认是关闭的？" class="headerlink" title="2、为什么 tcp_tw_reuse  默认是关闭的？"></a>2、为什么 tcp_tw_reuse  默认是关闭的？</h3><h4 id="（1）第一个问题"><a href="#（1）第一个问题" class="headerlink" title="（1）第一个问题"></a>（1）第一个问题</h4><p>我们知道开启 tcp_tw_reuse 的同时，也需要开启 tcp_timestamps，意味着可以用时间戳的方式有效的判断回绕序列号的历史报文。但是，防回绕序列号函数的源码中，对于 <strong>RST 报文</strong>， <strong>即使其时间戳过期了，只要 RST 报文的序列号在对方的接收窗口内，也是能被接受的</strong>。</p>
<p>假设有这样的场景：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406102019052.png" alt="img"></p>
<ul>
<li>客户端向一个还没有被服务端监听的端口发起了 HTTP 请求，接着服务端就会回 RST 报文给对方，很可惜的是 <strong>RST 报文被网络阻塞了</strong>。</li>
<li>由于客户端迟迟没有收到 TCP 第二次握手，于是重发了 SYN 包，与此同时服务端已经开启了服务，监听了对应的端口。于是接下来，客户端和服务端就进行了 TCP 三次握手、数据传输（HTTP应答-响应）、四次挥手。</li>
<li>因为<strong>客户端开启了 tcp_tw_reuse，于是快速复用 TIME_WAIT 状态的端口，又与服务端建立了一个与刚才相同的四元组的连接</strong>。</li>
<li>接着，<strong>前面被网络延迟 RST 报文这时抵达了客户端，而且 RST 报文的序列号在客户端的接收窗口内，由于防回绕序列号算法不会防止过期的 RST，所以 RST 报文会被客户端接受了，于是客户端的连接就断开了</strong>。</li>
</ul>
<p>上面这个场景就是开启 tcp_tw_reuse 的风险，<strong>因为快速复用 TIME_WAIT 状态的端口，导致新连接可能被回绕序列号的 RST 报文断开，而如果不跳过 TIME_WAIT 状态，而是停留 2MSL 时长，那么这个 RST 报文就不会出现在下一个新的连接</strong>。</p>
<h4 id="（2）第二个问题"><a href="#（2）第二个问题" class="headerlink" title="（2）第二个问题"></a>（2）第二个问题</h4><p>开启 tcp_tw_reuse 来快速复用 TIME_WAIT 状态的连接，如果第四次挥手的 ACK 报文丢失了，服务端会触发超时重传，重传第三次挥手报文，处于 syn_sent 状态的客户端收到服务端重传第三次挥手报文，则会回 RST 给服务端。如下图：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406102019869.png" alt="img" style="zoom:67%;" />



<h2 id="3-18-TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？"><a href="#3-18-TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？" class="headerlink" title="3.18 TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？"></a>3.18 TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</h2><p>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。</p>
<p>TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。</p>
<h2 id="3-19-端口复用问题"><a href="#3-19-端口复用问题" class="headerlink" title="3.19 端口复用问题"></a>3.19 端口复用问题</h2><h3 id="1、TCP-和-UDP-可以同时绑定相同的端口吗？"><a href="#1、TCP-和-UDP-可以同时绑定相同的端口吗？" class="headerlink" title="1、TCP 和 UDP 可以同时绑定相同的端口吗？"></a>1、TCP 和 UDP 可以同时绑定相同的端口吗？</h3><p>TCP 和 UDP 服务端网络相似的一个地方，就是会调用 bind 绑定端口。</p>
<p>TCP 网络编程如下，服务端执行 listen() 系统调用就是监听端口的动作。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.png" alt="img" style="zoom: 67%;" />

<p>UDP 网络编程如下，服务端是没有监听这个动作的，只有执行  bind()  系统调用来绑定端口的动作。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/udp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.png" alt="img" style="zoom: 80%;" />

<blockquote>
<p>TCP 和 UDP 可以同时绑定相同的端口吗？</p>
</blockquote>
<p>答案：<strong>可以的</strong>。</p>
<p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。</p>
<p>所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。</p>
<p>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。</p>
<p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。因此， TCP&#x2F;UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80 号端口，二者并不冲突。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97.jpeg" alt="img" style="zoom:50%;" />

<h3 id="2、多个-TCP-服务进程可以绑定同一个端口吗？"><a href="#2、多个-TCP-服务进程可以绑定同一个端口吗？" class="headerlink" title="2、多个 TCP 服务进程可以绑定同一个端口吗？"></a>2、多个 TCP 服务进程可以绑定同一个端口吗？</h3><blockquote>
<p>默认情况下，<strong>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”</strong>。</p>
<p>如果想多个进程绑定相同的 IP 地址和端口，也是有办法的，就是对 socket 设置 SO_REUSEPORT 属性。SO_REUSEADDR 作用是：<strong>如果当前启动进程绑定的 IP+PORT 与处于TIME_WAIT 状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了 SO_REUSEADDR 选项，那么该进程就可以绑定成功</strong>。</p>
</blockquote>
<p>默认情况下，<strong>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”</strong>。</p>
<p>注意，如果 TCP 服务进程 A 绑定的地址是  0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是 192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。这是因为 0.0.0.0  地址比较特殊，代表任意地址，意味着绑定了 0.0.0.0  地址，相当于把主机上的所有 IP 地址都绑定了。</p>
<p>如果想多个进程绑定相同的 IP 地址和端口，也是有办法的，就是对 socket 设置 SO_REUSEPORT 属性（内核 3.9 版本提供的新特性）。</p>
<blockquote>
<p>重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？</p>
</blockquote>
<p>当 TCP 服务进程重启之后，总是碰到“Address in use”的报错信息，TCP 服务进程不能很快地重启，而是要过一会才能重启成功。这是因为当我们重启 TCP 服务进程的时候，意味着通过服务器端发起了关闭连接操作，于是就会经过四次挥手，而对于主动关闭方，会在 TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。</p>
<p><strong>当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT  仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind()  函数的时候，就会返回了 Address already in use 的错误</strong>。</p>
<p>而等 TIME_WAIT 状态的连接结束后，重启 TCP 服务进程就能成功。</p>
<blockquote>
<p>重启 TCP 服务进程时，如何避免“Address in use”的报错信息？</p>
</blockquote>
<p>我们可以在调用 bind 前，对 socket 设置 SO_REUSEADDR 属性，可以解决这个问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br></pre></td></tr></table></figure>

<p>因为 SO_REUSEADDR 作用是：<strong>如果当前启动进程绑定的 IP+PORT 与处于TIME_WAIT 状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了 SO_REUSEADDR 选项，那么该进程就可以绑定成功</strong>。</p>
<p>举个例子，服务端有个监听 0.0.0.0 地址和 8888 端口的 TCP 服务进程。‍</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/5.png" alt="img"></p>
<p>有个客户端（IP地址：192.168.1.100）已经和服务端（IP 地址：172.19.11.200）建立了 TCP 连接，那么在 TCP 服务进程重启时，服务端会与客户端经历四次挥手，服务端的 TCP 连接会短暂处于 TIME_WAIT 状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">客户端地址:端口           服务端地址:端口        TCP 连接状态</span><br><span class="line">192.168.1.100:37272     172.19.11.200:8888    TIME_WAI</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 TCP 服务进程没有对 socket 设置 SO_REUSEADDR  属性，那么在重启时，由于存在一个和绑定 IP+PORT 一样的 TIME_WAIT 状态的连接，那么在执行 bind() 函数的时候，就会返回了 Address already in use 的错误；</li>
<li>如果 TCP 服务进程对 socket 设置 SO_REUSEADDR 属性了，那么在重启时，即使存在一个和绑定 IP+PORT 一样的 TIME_WAIT 状态的连接，依然可以正常绑定成功，因此可以正常重启成功。</li>
</ul>
<p>因此，在所有 TCP 服务器程序中，调用 bind 之前最好对 socket 设置 SO_REUSEADDR 属性，这不会产生危害，相反，它会帮助我们在很快时间内重启服务端程序。‍</p>
<p><strong>前面我提到过这个问题</strong>：如果 TCP 服务进程 A 绑定的地址是  0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是 192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。</p>
<p>这个问题也可以由 SO_REUSEADDR 解决，因为它的<strong>另外一个作用</strong>：绑定的 IP地址 + 端口时，只要 IP 地址不是正好(exactly)相同，那么允许绑定。比如，0.0.0.0:8888 和192.168.1.100:8888，虽然逻辑意义上前者包含了后者，但是 0.0.0.0 泛指所有本地 IP，而 192.168.1.100 特指某一IP，两者并不是完全相同，所以在对 socket 设置 SO_REUSEADDR 属性后，那么执行 bind() 时候就会绑定成功。</p>
<h3 id="3、客户端的端口可以重复使用吗？"><a href="#3、客户端的端口可以重复使用吗？" class="headerlink" title="3、客户端的端口可以重复使用吗？"></a>3、客户端的端口可以重复使用吗？</h3><p>TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP  连接的。所以如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992  的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。</p>
<blockquote>
<p>客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？</p>
</blockquote>
<p>针对这个问题要看，客户端是否都是与同一个服务器（目标地址和目标端口一样）建立连接。</p>
<p>如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。</p>
<p>但是，<strong>因为只要客户端连接的服务器不同，端口资源可以重复使用的</strong>。</p>
<p>所以，如果客户端都是与不同的服务器建立连接，即使客户端端口资源只有几万个， 客户端发起百万级连接也是没问题的（当然这个过程还会受限于其他资源，比如文件描述符、内存、CPU 等）。</p>
<blockquote>
<p>如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？</p>
</blockquote>
<p>前面我们提到，如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。</p>
<p>针对这个问题，也是有解决办法的，那就是在客户端打开 <code>net.ipv4.tcp_tw_reuse</code> 这个内核参数。</p>
<p><strong>因为开启了这个内核参数后，客户端调用 connect  函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于  TIME_WAIT  状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1  秒，那么就会重用这个连接，然后就可以正常使用该端口了。</strong></p>
<p>再次提醒一次，开启了 net.ipv4.tcp_tw_reuse  内核参数，是客户端（连接发起方） 在调用 connect() 函数时才起作用，所以在服务端开启这个参数是没有效果的。</p>
<blockquote>
<p>客户端端口选择的流程总结</p>
</blockquote>
<p>至此，我们已经把客户端在执行 connect 函数时，内核选择端口的情况大致说了一遍，为了让大家更明白客户端端口的选择过程，我画了一流程图。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/%E7%AB%AF%E5%8F%A3%E9%80%89%E6%8B%A9.jpg" alt="img"></p>
<h3 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、<strong>总结</strong></h3><blockquote>
<p>TCP 和 UDP 可以同时绑定相同的端口吗？</p>
</blockquote>
<p>可以的。</p>
<p>TCP 和 UDP 传输协议，在内核中是由两个完全独立的软件模块实现的。</p>
<p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p>
<p>因此， TCP&#x2F;UDP 各自的端口号也相互独立，互不影响。</p>
<blockquote>
<p>多个 TCP 服务进程可以同时绑定同一个端口吗？</p>
</blockquote>
<p>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。</p>
<p>如果两个 TCP 服务进程绑定的端口都相同，而 IP 地址不同，那么执行 bind() 不会出错。</p>
<blockquote>
<p>如何解决服务端重启时，报错“Address already in use”的问题？</p>
</blockquote>
<p>当我们重启 TCP 服务进程的时候，意味着通过服务器端发起了关闭连接操作，于是就会经过四次挥手，而对于主动关闭方，会在 TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。</p>
<p>当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT  仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind()  函数的时候，就会返回了 Address already in use 的错误。</p>
<p>要解决这个问题，我们可以对 socket 设置 SO_REUSEADDR 属性。</p>
<p>这样即使存在一个和绑定 IP+PORT 一样的 TIME_WAIT 状态的连接，依然可以正常绑定成功，因此可以正常重启成功。</p>
<blockquote>
<p>客户端的端口可以重复使用吗？</p>
</blockquote>
<p>在客户端执行 connect 函数的时候，只要客户端连接的服务器不是同一个，内核允许端口重复使用。</p>
<p>TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。</p>
<p>所以，如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。</p>
<blockquote>
<p>客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？</p>
</blockquote>
<p>要看客户端是否都是与同一个服务器（目标地址和目标端口一样）建立连接。</p>
<p>如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT  状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。即使在这种状态下，还是可以与其他服务器建立连接的，只要客户端连接的服务器不是同一个，那么端口是重复使用的。</p>
<blockquote>
<p>如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？</p>
</blockquote>
<p>打开 net.ipv4.tcp_tw_reuse  这个内核参数。</p>
<p>因为开启了这个内核参数后，客户端调用 connect  函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于  TIME_WAIT 状态。</p>
<p>如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。</p>
<h2 id="3-20-服务端没有-listen，客户端发起连接建立，会发生什么？"><a href="#3-20-服务端没有-listen，客户端发起连接建立，会发生什么？" class="headerlink" title="3.20 服务端没有 listen，客户端发起连接建立，会发生什么？"></a>3.20 服务端没有 listen，客户端发起连接建立，会发生什么？</h2><blockquote>
<p>服务端如果只 bind了 ip 和端口，但是没有调用 listen 让这个 socket 监听连接，这时候如果客户端朝这个服务端 socket 发数据，会发生啥？</p>
</blockquote>
<p>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，此时客户端对服务端发起连接建立，服务端会回 RST 报文。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>Linux 内核处理收到 TCP 报文的入口函数是  tcp_v4_rcv，在收到 TCP 报文后，会调用 __inet_lookup_skb 函数找到 TCP 报文所属 socket 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">  </span><br><span class="line"> sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, th-&gt;source, th-&gt;dest);</span><br><span class="line"> <span class="keyword">if</span> (!sk)</span><br><span class="line">  <span class="keyword">goto</span> no_tcp_socket;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__inet_lookup_skb</code> 函数首先查找连接建立状态的socket（<code>__inet_lookup_established</code>），在没有命中的情况下，才会查找监听套接口（<code>__inet_lookup_listener</code>）。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/88416aa95d255495e07fb3a002b2167b.png" alt="图片"></p>
<p>查找监听套接口（<code>__inet_lookup_listener</code>）这个函数的实现是，<strong>根据目的地址和目的端口算出一个哈希值，然后在哈希表找到对应监听该端口的 socket。</strong>本次的案例中，服务端是没有调用 listen 函数的，所以自然也是找不到监听该端口的 socket。所以，__inet_lookup_skb 函数最终找不到对应的 socket，于是跳转到no_tcp_socket。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/54ee363e149ee3dfba30efb1a542ef5c.png" alt="图片"></p>
<p>在这个错误处理中，只要收到的报文（skb）的「校验和」没问题的话，内核就会调用 tcp_v4_send_reset 发送 RST 中止这个连接。</p>
<p>至此，整个源码流程就解析完。</p>
<h2 id="3-21-没有-listen，能建立-TCP-连接吗？"><a href="#3-21-没有-listen，能建立-TCP-连接吗？" class="headerlink" title="3.21 没有 listen，能建立 TCP 连接吗？"></a>3.21 没有 listen，能建立 TCP 连接吗？</h2><blockquote>
<p>不使用 listen ，可以建立 TCP 连接吗？</p>
</blockquote>
<p>答案，<strong>是可以的，客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有listen，就能建立连接</strong>。</p>
<blockquote>
<p>那没有listen，为什么还能建立连接？</p>
</blockquote>
<p>我们知道执行 listen 方法时，会创建半连接队列和全连接队列。三次握手的过程中会在这两个队列中暂存连接信息。所以形成连接，前提是你得有个地方存放着，方便握手的时候能根据 IP + 端口等信息找到对应的 socket。</p>
<blockquote>
<p>那么客户端会有半连接队列吗？</p>
</blockquote>
<p>显然没有，因为客户端没有执行listen，而半连接队列和全连接队列都是在执行 listen 方法时，内核自动创建的。但内核还有个全局 hash 表，可以用于存放 sock 连接的信息。这个全局 hash 表其实还细分为 ehash，bhash和listen_hash等，但因为过于细节，大家理解成有一个全局 hash 就够了，</p>
<p><strong>在 TCP 自连接的情况中，客户端在 connect 方法时，最后会将自己的连接信息放入到这个全局 hash  表中，然后将信息发出，消息在经过回环地址重新回到 TCP 传输层的时候，就会根据 IP + 端口信息，再一次从这个全局 hash  中取出信息。于是握手包一来一回，最后成功建立连接</strong>。</p>
<p>TCP 同时打开的情况也类似，只不过从一个客户端变成了两个客户端而已。</p>
<h2 id="3-22-TCP-四次挥手，可以变成三次吗？"><a href="#3-22-TCP-四次挥手，可以变成三次吗？" class="headerlink" title="3.22 TCP 四次挥手，可以变成三次吗？"></a>3.22 TCP 四次挥手，可以变成三次吗？</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406102122868.png" alt="在这里插入图片描述" style="zoom: 80%;" />

<blockquote>
<p>当被动关闭方在 TCP 挥手过程中，<strong>如果「没有数据要发送」，同时「没有开启 TCP_QUICKACK（默认情况就是没有开启，没有开启  TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制）」</strong>，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</p>
</blockquote>
<p><strong>所以，出现三次挥手现象，是因为 TCP 延迟确认机制导致的。</strong></p>
<blockquote>
<p>什么是  TCP 延迟确认机制？</p>
</blockquote>
<p>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。 TCP 延迟确认的策略：</p>
<ul>
<li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li>
<li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li>
<li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li>
</ul>
<img src="https://cdn.xiaolincoding.com//mysql/other/33f3d2d54a924b0a80f565038327e0e4.png" alt="img" style="zoom: 67%;" />

<h2 id="3-23-TCP-序列号和确认号是如何变化的？"><a href="#3-23-TCP-序列号和确认号是如何变化的？" class="headerlink" title="3.23 TCP 序列号和确认号是如何变化的？"></a>3.23 TCP 序列号和确认号是如何变化的？</h2><ul>
<li>三次握手中 TCP 序列号和确认号的变化</li>
<li>数据传输中 TCP 序列号和确认号的变化</li>
<li>四次挥手中 TCP 序列号和确认号的变化</li>
</ul>
<h3 id="1、万能公式"><a href="#1、万能公式" class="headerlink" title="1、万能公式"></a>1、万能公式</h3><p>我根据经验总结了一条万能公式。</p>
<p><strong>发送的 TCP 报文：</strong></p>
<ul>
<li><strong>公式一：序列号 &#x3D; 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</strong></li>
<li><strong>公式二：确认号 &#x3D; 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</strong></li>
</ul>
<p>TCP 序列号和确认号在 TCP 头部的位置：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/41da16ec3ea04e27bcb35a93c0193855.png" alt="在这里插入图片描述" style="zoom:50%;" />

<p>这里重点关注这三个字段的作用：</p>
<ul>
<li><strong>序列号</strong>：在建立连接时由内核生成的随机数作为其初始值，通过 SYN 报文传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></li>
<li><strong>确认号</strong>：指下一次「期望」收到的数据的序列号，发送端收到接收方发来的 ACK 确认报文以后，就可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></li>
<li><strong>控制位：</strong>用来标识 TCP 报文是什么类型的报文，比如是 SYN 报文、数据报文、ACK 报文，FIN 报文等。</li>
</ul>
<h3 id="2、三次握手阶段的变化"><a href="#2、三次握手阶段的变化" class="headerlink" title="2、三次握手阶段的变化"></a>2、三次握手阶段的变化</h3><p>先来说说三次握手中 TCP 序列号和确认号的变化。</p>
<p>假设客户端的初始化序列号为 client_isn，服务端的初始化序列号为 server_isn，TCP 三次握手的流程如下：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/06c4ed62087040438f86ba64e9e609e7.png" alt="在这里插入图片描述" style="zoom:50%;" />

<blockquote>
<p>为什么第二次和第三次握手报文中的确认号是将对方的序列号 + 1 后作为确认号呢？</p>
</blockquote>
<p>SYN 报文是特殊的 TCP 报文，用于建立连接时使用，虽然 SYN 报文不携带用户数据，但是 <strong>TCP 将 SYN 报文视为 1 字节的数据</strong>，当对方收到了 SYN 报文后，在回复 ACK 报文时，就需要将 ACK 报文中的确认号设置为 SYN 的序列号 + 1 ，这样做是有两个目的：</p>
<ul>
<li><strong>告诉对方，我方已经收到 SYN 报文。</strong></li>
<li><strong>告诉对方，我方下一次「期望」收到的报文的序列号为此确认号，比如客户端与服务端完成三次握手之后，服务端接下来期望收到的是序列号为  client_isn + 1 的 TCP 数据报文。</strong></li>
</ul>
<h3 id="2、数据传输阶段的变化"><a href="#2、数据传输阶段的变化" class="headerlink" title="2、数据传输阶段的变化"></a>2、数据传输阶段的变化</h3><p>完成了，三次握手后，客户端就可以发送第一个 ** **TCP 数据报文了，假设客户端即将要发送 10 字节的数据，流程图下：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/dadf9a94328a4446b32ebabf1623c729.png" alt="在这里插入图片描述" style="zoom:50%;" />

<p>可以看到，<strong>客户端与服务端完成 TCP 三次握手后，发送的第一个 「TCP 数据报文的序列号和确认号」都是和「第三次握手的 ACK 报文中序列号和确认号」一样的</strong>。</p>
<blockquote>
<p>之前有读者问，如果客户端发送的第三次握手  ACK 报文丢失了，处于 SYN_RCVD 状态服务端收到了客户端第一个 TCP 数据报文会发生什么？</p>
</blockquote>
<p>刚才前面我也说了，发送的第一个 「TCP 数据报文的序列号和确认号」都是和「第三次握手的 ACK 报文中序列号和确认号」一样的，并且该 TCP 数据报文也有将 ACK 标记位置为 1。如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/942c2a1e67224c8c8bd41b13d7c89a96.png" alt="在这里插入图片描述"></p>
<p>所以，服务端收到这个数据报文，是可以正常完成连接的建立，然后就可以正常接收这个数据包了。</p>
<h3 id="4、四次挥手阶段的变化"><a href="#4、四次挥手阶段的变化" class="headerlink" title="4、四次挥手阶段的变化"></a>4、四次挥手阶段的变化</h3><p>最后，我们来看看四次挥手阶段中，序列号和确认号的变化。</p>
<p>数据传输阶段结束后，客户端发起了 FIN 报文，请求服务端端开该 TCP 连接，此时就进入了 TCP 四次挥手阶段，如下图。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/ae18cbf6071c47b98014a68d05c37d16.png" alt="在这里插入图片描述" style="zoom:50%;" />

<h2 id="3-24-TCP快速打开（TFO）"><a href="#3-24-TCP快速打开（TFO）" class="headerlink" title="3.24 TCP快速打开（TFO）"></a>3.24 TCP快速打开（TFO）</h2><h2 id="3-25-TCP报文中的时间戳有什么作用？"><a href="#3-25-TCP报文中的时间戳有什么作用？" class="headerlink" title="3.25 TCP报文中的时间戳有什么作用？"></a>3.25 TCP报文中的时间戳有什么作用？</h2><p>TCP Timestamps Option 由四部分构成：</p>
<p>类别（kind）、长度（Length）、发送⽅时间戳（TS value）、回显时间戳（TS Echo Reply）。</p>
<p>TCP 的时间戳主要解决两⼤问题：</p>
<ul>
<li><p><strong>计算往返时延 RTT(Round-Trip Time)：</strong></p>
<p>在启⽤ Timestamps 选项以后，因为 ACK 包⾥包含了 TSval 和 TSecr，这样⽆论是正常确认包，还是</p>
<p>重传确认包，都可以通过这两个值计算出 RTT。</p>
</li>
<li><p><strong>防止序列号的回绕问题：</strong></p>
<p>TCP 的序列号⽤ 32bit 来表示，因此在 2^32 字节的数据传输后序列号就会溢出回绕。TCP 的窗⼝经过</p>
<p>窗⼝缩放可以最⾼到 1GB（2^30)，在⾼速⽹络中，序列号在很短的时间内就会被重复使⽤。</p>
</li>
</ul>
<h2 id="3-26-TCP场景问题"><a href="#3-26-TCP场景问题" class="headerlink" title="3.26 TCP场景问题"></a>3.26 TCP场景问题</h2><h3 id="1、收到-IP-数据包解析以后，怎么知道这个分组应该投递到上层的哪一个协议（UDP-或-TCP）？"><a href="#1、收到-IP-数据包解析以后，怎么知道这个分组应该投递到上层的哪一个协议（UDP-或-TCP）？" class="headerlink" title="1、收到 IP 数据包解析以后，怎么知道这个分组应该投递到上层的哪一个协议（UDP 或 TCP）？"></a>1、收到 IP 数据包解析以后，怎么知道这个分组应该投递到上层的哪一个协议（UDP 或 TCP）？</h3><p>通过查看 IP 头部中的 “协议字段”（Protocol field）来实现的。</p>
<ol>
<li><strong>接收 IP 数据包</strong>： 当一个 IP 数据包到达时，首先由网络层（即 IP 协议栈）进行处理。此时，系统会解析 IP 头部以提取相关信息。</li>
<li><strong>解析 IP 头部</strong>： IP 头部包含了很多重要的信息，其中包括源地址、目的地址、总长度、标识、片偏移、TTL（生存时间）、协议字段等。我们关心的是其中的协议字段。</li>
<li><strong>检查协议字段</strong>： IP 头部中的协议字段（Protocol field）位于 IP 头部的第 9 个字节。这个字段是一个 8 位的值，用来指示上层协议的类型。不同的协议有不同的编号：<ul>
<li>6：TCP（传输控制协议）</li>
<li>17：UDP（用户数据报协议）</li>
<li>1：ICMP（互联网控制消息协议）</li>
<li>其他值：对应其他上层协议</li>
</ul>
</li>
<li><strong>投递到相应的上层协议</strong>： 根据协议字段的值，IP 协议栈会将数据包投递到相应的上层协议处理程序。例如：<ul>
<li>如果协议字段的值是 6，系统会将数据包投递到 TCP 协议栈处理。</li>
<li>如果协议字段的值是 17，系统会将数据包投递到 UDP 协议栈处理。</li>
</ul>
</li>
</ol>
<h3 id="2、TCP-提供了⼀种字节流服务，而收发双方都不保持记录的边界，应用程序应该如何提供他们自己的记录标识呢？"><a href="#2、TCP-提供了⼀种字节流服务，而收发双方都不保持记录的边界，应用程序应该如何提供他们自己的记录标识呢？" class="headerlink" title="2、TCP 提供了⼀种字节流服务，而收发双方都不保持记录的边界，应用程序应该如何提供他们自己的记录标识呢？"></a>2、TCP 提供了⼀种字节流服务，而收发双方都不保持记录的边界，应用程序应该如何提供他们自己的记录标识呢？</h3><p>应⽤程序使⽤⾃⼰约定的规则来表示消息的边界，⽐如有⼀些使⽤回⻋+换⾏（”\r\n”），⽐如 Redis的通信协议（RESP protocol）。</p>
<h2 id="3-27-telnet的用法"><a href="#3-27-telnet的用法" class="headerlink" title="3.27 telnet的用法"></a>3.27 telnet的用法</h2><p>Telnet 是一个网络协议和程序，允许用户通过命令行接口登录到远程计算机或网络设备。它使用 TCP 端口 23，提供一个简单的、未加密的通信方式，适用于访问和管理远程设备。</p>
<h3 id="1、连接到远程主机"><a href="#1、连接到远程主机" class="headerlink" title="1、连接到远程主机"></a>1、连接到远程主机</h3><p>要使用 Telnet 连接到远程主机，可以在命令行输入以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">telnet [hostname] [port]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>[hostname]</code> 是远程主机的 IP 地址或域名。</li>
<li><code>[port]</code> 是可选的端口号。如果未指定，默认端口为 23。</li>
</ul>
<p>例如，连接到 IP 地址为 <code>192.168.1.1</code> 的主机：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">telnet 192.168.1.1</span><br></pre></td></tr></table></figure>

<p>或连接到 <code>example.com</code> 的主机：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">telnet example.com</span><br></pre></td></tr></table></figure>

<h3 id="2、检查端口是否开放"><a href="#2、检查端口是否开放" class="headerlink" title="2、检查端口是否开放"></a>2、检查端口是否开放</h3><p>Telnet 还可以用于检查某个端口是否在远程主机上开放。例如，检查 <code>example.com</code> 上的端口 80：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">telnet example.com 80</span><br></pre></td></tr></table></figure>

<p>如果连接成功，表示端口 80 是开放的。</p>
<h3 id="3、使用-Telnet-脚本自动化任务"><a href="#3、使用-Telnet-脚本自动化任务" class="headerlink" title="3、使用 Telnet 脚本自动化任务"></a>3、使用 Telnet 脚本自动化任务</h3><p>Telnet 客户端支持自动化脚本，可以使用 Expect 等工具来实现自动化。例如，使用 Expect 脚本登录远程主机并执行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/expect -f</span></span><br><span class="line"></span><br><span class="line">spawn telnet 192.168.1.1</span><br><span class="line">expect <span class="string">&quot;login:&quot;</span></span><br><span class="line">send <span class="string">&quot;your_username\r&quot;</span></span><br><span class="line">expect <span class="string">&quot;Password:&quot;</span></span><br><span class="line">send <span class="string">&quot;your_password\r&quot;</span></span><br><span class="line">expect <span class="string">&quot;$&quot;</span></span><br><span class="line">send <span class="string">&quot;ls -la\r&quot;</span></span><br><span class="line">expect <span class="string">&quot;$&quot;</span></span><br><span class="line">send <span class="string">&quot;exit\r&quot;</span></span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure>

<p>将上述内容保存为 <code>telnet_script.exp</code>，然后运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">expect telnet_script.exp</span><br></pre></td></tr></table></figure>

<h2 id="3-28-netstat的⽤法"><a href="#3-28-netstat的⽤法" class="headerlink" title="3.28 netstat的⽤法"></a>3.28 netstat的⽤法</h2><p>netstat 命令⽤于显示各种⽹络相关信息。</p>
<p>常⻅参数</p>
<blockquote>
<p>-a (all)显示所有选项，默认不显示LISTEN相关</p>
<p>-t (tcp)仅显示tcp相关选项</p>
<p>-u (udp)仅显示udp相关选项</p>
<p>-n 拒绝显示别名，能显示数字的全部转化成数字。</p>
<p>-l 仅列出有在 Listen (监听) 的服務状态</p>
<p>-p 显示建⽴相关链接的程序名</p>
<p>-r 显示路由信息，路由表</p>
<p>-e 显示扩展信息，例如uid等</p>
<p>-s 按各个协议进⾏统计</p>
<p>-c 每隔⼀个固定时间，执⾏该netstat命令</p>
</blockquote>
<h2 id="3-29-tcpdump"><a href="#3-29-tcpdump" class="headerlink" title="3.29 tcpdump"></a>3.29 tcpdump</h2><h2 id="3-30-wireshark"><a href="#3-30-wireshark" class="headerlink" title="3.30 wireshark"></a>3.30 wireshark</h2><h2 id="3-31-如果要设计一个QQ，在网络协议上如何设计？"><a href="#3-31-如果要设计一个QQ，在网络协议上如何设计？" class="headerlink" title="3.31 如果要设计一个QQ，在网络协议上如何设计？"></a>3.31 如果要设计一个QQ，在网络协议上如何设计？</h2><p>登陆采用TCP协议和HTTP协议，你和好友之间发送消息，主要采用UDP协议，内⽹传⽂件采用了P2P技术。</p>
<p>总的来说：</p>
<ol>
<li><p>登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会有⼀个TCP连接来保持在线状态。</p>
</li>
<li><p>和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。</p>
</li>
<li><p>如果是在内网里面的两个客户端传⽂件，QQ采用的是P2P技术，不需要服务器中转。</p>
</li>
</ol>
<h2 id="3-32-用了TCP协议，一定不会丢包吗？"><a href="#3-32-用了TCP协议，一定不会丢包吗？" class="headerlink" title="3.32 用了TCP协议，一定不会丢包吗？"></a>3.32 用了TCP协议，一定不会丢包吗？</h2><h3 id="1、数据包的发送流程"><a href="#1、数据包的发送流程" class="headerlink" title="1、数据包的发送流程"></a>1、数据包的发送流程</h3><ol>
<li>把消息从用户空间拷贝到内核空间的发送缓冲区(send_buffer)；</li>
<li>顺着传输层、网络层，通过 Qdisc(排队规则) 进行流控进入到数据链路层；</li>
<li>通过 RingBuffer 发送到物理层的网卡；</li>
<li>目的机器 DMA 从网卡收包到 RingBuffer，网卡触发硬中断给 CPU；</li>
<li>CPU触发软中断让 ksoftirqd 去 RingBuffer收包，按着协议栈向上传输。</li>
</ol>
<h3 id="2、几个丢包的可能性"><a href="#2、几个丢包的可能性" class="headerlink" title="2、几个丢包的可能性"></a>2、几个丢包的可能性</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111917261.png" alt="image-20240611191756056" style="zoom: 67%;" />

<h2 id="3-33-如何基于UDP实现可靠传输？"><a href="#3-33-如何基于UDP实现可靠传输？" class="headerlink" title="3.33 如何基于UDP实现可靠传输？"></a>3.33 如何基于UDP实现可靠传输？</h2><h3 id="1、QUIC如何实现可靠传输？"><a href="#1、QUIC如何实现可靠传输？" class="headerlink" title="1、QUIC如何实现可靠传输？"></a>1、QUIC如何实现可靠传输？</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111919871.png" alt="image-20240611191943734"></p>
<h3 id="2、QUIC如何解决TCP队头阻塞问题？"><a href="#2、QUIC如何解决TCP队头阻塞问题？" class="headerlink" title="2、QUIC如何解决TCP队头阻塞问题？"></a>2、QUIC如何解决TCP队头阻塞问题？</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111919210.png" alt="image-20240611191958139"></p>
<h3 id="3、QUIC如何做流量控制？"><a href="#3、QUIC如何做流量控制？" class="headerlink" title="3、QUIC如何做流量控制？"></a>3、QUIC如何做流量控制？</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111920242.png" alt="image-20240611192007166"></p>
<h3 id="4、QUIC更快的连接建立"><a href="#4、QUIC更快的连接建立" class="headerlink" title="4、QUIC更快的连接建立"></a>4、QUIC更快的连接建立</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111920442.png" alt="image-20240611192013378"></p>
<h3 id="5、QUIC如何迁移连接？"><a href="#5、QUIC如何迁移连接？" class="headerlink" title="5、QUIC如何迁移连接？"></a>5、QUIC如何迁移连接？</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111920900.png" alt="image-20240611192018839"></p>
]]></content>
      <categories>
        <category>面试</category>
        <category>八股</category>
      </categories>
  </entry>
  <entry>
    <title>STL标准库与泛型编程</title>
    <url>/2024/04/29/Computer/C++/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/STL%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://lishizheng.blog.csdn.net/article/details/135440545">STL标准库与泛型编程（侯捷）笔记1</a></p>
<p>3 容器之分类与各种测试（一）：array<br>4 容器之分类与各种测试（二）：vector<br>5 容器之分类与各种测试（三）list, deque,stack, queue<br>6 容器之分类与各种测试（四）：set和unordered_set等<br>7 分配器之测试</p>
<span id="more"></span>

<p><a href="https://lishizheng.blog.csdn.net/article/details/135440667">STL标准库与泛型编程（侯捷）笔记2</a></p>
<p>8 源代码之分布 VCGcc<br>9 OOP 面向对象编程 vs GP 泛型编程<br>10 技术基础：操作符重载and模板泛化, 全特化, 偏特化<br>11 分配器<br>12 容器之间的实现关系与分类<br>13 深度探索list（上）<br>14 深度探索list（下）<br>15 迭代器的设计原则和Iterator Traits的作用与设计</p>
<p><a href="https://lishizheng.blog.csdn.net/article/details/135440862">STL标准库与泛型编程（侯捷）笔记3</a></p>
<p>16 vector深度探索<br>17 array、forward list深度探索<br>18 deque、queue和 stack深度探索（上）<br>     容器deque<br>19 deque、queue和 stack深度探索（下）<br>     容器queue<br>     容器stack<br>     queue和stack，关于其iterator和底层结构</p>
<p><a href="https://lishizheng.blog.csdn.net/article/details/135456907">STL标准库与泛型编程（侯捷）笔记4</a></p>
<p>20 RB tree 深度探索<br>21 set、multiset深度探索<br>22 map、multimap深度探索<br>23 hashtable深度探索（上）<br>24 hashtable深度探索（下）<br>25 hash set、hash multiset, hash map、hash multimap概念<br>26 unordered容器概念</p>
<p><a href="https://lishizheng.blog.csdn.net/article/details/135474126">STL标准库与泛型编程（侯捷）笔记5</a></p>
<p>27 算法的形式<br>28 迭代器的分类（category）<br>29 迭代器分类（category）对算法的影响<br>30 算法源代码剖析（11个例子）<br>31 仿函数和函数对象<br>32 存在多种Adapter<br>33 函数适配器Binder2nd<br>34 函数适配器not1<br>35 新型适配器bind<br>36 迭代器适配器reverse iterator<br>37 迭代器适配器inserter<br>38 ostream iterator<br>39 istream iterator</p>
<p><a href="https://lishizheng.blog.csdn.net/article/details/135481367">STL标准库与泛型编程（侯捷）笔记6</a></p>
<p>40 一个万用的hash function<br>41 Tuple 用例<br>42 type traits<br>43 type traits 实现<br>44 cout<br>45 movable元素对于不同容器速度效能的影响<br>46 测试函数</p>
]]></content>
      <categories>
        <category>Computer</category>
        <category>C++</category>
        <category>侯捷C++系列</category>
      </categories>
  </entry>
  <entry>
    <title>内存管理机制</title>
    <url>/2024/04/30/Computer/C++/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="第一讲-Primitives"><a href="#第一讲-Primitives" class="headerlink" title="第一讲 Primitives"></a>第一讲 Primitives</h1><h2 id="2-内存分配的每一层面"><a href="#2-内存分配的每一层面" class="headerlink" title="2 内存分配的每一层面"></a>2 内存分配的每一层面</h2><blockquote>
<ul>
<li>C++内存分配的深度一般是有五个层面，它们分别是<ul>
<li>C++ application 常见：vector等容器</li>
<li>C++ allocator 常见：vector自带的allocator分配器</li>
<li>C++ primitives 常见：new delete</li>
<li>CRT 常见：malloc free</li>
<li>OS API 常见：heapalloc等等</li>
</ul>
</li>
</ul>
<p>一般情况下，为了保证可移植性质，一般最底层就到了malloc free，如果调用OS API就基本上丧失了可移植性质。每一个层面的对应的基本上都会依次向下调用，然后进行内存的分配。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404301822840.png" alt="4_内存管理_01"></p>
<p>C++ memory primitives</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302008310.png" alt="4_内存管理_02"></p>
<h2 id="3-四个层面的基本用法"><a href="#3-四个层面的基本用法" class="headerlink" title="3 四个层面的基本用法"></a>3 四个层面的基本用法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>				 <span class="comment">//std::allocator  </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext\pool_allocator.h&gt;</span>	 <span class="comment">//欲使用 std::allocator 以外的 allocator, 就得自行 #include &lt;ext/...&gt; </span></span></span><br><span class="line"><span class="keyword">namespace</span> jj01</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_primitives</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\ntest_primitives().......... \n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="type">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">512</span>);	<span class="comment">//512 bytes</span></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">    complex&lt;<span class="type">int</span>&gt;* p2 = <span class="keyword">new</span> complex&lt;<span class="type">int</span>&gt;; <span class="comment">//one object</span></span><br><span class="line">    <span class="keyword">delete</span> p2;             </span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p3 = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="number">512</span>); <span class="comment">//512 bytes</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下使用 C++ 標準庫提供的 allocators。</span></span><br><span class="line"><span class="comment">//其接口雖有標準規格，但實現廠商並未完全遵守；下面三者形式略異。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">    <span class="comment">//以下兩函數都是 non-static，定要通過 object 調用。以下分配 3 個 ints.</span></span><br><span class="line">    <span class="type">int</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">3</span>, (<span class="type">int</span>*)<span class="number">0</span>); </span><br><span class="line">    <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p4,<span class="number">3</span>);           </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __BORLANDC__</span></span><br><span class="line">    <span class="comment">//以下兩函數都是 non-static，定要通過 object 調用。以下分配 5 個 ints.</span></span><br><span class="line">    <span class="type">int</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">5</span>);  </span><br><span class="line">    <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p4,<span class="number">5</span>);       </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line">    <span class="comment">//以下兩函數都是 static，可通過全名調用之。以下分配 512 bytes.(GNUC 2.9)</span></span><br><span class="line">    <span class="comment">//void* p4 = alloc::allocate(512); </span></span><br><span class="line">    <span class="comment">//alloc::deallocate(p4,512);   </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下兩函數都是 non-static，定要通過 object 調用。以下分配 7 個 ints.(GNUC 4.9) </span></span><br><span class="line">	<span class="type">void</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">7</span>); </span><br><span class="line">    <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="type">int</span>*)p4,<span class="number">7</span>);     </span><br><span class="line">	</span><br><span class="line">    <span class="comment">//以下兩函數都是 non-static，定要通過 object 調用。以下分配 9 個 ints.(GNUC 4.9) 	</span></span><br><span class="line">	<span class="type">void</span>* p5 = __gnu_cxx::__pool_alloc&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">9</span>); </span><br><span class="line">    __gnu_cxx::__pool_alloc&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="type">int</span>*)p5,<span class="number">9</span>);	</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;	</span><br><span class="line">&#125; <span class="comment">//namespace</span></span><br></pre></td></tr></table></figure>

<h2 id="4-基本构件之一new-delete-expression上"><a href="#4-基本构件之一new-delete-expression上" class="headerlink" title="4 基本构件之一new delete expression上"></a>4 基本构件之一new delete expression上</h2><ul>
<li>new expression（即new operator）（详见<a href="https://hioomph.github.io/2024/04/24/Computer/C++/new%E4%B8%8Eoperator%20new/">new与operator new</a>）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302012729.png" alt="https://hioomph.github.io/2024/04/24/Computer/C++/new%E4%B8%8Eoperator%20new/"></p>
<ul>
<li><p>右上角的operator new的实现（VC98版）</p>
<ol>
<li>调用malloc函数；</li>
<li>若malloc无法分配内存，就一直在while循环中：调用_callnewh，即一个new handler，用于处理内存分配失败的情况。</li>
</ol>
<blockquote>
<p>_callnewh 不是 C++ 标准中的函数，而是可能是用户定义的一个函数。通常情况下，这类函数的名字以 _new_handler 结尾，用于处理内存分配失败的情况。</p>
<p>在 C++ 中，当 new 表达式无法分配所需的内存时，会调用用户指定的 new_handler 函数。new_handler 是一个函数指针，指向一个用户定义的函数，其原型通常为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数可以尝试释放内存、扩大内存池，或者执行其他操作来尝试解决内存不足的问题。如果 new_handler 能够成功处理内存不足的情况，它返回；如果不能处理，它可以选择抛出异常或者终止程序。</p>
</blockquote>
</li>
</ul>
<h2 id="5-基本构件之一new-delete-expression中"><a href="#5-基本构件之一new-delete-expression中" class="headerlink" title="5 基本构件之一new delete expression中"></a>5 基本构件之一new delete expression中</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302021318.png" alt="4_内存管理_06"></p>
<h2 id="6-基本构件之一new-delete-expression下"><a href="#6-基本构件之一new-delete-expression下" class="headerlink" title="6 基本构件之一new delete expression下"></a>6 基本构件之一new delete expression下</h2><p>下面显示不能直接调用构造函数，而只有编译器会进行隐式调用。调用时在vc6编译通过，在GCC中编译失败。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A* pA = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">1</span>);         	<span class="comment">//ctor. this=000307A8 id=1</span></span><br><span class="line">cout &lt;&lt; pA-&gt;id &lt;&lt; endl;   	<span class="comment">//1</span></span><br><span class="line"><span class="comment">//!	pA-&gt;A::A(3);                //in VC6 : ctor. this=000307A8 id=3</span></span><br><span class="line">  								<span class="comment">//in GCC : [Error] cannot call constructor &#x27;jj02::A::A&#x27; directly</span></span><br><span class="line">  								</span><br><span class="line"><span class="comment">//!	A::A(5);	  				//in VC6 : ctor. this=0013FF60 id=5</span></span><br><span class="line">                      			<span class="comment">//         dtor. this=0013FF60  	</span></span><br><span class="line">  								<span class="comment">//in GCC : [Error] cannot call constructor &#x27;jj02::A::A&#x27; directly</span></span><br><span class="line">  								<span class="comment">//         [Note] for a function-style cast, remove the redundant &#x27;::A&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-Array-new"><a href="#7-Array-new" class="headerlink" title="7 Array new"></a>7 Array new</h2><p>（1）array new和array delete的搭配使用</p>
<p>如果<code>new[]</code>不搭配<code>delete[]</code>的话，实际上是针对<code>class with pointer member</code>的情况造成内存泄漏。<strong>此时若调用<code>delete</code>，带有<code>cookie</code>的动态数组部分实际上仍然会被回收，发生错误的地方是需要调用3次析构函数（如下图右边），但实际上只调用了1次，因此造成内存泄漏</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Complex* pca = <span class="keyword">new</span> Complex[<span class="number">3</span>];  <span class="comment">// 调用三次构造函数</span></span><br><span class="line"><span class="keyword">delete</span>[] pca;  <span class="comment">// 唤起三次析构函数， 这是正确的</span></span><br><span class="line"></span><br><span class="line">string* psa = <span class="keyword">new</span> string[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> psa;  <span class="comment">// 唤起一次析构函数，这是错误的</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302024595.png" alt="4_内存管理_08"></p>
<p>（2）array size in memory size</p>
<ul>
<li>右侧的图是new int[10]的内存布局，其中：<strong>灰色</strong>表示具体数据，<strong>橙色</strong>表示debug模式下添加的内存，最上面和最下面的两个0x61(61H)是cookie，记录整体内存分配的大小；<strong>浅蓝色</strong>的pad表示补齐，填补到16的倍数。<ul>
<li>61H实际上是60H，表示内存分配的大小，后面1H意思是占用最后一位，表示内存分配出去</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302027115.png" alt="4_内存管理_10"></p>
<h2 id="8-placement-new"><a href="#8-placement-new" class="headerlink" title="8 placement new"></a>8 placement new</h2><p>palcement new允许我们将object建构于allocated memory中。<strong>没有所谓的placement new，因为placement new根本没分配memory。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">sizeof</span>(Complex) * <span class="number">3</span>]; <span class="comment">// 已经分配了内存</span></span><br><span class="line">Complex* pc = <span class="built_in">new</span>(buf)<span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 把上面分配的内存位置传进来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br></pre></td></tr></table></figure>

<p>其中<code>Complex* pc = new(buf)Complex(1, 2);</code>这句话会被编译器转换为下图中的1，2，3三行，分别调用operator new（和上文看到的不同，这里需要第二个参数，表示位置，这个函数只是传回这个位置，不再分配内存），指针转型，调用构造函数。</p>
<p>这种用法被称为 “placement new”，它允许程序员在指定的内存位置上创建对象。这通常用于特殊的内存管理场景，例如在预分配的内存池中创建对象。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302031495.png" alt="4_内存管理_12"></p>
<h2 id="9-重载"><a href="#9-重载" class="headerlink" title="9 重载"></a>9 重载</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302031922.png" alt="4_内存管理_13"></p>
<p>（1）C++容器分配内存的途径</p>
<p>容器会走分配器，分配器会调用::operator new和::operator delete，底层也是调用malloc和free。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302033606.png" alt="4_内存管理_14"></p>
<p>在 C++ 中，容器使用分配器（Allocator）来进行内存分配和释放。分配器是负责管理容器内部元素内存的组件。下面是容器分配内存的一般途径：</p>
<ol>
<li><p>容器使用分配器：<br>C++ 容器（如 std::vector、std::list、std::map 等）通常使用分配器来分配和释放内存。分配器是容器的一部分，负责处理元素的内存分配和释放操作。</p>
</li>
<li><p>分配器调用 ::operator new 和 ::operator delete：<br>分配器的实现通常会调用全局作用域下的 ::operator new 来分配内存，并在需要释放内存时调用 ::operator delete。<br>::operator new 和 ::operator delete 是 C++ 中的全局内存分配和释放函数。它们底层可能调用标准库的 malloc 和 free。</p>
</li>
<li><p>底层可能调用 malloc 和 free：<br>malloc 和 free 是 C 标准库中的内存分配和释放函数，用于分配和释放原始的、未构造的内存块。C++ 的 ::operator new 和 ::operator delete 可能在底层调用这些函数。</p>
</li>
</ol>
<p>总体来说，C++ 容器使用分配器来管理内存，而分配器可能在其实现中调用 ::operator new 和 ::operator delete，从而涉及到底层的内存分配函数 malloc 和 free。这种设计允许用户自定义容器的内存管理行为，以适应不同的需求。用户可以通过提供自定义分配器来实现特定的内存分配策略。</p>
<p>（2）重载全局的::operator new 和::operator delete</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302034363.png" alt="4_内存管理_15"></p>
<p>（3）重载operator new和operator delete</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302034714.png" alt="4_内存管理_16"></p>
<p>（3）重载operator new[]和operator delete[]</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302035382.png" alt="4_内存管理_17"></p>
<h2 id="10-重载示例（上）"><a href="#10-重载示例（上）" class="headerlink" title="10 重载示例（上）"></a>10 重载示例（上）</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302036272.png" alt="4_内存管理_18"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302036230.png" alt="4_内存管理_19"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302036668.png" alt="4_内存管理_20"></p>
<h2 id="11-重载示例（下）"><a href="#11-重载示例（下）" class="headerlink" title="11 重载示例（下）"></a>11 重载示例（下）</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302036617.png" alt="4_内存管理_21"></p>
<p>placement new的重载第一参数必须是size_t类型，对于如何区分operator new和placement new，要看调用的时候怎么用。在调用时，编译器会根据传递给new表达式的参数来匹配适当的重载版本。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302038221.png" alt="4_内存管理_22"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302038657.png" alt="4_内存管理_23"></p>
<p>basic_string使用new(extra)扩充申请量</p>
<p>重载了operator new，其实是placement new。因为用法为<code>new(extra) Rep;</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302038299.png" alt="4_内存管理_24"></p>
<h2 id="12-Per-class-allocator"><a href="#12-Per-class-allocator" class="headerlink" title="12 Per class allocator"></a>12 Per class allocator</h2><p>（1）内存池</p>
<p>内存池是一种用于管理和分配内存的机制，它可以提高内存分配的效率，减少内存碎片，并降低动态内存分配的开销。在 C++ 中，内存池通常通过重载 operator new 和 operator delete 来实现。</p>
<p>下面简要描述一下内存池的概念，并提供一个简单的示意图：</p>
<ol>
<li><p>内存池概念：</p>
<ul>
<li>内存池是一块预先分配的内存区域，它被划分为多个小块，每个小块可以被分配给程序使用；</li>
<li>内存池通常由一个或多个链表、堆栈或其他数据结构来管理，以追踪哪些内存块是空闲的，哪些是已分配的；</li>
<li>内存池的目的是减少因频繁的内存分配和释放而引起的性能开销。</li>
</ul>
</li>
<li><p>示意图：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+------------------------------------+</span><br><span class="line">|            Memory Pool             |</span><br><span class="line">+------------------------------------+</span><br><span class="line">|   Free Block <span class="number">1</span>   |   Free Block <span class="number">2</span>  |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">|   Allocated Block <span class="number">1</span>                |</span><br><span class="line">+------------------------------------+</span><br><span class="line">|   Free Block <span class="number">3</span>   |   Free Block <span class="number">4</span>  |</span><br><span class="line">+------------------+-----------------+</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的示意图展示了一个简单的内存池，其中包含多个内存块，有一些是空闲的，有一些是已经分配给程序使用的；</li>
<li>每个内存块的大小可能不同，取决于内存池的设计；</li>
<li>空闲的内存块可以通过链表或其他数据结构连接在一起，以便快速分配。</li>
</ul>
</li>
<li><p>内存池的操作：</p>
<ul>
<li>当程序需要分配内存时，内存池会从空闲块中选择一个合适的块分配给程序；</li>
<li>当程序释放内存时，将相应的内存块标记为空闲，并重新加入空闲块链表，以便下次分配使用。</li>
</ul>
</li>
<li><p>自定义内存池的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> size;</span><br><span class="line">        Block* next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Block* freeList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MemoryPool</span>(<span class="type">size_t</span> poolSize) &#123;</span><br><span class="line">        <span class="comment">// 初始化内存池</span></span><br><span class="line">        <span class="type">void</span>* memory = ::<span class="keyword">operator</span> <span class="built_in">new</span>(poolSize);</span><br><span class="line">        freeList = <span class="built_in">static_cast</span>&lt;Block*&gt;(memory);</span><br><span class="line">        freeList-&gt;size = poolSize;</span><br><span class="line">        freeList-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从内存池中分配内存</span></span><br><span class="line">        <span class="keyword">if</span> (!freeList || freeList-&gt;size &lt; size) &#123;</span><br><span class="line">            <span class="comment">// 内存不足，或者没有空闲块，可以根据实际情况扩展内存池</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Block* allocatedBlock = freeList;</span><br><span class="line">        freeList = freeList-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(allocatedBlock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放内存到内存池</span></span><br><span class="line">        Block* block = <span class="built_in">static_cast</span>&lt;Block*&gt;(ptr);</span><br><span class="line">        block-&gt;next = freeList;</span><br><span class="line">        freeList = block;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述示例为了简洁，省略了一些内存池的管理细节</span></span><br><span class="line"><span class="comment">// 实际的内存池实现可能需要更复杂的数据结构和算法。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>引入内存池的考量：</p>
<p>当需要多次调用new来分配内存时，为了减少malloc分配内存的数量，以及减少cookie的用量，可以选择用malloc分配一大块内存（即内存池），然后将这块内存池分成小块，在实际的分配时直接取用其中的一小块，从而减少malloc的调用次数。</p>
</blockquote>
<p>（2）对类Screen进行内存设置的示例（设计类的内存分配器_版本1）</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302045487.png" alt="4_内存管理_25"></p>
<p>如下图右侧所示：</p>
<ul>
<li>左边间隔8，表示每个Screen对象内存分配的大小为8B，说明每个Screen分配的时候没有cookie；</li>
<li>右边间隔16，表示每个Screen对象内存分配的大小为16B，这是因为对象分配的时候上下加了cookie，最上面和最下面的cookie大小共为8B。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302046008.png" alt="4_内存管理_26"></p>
<h2 id="13-Per-class-allocator-2"><a href="#13-Per-class-allocator-2" class="headerlink" title="13 Per class allocator 2"></a>13 Per class allocator 2</h2><p>（1）设计类的内存分配器_版本2</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302047081.png" alt="4_内存管理_27"></p>
<p>这里和第一版本的最大不同是设计上采用union。</p>
<p>在C++中，union 是一种特殊的数据结构，允许在相同的内存位置存储不同类型的对象。它的每个成员共享相同的内存空间，只能同时使用一个成员。union 提供了一种有效利用内存的方式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AirplaneRep</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> miles;  <span class="comment">// 4B</span></span><br><span class="line">	<span class="type">char</span> type;  <span class="comment">// 1B</span></span><br><span class="line">    <span class="comment">// 由于对齐，这5B会变成8B</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">	AirplaneRep rep;</span><br><span class="line">	Airplane* next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302047903.png" alt="4_内存管理_28"></p>
<h2 id="14-Static-allocator"><a href="#14-Static-allocator" class="headerlink" title="14 Static allocator"></a>14 Static allocator</h2><p>（1）设计类的内存分配器_版本3</p>
<p>下面是内存分配的第三版本。</p>
<p>从软件工程的角度看，上面的operator new和operator delete对于不同 类都要重载，明显不是一个好的解法，下面是将allocator抽象成一个类。</p>
<p>allocator类中定义allocate和deallocate函数，用于分配和回收。</p>
<p>下图中右侧是具体的实现。这里每次分配CHUNK个大小的一大块，然后切割成小块，并用链表串起来。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302049167.png" alt="4_内存管理_29"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302049165.png" alt="4_内存管理_30"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302049639.png" alt="4_内存管理_31"></p>
<h2 id="15-Macro-for-static-allocator"><a href="#15-Macro-for-static-allocator" class="headerlink" title="15 Macro for static allocator"></a>15 Macro for static allocator</h2><p>（1）设计类的内存分配器_版本4</p>
<p>把allocator的部分拿出来用宏来定义。</p>
<p>在C++中，宏（macro）是一种预处理指令，用于在编译过程中执行文本替换。宏通常通过 #define 关键字定义，并在代码中通过宏名称来调用。它们是一种简单的文本替换机制，可以用于创建常量、函数替代、条件编译等。</p>
<p>在宏定义的末尾使用反斜杠是为了告诉编译器该宏定义将在下一行继续。如果在宏定义的最后一行没有使用反斜杠，那么编译器会认为宏定义结束了。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302050403.png" alt="4_内存管理_32"></p>
<p>（2）标准库中的allocator</p>
<p>其中一种分配器有16条自由链表，来应对不同大小的块分配，不同的大小的类对象，分配到不同的链表中。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302050613.png" alt="4_内存管理_34"></p>
<h2 id="16-New-Handler"><a href="#16-New-Handler" class="headerlink" title="16 New Handler"></a>16 New Handler</h2><p>new handler</p>
<p>new handler 是一个与 C++ 内存分配和 new 操作符相关的概念。它是一个函数指针，指向一个用户定义的函数，该函数负责处理 new 操作符无法满足内存分配请求时的情况。</p>
<p>当 new 操作符无法分配所需的内存时，它会调用与之关联的 new handler。new handler 可以执行一些操作，例如释放一些已分配的内存、尝试扩展堆的大小、选择性地抛出异常，或者执行其他用户定义的操作。</p>
<p>使用 set_new_handler 函数设置 new handler：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">customNewHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed! Custom new handler called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::<span class="built_in">terminate</span>();  <span class="comment">// 终止程序或者执行其他处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(customNewHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试分配大块内存</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1000000000000</span>];  <span class="comment">// 如果分配失败，会调用 customNewHandler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，通过 set_new_handler 函数设置了一个自定义的 new handler，即 customNewHandler。当 new 操作符在尝试分配非常大的内存块时失败，会调用这个自定义的 new handler。</p>
<p>注意事项：</p>
<ul>
<li>new handler 是全局的，一旦设置，会在程序的生命周期内一直有效，直到被其他<code>set_new_handler</code>覆盖。</li>
<li>如果 new handler 返回，new 操作符会再次尝试分配内存，如果还失败，则再次调用 new handler。这个过程会一直重复，直到 new handler 抛出异常或者不返回（例如调用 <code>std::terminate()</code>）。</li>
<li>在 C++11 及以后的版本中，可以使用 std::get_new_handler 获取当前的 new handler，以便在需要时进行保存和恢复。</li>
</ul>
<p>使用 new handler 可以提供一些灵活性，允许程序员在内存分配失败的情况下采取定制的操作，而不是默认的行为（即抛出 std::bad_alloc 异常）。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302052495.png" alt="4_内存管理_35"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302052411.png" alt="4_内存管理_36"></p>
<h1 id="第二讲-std-allocator"><a href="#第二讲-std-allocator" class="headerlink" title="第二讲 std::allocator"></a>第二讲 std::allocator</h1><h2 id="17-VC6-malloc"><a href="#17-VC6-malloc" class="headerlink" title="17 VC6 malloc"></a>17 VC6 malloc</h2><p>VC6下的malloc内存块布局：从上往下分别是cookie，debug header, 实际数据的block, debug tail, pad, cookie，对应于下图。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062002434.png" alt="在这里插入图片描述"></p>
<p>在VC6（Visual C++ 6.0）下，malloc 函数分配的内存块的布局包含以下部分：</p>
<ul>
<li><p>Cookie（饼干）：<br>Cookie 是一小段额外的标识信息，用于在边界检查中检测缓冲区溢出。它通常是一个特殊的值，放置在分配的内存块的开始位置。记录内存分配出去的大小。</p>
</li>
<li><p>Debug Header（调试头部）：<br>Debug Header 包含一些调试信息，例如分配的文件名、行号等。这些信息用于调试和跟踪内存分配的源。</p>
</li>
<li><p>实际数据的 Block：<br>这是分配的实际数据块，用于存储程序员请求的数据。</p>
</li>
<li><p>Debug Tail（调试尾部）：<br>Debug Tail 包含与调试信息相关的尾部数据。类似于 Debug Header，它包含一些额外的调试信息。</p>
</li>
<li><p>Pad（填充）：<br>填充是为了确保分配的内存块满足特定的对齐要求。它可能包含一些额外的字节，使得整个内存块的大小满足特定的对齐条件。</p>
</li>
<li><p>Cookie（饼干）：<br>与开头的 Cookie 相对应，是分配的内存块的结束位置。</p>
</li>
</ul>
<p>这样的内存布局在 VC6 中用于调试和检测内存溢出等问题。Cookie 和调试信息是为了帮助调试过程，检测潜在的内存错误。在实际的发布版本中，这些额外的调试信息通常会被省略，以减小内存开销。 VC6 是相对较老的版本，现代的 Visual C++ 版本可能采用了更高效和精简的内存分配方案。</p>
<h2 id="18-VC6标准分配器之实现"><a href="#18-VC6标准分配器之实现" class="headerlink" title="18 VC6标准分配器之实现"></a>18 VC6标准分配器之实现</h2><p>VC6标准分配器allocator的实现，里面的allocate和deallocate的实现只是调用<code>::operator new </code>和<code>::operator delete</code>, 没有任何特殊设计。我们知道它们底层是malloc和free，所以具体分配的时候是带有cookie的，存在内存浪费的现象。</p>
<p>这里分配的单位是具体的类型，比如<code>allocator&lt;int&gt;().allocate(512,(int*)0);</code>分配的就是512个int类型的大小。而后面讲到的一个分配器是以字节为单位，不是以具体类型的大小为单位。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062004430.png" alt="在这里插入图片描述"></p>
<h2 id="19-BC5标准分配器之实现"><a href="#19-BC5标准分配器之实现" class="headerlink" title="19 BC5标准分配器之实现"></a>19 BC5标准分配器之实现</h2><p>Borland5 编译器的allocator的实现，里面的allocate和deallocate的实现只是调用<code>::operator new</code> 和<code>::operator delete</code>, 没有任何特殊设计。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062004019.png" alt="在这里插入图片描述"></p>
<h2 id="20-G2-9标准分配器之实现"><a href="#20-G2-9标准分配器之实现" class="headerlink" title="20 G2.9标准分配器之实现"></a>20 G2.9标准分配器之实现</h2><p>GNU C++2.9标准分配器std::allocator的实现，里面的allocate和deallocate的实现只是调用<code>::operator new </code>和<code>::operator delete</code>, 没有任何特殊设计。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062005939.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>GNU C++2.9容器使用的分配器，不是std::allocator,而是std::alloc</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* p = alloc::<span class="built_in">allocate</span>(<span class="number">512</span>); <span class="comment">// 分配512bytes，不是512个int或者512个double类型等等</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062006939.png" alt="在这里插入图片描述"></p>
<h2 id="21-G2-9-std-alloc-VS-G4-9-pull-alloc"><a href="#21-G2-9-std-alloc-VS-G4-9-pull-alloc" class="headerlink" title="21 G2.9 std::alloc VS G4.9 __pull_alloc"></a>21 G2.9 std::alloc VS G4.9 __pull_alloc</h2><blockquote>
<p>G2.9 std::alloc在G4.9中是 __pull_alloc。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062006172.png" alt="在这里插入图片描述"></p>
<p>G4.9版本中标准分配器std::allocator的实现，里面的allocate和deallocate的实现只是调用::operator new 和::operator delete, 没有任何特殊设计。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062006067.png" alt="在这里插入图片描述"></p>
<h2 id="22-G4-9-pull-alloc用例"><a href="#22-G4-9-pull-alloc用例" class="headerlink" title="22 G4.9 __pull_alloc用例"></a>22 G4.9 __pull_alloc用例</h2><p>这里的alloc（G2.9的叫法, G4.9叫做__pull_alloc）用法, 它在__gnu_cxx这个命名空间内。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>, __gnu_cxx::__pool_alloc&lt;<span class="type">int</span>&gt;&gt; vecPool;</span><br></pre></td></tr></table></figure>

<p>这个分配器是去除了cookie（一个元素带有上下两个cookie，共8B），可以省很多的内存空间。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062007981.png" alt="在这里插入图片描述"></p>
<h2 id="23-G2-9-std-alloc"><a href="#23-G2-9-std-alloc" class="headerlink" title="23 G2.9 std::alloc"></a>23 G2.9 std::alloc</h2><p>（1）alloc的运作模式</p>
<p>第一讲中介绍的Per class allocator类，每个类里面重载了 operator new和operator delete，每个类都单独维护一个链表。如下图所示，<code>std::alloc</code>为所有的类维护16个链表，每个链表负责不同大小的区块分配，从小到大分别为：<code>8B, 16B, 24B, 32B, …, 128B</code>，按8的倍数增长。<strong>当大小不为8的倍数的时候，分配器会自动将其对齐到8的倍数。当大小超过128B时，就交给malloc来单独处理。</strong></p>
<blockquote>
<p>这里可以联系到面经中的问答：malloc函数的底层实现是什么？及相关问题。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011019232.png" alt="4_内存管理_51"></p>
<p><strong>举例：</strong>对于<code>#3</code>链表，每次将分配一大块内存给它（负责32B区块的分配，里面有20个小块，每个都是32B，但是实际分配的时候是20块的两倍大小，剩余的部分可能分配给其他的<code>#x</code>链表）。当一个vector里面存储一个32B的stone类型的对象，会在<code>#3</code>链表里指定一小块给该对象。</p>
<p>（2）embedded pointers</p>
<blockquote>
<p>嵌入式指针工作原理：借用A对象所占用的内存空间中的前4个字节，这4个字节用来 链住这些空闲的内存块；<br>但是，一旦某一块被分配出去，那么这个块的 前4个字节 就不再需要，此时这4个字节可以被正常使用；</p>
<p>参考:<a href="https://blog.csdn.net/qq_42604176/article/details/113871565">https://blog.csdn.net/qq_42604176/article/details/113871565</a></p>
<p>内存的使用方法是,使用的时候看成对象实例,空闲的时候会看成next指针.</p>
<p>参考：<a href="https://github.com/KinWaiYuen/KinWaiYuen.github.io/blob/master/c%2B%2B/%E4%BE%AF%E6%8D%B7%E5%86%85%E5%AD%98.md">https://github.com/KinWaiYuen/KinWaiYuen.github.io/blob/master/c%2B%2B/%E4%BE%AF%E6%8D%B7%E5%86%85%E5%AD%98.md</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011041526.png" alt="4_内存管理_52"></p>
<h2 id="24-G2-9-std-alloc运行一瞥01-05"><a href="#24-G2-9-std-alloc运行一瞥01-05" class="headerlink" title="24 G2.9 std::alloc运行一瞥01-05"></a>24 G2.9 std::alloc运行一瞥01-05</h2><p>（1）源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;                        <span class="comment">//小區塊的上調邊界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;                  <span class="comment">//小區塊的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;; <span class="comment">//free-lists 個數</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// union obj &#123;                   //G291[o],CB5[x],VC6[x]</span></span><br><span class="line"><span class="comment">//   union obj* free_list_link;  //這麼寫在 VC6 和 CB5 中也可以，</span></span><br><span class="line"><span class="comment">// &#125;;                            //但以後就得使用 &quot;union obj&quot; 而不能只寫 &quot;obj&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__obj</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__obj</span>* free_list_link;</span><br><span class="line">&#125; obj;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*   start_free = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>*   end_free = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span>  heap_size = <span class="number">0</span>;</span><br><span class="line">obj* free_list[__NFREELISTS]</span><br><span class="line">     = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="meta"># enum &#123;__ALIGN = 8&#125;;  </span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ROUND_UP</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个常量<code>__ALIGN</code>，它表示内存分配时的对齐边界，设定为8字节。然后，定义了一个函数 <code>ROUND_UP</code>，该函数接受一个大小（<code>bytes</code>）作为参数，然后将其上调到对齐边界。</p>
<p>具体来说，<code>ROUND_UP</code>函数的作用是将传入的大小（<code>bytes</code>）上调到<code>__ALIGN</code>的倍数。这是通过以下步骤实现的：</p>
<ul>
<li>将<code>bytes</code>加上<code> __ALIGN-1</code>，即<code> bytes + 7</code>；</li>
<li>对结果进行按位与操作，通过<code>&amp; ~(__ALIGN - 1)</code>将最低的3位清零，确保结果是<code>__ALIGN</code>的倍数。</li>
</ul>
<blockquote>
<p>这样做的目的是为了满足内存对齐的要求。在一些硬件体系结构中，访问未对齐的内存可能会导致性能问题或者错误，因此内存分配时通常需要对齐到某个特定的边界。这个函数就提供了一种简单的方法来确保分配的内存大小是对齐的。</p>
</blockquote>
<p>（2）std::alloc运行01-05</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053088.png" alt="4_内存管理_53"></p>
<ol start="2">
<li>当一个容器里面存储的元素大小是<code>32B</code>时，它的运作过程如下：</li>
</ol>
<ul>
<li><p>挂在<code>32 / 8 - 1 = #3</code>号链表；</p>
</li>
<li><p>刚开始的时候pool为空，此时要分配<code>32 * 20 *2 + RoundUp(0 &gt;&gt; 4)= 1280B</code>大小的空间为pool，然后从pool里面切割20个小块（共640B）挂在<code>#3</code>链表上。第1个给容器，剩下的19个挂在<code>#3</code>链表；</p>
</li>
<li><p>此时pool的余量为<code>640B</code>。RoundUp是追加量，里面的大小是把上次的累计申请量右移4位(除以16)，由于这里是刚开始，没有累计申请量，故为0&gt;&gt;4。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053848.png" alt="4_内存管理_54"></p>
</li>
</ul>
<ol start="3">
<li>此时，又创建了新的容器，它里面的元素大小为<code>64B</code></li>
</ol>
<ul>
<li>对应#7链表；</li>
<li>此时链表为空。由于上页的pool里面还剩<code>640B</code>，现在将其切分为<code>640/64 = 10</code>个区块，第1个给容器，剩下的9个挂在<code>#7</code>链表；</li>
<li>此时pool的余量为<code>0B</code>，因为被切分挂到链表上了。<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053984.png" alt="4_内存管理_55"></li>
</ul>
<ol start="4">
<li>在上面的基础上，现在新建容器，它的元素大小为<code>96B</code></li>
</ol>
<ul>
<li>对应<code>96 / 8 - 1 = #11</code>链表；</li>
<li>先检查pool是否有余量，由于pool为空，此时调用malloc分配一大块作为pool，总共大小为<code>96x 20 x 2 + RoundUp(1280 &gt;&gt; 4) = 3840 + 80 = 3920B</code>，切割20个区块拿出来用，第1个给容器，另外19个挂在<code>#11</code>链表上；</li>
<li>此时pool的余量为<code>3920−(96×20)=3920−1920=2000 B</code>。累计申请量是1280 + 3920 &#x3D; 5200B。<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053482.png" alt="4_内存管理_56"></li>
</ul>
<ol start="5">
<li>再次新建容器，里面元素大小是<code>88B</code></li>
</ol>
<ul>
<li><p>挂在<code>88 / 8 - 1 = #10</code>号链表；</p>
</li>
<li><p>现在pool中的余量为<code>2000B</code>，将2000B切分为20个区块（每个区块88B），第1个给容器，剩下的19个挂在<code>#10</code>链表上；</p>
</li>
<li><p>此时pool的余量为<code>2000 - 88 x 20 = 240B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053390.png" alt="4_内存管理_57"></p>
</li>
</ul>
<h2 id="25-G2-9-std-alloc运行一瞥06-10"><a href="#25-G2-9-std-alloc运行一瞥06-10" class="headerlink" title="25 G2.9 std::alloc运行一瞥06-10"></a>25 G2.9 std::alloc运行一瞥06-10</h2><ol start="6">
<li>下面这张图表示容器**连续申请3次<code>88B</code>**大小的空间</li>
</ol>
<ul>
<li><p>由于上面已经在<code>#10</code>链表上挂了19个大小为<code>88B</code>的区块，这时候直接从该链表上拿下来3个区块返回给容器即可；</p>
</li>
<li><p>此时pool的余量为<code>240B</code>没变。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021045105.png" alt="4_内存管理_58"></p>
</li>
</ul>
<ol start="7">
<li>又来新的容器，它的元素大小为8B</li>
</ol>
<ul>
<li><p>挂在<code>8 / 8 - 1 = #0</code>号链表；</p>
</li>
<li><p>根据06，pool容量为<code>240B</code>，从pool里面切分出20个区块，共<code>8B x 20 = 160B</code>大小，第1个返回给容器，其余19个区块挂在<code>#0</code>链表上；</p>
</li>
<li><p>此时pool的余量为<code>240 - 160 = 80B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021045366.png" alt="4_内存管理_59"></p>
</li>
</ul>
<ol start="8">
<li>又来新的容器，它的元素大小为<code>104B</code></li>
</ol>
<ul>
<li><p>挂在<code>104 / 8 - 1 = #12</code>链表；</p>
</li>
<li><p>由于此时pool余量为<code>80B</code>，一个大小为<code>104B</code>的区块都切分不了。此时这个<code>80B</code>大小的空间就是碎片，需要将其挂在<code>80 / 8 - 1 = #9</code>链表上。碎片处理完之后， 再来应付现在的需求：<code>104B</code>的分配；</p>
</li>
<li><p>现在再调用<code>malloc</code>分配一大块，大小为<code>104 x 20 x 2 + RoundUp(5200 &gt;&gt; 4) = 4160 + RoundUp(325) = 4160 + 328 = 4488</code>；把第1个分配给容器，切出的19个挂在<code>#12</code>链表上。累计申请量为<code>5200 + 4488 = 9688B</code>；</p>
</li>
<li><p>此时pool的余量为<code>4488 - 104 x 20 = 2408B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021045618.png" alt="4_内存管理_60"></p>
</li>
</ul>
<ol start="9">
<li>现在申请<code>112B</code></li>
</ol>
<ul>
<li><p>挂在<code>112 / 8 - 1 = #13</code>链表上；</p>
</li>
<li><p>根据08，pool容量为<code>2408B</code>，从里面取出<code>112 * 20 = 2240B</code>，第1个返回给容器，留下19个挂在<code>#13</code>链表上；</p>
</li>
<li><p>此时pool的余量为<code>2408 - 2240 = 168B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021045344.png" alt="4_内存管理_61"></p>
</li>
</ul>
<ol start="10">
<li>现在的新需求是申请<code>48B</code></li>
</ol>
<ul>
<li>挂在<code>48 / 8 - 1 = #5</code>链表上；</li>
<li>根据09，pool余量是<code>168B</code>，可以分配<code>168 / 48 = 3</code>个区块，第1个返回给容器，剩下2个挂在<code>#5</code>链表上；</li>
<li>此时pool的余量为<code>24B</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021046301.png" alt="4_内存管理_62"></p>
<h2 id="26-G2-9-std-alloc运行一瞥11-13"><a href="#26-G2-9-std-alloc运行一瞥11-13" class="headerlink" title="26 G2.9 std::alloc运行一瞥11-13"></a>26 G2.9 std::alloc运行一瞥11-13</h2><p>下面看一下内存分配失败的动作。</p>
<ol start="11">
<li>新的容器请求<code>72B</code>的大小</li>
</ol>
<ul>
<li><p>挂在<code>72 / 8 - 1 = #8</code>链表；</p>
</li>
<li><p>pool容量为<code>24B</code>，不足以分配一个大小为<code>72B</code>的区块，于是这个大小为<code>24B</code>的pool就成为碎片，需要先挂在<code>24 / 8 - 1 = #2</code>链表，所以把这个pool余量挂在#2链表, 然后调用malloc分配<code>72 x 20 x 2 + RoundUP(9688 &gt;&gt; 4) = 3488B</code>。在实验过程中把系统heap大小设置为<code>10000B</code>，前面已经累计分配了<code>9688B</code>，因此无法满足本次内存分配。</p>
</li>
<li><p>此时，alloc从手中资源取最接近<code>72B</code>的大小回填pool，这里最接近的是<code>80B</code>(即在<code>#9</code>链表有1个空的区块可用)，然后从其<code>80B</code>中切<code>72B</code>给容器，此时pool的余量为<code>80 - 72 = 8B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021131569.png" alt="4_内存管理_63"></p>
</li>
</ul>
<ol start="12">
<li>容器再申请<code>72B</code></li>
</ol>
<ul>
<li><p><code>#8</code>链表没有区块可用，而pool余量为<code>8B</code>，不足以供应1个区块。因此先将pool余量挂在<code>#0</code>链表上，然后想要调用malloc分配<code>72 x 20 x 2 + RoundUP(9688 &gt;&gt; 4) = 3488B</code>的空间，此时依然无法满足分配；</p>
</li>
<li><p>于是alloc从手中资源取最接近<code>72B</code>的<code>88B</code>（#10链表）回填pool。因为上面的<code>80B</code>（<code>#9</code>链表）已经用完了，从<code>88B</code>中切出<code>72B</code>返回给容器；</p>
</li>
<li><p>此时pool余量为<code>88 - 72 = 16B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021133827.png" alt="4_内存管理_64"></p>
</li>
</ul>
<ol start="13">
<li>新的容器申请<code>120B</code></li>
</ol>
<ul>
<li><p>挂在<code>120 / 8 - 1 = #14</code>链表；</p>
</li>
<li><p>同样的，pool供应不足，先将上面的<code>16B</code>挂在<code>#1</code>链表上，再想要malloc分配一大块也分配不出，无法满足需求；</p>
</li>
<li><p>于是，alloc从手中资源中取最接近<code>120B</code>的区块回填pool，但是<code>#14</code>链表和<code>#15</code>链表都是空的，于是无法分配。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021135087.png" alt="4_内存管理_65"></p>
</li>
</ul>
<ol start="14">
<li>检讨</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021135931.png" alt="4_内存管理_66"></p>
<h2 id="27-G2-9-std-alloc源码剖析（上）"><a href="#27-G2-9-std-alloc源码剖析（上）" class="headerlink" title="27 G2.9 std::alloc源码剖析（上）"></a>27 G2.9 std::alloc源码剖析（上）</h2><p>GNU C++2.9 分配器的设计：分为两级分配器，分别是第一级分配器和第二级分配器.</p>
<ol>
<li>第一级分配器</li>
</ol>
<p>其中<strong>第一级分配器不重要</strong>，主要模拟new handler的作用，处理一下内存分配的情况。下列图片是第一级分配器的代码。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041115341.png" alt="4_内存管理_67"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041115436.png" alt="4_内存管理_68"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041116564.png" alt="4_内存管理_69"></p>
<ol start="2">
<li>第二级分配器</li>
</ol>
<p>（1）定义</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041140479.png" alt="4_内存管理_70"></p>
<ul>
<li><p>ROUND_UP：将分配的大小变成8的倍数；</p>
</li>
<li><p>FREELIST_INDEX：根据bytes的大小指定分配到哪个链表；</p>
</li>
<li><p>几个变量的作用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>*   start_free = <span class="number">0</span>; <span class="comment">// 指向战备池pool的头</span></span><br><span class="line"><span class="type">char</span>*   end_free = <span class="number">0</span>;   <span class="comment">// 指向战备池pool的尾</span></span><br><span class="line"><span class="type">size_t</span>  heap_size = <span class="number">0</span>;  <span class="comment">// 累计分配大小</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>（2）最重要的两个函数：allocate和deallocate</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041141570.png" alt="4_内存管理_71"></p>
<ul>
<li><p><code>allocate</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span>  <span class="comment">//n must be &gt; 0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  obj* <span class="keyword">volatile</span> *my_free_list;    <span class="comment">//obj** my_free_list;</span></span><br><span class="line">  obj* result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>)__MAX_BYTES) &#123; <span class="comment">// 大于128B，交给第一级分配器来分配</span></span><br><span class="line">      <span class="keyword">return</span>(<span class="built_in">malloc_allocate</span>(n));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);  <span class="comment">// 定位到几号链表</span></span><br><span class="line">  result = *my_free_list;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;  <span class="comment">// 该链表为空</span></span><br><span class="line">      <span class="type">void</span>* r = <span class="built_in">refill</span>(<span class="built_in">ROUND_UP</span>(n));  <span class="comment">// 链表充值，从pool中去拿区块，链表有了可用区块</span></span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 指针指向下一个可用区块</span></span><br><span class="line">  *my_free_list = result-&gt;free_list_link;</span><br><span class="line">  <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041143025.png" alt="4_内存管理_72"></p>
</li>
<li><p><code>deallocate</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> n)</span>  <span class="comment">//p may not be 0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  obj* q = (obj*)p;</span><br><span class="line">  obj* <span class="keyword">volatile</span> *my_free_list;  <span class="comment">//obj** my_free_list;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>) __MAX_BYTES) &#123;  <span class="comment">// 大于128B，改用第一级分配器进行回收</span></span><br><span class="line">      <span class="built_in">malloc_deallocate</span>(p, n);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 回收过来的p指针指向的区块，挂在单向链表的头</span></span><br><span class="line">  my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);  <span class="comment">// 指向16个链表中的一个，比如list #6,如下图所示</span></span><br><span class="line">  q-&gt;free_list_link = *my_free_list;  <span class="comment">// q的next指向单向链表的头，就是list #6指向的具体区块的单向链表（free_list_link即next指针）</span></span><br><span class="line">  *my_free_list = q;  <span class="comment">// my_free_list重新指向新的单向链表q，因为头指针被换成新的了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041143591.png" alt="4_内存管理_73"></p>
</li>
</ul>
<h2 id="28-G2-9-std-alloc源码剖析（中）"><a href="#28-G2-9-std-alloc源码剖析（中）" class="headerlink" title="28 G2.9 std::alloc源码剖析（中）"></a>28 G2.9 std::alloc源码剖析（中）</h2><ul>
<li><code>refill</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041150983.png" alt="4_内存管理_75"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="comment">// Returns an object of size n, and optionally adds</span></span><br><span class="line"><span class="comment">// to size n free list. We assume that n is properly aligned.</span></span><br><span class="line"><span class="comment">// We hold the allocation lock.</span></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">refill</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span>* chunk = <span class="built_in">chunk_alloc</span>(n,&amp;nobjs);</span><br><span class="line">    obj* <span class="keyword">volatile</span> *my_free_list;   <span class="comment">//obj** my_free_list;</span></span><br><span class="line">    obj* result;</span><br><span class="line">    obj* current_obj;</span><br><span class="line">    obj* next_obj;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);</span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Build free list in chunk</span></span><br><span class="line">    result = (obj*)chunk;</span><br><span class="line">    *my_free_list = next_obj = (obj*)(chunk + n);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;  ; ++i) &#123;</span><br><span class="line">      current_obj = next_obj;</span><br><span class="line">      next_obj = (obj*)((<span class="type">char</span>*)next_obj + n);</span><br><span class="line">      <span class="keyword">if</span> (nobjs<span class="number">-1</span> == i) &#123;</span><br><span class="line">          current_obj-&gt;free_list_link = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          current_obj-&gt;free_list_link = next_obj;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，next_obj 的计算是为了在内存块（chunk）上构建一个链表，以形成一个自由链表（free list）。这个链表将被用于分配对象。让我们解释一下这行代码的目的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">next_obj = (obj*)((<span class="type">char</span>*)next_obj + n);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>next_obj</code>是一个指向当前空闲块的指针，它一开始指向<code>chunk + n</code>，即第一个可用的内存块；</li>
<li><code>(char*)next_obj</code>将<code>next_obj</code>强制类型转换为<code>char*</code>类型，这是因为我们希望按字节递增，而不是按对象递增；</li>
<li><code>((char*)next_obj + n)</code>表示将指针移动到下一个内存块的起始位置，即当前内存块的末尾加上一个对象的大小<code>n</code>；</li>
<li><code>(obj*)((char*)next_obj + n)</code>将移动后的指针重新转换为<code>obj*</code>类型，以便正确指向下一个空闲块的起始位置。</li>
</ul>
<p>这样，通过不断地按对象大小 n 的步长在内存块上移动，构建了一个包含多个空闲块的链表。这个链表可以有效地用于分配对象。这种处理方式是为了确保链表中相邻的空闲块之间的间隔是 n 字节，从而满足对象的对齐需求。</p>
<p>在上述代码中，for 循环的第二个条件 ; 是一个空语句，表示没有额外的条件来控制循环的执行。这意味着 for 循环会一直执行，直到执行到 break 语句为止。</p>
<p>在这个具体的代码中，循环的目的是为了在内存块上构建一个链表，将多个空闲块连接在一起。循环体中的 if 语句用于判断是否已经遍历了 nobjs-1 个空闲块。如果是，则最后一个空闲块的 free_list_link 设置为 0，表示链表的结束。此时，break 语句被执行，跳出循环。</p>
<p>因此，循环终止的条件是遍历了 nobjs-1 个空闲块，确保链表的正确构建，并在最后一个空闲块处设置了结束标志。循环的终止是由 break 语句触发的，而不是由循环条件控制的。</p>
<ul>
<li><code>chunk_alloc</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041210910.png" alt="4_内存管理_74"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041210501.png" alt="4_内存管理_75"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="comment">// We allocate memory in large chunks in order to</span></span><br><span class="line"><span class="comment">// avoid fragmentingthe malloc heap too much.</span></span><br><span class="line"><span class="comment">// We assume that size is properly aligned.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocates a chunk for nobjs of size &quot;size&quot;.</span></span><br><span class="line"><span class="comment">// nobjs may be reduced if it is inconvenient to</span></span><br><span class="line"><span class="comment">// allocate the requested number.</span></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="comment">//char* chunk_alloc(size_t size, int&amp; nobjs)  //G291[o],VC6[x],CB5[x]</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">chunk_alloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span>* nobjs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span>* result;</span><br><span class="line">  <span class="comment">// 调用chunk_alloc的时候，nobjs为20，所以默认total_bytes为20个区块的大小</span></span><br><span class="line">  <span class="type">size_t</span> total_bytes = size * (*nobjs);   <span class="comment">// 原nobjs改為 (*nobjs)</span></span><br><span class="line">  <span class="type">size_t</span> bytes_left = end_free - start_free; <span class="comment">// pool中剩余的字节个数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. pool空间足以满足20块需求</span></span><br><span class="line">  <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;  </span><br><span class="line">      result = start_free;  <span class="comment">// 将原来的start_free作为结果传回去</span></span><br><span class="line">      start_free += total_bytes;  <span class="comment">// 调整pool水位，下降，战备池pool变小</span></span><br><span class="line">      <span class="keyword">return</span>(result);</span><br><span class="line">  <span class="comment">// 2. pool空间只能满足1个及以上区块的需求，但不足20块</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) &#123; </span><br><span class="line">      *nobjs = bytes_left / size;     <span class="comment">//原nobjs改為 (*nobjs)，改变需求数，看看可以切成几个区块</span></span><br><span class="line">      total_bytes = size * (*nobjs);  <span class="comment">//原nobjs改為 (*nobjs)，改变需求总量</span></span><br><span class="line">      result = start_free;</span><br><span class="line">      start_free += total_bytes;</span><br><span class="line">      <span class="keyword">return</span>(result);</span><br><span class="line">  <span class="comment">// 3. pool空间不足以满足1块需求，pool空间可能是碎片，也可能表示pool大小为0</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">      <span class="type">size_t</span> bytes_to_get =  </span><br><span class="line">                 <span class="number">2</span> * total_bytes + <span class="built_in">ROUND_UP</span>(heap_size &gt;&gt; <span class="number">4</span>);  <span class="comment">// 需要请求的一大块的大小</span></span><br><span class="line">      <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">      <span class="comment">// 先将pool池的碎片挂到对应大小的链表上</span></span><br><span class="line">      <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          obj* <span class="keyword">volatile</span> *my_free_list =  <span class="comment">// 找出应转移到第#号链表</span></span><br><span class="line">                 free_list + <span class="built_in">FREELIST_INDEX</span>(bytes_left);</span><br><span class="line">		  <span class="comment">// 将pool空间编入第#号链表，next指针指向链表的头节点，编入链表的第一个节点</span></span><br><span class="line">          ((obj*)start_free)-&gt;free_list_link = *my_free_list;</span><br><span class="line">          *my_free_list = (obj*)start_free;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 上面处理完pool的碎片，pool为空，开始用malloc为pool分配内存</span></span><br><span class="line">      start_free = (<span class="type">char</span>*)<span class="built_in">malloc</span>(bytes_to_get); <span class="comment">// pool的起点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123;  <span class="comment">// 分配失败，从free list中找区块（向右边更大的区块去找）</span></span><br><span class="line">          <span class="type">int</span> i;</span><br><span class="line">          obj* <span class="keyword">volatile</span> *my_free_list, *p;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//Try to make do with what we have. That can&#x27;t</span></span><br><span class="line">          <span class="comment">//hurt. We do not try smaller requests, since that tends</span></span><br><span class="line">          <span class="comment">//to result in disaster on multi-process machines.</span></span><br><span class="line">          <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123; <span class="comment">// 向右侧的链表去找区块，例如88B，96B，104B， 112B等等</span></span><br><span class="line">              my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(i);</span><br><span class="line">              p = *my_free_list;</span><br><span class="line">              <span class="keyword">if</span> (<span class="number">0</span> != p) &#123; <span class="comment">// 找到右边的list中的可用区块，只释放一块给pool</span></span><br><span class="line">                  *my_free_list = p -&gt; free_list_link;</span><br><span class="line">                  <span class="comment">// start_free 和 end_free是战备池pool的头尾指针，指向这一块空间</span></span><br><span class="line">                  start_free = (<span class="type">char</span>*)p;  </span><br><span class="line">                  end_free = start_free + i;</span><br><span class="line">                  <span class="keyword">return</span>(<span class="built_in">chunk_alloc</span>(size, nobjs)); <span class="comment">// 递归再试一次</span></span><br><span class="line">                  <span class="comment">//Any leftover piece will eventually make it to the</span></span><br><span class="line">                  <span class="comment">//right free list.</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          end_free = <span class="number">0</span>;       <span class="comment">//In case of exception.</span></span><br><span class="line">          start_free = (<span class="type">char</span>*)<span class="built_in">malloc_allocate</span>(bytes_to_get);</span><br><span class="line">          <span class="comment">//This should either throw an exception or</span></span><br><span class="line">          <span class="comment">//remedy the situation. Thus we assume it</span></span><br><span class="line">          <span class="comment">//succeeded.</span></span><br><span class="line">      &#125; <span class="comment">// if结束</span></span><br><span class="line">      </span><br><span class="line">      heap_size += bytes_to_get;  <span class="comment">// 累计总分配量</span></span><br><span class="line">      end_free = start_free + bytes_to_get;  <span class="comment">// 调整pool水位，pool空间变大，pool的终点</span></span><br><span class="line">      <span class="keyword">return</span>(<span class="built_in">chunk_alloc</span>(size, nobjs));  <span class="comment">// 递归再调用一次</span></span><br><span class="line">      <span class="comment">// 不论是58/59行还是72/73行，都是先将空闲放入战备池中，然后再递归调用chunk_aclloc，就可以达到重新分配内存的效果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="29-G2-9-std-alloc源码剖析（下）"><a href="#29-G2-9-std-alloc源码剖析（下）" class="headerlink" title="29 G2.9 std::alloc源码剖析（下）"></a>29 G2.9 std::alloc源码剖析（下）</h2><p>分析chunk_alloc函数在G2.9 std::alloc源码剖析（中）进行。</p>
<p>具体一些数据的初始定义：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041212367.png" alt="在这里插入图片描述"></p>
<h2 id="30-G2-9-std-alloc观念大整理"><a href="#30-G2-9-std-alloc观念大整理" class="headerlink" title="30 G2.9 std::alloc观念大整理"></a>30 G2.9 std::alloc观念大整理</h2><p>（1）观念整理</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041233313.png" alt="4_内存管理_78"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">list&lt;Foo&gt; c;</span><br><span class="line">c.<span class="built_in">push_back</span>(<span class="built_in">Foo</span>(<span class="number">1</span>)); <span class="comment">// Foo(1)临时对象，创建在栈stack中</span></span><br><span class="line"><span class="comment">//容器c使用alloc分配空间，看16条链表中哪一条可以提供区块，分配给它。所以它不带cookie</span></span><br><span class="line"></span><br><span class="line">Foo* p = <span class="keyword">new</span> <span class="built_in">Foo</span>(<span class="number">2</span>); <span class="comment">// 采用new，创建在heap中</span></span><br><span class="line"><span class="comment">// new是调用operator new，底层是调用malloc，它带有cookie</span></span><br><span class="line">c.<span class="built_in">push_back</span>(*p); <span class="comment">// 容器c push_back的时候不带cookie</span></span><br><span class="line"><span class="keyword">delete</span> p; </span><br></pre></td></tr></table></figure>

<p>（2）“批斗”大会</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041234181.png" alt="4_内存管理_79"></p>
<ul>
<li><p>需要学习的地方：比较判断的时候把具体的值写在前面，防止出现将&#x3D;&#x3D;写成&#x3D;赋值的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == start_free)</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> != p)</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == nobjs)        </span><br></pre></td></tr></table></figure>
</li>
<li><p>不好的地方</p>
<ul>
<li><p>变量定义的地方不要和使用的地方间隔太远，尤其是指针的使用；</p>
</li>
<li><p>第一级分配器使用的一个函数：炫技，没有人看得懂；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> (*<span class="built_in">set_malloc_handler</span>(<span class="built_in">void</span> (*f)()))()</span><br><span class="line">&#123; <span class="comment">//類似 C++ 的 set_new_handler().</span></span><br><span class="line">  <span class="built_in">void</span> (*old)() = oom_handler;</span><br><span class="line">  oom_handler = f;</span><br><span class="line">  <span class="keyword">return</span>(old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于 //</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*H)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">H <span class="title">set_malloc_handler</span><span class="params">(H f)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有deallocate的时候并没有free掉，这是由设计的先天缺陷造成的。</p>
</li>
</ul>
</li>
</ul>
<h2 id="31-G4-9-pull-allocator运行观察"><a href="#31-G4-9-pull-allocator运行观察" class="headerlink" title="31 G4.9 pull allocator运行观察"></a>31 G4.9 pull allocator运行观察</h2><p>在GNU C++4.9版本下的测试，由于2.9版本分配内存都是调用malloc，无法重载，即无法接管到我们用户手中，无法记录总分配量和总释放量。而在4.9版本中，它的内存分配动作是调用operator new，这样我们就可以接管operator new，对其进行重载。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041240025.png" alt="4_内存管理_80"></p>
<p>下面测试两个分配器使用情况，分别对list容器进行100万次分配。</p>
<p>由于GNU C++4.9版本标准分配器是allocator，并不是2.9版本alloc，所以容器（客户）分配内存的时候每个元素（100万个）都带cookie（每个cookie占8B）。这个如下图右侧所示。</p>
<p>下图左侧使用4.9版本好的分配器__pool_alloc，这个是2.9版本的alloc，显示分配的次数timesNew为122次（调用malloc的次数），这比右侧标准分配器好上不少。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041240699.png" alt="4_内存管理_81"></p>
<h1 id="第三讲-malloc-free"><a href="#第三讲-malloc-free" class="headerlink" title="第三讲 malloc&#x2F;free"></a>第三讲 malloc&#x2F;free</h1><h2 id="32-VC6和VC10的malloc比较"><a href="#32-VC6和VC10的malloc比较" class="headerlink" title="32 VC6和VC10的malloc比较"></a>32 VC6和VC10的malloc比较</h2><blockquote>
<p> SBH：Small Block Heap</p>
</blockquote>
<p>（1）VC6内存分配</p>
<p>下图为<code>call stack</code>，即调用栈，需要从下往上看。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061116653.png" alt="4_内存管理_86"></p>
<p><code>mainCRTStartup</code>函数是<code>CRT</code>（C Run Time，C标准库）提供的入口点函数，调用一系列函数，后面才是调用<code>main</code>函数。其中，在<code>_heap_alloc_base</code>函数中：</p>
<ul>
<li>当size小于阈值<code>_sbh_thrshold</code>时调用<code>__sbh_alloc_block</code>函数；</li>
<li>否则调用<code>HeapAlloc</code>函数，即操作系统提供的内存分配函数。</li>
</ul>
<blockquote>
<p>在 VC6（Visual C++ 6.0）的内存分配机制中，SBH（Small Block Heap）是用于管理小块内存的一部分。这是一个专门用于分配和释放相对较小内存块的堆管理机制，通常用于提高小对象的内存分配效率。</p>
<p>在调用栈中，从下往上看，mainCRTStartup 函数是 CRT（C Runtime）提供的入口点函数。CRT 是 C++ 程序运行时环境的一部分，负责初始化和管理程序的运行时状态。mainCRTStartup 函数会执行一系列的初始化操作，包括初始化全局变量、调用构造函数等。在这个过程中，可能会涉及到内存分配操作，其中就包括 SBH 的管理。</p>
<p>在 VC6 中，SBH 通常使用一些数据结构（例如内存池、free list 等）来管理小块内存。这有助于减少内存碎片，并提高小对象的分配和释放效率。</p>
<p>整个调用栈的过程可能是这样的：</p>
<ul>
<li>mainCRTStartup 函数初始化 CRT 环境。</li>
<li>在初始化过程中，可能会涉及到 SBH 的初始化或使用。</li>
<li>然后执行 main 函数，开始程序的主要逻辑。</li>
</ul>
<p>总的来说，VC6 的内存分配机制在运行时可能会使用 SBH 等机制来管理小块内存，以提高性能和效率。这些机制通常是底层的、对开发者透明的，但在整个程序运行的过程中发挥着重要的作用。</p>
</blockquote>
<p>（2）VC10内存分配</p>
<p>下图中黑色覆盖的函数表示VC10不再使用，对于<code>_heap_alloc_base</code>函数，它里面直接调用<code>HeapAlloc</code>函数，不再对小块内存进行管理，统统交给操作系统来做。对于VC10版本，它的SHB等小块内存的管理都被包装到<code>HeapAlloc</code>里面来了。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061120640.png" alt="4_内存管理_87"></p>
<p>（3）SBH之始</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061124139.png" alt="4_内存管理_88"></p>
<p><code>_heap_init</code></p>
<ul>
<li><p>调用<code>HeapCreate</code>来分配一块大小为<code>4096</code>的堆空间，命名为<code>_crtheap</code>，后面<code>CRT</code>的动作都要从这一块内存中来拿；</p>
</li>
<li><p>调用<code>__sbh_heap_init</code>，里面是<code>HeapAlloc</code>，从<code>_crtheap</code>中拿内存，准备好<code>16个header</code>。</p>
<ul>
<li><p>header的结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> BITVEC;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagHeader</span></span><br><span class="line">&#123;</span><br><span class="line">    BITVEC bitvEntryHi; <span class="comment">// 32位</span></span><br><span class="line">    BITVEC bitbEntryLo;  <span class="comment">// 32位</span></span><br><span class="line">    BITVEC bitvCommit;  <span class="comment">// 32位</span></span><br><span class="line">    <span class="type">void</span>* pHeapData;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tagRegion</span>* pRegion;</span><br><span class="line">&#125;</span><br><span class="line">HEADER, *PHEADER;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061123323.png" alt="4_内存管理_89"></p>
</li>
</ul>
</li>
</ul>
<h2 id="33-VC6内存分配（1）"><a href="#33-VC6内存分配（1）" class="headerlink" title="33 VC6内存分配（1）"></a>33 VC6内存分配（1）</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061126561.png" alt="4_内存管理_90"></p>
<h3 id="（1）ioinit"><a href="#（1）ioinit" class="headerlink" title="（1）ioinit()"></a>（1）ioinit()</h3><ul>
<li><p>和<code>I/O</code>相关的初始化，其中调用<code>_malloc_crt</code>进行内存分配，这是<code>CRT</code>进行的第一次内存分配，大小为<code>32×8=256B</code>，所有的程序一进来都是分配<code>256B</code>。256在十六进制下是0x100，或者写成<code>100H</code>。</p>
</li>
<li><p>调用了<code>_malloc_dbg</code>，和<code>malloc</code>稍微有所不同，是与调试相关的内存分配函数，</p>
<ul>
<li><p>是 Microsoft Visual C++ 提供的一种扩展版本，用于在调试模式下进行内存分配，并提供额外的调试信息。与标准的<code>malloc</code>函数相比，<code>_malloc_dbg</code>主要用于在调试期间更容易跟踪内存分配和释放的情况。</p>
</li>
<li><p>示例用法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;crtdbg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* ptr = _malloc_dbg(size, _NORMAL_BLOCK, __FILE__, __LINE__);</span><br><span class="line"></span><br><span class="line"><span class="comment">// _malloc_dbg 用于分配带有调试信息的内存块</span></span><br><span class="line"><span class="comment">// _NORMAL_BLOCK 表示内存块的类型</span></span><br><span class="line"><span class="comment">// __FILE__ 和 __LINE__ 分别表示调用该函数的源文件和行号</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="（2）-heap-alloc-dbg"><a href="#（2）-heap-alloc-dbg" class="headerlink" title="（2）_heap_alloc_dbg()"></a>（2）_heap_alloc_dbg()</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061130993.png" alt="4_内存管理_91"></p>
<ul>
<li><code>_CrtMemBlockHeader</code>是一个结构体，可称为<code>debug header</code>；<code>nSize</code>就是上文提到的<code>256B</code>；<code>nNoManLandSize</code>为4；</li>
<li>右侧的图显示了<strong>debug模式下申请nsize&#x3D;256B大小内存</strong>，额外附加了一些东西，debug header和NoMansLand，这是为调试器设计的；</li>
<li><strong>blockSize计算完毕之后，开始调用_heap_alloc_base分配内存空间</strong></li>
<li><strong>所需内存的nSize部分加上调试所加的部分，这个整体称为block，由灰色、深绿色、浅绿色共同构成</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061132445.png" alt="4_内存管理_92"></p>
<ul>
<li><code>_pFirstBlock</code>和<code>_pLastBlock</code>两根指针指向block链表的头尾，<code>malloc</code>分配的内存块都用链表串起来；</li>
<li>右下角的<code>memset</code>是给特定地方填入特定的值。</li>
</ul>
<h2 id="34-VC6内存分配（2）"><a href="#34-VC6内存分配（2）" class="headerlink" title="34 VC6内存分配（2）"></a>34 VC6内存分配（2）</h2><h3 id="（3）-heap-alloc-base"><a href="#（3）-heap-alloc-base" class="headerlink" title="（3）_heap_alloc_base()"></a>（3）_heap_alloc_base()</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061135466.png" alt="4_内存管理_93"></p>
<ul>
<li>调用<code>_heap_alloc_base</code>分配内存，小于阈值的内存交给sbh服务，大于阈值的内存交给操作系统HeapAlloc来服务；</li>
<li>这里<code>_Sbh_threshold</code>的值是<code>1016B</code>，这是因为还没有加cookie（大小为8），两者加起来是<code>1024B</code>。</li>
</ul>
<h3 id="（4）-sbh-alloc-block"><a href="#（4）-sbh-alloc-block" class="headerlink" title="（4）_sbh_alloc_block()"></a>（4）_sbh_alloc_block()</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061136305.png" alt="4_内存管理_94"></p>
<p>在前面<code>block</code>的基础上，上下添加<code>cookie</code>（体现在2*sizeof(int)，以及下图右侧上下两块红色的地方0x131），后面涉及到的(BYTE_PER_PARA-1) 是进行向上调整ROUND_UP，调整到16的倍数。</p>
<ul>
<li><strong>cookie的计算</strong>：<ul>
<li>首先是<code>_ioinit</code>首次需要的内存<code>256B</code>（0x100，浅绿色的部分）;</li>
<li>然后是调试器加的<code>debug header</code>，大小为<code>9 x 4 = 36B</code>（0x24，灰色部分和深绿色部分(4个0xfd)），再加上下两个cookie大小<code>4 x 2 = 8B</code>（0x8），所有的加起来：0x100 + 0x24 + 0x8 &#x3D; 0x12C，<strong>向上调整到16的倍数</strong>，变成<code>0x130</code>；</li>
<li>最后，末位为<code>1</code>表示这块内存分配出去，如果末位为0则表示这块内存还在<code>sbh</code>手上。这里是分配出去的内存，所以<code>cookie</code>里面填的值是<code>0x131</code>。</li>
</ul>
</li>
</ul>
<h2 id="35-VC6内存分配（3）"><a href="#35-VC6内存分配（3）" class="headerlink" title="35 VC6内存分配（3）"></a>35 VC6内存分配（3）</h2><p>上述函数的作用都是确定该分配内存的大小，接下来真正进行内存分配的任务。</p>
<h3 id="（5）-sbh-alloc-new-region"><a href="#（5）-sbh-alloc-new-region" class="headerlink" title="（5）_sbh_alloc_new_region()"></a>（5）_sbh_alloc_new_region()</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061139061.png" alt="4_内存管理_95"></p>
<p>共<code>16</code>个<code>header</code>，每个<code>header</code>负责<code>1MB</code>的内存。</p>
<p><code>header</code>有两个指针：</p>
<ul>
<li>一个指向<strong>真正的内存</strong>；</li>
<li>另一个指向<strong>管理中心（region）</strong>，上图中橙色框圈出来的就是<code>new region</code>，具体细节如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagRegion</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> indGroupUse;                  <span class="comment">// 一个整数</span></span><br><span class="line">	<span class="type">char</span> cntRegionSize[<span class="number">64</span>];           <span class="comment">// 64个char</span></span><br><span class="line">    <span class="comment">// 下面两者合并，共有32组，每组64bits，用来管理区块在链表中存在与否等细节</span></span><br><span class="line">	BITVEC bitvGroupHi[<span class="number">32</span>];           <span class="comment">// unsigned int</span></span><br><span class="line">	BITVEC bitvGroupLo[<span class="number">32</span>];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tagGroup</span> grpHeadList[<span class="number">32</span>];  <span class="comment">// 32个group</span></span><br><span class="line">&#125;</span><br><span class="line">REGION, *REGION;</span><br></pre></td></tr></table></figure>

<ul>
<li>每一个<code>group</code>是<code>64</code>个<code>ListHead</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagGroup</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> cntEntries;                   <span class="comment">// 记录累计分配出去的区块</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tagListHead</span> listHead[<span class="number">64</span>];  <span class="comment">// 64个ListHead</span></span><br><span class="line">&#125;</span><br><span class="line">GROUP, *PGROUP;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ListHead</code>里面有两个指针，双向链表</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagListHead</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tagEntry</span>* pEntryNext;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tagEntry</span>* pEntryPrev;</span><br><span class="line">&#125;</span><br><span class="line">LISTHEAD, *PLISTHEAD;	</span><br></pre></td></tr></table></figure>

<p>一个<code>region</code>的大小大概有<code>16K</code>左右。管理右侧的虚拟地址空间的成本即为<code>region</code>的大小，<code>16K</code>。</p>
<h2 id="36-VC6内存分配（4）"><a href="#36-VC6内存分配（4）" class="headerlink" title="36 VC6内存分配（4）"></a>36 VC6内存分配（4）</h2><p>接下来就是如何从<code>1MB</code>内存中切出一块。</p>
<h3 id="（6）-sbh-alloc-new-group"><a href="#（6）-sbh-alloc-new-group" class="headerlink" title="（6）_sbh_alloc_new_group()"></a>（6）_sbh_alloc_new_group()</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061241209.png" alt="4_内存管理_96"></p>
<p>将右侧的虚拟内存空间（大小为<code>1MB</code>），分成<code>32</code>块，每个<code>group</code>管理<code>1</code>块，每一块大小为<code>1MB / 32 = 32KB</code>。然后再将每一块细分为<code>8</code>个<code>page</code>，每个<code>page</code>大小为<code>32KB / 8 = 4KB</code>，如上图<code>page1, page2, …, page8</code>所示。</p>
<p>第<code>1</code>块由<code>group0</code>进行管理。<code>group0</code>里面有<code>64</code>条链表。<code>SBH</code>中用链表把第<code>1</code>块的<code>8</code>个<code>page</code>串起来，挂在<code>group0</code>里面<code>64</code>条链表的最后一条上。</p>
<p>当<code>_ioinit</code>第一次来要内存的时候，就从<code>group0</code>的<code>page1</code>挖一块给它。后面又有要内存的时候，就一直往后挖，如果<code>page1</code>到<code>page8</code>都被分配出去了，之后还是要内存，就到<code>group1</code>中去处理。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061241234.png" alt="4_内存管理_97"></p>
<ul>
<li><p><strong>黄色部分</strong>：这<code>32KB</code>（8个page）是一次性从操作系统分配过来的。每一个<code>page</code>的偏移值地方设置为<code>0xffffffff</code>，也就是<code>-1</code>（上图中黄色的部分），设置为<code>-1</code>的作用是合并的时候做分隔符（栅栏），分隔符（栅栏）之内的合并在一起。</p>
</li>
<li><p><strong>红色部分</strong>：有三个小块，下面两个红色的小块是两个指针，将8个page串起来，上面的一个红色小块是记录可用空间的大小，这里是<code>4080</code>（由4KB &#x3D; 4096B，4096减去两个黄色的部分（栅栏，分隔符）8B，剩下4088B，但是要下调到16的倍数，变成4080B，剩余的放到保留区），这上下两块<code>4080</code>是cookie，记录自己这一块的大小。</p>
</li>
</ul>
<p>64条链表负责不同大小的区块，分别是<code>16B， 32B， 64B,…, </code>每次增加16B，一直到最后一条链表，最后一条应该负责<code>64 x 16 = 1024B</code>的区块分配。<strong>另外最后一根链表还有一个任务，就是所有大于1024B的区块都由它负责</strong>。当切分完之后如果剩下的空间小于1024B，就要挂载到对应区块大小的那根链表上。</p>
<p>这64条链表上面还有一个整数<code>cntEntries</code>，表示分配的累积量，分配出去一个区块就<code>+1</code>，回收回来一个区块就<code>-1</code>。</p>
<h2 id="37-VC6内存分配（5）"><a href="#37-VC6内存分配（5）" class="headerlink" title="37 VC6内存分配（5）"></a>37 VC6内存分配（5）</h2><p>下面分析第一个<code>page</code>怎么切分。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061248201.png" alt="4_内存管理_98"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4080 = 0xff0</span><br></pre></td></tr></table></figure>

<p>上面<code>_ioinit</code>第一次要的内存是<code>256B</code>（0x110），然后加上各种<code>debug header</code>和其他，总共是<code>0x130</code>，所以给出去的内存是<code>0x130</code>，<code>cookie</code>记录的值是<code>0x131</code>。</p>
<p>剩下的大小为<code>0xff0 - 0x130 = 0xec0</code>。</p>
<ul>
<li><p>上图左侧<strong>红色的地址0x007d0ed0</strong>是传出去的指针，<strong>指向的是客户要的<code>0x130</code>大小（加上各种debug header等）的内存</strong>。<strong>然后0x130内部还要调整指针，指向实际要的大小0x100大小的位置，就是图中的纯绿色（fill 0xcd）位置。这就是_ioinit获得的空间的位置。</strong></p>
</li>
<li><p>上图右侧的<code>_NORMAL_BLOCK </code>和<code>_CRT_BLOCK</code>指的是不同类型的<code>block</code></p>
<ul>
<li><p><code>_NORMAL_BLOCK</code>是<code>main</code>函数里面具体用的<code>block</code>，它在<code>main</code>函数结束的时候应该全部被归还，否则就是内存泄漏；</p>
</li>
<li><p><code>_CRT_BLOCK</code>在<code>main</code>函数运行结束之后还会存在，它会由<code>CRT</code>进行释放。</p>
</li>
</ul>
</li>
</ul>
<h2 id="38-SBH行为分析-分配-释放之连续动作图解（1）"><a href="#38-SBH行为分析-分配-释放之连续动作图解（1）" class="headerlink" title="38 SBH行为分析 分配+释放之连续动作图解（1）"></a>38 SBH行为分析 分配+释放之连续动作图解（1）</h2><p>（1）首次需求</p>
<p><strong>首次需求</strong>是由<code>ioinit.c</code>第<code>81</code>行代码发出，申请<code>100H</code>的空间，加上各种<code>debug header</code>，它的区块大小变成<code>130H</code>（十进制是304），应该由<code>64</code>条链表中的第<code>304 / 16 - 1 = 18</code>号链表进行供应（不同链表区块大小是16的倍数）。<strong>但是前63条链表都为空，只有最后一条（#63）有空间。下面就是以最后一条链表（#63）来讲解。</strong></p>
<p><code>SBH</code>面对这样的需求，它在初始化的时候已经有<code>16</code>个<code>header</code>，现在<code>0</code>号<code>header</code>来进行处理。</p>
<ol>
<li>它首先分配<code>1MB</code>的地址空间，这个动作是由<code>VirtualAlloc</code>去拿到的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, <span class="number">1</span>MB, MEM_RESERVE, ...)</span><br></pre></td></tr></table></figure>

<p>这段代码使用了<code>VirtualAlloc</code>函数，该函数是 Windows API 提供的用于虚拟内存操作的函数之一。在这里，<code>VirtualAlloc</code>用于分配 1MB 的地址空间，并且使用<code>MEM_RESERVE</code>标志表示要保留这个地址空间，而不分配物理内存。</p>
<ul>
<li>0：表示欲分配或保留的内存区域的起始地址。在这里，设置为 0，表示让系统决定分配的地址。</li>
<li>1MB：表示要分配或保留的内存区域的大小，这里是 1MB。</li>
<li>MEM_RESERVE：表示要保留而不是分配物理内存。这样做可以预留地址空间，但只有在访问这些地址空间时才会分配物理内存。</li>
<li>…：其他参数，这里没有提供具体的细节。</li>
</ul>
<p><strong>所以，这个调用的目的是在虚拟地址空间中保留 1MB 的地址区域，但实际上并没有分配物理内存。这样的操作通常用于预留地址空间，以便在需要时再分配实际的物理内存。</strong></p>
<ol start="2">
<li>其次，<code>header0</code>有另外一根指针分配出<code>region</code>，这个动作是由<code>HeapAlloc</code>进行</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">HeapAlloc</span>(_crtheap, <span class="built_in">sizeof</span>(REGION));</span><br></pre></td></tr></table></figure>

<p>这个<code>region</code>里面就是上文介绍的，里面有一些<code>bit</code>，还有<code>32</code>个<code>group</code>，每个<code>group</code>有<code>64</code>条链表。</p>
<p>上述动作准备好之后，要从虚拟地址空间中分配<code>32KB</code>（被分成8个page，每个page大小为4KB），8个page由指针串起来，这次内存分配是用<code>VirtualAlloc</code>进行的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">VirtualAlloc</span>(addr, <span class="number">32</span>KB, MEM_COMMIT, ...)  <span class="comment">// MEM_COMMIT表示真的分配内存</span></span><br></pre></td></tr></table></figure>

<p>万事俱备，开始在page1上分配刚开始的需求：申请的<code>100h</code>，区块大小<code>130h</code>，十进制大小<code>4080</code>。剩下的大小为<code>0xff0 - 0x130 = 0xec0</code>，这部分还在<code>SBH</code>控制之中，<code>130h</code>被分配出去，所以cookie记为<code>131h</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061255241.png" alt="4_内存管理_99"></p>
<p>下面红色方框中是32组64bits，64bits分别对应64根链表的状态，哪一条链表有挂区块，对应的bit就设置为1。32组表示的是32个group</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061255415.png" alt="在这里插入图片描述"></p>
<p>（2）第二次需求</p>
<p><strong>第二次需求，这个需求是<code>CRT</code>里面谁发出来的需求呢？是上面讲的<code>call stack</code>中的<code>__crtGetEnvironmentStringsA()</code>发出的。</strong></p>
<p>这次需求是且分出<code>240H</code>的大小（包含各种debug header，调整16的边界等之后的大小），这个240h的区块应该由哪条链表提供服务呢？240h &#x3D; 576d（d表示十进制）,576 &#x2F; 16 -1 &#x3D; 35, 所以由#35号链表提供服务。然后去检查64bits中35号对应的bit，看看是否挂有区块，这里的情况是#35链表是空的。 然后退而求其次逐渐遍历更大容量的链表，这里只能找到最大的那条链表，这里最后一条是#63（从0开始编号）。</p>
<p>和前面一样，检查#63链表发现它有8个page，page1还有空间可用。从这里切出<code>240h</code>的大小，经过两次切割之后，<code>page1</code>还剩<code>c80h</code>大小，<code>ec0h - 240h = c80h</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061256770.png" alt="4_内存管理_100"></p>
<p>（3）第三次需求</p>
<p><strong>第三次需求分配<code>70h</code>的大小。</strong>首先先检查应该是几号链表服务刚刚好？这里是<code>70h = 112D</code>, <code>112 / 16 - 1 = 6</code>, 应该由6号链表服务，但是它是空的，往上寻找只发现最后一个链表有区块。</p>
<p><code>page1</code>继续分配空间，这次分配之后还剩下<code>c80h - 70h = c10h</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061256560.png" alt="4_内存管理_101"></p>
<h2 id="39-SBH行为分析-分配-释放之连续动作图解（2）"><a href="#39-SBH行为分析-分配-释放之连续动作图解（2）" class="headerlink" title="39 SBH行为分析 分配+释放之连续动作图解（2）"></a>39 SBH行为分析 分配+释放之连续动作图解（2）</h2><p>上面是分析内存分配的情况，下面分析一下内存回收的阶段。</p>
<p>下图是第<code>15</code>次的动作，它前面有<code>14</code>次内存分配，这次是内存释放（回收），右上角可以看到<code>cntEntries</code>由<code>14</code>变成<code>13</code>，内存释放会<code>-1</code>.</p>
<p>这次释放的是大小为<code>240h</code>的区块，这一块应该回收到<code>64</code>条链表中的哪一条呢？<code>240h = 576D， 576 / 16 - 1 = 35</code>，所以应该还到<code>#35</code>号链表。由于分配出去的<code>cookie</code>为<code>241h</code>，现在将其变为<code>240h</code>，就表示回收回来，在<code>SBH</code>的掌控之下。然后<code>64bits</code>中<strong>第35号bit需要由0变成1</strong>。</p>
<blockquote>
<p>切割实际上只是cookie的调整。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061257419.png" alt="4_内存管理_102"></p>
<h2 id="40-SBH行为分析-分配-释放之连续动作图解（3）"><a href="#40-SBH行为分析-分配-释放之连续动作图解（3）" class="headerlink" title="40 SBH行为分析 分配+释放之连续动作图解（3）"></a>40 SBH行为分析 分配+释放之连续动作图解（3）</h2><p>下图是第<code>16</code>次的动作，还是内存分配的动作</p>
<p>这次分配的是<code>b0h</code>，应该由哪条链表来服务呢？<code>b0h = 176D， 176 / 16 - 1 = 10</code>，所以应该由<code>#10</code>号链表服务，但是它是空的。此时需要向右寻求拥有更大区块的链表的帮助，这里从<code>#10</code>号往右逐个查找，发现上次回收了回来第<code>#35</code>号链表，它是可用的，所以这次应该由#35号链表提供服务。</p>
<p>上次刚回收回来<code>240h</code>，分配出去<code>b0h</code>，这块空间还剩多大？<code>240h - b0h = 190h</code>。</p>
<p>这里的<code>190h</code>，应该挂到哪条链表呢？ <code>190h = 400D, 400 / 16 - 1= 24</code>，所以应该挂到<code>#24</code>号链表。此时<code>64bits</code>中的<code>24号bit</code>需要变成<code>1</code>，表示该号链表有区块可分配。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061257265.png" alt="4_内存管理_103"></p>
<p>一直进行下去，不断的进行内存分配和回收。</p>
<p><code>group1</code>共有<code>32KB</code>，下面的第一行表示的就是<code>group1</code>的<code>64</code>条链表的使用情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">02000014</span> <span class="number">00000000</span>H  <span class="comment">// 共64bits，表示的是第几号链表时候有区块</span></span><br></pre></td></tr></table></figure>

<p>展开成二进制，发现有3个链表挂有区块，有可用空间供分配。</p>
<p>现在要分配的大小为<code>230h</code>，上面的<code>group1</code>中的可用链表都不能满足它的需求</p>
<p>现在用的是<code>group2</code>，对于<code>group2</code>中，<code>230h</code>应该由几号链表来服务呢？ <code>230h = 560D， 560 / 16 - 1 = 34</code>，理想的状况是由<code>34</code>号链表服务，它检查下面的表示链表状态的64bits，</p>
<p>这里第二行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000001</span>H  <span class="comment">// 表示只有最后一条链表有可用空间供分配</span></span><br></pre></td></tr></table></figure>

<p>表示只有最后一条链表有可用空间供分配，最后一条链表的编号为<code>#63</code>， 每个大小<code>page</code>还是<code>4080D = ff0H</code>。</p>
<p>现在<code>ff0H</code>分配出去<code>230H</code>，还剩<code>ff0h - 230h = dc0h</code>，<code>dc0h</code>应该挂在哪个链表上呢？<code>dc0h = 3520D</code>，表示空间大小为<code>3520B</code>，比前<code>63</code>条链表的区块（小于<code>1024B</code>）还要大，它只能还挂在<code>#63</code>号链表上。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061258561.png" alt="4_内存管理_104"></p>
<h2 id="41-SBH行为分析-分配-释放之连续动作图解（4）"><a href="#41-SBH行为分析-分配-释放之连续动作图解（4）" class="headerlink" title="41 SBH行为分析 分配+释放之连续动作图解（4）"></a>41 SBH行为分析 分配+释放之连续动作图解（4）</h2><p><strong>VC6内存管理：区块的合并</strong></p>
<p>如果回收的是相邻的空间，则应该合并。这里的上cookie表示的是上面的cookie，下cookie表示的是下面的cookie。下图左侧第一张图中灰色部分表示待收回的区块300h，它的上下两部分为白色，表示已经回收过来的区块，可以合并。</p>
<p>（1）首先往下看，怎么往下看呢？</p>
<p>指针找到自己的cookie大小，这里是300h，指针移动300h，就到了下面一个区块的cookie位置，看最后1bit是否是为0，如果为0，表示可以和下面的区块合并。</p>
<p>现在发现，下方区块为free，也为300h，合并之，合并为600h，如第二张图中间灰色部分所示。</p>
<p>总之，往下合并，用的就是上cookie，根据上cookie的大小，指针移动cookie个大小，就可以找到下一个区块的位置。</p>
<p>（2）其次往上看，怎么往上看呢？</p>
<p>指针还在自己cookie的位置，往上移动4字节，就找到上方区块的下cookie，判断最后1bit是否为0，若为0，就表示可以和上面的区块合并。</p>
<p>现在发现，上方区块也为free，大小也为300h，合并之。</p>
<p>总之，往上合并，用的是上面区块的下cookie，根据这个值，往上跳cookie个大小，找到上面区块的起始位置。如果没有下cookie，就不能往上合并。</p>
<p>（3）三个300h合并大小为900h，然后去找900h应该挂在几号链表上，900h &#x3D; 2304D， 2304大于1024，所以它应该挂在最后一个链表#63上，它用来处理大于1024B的区块。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061258046.png" alt="4_内存管理_105"></p>
<h2 id="42-VC6内存管理free（p）"><a href="#42-VC6内存管理free（p）" class="headerlink" title="42 VC6内存管理free（p）"></a>42 VC6内存管理free（p）</h2><p><code>free</code>回收，<code>SBH</code>要确定落在哪个<code>header</code>（共16个header）指定的<code>1MB</code>空间中，然后确定是这个<code>header</code>中的哪个<code>group</code>，然后确定这个<code>group</code>中的<code>64</code>条链表中的哪个链表。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061258074.png" alt="4_内存管理_106"></p>
<h2 id="43-VC6内存管理总结（上）"><a href="#43-VC6内存管理总结（上）" class="headerlink" title="43 VC6内存管理总结（上）"></a>43 VC6内存管理总结（上）</h2><p>分成<code>16</code>个<code>header</code>，每个<code>header</code>管理<code>1MB</code>的虚拟空间，这个虚拟空间分成<code>32</code>个<code>group</code>（每个<code>group</code>管理大小为32KB的空间），每个<code>group</code>里有<code>64</code>个链表。</p>
<p>这里的管理是分段管理（一段是<code>32KB</code>），分段的时候便于一段全部回收，然后还给操作系统。</p>
<p><strong>如何判断全回收？</strong></p>
<p>因为每个<code>group</code>中都有一个<code>cntEntries</code>，统计分配和回收的区块数量，当它为<code>0</code>的时候，意味着这个<code>group</code>全回收，这一段<code>32KB</code>就可以还给操作系统。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagGroup</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> cntEntries; <span class="comment">// 记录累计分配出去的区块</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tagListHead</span> listHead[<span class="number">64</span>];  <span class="comment">// 64个ListHead</span></span><br><span class="line">&#125;</span><br><span class="line">GROUP, *PGROUP;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061259550.png" alt="4_内存管理_107"></p>
<p><code>cntEntries = 0</code>的时候，这些区块是什么样子呢？它们已经进行了合并，合并到初始状态，即<code>8</code>个<code>page</code>分别挂载<code>4080B</code>那个状态，如下图所示，然后挂在<code>#63</code>号链表上。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061259316.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>不急着还给操作系统，有一个<code>defering</code>，延缓归还的操作。</p>
<p>有一个全回收的<code>group</code>时，先暂存，当有第二个全回收的<code>group</code>时，才释放前面那个<code>group</code>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061300668.png" alt="4_内存管理_108"></p>
<h2 id="44-VC6内存管理总结（下）"><a href="#44-VC6内存管理总结（下）" class="headerlink" title="44 VC6内存管理总结（下）"></a>44 VC6内存管理总结（下）</h2><p>释放所有的内存块，SBH系统的面貌就是初始状态，如前面所述。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061300128.png" alt="4_内存管理_109"></p>
<blockquote>
<p>第二讲讲的是GNU C++的分配器，这里的第三讲涉及的是VC的malloc函数，可以把它们混在一起吗？其实GNU C++的malloc实现差不多。</p>
<p>这里再系统化一遍。</p>
<p>allocator要内存，底部还是向malloc要内存。</p>
<p>allocator设计成16个链表的目的不是提升分配的速度，而是为了去除malloc的cookie开销，减少malloc的次数，每一次malloc要一大块内存，然后切分成相等的区块，这样就可以去除每一小块的cookie。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061301504.png" alt="4_内存管理_111"></p>
<p><strong>从操作系统的API(这里是windows系统，比如HeapAlloc， VirtualAlloc)，到CRT的malloc设计，再到std::allocator的底部实现，都有类似的链表管理结构。</strong><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061301013.png" alt="4_内存管理_112"></p>
<h1 id="第四讲-loki-allocator"><a href="#第四讲-loki-allocator" class="headerlink" title="第四讲 loki::allocator"></a>第四讲 loki::allocator</h1><h2 id="45-上中下三个classes分析"><a href="#45-上中下三个classes分析" class="headerlink" title="45 上中下三个classes分析"></a>45 上中下三个classes分析</h2><p>Loki 是 C++ 中一个开源的库，其中包含一组通用的 C++ 组件。在 Loki 库中，有一个称为 Loki::Allocator 的组件，它是一个用于内存分配的工具。讲这个分配器是为了和GNU C++中的alloc分配器作比较，alloc分配器最后的内存并没有还给操作系统。</p>
<p>Loki allocator的三个类，从低阶到高阶分别为：<code>Chunk, FixedAllocator, SmallObjAllocator</code>。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061930580.png" alt="4_内存管理_117"></p>
<ul>
<li>Chunk</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pData_: <span class="type">unsigned</span> <span class="type">char</span>* <span class="comment">// 指针，指向分配的一个chunk</span></span><br><span class="line">firstAvailableBlock_：<span class="type">unsigned</span> <span class="type">char</span> <span class="comment">// 第一个可用区块</span></span><br><span class="line">blocksAvailable_: <span class="type">unsigned</span> <span class="type">char</span> <span class="comment">// 目前还可以供应几个区块</span></span><br></pre></td></tr></table></figure>

<ul>
<li>FixedAllocator</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">chunks_: vector&lt;Chunk&gt; <span class="comment">// vector里面放了很多chunk</span></span><br><span class="line"><span class="comment">// 两个指针，指向某两个Chunk</span></span><br><span class="line">allocChunk_: Chunk* </span><br><span class="line">deallocChunk_: Chunk*</span><br></pre></td></tr></table></figure>

<ul>
<li>SmallObjectAllocator</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pool_: vector&lt;FixedAllocator&gt;  <span class="comment">// 里面放了很多FixedAllocator</span></span><br><span class="line"><span class="comment">// 两个指针，指向某两个FixedAllocator</span></span><br><span class="line">pLastAlloc: FixedAllocator*</span><br><span class="line">pLastDealloc: FixedAllocator*</span><br><span class="line">chunkSize: <span class="type">size_t</span></span><br><span class="line">maxObjectSize: <span class="type">size_t</span></span><br></pre></td></tr></table></figure>

<h2 id="46-Class-Chunk分析"><a href="#46-Class-Chunk分析" class="headerlink" title="46 Class Chunk分析"></a>46 Class Chunk分析</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061935095.png" alt="4_内存管理_125"></p>
<ul>
<li><code>Init()</code><ul>
<li>动态分配一大块Chunk；</li>
<li>调用<code>Reset()</code><ul>
<li>上图中可用的block个数为64，第一个可用的block编号为0；</li>
<li>for循环把每个block的第一个字节当作索引index使用（类似于嵌入式指针）</li>
</ul>
</li>
</ul>
</li>
<li><code>Release()</code><ul>
<li>调用<code>delete[]</code>释放空间，归还操作系统。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061936225.png" alt="4_内存管理_126"></p>
<ul>
<li><code>Allocate()</code><ul>
<li>分配一个可用区块，并赋予其最高优先权；</li>
<li><code>firstAvailableBlock_</code>对应指向下一个可用区块，比如这里可用区块的索引从左边的4变成了右边的3，剩余区块个数也相应调整。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061938608.png" alt="4_内存管理_127"></p>
<ul>
<li><code>Deallocate()</code><ul>
<li>用p指针减去头指针然后除以每个block的大小，得到该释放的block的索引（即该block为第几个block）；</li>
<li>这个释放回收的block赋予最高优先权，成为<code>firstAvailableBlock_</code>;</li>
<li>最后，可利用的block个数<code>+1</code>。</li>
</ul>
</li>
</ul>
<h2 id="47-class-FixedAllocator分析（上）"><a href="#47-class-FixedAllocator分析（上）" class="headerlink" title="47 class FixedAllocator分析（上）"></a>47 class FixedAllocator分析（上）</h2><p>FixedAllocator</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">chunks_: vector&lt;Chunk&gt;  <span class="comment">// vector里面放了很多chunk</span></span><br><span class="line">allocChunk_: Chunk* 	<span class="comment">// 指向最近一次满足分配动作的chunk</span></span><br><span class="line">deallocChunk_: Chunk*	<span class="comment">// 指向最近一次回收的chunk</span></span><br><span class="line"><span class="comment">// 这两个chunk的指定符合数据的局部性原理</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Allocate的逻辑如下图所示：如果有最近的allocChunk_，那么直接取区块，</span></span><br><span class="line"><span class="comment">// 否则就要for循环从头开始遍历每个chunk，直到找到有可用空间的chunk。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061940593.png" alt="4_内存管理_128"></p>
<h2 id="48-class-FixedAllocator分析（下）"><a href="#48-class-FixedAllocator分析（下）" class="headerlink" title="48 class FixedAllocator分析（下）"></a>48 class FixedAllocator分析（下）</h2><ul>
<li>第二级FixedAllocator类的Deallocate函数，调用VicinityFind函数查找还回来的指针p落在哪个chunk，找到之后交给第一级Chunk类的Deallocate来处理。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061942795.png" alt="4_内存管理_129"></p>
<ul>
<li>VicinityFind()（临近搜寻）<ul>
<li>chunkLength是chunk的大小；lo是上次还回来的chunk，hi是下一个chunk；loBound和hiBound是vector的头跟尾</li>
<li>整体思路是：兵分两路，一路往上查找，一路往下查找。<ul>
<li>在lo里面找，找不到的话就往上面的chunk去查找，一直往上，一个接一个的chunk去找。</li>
<li>然后在hi里面找，找不到就往下面的chunk去查找，一直往下，一个接一个的chunk去找。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061943323.png" alt="4_内存管理_130"></p>
<ul>
<li>调用Deallocate()进行回收时，进行分情况处理。注意全回收时，需要确认有2个chunk，才会回收其中一个，也就是上文提到的<strong>deferring延缓回收</strong>。</li>
</ul>
<h2 id="49-Loki-allocator总结"><a href="#49-Loki-allocator总结" class="headerlink" title="49 Loki::allocator总结"></a>49 Loki::allocator总结</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061943975.png" alt="4_内存管理_131"></p>
<h1 id="第五讲-other-issues"><a href="#第五讲-other-issues" class="headerlink" title="第五讲 other issues"></a>第五讲 other issues</h1><h2 id="50-GNU-C-对allocators的描述"><a href="#50-GNU-C-对allocators的描述" class="headerlink" title="50 GNU C++对allocators的描述"></a>50 GNU C++对allocators的描述</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061944785.png" alt="4_内存管理_138"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061944147.png" alt="4_内存管理_139"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061944623.png" alt="4_内存管理_140"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061944227.png" alt="4_内存管理_141"></p>
<p><img src="C:/Users/86135/Desktop/内存管理/4_内存管理_142.png" alt="4_内存管理_142"></p>
<h2 id="51-VS2013标准分配器-G4-9标准分配器与new-allocator以及G4-9malloc"><a href="#51-VS2013标准分配器-G4-9标准分配器与new-allocator以及G4-9malloc" class="headerlink" title="51 VS2013标准分配器&amp;G4.9标准分配器与new_allocator以及G4.9malloc"></a>51 VS2013标准分配器&amp;G4.9标准分配器与new_allocator以及G4.9malloc</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061945904.png" alt="4_内存管理_143"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061945669.png" alt="4_内存管理_144"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061946198.png" alt="4_内存管理_145"></p>
<h2 id="52-G4-9-array-allocator"><a href="#52-G4-9-array-allocator" class="headerlink" title="52 G4.9 array_allocator"></a>52 G4.9 array_allocator</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061947049.png" alt="4_内存管理_146"></p>
<ul>
<li>指针<code>_M_array</code>指向一个C++数组，静态数组不需要释放与归还</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061947075.png" alt="4_内存管理_148"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061948852.png" alt="4_内存管理_147"></p>
<h2 id="53-G4-9-debug-allocator"><a href="#53-G4-9-debug-allocator" class="headerlink" title="53 G4.9 debug_allocator"></a>53 G4.9 debug_allocator</h2><p><code>debug_allocator</code>是一个包装器，把另一个分配器包装进来，这里是<code>_Alloc</code>分配器，定义为<code>_M_allocator</code>，实际分配的时候就是调用这个分配器的<code>allocate</code>，分配<code>n + extra</code>个大小的空间。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061948633.png" alt="4_内存管理_149"></p>
<h2 id="54-bitmap-allocator（上）"><a href="#54-bitmap-allocator（上）" class="headerlink" title="54 bitmap_allocator（上）"></a>54 bitmap_allocator（上）</h2><p>（1）介绍bitmap_allocator</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061949227.png" alt="4_内存管理_153"></p>
<ul>
<li><code>_M_allocate_single_object</code>和<code>_M_deallocate_single_object</code>：所有的<code>allocator</code>都是供给容器使用的，容器每次请求的都是一个元素的内存分配，所以这里就是<strong>单独处理一个<code>object</code>的请求</strong>。<strong>当不是一个object的时候，就会退化到operator new和operator delete</strong>，但是这种情况一般遇不到。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061950407.png" alt="4_内存管理_154"></p>
<p>当使用容器时，容器中一个元素的内存空间就是<code>block</code>，如果是<code>std::list</code>的时候，这个<code>block</code>还包括<code>node</code>里面的指针。上图中的<code>64blocks</code>指的是一次性挖<code>64个blocks</code>开始供应，注意这里是两倍成长，下次挖<code>128</code>个，再是<code>256</code>个，…。<strong>挖的这些blocks，加上前面的bitmap，还有前面的数值，一起称为super block。</strong></p>
<ul>
<li><code>bitmap</code>中是<code>64bits</code>（对应于blocks的数量），每个<code>bit</code>表示单个<code>block</code>的状态，<code>bitmap</code>是<code>unsigned int</code>，一个<code>bitmap</code>是<code>32</code>位，只能记录<code>32</code>个blocks的情况。这里是<code>64</code>个<code>blocks</code>，需要<code>2</code>个<code>bitmap</code>来记录。</li>
<li>前面还有一个整数<code>use count</code>，记录有几个block被分配。</li>
<li>最前面还有一个整数，记录<code>super block</code>的大小。</li>
<li>有一个<code>mini vector</code>（模拟标准库中的vector写出来的）来操纵<code>super block</code>，里面的<code>start</code>指针和<code>finish</code>指针分别指向<code>super block</code>的头和尾。</li>
</ul>
<p>（2）示例分析</p>
<ol>
<li>现在客户需要分配内存，此时深灰色这个block被分配出去：<ul>
<li>use count &#x3D; 1；</li>
<li>bitmap[0]最后一位变成0，表示已经分配出去</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061955406.png" alt="4_内存管理_155"></p>
<ol start="2">
<li>然后请求分配第二个block，下面两个灰色的block表示被分配出去：<ul>
<li>use count &#x3D; 2；</li>
<li>bitmap[0]后两位变成0，表示这两个block被分配出去。</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061955242.png" alt="4_内存管理_156"></p>
<ol start="3">
<li>后面一直分配block出去，下图表示已经分配出去63个block：<ul>
<li>对应的use count &#x3D; 63；</li>
<li>bitmap[1]和bitmap[0]变成80000000H和00000000H，只有最后一个block对应的bitmap中的bit才为1,表示未被分配出去。</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061957215.png" alt="4_内存管理_157"></p>
<ol start="4">
<li>下面客户归还其中一个block：<ul>
<li>对应的bitmap要变成1，表示未分配（回收回来）；</li>
<li>use count由63变成62。</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061957438.png" alt="4_内存管理_158"></p>
<ol start="5">
<li>当一个super block(有64个blocks)用完后，开始启用第二号super block，<strong>这时候super block中的block块数由64扩大两倍变成128个</strong>，由4个bitmap整数表示。而且mini vector中由一个单元变成两个单元，每个单元指向一个super block。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061957540.png" alt="4_内存管理_159"></p>
<ol start="6">
<li>第二个super block用完（前面已经用完第一个super block，其含有64个blocks，第二个super block包含128个blocks，也已经用完），<strong>启用第三个super bloc，其包含的blocks为128 x 2 &#x3D; 256个</strong>。mini vector中也有第三个单元来控制这个super block。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061958956.png" alt="4_内存管理_160"></p>
<h2 id="55-bitmap-allocator（下）"><a href="#55-bitmap-allocator（下）" class="headerlink" title="55 bitmap_allocator（下）"></a>55 bitmap_allocator（下）</h2><p>上面谈的是bitmap_allocator的分配，下面谈它的回收（容器归还元素空间）机制。</p>
<ol>
<li><p>第一个super block全回收，用另一个mini vector（称为free list）中的entry指针指向这个super block，表示已经回收。<strong>如果下次新分配一个super block，它其中blocks的数量要减半</strong>。</p>
<p>如下图所示，前三个superblocks大小分别为64个，128个，256个，由于第一个superblock被回收，那么下次分配的superblock大小由已经分配的最大值256变成一半，为128个blocks。原来的mini vector里面的指向回收的这个superblock头和尾的entry被删除。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061959663.png" alt="4_内存管理_161"></p>
<ol start="2">
<li>第二个super block也全回收，则free list里的entry加一个，指向这个super block。原来的mini vector里面指向这个superblock头尾的entry被删除。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062000036.png" alt="4_内存管理_162"></p>
<ol start="3">
<li>第三个super block被全回收，被free list的指针指向。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062000522.png" alt="4_内存管理_163"></p>
]]></content>
      <categories>
        <category>Computer</category>
        <category>C++</category>
        <category>侯捷C++系列</category>
      </categories>
  </entry>
  <entry>
    <title>C++ Allocator</title>
    <url>/2024/05/06/Computer/C++/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9/C++%20Allocator/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h2 id="1、GNU-allocator总述（pool-allocator"><a href="#1、GNU-allocator总述（pool-allocator" class="headerlink" title="1、GNU allocator总述（pool_allocator)"></a>1、GNU allocator总述（pool_allocator)</h2><p>allocator，作为一个STL的分配器，其底层是由<code>new/delete</code>进行实现的。</p>
<h3 id="在GNU的编译器里面"><a href="#在GNU的编译器里面" class="headerlink" title="在GNU的编译器里面"></a><strong>在GNU的编译器里面</strong></h3><ul>
<li>对于比较大的或者一般的allocator，我们一般调用<code>::operator new/delete allocator和deallocate</code>进行</li>
<li>对于较小块内存的分配，在GNU2.9里面有一个比较特殊的设计。</li>
</ul>
<!--more-->

<h3 id="GNU-pool-allocator分配器简述"><a href="#GNU-pool-allocator分配器简述" class="headerlink" title="GNU pool allocator分配器简述"></a><strong>GNU pool allocator分配器简述</strong></h3><ul>
<li><p>核心思想</p>
<ul>
<li><p>首先分配一个数组，里面含有16个指针，这16个指针在未来会再一次指向对应的内存空间，每一个指针都会负责比前一个指针多8bytes的数据。</p>
</li>
<li><p>每一个指针再一次分配的时候。一般会分配40个和对象+一个上一个分配空间&#x2F;4的一样大的空间，每一个空间里面包括一个嵌入式指针，指向下一块空间，其中20个作为现在的用池，用来进行对象的安放。剩下的就作为后面的战备池每一次分配出去一个，指针就往下移动一个。</p>
</li>
<li><p>当需要分配新的对象的时候</p>
<ul>
<li>如果战备池子有充足的空间，就从战备池子取一定的空间，具体看战备池能取出多少就取出多少，最多不超过20个。<ul>
<li>如果战备池子没有多余的空间，就重新分配一块内存，同时如果战备池的空间不足以分配当前一个对象，就将这个空间交还给对应的链表。</li>
<li>如果在无法分配内存的情况下，就会从现有的，比他大一级的池子（右边第一个池子）里面分配内存，只是裁剪出来一块挂到对应的链表中。当右边没有的时候就会分配失败。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>优点与缺点</p>
<ul>
<li><p>优点</p>
<ul>
<li>减少了cookie，使得软件拥有了更大的内存分配空间。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>无法释放已经分配的内存，存在着不少的内存浪费的情况。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2、loki-allocator"><a href="#2、loki-allocator" class="headerlink" title="2、loki allocator"></a>2、loki allocator</h2><p>loki allocator是分配器里面一个比较特殊的设计。</p>
<h3 id="设计框架"><a href="#设计框架" class="headerlink" title="设计框架"></a><strong>设计框架</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">底层：</span><br><span class="line">   底层作为alloc直接管理的一个基层，他是中层的一个嵌套类</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">chunk</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>* pData;  --指针，指向分配内存的头部</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> firstAvailableBlock;--记录下一个可以供给分配的内存</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> blocks;--记录总的可分配格子的大小</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">中层：</span><br><span class="line">   中层作为alloc管理基层的工具，以一个小型的vector为基础。担任分配和释放的操作</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixedAlloctor</span>&#123;</span><br><span class="line">	vector&lt;chuck&gt; chucks; --管理底层的<span class="function">vector</span></span><br><span class="line"><span class="function">	chuck* <span class="title">allocChucks</span><span class="params">()</span></span>; --分配<span class="function">chuck</span></span><br><span class="line"><span class="function">	chuck* <span class="title">deallocChucks</span><span class="params">()</span></span>; --销毁chuck</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">高层：</span><br><span class="line">	高层继承中层，作为主要的对外接口，去分配和释放内存，他的客户是STL</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallObjAllocator</span>&#123;</span><br><span class="line">	vector&lt;FixedAllocator&gt; pool; --管理中层的vector</span><br><span class="line">	FixedAllocator* pLastAlloc;  --指向最后一个可以分配的alloc</span><br><span class="line">	FixedAllocator* pLastDealloc;--指向最后一个销毁的alloc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><p>1.首先，创建一个smallobjallocator，然后制定分配的内存和大小。</p>
<ul>
<li>一般情况下，一次性默认要4096字节空间，超过256字节就不使用loki了。</li>
</ul>
<p>2.每一次进行分配内存的时候指定内存大小，然后进行分配。</p>
<p>3.在释放的时候需要其制定的内存大小和指针就可以进行释放了。</p>
<h3 id="工作逻辑"><a href="#工作逻辑" class="headerlink" title="工作逻辑"></a><strong>工作逻辑</strong></h3><p>chuck</p>
<p>1.chuck首先按照上层的要求进行初始化。调用init。初始化大小，初始化内存空间及其对应的数字</p>
<p>2.然后索要对应的内存，进行分配，如果分配的内存大小和之前相同，就从之前的取</p>
<p>3.在alloc的时候</p>
<ul>
<li>chuck首先找到下一个可以分配的内存，将其分配出去，</li>
<li>同时将内存写好中的数字记录下来，这个数字就是下一个可以分配的内存空间</li>
</ul>
<p>4.在dealloc的时候</p>
<ul>
<li><p>首先利用从中间向两边找的准则，找到对应的位置（中间层，剩下的是底层）</p>
</li>
<li><p>chuck然后找到将进来的指针进行强制类型转换</p>
</li>
<li><p>然后将原先的下一个内存的数字给他</p>
</li>
<li><p>然后通过指针去找他和之前有几个格子的距离，为firstAvailblocks赋予新的值</p>
</li>
</ul>
<p>其他两层按照vector的方式去进行操作和管理。</p>
<h2 id="3、new-allocator与malloc-allocator"><a href="#3、new-allocator与malloc-allocator" class="headerlink" title="3、new_allocator与malloc_allocator"></a>3、new_allocator与malloc_allocator</h2><p>new_allocator与malloc-allocator唯一的区别就是。</p>
<ul>
<li>new allocator可以重载operator::new,可以实现自由的构建malloc不行，他直接调用malloc去使用。</li>
<li>重载operator::new的一个功能就是可以在一定程度上接管alloc所作的工作，去灵活的管理。</li>
</ul>
<h2 id="4、array-allocator"><a href="#4、array-allocator" class="headerlink" title="4、array_allocator"></a>4、array_allocator</h2><p>array_allocator是一个数组类型的分配器，他可以分配固定的内存。</p>
<p>在main程序运行之前，底层函数就已经通过固定的程序让array_allocator这个其依赖的基本数据结构array可用了。</p>
<h2 id="5、debug-allocator"><a href="#5、debug-allocator" class="headerlink" title="5、debug_allocator"></a>5、debug_allocator</h2><p>这个是一个allocator的适配器，类似于stack，他可以帮助程序员调试allocator的内部操作，没什么用。</p>
<h2 id="6、bitmap-allocator"><a href="#6、bitmap-allocator" class="headerlink" title="6、bitmap_allocator"></a>6、bitmap_allocator</h2><h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a><strong>层次结构</strong></h3><p>bitmap_allocator结构分为两层</p>
<p>记录层：这层主要用来记录那些blocks的内存被分配掉了,private&#x2F;public关系省略了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">bitmap</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> useCount;  <span class="comment">//记录使用的blocks数目</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> superBlockSize;  <span class="comment">//记录整个记录层和管理层一共占用的空间总数</span></span><br><span class="line">	<span class="type">char</span> bitmapGuide[bitmapSize] = ‘F’;  <span class="comment">//用16个字符记录使用的数目,bitmapSize是一个可以变的数目，后续根据是否需要扩容决定</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>管理层：这层主要用来管理对应的分配出来的blocks，做实质的alloc&#x2F;dealloc操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">block</span>&#123;</span><br><span class="line">	T *p; --有一个指针</span><br><span class="line">	<span class="built_in">block</span>(<span class="type">int</span> number = <span class="number">4096</span>)&#123;</span><br><span class="line">		p=<span class="keyword">new</span> <span class="built_in">T</span>(number/<span class="built_in">sizeof</span>(<span class="built_in">T</span>()))  <span class="comment">// 为T分配一块内存，这块内存按照传入的字节大小去除一个T对象本身的大小（注意这段代码是伪代码，本身是错误的）</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">tempate &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> superBlock&#123;</span><br><span class="line">	block&lt;T&gt; blocks[<span class="number">64</span>]  <span class="comment">// 这块默认是64个blocks，64个blocks组成一个superBlocks</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在有以上两个之后，然后</span></span><br><span class="line">superBlock&lt;T&gt; blockss;  <span class="comment">// 创建内存</span></span><br><span class="line"><span class="function">mini_vector&lt;T*&gt; <span class="title">vector</span><span class="params">(<span class="number">2</span>,<span class="literal">nullptr</span>)</span></span>;  <span class="comment">// 创建一个minivector，这个是用来储存blockss的头尾指针的</span></span><br><span class="line">vector[<span class="number">0</span>]=&amp;(blockss[<span class="number">0</span>]);</span><br><span class="line">vector[<span class="number">1</span>]=&amp;(blockss[<span class="number">63</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h3><p>具体图解见笔记。</p>
<ul>
<li><p>对于少量内存分配</p>
<ul>
<li><p>选择一格，把他们分配出去</p>
</li>
<li><p>在记录层记录blocks数目的记录加一（已经使用一格）</p>
</li>
<li><p>更改bitmap</p>
<ul>
<li>注意，bitmap的读条方式是，bitmap地图从左往右，对应内存池的从右边向左边的格子，利用二进制表明其是否被占用</li>
</ul>
</li>
</ul>
</li>
<li><p>对于大量内存分配</p>
<ul>
<li><p>如果在一个bitmap不够的情况下就变成原来的两倍，也就是bitmap大小为32，有128个blocks</p>
</li>
<li><p>后面每一次分配都会加量一次（原先x2），每一次全回收都会减量一次（原先&#x2F;2）</p>
</li>
</ul>
</li>
<li><p>对于回收</p>
<ul>
<li><p>和malloc一样，他会有一个“垃圾寄存处”，当不需要的时候，会重新分配一个minivector来寄存这些已经全回收的内存，如果需要的话也是优先看手上有没有</p>
</li>
<li><p>如果有则使用，当有64个组以上的minivector的时候，进行回收。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Computer</category>
        <category>C++</category>
        <category>零散知识点</category>
      </categories>
  </entry>
</search>
