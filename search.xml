<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vscode连接阿里云如何免密</title>
    <url>/2023/08/01/vscode%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E5%A6%82%E4%BD%95%E5%85%8D%E5%AF%86/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="1、-vscode连接阿里云如何免密？"><a href="#1、-vscode连接阿里云如何免密？" class="headerlink" title="1、 vscode连接阿里云如何免密？"></a>1、 vscode连接阿里云如何免密？</h1><h2 id="windows端："><a href="#windows端：" class="headerlink" title="windows端："></a><code>windows</code>端：</h2><p>1）在<code>cmd</code>中输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>

<p>在<code>c:\Users\用户名\\.ssh</code>下会生成私钥和公钥。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308021257775.png" alt="image-20230802125702563"></p>
<p>2）复制<code>id_rsa.pub</code>中的内容</p>
<h2 id="linux端："><a href="#linux端：" class="headerlink" title="linux端："></a><code>linux</code>端：</h2><p>1）输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>生成<code>linux</code>端的密钥，进入<code>/root/.ssh/id_rsa</code>路径下。</p>
<p>2）创建一个文件，名字叫<code>authorized_keys</code></p>
<p>3）把复制的<code>windows</code>公钥粘贴到<code>authorized_keys</code>中，保存退出</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308012055885.png" alt="Snipaste_2023-08-01_20-46-53"></p>
<h1 id="2、Linux环境使用VSCode调试简单C-代码"><a href="#2、Linux环境使用VSCode调试简单C-代码" class="headerlink" title="2、Linux环境使用VSCode调试简单C++代码"></a>2、Linux环境使用VSCode调试简单C++代码</h1><p>参考教程：<a href="https://blog.csdn.net/hypc9709/article/details/129413482?ops_request_misc=&request_id=&biz_id=102&utm_term=vscode%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-129413482.142%5Ev96%5Epc_search_result_base7&spm=1018.2226.3001.4187">Linux环境使用VSCode调试简单C++代码</a></p>
<h2 id="1）终端命令行进行编译、调试"><a href="#1）终端命令行进行编译、调试" class="headerlink" title="1）终端命令行进行编译、调试"></a>1）终端命令行进行编译、调试</h2><h2 id="2）通过VSCode进行编译、调试"><a href="#2）通过VSCode进行编译、调试" class="headerlink" title="2）通过VSCode进行编译、调试"></a>2）通过VSCode进行编译、调试</h2><h3 id="（1）前置条件"><a href="#（1）前置条件" class="headerlink" title="（1）前置条件"></a>（1）前置条件</h3><p>插件<code>C/C++</code>已安装；<code>g++编译器</code>和<code>gdb调试器</code>已安装。</p>
<h3 id="（2）配置tasks-json"><a href="#（2）配置tasks-json" class="headerlink" title="（2）配置tasks.json"></a>（2）配置<code>tasks.json</code></h3><ul>
<li><p>在<code>VSCode</code>的主菜单中，选择<code>Terminal&gt;Configure Default Build Task</code></p>
</li>
<li><p>出现一个下拉菜单，显示<code>C++</code>编译器的各种预定义编译任务。选择<code>C/C++: g++ build active file</code>（如果配置了中文，会显示<code>C/C++: g++ 生成活动文件</code>）</p>
</li>
<li><p>选择后，<code>VSCode</code>会自动生成一个<code>.vscode</code>文件夹和<code>tasks.json</code>文件，如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312071610116.png" alt="image-20231207144919415"></p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++ 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/g++&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>tasks.json</code>的作用是告诉<code>VSCode</code>如何编译程序，因此从其中的<code>Command</code>和<code>args</code>可以看出，实际上是执行了以下命令：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/usr/bin/g++ -g $&#123;file&#125; -o $&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li><code>$&#123;file&#125;</code>：当前活动文件是<code>VSCode</code>当前查看的文件，如<code>Main.cpp</code>；</li>
<li><code>$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;</code>：用于获取当前文件的目录和不包含扩展名的文件名，如<code>Main</code>。</li>
</ul>
<h3 id="（3）执行编译"><a href="#（3）执行编译" class="headerlink" title="（3）执行编译"></a>（3）执行编译</h3><ul>
<li><p><strong>回到需要执行编译的文件</strong>（这一步很重要，否则<code>\$&#123;file&#125;</code>和<code>$&#123;fileDirname&#125;</code>这些变量都会错）；</p>
</li>
<li><p>快捷键<code>ctrl+shift+B</code>或从菜单中选择运行：<strong>Terminal -&gt; Run Build Task</strong>，即可执行<code>tasks.json</code>中指定的编译过程；</p>
<p>编译任务完成后，会出现终端提示，对于成功的g++编译，输出如下：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312071609602.png" alt="image-20231207150223290"></p>
<p>（这里我将<code>tasks.json</code>中的<code>&quot;$&#123;file&#125;&quot;</code>项更改为<code>&quot;$&#123;fileDirname&#125;/*.cpp&quot;</code></p>
<h3 id="（4）调试文件"><a href="#（4）调试文件" class="headerlink" title="（4）调试文件"></a>（4）调试文件</h3><p>对需要调试的文件设置断点，选择<code>Debug C/C++ file</code>进行调试。</p>
<h3 id="（5）个性化配置launch-json"><a href="#（5）个性化配置launch-json" class="headerlink" title="（5）个性化配置launch.json"></a>（5）个性化配置<code>launch.json</code></h3><blockquote>
<p>这里<code>launch.json</code>的作用就是告诉<code>VSCode</code>如何调用<code>gdb调试器</code>。</p>
</blockquote>
<p>如果想要在调试&#x2F;运行程序时添加参数，只需要把参数添加在<code>&quot;args&quot;</code>选项中即可。</p>
<h4 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h4><p>在<code>VSCode</code>中编译、调试一个简单的<code>.cpp</code>文件，所需要做的就是：</p>
<ol>
<li>在<code>tasks.json</code>中调用<code>g++</code>生成一个可执行二进制文件；</li>
<li>在<code>launch.json</code>中调用<code>gdb</code>对生成的可执行文件进行调试。</li>
</ol>
<h3 id="（7）复用C-配置"><a href="#（7）复用C-配置" class="headerlink" title="（7）复用C++配置"></a>（7）复用C++配置</h3><p>上面的过程已经完成了在<code>VSCode</code>中调试<code>Linux</code>环境下的<code>C++</code>代码的配置，但只适用于当前工作空间。</p>
<p>如果想要在其他的工程文件夹下复用这种配置，只需要把<code>tasks.json</code>和<code>launch.json</code>文件复制到新文件夹下的<code>.vscode</code>目录下，然后根据需要改变对应的源文件和可执行文件的名称即可。</p>
<h1 id="3、VSCode自动生成头文件的-ifndef-define-endif"><a href="#3、VSCode自动生成头文件的-ifndef-define-endif" class="headerlink" title="3、VSCode自动生成头文件的 #ifndef #define #endif"></a>3、VSCode自动生成头文件的 #ifndef #define #endif</h1><p>参考这篇博客：<a href="https://blog.csdn.net/p1279030826/article/details/123851420">VSCode自动生成头文件的 #ifndef #define #endif</a></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>进程终止</title>
    <url>/2024/07/16/2%20Linux%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2/</url>
    <content><![CDATA[<h2 id="1、什么是终止函数"><a href="#1、什么是终止函数" class="headerlink" title="1、什么是终止函数"></a>1、什么是终止函数</h2><span id="more"></span>

<p>内核中每个启动的进程都有一个<strong>标准的默认终止函数</strong>，在进程终止时执行，主要用来释放进程所占用的资源。根据 ISO C 规定，一个进程可以注册 32 个终止函数，<strong>这些函数由 exit() 自动调用</strong>。</p>
<p>登记的终止函数以<strong>栈</strong>的形式运行，先注册的后执行。如果自定义注册了进程终止函数，那么内核提供的默认终止函数<strong>将被覆盖</strong>。</p>
<h2 id="2、为什么需要终止函数"><a href="#2、为什么需要终止函数" class="headerlink" title="2、为什么需要终止函数"></a>2、为什么需要终止函数</h2><p>有时候需要在进程结束时进行一些清理工作，比如将某些重要的数据保存到文件中。如果不登记终止函数的话，实现起来较为困难。因为进程可能因为某个函数调用失败，该函数出错时又调用了 exit()，导致进程终止。而具体哪个函数会调用出错是不确定的。因此此时就可以通过登记注册终止函数，在进程终止时将数据进行保存。</p>
<h2 id="3、atexit-函数"><a href="#3、atexit-函数" class="headerlink" title="3、atexit() 函数"></a>3、atexit() 函数</h2><p>atexit() 是内核中注册一个进程终止时执行的函数。函数原型是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span>(*function)(<span class="type">void</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回0，失败返回-1，不会设置errno变量</span></span><br></pre></td></tr></table></figure>

<h2 id="4、atexit-实现进程不同方式退出"><a href="#4、atexit-实现进程不同方式退出" class="headerlink" title="4、atexit() 实现进程不同方式退出"></a>4、atexit() 实现进程不同方式退出</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义3个线程终止函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">term_func1</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;term func1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">term_func2</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;term func2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">term_func3</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;term func3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;use: %s file[exit | _exit | return]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    atexit(term_func1);</span><br><span class="line">    atexit(term_func2);</span><br><span class="line">    atexit(term_func3);</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;hello linux\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);   <span class="comment">// 标准C库函数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;_exit&quot;</span>))&#123;</span><br><span class="line">        _exit(<span class="number">0</span>);  <span class="comment">//系统调用</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;return&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;         <span class="comment">//正常返回</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;use: %s file[exit | _exit | return]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-以-return-方式退出"><a href="#4-1-以-return-方式退出" class="headerlink" title="4.1 以 return 方式退出"></a>4.1 以 return 方式退出</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@iisayhi:~/Documents/Test_for_Use<span class="comment"># ./test test.txt return</span></span><br><span class="line">term func3</span><br><span class="line">term func2</span><br><span class="line">term func1</span><br><span class="line">root@iisayhi:~/Documents/Test_for_Use<span class="comment"># cat test.txt </span></span><br><span class="line">hello linux</span><br><span class="line">root@iisayhi:~/Documents/Test_for_Use<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<ul>
<li>当前进程以 return 形式退出，<strong>终止函数是以栈的形式执行的，先注册的终止函数后执行</strong>；</li>
<li>通过 cat 命令查看 test.txt 文件的内容为 hello linux 。</li>
</ul>
<h3 id="4-2-以-exit-方式退出"><a href="#4-2-以-exit-方式退出" class="headerlink" title="4.2 以 exit 方式退出"></a>4.2 以 exit 方式退出</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@iisayhi:~/Documents/Test_for_Use<span class="comment"># ./test test.txt exit</span></span><br><span class="line">term func3</span><br><span class="line">term func2</span><br><span class="line">term func1</span><br><span class="line">root@iisayhi:~/Documents/Test_for_Use<span class="comment"># cat test.txt </span></span><br><span class="line">hello linux</span><br><span class="line">root@iisayhi:~/Documents/Test_for_Use<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p>同 return 方式。</p>
<h3 id="4-3-以-exit-方式退出"><a href="#4-3-以-exit-方式退出" class="headerlink" title="4.3 以 _exit 方式退出"></a>4.3 以 _exit 方式退出</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@iisayhi:~/Documents/Test_for_Use<span class="comment"># ./test test.txt _exit</span></span><br><span class="line">root@iisayhi:~/Documents/Test_for_Use<span class="comment"># cat test.txt </span></span><br><span class="line">root@iisayhi:~/Documents/Test_for_Use<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<ul>
<li>注册的终止函数均未执行；</li>
<li>test.txt 文件创建了，但未写入内容。</li>
</ul>
<h3 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h3><p>在程序中写入文件数据用的是标准 C 库函数，在使用 fprintf 函数写入数据时，实际上数据并不会写入文件，而是先写入 buf 缓冲区中，这种方式也叫<strong>全缓存</strong>，只有<strong>当缓冲区写满或者调用 fclose 函数时</strong>才会把数据写入文件中。</p>
<p>当程序终止时也会把数据写入文件，但是会有一些区别：</p>
<ul>
<li>如果使用 <code>return</code> 方式或 <code>exit</code> 方式让程序退出，会刷新 buf 中的数据到文件中；</li>
<li>以 <code>_exit</code> 方式退出时，不会刷新数据到文件中。</li>
</ul>
<p><code>_exit</code>是系统调用，<strong>进程终止前不会调用终止函数，也不会刷新数据到文件中，而是直接进入内核</strong>。而 <code>exit</code>  和 <code>return</code> 是标准库函数，<strong>进程终止前会调用终止函数，也会刷新数据到文件中</strong>。</p>
<p>因此可以把进程终止方式简单总结为：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407161543866.png" alt="进程终止方式" style="zoom: 67%;" />

<p>进程的启动和退出过程如图所示：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407161544936.png" alt="进程的启动和退出过程"></p>
<p>进程的启动和退出过程大概如上图所示：</p>
<p>  1．进程在运行时，首先内核会先启动一个例程，这个例程的作用是加载程序运行的参数，环境变量，在内核注册终止函数等这些工作，然后启动例程会调用 <code>main</code> 函数。</p>
<p>  2．<code>main</code> 函数调用了 <code>exit</code> 函数使进程终止退出，在进程终止之前，如果注册了终止函数，那么 <code>exit</code> 函数会先去依次调用进程终止函数，注册了几个就调用几个，每调用完一个终止函数并返回，<strong>调用顺序是以栈的形式来调用</strong>，然后调用 <code>flush</code> 刷新 <code>I/O</code> 缓冲区的数据再返回，最后调用了系统调用<code>_exit</code>，然后进程终止退出。</p>
<p>  3．值得注意的是 <code>main</code> 函数也可以通过调用系统调用 <code>_exit</code>直接进入内核使进程终止并退出，<strong>通过调用系统调用的方式使进程终止的话，并不会调用注册的进程终止函数</strong>。也可以通过 main 函数调用用户函数，然后用户函数调用 <code>exit</code>，然后依次调用进程终止函数，再调用标准 <code>I/O</code> 函数刷新缓冲区，最后调用系统调用 <code>_exit</code> 使进程终止退出。</p>
<p>  4．当然，用户函数也是可以直接通过系统调用 <code>_exit()</code> 进入内核使进程终止退出的。</p>
]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基础</title>
    <url>/2024/04/17/2%20Linux%E7%BC%96%E7%A8%8B/Linux%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="1、GCC安装"><a href="#1、GCC安装" class="headerlink" title="1、GCC安装"></a>1、GCC安装</h1><h2 id="（1）GCC相关知识点"><a href="#（1）GCC相关知识点" class="headerlink" title="（1）GCC相关知识点"></a>（1）GCC相关知识点</h2><p>GCC（GNU Compiler Collection， GNU编译器套件）是由GNU开发的编程语言译器。</p>
<p>gcc和g++都是GNU（组织）的一个编译器</p>
<ul>
<li>误区一：gcc只能编译C程序，g++只能编译C++代码：<ul>
<li>后缀为.c时，gcc认为其是C程序，g++认为其是C++程序；</li>
<li>后缀为.cpp时，gcc和g++均认为其是C++程序。</li>
</ul>
</li>
<li>误区二：编译只能用gcc，链接只能用g++：<ul>
<li>严格来说不算错误，但混淆了概念，应该说：编译可以用gcc&#x2F;g++，而链接可以用g++或者gcc -lstdc++;</li>
<li>gcc命令不能自动和C++程序使用的库链接，所以通常使用g++来完成链接。但在编译阶段，g++会自动调用gcc，二者等价。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171012036.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171012580.png" alt="2"></p>
<h2 id="（2）GCC工作流程"><a href="#（2）GCC工作流程" class="headerlink" title="（2）GCC工作流程"></a>（2）GCC工作流程</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013866.png" alt="3"></p>
<ul>
<li><p>预处理：对头文件展开\删除代码中的注释\宏替换</p>
</li>
<li><p><strong>程序编译成可执行程序的过程：</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013529.png" alt="4"></p>
</li>
</ul>
<h1 id="2、静态库和动态库"><a href="#2、静态库和动态库" class="headerlink" title="2、静态库和动态库"></a>2、静态库和动态库</h1><h2 id="（1）静态库"><a href="#（1）静态库" class="headerlink" title="（1）静态库"></a>（1）静态库</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013337.png" alt="5"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013840.png" alt="6"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@iisayhi:~/lesson/library<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">├── add.c</span><br><span class="line">├── div.c</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br><span class="line">root@iisayhi:~/lesson/library<span class="comment"># gcc main.c -o app -I ./include/ -l calc -L ./lib/</span></span><br><span class="line">root@iisayhi:~/lesson/library<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── app</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">		├── add.c</span><br><span class="line">		├── div.c</span><br><span class="line">		├── mult.c</span><br><span class="line">		└── sub.c</span><br></pre></td></tr></table></figure>

<h2 id="（2）动态库"><a href="#（2）动态库" class="headerlink" title="（2）动态库"></a>（2）动态库</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013622.png" alt="7"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013961.png" alt="8"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013076.png" alt="9"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/calc# **gcc -c -fpic add.c mult.c sub.c div.c** </span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# ls</span><br><span class="line">add.c  add.o  div.c  div.o  head.h  main.c  mult.c  mult.o  sub.c  sub.o</span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# **gcc -shared *.o -o libcalc.so**</span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# ll</span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x 2 root root  4096 Apr  6 22:49 ./</span><br><span class="line">drwxr-xr-x 4 root root  4096 Apr  6 22:47 ../</span><br><span class="line">-rw-r--r-- 1 root root    80 Apr  6 22:47 add.c</span><br><span class="line">-rw-r--r-- 1 root root  1376 Apr  6 22:48 add.o</span><br><span class="line">-rw-r--r-- 1 root root    94 Apr  6 22:47 div.c</span><br><span class="line">-rw-r--r-- 1 root root  1384 Apr  6 22:48 div.o</span><br><span class="line">-rw-r--r-- 1 root root   189 Apr  6 22:47 head.h</span><br><span class="line">-rwxr-xr-x 1 root root 15824 Apr  6 22:49 libcalc.so*</span><br><span class="line">-rw-r--r-- 1 root root   306 Apr  6 22:47 main.c</span><br><span class="line">-rw-r--r-- 1 root root    85 Apr  6 22:47 mult.c</span><br><span class="line">-rw-r--r-- 1 root root  1384 Apr  6 22:48 mult.o</span><br><span class="line">-rw-r--r-- 1 root root    85 Apr  6 22:47 sub.c</span><br><span class="line">-rw-r--r-- 1 root root  1376 Apr  6 22:48 sub.o</span><br></pre></td></tr></table></figure>

<ul>
<li>运行main可执行文件报错：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># gcc main.c -o main -I include/ -L lib/ -l calc</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ls</span></span><br><span class="line">include  lib  main  main.c  src</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">**./main: error <span class="keyword">while</span> loading shared libraries: [libcalc.so](&lt;http://libcalc.so/&gt;): cannot open shared object file: No such file or directory**</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffda29fd000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; not found</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbe8fa25000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007fbe8fc31000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>原因即是由于动态库是在程序启动后才被加载到内存中，而我们自己写的动态库libcalc.so并没有给出对应的路径去查找它，所以会报错。</p>
<p>解决方法：</p>
<blockquote>
<p>对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的 <strong>DT_RPATH段</strong> ——&gt; <strong>环境变量LD_LIBRARY_PATH</strong> ——&gt; <strong>&#x2F;etc&#x2F;ld.so.cache</strong>文件列表 ——&gt; <strong>&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib</strong>目录找到库文件后将其载入内存</p>
</blockquote>
<p><strong>1）DT_RPATH段 无法修改，系统本身固定值</strong></p>
<p><strong>2）环境变量LD_LIBRARY_PATH</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># echo $LD_LIBRARY_PATH </span></span><br><span class="line">:/root/lesson/lesson01/library/lib</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffff57e5000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; /root/lesson/lesson01/library/lib/libcalc.so (0x00007f06515af000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f06513aa000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f06515bb000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">a = 20, b = 12</span><br><span class="line">a + b = 32</span><br><span class="line">a - b = 8</span><br><span class="line">a * b = 240</span><br><span class="line">a / b = 1.666667</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>直接在终端中配置，当终端被关闭后该环境变量就会消失了，属于临时性配置。</p>
<p>永久性配置：</p>
<ul>
<li><p>用户级别</p>
<ul>
<li><p>根目录下，<code>vim .bashrc</code></p>
</li>
<li><p>在最后一行加上要添加的路径</p>
<p><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</code></p>
</li>
<li><p><code>source ~/.bashrc</code></p>
</li>
</ul>
</li>
<li><p>系统级别</p>
<ul>
<li><p><code>sudo vim /etc/profile</code></p>
</li>
<li><p>在最后一行加上要添加的路径</p>
<p><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</code></p>
</li>
<li><p><code>source /etc/profile</code></p>
</li>
</ul>
</li>
</ul>
<p><strong>3）&#x2F;etc&#x2F;ld.so.cache文件列表</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@iisayhi:~/lesson<span class="comment"># ll /etc/ld.so.cache</span></span><br><span class="line">-rw-r--r-- 1 root root 74025 Jan 12 21:15 /etc/ld.so.cache</span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># **sudo vim /etc/ld.so.conf**</span></span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># **sudo ldconfig**</span></span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># cd lesson01/library/</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffd633f6000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; /root/lesson/lesson01/library/lib/libcalc.so (0x00007f7b8a4e1000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7b8a2ef000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f7b8a500000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">a = 20, b = 12</span><br><span class="line">a + b = 32</span><br><span class="line">a - b = 8</span><br><span class="line">a * b = 240</span><br><span class="line">a / b = 1.666667</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p><code>/etc/ld.so.cache</code>是一个二进制文件，无法直接用vim进行修改；</p>
<p>因此要借助<code>/etc/ld.so.conf</code>的帮助：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014770.png" alt="10"></p>
<p><strong>4）&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib目录</strong></p>
<p>不推荐使用，因为在上述目录下已经包含很多系统自带的库文件，因此可能存在重名导致被替换的问题存在。</p>
<h2 id="（3）静态库和动态库的对比"><a href="#（3）静态库和动态库的对比" class="headerlink" title="（3）静态库和动态库的对比"></a>（3）静态库和动态库的对比</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014481.png" alt="11"></p>
<ul>
<li>消耗系统资源、浪费内存：<ul>
<li>每个程序在运行时都会将静态库复制一份到内存中，多个程序同时运行时浪费内存；</li>
</ul>
</li>
<li>更新、部署、发布麻烦：<ul>
<li>每次更新、部署或发布时都需要重新编译</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014264.png" alt="12"></p>
<h1 id="3、Makefile"><a href="#3、Makefile" class="headerlink" title="3、Makefile"></a>3、Makefile</h1><ul>
<li>定义<ul>
<li>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 <code>Makefile 文件就像一个 Shell 脚本一样，也可以执行操作系统的命令</code>。</li>
<li><strong>Makefile 带来的好处就是“自动化编译”</strong> ，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如 Delphi 的 <code>make</code>，Visual C++ 的 <code>nmake</code>，Linux 下 GNU 的 <code>make</code>。</li>
</ul>
</li>
<li>命名规则</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014308.png" alt="13"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014605.png" alt="14"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014917.png" alt="15"></p>
<ul>
<li>工作原理</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015389.png" alt="16"></p>
<ul>
<li>变量</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015553.png" alt="17"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171018439.png" alt="Untitled"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019513.png" alt="Untitled"></p>
<p><strong>对原始写法进行简写：</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015837.png" alt="20"></p>
<p>改进1：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171018316.png" alt="Untitled"></p>
<p>改进2：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015549.png" alt="22"></p>
<p>改进3：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015818.png" alt="23"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.PHONY:clean  # 定义clean为伪目标</span><br></pre></td></tr></table></figure>

<p>改进4：<code>Makefile</code>中写了<code>clean</code>之后，在命令行要用<code>make clean</code>来调用</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019153.png" alt="24"></p>
<h1 id="4、GDB调试"><a href="#4、GDB调试" class="headerlink" title="4、GDB调试"></a>4、GDB调试</h1><!--more-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">man gdb</span><br></pre></td></tr></table></figure>

<p>要进入gdb调试模式需要加上-g参数，<code>gcc -g filename</code></p>
<blockquote>
<p>gdb基本命令</p>
</blockquote>
<p><code>list</code> 查看当前源代码</p>
<p><code>run</code> 运行程序</p>
<p><code>break(b)</code> 打断点，有两种打断点方式：</p>
<ol>
<li><code>break function</code></li>
<li><code>break 可执行文件:行号</code></li>
</ol>
<p><code>info b</code> 查看已经打的断点</p>
<p><code>next(n)</code> 执行下一步</p>
<p><code>step(s)</code> 执行函数内部</p>
<p><code>print(p)</code> 打印当前变量内容</p>
<blockquote>
<p>gdb小技巧</p>
</blockquote>
<ol>
<li>gdb中可以通过<code>shell</code>调取终端命令，如：</li>
</ol>
<ul>
<li>shell ls</li>
<li>shell cat filename</li>
</ul>
<ol>
<li>设置日志功能，<code>set logging on</code></li>
<li>断点的相关设置：</li>
</ol>
<ul>
<li>breakpoints</li>
<li>watchpoints：观察变量是否变化</li>
<li>catchpoints</li>
</ul>
<blockquote>
<p>调试core文件</p>
</blockquote>
<p>系统不会默认生成core文件，需要进行手动设置</p>
<p>man ulimit</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404170953727.png" alt="1"></p>
<p>注意其中一行：<code>open file 65535</code>，能打开的最大文件数是65535</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulimit -c unlimited</span><br></pre></td></tr></table></figure>

<p>这样设置之后，运行可执行文件后出现(core dump)即为生成了对应的core文件。若仍为生成core文件，调用命令：<code>echo &quot;core&quot; &gt; /proc/sys/kernel/core_pattern</code></p>
<p>此时的gdb调试命令为：<code>gdb 可执行文件名（二进制文件） 可执行文件生成的core文件名</code></p>
<blockquote>
<p>调试正在运行的文件</p>
</blockquote>
<p>后台运行一个程序并返回其pid号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./a.out &amp;</span><br><span class="line">[1] 96929</span><br></pre></td></tr></table></figure>

<p>gdb调试该后台程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb -p 96929</span><br><span class="line">root@iisayhi:~/Documents/useless# vim test_for.c </span><br><span class="line">root@iisayhi:~/Documents/useless# **gcc test_for.c -g**</span><br><span class="line">root@iisayhi:~/Documents/useless# **./a.out &amp;**</span><br><span class="line">**[1] 96929**</span><br><span class="line">root@iisayhi:~/Documents/useless# **gdb -p 96929**</span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br><span class="line">Attaching to process 96929</span><br><span class="line">Reading symbols from /root/Documents/useless/a.out...</span><br><span class="line">Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...</span><br><span class="line">Reading symbols from /usr/lib/debug/.build-id/ee/be5d5f4b608b8a53ec446b63981bba373ca0ca.debug...</span><br><span class="line">Reading symbols from /lib64/ld-linux-x86-64.so.2...</span><br><span class="line">Reading symbols from /usr/lib/debug/.build-id/7a/e2aaae1a0e5b262df913ee0885582d2e327982.debug...</span><br><span class="line">test1 () at test_for.c:14</span><br><span class="line">14	&#125;</span><br><span class="line">(gdb) n</span><br><span class="line">main () at test_for.c:18</span><br><span class="line">18			test();</span><br><span class="line">(gdb) n</span><br><span class="line">19			test1();</span><br><span class="line">(gdb) s</span><br><span class="line">test1 () at test_for.c:11</span><br><span class="line">11	void test1() &#123;</span><br><span class="line">(gdb) n</span><br><span class="line">12		int i = 0;</span><br><span class="line">(gdb) n</span><br><span class="line">13		i++;</span><br><span class="line">(gdb) p i</span><br><span class="line">$1 = 0</span><br><span class="line">(gdb) n</span><br><span class="line">14	&#125;</span><br><span class="line">(gdb) p i</span><br><span class="line">$2 = 1</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// test test1</span><br><span class="line">// i i++</span><br><span class="line">// call test test1</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test1() &#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	for(;;) &#123;</span><br><span class="line">		test();</span><br><span class="line">		test1();</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5、文件I-O"><a href="#5、文件I-O" class="headerlink" title="5、文件I&#x2F;O"></a>5、文件I&#x2F;O</h1><h2 id="（1）标准C库IO函数"><a href="#（1）标准C库IO函数" class="headerlink" title="（1）标准C库IO函数"></a>（1）标准C库IO函数</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019600.png" alt="25"></p>
<p>标准C库IO函数可以跨平台（win\linux等）。</p>
<p><strong>在不同平台上调用不同的系统API，从而实现跨平台。</strong></p>
<p>写数据时首先有一个缓冲区，内容首先写到缓冲区（内存，默认<em><strong>8k</strong></em>）中，当<strong>缓冲区内容满后&#x2F;强行刷新缓冲区&#x2F;正常关闭文件后</strong>，再将当前缓冲区的内容传递到磁盘中。</p>
<ul>
<li>标准C库IO和Linux系统IO的关系：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019149.png" alt="26"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020236.png" alt="27"></p>
<h2 id="（2）虚拟地址空间"><a href="#（2）虚拟地址空间" class="headerlink" title="（2）虚拟地址空间"></a>（2）虚拟地址空间</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020344.png" alt="28"></p>
<p>虚拟地址空间会通过MMU映射到真实物理空间上。</p>
<p>NULL\NULL pointer — 受保护的地址</p>
<p>new\malloc              — 堆空间</p>
<p>局部变量                  — 栈空间</p>
<h2 id="（3）文件描述符"><a href="#（3）文件描述符" class="headerlink" title="（3）文件描述符"></a>（3）文件描述符</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020768.png" alt="29"></p>
<ul>
<li><p>程序和进程间的区别</p>
<ul>
<li>程序（test.c)\可执行程序(test) — 不占用内存空间，只占用磁盘空间，是伪文件；</li>
<li>进程 — 运行一个程序时，操作系统创建一个进程为其分配资源，会占用内存空间。</li>
</ul>
</li>
<li><pre><code>PCB进程控制块
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">是一个复杂的结构体，位于Linux kernel的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
内存管理
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  。中封装了各类信息，如文件描述符表</span><br><span class="line"></span><br><span class="line">  - 文件描述符表，是一个数组</span><br><span class="line"></span><br><span class="line">    ，存储多个文件描述符 — 使得一个进程可以打开多个文件（产生多个文件描述符）</span><br><span class="line"></span><br><span class="line">    - 默认的大小是**1024（默认能打开的文件数）；**</span><br><span class="line">    - 数组前3位被默认占用，为**标准输入、标准输出、标准错误，且默认是打开状态**（此三个文件描述符和**当前终端**绑定，联系linux系统一切皆文件的思想来理解）；</span><br><span class="line">    - 占用文件描述符时内核会自动寻找最小的没有被占用的文件描述符来使用。</span><br><span class="line"></span><br><span class="line">## （4）Linux系统IO函数</span><br><span class="line"></span><br><span class="line">![30](https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020793.png)</span><br><span class="line"></span><br><span class="line">1）open函数</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">// 打开一个已经存在的文件</span><br><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">    参数：</span><br><span class="line">        - pathname  要打开的文件路径</span><br><span class="line">        - flags     对文件的操作权限设置还有其他的设置</span><br><span class="line">                    O_RDONLY, O_WRONLY, or O_RDWR 这三个操作互斥</span><br><span class="line">    返回值：</span><br><span class="line">        返回一个新的文件描述符；若失败则返回-1</span><br><span class="line"></span><br><span class="line">errno：属于Linux系统函数库里面的一个全局变量，记录的是最近的错误号</span><br><span class="line">    #include &lt;stdio.h&gt;</span><br><span class="line">    void perror(const char *s);</span><br><span class="line">        作用：打印errno对应的错误描述</span><br><span class="line">        参数：</span><br><span class="line">            - s     用户描述</span><br><span class="line">// 创建一个新的文件</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line">    参数：</span><br><span class="line">        - pathname  要打开的文件路径</span><br><span class="line"></span><br><span class="line">        - flags     对文件的操作权限设置还有其他的设置</span><br><span class="line">                    - 必选项：O_RDONLY, O_WRONLY, O_RDWR 这三个操作互斥</span><br><span class="line">                    - 可选项：O_CREAT 文件不存在，创建新文件</span><br><span class="line">                    flags参数是一个int类型的数据，占4个字节，32位</span><br><span class="line">                    flags32位，每一位就是一个标志位</span><br><span class="line"></span><br><span class="line">        - mode      八进制数，表述用户对创建出的新的文件的操作权限</span><br><span class="line">                    - 0777</span><br><span class="line">                        0：     0开头，八进制数</span><br><span class="line">                        777：   并非就是777，涉及到掩码，最终的权限是 mode &amp; ~umask</span><br><span class="line">                                    umask = 0022  ~umask = 0755</span><br><span class="line">                                        0777 -&gt; 111111111</span><br><span class="line">                                    &amp;   0755 -&gt; 111101101</span><br><span class="line">                                        0755 -&gt; 111101101</span><br><span class="line">                    umask的作用就是抹去某些权限</span><br><span class="line"></span><br><span class="line">                                </span><br><span class="line">    返回值：</span><br><span class="line">    返回一个新的文件描述符；若失败则返回-1</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code>flags
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">和</span><br><span class="line"></span><br></pre></td></tr></table></figure>
mode_t
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  的区别：</span><br><span class="line"></span><br><span class="line">  - `flags`是程序在运行时，能以什么权限对文件进行操作；</span><br><span class="line">  - `mode_t`是指这个文件本身的权限。</span><br><span class="line"></span><br><span class="line">- 关于rwx权限：</span><br><span class="line"></span><br><span class="line">  - r   - 读，对文件而言，具有读取文件内容的权限；对目录来说，具有浏览该目录信息的权限</span><br><span class="line"></span><br><span class="line">  - w  - 写，对文件而言，具有修改文件内容的权限；对目录来说具有删除移动目录内文件的权限</span><br><span class="line"></span><br><span class="line">  - x   - 可执行，对文件而言，具有执行文件的权限；对目录来说，具有进入目录的权限</span><br><span class="line"></span><br><span class="line">    | 第一位  | 用户   | 组用户 | 其他用户 |</span><br><span class="line">    | ------- | ------ | ------ | -------- |</span><br><span class="line">    | -  文件 | d 目录 | rwx    | r-x      |</span><br><span class="line"></span><br><span class="line">2）read &amp; write函数</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">        参数：</span><br><span class="line">            - fd        文件描述符，open得到</span><br><span class="line">            - *buf      缓冲区，读取数据存放的地方，数组的地址</span><br><span class="line">            - count     指定的数组的大小</span><br><span class="line">        返回值</span><br><span class="line">            - 成功：</span><br><span class="line">                &gt;0      返回实际读取到的字节数</span><br><span class="line">                =0      文件已经读取完毕</span><br><span class="line">            - 失败</span><br><span class="line">                -1      并设置errno</span><br><span class="line"></span><br><span class="line">ssize_t  write(int  fd,  const void *buf, size_t count);</span><br><span class="line">        参数：</span><br><span class="line">		        - fd        文件描述符，open得到</span><br><span class="line">		        - *buf      要往磁盘写入的数据，数据</span><br><span class="line">		        - count     实际写入数据大小</span><br><span class="line">        返回值</span><br><span class="line">            - 成功：</span><br><span class="line">                &gt;0      返回实际读取到的字节数</span><br><span class="line">                =0      无任何数据写到文件中</span><br><span class="line">            - 失败</span><br><span class="line">                -1      并设置errno</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>对于write函数来说，如果count的大小（实际写入数据的大小）大于缓冲区实际大小时，那么会把缓冲区后面的内存中的数据写进去，只不过这些数据我们是不确定的，是野内存，操作野内存有可能会产生问题，所以一般不会这么去做。缓冲区中有多少数据，我们就写多少数据即可。</p>
</li>
</ul>
<p>3）lseek函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">标准C库：</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"></span><br><span class="line">Linux系统函数：</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line">    <span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line">        对文件指针进行操作</span><br><span class="line">        参数：</span><br><span class="line">            - fd        文件描述符</span><br><span class="line">            - offset    偏移量  </span><br><span class="line">            - whence    </span><br><span class="line">                SEEK_SET</span><br><span class="line">                    设置文件指针的偏移量</span><br><span class="line"></span><br><span class="line">                SEEK_CUR</span><br><span class="line">                    设置偏移量：当前位置 + 第二个参数offset的值</span><br><span class="line"></span><br><span class="line">                SEEK_END</span><br><span class="line">                    设置偏移量：文件大小 + 第二个参数offset的值</span><br><span class="line">        返回值：返回文件指针的位置</span><br><span class="line">        作用：</span><br><span class="line">            <span class="number">1</span>、移动文件指针到头文件</span><br><span class="line">                lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">            <span class="number">2</span>、获取当前文件指针的位置</span><br><span class="line">                lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line">            <span class="number">3</span>、获取文件长度</span><br><span class="line">                lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">            <span class="number">4</span>、拓展文件长度 ex. <span class="number">10b</span> =&gt; <span class="number">110b</span></span><br><span class="line">                lseek(fd, <span class="number">100</span>, SEEK_END);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>利用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lseek</span><br></pre></td></tr></table></figure>

<p>函数拓展文件长度时需要写入一次数据才能起作用：</p>
<ul>
<li>拓展时，<code>lseek</code>只是逻辑上移动文件指针的位置，并没有为文件分配存储空间，为了让这些空间实际得到分配，可以使用<code>write</code>在最后补充一个字符，这样拓展的存储空间应该就分配了。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓展文件长度</span></span><br><span class="line">    <span class="type">int</span> ret = lseek(fd, <span class="number">100</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入空数据，被写入到第112b的位置上</span></span><br><span class="line">    <span class="comment">// 不执行这一步之前一般ll是看不到hello.txt的文件大小变化的</span></span><br><span class="line">    <span class="comment">// hello.txt : 11b ==&gt; 112b</span></span><br><span class="line">    write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br></pre></td></tr></table></figure>

<p>4）stat\lstat函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line">    作用：获取一个文件相关的一些信息</span><br><span class="line">    参数:</span><br><span class="line">        - pathname：    操作的文件的路径</span><br><span class="line">        - statbuf：     结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="line">    返回值：</span><br><span class="line">        成功：返回<span class="number">0</span></span><br><span class="line">        失败：返回<span class="number">-1</span> 设置errno</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line">    参数:</span><br><span class="line">        - pathname：    操作的文件的路径</span><br><span class="line">        - statbuf：     结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="line">    返回值：</span><br><span class="line">        成功：返回<span class="number">0</span></span><br><span class="line">        失败：返回<span class="number">-1</span> 设置errno</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020543.png" alt="31"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020502.png" alt="32"></p>
<p>5）文件属性操作函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>;</span><br><span class="line">    作用：判断某个文件是否有某个权限，或者判断文件是否存在</span><br><span class="line">    参数：</span><br><span class="line">        - pathname: 判断的文件路径</span><br><span class="line">        - mode:</span><br><span class="line">            R_OK: 判断是否有读权限</span><br><span class="line">            W_OK: 判断是否有写权限</span><br><span class="line">            X_OK: 判断是否有执行权限</span><br><span class="line">            F_OK: 判断文件是否存在</span><br><span class="line">    返回值：成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">    修改文件的权限</span><br><span class="line">    参数：</span><br><span class="line">        - pathname: 需要修改的文件的路径</span><br><span class="line">        - mode:需要修改的权限值，八进制的数</span><br><span class="line">    返回值：成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line">    作用：缩减或者扩展文件的尺寸至指定的大小</span><br><span class="line">    参数：</span><br><span class="line">        - path: 需要修改的文件的路径</span><br><span class="line">        - length: 需要最终文件变成的大小</span><br><span class="line">    返回值：</span><br><span class="line">        成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前用户id和组id：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vim /etc/passwd <span class="comment">// 用户</span></span><br><span class="line">vim /etc/group   <span class="comment">// 组</span></span><br></pre></td></tr></table></figure>

<p>6）目录操作函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">    作用：创建一个目录</span><br><span class="line">    参数：</span><br><span class="line">        pathname: 创建的目录的路径</span><br><span class="line">        mode: 权限，八进制的数</span><br><span class="line">    返回值：</span><br><span class="line">        成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"><span class="type">int</span> ret = mkdir(<span class="string">&quot;aaa&quot;</span>, <span class="number">0777</span>);</span><br><span class="line"><span class="comment">// 最终的权限结果是 mode &amp; ~umask &amp; 0777</span></span><br><span class="line"><span class="comment">// 给的是0777 ==&gt; 最终得到 drwxr-xr-x</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line">    作用：修改进程的工作目录</span><br><span class="line">        比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder</span><br><span class="line">    参数：</span><br><span class="line">        path : 需要修改的工作目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br><span class="line">    作用：获取当前工作目录</span><br><span class="line">    参数：</span><br><span class="line">        - buf : 存储的路径，指向的是一个数组（传出参数）</span><br><span class="line">        - size: 数组的大小</span><br><span class="line">    返回值：</span><br><span class="line">        返回的指向的一块内存，这个数据就是第一个参数</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure>

<p>7）目录遍历函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开一个目录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - name: 需要打开的目录的名称</span><br><span class="line">    返回值：</span><br><span class="line">        DIR * 类型，理解为目录流</span><br><span class="line">        错误返回<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取目录中的数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line">    - 参数：dirp是opendir返回的结果</span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>，代表读取到的文件的信息</span></span><br><span class="line"><span class="class">        读取到了末尾或者失败了，返回<span class="title">NULL</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 关闭目录</span></span><br><span class="line"><span class="class">#<span class="title">include</span> &lt;</span>sys/types.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171021405.png" alt="33"></p>
<p>8）dup\dup2函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line">	  作用：复制一个新的文件描述符</span><br><span class="line">	  fd=<span class="number">3</span>, <span class="type">int</span> fd1 = dup(fd),</span><br><span class="line">	  fd指向的是a.txt, fd1也是指向a.txt</span><br><span class="line">		从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> dup2(<span class="type">int</span> oldfd, <span class="type">int</span> newfd);</span><br><span class="line">    作用：重定向文件描述符</span><br><span class="line">    oldfd 指向 a.txt, newfd 指向 b.txt</span><br><span class="line">    调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt</span><br><span class="line">    oldfd 必须是一个有效的文件描述符</span><br><span class="line">    oldfd和newfd值相同，相当于什么都没有做</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd1 = open(<span class="string">&quot;2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line"><span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d\\n&quot;</span>, fd, fd1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做了dup2之后 fd1就和2.txt没有关系了  </span></span><br><span class="line"><span class="comment">// 返回值fd2其实没必要再做任何操作了</span></span><br><span class="line"><span class="type">int</span> fd2 = dup2(fd, fd1);</span><br><span class="line"><span class="keyword">if</span>(fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样重定向之后2.txt就没有任何文件描述符了</span></span><br><span class="line"><span class="comment">// 如果还需要访问2.txt，则需要重新open一下，赋值一个新的文件描述符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过fd1去写数据，实际操作的是1.txt，而不是2.txt</span></span><br><span class="line"><span class="type">char</span> * str = <span class="string">&quot;hello, dup2&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9）fcntl函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span>;</span><br><span class="line">参数：</span><br><span class="line">    fd : 表示需要操作的文件描述符</span><br><span class="line">    cmd: 表示对文件描述符进行如何操作</span><br><span class="line">        - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）</span><br><span class="line">            <span class="type">int</span> ret = fcntl(fd, F_DUPFD);</span><br><span class="line"></span><br><span class="line">        - F_GETFL : 获取指定的文件描述符文件状态flag</span><br><span class="line">          获取的flag和我们通过open函数传递的flag是一个东西。</span><br><span class="line"></span><br><span class="line">        - F_SETFL : 设置文件描述符文件状态flag</span><br><span class="line">          必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改</span><br><span class="line">          可选性：O_APPEND, O_NONBLOCK</span><br><span class="line">            O_APPEND 表示追加数据</span><br><span class="line">            O_NONBLOCK 设置成非阻塞</span><br><span class="line">    </span><br><span class="line">    阻塞和非阻塞：描述的是函数调用的行为。</span><br></pre></td></tr></table></figure>

<h1 id="6、进程"><a href="#6、进程" class="headerlink" title="6、进程"></a>6、进程</h1><h2 id="（1）进程概述"><a href="#（1）进程概述" class="headerlink" title="（1）进程概述"></a>（1）进程概述</h2><ul>
<li>进程要占用内存和CPU资源，而程序不占用</li>
<li>从内核角度看：进程 &#x3D; 用户内存空间 + 内核数据结构</li>
<li><code>时间片(timeslice)</code>是操作系统分配给每个正在运行的进程微观上的一段CPU时间。由于timeslice的存在，让进程“看起来像”是同时运行的。<strong>Linux一般为5ms-800ms</strong></li>
<li>并行和并发<ul>
<li><code>并行(parallel)</code>：指在同一时刻，有多条指令在多个处理器上同时执行。</li>
<li><code>并发(concurrency)</code>：指在同一时刻只能有一条指令执行，但多个进程指令被快速的 轮换执行，本质上是把时间分成若干段，使多个进程快速交替的执行。</li>
</ul>
</li>
<li>内核为每个进程分配一个PCB(Processing Control Block)进程控制块</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171022599.png" alt="34"></p>
<h2 id="（2）进程状态转换"><a href="#（2）进程状态转换" class="headerlink" title="（2）进程状态转换"></a>（2）进程状态转换</h2><p>1）进程状态</p>
<ul>
<li><p>三态模型</p>
<ul>
<li>就绪态：进程具备运行条件，已分配到除CPU以外的所有必要资源；处于就绪态的多个进程排成就绪队列</li>
<li>运行态：进程占有处理器正在运行</li>
<li>阻塞态：进程不具备运行条件，又称wait或sleep态，需要与用户进行交互时也将阻塞</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171024144.png" alt="35"></p>
</li>
<li><p>五态模型</p>
<ul>
<li>新建态：进程刚被创建，尚未进入就绪队列</li>
<li>就绪态</li>
<li>运行态</li>
<li>阻塞态</li>
<li>终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统以及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171024552.png" alt="36"></p>
</li>
</ul>
<p>2）进程相关命令</p>
<ul>
<li>查看进程 <code>ps aux / ajx</code> a：显示终端上的所有进程，包括其他用户的进程 u：显示进程的详细信息 x：显示没有控制终端的进程 j：列出与作业控制相关的信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@iisayhi:~/lesson<span class="meta"># ps aux</span></span><br><span class="line">USER  PID  %CPU  %MEM  VSZ  RSS  TTY  STAT  START  TIME  COMMAND</span><br><span class="line"></span><br><span class="line">root@iisayhi:~/lesson<span class="meta"># ps ajx</span></span><br><span class="line">PPID  PID  PGID  SID  TTY  TPGID  STAT  UID  TIME  COMMAND</span><br><span class="line">PPID - 父进程ID  </span><br><span class="line">PID  - 进程ID  </span><br><span class="line">PGID - 进程组的ID</span><br><span class="line">SID  - 会话的ID</span><br><span class="line">TTY  - 终端  </span><br></pre></td></tr></table></figure>

<ul>
<li>实时显示进程动态 <code>top</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171024495.png" alt="37"></p>
<ul>
<li>杀死进程<ul>
<li><code>kill [-signal] pid</code></li>
<li><code>kill –l</code> 列出所有信号</li>
<li><code>kill –SIGKILL</code> 进程ID</li>
<li><code>kill -9</code> 进程ID</li>
<li><code>killall name</code> 根据进程名杀死进程</li>
</ul>
</li>
</ul>
<p>3）进程相关</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025257.png" alt="38"></p>
<ul>
<li>父子进程虚拟地址空间情况</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid : %d\\n&quot;</span>, pid);</span><br><span class="line">        <span class="comment">// 若大于0，当前为父进程，并返回子进程的进程号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent procress, pid : %d, ppid : %d\\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 若等于0，当前为子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child procress, pid : %d, ppid : %d\\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d, pid : %d\\n&quot;</span>, i, getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。</span></span><br><span class="line"><span class="comment">写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</span></span><br><span class="line"><span class="comment">内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</span></span><br><span class="line"><span class="comment">只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</span></span><br><span class="line"><span class="comment">也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</span></span><br><span class="line"><span class="comment">注意：fork之后父子进程共享文件，</span></span><br><span class="line"><span class="comment">fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">root@iisayhi:~/lesson/lesson07<span class="meta"># gcc fork.c -o fork</span></span><br><span class="line">root@iisayhi:~/lesson/lesson07# ./fork</span><br><span class="line">pid : <span class="number">265418</span></span><br><span class="line">I am parent procress, pid : <span class="number">265417</span>, ppid : <span class="number">264856</span></span><br><span class="line">i : <span class="number">0</span>, pid : <span class="number">265417</span></span><br><span class="line">I am child procress, pid : <span class="number">265418</span>, ppid : <span class="number">265417</span></span><br><span class="line">i : <span class="number">0</span>, pid : <span class="number">265418</span></span><br><span class="line">i : <span class="number">1</span>, pid : <span class="number">265417</span></span><br><span class="line">i : <span class="number">1</span>, pid : <span class="number">265418</span></span><br><span class="line">i : <span class="number">2</span>, pid : <span class="number">265417</span></span><br><span class="line">i : <span class="number">2</span>, pid : <span class="number">265418</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025204.png" alt="39"></p>
<blockquote>
<p>Linux父子进程中变量地址相同——虚拟内存</p>
<p>csdn参考网址：<a href="https://blog.csdn.net/weixin_45636061/article/details/124610215?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124610215-blog-124260634.235%5Ev28%5Epc_relevant_t0_download&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124610215-blog-124260634.235%5Ev28%5Epc_relevant_t0_download&utm_relevant_index=2">虚拟内存</a></p>
<p><strong>物理内存和虚拟内存被分成了页框与页之后，其存储单元原来的地址都被自然地分成了两段，并且这两段各自代表着不同的意义：高位段分别叫做页框码和页码，它们是识别页框和页的编码；低位段分别叫做页框偏移量和页内偏移量，它们是存储单元在页框和页内的地址编码。</strong></p>
<p><strong>处理器遇到的地址都是虚拟地址。虚拟地址和物理地址都分成页码（页框码）和偏移值两部分。在由虚拟地址转化成物理地址的过程中，偏移值不变。而页码和页框码之间的映射就在一个映射记录表——页表中。</strong></p>
<p><strong>当程序执行fork()并创建子进程时，子进程会完全复制父进程的栈空间，包括页表，但没有复制物理页面，所以这时父子进程的变量地址相同，也即虚拟地址和物理地址相同。</strong></p>
<p>但是此时父子共享的页面仅标记为“只读”，在父子进程都没有访问内存时，二者共享一个页面。</p>
<p>当发生内存访问操作时，内核会复制一个物理页面给该进程，并修改其页表。同时把原来的只读页面标记为“可写”，留给另一个进程。以上即为所谓的“<strong>写时复制</strong>”或“<strong>写时拷贝</strong>”。</p>
</blockquote>
<ul>
<li><p>父子进程关系</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">父子进程之间的关系：</span><br><span class="line">    区别：</span><br><span class="line">        <span class="number">1.f</span>ork()函数的返回值不同</span><br><span class="line">            父进程中: &gt;<span class="number">0</span> 返回的子进程的ID</span><br><span class="line">            子进程中: =<span class="number">0</span></span><br><span class="line">        <span class="number">2.</span>pcb（进程控制块）中的一些数据</span><br><span class="line">            当前的进程的id pid</span><br><span class="line">            当前的进程的父进程的id ppid</span><br><span class="line">            信号集</span><br><span class="line"></span><br><span class="line">    共同点：</span><br><span class="line">        某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</span><br><span class="line">            - 用户区的数据</span><br><span class="line">            - 文件描述符表</span><br><span class="line">    </span><br><span class="line">    父子进程对变量是不是共享的？</span><br><span class="line">        - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。</span><br><span class="line">        - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。</span><br></pre></td></tr></table></figure>
</li>
<li><p>GDB多进程调试</p>
<ul>
<li><p>GDB默认只能跟踪一个进程，<strong>默认跟踪父进程</strong>。所以需要指令设置GDB跟踪的是父进程还是子进程</p>
</li>
<li><p>设置调试父进程或子进程：</p>
<ul>
<li><code>set follow-fork-mode [parent(默认) | child]</code></li>
</ul>
</li>
<li><p>设置调试模式</p>
<ul>
<li><pre><code>set detach-on-fork [on | off]
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      - `on`：调试当前进程时，其它进程继续运行；</span><br><span class="line">      - `off`：调试当前进程时，其它进程被GDB挂起。</span><br><span class="line"></span><br><span class="line">  - 查看调试的进程：</span><br><span class="line"></span><br><span class="line">    - `info inderiors`</span><br><span class="line"></span><br><span class="line">  - 切换当前调试的进程：</span><br><span class="line"></span><br><span class="line">    - `inferior id`</span><br><span class="line"></span><br><span class="line">  - 使进程脱离GDB调试：</span><br><span class="line"></span><br><span class="line">    - `detach inferiors id`</span><br><span class="line"></span><br><span class="line">## （3）exec函数族</span><br><span class="line"></span><br><span class="line">- **exec函数族**的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件</span><br><span class="line"></span><br><span class="line">- **exec函数族**的函数执行成功后不会返回，因为**调用进程的实体，包括代码段，数据段和堆栈等（即即将执行的可执行文件的用户区内容）都已经被新的内容取代**，只留下进程 ID 等一些表面上的信息仍保持原样；**只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行**</span><br><span class="line"></span><br><span class="line">- 函数原型：</span><br><span class="line"></span><br><span class="line">  ![40](https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025390.png)</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  #include &lt;unistd.h&gt;</span><br><span class="line">  int execl(const char *path, const char *arg, ...);</span><br><span class="line">      - 参数：</span><br><span class="line">          - path:需要指定的执行的文件的路径或者名称</span><br><span class="line">              a.out /home/nowcoder/a.out 推荐使用绝对路径</span><br><span class="line">              ./a.out hello world</span><br><span class="line">  </span><br><span class="line">          - arg:是执行可执行文件所需要的参数列表</span><br><span class="line">              第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="line">              从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="line">              参数最后需要以NULL结束（哨兵）</span><br><span class="line">  </span><br><span class="line">      - 返回值：</span><br><span class="line">          只有当调用失败，才会有返回值，返回-1，并且设置errno</span><br><span class="line">          如果调用成功，没有返回值。</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="（4）进程控制"><a href="#（4）进程控制" class="headerlink" title="（4）进程控制"></a>（4）进程控制</h2><p>1）进程退出</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025341.png" alt="41"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">    void exit(int status);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    void _exit(int status);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\\n&quot;</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exit(0); // 可打印hello world</span></span><br><span class="line">    _exit(<span class="number">0</span>);   <span class="comment">// 仅打印hello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分析：</span></span><br><span class="line">    <span class="comment">// 对于标准c库函数printf，首先会把其中的内容放入缓冲区</span></span><br><span class="line">    <span class="comment">// 当有\\n时，会对缓冲区进行刷新，从而就可以获取到hello这一内容</span></span><br><span class="line">    <span class="comment">// 而没有\\n时，world会首先被放到缓冲区，_exit也不会对缓冲区进行刷新，从而无法打印</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）孤儿进程</p>
<ul>
<li>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程<strong>（Orphan Process）</strong></li>
<li>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为<code>init</code>，而<code>init</code>进程会循环地 <code>wait()</code>已经退出的子进程。这样，当一个孤儿进程结束了其生命周期的时候，<code>init</code>进程就会处理它的一切善后工作</li>
<li>孤儿进程实际上无危害</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d, ppid : %d\\n&quot;</span>, getpid(), getppid());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 当前是子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d, ppid : %d\\n&quot;</span>, getpid(),getppid());</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d , pid : %d\\n&quot;</span>, i , getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">root@iisayhi:~/lesson/lesson08# ./orphan</span><br><span class="line">i am parent process, pid : <span class="number">275127</span>, ppid : <span class="number">272697</span></span><br><span class="line">i : <span class="number">0</span> , pid : <span class="number">275127</span></span><br><span class="line">i : <span class="number">1</span> , pid : <span class="number">275127</span></span><br><span class="line">i : <span class="number">2</span> , pid : <span class="number">275127</span></span><br><span class="line">root@iisayhi:~/lesson/lesson08<span class="meta"># i am child process, pid : 275128, **ppid : 1**</span></span><br><span class="line">i : <span class="number">0</span> , pid : <span class="number">275128</span></span><br><span class="line">i : <span class="number">1</span> , pid : <span class="number">275128</span></span><br><span class="line">i : <span class="number">2</span> , pid : <span class="number">275128</span></span><br></pre></td></tr></table></figure>

<p>3）僵尸进程</p>
<ul>
<li>每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。<strong>进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程</strong></li>
<li><strong>僵尸进程不能被</strong><code>kill -9</code><strong>杀死</strong>，因此如果父进程不调用<code>wait()</code>或<code>waitpid()</code>的话，那么保留的那段信息就不会释放，<strong>其进程号就会一直被占用</strong>，但是系统所能使用的进程号是有限的，<strong>如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免</strong></li>
</ul>
<p>4）wait &amp; waitpid</p>
<ul>
<li><p><strong>注意：一次<code>wait</code>或<code>waitpid</code>调用只能清理一个子进程，清理多个子进程应使用循环</strong></p>
</li>
<li><p><code>wait()</code></p>
<ul>
<li><code>wait()</code>函数会阻塞<strong>（阻塞的意思就是说，在子进程结束前，会一直阻塞在<code>wait()</code>函数处，等到子进程结束后才会继续向下执行）</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025019.png" alt="42"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *wstatus)</span>;</span><br><span class="line">    功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源。</span><br><span class="line">    参数：<span class="type">int</span> *wstatus</span><br><span class="line">        进程退出时的状态信息，传入的是一个<span class="type">int</span>类型的地址，传出参数。</span><br><span class="line">    返回值：</span><br><span class="line">        - 成功：返回被回收的子进程的id</span><br><span class="line">        - 失败：<span class="number">-1</span> (所有的子进程都结束，调用函数失败)</span><br><span class="line"></span><br><span class="line">调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span><br><span class="line">如果没有子进程了，函数立刻返回，返回<span class="number">-1</span>；如果子进程都已经结束了，也会立即返回，返回<span class="number">-1.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>waitpid()</code></p>
<ul>
<li><code>waitpid()</code>可以设置不阻塞<strong>（不阻塞的意思就是说，即使子进程还未结束，<code>waitpid()</code>也会立刻返回，程序可以接着往下执行）</strong>，<code>waitpid()</code>还可以指定等待哪个子进程结束</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line">    功能：回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="line">    参数：</span><br><span class="line">        - pid:</span><br><span class="line">            pid &gt; <span class="number">0</span> : 某个子进程的pid</span><br><span class="line">            pid = <span class="number">0</span> : 回收当前进程组的所有子进程    </span><br><span class="line">            pid = <span class="number">-1</span> : 回收所有的子进程，相当于 wait()  （最常用）</span><br><span class="line">            pid &lt; <span class="number">-1</span> : 某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="line">        - options：设置阻塞或者非阻塞</span><br><span class="line">            <span class="number">0</span> : 阻塞</span><br><span class="line">            WNOHANG : 非阻塞</span><br><span class="line">     返回值：</span><br><span class="line">        &gt; <span class="number">0</span> : 返回子进程的id</span><br><span class="line">        = <span class="number">0</span> : options=WNOHANG, 表示还有子进程或者</span><br><span class="line">        = <span class="number">-1</span> ：错误，或者没有子进程了</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="（5）进程间通信"><a href="#（5）进程间通信" class="headerlink" title="（5）进程间通信"></a>（5）进程间通信</h2><h3 id="1）匿名管道"><a href="#1）匿名管道" class="headerlink" title="1）匿名管道"></a>1）匿名管道</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">管道的读写特点：</span><br><span class="line">使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I/O操作）</span><br><span class="line">	<span class="number">1.</span>所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为<span class="number">0</span>），有进程从管道的读端</span><br><span class="line">	读数据，那么管道中剩余的数据被读取以后，再次read会返回<span class="number">0</span>，就像读到文件末尾一样。</span><br><span class="line">	</span><br><span class="line">	<span class="number">2.</span>如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于<span class="number">0</span>），而持有管道写端的进程</span><br><span class="line">	也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，</span><br><span class="line">	再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。</span><br><span class="line">	</span><br><span class="line">	<span class="number">3.</span>如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为<span class="number">0</span>），这个时候有进程</span><br><span class="line">	向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。</span><br><span class="line">	</span><br><span class="line">	<span class="number">4.</span>如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于<span class="number">0</span>），而持有管道读端的进程</span><br><span class="line">	也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，</span><br><span class="line">	直到管道中有空位置才能再次写入数据并返回。</span><br><span class="line">总结：</span><br><span class="line">	读管道：</span><br><span class="line">		管道中有数据，read返回实际读到的字节数。</span><br><span class="line">		管道中无数据：</span><br><span class="line">			写端被全部关闭，read返回<span class="number">0</span>（相当于读到文件的末尾）</span><br><span class="line">			写端没有完全关闭，read阻塞等待</span><br><span class="line">	</span><br><span class="line">	写管道：</span><br><span class="line">    管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）</span><br><span class="line">    管道读端没有全部关闭：</span><br><span class="line">        管道已满，write阻塞</span><br><span class="line">        管道没有满，write将数据写入，并返回实际写入的字节数</span><br></pre></td></tr></table></figure>

<h3 id="2）有名管道"><a href="#2）有名管道" class="headerlink" title="2）有名管道"></a>2）有名管道</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">有名管道的注意事项：</span><br><span class="line">	<span class="number">1.</span>一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</span><br><span class="line">	<span class="number">2.</span>一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</span><br><span class="line"></span><br><span class="line">读管道：</span><br><span class="line">    管道中有数据，read返回实际读到的字节数</span><br><span class="line">    管道中无数据：</span><br><span class="line">        写端被全部关闭，read返回<span class="number">0</span>（相当于读到文件末尾）</span><br><span class="line">        写端没有完全关闭，read阻塞等待</span><br><span class="line"></span><br><span class="line">写管道：</span><br><span class="line">    管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）</span><br><span class="line">    管道读端没有全部关闭：</span><br><span class="line">        管道已满，write阻塞</span><br><span class="line">        管道没有满，write将数据写入，并返回实际写入的字节数。</span><br></pre></td></tr></table></figure>

<ul>
<li>有名管道实现简单版聊天功能</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171026474.png" alt="43"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读数据</span></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">  ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">  <span class="comment">// ret = read(fdr, buf, strlen(buf)); 错误写法</span></span><br><span class="line">  <span class="keyword">if</span>(ret &lt;= <span class="number">0</span> )&#123;perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>read</code>函数的原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>fd</code>为文件描述符；<code>buf</code>表示读出数据缓冲区地址；<code>count</code>表示读出的字节数。</p>
<p>因此，若写成<code>ret = read(fdr, buf, strlen(buf))</code>，在当时所写程序中，最开始并未写入数据，因此读到的数据为空，则将报错</p>
<h2 id="（6）内存映射"><a href="#（6）内存映射" class="headerlink" title="（6）内存映射"></a>（6）内存映射</h2><p>内存映射（Memory-mapped I&#x2F;O）是将磁盘文件的数据映射到内存，用户通过修改 内存就能修改磁盘文件。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171026332.png" alt="44"></p>
<h1 id="7、阻塞-非阻塞-同步-异步"><a href="#7、阻塞-非阻塞-同步-异步" class="headerlink" title="7、阻塞&#x2F;非阻塞 &amp;&amp; 同步&#x2F;异步"></a>7、阻塞&#x2F;非阻塞 &amp;&amp; 同步&#x2F;异步</h1><p><a href="https://blog.csdn.net/lengxiao1993/article/details/78154467?ops_request_misc=%7B%22request_id%22:%22168319803316800182190279%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168319803316800182190279&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-78154467-null-null.142%5Ev86%5Ekoosearch_v1,239%5Ev2%5Einsert_chatgpt&utm_term=%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E&spm=1018.2226.3001.4187">阻塞与非阻塞_csdn</a></p>
<ul>
<li><p>阻塞（Blocking）与非阻塞（Nonblocking）是在数据就绪阶段进行判断</p>
<ul>
<li><p>阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。</p>
</li>
<li><p>非阻塞指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。当前线程可以去干别的事情。</p>
</li>
<li><p>sockfd对应操作系统中一个tcp缓冲区，阻塞与非阻塞都在该缓冲区中进行考虑。</p>
<blockquote>
<p><strong>阻塞IO和非阻塞IO的区别就在于</strong>： 应用程序的调用是否立即返回</p>
</blockquote>
</li>
</ul>
</li>
<li><p>同步（Synchronous）与非同步（Asynchronous）在数据读写阶段进行判断</p>
<ul>
<li><p>同步即应用程序自己从内核缓冲区中获取数据送入自己定义的buf中，只有数据获取结束之后应用程序才能进行其他的操作。</p>
</li>
<li><p>异步中有一个非常重要的“通知方式”，异步即为操作系统将数据从内核中送入自己定义的buf中，不需要我们自己操作，数据放好后通过“通知方式”告诉我们</p>
<blockquote>
<p><strong>同步IO</strong>：应用程序主动向内核查询是否有可用数据，如果有,当前进程自己负责把数据从内核copy到用户空间，拷贝的过程中进程阻塞。 <strong>异步IO</strong>：应用程序向内核发起读数据请求时需要：（1）告诉内核数据存放位置（2）注册回调函数，当内核完成数据copy后调用回调通知应用程序取数据。因为数据copy由内核完成的，所以拷贝的时候进程不阻塞。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="8、用户空间和内核空间"><a href="#8、用户空间和内核空间" class="headerlink" title="8、用户空间和内核空间"></a>8、用户空间和内核空间</h1><ul>
<li>内存空间的划分<ul>
<li>内核空间</li>
<li>用户空间</li>
</ul>
</li>
<li><strong>操作系统内核需要拥有高于普通进程的权限</strong>， 以此来调度和管理用户的应用程序，不同进程间相对独立。</li>
<li>硬件层面的内存访问权限控制细节：DPL&#x2F;CPL</li>
</ul>
<h1 id="9、进程切换与进程阻塞"><a href="#9、进程切换与进程阻塞" class="headerlink" title="9、进程切换与进程阻塞"></a>9、进程切换与进程阻塞</h1><ul>
<li>进程切换中几个最重要的步骤：</li>
</ul>
<p>1）当一个程序正在执行的过程中， 中断（interrupt） 或 系统调用（system call） 发生可以使得CPU的控制权会从当前进程转移到操作系统内核。</p>
<p>2）操作系统内核负责保存<code>进程i</code>在CPU中的上下文（程序计数器， 寄存器）到<code>PCBi</code>（操作系统分配给进程的一个内存块）中。</p>
<p>3）从<code>PCBj</code>取出<code>进程j</code>的CPU 上下文， 将 CPU 控制权转移给<code>进程j</code> ， 开始执行<code>进程j</code>的指令。</p>
<ul>
<li>中断<ul>
<li>在每个时钟周期末尾查询当前CPU中断位是否有中断信号送入，若有，判断当前正在执行的指令和中断信号的指令的优先级，决定执行哪个指令</li>
</ul>
</li>
<li>时钟中断<ul>
<li>一个硬件时钟会每隔一段（很短）的时间就产生一个中断信号发送给 CPU，CPU 在响应这个中断时， 就会去执行操作系统内核的指令， 继而将 CPU 的控制权转移给了操作系统内核， 可以由操作系统内核决定下一个要被执行的指令</li>
</ul>
</li>
<li>系统调用<ul>
<li>system call 是操作系统提供给应用程序的接口。 用户通过调用 system call 来完成那些需要操作系统内核进行的操作， 例如硬盘， 网络接口设备的读写等</li>
</ul>
</li>
<li><strong>对于一个运行着 UNIX 系统的现代 PC 来说， 进程切换至少需要花费 300 us 的时间</strong></li>
<li>进程阻塞<ul>
<li>我们所说的 “阻塞”是指进程在<strong>发起了一个系统调用</strong>（System Call） 后， 由于该系统调用的操作不能立即完成，需要等待一段时间，于是内核将进程挂起为等待 （waiting）状态， 以确保它不会被调度执行， 占用 CPU 资源。</li>
</ul>
</li>
</ul>
<h1 id="10、Unix-Linux上的五种IO模型"><a href="#10、Unix-Linux上的五种IO模型" class="headerlink" title="10、Unix&#x2F;Linux上的五种IO模型"></a>10、Unix&#x2F;Linux上的五种IO模型</h1><p>（1）<strong>（同步）阻塞 blocking</strong></p>
<p>阻塞即为：调用某函数后，必须等到该函数返回之后才能进行下一步动作。</p>
<p>（2）<strong>（同步）非阻塞 non-blocking</strong></p>
<p>非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。一旦内核中的数据准备好了，并且又再次收到了用户进程的请求，那么<strong>进程就会将内核中的数据拷贝到用户内存</strong>，然后返回。</p>
<p>非阻塞I&#x2F;O执行系统调用总是立即返回，不管事件是否已经发生。</p>
<p>（3）<strong>IO复用 IO multiplexing</strong></p>
<p>Linux 用 <code>select/poll/epoll</code> 函数实现 IO 复用模型。</p>
<p>这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。</p>
<p>（4）<strong>信号驱动 signal-driven</strong></p>
<p>Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到<code>SIGIO</code>信号，然后处理 IO 事件。</p>
<blockquote>
<p>多路复用和信号驱动的区别与联系：</p>
<ul>
<li>多路复用：内核们监听多个文件描述符，阻塞在监听的函数处（如<code>select/poll/epoll</code>），同时也阻塞在数据拷贝阶段。多路复用只是<strong>防止进程在某个io阻塞后，不能及时处理其他io的事件。</strong></li>
<li>信号驱动：先登记信号处理函数，当数据准备完毕后由内核发送信号给进程，让进程处理。信号驱动<strong>不阻塞在数据准备过程，但阻塞在数据拷贝</strong>。</li>
</ul>
</blockquote>
<p>💡 <strong>前四种方式都属于同步IO。</strong></p>
<p>（5）<strong>异步 asynchronous</strong></p>
<p>Linux中，可以调用 <code>aio_read</code> 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及<strong>通知的方式</strong>，然后<strong>立即返回</strong>，当内核将数据拷贝到缓冲区后，再通知应用程序。</p>
<h1 id="11、Web-Server（网页服务器）"><a href="#11、Web-Server（网页服务器）" class="headerlink" title="11、Web Server（网页服务器）"></a>11、<strong>Web Server（网页服务器）</strong></h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171026839.png" alt="45"></p>
]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/08/4%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、因特网概述"><a href="#1、因特网概述" class="headerlink" title="1、因特网概述"></a>1、因特网概述</h2><p><strong>internet与Internet的区别</strong></p>
<ul>
<li><p><strong>internet(互联网或互连网)<strong>是一个通用名词，它泛指</strong>多个计算机网络互连而成的网络</strong>。在这些网络之间的通信协议可以是任意的。</p>
</li>
<li><p><strong>Internet（因特网）则是一个专用名词</strong>，它指<strong>当前全球最大的、开放的、由众多网络互连而成的特定计算机网络</strong>，它采用TCP&#x2F;IP协议族作为通信的规则，其前身是美国的ARPANET。</p>
</li>
</ul>
<p>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是互联网(Internet)。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121642022.webp" alt="img"></p>
<blockquote>
<p>普通用户是如何接入到因特网的呢？</p>
<p>答：<strong>通过ISP接入因特网</strong></p>
<p>ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从<strong>ISP的得到所需要的IP地址</strong>。</p>
<p><strong>因为因特网上的主机都必须有IP地址才能进行通信，这样就可以通过该ISP接入到因特网</strong></p>
</blockquote>
<h2 id="2、计算机网络体系结构"><a href="#2、计算机网络体系结构" class="headerlink" title="2、计算机网络体系结构"></a>2、计算机网络体系结构</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121644183.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121645050.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121645246.webp" alt="img"></p>
<h1 id="二、网络层"><a href="#二、网络层" class="headerlink" title="二、网络层"></a>二、网络层</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646323.png" alt="image-20240412164600035"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646120.png" alt="image-20240412164607943"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646736.png" alt="image-20240412164616479"></p>
<h1 id="三、运输层"><a href="#三、运输层" class="headerlink" title="三、运输层"></a>三、运输层</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-d9a70806edc95dc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的。</strong></p>
<h2 id="2、运输层端口号、复用与分用的概念"><a href="#2、运输层端口号、复用与分用的概念" class="headerlink" title="2、运输层端口号、复用与分用的概念"></a>2、运输层端口号、复用与分用的概念</h2><h3 id="（1）为什么用端口号"><a href="#（1）为什么用端口号" class="headerlink" title="（1）为什么用端口号"></a>（1）为什么用端口号</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-de597eda77aa6acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（2）发送方的复用和接收方的分用"><a href="#（2）发送方的复用和接收方的分用" class="headerlink" title="（2）发送方的复用和接收方的分用"></a>（2）发送方的复用和接收方的分用</h3><ul>
<li><p><strong>多个进程</strong>利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据——<strong>复用</strong></p>
</li>
<li><p><strong>多个进程</strong>利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>数据—— <strong>分用</strong></p>
</li>
<li><p>这里一个端口表示一个进程</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2a4ec3f5d5c11433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（3）常用端口号"><a href="#（3）常用端口号" class="headerlink" title="（3）常用端口号"></a>（3）常用端口号</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2117fa99a7f2a89c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="3、TCP和UDP的对比"><a href="#3、TCP和UDP的对比" class="headerlink" title="3、TCP和UDP的对比"></a>3、TCP和UDP的对比</h2><h3 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h3><ul>
<li><p>TCP</p>
<ol>
<li>面向连接，需要在两个套接字之间建立连接，提供可靠服务；</li>
<li>传送TCP报文；</li>
<li>支持点对点单播，不支持多播、广播；</li>
<li>应用场景如万维网、电子邮件、文件传送等。</li>
</ol>
</li>
<li><p>UDP</p>
<ol>
<li><p>无连接，不需要套接字，不提供可靠交付；</p>
</li>
<li><p>传送UDP报文或用户数据报；</p>
</li>
<li><p>支持单播、多播和广播；</p>
</li>
<li><p>应用场景如多媒体应用等。</p>
<img src="https:////upload-images.jianshu.io/upload_images/24878825-624005a24bc5bfcd.png?imageMogr2/auto-orient/strip|imageView2/2/w/871/format/webp" alt="img" style="zoom: 50%;" /></li>
</ol>
</li>
</ul>
<h3 id="（2）TCP"><a href="#（2）TCP" class="headerlink" title="（2）TCP"></a>（2）TCP</h3><p>TCP（Transmission Control Protocol）</p>
<p>发送方</p>
<ul>
<li><p>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，但不知道这些待传送的字节流的含义</p>
</li>
<li><p>将他们编号，并存储在自己发送缓存中</p>
</li>
<li><p>根据发送策略，提取一定量的字节构建TCP报文并发送</p>
</li>
</ul>
<p>接收方</p>
<ul>
<li><p>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</p>
</li>
<li><p>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</p>
</li>
<li><p>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</p>
</li>
</ul>
<p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础。在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收。</p>
<img src="https:////upload-images.jianshu.io/upload_images/24878825-db48b70af7fb7884.png?imageMogr2/auto-orient/strip|imageView2/2/w/897/format/webp" alt="img" style="zoom:50%;" />

<h2 id="4、TCP的流量控制"><a href="#4、TCP的流量控制" class="headerlink" title="4、TCP的流量控制"></a>4、TCP的流量控制</h2><p>流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p>
<ul>
<li>当主机A收到主机B对相关字节数据的<strong>累计确认</strong>时，可以将其在发送缓存中删除。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f73e94f75e94ea4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5bd53b8a5a5ac400.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ea9dc3589e6c6bd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面。因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传。</p>
</blockquote>
<h2 id="5、TCP的拥塞控制"><a href="#5、TCP的拥塞控制" class="headerlink" title="5、TCP的拥塞控制"></a>5、TCP的拥塞控制</h2><p>在某段时间中，若对网络中某一资源（如链路容量&#x2F;带宽、缓存和处理机等）的需求超过了该资源所能提供的可用部分，就称发生了<strong>拥塞</strong>。</p>
<p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p>
<ol>
<li>点缓存的容量太小；</li>
<li>链路的容量不足；</li>
<li>处理机处理的速率太慢；</li>
<li>拥塞本身会进一步加剧拥塞；</li>
</ol>
<blockquote>
<p>相关算法</p>
<ul>
<li><strong>慢开始（slow-start）</strong></li>
<li><strong>拥塞避免（congestion avoidance）</strong></li>
<li><strong>快重传（fast transmit）</strong></li>
<li><strong>快恢复（fast recovery）</strong></li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c7682fe29ebcb6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>真正的发送窗口值 &#x3D; Min (接收方窗口值，拥塞窗口值)</p>
</blockquote>
<h3 id="（1）慢开始和拥塞避免"><a href="#（1）慢开始和拥塞避免" class="headerlink" title="（1）慢开始和拥塞避免"></a>（1）慢开始和拥塞避免</h3><h4 id="A-慢开始"><a href="#A-慢开始" class="headerlink" title="A. 慢开始"></a>A. 慢开始</h4><ul>
<li>目的：用来确定网络的负载能力或拥塞程度。</li>
<li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li>
<li>两个变量：<ul>
<li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。<ul>
<li>1 至 2 个最大报文段 （旧标准）</li>
<li>2 至 4 个最大报文段 （RFC 5681）</li>
</ul>
</li>
<li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-47dba7f2068f35df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1bca665e8eaa965a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/713/format/webp" alt="img"></p>
<blockquote>
<p>图中swnd是发送窗口</p>
<p>每经过一个传输轮次，拥塞窗口就加倍</p>
<p>窗口大小按<strong>指数增加</strong>，2的n-1次方</p>
</blockquote>
<h4 id="B-拥塞避免"><a href="#B-拥塞避免" class="headerlink" title="B. 拥塞避免"></a>B. 拥塞避免</h4><ul>
<li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。</li>
<li>每经过一个传输轮次，拥塞窗口 <strong>cwnd &#x3D; cwnd + 1</strong>。</li>
<li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li>
<li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。<img src="https://upload-images.jianshu.io/upload_images/24878825-f5db7ea25d8aca73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></li>
</ul>
<h3 id="（2）快重传和快恢复"><a href="#（2）快重传和快恢复" class="headerlink" title="（2）快重传和快恢复"></a>（2）快重传和快恢复</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-fee86fb3707a175c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="A-快重传"><a href="#A-快重传" class="headerlink" title="A. 快重传"></a>A. 快重传</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a57c7cc819aa4bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="B-快恢复"><a href="#B-快恢复" class="headerlink" title="B. 快恢复"></a>B. 快恢复</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-ab5a63efbd586eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="C-改进后的整体示意图"><a href="#C-改进后的整体示意图" class="headerlink" title="C. 改进后的整体示意图"></a>C. 改进后的整体示意图</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-8f61b8eddb5b2624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="6、TCP超时重传"><a href="#6、TCP超时重传" class="headerlink" title="6、TCP超时重传"></a>6、TCP超时重传</h2><blockquote>
<p>往返时间：<strong>RTT0</strong></p>
<p>超时重传时间：<strong>RTO</strong></p>
</blockquote>
<p>如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大；如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率。因此需要合理选择RTO的值。</p>
<ul>
<li>不能直接使用某次测量得到的RTT样本来计算超时重传时间RTO。应该利用每次测量得到的RTT样本，计算加权平均往返时间<strong>RTTs</strong>（又称为平滑的往返时间）</li>
</ul>
<p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107689.webp" alt="img"></p>
<p><strong>往返时间RTT的测量比较复杂</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107552.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107260.webp" alt="img"></p>
<p><strong>TCP超时重传的计算</strong></p>
<p>举例</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107514.webp" alt="img"></p>
<h2 id="7、TCP可靠传输的实现"><a href="#7、TCP可靠传输的实现" class="headerlink" title="7、TCP可靠传输的实现"></a>7、TCP可靠传输的实现</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-6d10ea76a1ea032b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-92d975bc880db892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-35bff0a8cc5b0d71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="8、三次握手"><a href="#8、三次握手" class="headerlink" title="8、三次握手"></a>8、三次握手</h2><h3 id="（1）三次握手详解"><a href="#（1）三次握手详解" class="headerlink" title="（1）三次握手详解"></a>（1）三次握手详解</h3><ul>
<li>采用<strong>三次握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li>
</ul>
<ul>
<li><p>TCP的连接建立要解决以下三个问题</p>
<ul>
<li>使得双方能够确知对方的存在；</li>
<li>使得双方能够协商一些参数（如最大窗口值、是否使用时间戳选项和服务质量等）；</li>
<li>使得双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li>
</ul>
</li>
<li><p><strong>具体过程</strong></p>
<ol>
<li><p><strong>TCP服务器进程创建传输控制块，用来存储TCP连接中的一些重要信息，并进入监听状态，等待TCP客户端进程的连接请求</strong></p>
</li>
<li><p><strong>TCP客户进程也是首先创建传输控制块</strong></p>
</li>
<li><p><strong>TCP客户进程向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态。</strong></p>
<ol>
<li>其中， TCP连接请求报文段首部中的同步位syn被设置为1，表明这是一个TCP连接请求报文段；</li>
<li>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号；</li>
<li>注意<em>该报文段不能携带数据</em>，但要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态。</strong></p>
<ol>
<li>同步位SYN和确认位ACK都设置为1，表明这是一个TCP连接请求确认报文段；</li>
<li>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号；</li>
<li>确认位ACK的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认；</li>
<li>注意<em>该报文段也不能携带数据</em>，且同样要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态。</strong></p>
<ol>
<li>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1；</li>
<li>确认位ACK被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认；</li>
<li>注意<em>普通的TCP确认报文段可以携带数据</em>，但如果不携带数据，则不消耗序号。</li>
</ol>
</li>
<li><p><strong>TCP服务器进程收到该确认报文段后也进入连接已建立状态。</strong></p>
</li>
</ol>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-987d5c8512392422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（2）为什么不能“两次握手”？"><a href="#（2）为什么不能“两次握手”？" class="headerlink" title="（2）为什么不能“两次握手”？"></a>（2）为什么不能“两次握手”？</h3><blockquote>
<p>不采用两次握手主要是为了<strong>防止已经失效的连接请求报文段突然又传到服务端</strong>，因而产生错误。</p>
<p>这种情况是：<strong>客户端发出的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到下一个连接释放以后的某个时间才到达服务器端。</strong>当服务器端收到此失效报文后，会误认为是客户端发出的一个新连接请求，于是客户端又发出确认报文，表示同意建立连接。</p>
<p>如果不采用“三次握手”，那么只要服务器端发出确认报文就会认为新的连接已经建立了，但此时客户端并没有发出建立连接的请求，因此不会向服务器端发送数据。服务器端没有收到数据就会一直等待，这样就会白白浪费掉很多资源。</p>
<p>所以必须采用“三次握手”而非“两次握手”。</p>
</blockquote>
<p>下图是“两次握手”的示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0a5773a600817c41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="9、四次挥手"><a href="#9、四次挥手" class="headerlink" title="9、四次挥手"></a>9、四次挥手</h2><h3 id="（1）四次挥手详解"><a href="#（1）四次挥手详解" class="headerlink" title="（1）四次挥手详解"></a>（1）四次挥手详解</h3><ul>
<li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong>端，被动等待连接建立的应用进程叫做<strong>TCP服务器</strong>。<strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong>。</li>
</ul>
<ul>
<li><p>具体过程</p>
<ol>
<li><p><strong>当客户端和服务器端都处于连接已建立状态时，若要释放连接，客户进程会发送TCP连接释放报文段，并进入终止等待状态。</strong></p>
<ol>
<li>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；</li>
<li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1；</li>
<li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1；</li>
<li>注意FIN等于1的报文段即使不携带数据，也要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态。</strong></p>
<ol>
<li>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配；</li>
<li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认。</li>
</ol>
</li>
<li><p><strong>此时，从客户进程到服务器进程这个方向的连接就释放了，这时的TCP连接属于半关闭状态，也就是客户进程已经没有数据要发送了。但如果服务器进程还有数据要发送，客户进程仍要接收，也就是说从服务器进程到客户进程这个方向的连接并未关闭。</strong></p>
</li>
<li><p><strong>客户进程收到TCP确认报文段后就进入终止等待状态，等待服务器进程发出的TCP连接释放报文段。若服务器进程已经没有数据要发送了，服务器进程即释放连接。由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接。</strong></p>
</li>
<li><p><strong>服务器进程发送TCP连接释放报文段并进入最后确认状态。</strong></p>
<ol>
<li><p>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；</p>
</li>
<li><p>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送；</p>
</li>
<li><p>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认。</p>
</li>
</ol>
</li>
<li><p><strong>客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态。服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要经过2MSL后才能进入关闭状态。</strong></p>
<ol>
<li>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号；</li>
<li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认。</li>
</ol>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1c5e0c6357d039ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
</li>
</ul>
<h3 id="（2）为什么不能“三次挥手”？"><a href="#（2）为什么不能“三次挥手”？" class="headerlink" title="（2）为什么不能“三次挥手”？"></a>（2）为什么不能“三次挥手”？</h3><p>TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p>
<blockquote>
<p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。</p>
<p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ef85470fe120f146.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="10、TCP保活计时器"><a href="#10、TCP保活计时器" class="headerlink" title="10、TCP保活计时器"></a>10、TCP保活计时器</h2><p>TCP双方已经建立连接时，TCP客户进程所在的主机突然出现了故障。此时服务器进程无法再收到客户进程发来的数据。因此，应当有措施使TCP服务器进程不要再白白等待下去。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2dc97e06fe1d82ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h1 id="四、应用层"><a href="#四、应用层" class="headerlink" title="四、应用层"></a>四、应用层</h1><h2 id="1、CS方式和P2P方式"><a href="#1、CS方式和P2P方式" class="headerlink" title="1、CS方式和P2P方式"></a>1、CS方式和P2P方式</h2><h3 id="（1）CS方式（客户-服务器方式）"><a href="#（1）CS方式（客户-服务器方式）" class="headerlink" title="（1）CS方式（客户&#x2F;服务器方式）"></a>（1）CS方式（客户&#x2F;服务器方式）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121850174.webp" alt="img"></p>
<h3 id="（2）P2P方式（对等方式）"><a href="#（2）P2P方式（对等方式）" class="headerlink" title="（2）P2P方式（对等方式）"></a>（2）P2P方式（对等方式）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121850280.webp" alt="img"></p>
<h2 id="2、动态主机配置协议DHCP"><a href="#2、动态主机配置协议DHCP" class="headerlink" title="2、动态主机配置协议DHCP"></a>2、动态主机配置协议DHCP</h2><ul>
<li><p>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</p>
</li>
<li><p>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</p>
</li>
<li><p>DHCP的工作过程</p>
<ul>
<li><p><strong>DHCP 使用客户 - 服务器方式</strong></p>
<ul>
<li><p>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文  （DHCP DISCOVER），这时该主机就成为 DHCP 客户。</p>
</li>
<li><p>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</p>
</li>
<li><p>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</p>
</li>
</ul>
</li>
<li><p><strong>DHCP 工作方式</strong></p>
<ul>
<li><p>DHCP 使用客户-服务器方式，采用请求&#x2F;应答方式工作。</p>
</li>
<li><p>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121853443.webp" alt="img"></p>
<ul>
<li><p>DHCP中继代理</p>
<h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p>下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-33c64efac75f0ad2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p>
</blockquote>
</li>
<li><p>总结</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121854516.webp" alt="img"></p>
</li>
</ul>
<h2 id="3、域名系统DNS"><a href="#3、域名系统DNS" class="headerlink" title="3、域名系统DNS"></a>3、域名系统DNS</h2><h3 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855489.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855338.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855952.webp" alt="img"></p>
<h3 id="（2）域名解析过程"><a href="#（2）域名解析过程" class="headerlink" title="（2）域名解析过程"></a>（2）域名解析过程</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856499.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856729.webp" alt="img"></p>
<h2 id="4、文件传送协议FTP"><a href="#4、文件传送协议FTP" class="headerlink" title="4、文件传送协议FTP"></a>4、文件传送协议FTP</h2><blockquote>
<p>注意两种模式都是（1）控制连接在整个会话期间保持打开状态；（2）数据连接传输完毕后就关闭。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856907.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121857685.webp" alt="img"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>时间&amp;空间复杂度</title>
    <url>/2024/06/11/5%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4&amp;%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h1><h2 id="1、时间复杂度"><a href="#1、时间复杂度" class="headerlink" title="1、时间复杂度"></a>1、时间复杂度</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;     <span class="comment">// for循环语句执行 n+1 次</span></span><br><span class="line">  x++;                         <span class="comment">// x++;语句执行 n 次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段代码，总执行次数是<code>2n+1</code>，因此取其最大阶，其时间复杂度就是<code>O(n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;   <span class="comment">// 该for循环语句执行 n*(n+1) 次</span></span><br><span class="line">    x++;                       <span class="comment">// 该x++;语句执行 n*n 次</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段代码，总执行次数是<code>n+1+n*(n+1)+n*n</code>，因此取其最大阶，其时间复杂度就是<code>O(n^2)</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=i; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>; k&lt;=j; k++) &#123;</span><br><span class="line">            x++;                     <span class="comment">// 该x++;语句执行 A 次（见下方注释）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段代码，取其最大阶，其时间复杂度就是<code>O(n^3)</code>。</p>
<blockquote>
<p>A</p>
<p>对于这三个<code>for</code>循环语句，从下往上分析：</p>
<ul>
<li><pre><code class="c++">
</code></pre>
</li>
</ul>
<p> for (int k&#x3D;1; k&lt;&#x3D;j; k++) {<br>     x++;<br>  }<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> 执行`j`次；</span><br><span class="line"></span><br><span class="line">&gt;+ ```c++</span><br><span class="line"> for (int j=1; j&lt;=i; j++) &#123; </span><br><span class="line">     for (int k=1; k&lt;=j; k++) &#123; </span><br><span class="line">         x++; </span><br><span class="line">     &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p> 执行<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111459800.png" alt="image-20240611145906766" style="zoom:67%;" />次；</p>
<ul>
<li><pre><code class="c++">
</code></pre>
</li>
</ul>
<p> for (int i&#x3D;1; i&lt;&#x3D;n; i++) {<br>     for (int j&#x3D;1; j&lt;&#x3D;i; j++) {<br>         for (int k&#x3D;1; k&lt;&#x3D;j; k++) {<br>             x++;<br>         }<br>     }<br>  }</p>
<p>执行<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111500830.png" alt="image-20240611150038794" style="zoom: 67%;" />次。</p>
<p>综上所述，<code>x++;</code>语句执行的次数如下所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111457129.png" alt="image-20240611145732091" style="zoom:67%;" />
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i=i*<span class="number">2</span>) &#123;</span><br><span class="line">    x++;                         <span class="comment">// 该x++;语句执行 B 次（见下方注释）</span></span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段代码，取其最大阶，其时间复杂度就是<code>O(log2n)</code>。</p>
<blockquote>
<p>B</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111455603.png" alt="image-20240611145554310" style="zoom: 67%;" />

<p>所以，对于<code>for</code>循环语句来说，其执行了<code>k+1</code>次；但对于<code>x++;</code>语句来说，只执行了<code>k</code>次。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111527560.png" alt="image-20240611152735504" style="zoom:67%;" />
</blockquote>
<h2 id="2、空间复杂度"><a href="#2、空间复杂度" class="headerlink" title="2、空间复杂度"></a>2、空间复杂度</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111529670.png" alt="image-20240611152906551"></p>
<h1 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h1><h2 id="1、二分查找"><a href="#1、二分查找" class="headerlink" title="1、二分查找"></a>1、二分查找</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）时间复杂度</p>
<p><code>int left = 0, right = nums.size() - 1;</code>的时间复杂度为<code>O(1)</code>。</p>
<p>接下来看<code>while (left &lt;= right)</code>这个while循环最多会执行几次。</p>
<p>由于<code>int mid = left + (right - left) / 2;</code>，因此每一次会将搜索空间（<code>S</code>）折半，如下所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111544858.png" alt="image-20240611154411802" style="zoom: 80%;" />

<p>（2）空间复杂度</p>
<p>空间复杂度主要看算法使用的额外空间量（不包括输入数据本身）。</p>
<ol>
<li><strong>变量声明</strong>：<ul>
<li><code>int left</code>, <code>int right</code>, <code>int mid</code> 都是常数空间<code>O(1)</code>。</li>
</ul>
</li>
<li><strong>没有递归或额外的数据结构</strong>：<ul>
<li>算法不需要额外的数组、栈或队列等辅助数据结构。</li>
</ul>
</li>
</ol>
<p>综上，整个算法的空间复杂度是 <code>O(1)</code>。</p>
<h2 id="2、滑动窗口"><a href="#2、滑动窗口" class="headerlink" title="2、滑动窗口"></a>2、滑动窗口</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        sum += nums[r++];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if (sum &gt;= target) &#123;</span></span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, r - l);</span><br><span class="line">            sum -= nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<blockquote>
<p>注意此处的时间复杂度不是O(n^2)！分析如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (r &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    sum += nums[r++]; <span class="comment">// 这个操作会执行 n 次</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">        res = <span class="built_in">min</span>(res, r - l);</span><br><span class="line">        sum -= nums[l++]; <span class="comment">// 最坏情况下，内层 while 循环会执行 n 次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然嵌套了两层循环，但是由于整个过程中，<code>nums</code>中的每个元素最多会被<code>l</code>和<code>r</code>各访问一次，也即被操作两次，因此时间复杂度是<code>2n</code>，也即<code>O(n)</code>。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构_b站鲍松山</title>
    <url>/2023/12/05/5%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_b%E7%AB%99%E9%B2%8D%E6%9D%BE%E5%B1%B1/</url>
    <content><![CDATA[<p>参考教材：《数据结构（严蔚敏）》</p>
<span id="more"></span>

<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><p>数据结构（Data Struct）：数据之间的组织架构&#x2F;结构。</p>
<blockquote>
<p><strong>DS：</strong></p>
<ul>
<li><strong>线性结构</strong><ul>
<li><strong>SeqList&#x2F;List&#x2F;Stack&#x2F;Queue&#x2F;String&#x2F;Array</strong></li>
</ul>
</li>
<li><strong>非线性结构</strong><ul>
<li><strong>Tree&#x2F;Graph</strong></li>
</ul>
</li>
<li><strong>排序</strong></li>
<li><strong>查找</strong></li>
<li><strong>算法</strong></li>
</ul>
</blockquote>
<h1 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2 线性表"></a>2 线性表</h1><h2 id="2-1-顺序表（SeqList）"><a href="#2-1-顺序表（SeqList）" class="headerlink" title="2.1 顺序表（SeqList）"></a>2.1 顺序表（SeqList）</h2><p>顺序表通过一组地址连续的空间对数据进行存储。</p>
<h2 id="2-2-单链表（List）"><a href="#2-2-单链表（List）" class="headerlink" title="2.2 单链表（List）"></a>2.2 单链表（List）</h2><p>不要求逻辑上相邻的元素在物理位置上也相邻，因此无法实现随机存取。</p>
<p>分清“谁的谁是谁”。 </p>
<p>操作时要时刻注意<code>last</code>这一项。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120918067.png" alt="image-20231212091813193" style="zoom: 33%;" />

<p><strong>头部插入时易错：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(List *<span class="built_in">list</span>, ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *s = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    assert(s != <span class="literal">NULL</span>);</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="built_in">list</span>-&gt;first-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;first-&gt;next = s;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下图所示，当使用头插法向<code>空list</code>中插入<code>1</code>后，<code>list-&gt;last</code>仍然指向头结点。‘</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915222.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915816.png" alt="2"></p>
<p> 对<code>pop_front</code>进行修改，加入对<code>size</code>的判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">list</span>-&gt;last = s; <span class="comment">// 当list为空时，对last进行移动</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915584.png" alt="3"></p>
<p><strong>头部删除时同理</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_front</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Node *p = <span class="built_in">list</span>-&gt;first-&gt;next;</span><br><span class="line">    <span class="built_in">list</span>-&gt;first-&gt;next = <span class="built_in">list</span>-&gt;first-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">list</span>-&gt;last = <span class="built_in">list</span>-&gt;first;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-静态链表（StaticList）"><a href="#2-3-静态链表（StaticList）" class="headerlink" title="2.3 静态链表（StaticList）"></a>2.3 静态链表（StaticList）</h2><p>使用<strong>静态链表</strong>可以便于在不设<em>指针</em>类型的高级程序设计语言中使用链表结构。</p>
<p>静态链表实际上就是用数组去模拟链表。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915948.png" alt="4" style="zoom: 67%;" />

<p>这里的<code>pool</code>指明下一个备用空间的地址。</p>
<h2 id="2-4-单循环链表（SCList）"><a href="#2-4-单循环链表（SCList）" class="headerlink" title="2.4 单循环链表（SCList）"></a>2.4 单循环链表（SCList）</h2><p>特点：尾节点指向头节点，整个链表形成一个环。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312121129584.png" alt="image-20231212112956184" style="zoom:33%;" />

<p>循环链表的操作和线性链表基本一致,差别仪在于算法中的循环条件不是<code>p</code>或<code>p-&gt;next</code>是否为空，而是它们是否等于头指针。但有的时候，若在循环链表中设立尾指针而不设头指针，可使某些操作简化。例如将两个线性表合并成一个表时，仅需将一个表的表尾和另一个表的表头相接。</p>
<p>初始化时，注意：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>-&gt;first = <span class="built_in">list</span>-&gt;last = s;</span><br><span class="line"><span class="built_in">list</span>-&gt;last-&gt;next = <span class="built_in">list</span>-&gt;first;</span><br><span class="line"><span class="built_in">list</span>-&gt;size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120928507.png" alt="image-20231212092812466"></p>
<p>尾插时的各节点地址：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120954889.png" alt="image-20231212095457800"  />

<p><strong>掌握按值删除这里的的思想：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按值删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_val</span><span class="params">(List *<span class="built_in">list</span>, ElemType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Node *p = find(<span class="built_in">list</span>, key);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;要删除的数据不存在！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p == <span class="built_in">list</span>-&gt;last)</span><br><span class="line">        pop_back(<span class="built_in">list</span>);</span><br><span class="line">    <span class="comment">////////////////////////////////***</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 即不是删除当前节点，而是将下一个节点的值赋值给当前节点，然后删除下一个节点</span></span><br><span class="line">        <span class="comment">// 这样做避免从头遍历链表</span></span><br><span class="line">        Node *q = p-&gt;next;</span><br><span class="line">        p-&gt;data = q-&gt;data;</span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        <span class="built_in">list</span>-&gt;size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">////////////////////////////////***</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>申请节点：Node *s<br>遍历节点：Node *p<br>删除节点：Node *q</p>
</blockquote>
<h2 id="2-5-双向链表（DList）"><a href="#2-5-双向链表（DList）" class="headerlink" title="2.5 双向链表（DList）"></a>2.5 双向链表（DList）</h2><p>每次操作时涉及4个指针：</p>
<ul>
<li>当前节点的前驱；</li>
<li>当前节点的后继；</li>
<li>前一个节点的后继；</li>
<li>后一个节点的前驱。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312131154818.png" alt="image-20231213115430268" style="zoom:33%;" />

<h2 id="2-6-双向循环链表（DCList）"><a href="#2-6-双向循环链表（DCList）" class="headerlink" title="2.6 双向循环链表（DCList）"></a>2.6 双向循环链表（DCList）</h2><p>存在两个环。</p>
<p><strong>环1是<code>list-&gt;last-&gt;next</code></strong></p>
<p><strong>环2是<code>list-&gt;first-&gt;prev</code></strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312140920009.png" alt="image-20231214092024742" style="zoom: 25%;" />

<h1 id="3-栈和队列"><a href="#3-栈和队列" class="headerlink" title="3 栈和队列"></a>3 栈和队列</h1><h2 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h2><p><strong>栈和队列的基本操作是线性表操作的子集，是操作受限的线性表。</strong></p>
<p>栈：限定仅在表尾插入或删除操作的线性表。表尾称为<strong>栈顶</strong>，表头称为<strong>栈底</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312141056107.png" alt="image-20231214105656926" style="zoom: 25%;" />

<h3 id="3-1-1-顺序栈（SeqStack）"><a href="#3-1-1-顺序栈（SeqStack）" class="headerlink" title="3.1.1 顺序栈（SeqStack）"></a>3.1.1 顺序栈（SeqStack）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312141103006.png" alt="image-20231214110346157" style="zoom:25%;" />

<h3 id="3-1-2-链栈（LinkStack）"><a href="#3-1-2-链栈（LinkStack）" class="headerlink" title="3.1.2 链栈（LinkStack）"></a>3.1.2 链栈（LinkStack）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312151207109.png" alt="image-20231215120659701" style="zoom:25%;" />

<h3 id="3-1-3-栈的应用"><a href="#3-1-3-栈的应用" class="headerlink" title="3.1.3 栈的应用"></a>3.1.3 栈的应用</h3><h4 id="1、数制转换"><a href="#1、数制转换" class="headerlink" title="1、数制转换"></a>1、数制转换</h4><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312151258969.png" alt="image-20231215125804838" style="zoom:67%;" />

<p>由于结果要从下往上读取，因此用一个栈来依次存放余数。最终依次取栈顶元素，就可以得到转换后的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;SeqStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数制转换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Convert_8</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqStack st;</span><br><span class="line">    InitStack(&amp;st);</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;st, value%<span class="number">8</span>);</span><br><span class="line">        value /= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Show(&amp;st);</span></span><br><span class="line">    <span class="keyword">while</span> (!(IsEmpty(&amp;st)))</span><br><span class="line">    &#123;</span><br><span class="line">        GetTop(&amp;st, &amp;v);</span><br><span class="line">        Pop(&amp;st);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.数制转换 ElemType int</span></span><br><span class="line">    <span class="type">int</span> value = <span class="number">47183</span>;</span><br><span class="line">    Convert_8(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、括号匹配"><a href="#2、括号匹配" class="headerlink" title="2、括号匹配"></a>2、括号匹配</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 括号匹配</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Check</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqStack st;</span><br><span class="line">    InitStack(&amp;st);</span><br><span class="line">    <span class="type">char</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">&#x27;[&#x27;</span> || *str == <span class="string">&#x27;&#123;&#x27;</span> || *str == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            Push(&amp;st, *str);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetTop(&amp;st, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Pop(&amp;st);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetTop(&amp;st, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Pop(&amp;st);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetTop(&amp;st, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Pop(&amp;st);</span><br><span class="line">        &#125; </span><br><span class="line">        *str++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IsEmpty(&amp;st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2.括号匹配 ElemType char</span></span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;[([][])]&quot;</span>; <span class="comment">// char *str    str是一个指向字符数组的指针</span></span><br><span class="line">    <span class="type">bool</span> flag = Check(str);</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Ok!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、行编辑程序"><a href="#3、行编辑程序" class="headerlink" title="3、行编辑程序"></a>3、行编辑程序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 3.行编辑程序</span></span><br><span class="line">    SeqStack st;</span><br><span class="line">    InitStack(&amp;st);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch != <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(ch !=<span class="string">&#x27;$&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(ch)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    Pop(&amp;st);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">                    Clear(&amp;st);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    Push(&amp;st, ch);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        Print(&amp;st);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    Destroy(&amp;st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-队列（LinkQueue）"><a href="#3-2-队列（LinkQueue）" class="headerlink" title="3.2 队列（LinkQueue）"></a>3.2 队列（LinkQueue）</h2><p>先进先出的结构。</p>
<p>最典型的队列例子是<strong>操作系统中的作业排队</strong>。</p>
<p>队列可分为单端队列和双端队列，但双端队列实际上远不及栈和单端队列有用。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161259625.png" alt="image-20231216125953859" style="zoom: 25%;" />

<h3 id="3-2-1-链队列（LinkQueue）"><a href="#3-2-1-链队列（LinkQueue）" class="headerlink" title="3.2.1 链队列（LinkQueue）"></a>3.2.1 链队列（LinkQueue）</h3><p>由两个分别指向队头和队尾的指针唯一确定一个队列。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161300828.png" alt="image-20231216130008621" style="zoom:20%;" />

<h3 id="3-2-2-顺序队列（SeqQueue）实现循环队列"><a href="#3-2-2-顺序队列（SeqQueue）实现循环队列" class="headerlink" title="3.2.2 顺序队列（SeqQueue）实现循环队列"></a>3.2.2 顺序队列（SeqQueue）实现循环队列</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161300215.png" alt="image-20231216130020025" style="zoom:25%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161300091.png" alt="image-20231216130034444" style="zoom: 33%;" />

<h1 id="4-串"><a href="#4-串" class="headerlink" title="4 串"></a>4 串</h1><p><code>C</code>语言实际上不存在字符串的概念。它是通过相应的字符指针指向一串字符。</p>
<p>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>而在<code>C++</code>中则出现了<code>string</code>类型，它实际上是一个用类实现的数据结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>串的定义：串（<code>string</code>）（或字符串）是由零个或多个字符组成的有限序列。</p>
<p>一般对串的整体进行操作，而不是对其中的单个元素进行操作。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312182049251.png" alt="image-20231218204922589" style="zoom: 25%;" />

<h2 id="4-1-定长顺序存储方式（StackString）"><a href="#4-1-定长顺序存储方式（StackString）" class="headerlink" title="4.1 定长顺序存储方式（StackString）"></a>4.1 定长顺序存储方式（StackString）</h2><p>定长的方式：<strong>先开辟的定长数组</strong>描述字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRLEN 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> u_char unsigned char</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> u_char SString[MAXSTRLEN+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<h2 id="4-2-堆分配存储方式（HeapString）"><a href="#4-2-堆分配存储方式（HeapString）" class="headerlink" title="4.2 堆分配存储方式（HeapString）"></a>4.2 堆分配存储方式（HeapString）</h2><p>仍以一组地址连续的存储单元存放串值字符序列，但其存储空间在程序执行过程中动态分配而得。用<code>malloc()</code>来为新产生的串分配存储空间，并约定串长也作为存储结构的一部分。</p>
<p>函数内部四步：</p>
<ul>
<li>条件判断（不满足条件直接返回）</li>
<li>空间判断（涉及操作的串的空间是否需要赋空，<code>free</code>）</li>
<li>空间分配（给串分配空间，<code>malloc</code>)</li>
<li>赋值操作</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312182049570.png" alt="image-20231218204932225" style="zoom: 33%;" />

<h1 id="5-数组和广义表"><a href="#5-数组和广义表" class="headerlink" title="5 数组和广义表"></a>5 数组和广义表</h1><h2 id="5-1-矩阵的压缩存储（SparseMatrix）"><a href="#5-1-矩阵的压缩存储（SparseMatrix）" class="headerlink" title="5.1 矩阵的压缩存储（SparseMatrix）"></a>5.1 矩阵的压缩存储（SparseMatrix）</h2><p>感兴趣的不是矩阵本身，而是如何存储矩阵的元，使得矩阵进行各项运算。</p>
<p>压缩存储：为多个值相同的元只分配一个存储空间；对零元不分配存储空间。假若值相同的元素或者零元素在矩阵中的分布有一定规律，称为<strong>特殊矩阵</strong>；反之，称为<strong>稀疏矩阵</strong>。</p>
<p><strong>压缩存储时，需要用一个三元组<code>(i,j,aij)</code>唯一确定矩阵A的一个非零元，即除了存储非零元的值<code>aij</code>外，还需要存储其所在行和列的位置<code>(i,j)</code>。</strong></p>
<p>稀疏矩阵的压缩存储示例：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312191547788.png" alt="image-20231219154712437" style="zoom:80%;" />

<h2 id="5-2-矩阵的快速转置算法实现"><a href="#5-2-矩阵的快速转置算法实现" class="headerlink" title="5.2 矩阵的快速转置算法实现"></a>5.2 矩阵的快速转置算法实现</h2><ul>
<li><p>（1）交换矩阵的行列值；</p>
</li>
<li><p>（2）交换三元组中的<code>i</code>和<code>j</code>；</p>
</li>
<li><p><strong>（3）重排三元组之间的次序。—-重点！</strong></p>
<ul>
<li>实现方法1：较为笨拙的重复遍历</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312192015890.png" alt="image-20231219201524473" style="zoom: 33%;" />

<ul>
<li><p>实现方法2：快速转置算法</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312192039855.png" alt="image-20231219203949650" style="zoom: 50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矩阵快速转置（实现方法2）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FastTransposeMatrix</span><span class="params">(SparseMatrix *M, SparseMatrix *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    T-&gt;mu = M-&gt;nu;</span><br><span class="line">    T-&gt;nu = M-&gt;mu;</span><br><span class="line">    T-&gt;tu = M-&gt;tu;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *num = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * M-&gt;nu);  <span class="comment">// M中每一列非零元的个数</span></span><br><span class="line">    assert(num != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">int</span> *cpot = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * M-&gt;nu);  <span class="comment">// M中每一列的第一个非零元对应三元组空间所在位置</span></span><br><span class="line">    assert(cpot != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;tu != <span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 初始化num数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>; col&lt;M-&gt;nu; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            num[col] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>; t&lt;M-&gt;tu; ++t)</span><br><span class="line">        &#123;</span><br><span class="line">            num[M-&gt;data[t].j]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化cpot数组</span></span><br><span class="line">        cpot[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">1</span>; col&lt;M-&gt;nu; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            cpot[col] = cpot[col<span class="number">-1</span>] + num[col<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行转置映射</span></span><br><span class="line">        <span class="type">int</span> col = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> kt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> km=<span class="number">0</span>; km&lt;M-&gt;tu; ++km)</span><br><span class="line">        &#123;</span><br><span class="line">            col = M-&gt;data[km].j;</span><br><span class="line">            kt = cpot[col];</span><br><span class="line">            T-&gt;data[kt].i = M-&gt;data[km].j;</span><br><span class="line">            T-&gt;data[kt].j = M-&gt;data[km].i;</span><br><span class="line">            T-&gt;data[kt].e = M-&gt;data[km].e;</span><br><span class="line">            cpot[col]++; <span class="comment">// 重要步骤</span></span><br><span class="line">            kt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在C中，如果使用了动态内存分配函数如malloc、calloc或realloc来分配内存</span></span><br><span class="line">    <span class="comment">// 那么最终应该使用 free 函数来释放已分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(num);</span><br><span class="line">    <span class="built_in">free</span>(cpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="5-3-广义表（GenList"><a href="#5-3-广义表（GenList" class="headerlink" title="5.3 广义表（GenList)"></a>5.3 广义表（GenList)</h2><blockquote>
<p><strong>所谓的广义表实际上就是一个递归概念。</strong></p>
<p><strong>1、处理tag&#x3D;&#x3D;ATOM的节点；</strong></p>
<p><strong>2、对子表进行递归操作；</strong></p>
<ul>
<li><strong>找到子表中的tag&#x3D;&#x3D;ATOM的节点并处理；</strong></li>
<li><strong>对剩下的节点组成的新的子表重复步骤2，直至子表中不存在节点。</strong></li>
</ul>
</blockquote>
<h3 id="1、含义"><a href="#1、含义" class="headerlink" title="1、含义"></a>1、含义</h3><p>线性表的推广。简单来说就是<strong>表中有表</strong>。</p>
<p>因此，有一个概念要尤其注意，<strong>即广义表是由无数个广义表组成的自身。</strong></p>
<h3 id="2、定义"><a href="#2、定义" class="headerlink" title="2、定义"></a>2、定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LS=(a1,a2,...an)</span><br></pre></td></tr></table></figure>

<p>其中，<code>ai(1&lt;=i&lt;=n)</code>可以是单个元素，也可以是广义表，分别称为<strong>原子</strong>和<strong>子集</strong>。当广义表非空时，<code>a1</code>称为表头（<code>Head</code>），其余元素组成的表<code>(a2,a3,...,an)</code>称为表尾（<code>Tail</code>）。</p>
<p><strong>举例：</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312200930160.png" alt="image-20231220093015065"></p>
<p><strong>注意：</strong>           </p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312200931491.png" alt="image-20231220093159352"></p>
<h3 id="3、存储结构"><a href="#3、存储结构" class="headerlink" title="3、存储结构"></a>3、存储结构</h3><p>由于表中的数据元素可以具有不同结构，因此一般采用<strong>链式存储方式</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312201010034.png" alt="image-20231220101006602" style="zoom: 33%;" />

<h2 id="5-4-表头分割算法"><a href="#5-4-表头分割算法" class="headerlink" title="5.4 表头分割算法"></a>5.4 表头分割算法</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312201628127.png" alt="image-20231220162815397" style="zoom: 33%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建广义表：通过字符串str来创建广义表gl</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateGenList</span><span class="params">(GenList &amp;gl, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(str);  <span class="comment">// 求解字符串长度</span></span><br><span class="line">	<span class="comment">// 存储表内元素</span></span><br><span class="line">	<span class="type">char</span> *sub = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (n<span class="number">-2</span>));</span><br><span class="line">	<span class="comment">// 存储表头</span></span><br><span class="line">	<span class="type">char</span> *hsub = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (n<span class="number">-2</span>));</span><br><span class="line">	assert(sub!=<span class="literal">NULL</span> &amp;&amp; hsub!=<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &quot;1,2,3&quot;</span></span><br><span class="line">	<span class="comment">// 去掉sub左右两边的括号</span></span><br><span class="line">	<span class="built_in">strncpy</span>(sub,str+<span class="number">1</span>,n<span class="number">-2</span>); </span><br><span class="line">	sub[n<span class="number">-2</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//加上结束符</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断广义表是否为空</span></span><br><span class="line">	<span class="keyword">if</span>(gl == <span class="literal">NULL</span>)  <span class="comment">// 为空</span></span><br><span class="line">	&#123;   </span><br><span class="line">		<span class="comment">//  创建头结点(广义表的第一个结点为头结点，其余都为尾结点)</span></span><br><span class="line">		gl = (GLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GLNode));</span><br><span class="line">		assert(gl != <span class="literal">NULL</span>);</span><br><span class="line">		gl-&gt;tag = HEAD;  <span class="comment">// 结点标记为头结点</span></span><br><span class="line">		gl-&gt;hp = gl-&gt;tp = <span class="literal">NULL</span>;  <span class="comment">// 把子表指针和尾指针都指向空</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	GLNode *p = gl;  <span class="comment">// 为了不丢失gl的指向，定义一个指针来操作</span></span><br><span class="line">	<span class="comment">// 求子串长度，当sub长度不为零时，说明广义表还未创建完成</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">strlen</span>(sub) != <span class="number">0</span>)</span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="comment">//  采用尾插法,在后面插入结点</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			1、创建一个结点</span></span><br><span class="line"><span class="comment">			2、让p所指结点的尾指针指向新建的结点</span></span><br><span class="line"><span class="comment">			3、让p指向新建结点</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		p = p-&gt;tp = (GLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GLNode));</span><br><span class="line">		assert(p != <span class="literal">NULL</span>);</span><br><span class="line">		p-&gt;hp = p-&gt;tp = <span class="literal">NULL</span>;  <span class="comment">// 将新建结点的子表指针和尾指针都赋空</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//  &quot;1,2,3&quot;     ==&gt;  &quot;1&quot;      hsub=&quot;1&quot;  sub=&quot;2,3&quot;;</span></span><br><span class="line">		<span class="comment">//  &quot;(1,2),3,4&quot; ==&gt;  &quot;(1,2)&quot;  hsub=&quot;(1,2)&quot; sub=&quot;3,4&quot;</span></span><br><span class="line">		<span class="keyword">if</span>(sever(sub,hsub))  <span class="comment">// sever函数分离表头，并将表头存入hsub中</span></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 对分离出来的表头进行判断，是否包含括号</span></span><br><span class="line">			<span class="keyword">if</span>(hsub[<span class="number">0</span>] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 说明要创建的结点是子表类型</span></span><br><span class="line">				p-&gt;tag = CHILDLIST;  <span class="comment">// 设置子表标记</span></span><br><span class="line">				CreateGenList(p-&gt;hp,hsub);  <span class="comment">// 在p的表头结点处，创建hsub子表</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 说明要创建的结点是原子类型</span></span><br><span class="line">				p-&gt;tag = ATOM;  <span class="comment">// 设置原子标记</span></span><br><span class="line">				p-&gt;atom = atoi(hsub);  <span class="comment">// 将表头字符串转换成整型数据，赋值给原子数据</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广义表表头分割函数，将sub中的表头分割到hsub中</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sever</span><span class="params">(<span class="type">char</span> *sub, <span class="type">char</span> *hsub)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//  判断sub是否为空</span></span><br><span class="line">	<span class="keyword">if</span>(*sub==<span class="string">&#x27;\0&#x27;</span> || <span class="built_in">strcmp</span>(sub,<span class="string">&quot;()&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 是 情况：&quot;&quot;  或  &quot;()&quot;</span></span><br><span class="line">		hsub[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 将hsub赋空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(sub);  <span class="comment">// 求sub的长度</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch = sub[<span class="number">0</span>];  <span class="comment">// 获取第一个字符</span></span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;  <span class="comment">// 表示括号的信息</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        当sub还没遍历完成且还未检测到括号外的逗号，继续遍历</span></span><br><span class="line"><span class="comment">	    注：当检测到括号外的逗号时，说明找到表头分割点，如：&quot;(1,2),3,4&quot; 表头即为(1,2)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;n &amp;&amp; (ch!=<span class="string">&#x27;,&#x27;</span>|| k!=<span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 判断是否运到左括号</span></span><br><span class="line">		<span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">			k++;  <span class="comment">// k++表示进入一层括号</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;)&#x27;</span>)  <span class="comment">// 判断是否遇到右括号</span></span><br><span class="line">			k--;   <span class="comment">// k--表示退出一层括号</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取下一个元素</span></span><br><span class="line">		i++;</span><br><span class="line">		ch = sub[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断是否是因为检测到括号外的逗号而结束的</span></span><br><span class="line">	<span class="keyword">if</span>(i &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 是</span></span><br><span class="line">		<span class="comment">// 在i位置截断，前面部分就是表头</span></span><br><span class="line">		sub[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="comment">// 将取得的表头放入hsub中</span></span><br><span class="line">		<span class="built_in">strcpy</span>(hsub,sub);</span><br><span class="line">		<span class="comment">// 更新sub的值：此时的sub应该去掉表头hsub</span></span><br><span class="line">		<span class="built_in">strcpy</span>(sub,sub+i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(k != <span class="number">0</span>)  <span class="comment">// 判断是否是因为内部括号不匹配</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 是，分割失败</span></span><br><span class="line">	<span class="keyword">else</span>  <span class="comment">// 判断是否是因为i&gt;=n而结束</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 是，情况 &quot;(1,2)&quot;  ==&gt; hsub =&quot;(1,2)&quot;  sub = &quot;&quot;</span></span><br><span class="line">		<span class="comment">// 说明sub整个就是表头</span></span><br><span class="line">		<span class="built_in">strcpy</span>(hsub,sub);  <span class="comment">// 把sub整个赋值给hsub</span></span><br><span class="line">		sub[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// sub赋给hsub后，此时sub为空</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-树和二叉树"><a href="#6-树和二叉树" class="headerlink" title="6 树和二叉树"></a>6 树和二叉树</h1><h2 id="6-1-树及二叉树的概念与性质"><a href="#6-1-树及二叉树的概念与性质" class="headerlink" title="6.1 树及二叉树的概念与性质"></a>6.1 树及二叉树的概念与性质</h2><p><strong>树</strong>：</p>
<ul>
<li><p>结点拥有的子树数称为结点的<strong>度</strong>；</p>
</li>
<li><p>树种结点的最大层次（横向）称为树的<strong>深度****或</strong>高度**；</p>
</li>
<li><p><strong>森林</strong>是<code>m(m&gt;=0)</code>棵互不相交的树的集合。</p>
</li>
</ul>
<p><strong>二叉树</strong></p>
<ul>
<li><p>每个结点至多只有两颗子树，且有左右之分；</p>
<ul>
<li><strong>性质1：</strong>第<code>i</code>层（层次）至多有<code>2^(i-1)</code>个结点；</li>
<li><strong>性质2：</strong>深度为<code>k</code>的二叉树至多有<code>2^k-1</code>个结点；</li>
<li><strong>性质3：</strong>对任何一棵二叉树<code>T</code>，其终端结点数为<code>n0</code>，度为<code>2</code>的结点数为<code>n2</code>，则<code>n0=n2+1</code>；</li>
</ul>
</li>
<li><p>满二叉树：所有结点（除叶子结点外）均有左右分支；</p>
</li>
<li><p>完全二叉树：基于满二叉树实现，<em><strong>性质4&#x2F;5代表从<code>1</code>开始编号的情况。</strong></em></p>
<ul>
<li><strong>性质4：</strong>具有<code>n</code>个结点的<strong>完全二叉树</strong>的深度为<code>[log2n]+1</code>(<code>&quot;[]&quot;</code>表示向下取整)；</li>
<li><strong>性质5：</strong>对一棵有<code>n</code>个结点的<strong>完全二叉树</strong>的结点按层序编号，对任一结点<code>i(1&lt;=i&lt;=n)</code>：<ul>
<li><strong>（1）</strong>若<code>i=1</code>，则结点i是二叉树的根，无双亲；若<code>i&gt;1</code>，则其双亲<code>PARENT(i)</code>是结点<code>[i/2]</code>；</li>
<li><strong>（2）</strong>若<code>2i&gt;n</code>，则结点<code>i</code>无左孩子；否则左孩子是<code>2i</code>；</li>
<li><strong>（3）</strong>若<code>2i+1&gt;n</code>，则结点<code>i</code>无右孩子；否则右孩子是<code>2i+1</code>；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-2-二叉树的链式存储方式（二叉链表，BinTree）"><a href="#6-2-二叉树的链式存储方式（二叉链表，BinTree）" class="headerlink" title="6.2 二叉树的链式存储方式（二叉链表，BinTree）"></a>6.2 二叉树的链式存储方式（二叉链表，BinTree）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType BinTreeNode*</span></span><br></pre></td></tr></table></figure>

<h2 id="6-3-二叉树的非递归遍历"><a href="#6-3-二叉树的非递归遍历" class="headerlink" title="6.3 二叉树的非递归遍历"></a>6.3 二叉树的非递归遍历</h2><p>用<strong>栈</strong>实现。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221544737.png" alt="image-20231222154427982"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221544992.png" alt="image-20231222154440257"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221544658.png" alt="image-20231222154447677"></p>
<h2 id="6-4-二叉树的恢复实现"><a href="#6-4-二叉树的恢复实现" class="headerlink" title="6.4 二叉树的恢复实现"></a>6.4 二叉树的恢复实现</h2><p>两个概念：二叉树的<strong>相似</strong>和<strong>等价</strong>。</p>
<ul>
<li>相似：形状相同，内容不同</li>
<li>等价：形状和内容均相同。</li>
</ul>
<p>二叉树的计数问题：讨论具有<code>n</code>个结点、互不相似的二叉树的数目<code>b</code>。</p>
<p>含有<code>n</code>个结点的不相似的二叉树有：<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221413095.png" alt="image-20231222141353060" style="zoom: 50%;" />棵。</p>
<blockquote>
<p>1、前序+中序唯一恢复一棵二叉树。</p>
<p>2、中序+后序唯一恢复一棵二叉树。</p>
<p>注意：<strong>恢复二叉树时一定要有中序存在</strong>，因为通过中序遍历可以得知这棵二叉树的左右分布。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序+中序恢复二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_5</span><span class="params">(BinTree *bt, <span class="type">char</span> *VLR, <span class="type">char</span>*LVR, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    CreateBinTree_5(bt-&gt;root, VLR, LVR, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_5</span><span class="params">(BinTreeNode *&amp;t, <span class="type">char</span> *VLR, <span class="type">char</span>*LVR, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(VLR[<span class="number">0</span>] != LVR[k])</span><br><span class="line">            k++;</span><br><span class="line"></span><br><span class="line">        t = (BinTreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTreeNode));</span><br><span class="line">        assert(t != <span class="literal">NULL</span>);</span><br><span class="line">        t-&gt;data = LVR[k];</span><br><span class="line"></span><br><span class="line">        CreateBinTree_5(t-&gt;leftChild, VLR+<span class="number">1</span>, LVR, k);</span><br><span class="line">        CreateBinTree_5(t-&gt;rightChild, VLR+k+<span class="number">1</span>, LVR+k+<span class="number">1</span>, n-k<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序+后序恢复二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_6</span><span class="params">(BinTree *bt, <span class="type">char</span> *LVR, <span class="type">char</span>*LRV, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    CreateBinTree_6(bt-&gt;root, LVR, LRV, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_6</span><span class="params">(BinTreeNode *&amp;t, <span class="type">char</span> *LVR, <span class="type">char</span>*LRV, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(LRV[n<span class="number">-1</span>] != LVR[k])</span><br><span class="line">            k++;</span><br><span class="line">        </span><br><span class="line">        t = (BinTreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTreeNode));</span><br><span class="line">        assert(t != <span class="literal">NULL</span>);</span><br><span class="line">        t-&gt;data = LVR[k];</span><br><span class="line"></span><br><span class="line">        CreateBinTree_6(t-&gt;rightChild, LVR+k+<span class="number">1</span>, LRV+k, n-k<span class="number">-1</span>);</span><br><span class="line">        CreateBinTree_6(t-&gt;leftChild, LVR, LRV, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-5-线索二叉树"><a href="#6-5-线索二叉树" class="headerlink" title="6.5 线索二叉树"></a>6.5 线索二叉树</h2><blockquote>
<p>同时保存节点的<strong>前驱和后继</strong>信息。由于<code>n</code>个结点必然存在<code>n+1</code>个空链，实际上并未完全保存所有的前驱后继信息，而只是利用了这<code>n+1</code>个空链。</p>
</blockquote>
<p>举例：对下面这棵二叉树按照中序遍历线索化</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312232026443.png" alt="image-20231223202641174"></p>
<h2 id="6-6-树和森林"><a href="#6-6-树和森林" class="headerlink" title="6.6 树和森林"></a>6.6 树和森林</h2><p>讨论树的表示及其遍历操作，并建立森林与二叉树的对应关系。</p>
<p>注意这里的树<em>不局限于二叉树</em>。</p>
<h3 id="1、双亲表示法（仅了解即可）"><a href="#1、双亲表示法（仅了解即可）" class="headerlink" title="1、双亲表示法（仅了解即可）"></a>1、双亲表示法（仅了解即可）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241441068.png" alt="image-20231224144144837" style="zoom: 80%;" />

<p><strong>缺点</strong>：求父结点很方便，但求孩子结点时需要遍历整个结构。</p>
<h3 id="2、孩子表示法（仅了解即可）"><a href="#2、孩子表示法（仅了解即可）" class="headerlink" title="2、孩子表示法（仅了解即可）"></a>2、孩子表示法（仅了解即可）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241517749.png" alt="image-20231224151751633"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241518866.png" alt="image-20231224151800720"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241517901.png" alt="image-20231224151730578"></p>
<h3 id="3、孩子兄弟表示法（重要）"><a href="#3、孩子兄弟表示法（重要）" class="headerlink" title="3、孩子兄弟表示法（重要）"></a>3、孩子兄弟表示法（重要）</h3><p>又称二叉树表示法或二叉链表表示法。即以二叉链表作为树的存储结构。</p>
<p>链表中结点的两个链域分别指向该结点的第一个<strong>孩子结点</strong>和下一个<strong>兄弟结点</strong>。<em>（即左孩子，右兄弟）</em></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241541154.png" alt="image-20231224154137327" style="zoom: 33%;" />

<p>对其进行遍历可得：</p>
<p>（1）先序遍历<strong>（先访问根，再依次访问根的每棵子树）</strong>：<code>A B C D E</code></p>
<p>（2）后序遍历<strong>（先依次访问根的每棵子树，再访问根）</strong>：<code>B D C E A</code></p>
<p><strong>树不包含中序遍历！</strong></p>
<h3 id="4、森林和二叉树的转换"><a href="#4、森林和二叉树的转换" class="headerlink" title="4、森林和二叉树的转换"></a>4、森林和二叉树的转换</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241530772.png" alt="image-20231224153024529" style="zoom: 67%;" />

<p>上图依然遵循“左孩子右兄弟”的概念。当三棵树的树根相连时，树根结点之间的关系即为“兄弟”的关系。</p>
<p>对其进行遍历可得：</p>
<p>（1）先序遍历：<code>A B C D E F G H I J</code></p>
<ul>
<li>访问第一棵树的根结点；</li>
<li>先序遍历第一棵树的根结点的子树森林；</li>
<li>先序遍历除去第一棵树之后剩余的树构成的森林。</li>
</ul>
<p>（2）中序遍历：<code>B C D A F E H J I G</code></p>
<ul>
<li>中序遍历森林中第一棵树的根结点的子树森林；</li>
<li>访问第一棵树的根结点；</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林。</li>
</ul>
<blockquote>
<p>对比图6.15和图6.17可以发现，若以二叉链表的形式表示时：</p>
<ul>
<li>如果仅包含左孩子，则为一棵树的二叉链表表示；</li>
<li>否则，则是森林的二叉链表表示。</li>
</ul>
</blockquote>
<h3 id="5、在树中查找父结点和在二叉树中查找父结点"><a href="#5、在树中查找父结点和在二叉树中查找父结点" class="headerlink" title="5、在树中查找父结点和在二叉树中查找父结点"></a>5、在树中查找父结点和在二叉树中查找父结点</h3><h4 id="（1）在树中查找父结点"><a href="#（1）在树中查找父结点" class="headerlink" title="（1）在树中查找父结点"></a>（1）在树中查找父结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找父结点</span></span><br><span class="line">TreeNode* <span class="title function_">Parent</span><span class="params">(Tree *tree, TreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Parent(tree-&gt;root, p);</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* <span class="title function_">Parent</span><span class="params">(TreeNode *t, TreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span> || p == <span class="literal">NULL</span> || p == t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode *q = t-&gt;firstChild;</span><br><span class="line">    TreeNode *parent;</span><br><span class="line">    <span class="keyword">while</span>(q != <span class="literal">NULL</span> &amp;&amp; q != p)</span><br><span class="line">    &#123;</span><br><span class="line">        parent = Parent(q, p);  <span class="comment">// 在第一个孩子结点中查找parent结点</span></span><br><span class="line">        <span class="keyword">if</span>(parent != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        q = q-&gt;nextSilbing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(q != <span class="literal">NULL</span> &amp;&amp; q == p)  <span class="comment">// q(t-&gt;firstChild)==p说明要查找的结点p的父结点即为t</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241742171.png" alt="image-20231224174224376" style="zoom: 33%;" />

<h4 id="（2）在二叉树中查找父结点"><a href="#（2）在二叉树中查找父结点" class="headerlink" title="（2）在二叉树中查找父结点"></a>（2）在二叉树中查找父结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找父节点</span></span><br><span class="line">BinTreeNode* <span class="title function_">Parent</span><span class="params">(BinTree *bt, BinTreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Parent(bt-&gt;root, p);</span><br><span class="line">&#125;</span><br><span class="line">BinTreeNode* <span class="title function_">Parent</span><span class="params">(BinTreeNode *t, BinTreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span> || p == <span class="literal">NULL</span>)  <span class="comment">// 树为空或查找的节点为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">if</span>(t-&gt;leftChild == p || t-&gt;leftChild == p)</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    </span><br><span class="line">    BinTreeNode *q = Parent(t-&gt;leftChild, p);</span><br><span class="line">    <span class="keyword">if</span>(q != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    <span class="keyword">return</span> Parent(t-&gt;rightChild, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-图"><a href="#7-图" class="headerlink" title="7 图"></a>7 图</h1><h2 id="7-1-图的定义与概念"><a href="#7-1-图的定义与概念" class="headerlink" title="7.1 图的定义与概念"></a>7.1 图的定义与概念</h2><p>图中的数据元素称为<strong>顶点</strong>(<code>Vertex</code>)，<code>V</code>是顶点的有穷非空集合。<code>E</code>是两个顶点之间的集合。</p>
<ul>
<li><p><code>&lt;v, w&gt;</code>：从顶点<code>v</code>到顶点<code>w</code>的有向边；</p>
</li>
<li><p><code>(v, w)</code>：从顶点<code>v</code>到顶点<code>w</code>的无向边。</p>
</li>
</ul>
<p>图中共<code>n</code>个顶点，此时：</p>
<ul>
<li>对无向图来说边的个数范围为<code>0~1/2(n(n-1))</code>，当有<code>1/2(n(n-1)</code>条边时为<strong>无向完全图</strong>。</li>
<li>对有向图来说边的个数范围为<code>0~n(n-1)</code>，当有<code>n(n-1)</code>条边时为<strong>有向完全图</strong>。</li>
</ul>
<p>图（<code>Graph</code>）与子图（<code>Subgraph</code>）</p>
<p>权（<code>Weight</code>）</p>
<p>邻接点</p>
<p>顶点<code>v</code>的度（<code>Degree</code>）是和<code>v</code>相关联的边的数目。在有向图中还要分<strong>入度</strong>和<strong>出度</strong>。</p>
<p>从顶点<code>v</code>到顶点<code>v&#39;</code>的路径（<code>Path</code>）是一个顶点序列。路径的长度是路径上的边或弧的数目。第一个顶点和最后一个顶点相同的路径称为回路或环（<code>Cycle</code>）。在无向图<code>G</code>中，若从顶点<code>v</code>到顶点<code>v&#39;</code>有路径，则称<code>v</code>和<code>v&#39;</code>是连通的。若图中任意两个顶点都是连通的，则称<code>G</code>为<strong>连通图</strong>。而<strong>连通分量</strong>（<code>Connected Component</code>）是指无向图中的<strong>极大连通子图</strong>。</p>
<p>一个连通图的<strong>生成树</strong>是一个极小连通子图。如果在一棵生成树上添加一条边，必定形成一个环。</p>
<h2 id="7-2-图的存储方式"><a href="#7-2-图的存储方式" class="headerlink" title="7.2 图的存储方式"></a>7.2 图的存储方式</h2><h3 id="1、邻接矩阵表示方式（数组形式，重要）"><a href="#1、邻接矩阵表示方式（数组形式，重要）" class="headerlink" title="1、邻接矩阵表示方式（数组形式，重要）"></a>1、邻接矩阵表示方式（数组形式，重要）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251216684.png" alt="image-20231225121641478" style="zoom: 25%;" />

<p>两个数组分别存储数据元素（顶点）的信息和数据元素之间的关系（边或弧）的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Default_Vertex_Size 10  <span class="comment">// 默认顶点数大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T char</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphMtx</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span>   MaxVertices;    <span class="comment">// 最大顶点数，即容量</span></span><br><span class="line">    <span class="type">int</span>   NumVertices;    <span class="comment">// 当前顶点数，即真实大小</span></span><br><span class="line">    <span class="type">int</span>   NumEdges;       <span class="comment">// 当前边数</span></span><br><span class="line"></span><br><span class="line">    T    *VerticesList;   <span class="comment">// 顶点列表</span></span><br><span class="line">    <span class="type">int</span> **Edge;           <span class="comment">// 指向邻接矩阵，二维数组</span></span><br><span class="line">    <span class="comment">// 一维数组：指向每一行，即每个顶点和其他顶点的边的连接</span></span><br><span class="line">    <span class="comment">// 二维数组：指向每一列，即当前图包含的所有顶点</span></span><br><span class="line"></span><br><span class="line">&#125;GraphMtx;</span><br></pre></td></tr></table></figure>

<h3 id="2、邻接表表示方式（链表形式，重要）"><a href="#2、邻接表表示方式（链表形式，重要）" class="headerlink" title="2、邻接表表示方式（链表形式，重要）"></a>2、邻接表表示方式（链表形式，重要）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Dafault_Vertex_Size 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 边结构。1）保存顶点的位置信息；2）指向下一个顶点的位置信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> dest;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点结构。包含1）顶点的信息；2）指向的边的信息。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T data;</span><br><span class="line">    Edge *adj;</span><br><span class="line">&#125;Vertex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphLink</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> MaxVertices;</span><br><span class="line">    <span class="type">int</span> NumVertices;</span><br><span class="line">    <span class="type">int</span> NumEdges;</span><br><span class="line"></span><br><span class="line">    Vertex *NodeTable;  <span class="comment">// 存放顶点的“List”</span></span><br><span class="line">&#125;GraphLink;</span><br></pre></td></tr></table></figure>

<p>最重要也是最复杂的函数：删除顶点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除顶点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RemoveVertex</span><span class="params">(GraphLink *g, T vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v = GetVertexPos(g, vertex);</span><br><span class="line">    <span class="comment">// 顶点v不存在，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(v == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除顶点：用最后一个顶点的值覆盖要删除的顶点</span></span><br><span class="line">    <span class="comment">// 删除边：直接调用函数RemoveEdge</span></span><br><span class="line"></span><br><span class="line">    Edge *p = g-&gt;NodeTable[v].adj;  <span class="comment">// p指向要删除结点v的边链表</span></span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    Edge *t = <span class="literal">NULL</span>;  <span class="comment">// s的前驱t，注意一定要先赋值为NULL</span></span><br><span class="line">    Edge *s;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        k = p-&gt;dest;  <span class="comment">// 在释放边之前要先获取和这个顶点有关的顶点的位置信息</span></span><br><span class="line">        s = g-&gt;NodeTable[k].adj;  <span class="comment">// s指向和v相连的第一个顶点的边链表</span></span><br><span class="line">        <span class="keyword">while</span>(s != <span class="literal">NULL</span> &amp;&amp; s-&gt;dest != v)</span><br><span class="line">        &#123;</span><br><span class="line">            t = s;</span><br><span class="line">            s = s-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="literal">NULL</span>) </span><br><span class="line">                g-&gt;NodeTable[k].adj = s-&gt;link;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t-&gt;link = s-&gt;link;</span><br><span class="line">            <span class="built_in">free</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放当前结点</span></span><br><span class="line">        g-&gt;NodeTable[v].adj = p-&gt;link;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="comment">// p指向下一个结点，执行下一次删除</span></span><br><span class="line">        p = g-&gt;NodeTable[v].adj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g-&gt;NumVertices--;</span><br><span class="line">    <span class="comment">// 用最后一个结点vl覆盖要删除的结点v</span></span><br><span class="line">    g-&gt;NodeTable[v].data = g-&gt;NodeTable[g-&gt;NumVertices].data;</span><br><span class="line">    g-&gt;NodeTable[v].adj = g-&gt;NodeTable[g-&gt;NumVertices].adj;</span><br><span class="line">    <span class="comment">// 由于此时vl的下标改变，因此遍历vl的边，对应修改和vl相连的顶点，其指向vl的边的下标位置</span></span><br><span class="line">    s = g-&gt;NodeTable[v].adj;</span><br><span class="line">    <span class="keyword">while</span>(s != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        k = s-&gt;dest;</span><br><span class="line">        p = g-&gt;NodeTable[k].adj;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;dest == g-&gt;NumVertices)  <span class="comment">// 找到了指向vl的边</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;dest = v;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、十字链表（仅了解即可）"><a href="#3、十字链表（仅了解即可）" class="headerlink" title="3、十字链表（仅了解即可）"></a>3、十字链表（仅了解即可）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312261148808.png" alt="image-20231226114811489" style="zoom:50%;" />

<h3 id="4、多重邻接表（仅了解即可）"><a href="#4、多重邻接表（仅了解即可）" class="headerlink" title="4、多重邻接表（仅了解即可）"></a>4、多重邻接表（仅了解即可）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312261256940.png" alt="image-20231226125619799" style="zoom: 50%;" />

<h3 id="5、四种存储结构的对比"><a href="#5、四种存储结构的对比" class="headerlink" title="5、四种存储结构的对比"></a>5、四种存储结构的对比</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312261300229.png" alt="image-20231226130055141" style="zoom: 25%;" />

<h2 id="7-3-图的两种遍历方式"><a href="#7-3-图的两种遍历方式" class="headerlink" title="7.3 图的两种遍历方式"></a>7.3 图的两种遍历方式</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312281111625.png" alt="image-20231228111115955" style="zoom:25%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphLink *g, T vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    <span class="type">bool</span> *visited = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * n);  <span class="comment">// visited数组指明当前顶点是否被访问过</span></span><br><span class="line">    assert(visited != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v = GetVertexPos(g, vertex);</span><br><span class="line">    <span class="keyword">if</span>(v == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    DFS(g, v, visited);</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphLink *g, <span class="type">int</span> v, <span class="type">bool</span> visited[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 顶点A对应的位置为A</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;&quot;</span>, GetVertexValue(g, v));</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问顶点A的邻接点</span></span><br><span class="line">    <span class="type">int</span> w = GetFirstNeighbor(g, GetVertexValue(g, v));</span><br><span class="line">    <span class="keyword">while</span>(w != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 深度遍历</span></span><br><span class="line">        <span class="comment">// 递归访问和当前邻接点相连的邻接点</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[w])</span><br><span class="line">            DFS(g, w, visited);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归访问A的其他邻接点</span></span><br><span class="line">        <span class="comment">// 类似于链表中的 w = w-&gt;next;</span></span><br><span class="line">        w = GetNextNeighbor(g, GetVertexValue(g, v), GetVertexValue(g, w));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 广度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(GraphLink *g, T vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    <span class="type">bool</span> *visited = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * n);  <span class="comment">// visited数组指明当前顶点是否被访问过</span></span><br><span class="line">    assert(visited != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> v = GetVertexPos(g, vertex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;&quot;</span>, GetVertexValue(g, v));</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line"></span><br><span class="line">    EnQueue(&amp;Q, v);</span><br><span class="line">    <span class="keyword">while</span>(!EmptyQueue(&amp;Q))</span><br><span class="line">    &#123;</span><br><span class="line">        GetHead(&amp;Q, &amp;v);</span><br><span class="line">        DeQueue(&amp;Q);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> w = GetFirstNeighbor(g, GetVertexValue(g, v));</span><br><span class="line">        <span class="keyword">while</span>(w != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;&quot;</span>, GetVertexValue(g, w));</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                EnQueue(&amp;Q, w);</span><br><span class="line">            &#125;</span><br><span class="line">            w = GetNextNeighbor(g, GetVertexValue(g, v), GetVertexValue(g, w));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-4-图的连通性问题"><a href="#7-4-图的连通性问题" class="headerlink" title="7.4 图的连通性问题"></a>7.4 图的连通性问题</h2><p><strong>连通图：任意顶点间都有路径可以相互到达。</strong></p>
<p>对于无向图来说，若图连通，则采用<code>DFS/BFS</code>即可遍历整张图。</p>
<h3 id="1、非连通图遍历"><a href="#1、非连通图遍历" class="headerlink" title="1、非连通图遍历"></a>1、非连通图遍历</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312281110107.png" alt="image-20231228111031643" style="zoom: 25%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非连通图遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Components</span><span class="params">(GraphLink *g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    <span class="type">bool</span> *visited = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * n);  <span class="comment">// visited数组指明当前顶点是否被访问过</span></span><br><span class="line">    assert(visited != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            DFS(g, i, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、最小生成树（Minimum-Spanning-Tree-MST）"><a href="#2、最小生成树（Minimum-Spanning-Tree-MST）" class="headerlink" title="2、最小生成树（Minimum Spanning Tree, MST）"></a>2、最小生成树（Minimum Spanning Tree, MST）</h3><p>对于<code>n</code>个顶点，通过<code>n-1</code>条边进行连接，找到加权和最小的图。</p>
<h4 id="（1）Prim算法"><a href="#（1）Prim算法" class="headerlink" title="（1）Prim算法"></a>（1）<code>Prim</code>算法</h4><p>先找一条权值最小的边，然后从这两个顶点出发，依次找和这两个顶点连接的边中权值较小的，逐步扩散。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312281115869.png" alt="image-20231228111509756" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401030936983.png" alt="image-20240103093658857" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401030937827.png" alt="image-20240103093711759" style="zoom:67%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最小生成树_Prim算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MinSpanTree_Prim</span><span class="params">(GraphMtx *g, T vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;  <span class="comment">// 计算顶点个数</span></span><br><span class="line">    E *lowcost = (E*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E)*n);  <span class="comment">// lowcost[n]，最小花费的数组</span></span><br><span class="line">    <span class="type">int</span> *mst = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*n);  <span class="comment">// mst[n]，最小花费的起始顶点的数组</span></span><br><span class="line">    assert(lowcost != <span class="literal">NULL</span> &amp;&amp; mst != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、初始化lowcost</span></span><br><span class="line">    <span class="type">int</span> k = GetVertexPos(g, vertex);  <span class="comment">// 获取vertex的位置，作为初始的起始顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != k)</span><br><span class="line">        &#123;</span><br><span class="line">            lowcost[i] = GetWeight(g, k, i);  <span class="comment">// 获取从k到i的边的权重，lowcost[i]中i为终点顶点</span></span><br><span class="line">            mst[i] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            lowcost[i] = <span class="number">0</span>;  <span class="comment">// lowcost[i]=0 ==&gt; 顶点i属于MST的顶点集合</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、从初始起始顶点出发，寻找最小代价的边值</span></span><br><span class="line">    <span class="type">int</span> min, min_index;</span><br><span class="line">    <span class="type">int</span> begin, end;</span><br><span class="line">    E cost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历找到需要的n-1条边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)  <span class="comment">// n-1 ==&gt; n个顶点最多n-1条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        min = MAX_COST;</span><br><span class="line">        min_index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// （1）经过n次遍历，找到从vertex出发的一条权值最小的路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j]&lt;min)  </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// lowcost[j] != 0 ==&gt; 说明顶点j还未加入MST的顶点集合</span></span><br><span class="line">                min = lowcost[j];</span><br><span class="line">                min_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        begin = mst[min_index];</span><br><span class="line">        end = min_index;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;%c : %d\n&quot;</span>, g-&gt;VerticesList[begin], g-&gt;VerticesList[end], min);</span><br><span class="line">        </span><br><span class="line">        lowcost[min_index] = <span class="number">0</span>;  <span class="comment">// 将minx_index所代表的顶点加入MST顶点集合中，后续不再进行考虑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// （2）加入新顶点后，更新此时的lowcost和mst数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cost = GetWeight(g, min_index, j);</span><br><span class="line">            <span class="keyword">if</span>(cost &lt; lowcost[j])</span><br><span class="line">            &#123;</span><br><span class="line">                lowcost[j] = cost;  <span class="comment">// 顶点j到min_index对应顶点的权值比到之前保存的权值更小，因此更新权值</span></span><br><span class="line">                mst[j] = min_index;  <span class="comment">// 更新此时顶点j所对应的起始顶点为min_index对应顶点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（2）Kruskal算法"><a href="#（2）Kruskal算法" class="headerlink" title="（2）Kruskal算法"></a>（2）<code>Kruskal</code>算法</h4><p>每次找权值最小的边，但不关心此时顶点是否已与其他顶点相连。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312281115942.png" alt="image-20231228111533837" style="zoom:80%;" />

<p><strong>关键点：判断新加入的边是否可已有的边属于同一个连通子图。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断i和j是否处于同一连通子图</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_Same</span><span class="params">(<span class="type">int</span> *father, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从当前节点i开始层层追踪，直到找到其最后的父节点</span></span><br><span class="line">    <span class="comment">// father[i]==i说明i自己是一个单独的存在，没有和它连通的顶点</span></span><br><span class="line">    <span class="keyword">while</span>(father[i] != i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 否则，找到和它连通的顶点，并且层层寻找，直到找到最后一个不和其他顶点相连的顶点</span></span><br><span class="line">        <span class="comment">// 这样就追溯到了他的根节点</span></span><br><span class="line">        i = father[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(father[j] != j)</span><br><span class="line">    &#123;</span><br><span class="line">        j = father[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i==j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将i和j标记为相同集合</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mark_Same</span><span class="params">(<span class="type">int</span> *father, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(father[i] != i)</span><br><span class="line">    &#123;</span><br><span class="line">        i = father[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(father[j] != j)</span><br><span class="line">    &#123;</span><br><span class="line">        j = father[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    father[j] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MinSpanTree_Kruskal</span><span class="params">(GraphMtx *g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    Edge *edge = (Edge*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Edge) * (n*(n<span class="number">-1</span>)/<span class="number">2</span>));</span><br><span class="line">    assert(edge != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化edge结构</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查找邻接矩阵的上三角矩阵，避免重复查找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 顶点间的边存在时，初始化edge结构体</span></span><br><span class="line">            <span class="keyword">if</span>(g-&gt;Edge[i][j] != <span class="number">0</span> &amp;&amp; g-&gt;Edge[i][j] != MAX_COST)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[k].x = i;</span><br><span class="line">                edge[k].y = j;</span><br><span class="line">                edge[k].cost = g-&gt;Edge[i][j];</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;k; ++i)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     v1 = edge[i].x;</span></span><br><span class="line">    <span class="comment">//     v2 = edge[i].y;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%c--&gt;%c : %d\n&quot;, g-&gt;VerticesList[v1], g-&gt;VerticesList[v2], edge[i].cost);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将边按照权值升序排序</span></span><br><span class="line">    qsort(edge, k, <span class="keyword">sizeof</span>(Edge), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法核心，判断新加入的边是否可已有的边属于同一个连通子图</span></span><br><span class="line">    <span class="type">int</span> *father = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) *n);</span><br><span class="line">    assert(father != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i] = i;  <span class="comment">// 初始化i的父节点为i自己</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当x与y的父节点不为同一个父节点时，进行连接</span></span><br><span class="line">        <span class="keyword">if</span>(!Is_Same(father, edge[i].x, edge[i].y))</span><br><span class="line">        &#123;</span><br><span class="line">            v1 = edge[i].x;</span><br><span class="line">            v2 = edge[i].y;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;%c : %d\n&quot;</span>, g-&gt;VerticesList[v1], g-&gt;VerticesList[v2], edge[i].cost);</span><br><span class="line">            Mark_Same(father, edge[i].x, edge[i].y);  <span class="comment">// 连接x和y后，将其标记为Same，合并为一个整体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一般来说，两个算法得到的最小生成树唯一。权值相同时可能形状存在差异，但加权和一定一致。</strong></p>
<h2 id="7-5-有向无环图（Directed-Acyclic-Graph-DAG）"><a href="#7-5-有向无环图（Directed-Acyclic-Graph-DAG）" class="headerlink" title="7.5 有向无环图（Directed Acyclic Graph, DAG）"></a>7.5 有向无环图（Directed Acyclic Graph, DAG）</h2><p><code>DAG</code>图是描述含有公共子式的表达式的有效工具。</p>
<ul>
<li><p><code>AOV（Activity On Vertex）</code>：以顶点为活动的网络图</p>
</li>
<li><p><code>AOE（Activity On Edge）</code>：以边为活动的网络图</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401071525659.png" alt="image-20240107152528272"></p>
<h3 id="1、拓扑排序（Topological-Sort）"><a href="#1、拓扑排序（Topological-Sort）" class="headerlink" title="1、拓扑排序（Topological Sort）"></a>1、拓扑排序（<code>Topological Sort</code>）</h3><p><strong>定义</strong>：由某个集合上的一个偏序得到该集合上的一个全序，这个操作称为拓扑排序。（<code>AOV</code>）</p>
<blockquote>
<p><strong>步骤：</strong></p>
<p><strong>s1、先找到一个没有入度的顶点，放入排序中；</strong></p>
<p><strong>s2、删除该顶点和与其相关的边，此时各顶点的入度改变；</strong></p>
<p><strong>s3、重复s1和s2，直至不存在顶点未被排序。</strong></p>
</blockquote>
<p><strong>关键实现</strong>：</p>
<ul>
<li>建立一个栈结构，保存顶点及其入度相关的信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TopologicalSort</span><span class="params">(GraphLink *g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;  <span class="comment">// 顶点个数</span></span><br><span class="line">    <span class="type">int</span> *count = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*n);  <span class="comment">// 初始化count数组，存储顶点及其入度信息</span></span><br><span class="line">    assert(count != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        count[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计入度信息</span></span><br><span class="line">    Edge *p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = g-&gt;NodeTable[i].adj;  <span class="comment">// p指向存放当前顶点边信息的邻接表</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count[p-&gt;dest]++;  <span class="comment">// 在count数组中，对应有入度的顶点位置++</span></span><br><span class="line">            p = p-&gt;link;  <span class="comment">// p指向下一个顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;n; ++i)</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\n&quot;, count[i]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历count，找到所有入度为0的顶点，并存入栈中</span></span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;  <span class="comment">// 所谓的“栈顶指针”</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若该顶点入度为0</span></span><br><span class="line">        <span class="keyword">if</span>(count[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 模拟入栈</span></span><br><span class="line">            count[i] = top;  <span class="comment">// count[i]保存了上一个入度为0的顶点的下标   </span></span><br><span class="line">            top = i;  <span class="comment">// top指向顶点i（即入度为0的栈顶元素）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v, w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(top == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;网络中有回路，无法进行拓扑排序！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 模拟出栈</span></span><br><span class="line">            v = top;  <span class="comment">// v指向栈顶元素（即此时度为0的顶点）</span></span><br><span class="line">            top = count[top];  <span class="comment">// 相当于出栈顶点v的操作</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;&quot;</span>, g-&gt;NodeTable[v]);</span><br><span class="line">            <span class="comment">// 求解v的邻接顶点</span></span><br><span class="line">            w = GetFirstNeighbor(g, g-&gt;NodeTable[v].data);</span><br><span class="line">            <span class="keyword">while</span>(w != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 删去对应的边后若入度为0，则对顶点w进行入栈操作</span></span><br><span class="line">                <span class="keyword">if</span>(--count[w] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 入栈</span></span><br><span class="line">                    count[w] = top;</span><br><span class="line">                    top = w;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则不进行入栈操作，寻找下一个邻接顶点</span></span><br><span class="line">                w = GetNextNeighbor(g, g-&gt;NodeTable[v].data, g-&gt;NodeTable[w].data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Nul.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、关键路径求解（Critical-Path）"><a href="#2、关键路径求解（Critical-Path）" class="headerlink" title="2、关键路径求解（Critical Path）"></a>2、关键路径求解（Critical Path）</h3><p><strong>定义</strong>：由于在<code>AOE</code>网中有些活动可以并行地进行，所以完成工程的最短时间是从开始点到完成点的最长路径的长度，路径长度最长的路径叫做关键路径。（这里的路径长度指路径上各活动的持续时间之和）</p>
<blockquote>
<p><strong>步骤：</strong></p>
<p><strong>s1、先正向求解每个顶点的最早开始时间；</strong></p>
<p><strong>s2、再反向求解每个顶点的最晚开始时间。</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求解关键路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CriticalPath</span><span class="params">(GraphMtx *g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    <span class="type">int</span> *ve = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    <span class="type">int</span> *vl = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    assert(ve != <span class="literal">NULL</span> &amp;&amp; vl != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ve[i] = <span class="number">0</span>;</span><br><span class="line">        vl[i] = MAX_COST;  <span class="comment">// 此处不能初始化为0，否则求解vl时会出现负数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正向求解每个顶点的最早开始时间，ve</span></span><br><span class="line">    <span class="comment">// 实际上这个步骤相当于在初始化最早开始时间</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        对最早开始时间的理解：</span></span><br><span class="line"><span class="comment">            假设此时有一条边从v指向w，</span></span><br><span class="line"><span class="comment">            v的最早开始时间为t1，w的最早开始时间为t2，边v-&gt;w的权值为cost，</span></span><br><span class="line"><span class="comment">            若t1+cost&gt;t2，则更新t2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> j, w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        j = GetFirstNeighbor(g, g-&gt;VerticesList[i]);  <span class="comment">// 指向i的第一个邻接顶点</span></span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            w = GetWeight(g, i, j);  <span class="comment">// 获取边i-&gt;j的权值</span></span><br><span class="line">            <span class="keyword">if</span>((ve[i] + w) &gt; ve[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ve[j] = ve[i] + w;</span><br><span class="line">            &#125;</span><br><span class="line">            j = GetNextNeighbor(g, g-&gt;VerticesList[i], g-&gt;VerticesList[j]);  <span class="comment">// 获取下一个邻接顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;n; ++i)</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\t&quot;, ve[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向求解每个顶点的最晚开始时间，vl</span></span><br><span class="line">    <span class="comment">// 实际上这个步骤相当于在初始化最晚开始时间</span></span><br><span class="line">    <span class="comment">// 最晚开始时间：如果从顶点i到顶点j存在多条路径，则最长时间的那条路径A为关键路径，而小于最长时间的其他路径可以在A开始后一段时间再进行</span></span><br><span class="line">    vl[n<span class="number">-1</span>] = ve[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>; i&gt;<span class="number">0</span>; --i)  <span class="comment">// 从倒数第二个顶点开始往前遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        j = GetFirstNeighbor(g, g-&gt;VerticesList[i]);  <span class="comment">// 指向i的第一个邻接顶点</span></span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            w = GetWeight(g, i, j);</span><br><span class="line">            <span class="comment">// 若步骤j的最晚开始时间（vl[j]）减去活动(i, j)的时间（w）小于步骤i的最晚开始时间（vl[i]），更新vl[i]</span></span><br><span class="line">            <span class="comment">// 因为说明此时活动(i, j)的持续时间要长于原先走的那条路径，所以要进行更新</span></span><br><span class="line">            <span class="comment">// 也就是说，应该选择更小的时间</span></span><br><span class="line">            <span class="keyword">if</span>((vl[j] - w) &lt; vl[i])  </span><br><span class="line">            &#123;</span><br><span class="line">                vl[i] = vl[j] - w;</span><br><span class="line">            &#125;</span><br><span class="line">            j = GetNextNeighbor(g, g-&gt;VerticesList[i], g-&gt;VerticesList[j]);  <span class="comment">// 获取下一个邻接顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;n; ++i)</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\t&quot;, vl[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> Ae, Al;  <span class="comment">// 活动的最早开始时间和最晚开始时间，这里的A代表边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        j = GetFirstNeighbor(g, g-&gt;VerticesList[i]);  <span class="comment">// 指向i的第一个邻接顶点</span></span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Ae = ve[i];  <span class="comment">// 活动的最早开始时间</span></span><br><span class="line">            Al = vl[j] - GetWeight(g, i, j);  <span class="comment">// 有点没太理解这一行</span></span><br><span class="line">            <span class="comment">// vl[j]是顶点j代表该步骤的最晚开始时间，边ij的权重是从完成步骤i所需的时间</span></span><br><span class="line">            <span class="comment">// vl[j] - GetWeight(g, i, j)即代表活动j的最晚开始时间</span></span><br><span class="line">            <span class="keyword">if</span>(Ae == Al)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 说明i和j是关键路径上的两个顶点</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;%c, %c&gt;是关键路径.\n&quot;</span>, g-&gt;VerticesList[i], g-&gt;VerticesList[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            j = GetNextNeighbor(g, g-&gt;VerticesList[i], g-&gt;VerticesList[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ve);</span><br><span class="line">    <span class="built_in">free</span>(vl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-6-最短路径"><a href="#7-6-最短路径" class="headerlink" title="7.6 最短路径"></a>7.6 最短路径</h2><p><strong>从某个源点到其余各个顶点的最短路径</strong></p>
<p><strong><code>Dijkstra</code>算法</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401081053558.png" alt="image-20240108105354193" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401081055708.png" alt="image-20240108105532557" style="zoom: 50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// diskstra算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath</span><span class="params">(GraphMtx *g, T vertex, E dist[], <span class="type">int</span> path[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;  <span class="comment">// 记录顶点个数</span></span><br><span class="line">    <span class="type">bool</span> *S = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>)*n);  <span class="comment">// 已找到从vertex出发的最短路径的终点的集合</span></span><br><span class="line">    assert(S != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v = GetVertexPos(g, vertex);  <span class="comment">// 得到vertex的下标位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dist[i] = GetWeight(g, v, i);  <span class="comment">// 获取顶点vertex到其余各顶点对应的权值，初始化dist</span></span><br><span class="line">        S[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(i != v &amp;&amp; dist[i] &lt; MAX_COST)</span><br><span class="line">        &#123;</span><br><span class="line">            path[i] = v;  <span class="comment">// 若vertex和顶点i有边（方向为vertex-&gt;i），则初始化其起始点为vertex</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            path[i] = <span class="number">-1</span>;  <span class="comment">// 否则初始化其起始点为-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    S[v] = <span class="literal">true</span>;  <span class="comment">// 代表顶点vertex已经加入集合</span></span><br><span class="line">    <span class="type">int</span> min, w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)  <span class="comment">// n-1是因为起始点已经定为vertex了</span></span><br><span class="line">    &#123;</span><br><span class="line">        min = MAX_COST;  <span class="comment">// 初始化最小花费为最大代价</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在本次循环中找到花费最小的路径&lt;i, j&gt;，并用顶点u记录这个顶点j方便后续处理</span></span><br><span class="line">        <span class="type">int</span> u = v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!S[j] &amp;&amp; dist[j] &lt; min)  <span class="comment">// !S[j] --&gt; 未加入集合</span></span><br><span class="line">            &#123;</span><br><span class="line">                u = j;  <span class="comment">// 记录当前顶点</span></span><br><span class="line">                min = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        S[u] = <span class="literal">true</span>;  <span class="comment">// 加入顶点u</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从顶点u出发，更新从u出发到达其他顶点的dist对应的权重</span></span><br><span class="line">        <span class="comment">// 相当于更新dist数组，以便进入下一次循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            w = GetWeight(g, u, k);  <span class="comment">// 顶点u到其余顶点的权值</span></span><br><span class="line">            <span class="keyword">if</span>(!S[k] &amp;&amp; w &lt; MAX_COST &amp;&amp; (dist[u]+w)&lt;dist[k])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[k] = dist[u] + w;</span><br><span class="line">                path[k] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d--&gt;&quot;</span>, path[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Nul.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d--&gt;&quot;</span>, dist[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Nul.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-查找"><a href="#8-查找" class="headerlink" title="8 查找"></a>8 查找</h1><p><strong>查找表</strong>（<code>Search Table</code>）：由同一类型的数据元素（或记录）构成的集合。</p>
<h2 id="8-1-静态查找表"><a href="#8-1-静态查找表" class="headerlink" title="8.1 静态查找表"></a>8.1 静态查找表</h2><h2 id="8-2-动态查找表"><a href="#8-2-动态查找表" class="headerlink" title="8.2 动态查找表"></a>8.2 动态查找表</h2><p><strong>定义</strong>：表结构本身是在查找过程中动态生成的。即对于给定key值，若表中存在关键字等于key值的记录，则查找成功返回；否则插入关键字等于key的记录。</p>
<h3 id="1、二叉排序树（Binary-Sort-Tree）"><a href="#1、二叉排序树（Binary-Sort-Tree）" class="headerlink" title="1、二叉排序树（Binary Sort Tree）"></a>1、二叉排序树（Binary Sort Tree）</h3><p>二叉排序树又称二叉搜索树。</p>
<p><strong>定义</strong>：</p>
<ul>
<li>（1）若左子树非空，则左子树上的所有结点的值小于根节点的值；</li>
<li>（2）若右子树非空，则右子树上的所有结点的值大于根节点的值；</li>
<li>（3）左、右子树分别也为二叉排序树。</li>
</ul>
<h3 id="2、平衡二叉树（Balanced-Binary-Tree-Height-Balanced-Tree）"><a href="#2、平衡二叉树（Balanced-Binary-Tree-Height-Balanced-Tree）" class="headerlink" title="2、平衡二叉树（Balanced Binary Tree&#x2F;Height-Balanced Tree）"></a>2、平衡二叉树（Balanced Binary Tree&#x2F;Height-Balanced Tree）</h3><p>平衡二叉树的前提是这棵树为二叉搜索树。</p>
<p><strong>平衡</strong>：左右子树的深度之差绝对值不大于1。</p>
<p><strong>平衡因子</strong><code>BF(Balanced Factor)</code>：该结点的右子树的深度减去其左子树的深度。</p>
<blockquote>
<p>深度：从根节点数到它的叶节点；</p>
<p>⾼度：从叶节点数到它的根节点</p>
</blockquote>
<p><strong>处理方法</strong>：旋转时结点的处理顺序是从<strong>第一个不平衡的结点</strong>开始。</p>
<ul>
<li>单旋转：不平衡的结点处于同一直线<ul>
<li>左旋转</li>
<li>右旋转</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401191222815.png" alt="image-20240119122225757" style="zoom: 25%;" />

<ul>
<li>双旋转：不平衡的结点处于折线状态<ul>
<li>先左后右（针对向左突出，＜）</li>
<li>先右后左（针对向右突出，＞）</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401191600972.png" alt="image-20240119160055303" style="zoom:25%;" />

<p>删除结点：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401211202772.png" alt="image-20240121120204211"></p>
<h3 id="3、哈希表"><a href="#3、哈希表" class="headerlink" title="3、哈希表"></a>3、哈希表</h3><p><strong>定义：</strong></p>
<p>根据设定的哈希函数<code>H(key)</code>和处理冲突的方法将一组关键字映像到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置。这一映像过程称为<strong>哈希表</strong>或<strong>散列</strong>，所得存储位置称哈希地址或散列地址。</p>
<p><strong>关键问题：</strong></p>
<p>1、创建哈希函数；</p>
<ul>
<li><strong>除留余数法</strong>；（使用最广泛）</li>
</ul>
<p>2、解决哈希冲突。</p>
<ul>
<li><strong>链地址法</strong>；（使用最广泛，相当于顺序表+链表）</li>
</ul>
<p><strong>溢出表算法（公司面试题）</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401231117485.png" alt="image-20240123111749039"></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401231307889.png" alt="image-20240123130752821" style="zoom: 25%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init_bucket_node</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;P; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;BUCKET_NODE_SIZE; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            hash_table[i].data[j] = NULL_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">        hash_table[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Insert_new_element</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="built_in">Hash</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;BUCKET_NODE_SIZE; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hash_table[index].data[i] == NULL_DATA)</span><br><span class="line">        &#123;</span><br><span class="line">            hash_table[index].data[i] = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 溢出桶有空余，直接插入</span></span><br><span class="line">    bucket_node *p = &amp;hash_table[index];</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;BUCKET_NODE_SIZE; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data[i] == NULL_DATA)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;data[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不存在有空余的溢出桶，则新建一个</span></span><br><span class="line">    bucket_node *s = (bucket_node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(bucket_node));</span><br><span class="line">    <span class="built_in">assert</span>(s != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;BUCKET_NODE_SIZE; ++i)</span><br><span class="line">        s-&gt;data[i] = NULL_DATA;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    s-&gt;data[<span class="number">0</span>] = x;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-排序"><a href="#9-排序" class="headerlink" title="9 排序"></a>9 排序</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><p>线性&#x2F;非线性数据结构和排序都是为了最终的查找服务的。</p>
<p><strong>排序方法的稳定与否是针对相同的关键字而言的。若相同的关键字在排序后次序无变化，则其是稳定的。</strong></p>
<p><strong>分类：</strong></p>
<ul>
<li>内部排序：数据量较小，所有的数据一次性全部放入<strong>内存</strong>进行。<ul>
<li><strong>插入排序（稳定排序）</strong></li>
<li><strong>交换排序</strong></li>
<li><strong>选择排序</strong></li>
<li><strong>归并排序</strong></li>
<li><strong>基数排序</strong></li>
</ul>
</li>
<li>外部排序：数据量过大，一部分数据在<strong>内存</strong>中先进行排序，其余的数据暂存在磁盘中。</li>
</ul>
<p><strong>基本方法：</strong></p>
<ul>
<li>比较两个关键字的大小；</li>
<li>将记录从一个位置移动至另一个位置。</li>
</ul>
<h2 id="9-2-插入排序"><a href="#9-2-插入排序" class="headerlink" title="9.2 插入排序"></a>9.2 插入排序</h2><p>插入排序（稳定排序）</p>
<h3 id="1、直接插入排序"><a href="#1、直接插入排序" class="headerlink" title="1、直接插入排序"></a>1、直接插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接插入排序 O(n^2)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T *a, T*b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void InsertSort(SqList &amp;L, int n)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    for(int i=1; i&lt;n; ++i)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(L[i] &lt; L[i-1])</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            Swap(&amp;L[i], &amp;L[i-1]);</span></span><br><span class="line"><span class="comment">            for(int j=i-1; j&gt;0 &amp;&amp; L[j]&lt;L[j-1]; --j)  // important</span></span><br><span class="line"><span class="comment">                Swap(&amp;L[j], &amp;L[j-1]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 改进</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] &lt; L[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            L[<span class="number">0</span>] = L[i];</span><br><span class="line">            L[i] = L[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> j = i<span class="number">-2</span>;            </span><br><span class="line">            <span class="keyword">while</span>(L[<span class="number">0</span>]&lt;L[j])</span><br><span class="line">            &#123;</span><br><span class="line">                L[j+<span class="number">1</span>] = L[j];</span><br><span class="line">                --j;</span><br><span class="line">            &#125;            </span><br><span class="line">            L[j+<span class="number">1</span>] = L[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、折半插入排序"><a href="#2、折半插入排序" class="headerlink" title="2、折半插入排序"></a>2、折半插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 折半插入排序 O(n^2)  -- 减少直接插入排序的关键字比较次数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BInsertSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        L[<span class="number">0</span>] = L[i];</span><br><span class="line">        <span class="type">int</span> low = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> high = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)  <span class="comment">// 折半插入，通过移动low/high找到该插入的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(L[<span class="number">0</span>] &gt;= L[mid])</span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&gt;high+<span class="number">1</span>; --j)  <span class="comment">// high+1是要插入L[0]的数值的位置，因此把high+1到i的值全部往后挪动一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            L[j] = L[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        L[high+<span class="number">1</span>] = L[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、2路插入排序"><a href="#3、2路插入排序" class="headerlink" title="3、2路插入排序"></a>3、2路插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2路插入排序  -- 减少折半插入排序的数据移动次数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TWayInsertSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList tmp;</span><br><span class="line">    tmp[<span class="number">0</span>] = L[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> head, tail;</span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; ++i)  <span class="comment">// L[i]是当前要插入tmp的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] &lt; tmp[head])  <span class="comment">// 若当前遍历到的L[i]小于head所指元素，则将L[i]插入到head的前一个位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = (head<span class="number">-1</span>+n) % n;  <span class="comment">// 取模操作实现循环操作</span></span><br><span class="line">            tmp[head] = L[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L[i] &gt; tmp[tail])  <span class="comment">// 同理，若当前遍历到的L[i]大于head所指元素，则将L[i]插入到head的后一个位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            tail++;</span><br><span class="line">            tmp[tail] = L[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 若tmp[head]&lt;L[i]&lt;tmp[tail]，则需要移动数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            tail++;</span><br><span class="line">            tmp[tail] = tmp[tail<span class="number">-1</span>];  <span class="comment">// 将tmp[tail]向后移动一个，并将tail本身的值加1</span></span><br><span class="line">            <span class="type">int</span> j = tail<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(L[i] &lt; tmp[(j<span class="number">-1</span>+n)%n])  <span class="comment">// L[i]&lt;tmp[(j-1+n)%n]，找到L[i]应该插入的地方，即tmp[j]</span></span><br><span class="line">                                          <span class="comment">// 由于这里的j的指向是循环的，所以(j-1+n)%n相当于j-1</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp[j] = tmp[(j<span class="number">-1</span>+n)%n];</span><br><span class="line">                j = (j<span class="number">-1</span>+n)%n;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp[j] = L[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        L[i] = tmp[head];</span><br><span class="line">        head = (head+<span class="number">1</span>)%n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、表插入排序"><a href="#4、表插入排序" class="headerlink" title="4、表插入排序"></a>4、表插入排序</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401241536655.png" alt="image-20240124153639775" style="zoom: 25%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表插入排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVALUE 0x7fffffff</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SLNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">    <span class="type">int</span> link;</span><br><span class="line">&#125;SLNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> SLNode Table[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableInsertSort</span><span class="params">(Table t, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[<span class="number">0</span>].link = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p, q;  <span class="comment">// q是p的前驱</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = t[<span class="number">0</span>].link;  <span class="comment">// p指向当前检索的值的下标，每一次都要从t[0].link指向的头开始排序</span></span><br><span class="line">        q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">0</span> &amp;&amp; t[p].data&lt;=t[i].data)  <span class="comment">// p!=0说明未检索完；t[p].data&lt;=t[i].data说明当前检索到的值小于等于要排序进来的值，所以要接着往下找更大的值</span></span><br><span class="line">        &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = t[p].link;  <span class="comment">// p指向下一个更大的值对应的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当退出循环时，t[p].data&gt;t[i].data，则i在p的前驱位置插入</span></span><br><span class="line">        t[i].link = t[q].link;</span><br><span class="line">        t[q].link = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、希尔排序"><a href="#5、希尔排序" class="headerlink" title="5、希尔排序"></a>5、希尔排序</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401251321618.png" alt="image-20240125132057065"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> n, <span class="type">int</span> dk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=dk+<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] &lt; L[i-dk])  <span class="comment">// 间隔两端的两个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            L[<span class="number">0</span>] = L[i];</span><br><span class="line">            <span class="type">int</span> j = i - dk;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; L[<span class="number">0</span>] &lt; L[j])</span><br><span class="line">            &#123;</span><br><span class="line">                L[j+dk] = L[j];  <span class="comment">// 在间隔上取的几个数之间进行直接插入排序，需要注意这里数之间的间隔是dk</span></span><br><span class="line">                j -= dk;</span><br><span class="line">            &#125;</span><br><span class="line">            L[j+dk] = L[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n, <span class="type">int</span> dlta[], <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;t; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShellInsert</span>(L, n, dlta[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-3-交换排序"><a href="#9-3-交换排序" class="headerlink" title="9.3 交换排序"></a>9.3 交换排序</h2><h3 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n<span class="number">-1</span>-i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L[j] &gt; L[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Swap</span>(&amp;L[j], &amp;L[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、快速排序"><a href="#2、快速排序" class="headerlink" title="2、快速排序"></a>2、快速排序</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401251320399.png" alt="image-20240125132023301" style="zoom: 25%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T pk = L[low];  <span class="comment">// 先指定L[low]为关键字</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; L[high]&gt;=pk)  <span class="comment">// 循环使得high指向小于枢轴的值</span></span><br><span class="line">            high--;</span><br><span class="line">        L[low] = L[high];  <span class="comment">// 将这个较小的L[high]值赋值给low所处的位置</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; L[low]&lt;pk)  <span class="comment">// 循环使得low指向大于枢轴的值</span></span><br><span class="line">            low++;</span><br><span class="line">        L[high] = L[low];  <span class="comment">// 将这个较大的L[low]值赋值给high所处的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    L[low] = pk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)  <span class="comment">// 未排序完成</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pkloc = <span class="built_in">Partition</span>(L, low, high);  <span class="comment">// 求枢轴关键字的位置</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(L, low, pkloc<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(L, pkloc+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-4-选择排序"><a href="#9-4-选择排序" class="headerlink" title="9.4 选择排序"></a>9.4 选择排序</h2><h3 id="1、简单选择排序"><a href="#1、简单选择排序" class="headerlink" title="1、简单选择排序"></a>1、简单选择排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SelectMinKey</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T minval = L[i];</span><br><span class="line">    <span class="type">int</span> pos = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m=i+<span class="number">1</span>; m&lt;n; ++m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[m] &lt; minval)</span><br><span class="line">        &#123;</span><br><span class="line">            minval = L[m];</span><br><span class="line">            pos = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="built_in">SelectMinKey</span>(L, i, n);  <span class="comment">// 找到最小值对应的下标位置</span></span><br><span class="line">        <span class="keyword">if</span>(j != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Swap</span>(&amp;L[j], &amp;L[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、树形选择排序"><a href="#2、树形选择排序" class="headerlink" title="2、树形选择排序"></a>2、树形选择排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 树形选择排序，相较于简单选择排序减少了比较次数（锦标赛排序）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVALUE 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">GetValue</span><span class="params">(T e[], <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p &gt;= n)</span><br><span class="line">        <span class="keyword">return</span> MAXVALUE;</span><br><span class="line">    </span><br><span class="line">    T value;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; n/<span class="number">2</span>)  <span class="comment">// 得到的是下标位置</span></span><br><span class="line">        value = e[e[p]];</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 否则为叶子节点，直接返回e[p]</span></span><br><span class="line">        value = e[p];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Play</span><span class="params">(T e[], <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> left, right;  <span class="comment">// 左右下标</span></span><br><span class="line">    T lval, rval;  <span class="comment">// 左右值</span></span><br><span class="line">    <span class="keyword">while</span>(p &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        left = <span class="number">2</span>*p+<span class="number">1</span>;</span><br><span class="line">        right = <span class="number">2</span>*p+<span class="number">2</span>;</span><br><span class="line">        lval = <span class="built_in">GetValue</span>(e, n, left);</span><br><span class="line">        rval = <span class="built_in">GetValue</span>(e, n, right);</span><br><span class="line">        <span class="keyword">if</span>(lval &lt;= rval)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &lt; n/<span class="number">2</span>)</span><br><span class="line">                e[p] = e[left];  <span class="comment">// important</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[p] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(right &lt; n/<span class="number">2</span>)</span><br><span class="line">                e[p] = e[right];  <span class="comment">// important</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[p] = right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        --p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select</span><span class="params">(T e[], <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = p;  <span class="comment">// 父节点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">2</span>*p+<span class="number">1</span>;  <span class="comment">// 左子树</span></span><br><span class="line">    T lval, rval;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; flag)</span><br><span class="line">    &#123;</span><br><span class="line">        lval = <span class="built_in">GetValue</span>(e, n, j);</span><br><span class="line">        rval = <span class="built_in">GetValue</span>(e, n, j+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(lval &lt;= rval)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; n/<span class="number">2</span>)</span><br><span class="line">                e[i] = e[j];  <span class="comment">// j&lt;n/2说明j的位置在非叶子节点的位置，所以对于j的父节点，需要的是位置j上存储的内容即e[j]</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[i] = j;  <span class="comment">// j&gt;=n/2说明j的位置在叶子节点的位置，所以对于j的父节点，需要的是就是位置j本身</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((j+<span class="number">1</span>) &lt; n/<span class="number">2</span>)</span><br><span class="line">                e[i] = e[j+<span class="number">1</span>];  <span class="comment">// 同上</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[i] = j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            flag--;</span><br><span class="line">        <span class="comment">// 向上递归，找到新的父节点和对应的左孩子</span></span><br><span class="line">        i = (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        j = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TreeSelectSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">    T *e = (T*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T) * size);</span><br><span class="line">    <span class="built_in">assert</span>(e != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = size / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        e[k++] = L[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> curpos = size/<span class="number">2</span><span class="number">-1</span>;  <span class="comment">// 树最后一个叶子分支的父节点，相当于要打的第一场比赛</span></span><br><span class="line">    <span class="built_in">Play</span>(e, size, curpos);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    L[i] = e[e[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将已经选出来的最小值的节点A，将其赋值为最大值，使其不参与后续的比较</span></span><br><span class="line">    e[e[<span class="number">0</span>]] = MAXVALUE;  </span><br><span class="line">    <span class="comment">// 从A的父节点开始一路向上比较，直到到达根节点，比较完毕</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        curpos = (e[<span class="number">0</span>]<span class="number">-1</span>)/<span class="number">2</span>;  <span class="comment">// A的父节点</span></span><br><span class="line">        <span class="built_in">Select</span>(e, size, curpos);</span><br><span class="line">        L[i] = e[e[<span class="number">0</span>]];</span><br><span class="line">        e[e[<span class="number">0</span>]] = MAXVALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(e);</span><br><span class="line">    e = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、堆排序"><a href="#3、堆排序" class="headerlink" title="3、堆排序"></a>3、堆排序</h3><p><strong>大堆</strong>：父节点大于左右孩子；</p>
<p><strong>小堆</strong>：父节点小于左右孩子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆排序，相较于树形选择排序辅助空间大幅减少，只需要1个辅助空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(T heap[], <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = p;  <span class="comment">// 父节点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">2</span>*i+<span class="number">1</span>;  <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; n)  <span class="comment">// 说明p有左孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;n<span class="number">-1</span> &amp;&amp; heap[j]&gt;heap[j+<span class="number">1</span>])  <span class="comment">// j&lt;n-1说明有右孩子，heap[j]&gt;heap[j+1]说明左孩子大于右孩子</span></span><br><span class="line">            j++;  <span class="comment">// j指向右孩子，也即是保证j指向左右孩子中较小的那个值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(heap[i] &lt;= heap[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Swap</span>(&amp;heap[i], &amp;heap[j]);</span><br><span class="line">            <span class="comment">// 继续递归，使得该函数从位置p一直遍历到叶子结点</span></span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T <span class="title">RemoveMinKey</span><span class="params">(T heap[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T key = heap[<span class="number">0</span>];</span><br><span class="line">    heap[<span class="number">0</span>] = heap[n];</span><br><span class="line">    <span class="built_in">siftDown</span>(heap, n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T *heap = (T*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T) * n);</span><br><span class="line">    <span class="built_in">assert</span>(heap != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        heap[i] = L[i];  <span class="comment">// 将原始数据拷贝到heap空间中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将heap调整为小堆</span></span><br><span class="line">    <span class="comment">// 1、找到最后一个分支节点，调用函数SiftDown后，目前的堆顶元素即为当前序列的最小值</span></span><br><span class="line">    <span class="type">int</span> curpos = n/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(curpos &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">siftDown</span>(heap, n, curpos);</span><br><span class="line">        curpos--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、取走堆顶元素后，依次用最后一个节点补上根节点（最小值），重新进行小堆排序并取堆顶元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        L[i] = <span class="built_in">RemoveMinKey</span>(heap, n-i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-5-归并排序"><a href="#9-5-归并排序" class="headerlink" title="9.5 归并排序"></a>9.5 归并排序</h2><p><strong>2-路归并排序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(SqList &amp;L, SqList &amp;TP, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left; i&lt;=right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        TP[i] = L[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s1 = left;</span><br><span class="line">    <span class="type">int</span> s2 = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = left;</span><br><span class="line">    <span class="keyword">while</span>(s1&lt;=mid &amp;&amp; s2&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(TP[s1] &lt;= TP[s2])</span><br><span class="line">            L[k++] = TP[s1++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L[k++] = TP[s2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s1 &lt;= mid)</span><br><span class="line">        L[k++] = TP[s1++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(s2&lt;=right)</span><br><span class="line">        L[k++] = TP[s2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(SqList &amp;L, SqList &amp;TP, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(L, TP, left, mid);</span><br><span class="line">    <span class="built_in">MergeSort</span>(L, TP, mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="built_in">Merge</span>(L, TP, left, mid, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-6-基数排序"><a href="#9-6-基数排序" class="headerlink" title="9.6 基数排序"></a>9.6 基数排序</h2><p>对数据的<strong>分配和收集</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401262157878.png" alt="image-20240126215723896"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基数排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getkey</span><span class="params">(T value, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">while</span>(k &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        key = value % <span class="number">10</span>;</span><br><span class="line">        value /= <span class="number">10</span>;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Distribute</span><span class="params">(SqList &amp;L, <span class="type">int</span> n, List (&amp;lt)[<span class="number">10</span>], <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>(&amp;lt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        key = <span class="built_in">getkey</span>(L[i], k);  <span class="comment">// 取得需要比对的位置上的值</span></span><br><span class="line">        <span class="built_in">push_back</span>(&amp;lt[key], L[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Collect</span><span class="params">(SqList &amp;L, List (&amp;lt)[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Node *p = lt[i].first-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L[k++] = p-&gt;data;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List list[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InitList</span>(&amp;list[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Distribute</span>(L, n, list, i);</span><br><span class="line">        <span class="built_in">Collect</span>(L, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>OpenPose原理及编译</title>
    <url>/2023/12/25/7%20%E7%A7%91%E7%A0%94/OpenPose%E5%8E%9F%E7%90%86%E5%8F%8A%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="1-前提思考"><a href="#1-前提思考" class="headerlink" title="1 前提思考"></a>1 前提思考</h2><p>1、姿态估计中的关键任务是什么？</p>
<p>识别人体骨干躯干的关键点，并进行定位与拼接。</p>
<p>2、姿态估计中的难点是什么？</p>
<p><strong>（1）遮挡；（2）匹配。</strong></p>
<p>3、COCO数据集的关键点有几个，分别是？</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251524168.png" alt="COCO数据集关键点" style="zoom: 50%;" />

<p>数据集中是<code>17</code>个点，实际上训练时候还要加上<code>1</code>个脖子的点，共<code>18</code>个点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Joint index:</span></span><br><span class="line"><span class="comment"># &#123;0,  &quot;Nose&quot;&#125;</span></span><br><span class="line"><span class="comment"># &#123;1,  &quot;Neck&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;2,  &quot;RShoulder&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;3,  &quot;RElbow&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;4,  &quot;RWrist&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;5,  &quot;LShoulder&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;6,  &quot;LElbow&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;7,  &quot;LWrist&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;8,  &quot;RHip&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;9,  &quot;RKnee&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;10, &quot;RAnkle&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;11, &quot;LHip&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;12, &quot;LKnee&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;13, &quot;LAnkle&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;14, &quot;REye&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;15, &quot;LEye&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;16, &quot;REar&quot;&#125;,</span></span><br><span class="line"><span class="comment"># &#123;17, &quot;LEar&quot;&#125;,</span></span><br></pre></td></tr></table></figure>

<p>4、姿态估计方法分为几个大类？</p>
<p>（1）<code>Top-down</code>（自顶向下）：先检测所有的人，再对每个框的人进行姿态估计输出结果</p>
<p>优点：准确率高，点的回归率高；</p>
<p>缺点：算法性能依赖检测效果，复杂度较高，实时性比较差。</p>
<p>主要用于一些离线的项目，对实时性没要求。</p>
<p>（2）<code>bottom-up</code>（自底向上）：先检测所有关键点，再进行匹配连接</p>
<p>优点：计算量较小，可以达到实时性的效果；</p>
<p>缺点：精度较差，匹配策略比较复杂。</p>
<h2 id="2-论文解读"><a href="#2-论文解读" class="headerlink" title="2 论文解读"></a>2 论文解读</h2><p>论文地址：<a href="https://arxiv.org/pdf/1611.08050.pdf">https://arxiv.org/pdf/1611.08050.pdf</a></p>
<h3 id="1、网络框架"><a href="#1、网络框架" class="headerlink" title="1、网络框架"></a>1、网络框架</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251524273.png" alt="网络整体流程图">	<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251532476.jpg" alt="网络框架1"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251534898.png" alt="网络框架2"></p>
<p>其中的重点：</p>
<p>（1）关键点的<code>heatmap</code>标注生成，采用高斯热度图的方式；</p>
<p>（2）<code>PAF</code>：部分亲和域。这也是论文中的重点和难点；</p>
<p>（3）匹配策略：匈牙利匹配。</p>
<h3 id="2、数据制作"><a href="#2、数据制作" class="headerlink" title="2、数据制作"></a>2、数据制作</h3><p>采用的数据集为<code>COCO</code>数据集，其中人体骨骼点的标注信息为<code>[x, y, label]</code>。</p>
<p><code>label</code>取值为<code>0</code>、<code>1</code>、<code>2</code>，分别表示不存在、遮挡、正常，其中不存在的关键点是需要去除的。</p>
<p>（1）关键点高斯热力图实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">putGaussianMaps</span>(<span class="params">center, accumulate_confid_map, sigma, grid_y, grid_x, stride</span>):</span><br><span class="line"></span><br><span class="line">    start = stride / <span class="number">2.0</span> - <span class="number">0.5</span></span><br><span class="line">    y_range = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(grid_y))]</span><br><span class="line">    x_range = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(grid_x))]</span><br><span class="line">    xx, yy = np.meshgrid(x_range, y_range)      <span class="comment"># 构建棋盘</span></span><br><span class="line">    xx = xx * stride + start                    <span class="comment"># 每个点在原始图像上的位置</span></span><br><span class="line">    yy = yy * stride + start</span><br><span class="line">    d2 = (xx - center[<span class="number">0</span>]) ** <span class="number">2</span> + (yy - center[<span class="number">1</span>]) ** <span class="number">2</span>  <span class="comment"># 计算每个点和GT点的距离</span></span><br><span class="line">    exponent = d2 / <span class="number">2.0</span> / sigma / sigma                 <span class="comment"># 这里在做一个高斯计算</span></span><br><span class="line">    mask = exponent &lt;= <span class="number">4.6052</span>                           <span class="comment"># 将在这个阈值范围内的点用True记录</span></span><br><span class="line">    cofid_map = np.exp(-exponent)                       <span class="comment"># 这里做一个标准化</span></span><br><span class="line">    cofid_map = np.multiply(mask, cofid_map)            <span class="comment"># 取出对应关系为True的点</span></span><br><span class="line">    accumulate_confid_map += cofid_map                  <span class="comment"># 将每个点计算的结果都累加到上一次的特征中</span></span><br><span class="line">    accumulate_confid_map[accumulate_confid_map &gt; <span class="number">1.0</span>] = <span class="number">1.0</span>      <span class="comment"># 对结果大于1的值，只取1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> accumulate_confid_map    <span class="comment"># 返回热力图（heatmap）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）PAF数据计算的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">putVecMaps</span>(<span class="params">centerA, centerB, accumulate_vec_map, count, grid_y, grid_x, stride</span>):</span><br><span class="line">    centerA = centerA.astype(<span class="built_in">float</span>)</span><br><span class="line">    centerB = centerB.astype(<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line">    thre = <span class="number">1</span>  <span class="comment"># 表示宽度，也就是一个设定好的参数</span></span><br><span class="line">    centerB = centerB / stride  <span class="comment"># 缩放比例特定到特征图中</span></span><br><span class="line">    centerA = centerA / stride</span><br><span class="line"></span><br><span class="line">    limb_vec = centerB - centerA  <span class="comment"># 求出两个点的向量</span></span><br><span class="line">    norm = np.linalg.norm(limb_vec)  <span class="comment"># 是需要求单位向量，所以先计算范数，也就是向量模长</span></span><br><span class="line">    <span class="keyword">if</span> (norm == <span class="number">0.0</span>):  <span class="comment"># 这里表示两个点基本重合了</span></span><br><span class="line">        <span class="comment"># print &#x27;limb is too short, ignore it...&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> accumulate_vec_map, count</span><br><span class="line">    limb_vec_unit = limb_vec / norm  <span class="comment"># 向量除以模长，得到单位向量</span></span><br><span class="line">    <span class="comment"># print &#x27;limb unit vector: &#123;&#125;&#x27;.format(limb_vec_unit)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># To make sure not beyond the border of this two points</span></span><br><span class="line">    <span class="comment"># 得到所有可能存在方向的区域(这里就用到了之前的超参数阈值)</span></span><br><span class="line">    min_x = <span class="built_in">max</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="built_in">min</span>(centerA[<span class="number">0</span>], centerB[<span class="number">0</span>]) - thre)), <span class="number">0</span>)</span><br><span class="line">    max_x = <span class="built_in">min</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="built_in">max</span>(centerA[<span class="number">0</span>], centerB[<span class="number">0</span>]) + thre)), grid_x)</span><br><span class="line">    min_y = <span class="built_in">max</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="built_in">min</span>(centerA[<span class="number">1</span>], centerB[<span class="number">1</span>]) - thre)), <span class="number">0</span>)</span><br><span class="line">    max_y = <span class="built_in">min</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="built_in">max</span>(centerA[<span class="number">1</span>], centerB[<span class="number">1</span>]) + thre)), grid_y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 得到一个可能存在向量的矩形框</span></span><br><span class="line">    range_x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">int</span>(min_x), <span class="built_in">int</span>(max_x), <span class="number">1</span>))</span><br><span class="line">    range_y = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">int</span>(min_y), <span class="built_in">int</span>(max_y), <span class="number">1</span>))</span><br><span class="line">    xx, yy = np.meshgrid(range_x, range_y)  <span class="comment"># 制作一个网格</span></span><br><span class="line">    ba_x = xx - centerA[<span class="number">0</span>]  <span class="comment"># the vector from (x,y) to centerA 根据位置判断是否在该区域上（分别得到X和Y方向的）</span></span><br><span class="line">    ba_y = yy - centerA[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 向量叉乘根据阈值选择赋值区域，任何向量与单位向量的叉乘即为四边形的面积</span></span><br><span class="line">    <span class="comment"># 这里是重点步骤，也就是论文中的公式，表示计算出两个向量组成四边形的面积</span></span><br><span class="line">    limb_width = np.<span class="built_in">abs</span>(ba_x * limb_vec_unit[<span class="number">1</span>] - ba_y * limb_vec_unit[<span class="number">0</span>])</span><br><span class="line">    mask = limb_width &lt; thre  <span class="comment"># mask is 2D （小于阈值的表示在该区域上）</span></span><br><span class="line"></span><br><span class="line">    vec_map = np.copy(accumulate_vec_map) * <span class="number">0.0</span>  <span class="comment"># 构建一个全为0的矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这行代码主要作用是将mask扩展一个维度并且赋值给vec_map数组</span></span><br><span class="line">    vec_map[yy, xx] = np.repeat(mask[:, :, np.newaxis], <span class="number">2</span>, axis=<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 在该区域上的都用对应的方向向量表示（根据mask结果表示是否在，通过乘法的方式）</span></span><br><span class="line">    vec_map[yy, xx] *= limb_vec_unit[np.newaxis, np.newaxis, :]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># #在特征图中（46*46）中 哪些区域是该躯干所在区域，判断x或者y向量都不为0</span></span><br><span class="line">    mask = np.logical_or.reduce(</span><br><span class="line">        (np.<span class="built_in">abs</span>(vec_map[:, :, <span class="number">0</span>]) &gt; <span class="number">0</span>, np.<span class="built_in">abs</span>(vec_map[:, :, <span class="number">1</span>]) &gt; <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每次返回的accumulate_vec_map都是平均值，现在还原成实际值</span></span><br><span class="line">    accumulate_vec_map = np.multiply(</span><br><span class="line">        accumulate_vec_map, count[:, :, np.newaxis])</span><br><span class="line">    accumulate_vec_map += vec_map  <span class="comment"># 加上当前关键点位置形成的向量</span></span><br><span class="line">    count[mask == <span class="literal">True</span>] += <span class="number">1</span>  <span class="comment"># 该区域计算次数都+1</span></span><br><span class="line"></span><br><span class="line">    mask = count == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    count[mask == <span class="literal">True</span>] = <span class="number">1</span>  <span class="comment"># 没有被计算过的地方就等于自身（因为一会要除法）</span></span><br><span class="line"></span><br><span class="line">    accumulate_vec_map = np.divide(accumulate_vec_map, count[:, :, np.newaxis])  <span class="comment"># 算平均向量</span></span><br><span class="line">    count[mask == <span class="literal">True</span>] = <span class="number">0</span>  <span class="comment"># 还原回去</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> accumulate_vec_map, count</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两个函数是最重要的两个部分，也就是对训练数据的处理，生成出需要的训练数据。</p>
<h3 id="3、预测推理"><a href="#3、预测推理" class="headerlink" title="3、预测推理"></a>3、预测推理</h3><p>预测模型这里，在官方源码中是将<code>paf</code>的处理封装在一个<code>cpp</code>库中，<strong>通过编译得到静态库，代码中可以调用</strong>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">swig -python -c++ pafprocess.i</span><br><span class="line">python3 setup.py build_ext --inplace</span><br></pre></td></tr></table></figure>

<p>这里PAF的处理主要是采用积分计算的方式，也就是对于连线的点的方向选择，采用积分的方式计算最佳连线策略。</p>
<h2 id="3-OpenPose-Windows-cpu-only-编译"><a href="#3-OpenPose-Windows-cpu-only-编译" class="headerlink" title="3 OpenPose_Windows_cpu_only 编译"></a>3 OpenPose_Windows_cpu_only 编译</h2><p>主要步骤参考：</p>
<p><a href="https://blog.csdn.net/qq_51209492/article/details/124185106?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%AE%89%E8%A3%85openpose%E5%B9%B6%E4%BD%BF%E7%94%A8python%E8%B0%83%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-124185106.142%5Ev96%5Epc_search_result_base7&spm=1018.2226.3001.4187">CSDN——win10环境下下载安装openpose(only cpu)并在pycharm中运行代码（超详细）</a></p>
<p>基本按照这上面来走就可以正确编译，但其中要注意以下几点：</p>
<p><strong>1、<code>bat</code>批处理命令运行时给的网站我根本无法访问，一直<code>retry</code></strong></p>
<p>最后选择用迅雷下载，然后放进<code>\openpose\3rdparty\windows</code>文件夹下。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312272200864.png" alt="image-20231227220003816"></p>
<p>同时这里面的<code>caffe_cpu</code>不是用这4个<code>bat</code>文件下载的，但是由于网址同样进不去，也选择先用迅雷下载好后放进去。</p>
<p>我这里的4个<code>zip</code>文件大小显示为<code>0kb</code>似乎是<code>cmake</code>编译后自己更改的，不用去管。</p>
<p><strong>2、用迅雷提前下载好<code>\openpose\models</code>后，<code>cmake</code>编译依然会重新下载模型。</strong></p>
<p>这里我参考了<a href="https://zhuanlan.zhihu.com/p/446981890">OpenPose-CPU版本安装</a>的方法：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312272207425.png" alt="image-20231227220706339"></p>
<p>修改<code>CmakeLists.txt</code>文件后就不会再重新下载模型了。</p>
<p><strong>3、用<code>CMAKE</code>编译<code>openpose</code>项目时，一定要在第一次<code>configure</code>之前，点击<code>Add Entry</code>选择<code>Python</code>版本。</strong></p>
<p>如下所示：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312272202637.png" alt="在这里插入图片描述"></p>
<p>实际上这一步就是要确保在<code>cmake</code>编译时访问的<code>python</code>解释器和最后在<code>pycharm</code>中运行时选择的python解释器一致，否则可能会在<code>pycharm</code>中报错<code>No module named pyopenpose</code>。</p>
<p>我第一次在这里就是因为没有关注这个细节，导致<code>cmake</code>选择的是<code>python 3.6.5</code>的编译器，而<code>pycharm</code>选择的是<code>3.7.6</code>的编译器，出现错误。</p>
<p><strong>4、最好采用本地<code>python</code>解释器，不要用<code>anaconda</code>虚拟环境。</strong></p>
<p>我也不知道为什么虚拟环境会报错，可能还是路径的问题吧。</p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
  </entry>
  <entry>
    <title>代码随想录</title>
    <url>/2024/04/09/5%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><h2 id="1、二分法"><a href="#1、二分法" class="headerlink" title="1、二分法"></a>1、二分法</h2><p>采用二分法的前提条件：</p>
<ol>
<li><strong>数组有序（升序）；</strong></li>
<li><strong>无重复元素。</strong></li>
</ol>
<p>基础模版：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭区间 [left, right]</span></span><br><span class="line"><span class="comment">// 1. while(left &lt;= right) </span></span><br><span class="line"><span class="comment">// 2. right = mid - 1;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></p>
<p><a href="https://leetcode.cn/problems/search-insert-position/submissions/521863494/">35. 搜索插入位置</a></p>
<p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<p>这道题做的时候卡了很久，最开始采用前闭后开的区间，但结果是错的，改成前闭后闭的区间就正确了。</p>
<p><a href="https://leetcode.cn/problems/sqrtx/">69. x的平方根</a></p>
<p>1、由于y&#x3D;√x的图像是单调递增的，符合二分查找的条件，因此本题可采用二分查找的方式解决。</p>
<p>2、题目所述x为非负整数，因此left应该初始化为1而非0。</p>
<p>3、<strong>最后结束循环，返回右边界，主要是因为平方根是向下取整，例如 8 的平方跟是 2，而循环结束的条件又是 l &gt; r，因此最后返回右边界 r</strong></p>
<h2 id="2、双指针法"><a href="#2、双指针法" class="headerlink" title="2、双指针法"></a>2、双指针法</h2><p>双指针法：通过一个快指针和一个慢指针在一个for循环下完成两个for循环的工作</p>
<ol>
<li><p><strong>快慢指针</strong>：<strong>快慢指针通常都从下标为0的地方开始走</strong>，当快指针达到末尾时，慢指针通常还在中间位置。</p>
<ul>
<li><p>快指针（<code>fast</code>）：用于判断是否满足题目条件；</p>
</li>
<li><p>慢指针（<code>slow</code>）：保存不满足条件的值（<code>nums[fast]</code>），比如题目要求是移除数组中等于<code>val</code>的值，那么fast遍历完毕数组后，剩下的就是不等于<code>val</code>的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> fast=<span class="number">0</span>; fast&lt;nums.<span class="built_in">size</span>(); fast++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">            nums[slow++] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>左右指针</strong>：<strong>左右指针分别从数组的两端出发</strong>，根据问题的要求移动指针，并通过调整指针位置来实现问题的解决。</p>
</li>
<li><p><strong>滑动窗口</strong>：常用于解决数组或字符串中的子数组或子串问题，如最小覆盖子串、最长无重复字符的子串等。滑动窗口由左右指针定义，<strong>左指针指向窗口的起始位置，右指针指向窗口的结束位置，通过移动两个指针来扩大或缩小窗口</strong>，从而找到满足特定条件的子数组或子串。</p>
<blockquote>
<p><strong>滑动窗口的核心在于当找到一个满足条件的子数组时，要继续尝试缩小窗口以找到更小的子数组。</strong></p>
<p>在采用滑动窗口解决问题时，主要确定以下三点：</p>
<ul>
<li><p>窗口内是什么？</p>
</li>
<li><p>如何移动窗口的起始位置？</p>
</li>
<li><p>如何移动窗口的结束位置？</p>
</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></p>
<ul>
<li><p>解题思路</p>
<p>本题要求：<em>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组</em>，看到这样的要求时，就要很快地联想到<strong>双指针法（快慢指针法）</strong>。</p>
<ol>
<li><code>fast</code>和<code>slow</code>同时指向数组开始；</li>
<li>判断是否<code>nums[fast]==val</code>，若相等，<code>fast</code>前移一位，继续判断，直到<code>nums[fast]!=val</code>；</li>
<li>此时，将<code>nums[fast]</code>赋值给<code>nums[slow]</code>，<code>slow</code>前移一位；</li>
<li>循环执行步骤<strong>2&amp;3</strong>，直到<code>fast</code>遍历到数组末尾。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[fast] == val) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">                <span class="keyword">if</span> (fast == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> slow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></p>
<ul>
<li><p>解题思路</p>
<p>由于题目中已经说了“整数数组<code>nums</code>是非递减的”，那么在包含负数的情况下，平方后最大值就只能位于数组的两端。因此可以采用<strong>双指针法</strong>，用两个指针分别指向最左边和最右边，依次向中间移动。</p>
<ol>
<li>用两个指针<code>l</code>和<code>r</code>分别指向最左边和最右边，同时定义一个新的数组作为结果数组返回；</li>
<li>判断左右两边谁平方后的值更大，将大的那个放入结果数组的最右边；</li>
<li>更新指针；</li>
<li>重复步骤2&amp;3，直到原数组遍历完毕。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> index = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> tmpl = nums[l] * nums[l];</span><br><span class="line">            <span class="type">int</span> tmpr = nums[r] * nums[r];</span><br><span class="line">            <span class="keyword">if</span> (tmpl &lt; tmpr) &#123;</span><br><span class="line">                res[index] = tmpr;</span><br><span class="line">                index--;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[index] = tmpl;</span><br><span class="line">                index--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></p>
<ul>
<li><p>解题思路</p>
<p><strong>当看到题目中出现“子数组”、“子序列”等时，一般就要想到采用滑动窗口来解决。</strong>但这里我最开始想的是下面这种解法，这样实际上就是一种暴力的思想，而非双指针的思想。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样写会超时</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="type">int</span> sum = nums[i];</span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        sum += nums[j];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = j-i+<span class="number">1</span>;</span><br><span class="line">            len = tmp &lt; len ? tmp : len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，在本题中窗口就是满足其<code>和&gt;=target</code>的长度最小的连续子数组。移动窗口的起始位置是为了在满足条件的情况下缩小窗口，移动窗口的结束位置是为了遍历数组的所有元素。</p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        sum += nums[r++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, r-l);</span><br><span class="line">            sum -= nums[l++];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 或</span></span><br><span class="line">            <span class="comment">// sum -= nums[l++];</span></span><br><span class="line">            /res = <span class="built_in">min</span>(res, r-l+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、循环不变原则"><a href="#3、循环不变原则" class="headerlink" title="3、循环不变原则"></a>3、循环不变原则</h2><h3 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59. 螺旋矩阵II"></a>59. 螺旋矩阵II</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵II</a></p>
<ul>
<li><p>解题思路</p>
<p>本题实际上就是考察了<strong>循环不变量原则</strong>，要注意选择好了遍历<strong>区间的开闭</strong>后就一定要贯彻其开闭原则。</p>
<p>将整个过程分为从外到内“画”每一圈的过程。在此基础上，每一圈又包含4步：</p>
<ol>
<li>从左至右</li>
<li>从上至下</li>
<li>从右至左</li>
<li>从下至上</li>
</ol>
<p>这样经过一圈之后，就会回到这一圈的起点，接下来遍历下一圈，直到结束为止。</p>
<p>要注意几个地方：</p>
<ol>
<li><p>每一圈的起始坐标依次为<code>(1, 1)</code>，<code>(2, 2)</code>，….，因此每一圈结束后，<code>x</code>和<code>y</code>的起始位置都要分别加1才能进入下一圈；</p>
</li>
<li><p>循环的结束条件就是遍历到了最后一圈，其中要循环的圈数是<code>n/2</code>，这个可以举几个例子推导；另外一个要注意的就是当<code>n</code>为奇数时，最内圈是一个单独的值<code>n^2</code>，需要单独填充；</p>
</li>
<li><p>在遍历每一圈的4条边时，坚持左闭右开的原则：也就是说，每一条边的最后<code>n</code>个值属于下一条边。如下图所示，这是第一圈的情况。一定要记得设置一个<code>offset</code>，<strong>因为每遍历一圈，每条边的右边界就要收缩一位。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404102110076.png" alt="image-20240410211008731" style="zoom:33%;" /></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>;     <span class="comment">// 定义每一圈的起始坐标位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>;               <span class="comment">// 定义循环几圈</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>;                 <span class="comment">// 定义每一条边遍历的长度 </span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;                  <span class="comment">// 用来给矩阵赋值</span></span><br><span class="line">        <span class="keyword">while</span> (loop--) &#123;</span><br><span class="line">            <span class="type">int</span> i = startx;</span><br><span class="line">            <span class="type">int</span> j = starty;</span><br><span class="line">            <span class="comment">// 从左至右</span></span><br><span class="line">            <span class="keyword">for</span> (j; j&lt;n-offset; ++j) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="comment">// 从上至下</span></span><br><span class="line">            <span class="keyword">for</span> (i; i&lt;n-offset; ++i) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从右至左</span></span><br><span class="line">            <span class="keyword">for</span> (j; j&gt;starty; --j) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从下至上</span></span><br><span class="line">            <span class="keyword">for</span> (i; i&gt;startx; --i) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset++;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            res[n/<span class="number">2</span>][n/<span class="number">2</span>] = n*n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h1><p>实际上感觉链表的题都可以用快慢指针来解决。</p>
<h2 id="1、链表的定义"><a href="#1、链表的定义" class="headerlink" title="1、链表的定义"></a>1、链表的定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	ListNode *next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、删除链表元素"><a href="#2、删除链表元素" class="headerlink" title="2、删除链表元素"></a>2、删除链表元素</h2><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><p>举例来说，从<code>2-&gt;6-&gt;3</code>中删除节点6，需要完成以下几步：</p>
<p>（1）保存节点6，便于后续释放；</p>
<p>（2）将2的next改完3；</p>
<p>（3）释放原节点6。</p>
</li>
<li><p>注意要引入一个虚拟头结点，这样就可以避免在操作时还要区分头节点和非头节点两种情况。并且注意在最后返回真正的头节点时，返回的是<code>dummyhead-&gt;next</code>。</p>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *dummynode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummynode-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode *cur = dummynode;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode *tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummynode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummynode;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a>707. 设计链表</h3><p><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></p>
<ul>
<li><p>解题思路</p>
<p>这里有一个要注意的点，那就是对于这个<code>index</code>，在访问操作和增删操作时，遍历停止的位置是不同的：</p>
<ol>
<li>对于访问操作，需要<code>cur</code>正好停在<strong>下标为<code>index</code>的节点</strong>上，这样才能正确取到值；</li>
<li>对于增删操作，需要<code>cur</code>停在<strong>下标为<code>index</code>的前一个节点</strong>上，这样才方便进行增删操作。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (index-- &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        tmp-&gt;next = _dummyhead-&gt;next;</span><br><span class="line">        _dummyhead-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListNode *_dummyhead;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="19-删除链表的倒数第N个结点"><a href="#19-删除链表的倒数第N个结点" class="headerlink" title="19. 删除链表的倒数第N个结点"></a>19. 删除链表的倒数第N个结点</h3><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第N个结点</a></p>
<ul>
<li><p>解题思路</p>
<p>本题我采用了两趟扫描的方式进行解答。第一趟扫描确定了链表的长度，第二趟扫描则定位到了<strong>要删除结点的前一个结点</strong>。</p>
<ol>
<li><p>由于涉及到对头节点<code>head</code>的操作，因此定义一个<code>dummyhead</code>，避免需要对头结点单独操作；</p>
</li>
<li><p>如何定位到要删除结点的前一个结点，实际上需要分析<code>n</code>和<code>sz</code>之间的关系，如下图所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404120946983.png" alt="image-20240412094658218" style="zoom: 33%;" /></li>
</ol>
<blockquote>
<p>然而这道题我看了代码随想录提供的题解，实际上也是快慢指针法的一种变体，并且使用快慢指针法就可以无需先遍历一遍链表来求出链表的总长度。</p>
<p>只需要定义<code>fast</code>和<code>slow</code>两个指针</p>
<ul>
<li><code>fast</code>先走<code>n+1</code>步。之后<code>fast</code>和<code>slow</code>同时向前走；</li>
<li>当<code>fast</code>指向<code>nullptr</code>时，<code>slow</code>就正好指向要删除结点的前一个结点。</li>
</ul>
</blockquote>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *cur1 = head;</span><br><span class="line">        <span class="type">int</span> sz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            sz++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line">        ListNode *cur = dummyhead;</span><br><span class="line">        <span class="type">int</span> m = sz-n;</span><br><span class="line">        <span class="keyword">while</span> (m &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        head = dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyhead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、反转链表"><a href="#3、反转链表" class="headerlink" title="3、反转链表"></a>3、反转链表</h2><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><p>这道题实际上也相当于是双指针法中的快慢指针，通过定义两个指针<code>pre</code>和<code>cur</code>来依次遍历链表中的所有元素，并在遍历的过程中修改指针的指向。</p>
</li>
<li><p>有一个要注意的点在于：<code>while</code>循环的终止条件是<code>cur != nullptr</code>，若采用<code>cur-&gt;next != nullptr</code>，则最后一个节点不会被遍历到。</p>
</li>
</ol>
</li>
<li><p>AC代码（双指针法）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AC代码（递归法）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode *pre, ListNode *cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        ListNode *tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(cur, tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">NULL</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p>
<ul>
<li><p>解题思路</p>
<p>实际上这道题只要能够画图模拟出交换的过程，就没有问题了。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404111457295.png" alt="image-20240411145728810"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode *cur = dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode *tmp1 = cur-&gt;next;</span><br><span class="line">            ListNode *tmp2 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next = tmp1;</span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = tmp2;</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next;  <span class="comment">// cur要往后跳两步</span></span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyhead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、链表相交"><a href="#4、链表相交" class="headerlink" title="4、链表相交"></a>4、链表相交</h2><h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></p>
<ul>
<li><p>解题思路</p>
<p>主要有以下几个点要注意：</p>
<ol>
<li><p>最开始我额外定义了<code>a</code>和<code>b</code>用于去遍历两个链表来长度，实际上可以直接定义<code>curA</code>和<code>curB</code>，在遍历结束上让其重新指向头结点即可；</p>
</li>
<li><p>该题交点不是数值相等，而是指针相等！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (curA-&gt;val == curB-&gt;val)  <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">if</span> (curA == curB)			 <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size_a = <span class="number">0</span>, size_b = <span class="number">0</span>;</span><br><span class="line">        ListNode *curA = headA;</span><br><span class="line">        ListNode *curB = headB;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            size_a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">            size_b++;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">abs</span>(size_a - size_b);</span><br><span class="line">        <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// if (curA-&gt;val == curB-&gt;val) &#123;</span></span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></p>
<ul>
<li><p>解题思路</p>
<p>定义快慢指针<code>fast</code>和<code>slow</code>，其中<code>fast</code>每次走两个结点，<code>slow</code>每次走一个结点。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121316807.png" alt="image-20240412131623148"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *index1 = fast;</span><br><span class="line">                ListNode *index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三、哈希表"><a href="#三、哈希表" class="headerlink" title="三、哈希表"></a>三、哈希表</h1><h2 id="1、理论基础"><a href="#1、理论基础" class="headerlink" title="1、理论基础"></a>1、理论基础</h2><p>哈希表即为散列表，一般用于判断一个元素是否出现在集合里。</p>
<p>（1）常见的三种哈希函数：</p>
<ul>
<li><p>数组</p>
</li>
<li><p>集合（<code>set</code>）</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<ul>
<li><code>std::unordered_set</code>底层实现为哈希表；</li>
<li><code>std::set</code>和<code>std::multiset</code>的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以<code>key</code>值是有序的，但<code>key</code>不可以修改，改动<code>key</code>值会导致整棵树的错乱，所以只能删除和增加。</li>
</ul>
</li>
<li><p>映射（<code>map</code>）</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<ul>
<li><code>std::unordered_map</code>底层实现为哈希表；</li>
<li><code>std::map</code>和<code>std::multimap</code>的底层实现是红黑树。同理，<code>std::map</code>和<code>std::multimap</code>的<code>key</code>也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</li>
</ul>
</li>
</ul>
<p>（2）<code>std::unordered_set</code>提供了一系列方法来管理集合中的元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">插入元素：</span><br><span class="line">    <span class="built_in">insert</span>(): 向集合中插入元素。</span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">    <span class="built_in">erase</span>(): 删除集合中的元素。</span><br><span class="line">    <span class="built_in">clear</span>(): 清空集合中的所有元素。</span><br><span class="line"></span><br><span class="line">查找元素：</span><br><span class="line">    <span class="built_in">find</span>(): 查找集合中是否存在指定元素。</span><br><span class="line">    <span class="built_in">count</span>(): 统计集合中指定元素的个数。</span><br><span class="line"></span><br><span class="line">迭代器：</span><br><span class="line">    <span class="built_in">begin</span>(): 返回指向集合起始元素的迭代器。</span><br><span class="line">    <span class="built_in">end</span>(): 返回指向集合末尾元素的迭代器。</span><br><span class="line"></span><br><span class="line">大小和容量：</span><br><span class="line">    <span class="built_in">size</span>(): 返回集合中元素的个数。</span><br><span class="line">    <span class="built_in">empty</span>(): 检查集合是否为空。</span><br><span class="line"></span><br><span class="line">其他操作：</span><br><span class="line">    <span class="built_in">bucket_count</span>(): 返回集合中桶的数量。</span><br><span class="line">    <span class="built_in">load_factor</span>(): 返回集合的负载因子。</span><br><span class="line">    <span class="built_in">max_load_factor</span>(): 设置或返回集合的最大负载因子。</span><br></pre></td></tr></table></figure>

<p>（3）<code>std::set</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">插入元素：</span><br><span class="line">    <span class="built_in">insert</span>(): 向集合中插入元素。</span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">    <span class="built_in">erase</span>(): 删除集合中的元素。</span><br><span class="line">    <span class="built_in">clear</span>(): 清空集合中的所有元素。</span><br><span class="line"></span><br><span class="line">查找元素：</span><br><span class="line">    <span class="built_in">find</span>(): 查找集合中是否存在指定元素。</span><br><span class="line">    <span class="built_in">count</span>(): 统计集合中指定元素的个数。</span><br><span class="line"></span><br><span class="line">迭代器：</span><br><span class="line">    <span class="built_in">begin</span>(): 返回指向集合起始元素的迭代器。</span><br><span class="line">    <span class="built_in">end</span>(): 返回指向集合末尾元素的迭代器。</span><br><span class="line"></span><br><span class="line">大小和容量：</span><br><span class="line">    <span class="built_in">size</span>(): 返回集合中元素的个数。</span><br><span class="line">    <span class="built_in">empty</span>(): 检查集合是否为空。</span><br><span class="line"></span><br><span class="line">其他操作：</span><br><span class="line">    <span class="built_in">lower_bound</span>(): 返回指向大于或等于给定值的第一个元素的迭代器。</span><br><span class="line">    <span class="built_in">upper_bound</span>(): 返回指向大于给定值的第一个元素的迭代器。</span><br><span class="line">    <span class="built_in">equal_range</span>(): 返回集合中与给定值相等的元素范围。</span><br></pre></td></tr></table></figure>

<p>（3）<code>std::map</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">相关操作：</span><br><span class="line">    <span class="built_in">insert</span>()：用于将元素插入到map中。</span><br><span class="line">    <span class="built_in">erase</span>()：用于从map中删除指定的元素。</span><br><span class="line">    <span class="built_in">find</span>()：用于查找指定键对应的元素。</span><br><span class="line">    <span class="built_in">size</span>()：返回map中元素的数量。</span><br><span class="line">    <span class="built_in">clear</span>()：清空map中的所有元素。</span><br><span class="line">    <span class="built_in">begin</span>()：返回指向map起始元素的迭代器。</span><br><span class="line">    <span class="built_in">end</span>()：返回指向map末尾元素的迭代器。</span><br><span class="line">    <span class="built_in">count</span>()：返回指定键在map中出现的次数。</span><br></pre></td></tr></table></figure>

<h2 id="2、数组、set和map该如何选择？"><a href="#2、数组、set和map该如何选择？" class="headerlink" title="2、数组、set和map该如何选择？"></a>2、数组、set和map该如何选择？</h2><h3 id="什么时候选择用哈希表？"><a href="#什么时候选择用哈希表？" class="headerlink" title="什么时候选择用哈希表？"></a>什么时候选择用哈希表？</h3><p>当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候。</p>
<h3 id="什么时候选择用数组？"><a href="#什么时候选择用数组？" class="headerlink" title="什么时候选择用数组？"></a>什么时候选择用数组？</h3><p>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</p>
<p>如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费，此时不应使用数组。</p>
<h3 id="什么时候选择用set？"><a href="#什么时候选择用set？" class="headerlink" title="什么时候选择用set？"></a>什么时候选择用set？</h3><h3 id="什么时候选择用map？"><a href="#什么时候选择用map？" class="headerlink" title="什么时候选择用map？"></a>什么时候选择用map？</h3><h2 id="3、采用数组作为哈希函数"><a href="#3、采用数组作为哈希函数" class="headerlink" title="3、采用数组作为哈希函数"></a>3、采用数组作为哈希函数</h2><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h3><p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></p>
<ul>
<li><p>解题思路</p>
<p>由于“字母异位词”的定义是：两个词中每个字符出现的数组相同，而本题假设词中仅包含小写字母。因此直观的想法就是定义一个数组，先遍历<code>s</code>，将每个字符在数组中对应的位置加1，再遍历<code>t</code>，将每个字符在数组中对应的位置减1，这样若最终数组为全0，则这两个词是字母异位词。</p>
<p>但我陷入的思维瓶颈在于，我想的是按照<code>s</code>中每个字符出现的顺序定义数组<code>a</code>，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s = &quot;anagram&quot;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">// 其中下标1代表字符a</span></span><br></pre></td></tr></table></figure>

<p>但这样实际上就相当于是一个<code>map</code>了，操作变得格外复杂。</p>
<p>实际上，由于小写字母是有顺序的26个，因此只需要定义一个<code>int a[26]</code>，对于<code>s</code>中遍历到的每个字符，通过<code>s[i] - &#39;a&#39;</code>就可以定位到对应的下标。</p>
</li>
<li><p>易混知识点：</p>
<ol>
<li><p><code>a - &#39;a&#39;</code>:</p>
<ul>
<li><strong>用于将字母字符转换成一个从0开始的索引</strong>（例如，’a’变成0, ‘b’变成1, 等等）。</li>
</ul>
<ul>
<li>这里 <code>&#39;a&#39;</code> 是一个字符，其ASCII值是 97。</li>
<li>所以 <code>a - &#39;a&#39;</code> 实际上是计算 <code>97 - 97</code>，结果是 0。</li>
</ul>
</li>
<li><p><code>&#39;1&#39; - &#39;0&#39;</code> </p>
<ul>
<li><strong>计算两个字符的ASCII值之差，用于将字符表示的数字转换成其对应的整数值。</strong></li>
</ul>
<ul>
<li><code>&#39;1&#39;</code> 的 ASCII 值是 49，<code>&#39;0&#39;</code>是 48。所以，<code>&#39;1&#39;-&#39;0&#39;</code> 的计算过程是 <code>49-48</code>，结果是 1。</li>
</ul>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;t.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            record[t[j] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m=<span class="number">0</span>; m&lt;<span class="number">26</span>; ++m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[m] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></p>
<ul>
<li><p>解题思路</p>
<p>和242完全一致。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131611.png" alt="image-20240420113156470"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;magazine.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            record[magazine[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ransomNote.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            record[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m=<span class="number">0</span>; m&lt;<span class="number">26</span>; ++m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[m] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、采用set解题"><a href="#4、采用set解题" class="headerlink" title="4、采用set解题"></a>4、采用set解题</h2><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></p>
<ul>
<li><p>解题思路</p>
<p>由于本题的哈希值较少、较分散且跨度非常大，因此不能采用数组来实现。由于最终的结果无需排序，无重复，且只需要返回元素本身，不需要返回对应的下标，因此采用set即可。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131372.png" alt="image-20240420113120142"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; nums_set;</span><br><span class="line">        nums_set.<span class="built_in">insert</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> nums : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums_set.<span class="built_in">find</span>(nums) != nums_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></p>
<ul>
<li><p>解题思路</p>
<p>可以发现</p>
<ul>
<li>1）哈希值较分散，且跨度较大（不采用数组，应采用set或map）；</li>
<li>2）不需要同时保存元素和下标等成对出现，有对应关系的元素（不采用map）；</li>
<li>3）就是要找是否有重复的元素出现，因此采用set实现。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131501.png" alt="image-20240420113130345"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            sum += (n%<span class="number">10</span>) * (n%<span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; compare_set = &#123;n&#125;;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">        <span class="keyword">while</span> (sum != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compare_set.<span class="built_in">find</span>(sum) != compare_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// sum = getSum(sum);</span></span><br><span class="line">                compare_set.<span class="built_in">insert</span>(sum);</span><br><span class="line">                sum = <span class="built_in">getSum</span>(sum);  <span class="comment">// 这里一定要先把上一步计算得到的sum加入compare_set后，再计算新的sum</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、采用map解题"><a href="#5、采用map解题" class="headerlink" title="5、采用map解题"></a>5、采用map解题</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p>
<ul>
<li><p>解题思路</p>
<p>本题不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，<strong>需要使用key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p>
<p><strong>这道题目中并不需要key有序，选择std::unordered_map 效率更高</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131120.png" alt="image-20240420113138973"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; compare_map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = compare_map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (iter != compare_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second, i&#125;;           </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// compare_map.insert(nums[i], i);</span></span><br><span class="line">                compare_map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(nums[i], i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454. 四数相加II"></a>454. 四数相加II</h3><p><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加II</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131021.png" alt="image-20240420113148798"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; res1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num1 : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num2 : nums2) &#123;</span><br><span class="line">                <span class="type">int</span> sum = num1 + num2;</span><br><span class="line">                res1[sum]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num3 : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num4 : nums4) &#123;</span><br><span class="line">                <span class="type">int</span> sum = num3 + num4;</span><br><span class="line">                cnt += res1[-sum];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h1><h2 id="1、反转字符串"><a href="#1、反转字符串" class="headerlink" title="1、反转字符串"></a>1、反转字符串</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h3><ul>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> il = s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">auto</span> ir = s.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (il &lt;= ir) &#123;</span><br><span class="line">            <span class="comment">// char tmp;</span></span><br><span class="line">            <span class="comment">// tmp = *il;</span></span><br><span class="line">            <span class="comment">// *il = *ir;</span></span><br><span class="line">            <span class="comment">// *ir = tmp;</span></span><br><span class="line">            <span class="built_in">swap</span>(*il, *ir)</span><br><span class="line">            il++;</span><br><span class="line">            ir--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404222114861.png" alt="image-20240422211359195"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i+=<span class="number">2</span>*k) &#123;</span><br><span class="line">            <span class="type">int</span> start = i;</span><br><span class="line">            <span class="type">int</span> end = std::<span class="built_in">min</span>(start+k, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>()));</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+start, s.<span class="built_in">begin</span>()+end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a>151. 反转字符串中的单词</h3><ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404222114609.png" alt="image-20240422211419481"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string &amp;s, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=begin, j=end; i&lt;=j; ++i, --j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeSpace</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slow) &#123;</span><br><span class="line">                    s[slow++] = <span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">                    <span class="comment">// 当slow不在开头时，如果此时遇到了s[i]不为空格，则说明接下来需要从slow开始写新的单词了</span></span><br><span class="line">                    <span class="comment">// 因此手动控制添加一个空格</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow);  <span class="comment">// important</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeSpace</span>(s);</span><br><span class="line">        <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// for (int i=0; i&lt;s.size(); ++i) &#123;</span></span><br><span class="line">            <span class="comment">// if (s[i] == &#x27; &#x27;) &#123;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() || s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s, start, i<span class="number">-1</span>);  <span class="comment">// 翻转当前单词</span></span><br><span class="line">                <span class="comment">// start = i;</span></span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2、KMP算法"><a href="#2、KMP算法" class="headerlink" title="2、KMP算法"></a>2、KMP算法</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242023050.png" alt="image-20240424202306816"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> *next, <span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// i -&gt; 待匹配的后缀的末尾</span></span><br><span class="line">   <span class="comment">// j -&gt; 待匹配的前缀的末尾</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1. 初始化</span></span><br><span class="line">   <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">   next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">       <span class="comment">// 2. 处理前后缀不相同的情况</span></span><br><span class="line">       <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">           j = next[j<span class="number">-1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 3. 处理前后缀不相同的情况</span></span><br><span class="line">       <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">           j++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4. 更新next数组</span></span><br><span class="line">       next[i] = j;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 实现 strStr()</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li>求解字符串<code>s</code>的<code>next</code>数组；</li>
<li>定义<code>i</code>和<code>j</code>分别用来遍历<code>haystack</code>和<code>needle</code>，根据<code>next</code>数组调整对比的位置；</li>
<li>当<code>j</code>等于<code>needle</code>字符串的长度时，说明此时在<code>haystack</code>中找到了对应的匹配子串，因此返回该子串的开始下标。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line">        <span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;haystack.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> (i-needle.<span class="built_in">size</span>()+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a>459. 重复的子字符串</h3><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242023207.png" alt="image-20240424202348060"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> *next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; s[i]!=s[j]) &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(s.size())</span></span>;</span><br><span class="line">        <span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], s);</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(next[len<span class="number">-1</span>]!=<span class="number">0</span> &amp;&amp; (len%(len-next[len<span class="number">-1</span>])==<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="五、栈和队列"><a href="#五、栈和队列" class="headerlink" title="五、栈和队列"></a>五、栈和队列</h1><h2 id="1、栈和队列的理论基础"><a href="#1、栈和队列的理论基础" class="headerlink" title="1、栈和队列的理论基础"></a>1、栈和队列的理论基础</h2><ol>
<li><p>C++中stack 是容器么？</p>
<p>STL中stack往往不被归类为容器，而被归类为容器适配器（container adapter）。因为<strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p>
</li>
<li><p>我们使用的stack是属于哪个版本的STL？</p>
<p>SGI STL。</p>
</li>
<li><p>我们使用的STL中stack是如何实现的？</p>
<p>栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。<strong>常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。</strong></p>
<p>此外，<strong>SGI STL中队列一样是以deque为缺省情况下的底部结构。</strong></p>
<p>可以指定vector为栈的底层实现，初始化语句如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br></pre></td></tr></table></figure>

<p>也可以指定list 为起底层实现，初始化queue的语句如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242029774.png" alt="栈与队列理论3" style="zoom:50%;" />
</li>
<li><p>stack 提供迭代器来遍历stack空间么？</p>
<p>不提供。</p>
</li>
</ol>
<blockquote>
<p>三个最为普遍的STL版本：</p>
<ol>
<li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li>
<li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li>
<li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li>
</ol>
</blockquote>
<h2 id="2、栈的基本操作"><a href="#2、栈的基本操作" class="headerlink" title="2、栈的基本操作"></a>2、栈的基本操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">empty</span>();		<span class="comment">// 栈为空时返回1，非空返回0</span></span><br><span class="line">st.<span class="built_in">size</span>();		<span class="comment">// 返回栈中元素数量，size_type size() const;</span></span><br><span class="line">st.<span class="built_in">top</span>();		<span class="comment">// 返回栈顶元素，value_type&amp; top();</span></span><br><span class="line">st.<span class="built_in">push</span>(value);	<span class="comment">// 在栈顶插入一个元素，void push( const value_tyoe&amp; val );</span></span><br><span class="line">st.<span class="built_in">emplace</span>(value);	<span class="comment">// 在栈顶增加一个元素，void emplace( args&amp;&amp; args );</span></span><br><span class="line">st.<span class="built_in">pop</span>();			<span class="comment">// 栈顶元素出栈，即删除栈顶元素，void pop(); </span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st2;</span><br><span class="line">st1.<span class="built_in">swap</span>( st2 );	<span class="comment">// 交换两个栈中的内容，void swap( stack&amp; x );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与vector一样，重载了运算符：== != &lt; &lt;= &gt; &gt;=</span></span><br></pre></td></tr></table></figure>

<h2 id="3、队列的基本操作"><a href="#3、队列的基本操作" class="headerlink" title="3、队列的基本操作"></a>3、队列的基本操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">queue&lt;<span class="type">double</span>&gt; d;</span><br><span class="line">queue&lt;node&gt; n;  <span class="comment">// node是一个结构体</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">size</span>();	<span class="comment">// 返回q里元素个数</span></span><br><span class="line">q.<span class="built_in">empty</span>();	<span class="comment">// 返回q是否为空，空则返回1，否则返回0</span></span><br><span class="line">q.<span class="built_in">push</span>(k);	<span class="comment">// 在q的末尾插入k</span></span><br><span class="line">q.<span class="built_in">pop</span>();	<span class="comment">// 删掉q的第一个元素</span></span><br><span class="line">q.<span class="built_in">front</span>();	<span class="comment">// 返回q的第一个元素</span></span><br><span class="line">q.<span class="built_in">back</span>();	<span class="comment">// 返回q的末尾元素</span></span><br></pre></td></tr></table></figure>

<h2 id="4、对称匹配问题"><a href="#4、对称匹配问题" class="headerlink" title="4、对称匹配问题"></a>4、对称匹配问题</h2><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><p><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404252121420.png" alt="image-20240425212136199"></p>
<p>这里有两个要注意的地方：</p>
<ol>
<li><p>在遍历到左括号时，可以直接向栈中放入对应的右括号，这样遍历到右括号时可以直接比较是否相等；</p>
</li>
<li><p>注意在遍历到右括号时需要先判断此时栈是否为空。</p>
<p>对于<code>s = &quot;)&#123;&quot;</code>的情况，由于遍历到左括号时才会入栈，遍历到右括号时只执行比较操作，因此此时<code>st</code>为空，若直接执行<code>st.top()</code>会造成错误！</p>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">&#x27;)&#x27;</span> || i == <span class="string">&#x27;]&#x27;</span> || i == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == i) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h3><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404252121802.png" alt="image-20240425212128346"></p>
<p>注意输出的时候要进行一个reverse操作，因为栈是先进先出，和需要的结果次序是相反的。</p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == i) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res += st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h3><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261554153.png" alt="image-20240426155453665"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isDigit</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> token : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isDigit</span>(token)) &#123;</span><br><span class="line">                    <span class="comment">// 操作符</span></span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> tmp1 = res.<span class="built_in">top</span>();</span><br><span class="line">                    res.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> tmp2 = res.<span class="built_in">top</span>();</span><br><span class="line">                    res.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 + tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 - tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 * tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 / tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res.<span class="built_in">push</span>(tmp);   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push</span>(<span class="built_in">stoi</span>(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、队列解决相关问题"><a href="#5、队列解决相关问题" class="headerlink" title="5、队列解决相关问题"></a>5、队列解决相关问题</h2><blockquote>
<p>可用于以下题目：</p>
<ol>
<li>单调队列解决“<strong>区间内的最大值</strong>”问题；</li>
<li>优先级队列解决“<strong>统计元素出现频率</strong>”问题</li>
</ol>
</blockquote>
<h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261557720.png" alt="image-20240426155748508"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            <span class="comment">// 如果val == que.front()</span></span><br><span class="line">            <span class="comment">// 说明队列要pop()的元素为此时滑动窗口的最大值，需要执行实际的pop()操作</span></span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          que.<span class="built_in">push_back</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getMaxValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">      MyQueue que;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">      <span class="comment">// 先将前k个元素放进单调队列</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; ++i) &#123;</span><br><span class="line">        que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// res先记录这前k个元素的最大值</span></span><br><span class="line">      res.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=k; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        que.<span class="built_in">pop</span>(nums[i-k]);</span><br><span class="line">        que.<span class="built_in">push</span>((nums[i]));</span><br><span class="line">        res.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h3><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347.前 K 个高频元素</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261557691.png" alt="image-20240426155759481"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// step1</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            map[num]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step2</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pri_que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it=map.<span class="built_in">begin</span>(); it!=map.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            pri_que.<span class="built_in">push</span>(*it);</span><br><span class="line">            <span class="comment">// step3</span></span><br><span class="line">            <span class="keyword">if</span> (pri_que.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                pri_que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step4</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=k<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">            res[i] = pri_que.<span class="built_in">top</span>().first;</span><br><span class="line">            pri_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="六、二叉树"><a href="#六、二叉树" class="headerlink" title="六、二叉树"></a>六、二叉树</h1><h2 id="1、理论基础-1"><a href="#1、理论基础-1" class="headerlink" title="1、理论基础"></a>1、理论基础</h2><h3 id="（1）分类"><a href="#（1）分类" class="headerlink" title="（1）分类"></a>（1）分类</h3><blockquote>
<p>度：二叉树中某个结点的子结点或直接后继结点的个数。叶子节点的度为0。</p>
</blockquote>
<ul>
<li><p>满二叉树：一课二叉树上只有度为0的结点和度为2的结点，且度为0的结点在同一层上，则为满二叉树。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035207.png" alt="img"></p>
</li>
<li><p>完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035385.png" alt="img"></p>
</li>
<li><p>二叉搜索树：有序树。1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；3）左、右子树也分别为二叉排序树。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035643.png" alt="img"></p>
</li>
<li><p>平衡二叉搜索树：又称AVL（Adelson-Velsky and Landis）树。它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035200.png" alt="img"></p>
</li>
</ul>
<h3 id="（2）存储方式"><a href="#（2）存储方式" class="headerlink" title="（2）存储方式"></a>（2）存储方式</h3><ul>
<li><p>链式存储：指针。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271036601.png" alt="img"></p>
</li>
<li><p>顺序存储：数组。此时若父结点下标为<code>i</code>，则左孩子下标为<code>i*2+1</code>，右孩子下标为<code>i*2+2</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271036512.png" alt="img"></p>
</li>
</ul>
<h3 id="（3）遍历方式"><a href="#（3）遍历方式" class="headerlink" title="（3）遍历方式"></a>（3）遍历方式</h3><ul>
<li><p>深度优先遍历</p>
<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271039957.png" alt="img"></p>
</li>
<li><p>广度优先遍历</p>
<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ul>
<p>栈其实就是递归的一种实现结构，<strong>深度优先遍历可以借助栈来使用递归的方式实现。而广度优先遍历一般使用队列来实现</strong>。</p>
<h3 id="（4）定义方式"><a href="#（4）定义方式" class="headerlink" title="（4）定义方式"></a>（4）定义方式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	TreeNode *left;</span><br><span class="line">	TreeNode *right;</span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、深度优先遍历"><a href="#2、深度优先遍历" class="headerlink" title="2、深度优先遍历"></a>2、深度优先遍历</h2><p>递归三要素：</p>
<ul>
<li>确定递归函数的参数和返回值：如果在递归过程中需要处理某些参数，就在递归函数中加上这个参数；</li>
<li>确定终止条件</li>
<li>确定单层递归的逻辑</li>
</ul>
<h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h3><ul>
<li><p>AC代码（递归遍历）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, v);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">traversal</span>(root, v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代遍历的思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292106760.png" alt="image-20240429210650617"></p>
</li>
<li><p>AC代码（迭代遍历）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> v; &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *node = st.<span class="built_in">top</span>();                  <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            v.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) &#123; st.<span class="built_in">push</span>(node-&gt;right); &#125;  <span class="comment">// 右（入栈时先入右，出栈时才能先出左）</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) &#123; st.<span class="built_in">push</span>(node-&gt;left); &#125;    <span class="comment">// 左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h3><ul>
<li><p>AC代码（递归遍历）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, v);</span><br><span class="line">        v.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">traversal</span>(root, v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AC代码（迭代遍历）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历到最左侧的左孩子</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;        <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将左孩子加入完毕，开始从栈中弹出元素</span></span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                v.<span class="built_in">push_back</span>(cur-&gt;val);  <span class="comment">// 中</span></span><br><span class="line">                cur = cur-&gt;right;       <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h3><ul>
<li><p>AC代码（递归遍历）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;int&gt; v;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        while (cur != nullptr || !st.empty()) &#123;</span><br><span class="line">            if (cur != nullptr) &#123;</span><br><span class="line">                // 遍历到最左侧的左孩子</span><br><span class="line">                st.push(cur);</span><br><span class="line">                cur = cur-&gt;left;        // 左</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 将左孩子加入完毕，开始从栈中弹出元素</span><br><span class="line">                cur = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                v.push_back(cur-&gt;val);  // 中</span><br><span class="line">                cur = cur-&gt;right;       // 右</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AC代码（迭代遍历）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> v; &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            v.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123; st.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123; st.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、广度优先遍历"><a href="#3、广度优先遍历" class="headerlink" title="3、广度优先遍历"></a>3、广度优先遍历</h2><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292104737.png" alt="image-20240429210415502"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                v.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h3><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292105474.png" alt="image-20240429210504161"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                v.<span class="built_in">push_back</span>(node-&gt;val);  <span class="comment">// 方法1</span></span><br><span class="line">                <span class="comment">// if (i == (size - 1)) result.push_back(node-&gt;val);  // 方法2</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(*(v.<span class="built_in">end</span>()<span class="number">-1</span>));  <span class="comment">// 方法1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429. N叉树的层序遍历"></a>429. N叉树的层序遍历</h3><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N叉树的层序遍历</a></p>
<ul>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Node* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;children.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 将节点孩子加入队列</span></span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;children[i]) que.<span class="built_in">push</span>(node-&gt;children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h3><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292105156.png" alt="image-20240429210553988"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node *node;</span><br><span class="line">            Node *nodePre;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    nodePre = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    node = nodePre;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    nodePre-&gt;next = node;  <span class="comment">// 本层前一个节点(nodePre)的next指向本节点(node)</span></span><br><span class="line">                    nodePre = nodePre-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nodePre-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 本层最后一个节点指向NULL</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、二叉树的属性"><a href="#4、二叉树的属性" class="headerlink" title="4、二叉树的属性"></a>4、二叉树的属性</h2><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h3><p><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404301959840.png" alt="image-20240430195926626"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode *left, TreeNode *right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);</span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> outside &amp;&amp; inside;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h3><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p>
<ul>
<li><p>解题思路</p>
<blockquote>
<ul>
<li>二叉树节点的<strong>深度</strong>：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）– <strong>前序遍历</strong></li>
<li>二叉树节点的<strong>高度</strong>：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）– <strong>后序遍历</strong></li>
</ul>
</blockquote>
<p>本题牢记一点，<strong>根节点的高度就是二叉树的最大深度</strong>。因此采用后序遍历。</p>
</li>
<li><p>AC代码（解法1：层序遍历）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="type">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
<li><p>AC代码（解法2：递归法）</p>
<p>利用<strong>根节点的高度就是二叉树的最大深度</strong>这一理论。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getdepth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftdepth = <span class="built_in">getdepth</span>(node-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightdepth = <span class="built_in">getdepth</span>(node-&gt;right);     <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth); <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getdepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="559-n叉树的最大深度"><a href="#559-n叉树的最大深度" class="headerlink" title="559. n叉树的最大深度"></a>559. n叉树的最大深度</h3><p><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. n叉树的最大深度</a></p>
<ul>
<li><p>AC代码（迭代法）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;node-&gt;children.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[i]) &#123;</span><br><span class="line">                depth = <span class="built_in">max</span>(depth, <span class="built_in">getDepth</span>(node-&gt;children[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getDepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h3><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405071213847.png" alt="image-20240507121354366"></p>
</li>
<li><p>AC代码（迭代法）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">getDepth</span>(node-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">getDepth</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;left &amp;&amp; node-&gt;right) &#123; <span class="keyword">return</span> <span class="number">1</span> + rightDepth; &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left &amp;&amp; !node-&gt;right) &#123; <span class="keyword">return</span> <span class="number">1</span> + leftDepth; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> depth = <span class="built_in">getDepth</span>(root);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>精简版</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a>222. 完全二叉树的节点个数</h3><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><strong>完全二叉树</strong>只有两种情况：</li>
</ol>
<ul>
<li>满二叉树；<strong>（此时假设树深度为N，节点数为2^N-1）</strong></li>
<li>最后一层叶子节点没有满。<strong>（分别递归左右孩子，地轨道某一深度一定会有左孩子或右孩子为满二叉树）</strong></li>
</ul>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124092543662.png" alt="222.完全二叉树的节点个数" style="zoom:50%;" />

<ol start="2">
<li><p>如何判断<strong>完全二叉树是否是满二叉树</strong>？</p>
<p>在一棵完全二叉树中，如果递归向左遍历的深度等于递归向右遍历的深度，那就说明是满二叉树。</p>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163554.png" alt="img" style="zoom:50%;" />

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163709.png" alt="img" style="zoom:50%;" /></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="comment">// 开始根据左深度和右深度是否相同来判断该子树是不是满二叉树</span></span><br><span class="line">        TreeNode *left = root-&gt;left;</span><br><span class="line">        TreeNode *right = root-&gt;right;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="number">0</span>, rightDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left) &#123;</span><br><span class="line">            left = left-&gt;left;  <span class="comment">// 向左遍历</span></span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right) &#123;</span><br><span class="line">            right = right-&gt;right;  <span class="comment">// 向右遍历</span></span><br><span class="line">            rightDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h3><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></p>
<ul>
<li><p>解题思路</p>
<p>首先，<strong>求高度还是用到了后序遍历。</strong></p>
<p>递归三部曲分析：</p>
<ol>
<li><p>明确递归参数和返回值</p>
<ul>
<li>参数：当前传入节点</li>
<li>返回值：以当前传入节点为根节点的树的高度。但如果已经不是二叉平衡树了，则直接返回-1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode *node)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>明确终止条件</p>
<p>遇到了空节点即返回</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>明确单层递归的逻辑</p>
<p>分别求出其左右子树的高度：</p>
<ul>
<li>若差值小于等于1，则返回当前二叉树的高度</li>
<li>否则返回-1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line"><span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"><span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line"><span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;   <span class="comment">// 中</span></span><br><span class="line">    height =  <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    height = <span class="number">1</span> + <span class="built_in">max</span>(leftHeight, rightHeight);  <span class="comment">// 以当前节点为根节点的树的最大高度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> height;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">        <span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>+<span class="built_in">max</span>(leftHeight, rightHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHeight</span>(root) != <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h3><p><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><p>递归函数参数及返回值</p>
<ul>
<li>传入根节点、记录每一条路径的path、存放结果集的result</li>
<li>无需返回值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;string&gt; &amp;result)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归终止条件</p>
<p>本题不能写<code>if(cur == nullptr)</code>，因为这样写就直接跳过了叶子节点，而本题需要找到叶子节点所在处并进行相应的处理逻辑，因此终止条件如下，且此处无需判断cur是否为空，将在单层递归逻辑中进行判断。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 终止处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于终止处理逻辑，这里使用vector 结构path来记录路径，所以要把vector 结构的path转为string格式，再把这个string 放进 result里。<strong>那么为什么使用了vector 结构来记录路径呢？</strong>  因为在下面处理单层递归逻辑的时候，要做回溯，使用vector方便来做回溯。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123; <span class="comment">// 遇到叶子节点</span></span><br><span class="line">    string sPath;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123; <span class="comment">// 将path里记录的路径转为string格式</span></span><br><span class="line">        sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">        sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>() - <span class="number">1</span>]); <span class="comment">// 记录最后一个节点（叶子节点）</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(sPath); <span class="comment">// 收集一个路径</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单层递归逻辑</p>
<p>因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中，<code>path.push_back(cur-&gt;val);</code>。</p>
<ul>
<li><p>递归与回溯</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归和回溯一一对应，写到一个大括号里</span></span><br><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>AC代码（迭代法）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;string&gt; &amp;result)</span> </span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(cur-&gt;val);  <span class="comment">// 中（写在最前面是为了把这条路径的所有节点都加进path中）</span></span><br><span class="line">        <span class="comment">// 现在开始处理叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            string sPath;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;path.<span class="built_in">size</span>()<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">                sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">                sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(sPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;left, path, result);  <span class="comment">// 左</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;right, path, result); <span class="comment">// 右</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">        <span class="built_in">traversal</span>(root, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a>404. 左叶子之和</h3><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081211988.png" alt="image-20240508121115767"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> lval = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123;</span><br><span class="line">            lval = root-&gt;left-&gt;val;  <span class="comment">// 此处的root是左叶子的父结点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rval = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> val = lval + rval;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a>513. 找树左下角的值</h3><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></p>
<ul>
<li><p>解题思路</p>
<p>本题采用层序遍历的方式即可，只需要求最后一层的第一个元素。</p>
</li>
<li><p>AC代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                v.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = res[res.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h3><p><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></p>
<ul>
<li><p>AC代码（版本1，参考257的解法）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;path, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历到叶子节点了，开始计算和</span></span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> i : path) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == targetSum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> fleft = <span class="literal">false</span>, fright = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">            fleft = <span class="built_in">traversal</span>(cur-&gt;left, path, targetSum);  <span class="comment">// 左</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">            fright = <span class="built_in">traversal</span>(cur-&gt;right, path, targetSum); <span class="comment">// 右</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fleft || fright;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">traversal</span>(root, path, targetSum);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AC代码2（在遍历节点时就跟着计算和）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遇到叶子节点，并且计数为0</span></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遇到叶子节点直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            count -= cur-&gt;left-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;left-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            count -= cur-&gt;right-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;right-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、二叉树的修改与构造"><a href="#5、二叉树的修改与构造" class="headerlink" title="5、二叉树的修改与构造"></a>5、二叉树的修改与构造</h2><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h3><p><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></p>
<ul>
<li><p>解题思路</p>
<p>这道题只需要在遍历的过程中将每个节点的左右孩子翻转一遍，最终就可以达到整体翻转的效果。<strong>注意本题不能使用中序遍历，因为会把某些节点的左右孩子翻转两次。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302000083.png" alt="image-20240430200020967" style="zoom:67%;" />
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversel</span><span class="params">(TreeNode *cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left || cur-&gt;right) &#123;</span><br><span class="line">            TreeNode *tmp;</span><br><span class="line">            tmp = cur-&gt;left;</span><br><span class="line">            cur-&gt;left = cur-&gt;right;</span><br><span class="line">            cur-&gt;right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traversel</span>(cur-&gt;left);</span><br><span class="line">        <span class="built_in">traversel</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversel</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a>106. 从中序与后序遍历序列构造二叉树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081210471.png" alt="image-20240508121021941"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;inorder, vector&lt;<span class="type">int</span>&gt; &amp;postorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s1. 如果数组大小为零的话，说明是空节点</span></span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s2. 后序数组的最后一个元素就是当前的root</span></span><br><span class="line">        <span class="type">int</span> rootValue = postorder[postorder.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s3. 找到后序数组最后一个元素在中序数组的位置，作为切割点</span></span><br><span class="line">        <span class="type">int</span> cut1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootValue) &#123;</span><br><span class="line">                cut1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s4. 切割中序数组，切成中序左数组和中序右数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_inorder</span><span class="params">(inorder.begin(), inorder.begin()+cut1)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_inorder</span><span class="params">(inorder.begin()+cut1+<span class="number">1</span>, inorder.end())</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// s5. 切割后序数组，切成后序左数组和后序右数组</span></span><br><span class="line">        postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>() - <span class="number">1</span>);  <span class="comment">// [important]postorder 舍弃末尾元素</span></span><br><span class="line">        <span class="type">int</span> cut2 = left_inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_postorder</span><span class="params">(postorder.begin(), postorder.begin()+cut2)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_postorder</span><span class="params">(postorder.begin()+cut2, postorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s6. 递归处理左区间和右区间</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(left_inorder, left_postorder);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(right_inorder, right_postorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>)  &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p>
<ul>
<li><p>解题思路</p>
<p>步骤如下：</p>
<ol>
<li>若数组为空，则说明是空树；</li>
<li>若数组非空，则取前序数组的第一个元素作为root；</li>
<li>找到前序数组的第一个元素在中序数组的位置，作为切割点；</li>
<li>切割中序数组，切成中序左数组和中序右数组；</li>
<li>切割前序数组，切成前序左树组和前序右数组；</li>
<li>递归处理左区间和右区间。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s1. </span></span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s2. </span></span><br><span class="line">        <span class="type">int</span> rootValue = preorder[<span class="number">0</span>];</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">size</span>() == <span class="number">1</span>) &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s3. </span></span><br><span class="line">        <span class="type">int</span> cut1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootValue) &#123;</span><br><span class="line">                cut1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s4. </span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_inorder</span><span class="params">(inorder.begin(), inorder.begin()+cut1)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_inorder</span><span class="params">(inorder.begin()+cut1+<span class="number">1</span>, inorder.end())</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// s5. </span></span><br><span class="line">        preorder.<span class="built_in">erase</span>(preorder.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="type">int</span> cut2 = left_inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_preorder</span><span class="params">(preorder.begin(), preorder.begin()+cut2)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_preorder</span><span class="params">(preorder.begin()+cut2, preorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s6. </span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(left_preorder, left_inorder);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(right_preorder, right_inorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || preorder.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(preorder, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6、求二叉搜索树的属性"><a href="#6、求二叉搜索树的属性" class="headerlink" title="6、求二叉搜索树的属性"></a>6、求二叉搜索树的属性</h2><h2 id="7、二叉树公共祖先问题"><a href="#7、二叉树公共祖先问题" class="headerlink" title="7、二叉树公共祖先问题"></a>7、二叉树公共祖先问题</h2><h2 id="8、二叉搜索数的修改与构造"><a href="#8、二叉搜索数的修改与构造" class="headerlink" title="8、二叉搜索数的修改与构造"></a>8、二叉搜索数的修改与构造</h2><h1 id="七、回溯"><a href="#七、回溯" class="headerlink" title="七、回溯"></a>七、回溯</h1><h2 id="1、回溯法解决的问题"><a href="#1、回溯法解决的问题" class="headerlink" title="1、回溯法解决的问题"></a>1、回溯法解决的问题</h2><p>回溯法一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<h2 id="2、回溯算法模板框架如下："><a href="#2、回溯算法模板框架如下：" class="headerlink" title="2、回溯算法模板框架如下："></a>2、回溯算法模板框架如下：</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用树形结构来模拟回溯的过程：</p>
<ol>
<li>对于组合问题来说，目标是找树的叶子节点。横向代表不同的组合方式，纵向的每一根树枝代表了一种具体的组合；</li>
<li>对于切割问题来说，目标是找树的叶子节点。横向代表不同的切割方式，纵向的每一根树枝代表了一种具体的切割；</li>
<li>对于组合问题来说，目标是找树的所有节点。</li>
</ol>
<h1 id="八、贪心"><a href="#八、贪心" class="headerlink" title="八、贪心"></a>八、贪心</h1><h1 id="九、动态规划"><a href="#九、动态规划" class="headerlink" title="九、动态规划"></a>九、动态规划</h1><p><strong>对于动态规划问题，拆解为如下五步曲：</strong></p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>C++ Allocator</title>
    <url>/2024/05/06/1%20C++/STL/C++%20Allocator/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="1、GNU-allocator总述（pool-allocator"><a href="#1、GNU-allocator总述（pool-allocator" class="headerlink" title="1、GNU allocator总述（pool_allocator)"></a>1、GNU allocator总述（pool_allocator)</h2><p>allocator，作为一个STL的分配器，其底层是由<code>new/delete</code>进行实现的。</p>
<h3 id="在GNU的编译器里面"><a href="#在GNU的编译器里面" class="headerlink" title="在GNU的编译器里面"></a><strong>在GNU的编译器里面</strong></h3><ul>
<li>对于比较大的或者一般的allocator，我们一般调用<code>::operator new/delete allocator和deallocate</code>进行</li>
<li>对于较小块内存的分配，在GNU2.9里面有一个比较特殊的设计。</li>
</ul>
<!--more-->

<h3 id="GNU-pool-allocator分配器简述"><a href="#GNU-pool-allocator分配器简述" class="headerlink" title="GNU pool allocator分配器简述"></a><strong>GNU pool allocator分配器简述</strong></h3><ul>
<li><p>核心思想</p>
<ul>
<li><p>首先分配一个数组，里面含有16个指针，这16个指针在未来会再一次指向对应的内存空间，每一个指针都会负责比前一个指针多8bytes的数据。</p>
</li>
<li><p>每一个指针再一次分配的时候。一般会分配40个和对象+一个上一个分配空间&#x2F;4的一样大的空间，每一个空间里面包括一个嵌入式指针，指向下一块空间，其中20个作为现在的用池，用来进行对象的安放。剩下的就作为后面的战备池每一次分配出去一个，指针就往下移动一个。</p>
</li>
<li><p>当需要分配新的对象的时候</p>
<ul>
<li>如果战备池子有充足的空间，就从战备池子取一定的空间，具体看战备池能取出多少就取出多少，最多不超过20个。<ul>
<li>如果战备池子没有多余的空间，就重新分配一块内存，同时如果战备池的空间不足以分配当前一个对象，就将这个空间交还给对应的链表。</li>
<li>如果在无法分配内存的情况下，就会从现有的，比他大一级的池子（右边第一个池子）里面分配内存，只是裁剪出来一块挂到对应的链表中。当右边没有的时候就会分配失败。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>优点与缺点</p>
<ul>
<li><p>优点</p>
<ul>
<li>减少了cookie，使得软件拥有了更大的内存分配空间。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>无法释放已经分配的内存，存在着不少的内存浪费的情况。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2、loki-allocator"><a href="#2、loki-allocator" class="headerlink" title="2、loki allocator"></a>2、loki allocator</h2><p>loki allocator是分配器里面一个比较特殊的设计。</p>
<h3 id="设计框架"><a href="#设计框架" class="headerlink" title="设计框架"></a><strong>设计框架</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">底层：</span><br><span class="line">   底层作为alloc直接管理的一个基层，他是中层的一个嵌套类</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">chunk</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>* pData;  --指针，指向分配内存的头部</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> firstAvailableBlock;--记录下一个可以供给分配的内存</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> blocks;--记录总的可分配格子的大小</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">中层：</span><br><span class="line">   中层作为alloc管理基层的工具，以一个小型的vector为基础。担任分配和释放的操作</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixedAlloctor</span>&#123;</span><br><span class="line">	vector&lt;chuck&gt; chucks; --管理底层的<span class="function">vector</span></span><br><span class="line"><span class="function">	chuck* <span class="title">allocChucks</span><span class="params">()</span></span>; --分配<span class="function">chuck</span></span><br><span class="line"><span class="function">	chuck* <span class="title">deallocChucks</span><span class="params">()</span></span>; --销毁chuck</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">高层：</span><br><span class="line">	高层继承中层，作为主要的对外接口，去分配和释放内存，他的客户是STL</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallObjAllocator</span>&#123;</span><br><span class="line">	vector&lt;FixedAllocator&gt; pool; --管理中层的vector</span><br><span class="line">	FixedAllocator* pLastAlloc;  --指向最后一个可以分配的alloc</span><br><span class="line">	FixedAllocator* pLastDealloc;--指向最后一个销毁的alloc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><p>1.首先，创建一个smallobjallocator，然后制定分配的内存和大小。</p>
<ul>
<li>一般情况下，一次性默认要4096字节空间，超过256字节就不使用loki了。</li>
</ul>
<p>2.每一次进行分配内存的时候指定内存大小，然后进行分配。</p>
<p>3.在释放的时候需要其制定的内存大小和指针就可以进行释放了。</p>
<h3 id="工作逻辑"><a href="#工作逻辑" class="headerlink" title="工作逻辑"></a><strong>工作逻辑</strong></h3><p>chuck</p>
<p>1.chuck首先按照上层的要求进行初始化。调用init。初始化大小，初始化内存空间及其对应的数字</p>
<p>2.然后索要对应的内存，进行分配，如果分配的内存大小和之前相同，就从之前的取</p>
<p>3.在alloc的时候</p>
<ul>
<li>chuck首先找到下一个可以分配的内存，将其分配出去，</li>
<li>同时将内存写好中的数字记录下来，这个数字就是下一个可以分配的内存空间</li>
</ul>
<p>4.在dealloc的时候</p>
<ul>
<li><p>首先利用从中间向两边找的准则，找到对应的位置（中间层，剩下的是底层）</p>
</li>
<li><p>chuck然后找到将进来的指针进行强制类型转换</p>
</li>
<li><p>然后将原先的下一个内存的数字给他</p>
</li>
<li><p>然后通过指针去找他和之前有几个格子的距离，为firstAvailblocks赋予新的值</p>
</li>
</ul>
<p>其他两层按照vector的方式去进行操作和管理。</p>
<h2 id="3、new-allocator与malloc-allocator"><a href="#3、new-allocator与malloc-allocator" class="headerlink" title="3、new_allocator与malloc_allocator"></a>3、new_allocator与malloc_allocator</h2><p>new_allocator与malloc-allocator唯一的区别就是。</p>
<ul>
<li>new allocator可以重载operator::new,可以实现自由的构建malloc不行，他直接调用malloc去使用。</li>
<li>重载operator::new的一个功能就是可以在一定程度上接管alloc所作的工作，去灵活的管理。</li>
</ul>
<h2 id="4、array-allocator"><a href="#4、array-allocator" class="headerlink" title="4、array_allocator"></a>4、array_allocator</h2><p>array_allocator是一个数组类型的分配器，他可以分配固定的内存。</p>
<p>在main程序运行之前，底层函数就已经通过固定的程序让array_allocator这个其依赖的基本数据结构array可用了。</p>
<h2 id="5、debug-allocator"><a href="#5、debug-allocator" class="headerlink" title="5、debug_allocator"></a>5、debug_allocator</h2><p>这个是一个allocator的适配器，类似于stack，他可以帮助程序员调试allocator的内部操作，没什么用。</p>
<h2 id="6、bitmap-allocator"><a href="#6、bitmap-allocator" class="headerlink" title="6、bitmap_allocator"></a>6、bitmap_allocator</h2><h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a><strong>层次结构</strong></h3><p>bitmap_allocator结构分为两层</p>
<p>记录层：这层主要用来记录那些blocks的内存被分配掉了,private&#x2F;public关系省略了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">bitmap</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> useCount;  <span class="comment">//记录使用的blocks数目</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> superBlockSize;  <span class="comment">//记录整个记录层和管理层一共占用的空间总数</span></span><br><span class="line">	<span class="type">char</span> bitmapGuide[bitmapSize] = ‘F’;  <span class="comment">//用16个字符记录使用的数目,bitmapSize是一个可以变的数目，后续根据是否需要扩容决定</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>管理层：这层主要用来管理对应的分配出来的blocks，做实质的alloc&#x2F;dealloc操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">block</span>&#123;</span><br><span class="line">	T *p; --有一个指针</span><br><span class="line">	<span class="built_in">block</span>(<span class="type">int</span> number = <span class="number">4096</span>)&#123;</span><br><span class="line">		p=<span class="keyword">new</span> <span class="built_in">T</span>(number/<span class="built_in">sizeof</span>(<span class="built_in">T</span>()))  <span class="comment">// 为T分配一块内存，这块内存按照传入的字节大小去除一个T对象本身的大小（注意这段代码是伪代码，本身是错误的）</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">tempate &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> superBlock&#123;</span><br><span class="line">	block&lt;T&gt; blocks[<span class="number">64</span>]  <span class="comment">// 这块默认是64个blocks，64个blocks组成一个superBlocks</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在有以上两个之后，然后</span></span><br><span class="line">superBlock&lt;T&gt; blockss;  <span class="comment">// 创建内存</span></span><br><span class="line"><span class="function">mini_vector&lt;T*&gt; <span class="title">vector</span><span class="params">(<span class="number">2</span>,<span class="literal">nullptr</span>)</span></span>;  <span class="comment">// 创建一个minivector，这个是用来储存blockss的头尾指针的</span></span><br><span class="line">vector[<span class="number">0</span>]=&amp;(blockss[<span class="number">0</span>]);</span><br><span class="line">vector[<span class="number">1</span>]=&amp;(blockss[<span class="number">63</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h3><p>具体图解见笔记。</p>
<ul>
<li><p>对于少量内存分配</p>
<ul>
<li><p>选择一格，把他们分配出去</p>
</li>
<li><p>在记录层记录blocks数目的记录加一（已经使用一格）</p>
</li>
<li><p>更改bitmap</p>
<ul>
<li>注意，bitmap的读条方式是，bitmap地图从左往右，对应内存池的从右边向左边的格子，利用二进制表明其是否被占用</li>
</ul>
</li>
</ul>
</li>
<li><p>对于大量内存分配</p>
<ul>
<li><p>如果在一个bitmap不够的情况下就变成原来的两倍，也就是bitmap大小为32，有128个blocks</p>
</li>
<li><p>后面每一次分配都会加量一次（原先x2），每一次全回收都会减量一次（原先&#x2F;2）</p>
</li>
</ul>
</li>
<li><p>对于回收</p>
<ul>
<li><p>和malloc一样，他会有一个“垃圾寄存处”，当不需要的时候，会重新分配一个minivector来寄存这些已经全回收的内存，如果需要的话也是优先看手上有没有</p>
</li>
<li><p>如果有则使用，当有64个组以上的minivector的时候，进行回收。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
  </entry>
  <entry>
    <title>常用STL容器</title>
    <url>/2024/06/11/1%20C++/STL/%E5%B8%B8%E7%94%A8STL%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h1><h2 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a>std::vector</h2><h3 id="1、基本用法"><a href="#1、基本用法" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; c;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; d;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">e</span><span class="params">(n, <span class="number">10</span>)</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; f&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> m = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">g</span><span class="params">(arr, arr+m)</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">h</span><span class="params">(g.begin(), g.end())</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素操作</span></span><br><span class="line">    a.reverse(N);			<span class="comment">// 预分配N个元素的内存，注意reserve操作只是预分配内存，并不会改变Vector的大小</span></span><br><span class="line">    a.push_back(val);		<span class="comment">// 时间复杂度为O(1)</span></span><br><span class="line">    a.emplace_back(val);  	<span class="comment">// 时间复杂度为O(1)</span></span><br><span class="line">    a.pop_back();			<span class="comment">// 时间复杂度为O(1)</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> size = a.size(); <span class="comment">// 时间复杂度为O(1)</span></span><br><span class="line">    a.resize(size1);  		<span class="comment">// 缩容，size1 &lt; size</span></span><br><span class="line">    a.resize(size2, <span class="number">10</span>);  	<span class="comment">// 扩容，size2 &gt; size，且新增元素初始化为10</span></span><br><span class="line">    <span class="type">int</span> first = a.front();</span><br><span class="line">    <span class="type">int</span> last = a.back();</span><br><span class="line"></span><br><span class="line">    a.insert(a.begin(), <span class="number">0</span>);   			<span class="comment">// 时间复杂度为O(N)</span></span><br><span class="line">    a.erase(a.begin());          		<span class="comment">// erase()有两种方法，时间复杂度都为O(N)</span></span><br><span class="line">    a.erase(a.begin(), a.end()<span class="number">-1</span>);  	<span class="comment">// erase(first,last)删除[first, last)内的所有元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> is_empty = a.empty();</span><br><span class="line">    a.clear();        <span class="comment">// 时间复杂度为O(N)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// algorithm常用函数</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">    sort(a.begin(),a.end());  				<span class="comment">// 对[a.begin(), a.end())进行从大到小排序</span></span><br><span class="line">    reverse(a.begin(),a.end());  			<span class="comment">// 对[a.begin(), a.end())进行倒置，但不排序</span></span><br><span class="line">    copy(a.begin(),a.end(),b.begin()+<span class="number">1</span>); 	<span class="comment">// 把[a.begin(), a.end())的元素复制到b中</span></span><br><span class="line">    find(a.begin(),a.end(),<span class="number">10</span>);  			<span class="comment">// 在[a.begin(), a.end())的元素中查找10。并返回其位置（迭代器）</span></span><br><span class="line">    count(a.begin(), a.end(),<span class="number">10</span>);    		<span class="comment">// 在[a.begin(), a.end())的元素中查找10的个数，并返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、内部实现"><a href="#2、内部实现" class="headerlink" title="2、内部实现"></a>2、内部实现</h3><p>vector 的底层是一个动态数组，包含三个迭代器：start、finish 和 end_of_storage。</p>
<ul>
<li>start 和 finish 之间是已经被使用的空间范围；</li>
<li>end_of_storage 是整块连续空间（包括备用空间）的尾部。</li>
</ul>
<p>当<code>push_banck()</code>时发现空间容量不够，会自动申请另一片更大的空间（1.5或2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间【3、vector的扩容机制】。当释放或者删除（<code>vec.clear()</code>）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。因此，对vector的任何操作一旦引起了空间的重新配置，指向原 vector 的所有迭代器会都失效了。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111938752.png" alt="在这里插入图片描述"></p>
<p>vector 维护的是一个连续的线性空间，所以不论其元素类型为何，普通指针都可以作为 vector 的迭代器而满足所以必要条件，如 operator*，operator-&gt;，operator++，operator–，普通指针天生就具备。vector 支持随机存取，而普通指针正有这样的能力。所以底层直接将指针封装成了 iterator。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111939776.png" alt="在这里插入图片描述"></p>
<h3 id="3、vector-的扩容机制"><a href="#3、vector-的扩容机制" class="headerlink" title="3、vector 的扩容机制"></a>3、vector 的扩容机制</h3><h4 id="（1）扩容机制原理"><a href="#（1）扩容机制原理" class="headerlink" title="（1）扩容机制原理"></a>（1）扩容机制原理</h4><p>当向 vector 中插入元素时，如果元素有效个数 size 与空间容量 capacity 相等时，vector 内部会触发扩容机制：</p>
<ol>
<li>开辟新空间；</li>
<li>拷贝元素；</li>
<li>释放旧空间。</li>
</ol>
<h4 id="（2）如何避免动态扩容，导致效率降低"><a href="#（2）如何避免动态扩容，导致效率降低" class="headerlink" title="（2）如何避免动态扩容，导致效率降低"></a>（2）如何避免动态扩容，导致效率降低</h4><p>如果要避免扩容而导致程序效率过低问题，其实非常简单：<strong>如果在插入之前，可以预估vector存储元素的个数，提前将底层容量开辟好即可。</strong>如果插入之前进行 reserve，只要空间给足，则插入时不会扩容，如果没有 reserve，则会边插入边扩容，效率极其低下。</p>
<h4 id="（3）为什么选择1-5倍或者2倍方式扩容，而不是3倍、4倍"><a href="#（3）为什么选择1-5倍或者2倍方式扩容，而不是3倍、4倍" class="headerlink" title="（3）为什么选择1.5倍或者2倍方式扩容，而不是3倍、4倍"></a>（3）为什么选择1.5倍或者2倍方式扩容，而不是3倍、4倍</h4><p>扩容原理为：申请新空间，拷贝元素，释放旧空间。<strong>理想的分配方案是在第N次扩容时能复用之前N-1次释放的空间。</strong>如果按照2倍方式扩容，第i次扩容空间大小如下：<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111947980.png" alt="在这里插入图片描述"><br>可以看到，每次扩容时，前面释放的空间都不能使用。比如：第4次扩容时，前2次空间已经释放，第3次空间还没有释放(开辟新空间、拷贝元素、释放旧空间)，即前面释放的空间只有1 + 2 &#x3D; 3，假设第3次空间已经释放才只有1+2+4&#x3D;7，而第四次需要8个空间，因此无法使用之前已释放的空间，但是<strong>按照小于2倍方式扩容，多次扩容之后就可以复用之前释放的空间了</strong>。<strong>如果倍数超过2倍(包含2倍)方式扩容会存在以下问题</strong>：</p>
<ul>
<li>空间浪费可能会比较高，比如：扩容后申请了64个空间，但只存了33个元素，有接近一半的空间没有使用；</li>
<li>无法使用到前面已释放的内存。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111947476.png" alt="在这里插入图片描述"></p>
<ul>
<li>使用2倍（k&#x3D;2）扩容机制扩容时，每次扩容后的新内存大小必定大于前面的总和；</li>
<li>而使用1.5倍（k&#x3D;1.5）扩容时，在几次扩展以后，可以重用之前的内存空间了。</li>
</ul>
<p>因为 STL 标准并没有严格说明需要按何种方式进行扩容，因此不同的实现厂商都是按照自己的方式扩容的，即：<strong>Linux 下是按照2倍的方式扩容的，而 vs 下是按照1.5倍的方式扩容的</strong>。</p>
<h4 id="（4）Windows-和-Linux-的扩容底层原理"><a href="#（4）Windows-和-Linux-的扩容底层原理" class="headerlink" title="（4）Windows 和 Linux 的扩容底层原理"></a>（4）Windows 和 Linux 的扩容底层原理</h4><ol>
<li><p>Windows 扩容底层</p>
<p>Windows 中堆管理系统会对释放的堆块进行合并，因此 vs 下的 vector 扩容机制选择使用1.5倍的方式扩容，这样多次扩容之后就可以使用之前已经释放的空间。</p>
</li>
<li><p>Linux 的扩容底层</p>
</li>
</ol>
<img src="https://img-blog.csdnimg.cn/4f12d834bac147ee9bcba58e5521a961.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qOu5piO5biu5aSn5LqO6buR6JmO5biu,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:80%;" />

<ul>
<li>Linux 下主要使用 glibc 的 ptmalloc 来进行用户空间申请的<ul>
<li>如果 malloc 的空间小于<code>128KB</code>，其内部通过<code>brk()</code>来扩张；</li>
<li>如果大于<code>128KB</code>且<code>arena</code>中没有足够的空间时，通过<code>mmap()</code>将内存映射到进程地址空间。</li>
</ul>
</li>
<li>Linux 中引入<strong>伙伴系统</strong>（所谓的伙伴系统就是 STL 中通过链表来实现的内存池）为内核提供了一种用于分配连续页的高效的分配策略，实现对固定分区和动态分区方式的折中：固定分区存在内部碎片；动态分区存在外部碎片，而且动态分区回收时的合并以及分配时的切片是比较耗时的。<ul>
<li>伙伴系统是将整个内存区域构建成基本大小<code>basicSize</code>的1倍、2倍、4倍、8倍、16倍等，即要求内存空间分区链均对应2的整次幂倍大小的空间；</li>
<li>在分配和释放空间时，可以通过<code>log2(request/basicSize)</code>向上取整的哈希算法快速找到对应内存块。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111952632.png" alt="img"></p>
<h2 id="std-list"><a href="#std-list" class="headerlink" title="std::list"></a>std::list</h2><h3 id="1、基本用法-1"><a href="#1、基本用法-1" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// for std::accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; list1;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; list2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">list3</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>; <span class="comment">// 5个10</span></span><br><span class="line">    <span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">list4</span><span class="params">(list2.begin(), list2.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素访问</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;list2元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : list2) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    list1.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">    list1.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    list1.<span class="built_in">pop_back</span>();</span><br><span class="line">    list1.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入和删除特定位置的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = list2.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">2</span>); <span class="comment">// 移动迭代器到第三个位置</span></span><br><span class="line">    list2.<span class="built_in">insert</span>(it, <span class="number">10</span>); <span class="comment">// 在第三个位置插入10</span></span><br><span class="line">    it = list2.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">2</span>); <span class="comment">// 再次移动迭代器到第三个位置</span></span><br><span class="line">    list2.<span class="built_in">erase</span>(it); <span class="comment">// 删除第三个位置的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    list2.<span class="built_in">reverse</span>();	<span class="comment">// 反转列表</span></span><br><span class="line">    list2.<span class="built_in">sort</span>();		<span class="comment">// 排序列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// algorithm</span></span><br><span class="line">    it = std::<span class="built_in">find</span>(list2.<span class="built_in">begin</span>(), list2.<span class="built_in">end</span>(), <span class="number">4</span>);  <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(list2.<span class="built_in">begin</span>(), list2.<span class="built_in">end</span>(), <span class="number">0</span>);  <span class="comment">// 求和</span></span><br><span class="line">    std::for_each(list2.<span class="built_in">begin</span>(), list2.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;  <span class="comment">// 遍历</span></span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> count = std::<span class="built_in">count</span>(list2.<span class="built_in">begin</span>(), list2.<span class="built_in">end</span>(), <span class="number">10</span>);  <span class="comment">// 计算元素个数</span></span><br><span class="line">    list2.<span class="built_in">remove</span>(<span class="number">10</span>); <span class="comment">// 删除所有值为10的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、理论基础"><a href="#2、理论基础" class="headerlink" title="2、理论基础"></a>2、理论基础</h3><p>由于 list 拥有一片不连续的内存空间，且 STL list 是一个双向链表，因此其提供的迭代器是 Bidirectional Iterators。对于 list 来说，其插入操作和接合操作不会使得原迭代器失效。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node</span> &#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">	void_pointer prev;</span><br><span class="line">	void_pointer next;</span><br><span class="line">	T data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;  <span class="comment">// 缺省使用 alloc 作为空间配置器</span></span><br><span class="line"><span class="keyword">class</span> list &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* list_type;</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;  <span class="comment">// 专属空间配置器，每次配置一个节点大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    link_type node;</span><br><span class="line">    </span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="std-deque"><a href="#std-deque" class="headerlink" title="std::deque"></a>std::deque</h2><h3 id="1、基本用法-2"><a href="#1、基本用法-2" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// for std::accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化方式</span></span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; deque1;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; deque2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">deque3</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>; <span class="comment">// 5个10</span></span><br><span class="line">    <span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">deque4</span><span class="params">(deque2.begin(), deque2.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素访问</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deque2元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : deque2) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    deque1.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">    deque1.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    deque1.<span class="built_in">pop_back</span>();</span><br><span class="line">    deque1.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入和删除特定位置的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = deque2.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">2</span>); <span class="comment">// 移动迭代器到第三个位置</span></span><br><span class="line">    deque2.<span class="built_in">insert</span>(it, <span class="number">10</span>); <span class="comment">// 在第三个位置插入10</span></span><br><span class="line">    it = deque2.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">2</span>); <span class="comment">// 再次移动迭代器到第三个位置</span></span><br><span class="line">    deque2.<span class="built_in">erase</span>(it); <span class="comment">// 删除第三个位置的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转双端队列</span></span><br><span class="line">    std::<span class="built_in">reverse</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序双端队列</span></span><br><span class="line">    std::<span class="built_in">sort</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用算法函数</span></span><br><span class="line">    <span class="comment">// std::find</span></span><br><span class="line">    it = std::<span class="built_in">find</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != deque2.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;找到元素 4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到元素 4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::accumulate</span></span><br><span class="line">    <span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deque2元素的和：&quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::for_each</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deque2元素：&quot;</span>;</span><br><span class="line">    std::for_each(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::count</span></span><br><span class="line">    <span class="type">int</span> count = std::<span class="built_in">count</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>(), <span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deque2中包含10的个数：&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::remove</span></span><br><span class="line">    <span class="keyword">auto</span> new_end = std::<span class="built_in">remove</span>(deque2.<span class="built_in">begin</span>(), deque2.<span class="built_in">end</span>(), <span class="number">10</span>); <span class="comment">// 删除所有值为10的元素</span></span><br><span class="line">    deque2.<span class="built_in">erase</span>(new_end, deque2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最终的deque2元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : deque2) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、理论基础-1"><a href="#2、理论基础-1" class="headerlink" title="2、理论基础"></a>2、理论基础</h3><p>deque 是双向开口的连续线性空间。</p>
<blockquote>
<p>deque 和 vector 的差别：</p>
<ol>
<li>deque 允许于常数时间内对起头端进行元素的插入或移除操作；</li>
<li>deque 没有所谓容量（capacity）的概念，因为它是<strong>动态地以分段连续空间组合而成</strong>，随时可以增加一段新的空间并链接起来。</li>
<li>deque 虽然也提供 RamdomAccessIterator，但其迭代器并非普通指针，复杂度较高，因此除非必要，应尽量使用 vector 而非 deque。对 deque 进行的排序操作，可以先将 deque 完成复制到一个 vector 中，排序后再复制回 deque。</li>
</ol>
</blockquote>
<p>deque 的迭代器包含两个任务：</p>
<ol>
<li><p>指出分段连续空间（即缓冲区）在哪里；</p>
</li>
<li><p>判断自己是否已经处于所在缓冲区的边缘，若是，则一旦前进或后退时就必须跳跃至下一个或上一个缓冲区:</p>
<ol>
<li><p><strong>最后一个缓冲区只剩下一个备用空间</strong>，则调用 <code>push_back_aux()</code>新建并跳跃至下一个缓冲区；</p>
</li>
<li><p><strong>第一个缓冲区没有备用空间</strong>，则调用 <code>push_front_aux()</code>新建并跳跃至上一个缓冲区。</p>
<blockquote>
<p>由于前端插入操作涉及到现有缓冲区前面的空间，因此需要确保当前缓冲区完全没有空间时，再进行新的缓冲区分配和跳跃操作。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<p>deque 采用一个 “map”（并非 STL 中的 map 容器）来指向其分段连续空间（缓冲区）。map 中的每一个元素 node 为一个指针，指向其对应的缓冲区。对于 deque 来说，主要维护 3 个指针：</p>
<ol>
<li>指向 map 的指针；</li>
<li>start：指向第一缓冲区的第一个元素；</li>
<li>finish：指向最后缓冲区的最后一个元素。</li>
</ol>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406201720123.png" alt="image-20240620172003136" style="zoom: 25%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406201720621.png" alt="image-20240620172045147" style="zoom: 25%;" />

<h2 id="std-stack"><a href="#std-stack" class="headerlink" title="std::stack"></a>std::stack</h2><h3 id="1、基本用法-3"><a href="#1、基本用法-3" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">empty</span>();			<span class="comment">// 栈为空时返回1，非空返回0</span></span><br><span class="line">st.<span class="built_in">size</span>();			<span class="comment">// 返回栈中元素数量，size_type size() const;</span></span><br><span class="line">st.<span class="built_in">top</span>();			<span class="comment">// 返回栈顶元素，value_type&amp; top();</span></span><br><span class="line">st.<span class="built_in">push</span>(value);		<span class="comment">// 在栈顶插入一个元素，void push( const value_tyoe&amp; val );</span></span><br><span class="line">st.<span class="built_in">emplace</span>(value);	<span class="comment">// 在栈顶增加一个元素，void emplace( args&amp;&amp; args );</span></span><br><span class="line">st.<span class="built_in">pop</span>();			<span class="comment">// 栈顶元素出栈，即删除栈顶元素，void pop(); </span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st2;</span><br><span class="line">st1.<span class="built_in">swap</span>( st2 );	<span class="comment">// 交换两个栈中的内容，void swap( stack&amp; x );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与vector一样，重载了运算符：== != &lt; &lt;= &gt; &gt;=</span></span><br></pre></td></tr></table></figure>

<h3 id="2、理论相关"><a href="#2、理论相关" class="headerlink" title="2、理论相关"></a>2、理论相关</h3><p>STL 中 stack 往往不被归类为容器，而被归类为容器适配器（container adapter）。因为<strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p>
<p>栈的底层实现可以是 vector、deque或list 等， 主要就是数组和链表的底层实现。常用的 SGI STL ，如果没有指定底层实现的话，<strong>默认是以 deque 为缺省情况下栈的底层结构</strong>。此外，SGI STL 中队列一样是以 deque 为缺省情况下的底部结构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242029774.png" alt="栈与队列理论3" style="zoom:50%;" />

<blockquote>
<p>三个最为普遍的 STL 版本：</p>
<ol>
<li>HP STL 其他版本的 C++ STL，一般是以 HP STL 为蓝本实现出来的，HP STL 是 C++ STL 的第一个实现版本，而且开放源代码。</li>
<li>P.J.Plauger STL 由 P.J.Plauger 参照 HP STL 实现出来的，被 Visual C++ 编译器所采用，不是开源的。</li>
<li>SGI STL 由 Silicon Graphics Computer Systems 公司参照HP STL 实现，被 Linux 的 C++ 编译器 GCC 所采用，SGI STL 是开源软件，源码可读性甚高。</li>
</ol>
</blockquote>
<h2 id="std-queue"><a href="#std-queue" class="headerlink" title="std::queue"></a>std::queue</h2><h3 id="1、基本用法-4"><a href="#1、基本用法-4" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">queue&lt;<span class="type">double</span>&gt; d;</span><br><span class="line">queue&lt;node&gt; n;  <span class="comment">// node是一个结构体</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">size</span>();		<span class="comment">// 返回q里元素个数</span></span><br><span class="line">q.<span class="built_in">empty</span>();		<span class="comment">// 返回q是否为空，空则返回1，否则返回0</span></span><br><span class="line">q.<span class="built_in">push</span>(k);		<span class="comment">// 在q的末尾插入k</span></span><br><span class="line">q.<span class="built_in">pop</span>();		<span class="comment">// 删掉q的第一个元素</span></span><br><span class="line">q.<span class="built_in">front</span>();		<span class="comment">// 返回q的第一个元素</span></span><br><span class="line">q.<span class="built_in">back</span>();		<span class="comment">// 返回q的末尾元素</span></span><br></pre></td></tr></table></figure>

<h2 id="std-priority-queue"><a href="#std-priority-queue" class="headerlink" title="std::priority_queue"></a>std::priority_queue</h2><h3 id="1、基本用法-5"><a href="#1、基本用法-5" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><h4 id="（1）声明"><a href="#（1）声明" class="headerlink" title="（1）声明"></a>（1）声明</h4>   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = vector&lt;T&gt;, <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Container::value_type&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：优先队列中的元素类型；</li>
<li><code>Container</code>：底层容器的类型；</li>
<li><code>Compare</code>：比较函数对象，决定了优先队列的排序方式。</li>
</ul>
<h4 id="（2）基本操作"><a href="#（2）基本操作" class="headerlink" title="（2）基本操作"></a>（2）基本操作</h4>   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">q.<span class="built_in">size</span>();	<span class="comment">// 返回q里元素个数</span></span><br><span class="line">q.<span class="built_in">empty</span>();	<span class="comment">// 返回q是否为空，空则返回1，否则返回0</span></span><br><span class="line">q.<span class="built_in">push</span>(k);	<span class="comment">// 在q的末尾插入k</span></span><br><span class="line">q.<span class="built_in">pop</span>();	<span class="comment">// 删掉q的第一个元素</span></span><br><span class="line">q.<span class="built_in">top</span>();	<span class="comment">// 返回q的第一个元素</span></span><br></pre></td></tr></table></figure>

<h4 id="（3）排序实现"><a href="#（3）排序实现" class="headerlink" title="（3）排序实现"></a>（3）排序实现</h4><ol>
<li><p><code>less</code>和<code>greater</code>优先队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt; p;</span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// less&lt;int&gt;:14 12 10 8 6（大顶堆）</span></span><br><span class="line"><span class="comment">// greater&lt;int&gt;:6 8 10 12 14（小顶堆）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义仿函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义仿函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareByAge</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person&amp; p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.age &gt; p2.age;  <span class="comment">// 按照年龄从小到大排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2、理论相关-1"><a href="#2、理论相关-1" class="headerlink" title="2、理论相关"></a>2、理论相关</h3><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>优先级队列（<code>priority_queue</code>）是C++标准库中的一个<strong>容器适配器（container adapter）</strong>，其中的元素按照一定的优先级进行排序，每次取出的元素都是优先级最高的。其底层实现通常使用堆<strong>（heap）</strong>数据结构。</p>
<p>定义在<code>&lt;queue&gt;</code>头文件中。</p>
<p>默认情况下，<code>priority_queue</code>使用<code>std::less</code>作为比较函数，即元素的优先级按照从大到小的顺序排列。</p>
<h4 id="（2）特点"><a href="#（2）特点" class="headerlink" title="（2）特点"></a>（2）特点</h4><ul>
<li><strong>优先级排序</strong>：priority_queue中的元素按照一定的优先级进行排序。默认情况下，元素的优先级按照从大到小的顺序排列，也可以通过自定义的比较函数来指定不同的排序方式。</li>
<li><strong>自动排序</strong>：在插入元素时，priority_queue会根据元素的优先级自动进行排序。每次插入新元素时，都会将新元素放置在正确的位置上。</li>
<li><strong>取出优先级最高元素</strong>：priority_queue提供了一种方便的方式来取出优先级最高的元素。使用top()函数可以访问优先级最高的元素，而使用pop()函数可以将该元素从队列中移除。</li>
<li><strong>底层实现采用堆</strong>：priority_queue通常使用堆（heap）数据结构来实现。堆是一种具有特定性质的二叉树，可以高效地插入新元素和取出优先级最高的元素。</li>
<li><strong>动态大小</strong>：priority_queue的大小可以根据需要进行动态调整。可以随时插入新元素和删除已有元素，并在必要时自动重新排序。</li>
</ul>
<h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1><h2 id="std-unordered-set"><a href="#std-unordered-set" class="headerlink" title="std::unordered_set"></a>std::unordered_set</h2><h3 id="1、基本用法-6"><a href="#1、基本用法-6" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before add elements......&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 获取或设置允许的最大装载因子</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max load facotr: &quot;</span> &lt;&lt; mySet.<span class="built_in">max_load_factor</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 返回当前装载因子</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Load factor: &quot;</span> &lt;&lt; mySet.<span class="built_in">load_factor</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 返回当前bucket的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bucket count: &quot;</span> &lt;&lt; mySet.<span class="built_in">bucket_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">2</span>); <span class="comment">// 重复插入，不会有任何效果</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Is the set empty ? &quot;</span> &lt;&lt; mySet.<span class="built_in">empty</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">if</span> (mySet.<span class="built_in">find</span>(<span class="number">2</span>) != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Found 2 in the set.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历集合</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements in mySet: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : mySet) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    mySet.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After erasing 2, size of mySet: &quot;</span> &lt;&lt; mySet.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After add elements......&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max load facotr: &quot;</span> &lt;&lt; mySet.<span class="built_in">max_load_factor</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Load factor: &quot;</span> &lt;&lt; mySet.<span class="built_in">load_factor</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bucket count: &quot;</span> &lt;&lt; mySet.<span class="built_in">bucket_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    mySet.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Before add elements......</span><br><span class="line">Max load facotr: 1</span><br><span class="line">Load <span class="built_in">factor</span>: 0</span><br><span class="line">Bucket count: 1</span><br><span class="line"></span><br><span class="line">Is the <span class="built_in">set</span> empty ? 0</span><br><span class="line">Found 2 <span class="keyword">in</span> the <span class="built_in">set</span>.</span><br><span class="line">Elements <span class="keyword">in</span> mySet: 3 2 1 </span><br><span class="line">After erasing 2, size of mySet: 2</span><br><span class="line"></span><br><span class="line">After add elements......</span><br><span class="line">Max load facotr: 1</span><br><span class="line">Load <span class="built_in">factor</span>: 0.153846</span><br><span class="line">Bucket count: 13</span><br></pre></td></tr></table></figure>

<h3 id="2、内部实现-1"><a href="#2、内部实现-1" class="headerlink" title="2、内部实现"></a>2、内部实现</h3><p><code>std::unordered_set</code> 的内部实现基于哈希表，哈希表是一个数组，数组的每个元素称为一个 <code>bucket</code>。这点和 <code>std::unordered_map</code> 是一样的。</p>
<p>同样的，每个 <code>bucket</code> 维护一个链表（或其他容器，例如小型向量），用于解决哈希冲突（即不同元素的哈希值相同的情况）。</p>
<ul>
<li>哈希函数：<code>std::unordered_set</code>通过哈希函数将元素映射到一个 <code>bucket</code>。哈希函数的质量决定了元素在哈希表中的分布，影响容器的性能。</li>
<li>哈希冲突：当两个元素的哈希值相同时，它们会被存储在同一个 <code>bucket</code> 的链表中，这种情况称为哈希冲突。<code>std::unordered_set</code>通过链地址法来解决哈希冲突。</li>
<li>装载因子和重哈希：装载因子是<code>元素数量 / bucket数量</code>。当装载因子超过某个阈值时（默认为<code>1.0</code>），<code>std::unordered_set</code>会进行重哈希操作，即增加 <code>bucket</code> 数量并重新分配所有元素，以保持操作的高效性。</li>
</ul>
<p>适用场景</p>
<ul>
<li>需要快速查找的场景：当需要存储一组唯一元素，并且频繁地进行查找操作时；</li>
<li>不关心元素顺序：<code>std::unordered_set</code>不保证元素的顺序；</li>
<li>大量数据的去重：当需要从大量数据中去除重复项时。</li>
</ul>
<h2 id="std-unordered-map"><a href="#std-unordered-map" class="headerlink" title="std::unordered_map"></a>std::unordered_map</h2><h3 id="1、基本用法-7"><a href="#1、基本用法-7" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    map.<span class="built_in">insert</span>(&#123;<span class="string">&quot;apple&quot;</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    map[<span class="string">&quot;banana&quot;</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;apple has &quot;</span> &lt;&lt; map[<span class="string">&quot;apple&quot;</span>] &lt;&lt; <span class="string">&quot; units.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用find查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> search = map.<span class="built_in">find</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (search != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Found banana, count = &quot;</span> &lt;&lt; search-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Banana not found.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : map) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; has &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot; units.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    map.<span class="built_in">erase</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The map has &quot;</span> &lt;&lt; map.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; elements.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    map.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apple has 5 units.</span><br><span class="line">Found banana, count = 3</span><br><span class="line">banana has 3 units.</span><br><span class="line">apple has 5 units.</span><br><span class="line">The map has 1 elements.</span><br></pre></td></tr></table></figure>

<h3 id="2、内部实现-2"><a href="#2、内部实现-2" class="headerlink" title="2、内部实现"></a>2、内部实现</h3><p><code>std::unordered_map</code>内部使用哈希表实现，因此它支持平均常数时间复杂度的查找、插入和删除操作，而<code>std::map</code>使用红黑树实现，提供对数时间复杂度的操作。</p>
<p><code>std::unordered_map</code>内部主要是通过一个动态数组（通常称为 <code>bucket</code> 数组）来维护元素，每个数组元素（或称为 <code>bucket</code>）包含一个指向链表（或其他形式的容器，如小型向量）的指针。</p>
<p>这些链表用于存储具有相同哈希值的元素（键值对）。当发生哈希冲突时（即不同的键产生相同的哈希值），<code>std::unordered_map</code>会将具有相同哈希值的元素存储在同一个 <code>bucket</code> 的链表中。</p>
<ul>
<li>哈希函数：<code>std::unordered_map</code>使用一个哈希函数将键映射到 bucket 的索引。哈希函数的质量直接影响到容器的性能，理想情况下，哈希函数应该将键均匀分布到所有的 <code>buckets</code> 上，以减少哈希冲突。</li>
<li>哈希表：内部数据结构，通常是一个动态数组，其中的每个元素指向一个链表（或其他容器），用于解决哈希冲突。</li>
<li>键值对：存储在链表中的元素，每个元素包含一个键和一个值。</li>
<li>装载因子：<code>std::unordered_map</code>的装载因子是一个浮点数，定义为<code>元素个数 / bucket数量</code>。当装载因子超过特定阈值（默认为<code>1.0</code>）时，哈希表会进行重新哈希（<code>rehashing</code>），即增加 <code>bucket</code> 数量并重新分配所有元素，以保持操作的效率。</li>
</ul>
<p>适用场景</p>
<ul>
<li><p><strong>需要快速查找的场景；</strong></p>
</li>
<li><p><strong>不关心元素顺序的场景；</strong></p>
</li>
<li><p><strong>键值对存储。</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
  </entry>
  <entry>
    <title>new与operator new</title>
    <url>/2024/04/24/1%20C++/%E5%86%85%E5%AD%98/new%E4%B8%8Eoperator%20new/</url>
    <content><![CDATA[<blockquote>
<p><strong>区分三个概念：new operator、operator new和placement new</strong></p>
</blockquote>
<span id="more"></span>

<h1 id="一、new-operator、operator-new和placement-new"><a href="#一、new-operator、operator-new和placement-new" class="headerlink" title="一、new operator、operator new和placement new"></a>一、new operator、operator new和placement new</h1><h2 id="1、new-operator（new-操作符）"><a href="#1、new-operator（new-操作符）" class="headerlink" title="1、new operator（new 操作符）"></a>1、new operator（new 操作符）</h2><p>当写下<code>string *ps = new string(&quot;Memory Management&quot;)</code>时，使用的<code>new</code>是<strong>new操作符</strong>。这个操作符和<code>sizeof</code>一样是语言内置的，它总是完成以下功能：</p>
<ol>
<li>分配内存（调用 operator new 函数）；</li>
<li>调用构造函数初始化内存中的对象。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241419515.png" alt="image-20240424141921292"></p>
<h2 id="2、operator-new"><a href="#2、operator-new" class="headerlink" title="2、operator new"></a>2、operator new</h2><p>new 操作符调用一个函数来完毕必需的内存分配，即 <code>operator new</code>。注意这个函数的职责和<code>malloc</code>一样，只是为了分配内存。</p>
<p>函数 operator new 通常这样声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值类型：<code>void *</code>（返回一个未经处理的<code>raw</code>指针）</li>
<li>参数<code>size_t size</code>：确定分配多少内存。可以添加额外的參数重载函数<code>operator new</code>，但第一个參数类型必须是<code>size_t</code>。</li>
</ul>
<blockquote>
<p>operator new&#x2F;delete 是可以被设定为 &#x3D;delete，当 &#x3D;delete 时候。其不允许被分配。</p>
</blockquote>
<h2 id="3、placement-new"><a href="#3、placement-new" class="headerlink" title="3、placement new"></a>3、placement new</h2><blockquote>
<p><strong>placement new 是一种特殊的 operator new，作用于一块已分配但未处理或未初始化的 raw 内存。</strong></p>
</blockquote>
<p>当存在一些已经被分配单尚未被处理的<code>raw</code>内存时，如果需要再这些内存中构造一个对象，可以使用<strong>一个特殊的operator new</strong> ，它被称为<strong>placement new</strong>。当程序使用共享内存或 memory-mapped I&#x2F;O 时这个函数可能实用，由于在这样程序里对象必须被放置在一个确定地址上或一块被例程分配的内存里。</p>
<p>如下例所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">　<span class="keyword">public</span>:</span><br><span class="line">　　<span class="built_in">Widget</span>(<span class="type">int</span> widgetSize);</span><br><span class="line">　　...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Widget * <span class="title">constructWidgetInBuffer</span><span class="params">(<span class="type">void</span> *buffer,<span class="type">int</span> widgetSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　<span class="keyword">return</span> <span class="built_in">new</span> (buffer) <span class="built_in">Widget</span>(widgetSize);  <span class="comment">// placement new的用法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细来说，<code>new (buffer) Widget(widgetSize)</code>是new操作符的一个使用方法，需要使用一个额外的变量<code>buffer</code>。当new操作符隐含调用operator new函数时，把这个变量传递给它，此时，被调用的operator new函数除了带有强制的参数<code>size_t</code>外，还必须接受<code>void *</code>指针参数，指向构造对象占用的内存空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>, <span class="type">void</span> *location)</span>  <span class="comment">// size_t没有名字，以防止编译器发出警告说它没有使用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　<span class="keyword">return</span> location;</span><br><span class="line">  <span class="comment">// 在使用placement new的情况下，调用者已经获得了指向内存的指针</span></span><br><span class="line">  <span class="comment">// 由于调用者知道对象应该放在哪里，placement new必须做的就是返回转递给它的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p><strong>new 、operator new 和 placement new 区别</strong></p>
<p>（1）<code>new</code>：不能被重载，其行为总是一致的。它先调用operator new分配内存，然后调用构造函数初始化那段内存。</p>
<p>（2）<code>operator new</code>：要实现不同的内存分配行为，应该重载operator new，而不是new。</p>
<ul>
<li>operator new 就像 operator + 一样，是可以重载的。如果类中没有重载 operator new，那么调用的就是全局的 ::operator  new 来完成堆的分配。同理，operator new[]、operator delete、operator delete[] 也是可以重载的。</li>
<li>重载时，返回类型必须声明为 void*，第一个参数类型必须为表达要求分配空间的大小（字节），类型为 size_t，可以带其它参数。</li>
</ul>
<p>（3）<code>placement new</code>：只是 operator new 重载的一个标准、全局的版本。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。因此不能删除它，但需要调用对象的析构函数。placement new 允许在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。原型中 void* p 实际上就是指向一个已经分配好的内存缓冲区的的首地址。</p>
<h1 id="二、Deletion-and-Memory-Deallocation"><a href="#二、Deletion-and-Memory-Deallocation" class="headerlink" title="二、Deletion and Memory Deallocation"></a>二、Deletion and Memory Deallocation</h1><h2 id="1、delete-和-operator-delete"><a href="#1、delete-和-operator-delete" class="headerlink" title="1、delete 和 operator delete"></a>1、delete 和 operator delete</h2><p>为了避免内存泄漏，每一个动态内存分配必须与一个等同相反的 deallocation 相应。<strong>函数 operator delete</strong> 与 <strong>delete操作符</strong>的关系与 <strong>operator new</strong>与 <strong>new 操作符</strong>的关系一样。</p>
<p><code>delete</code>总是完成下述功能：</p>
<ol>
<li>调用析构函数；</li>
<li>释放内存。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241445181.png" alt="image-20240424144503094"></p>
<p><code>operator delete</code>函数用来释放内存，声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *memoryToBeDeallocated)</span></span>;</span><br></pre></td></tr></table></figure>

<p>因此，<strong>假设你仅仅想处理未被初始化的内存，你应该绕过 new 和 delete 操作符，而调用 operator new 获得内存和 operator delete 释放内存给系统</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *buffer = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="number">50</span>*<span class="built_in">sizeof</span>(<span class="type">char</span>)); <span class="comment">// 分配足够的内存以容纳50个char</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//没有调用构造函数</span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>; <span class="comment">// 释放内存</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 没有调用析构函数</span></span><br></pre></td></tr></table></figure>

<p>这与在 C 中调用 malloc 和 free 等同。</p>
<h2 id="2、placement-new建立的对象怎样释放？"><a href="#2、placement-new建立的对象怎样释放？" class="headerlink" title="2、placement new建立的对象怎样释放？"></a>2、placement new建立的对象怎样释放？</h2><p>假设用 <code>placement new</code> 在内存中建立对象，应该避免在该内存中使用 delete 操作符。</p>
<p>由于 delete 操作符调用 operator delete 释放内存，但这片存最开始并不是被 operator new 分配的，placement new 只是返回传递给它的这片内存的指针，因此无法得知这片内存究竟来自何处。因此，<strong>应该显式调用析构函数来解除构造函数的影响</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在共享内存中分配和释放内存的函数 void * mallocShared(size_t size);</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">freeShared</span><span class="params">(<span class="type">void</span> *memory)</span></span>;</span><br><span class="line"><span class="type">void</span> *sharedMemory = <span class="built_in">mallocShared</span>(<span class="built_in">sizeof</span>(Widget));</span><br><span class="line">Widget *pw = <span class="comment">// 如上所看到的</span></span><br><span class="line"><span class="built_in">constructWidgetInBuffer</span>(sharedMemory, <span class="number">10</span>); <span class="comment">// 使用</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 执行placement new操作 </span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">delete</span> pw;      <span class="comment">// 结果不确定! 共享内存来自mallocShared, 而不是operator new</span></span><br><span class="line">pw-&gt;~<span class="built_in">Widget</span>();  <span class="comment">// 正确。 析构pw指向的Widget，但并未释放存放Widget的这片内存</span></span><br><span class="line"><span class="built_in">freeShared</span>(pw); <span class="comment">// 正确。 释放pw指向的共享内存，但并未调用析构函数</span></span><br></pre></td></tr></table></figure>

<h2 id="3、new-delete和array-new-array-delete应该搭配使用"><a href="#3、new-delete和array-new-array-delete应该搭配使用" class="headerlink" title="3、new&#x2F;delete和array new&#x2F;array delete应该搭配使用"></a>3、new&#x2F;delete和array new&#x2F;array delete应该搭配使用</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241457401.png" alt="image-20240424145754309"></p>
<h1 id="三、相关问题"><a href="#三、相关问题" class="headerlink" title="三、相关问题"></a>三、相关问题</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Accoun *parray= <span class="keyword">new</span> Account[<span class="number">100</span>]; </span><br><span class="line"><span class="keyword">delete</span> parray; </span><br><span class="line"><span class="keyword">delete</span>[] parray; </span><br></pre></td></tr></table></figure>

<p>方括号的存在会使编译器获取数组大小（size）然后析构函数再被依次应用在每个元素上，一共size次。否则，只有一个元素被析构。 但无论哪种情况，分配的全部空间被返还给自由存储区。 </p>
<h2 id="1、为什么无论哪种情况，分配的全部空间被返还给自由存储区"><a href="#1、为什么无论哪种情况，分配的全部空间被返还给自由存储区" class="headerlink" title="1、为什么无论哪种情况，分配的全部空间被返还给自由存储区?"></a>1、为什么无论哪种情况，分配的全部空间被返还给自由存储区?</h2><p>首先，针对最后一句话“<strong>无论哪种情况，分配的全部空间被返还给自由存储区</strong>”，实际上是指：</p>
<p>无论是使用 <code>delete</code> 还是 <code>delete []</code>，分配的全部空间都会被释放，并返回给自由存储区。区别在于，<code>delete</code> 只会调用一次析构函数，而 <code>delete []</code> 会调用数组中每个元素的析构函数。因此，如果你分配了一个数组并使用 <code>delete</code> 来释放，只有一个元素的析构函数会被调用，可能导致内存泄漏，因为其他元素的资源没有得到正确释放。而使用 <code>delete []</code> 则能保证每个元素的析构函数都被正确调用，避免了这种潜在的内存泄漏问题。</p>
<h2 id="2、对于delete-parray，编译器怎么知道parray这个指针实际指向的是数组还是单个元素？"><a href="#2、对于delete-parray，编译器怎么知道parray这个指针实际指向的是数组还是单个元素？" class="headerlink" title="2、对于delete[] parray，编译器怎么知道parray这个指针实际指向的是数组还是单个元素？"></a>2、对于delete[] parray，编译器怎么知道parray这个指针实际指向的是数组还是单个元素？</h2><p>（1）一般在分配时分配器会自动写一个日志（即在分配的内存之前有一个结构）用于记录分配的大小，分配内容的sizeof等等。 </p>
<p>直观来说，<code>delete</code>和<code>delete[]</code>都是传入一个<code>void*</code>，因此如果不保存日志就无法知道分配时到底是分配了一个还是多个单元。所以虽然<code>delete</code>和<code>delete[]</code>不同，但是分配器在执行释放过程中都会读取这个日志，从而了解到底应该释放多少内存，但是从程序员的角度来说，既然分配了数组，就应该用<code>delete[]</code>。</p>
<p>（2）在VC下用汇编跟过delete[]的执行情况,发现这个 “日志 “就是一个4字节长的整数记录数组元素个数,紧挨在数组第一个元素之前。但是有个前提：对象类型(或其基类)有显式析构函数.换句话说,析构函数是非<code>virtual</code>的。否则的话,数组前面是没有这个日志的。其实对于析构函数是<code>virtual</code>的情况，<code>delete[]</code>时无需调用其析构函数，因此此时<code>VC</code>把<code>delete[]</code>当做<code>delete</code>同样处理。</p>
<p>（3）<code>delete parray</code>，编译器得到类型信息是<code>Account</code>单个的指针，那么释放时，只调用一次析构函数。<br><code>delete[] parray</code>，编译器得到的类型信息是<code>Account[]</code>类型，则按照<code>Account</code>数组来处理，依次调用每个元素的析构函数。 </p>
<h2 id="3、编译器又是如何获知这个数组的大小？"><a href="#3、编译器又是如何获知这个数组的大小？" class="headerlink" title="3、编译器又是如何获知这个数组的大小？"></a>3、编译器又是如何获知这个数组的大小？</h2><p>当我们使用<code>operator new</code>为一个自定义类型对象分配内存时，我们得到的内存要比实际对象的内存大一些，这些内存除了要存储对象数据外，还需要记录这片内存的大小，此方法称为<code>cookie</code>。这一点上的实现依据不同的编译器不同。（例如<code>MFC</code>选择在所分配内存的头部存储对象实际数据，而后面的部分存储边界标志和内存大小信息。<code>g++</code>则采用在所分配内存的头4个自己存储相关信息，而后面的内存存储对象实际数据。）当我们使用<code>delete operator</code>进行内存释放操作时，<code>delete operator</code>就可以根据这些信息正确的释放指针所指向的内存块。<br>对于<code>parray</code>指针，可以根据这样的<code>cookie</code>信息来得到指向内存空间的大小，<code>delete parray</code>和<code>delete[] parray</code>都是一样的，同样一个指针，<code>cookie</code>信息是相同的，所以对应的内存都会被释放掉。但是由于编译器理解两种情况下的类型是不同的，所以调用析构函数会有不同。 </p>
<h2 id="4、new-handler相关"><a href="#4、new-handler相关" class="headerlink" title="4、new handler相关"></a>4、new handler相关</h2><p>我们在分配内存的时候。分配内存可能会有失败的情况，在失败的时候往往会抛出异常。对于内存，我们在抛出失败之前。可以先调用一个自己制作的<code>handler</code>，这个<code>handler</code>可能能帮助正确的分配内存或者终止进程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">new</span> handler)</span><span class="params">()</span></span>;<span class="comment">//定义一个handler</span></span><br><span class="line"><span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span><span class="title">throw</span><span class="params">()</span></span>;<span class="comment">//设定一个handler</span></span><br></pre></td></tr></table></figure>

<p><code>new handler</code>的两种选择</p>
<ul>
<li>让更多<code>memory</code>可以被使用</li>
<li>抛出异常（<code>abort()</code>或<code>exit()</code>）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handlerx</span><span class="params">()</span></span>&#123;<span class="comment">//类似这样的就可以</span></span><br><span class="line">	cerr&lt;&lt;<span class="string">&quot;no&quot;</span>;</span><br><span class="line">	<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">set_new_handler</span>(handler);</span><br><span class="line">	..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、相关参考"><a href="#四、相关参考" class="headerlink" title="四、相关参考"></a>四、相关参考</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241530554.png" alt="image-20240424153034458"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241530444.png" alt="image-20240424153053351"></p>
<p><a href="https://www.cnblogs.com/luxiaoxun/archive/2012/08/10/2631812.html">C++中的new、operator new与placement new</a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>内存</category>
      </categories>
  </entry>
  <entry>
    <title>C++面向对象高级编程</title>
    <url>/2024/05/06/1%20C++/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://lishizheng.blog.csdn.net/article/details/135360282">C++面向对象高级编程（侯捷）笔记1</a></p>
<p>2 头文件和类的声明<br>3 构造函数<br>4 参数传递与返回值<br>5 操作符重载与临时对象<br>    操作符重载1——成员函数<br>    操作符重载2——非成员函数<br>6 复习Complex类的实现过程</p>
<span id="more"></span>


<p><a href="https://lishizheng.blog.csdn.net/article/details/135360334">C++面向对象高级编程（侯捷）笔记2</a></p>
<p>7 三大函数：拷贝构造、拷贝赋值、析构<br>8 堆 栈和内存管理<br>9 复习String类的实现过程<br>10 扩展补充：类模板，函数模板及其他<br>11 组合与继承<br>​		Composition复合，表示has-a<br>​		Delegation委托. Composition by reference<br>​		Inheritance（继承），表示is-a<br>12 虚函数和多态<br>13 委托相关设计</p>
<p><a href="https://lishizheng.blog.csdn.net/article/details/135388444">C++程序设计兼谈对象模型（侯捷）笔记</a></p>
<p>2 conversion function 转换函数<br>3 non-explicit-one-argument constructor<br>4 pointer-like classes<br>5 function-like classes<br>6 namespace经验谈<br>7 class template 类模板<br>8 function template 函数模板<br>9 member template 成员模板<br>10 specialization 模板特化<br>11 模板偏特化<br>12 模板模板参数<br>13 关于C++标准库<br>14 三个主题 variadic templates等<br>15 reference<br>16 复合&amp;继承关系下的构造和析构<br>17 （对象模型）关于vptr和vtbl，虚指针和虚表<br>18 （对象模型）关于this<br>19 （对象模型）关于Dynamic Binding</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>侯捷C++系列</category>
      </categories>
  </entry>
  <entry>
    <title>STL标准库与泛型编程</title>
    <url>/2024/04/29/1%20C++/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/STL%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://lishizheng.blog.csdn.net/article/details/135440545">STL标准库与泛型编程（侯捷）笔记1</a></p>
<p>3 容器之分类与各种测试（一）：array<br>4 容器之分类与各种测试（二）：vector<br>5 容器之分类与各种测试（三）list, deque,stack, queue<br>6 容器之分类与各种测试（四）：set和unordered_set等<br>7 分配器之测试</p>
<span id="more"></span>

<p><a href="https://lishizheng.blog.csdn.net/article/details/135440667">STL标准库与泛型编程（侯捷）笔记2</a></p>
<p>8 源代码之分布 VCGcc<br>9 OOP 面向对象编程 vs GP 泛型编程<br>10 技术基础：操作符重载and模板泛化, 全特化, 偏特化<br>11 分配器<br>12 容器之间的实现关系与分类<br>13 深度探索list（上）<br>14 深度探索list（下）<br>15 迭代器的设计原则和Iterator Traits的作用与设计</p>
<p><a href="https://lishizheng.blog.csdn.net/article/details/135440862">STL标准库与泛型编程（侯捷）笔记3</a></p>
<p>16 vector深度探索<br>17 array、forward list深度探索<br>18 deque、queue和 stack深度探索（上）<br>     容器deque<br>19 deque、queue和 stack深度探索（下）<br>     容器queue<br>     容器stack<br>     queue和stack，关于其iterator和底层结构</p>
<p><a href="https://lishizheng.blog.csdn.net/article/details/135456907">STL标准库与泛型编程（侯捷）笔记4</a></p>
<p>20 RB tree 深度探索<br>21 set、multiset深度探索<br>22 map、multimap深度探索<br>23 hashtable深度探索（上）<br>24 hashtable深度探索（下）<br>25 hash set、hash multiset, hash map、hash multimap概念<br>26 unordered容器概念</p>
<p><a href="https://lishizheng.blog.csdn.net/article/details/135474126">STL标准库与泛型编程（侯捷）笔记5</a></p>
<p>27 算法的形式<br>28 迭代器的分类（category）<br>29 迭代器分类（category）对算法的影响<br>30 算法源代码剖析（11个例子）<br>31 仿函数和函数对象<br>32 存在多种Adapter<br>33 函数适配器Binder2nd<br>34 函数适配器not1<br>35 新型适配器bind<br>36 迭代器适配器reverse iterator<br>37 迭代器适配器inserter<br>38 ostream iterator<br>39 istream iterator</p>
<p><a href="https://lishizheng.blog.csdn.net/article/details/135481367">STL标准库与泛型编程（侯捷）笔记6</a></p>
<p>40 一个万用的hash function<br>41 Tuple 用例<br>42 type traits<br>43 type traits 实现<br>44 cout<br>45 movable元素对于不同容器速度效能的影响<br>46 测试函数</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>侯捷C++系列</category>
      </categories>
  </entry>
  <entry>
    <title>字符串与整数的相互转换</title>
    <url>/2024/04/26/1%20C++/%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<span id="more"></span>

<p>今天在做<strong>Leetcode 150. 逆波兰表达式求值</strong>一题时，涉及到字符串转换为整数的相关问题，遂进行如下探讨：</p>
<h2 id="1、字符串转换为整数"><a href="#1、字符串转换为整数" class="headerlink" title="1、字符串转换为整数"></a>1、字符串转换为整数</h2><h3 id="（1）四种转换方法"><a href="#（1）四种转换方法" class="headerlink" title="（1）四种转换方法"></a>（1）四种转换方法</h3>   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、stoi()，传入string类型</span></span><br><span class="line">  string s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">  <span class="type">int</span> num1 = <span class="built_in">stoi</span>(s1);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2、atoi()，传入const char *类型</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s2 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">  <span class="type">int</span> num2 = <span class="built_in">atoi</span>(s2);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3、stringstream</span></span><br><span class="line">  <span class="function">stringstream <span class="title">ss</span><span class="params">(s1)</span></span>;</span><br><span class="line">  <span class="type">int</span> num3;</span><br><span class="line">  ss &gt;&gt; num3;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="type">int</span> num4;</span><br><span class="line">  <span class="built_in">sscanf</span>(s1.<span class="built_in">c_str</span>(), <span class="string">&quot;%d&quot;</span>, &amp;num4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）为什么下面四行代码得到了如下结果？"><a href="#（2）为什么下面四行代码得到了如下结果？" class="headerlink" title="（2）为什么下面四行代码得到了如下结果？"></a>（2）为什么下面四行代码得到了如下结果？</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">stoi</span>(<span class="string">&quot;13&quot;</span>) &lt;&lt; endl;  <span class="comment">// 13</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;13&quot;</span> - <span class="string">&quot;0&quot;</span> &lt;&lt; endl;  <span class="comment">// -3</span></span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;1&#x27;</span> - <span class="string">&#x27;0&#x27;</span> &lt;&lt; endl;   <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;1&quot;</span> - <span class="string">&quot;0&quot;</span> &lt;&lt; endl;   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>解释如下：</p>
<ol>
<li><code>stoi(&quot;13&quot;)</code> 将字符串 “13” 转换为整数，结果是 13。</li>
<li><code>&quot;13&quot; - &quot;0&quot;</code> 这里使用了字符串字面值进行减法运算，实际上这是不允许的，因为 C++ 中字符串字面值不能直接进行减法运算。但是在这个上下文中，编译器会尝试将字符串字面值转换为字符指针，然后进行指针运算，因此得到的结果是字符指针之间的差，即指向字符串 “13” 和 “0” 的地址之间的距离，而不是它们所代表的整数之差。在这个例子中，”13” 的地址比 “0” 的地址大，因此结果是负值，具体数值取决于编译器和平台。</li>
<li><code>&#39;1&#39; - &#39;0&#39;</code> 是字符之间的减法运算。字符 ‘1’ 对应的 ASCII 码是 49，字符 ‘0’ 对应的 ASCII 码是 48，因此结果是 1。</li>
<li><code>&quot;1&quot; - &quot;0&quot;</code> 和第二行的情况类似，仍然是字符串字面值之间的指针运算，结果是字符串指针之间的差，而不是字符串所代表的整数之差。</li>
</ol>
<h2 id="2、整数转换为字符串"><a href="#2、整数转换为字符串" class="headerlink" title="2、整数转换为字符串"></a>2、整数转换为字符串</h2>   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">intToString</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">  string str;</span><br><span class="line">  <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> digit = num % <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> ch = digit + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    str = ch + str;  <span class="comment">// 将字符添加到字符串的前面</span></span><br><span class="line">    num /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、to_string</span></span><br><span class="line">  <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">  string str1 = <span class="built_in">to_string</span>(num);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2、stringstream</span></span><br><span class="line">  stringstream ss;</span><br><span class="line">  ss &lt;&lt; num;</span><br><span class="line">  string str2 = ss.<span class="built_in">str</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3、sprintf</span></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">20</span>];</span><br><span class="line">  <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">  <span class="function">string <span class="title">str</span><span class="params">(buffer)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4、自定义实现</span></span><br><span class="line">  str = <span class="built_in">intToString</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2024/06/12/1%20C++/%E5%86%85%E5%AD%98/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="一、shared-ptr-weak-ptr"><a href="#一、shared-ptr-weak-ptr" class="headerlink" title="一、shared_ptr &amp; weak_ptr"></a>一、shared_ptr &amp; weak_ptr</h1><p><a href="https://blog.csdn.net/ithiker/article/details/51532484">C++ 智能指针（shared_ptr&#x2F;weak_ptr）源码分析</a></p>
<h2 id="1、类关系图"><a href="#1、类关系图" class="headerlink" title="1、类关系图"></a>1、类关系图</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406121430079.png" alt="img"></p>
<p>shared_ptr内部包含：</p>
<ul>
<li>1）指向被管理对象(managed object)T的指针</li>
<li>2）__shared_count对象，其内部包含：<ul>
<li>a. 指向管理对象(manager object)的基类指针。</li>
</ul>
</li>
</ul>
<p>管理对象(manager object)内部包含：</p>
<ul>
<li>1）具有原子属性(_Atomic_word)的use_count&#x2F;weak_count</li>
<li>2）指向被管理对象(managed object)T的指针</li>
<li>3）用来销毁被管理对象的deleter</li>
</ul>
<p>被管理对象和管理对象的划分如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406121436387.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406121436029.png" alt="img"></p>
<p>可以看出，shared_ptr与weak_ptr的差异主要是由__shared_ptr与__weak_ptr体现出来的，而__shared_ptr与__weak_ptr的差异则主要是由__shared_count与__weak_count体现出来。</p>
<h2 id="2、详细分析"><a href="#2、详细分析" class="headerlink" title="2、详细分析"></a>2、详细分析</h2><h3 id="（1）shared-ptr的构造函数"><a href="#（1）shared-ptr的构造函数" class="headerlink" title="（1）shared_ptr的构造函数"></a>（1）shared_ptr的构造函数</h3><p>在创建一个<code>shared_ptr</code>的时候需要通过被管理对象的地址来初始化<code>shared_ptr</code>, <code>shared_ptr</code>在内部会构建一个<code>__shared_count</code>对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt; <span class="keyword">explicit</span> __shared_ptr(_Tp1* __p)</span><br><span class="line">: _M_ptr(__p), _M_refcount(__p) &#123;</span><br><span class="line">    <span class="comment">// 静态断言，确保 _Tp1* 可以转换为 _Tp*，用于类型安全检查</span></span><br><span class="line">    __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)</span><br><span class="line">    <span class="comment">// 确保 _Tp1 类型是完整的</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> _IsComplete[<span class="built_in">sizeof</span>(_Tp1)];</span><br><span class="line">    <span class="comment">// 启用 shared_from_this 的辅助功能，允许被管理对象在不知道其自身被管理的情况下创建其他 shared_ptr 实例</span></span><br><span class="line">    __enable_shared_from_this_helper(_M_refcount, __p, __p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>explicit __shared_ptr(_Tp1* __p)</code>：显式构造函数，接受一个 <code>_Tp1*</code> 类型的指针 <code>__p</code>，该指针通常是通过 <code>new</code> 操作符分配的。</li>
<li><code>: _M_ptr(__p), _M_refcount(__p)</code>：初始化列表，负责初始化 <code>__shared_ptr</code> 的成员变量。<ul>
<li><code>_M_ptr</code> 是一个<strong>指向被管理对象的指针</strong>，初始化为 <code>__p</code>。</li>
<li><code>_M_refcount</code> 是一个<strong>引用计数控制块</strong>，通常包含引用计数和自定义删除器等信息，也被初始化为 <code>__p</code>。</li>
</ul>
</li>
</ul>
<p>由<code>__shared_count</code>对象的构造函数可知，创建<code>shared_ptr</code>的时候也动态的创建了一个管理对象<code>_Sp_counted_base_impl</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line">__shared_count(_Ptr __p) : _M_pi(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    __try</span><br><span class="line">   &#123;</span><br><span class="line">	  <span class="keyword">typedef</span> <span class="keyword">typename</span> std::tr1::remove_pointer&lt;_Ptr&gt;::type _Tp;</span><br><span class="line">	  _M_pi = <span class="keyword">new</span> _Sp_counted_base_impl&lt;_Ptr, _Sp_deleter&lt;_Tp&gt;, _Lp&gt;(__p, _Sp_deleter&lt;_Tp&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    __catch(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> __p;</span><br><span class="line">	__throw_exception_again;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>shared_ptr</code>内部包含一个指向被管理对象的指针<code>_M_ptr</code>， <code>_Sp_counted_base_impl</code>内部也含有一个指向被管理对象的指针<code>_M_ptr</code>， 它们是不是重复多余了呢？</p>
</blockquote>
<p>实际上不多余，它们有各自的功能。首先给出结论：</p>
<blockquote>
<p><code>__shared_ptr</code>直接包含的裸指针是为了实现一般指针的<code>-&gt;</code>和<code>*</code>等操作；通过<code>__shared_count</code>间接包含的指针是为了管理对象的生命周期，回收相关资源。</p>
<p>换句话说，<code>__shared_count</code>内部的<code>use_count</code>主要用来标记被管理对象的生命周期，<code>weak_count</code>主要用来标记管理对象的生命周期。</p>
<p>当一个<code>shared_ptr</code>超出作用域被销毁时，它会调用其<code>_share_count</code>的<code>_M_release()</code>对<code>use_count</code>和<code>weak_count</code>进行自减并判断是否需要释放管理对象和被管理对象，这是<code>RAII</code>原理的核心体现。</p>
</blockquote>
<p>这首先要从<code>shared_ptr</code>的拷贝构造或者赋值构造说起。当一个<code>shared_ptr</code>对象<code>sp2</code>是由<code>sp1</code>拷贝构造或者赋值构造得来的时候，实际上<strong>构造完成后<code>sp1</code>内部的<code>__shared_count</code>对象包含的指向管理对象的指针与<code>sp2</code>内部的<code>__shared_count</code>对象包含的指向管理对象的指针是相等的</strong>，也就是说当多个<code>shared_ptr</code>对象来管理同一个对象时，它们共同使用同一个动态分配的管理对象。</p>
<p>这可以从下面的<code>__share_ptr</code>的构造函数和<code>__shared_count</code>的构造函数清楚地看出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line"> __shared_ptr(<span class="type">const</span> __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r)</span><br><span class="line"> : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) <span class="comment">// never throws</span></span><br><span class="line">&#123; __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;) &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">__shared_count&amp;</span><br><span class="line">    <span class="keyword">operator</span>=(<span class="type">const</span> __shared_count&amp; __r) <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">    <span class="keyword">if</span> (__tmp != _M_pi)  <span class="comment">// 避免自我赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__tmp != <span class="number">0</span>)</span><br><span class="line">            __tmp-&gt;_M_add_ref_copy();  <span class="comment">// 增加目标控制块的引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (_M_pi != <span class="number">0</span>)  </span><br><span class="line">            _M_pi-&gt;_M_release();  <span class="comment">// 减少当前控制块的引用计数</span></span><br><span class="line">        _M_pi = __tmp;   <span class="comment">// 更新当前实例的控制块指针 _M_pi，使其指向目标控制块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对<code>if (_M_pi != 0)</code>，考虑以下两种情况：</p>
<ul>
<li><pre><code class="c++">std::shared_ptr&lt;int&gt; sp1(new int(10));
std::shared_ptr&lt;int&gt; sp2;

// sp2 此时未初始化，_M_pi == 0
sp2 = sp1;  // 调用赋值运算符
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ ```c++</span><br><span class="line">  std::shared_ptr&lt;int&gt; sp1(new int(10));  // sp1指向new int(10)，其引用计数为1</span><br><span class="line">  std::shared_ptr&lt;int&gt; sp2(new int(11));  // sp2指向new int(11)，其引用计数为1</span><br><span class="line">  </span><br><span class="line">  // sp2已初始化，_M_pi != 0</span><br><span class="line">  sp2 = sp1;  // 调用赋值运算符，注意此处sp2指向的new int(11)引用计数减1，因此sp2和其指向的对象均被析构</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>针对<code>_M_add_ref_copy()</code>和<code>_M_release()</code>做进一步分析：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//************_Sp_counted_base*****************//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_M_add_ref_copy()</span><br><span class="line">&#123; __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, <span class="number">1</span>); &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//************_Sp_counted_base*****************//</span></span><br><span class="line"><span class="type">void</span> _M_release() <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">    <span class="comment">// 用于告知数据竞赛检测工具（如 ThreadSanitizer），在这行代码之前发生了内存同步事件</span></span><br><span class="line">    <span class="comment">// 确保线程间正确通信</span></span><br><span class="line">    _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 减少引用计数，并检查是否是最后一个引用</span></span><br><span class="line">    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, <span class="number">-1</span>) == <span class="number">1</span>)  <span class="comment">// 减少引用计数 _M_use_count，并返回减少前的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 另一个内存同步事件，通知数据竞赛检测工具此时的引用计数减少操作已经完成</span></span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);</span><br><span class="line">      </span><br><span class="line">        _M_dispose();  <span class="comment">// 释放对象资源</span></span><br><span class="line">        <span class="comment">// There must be a memory barrier between dispose() and destroy()</span></span><br><span class="line">        <span class="comment">// to ensure that the effects of dispose() are observed in the</span></span><br><span class="line">        <span class="comment">// thread that runs destroy().</span></span><br><span class="line">        <span class="comment">// See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html</span></span><br><span class="line">        <span class="comment">// 确保在 _M_dispose() 和 _M_destroy() 之间有一个内存屏障，</span></span><br><span class="line">        <span class="comment">// 以确保所有 _M_dispose() 的效果对调用 _M_destroy() 的线程可见</span></span><br><span class="line">        <span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)</span><br><span class="line">        &#123;</span><br><span class="line">            __atomic_thread_fence (__ATOMIC_ACQ_REL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">        <span class="comment">// 通知数据竞赛检测工具弱引用计数的操作即将开始</span></span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 减少弱引用计数，并检查是否是最后一个弱引用</span></span><br><span class="line">        <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 另一个内存同步事件，通知数据竞赛检测工具此时的弱引用计数减少操作已经完成</span></span><br><span class="line">            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">                        </span><br><span class="line">            _M_destroy();  <span class="comment">// 释放控制块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//************_Sp_counted_base*****************//</span></span><br><span class="line"><span class="comment">// Called when _M_use_count drops to zero, to release the resources</span></span><br><span class="line"><span class="comment">// managed by *this.</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="type">void</span></span><br><span class="line">_M_dispose() = <span class="number">0</span>; <span class="comment">// nothrow</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Called when _M_weak_count drops to zero.</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="type">void</span></span><br><span class="line">_M_destroy() <span class="comment">// nothrow</span></span><br><span class="line">&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//************_Sp_counted_base_impl*************//</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="type">void</span></span><br><span class="line">_M_dispose() <span class="comment">// nothrow</span></span><br><span class="line">&#123; _M_del(_M_ptr); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）weak-ptr对应的-weak-count的拷贝构造函数"><a href="#（2）weak-ptr对应的-weak-count的拷贝构造函数" class="headerlink" title="（2）weak_ptr对应的__weak_count的拷贝构造函数"></a>（2）weak_ptr对应的__weak_count的拷贝构造函数</h3><ul>
<li><code>__weak_count</code>相关的赋值拷贝以及析构函数均只会影响到<code>weak_count</code>的值，对<code>use_count</code>没有影响；当<code>weak_count</code>为0时，释放管理对象。也就是说<code>__weak_ptr</code>不影响被管理对象的生命周期。同时由于<code>__weak_ptr</code>没有像<code>__shared_ptr</code>那样实现<code>*</code>，<code>-&gt;</code>等常见指针相关操作符，<code>__weak_ptr</code>不能直接操作被管理对象；</li>
<li><code>__weak_count</code>自身间的赋值以及<code>__shared_count</code>对<code>__weak_count</code>的赋值时，它们都具有同样的指向管理对象的指针；也就是说当多个<code>__weak_ptr</code>和<code>__shared_ptr</code>指向同一个被管理对象时，它们共享同一个管理对象，这就保证了可以通过<code>__weak_ptr</code>可以判断<code>__shared_ptr</code>指向的被管理对象是否存在以及获取到被管理对象的指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//************_Sp_counted_base*****************//</span></span><br><span class="line"> <span class="type">void</span></span><br><span class="line"> _M_weak_add_ref() <span class="comment">// nothrow</span></span><br><span class="line">&#123; __gnu_cxx::__atomic_add_dispatch(&amp;_M_weak_count, <span class="number">1</span>); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//************_Sp_counted_base*****************//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_M_weak_release() <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Be race-detector-friendly. For more info see bits/c++config.</span></span><br><span class="line">    _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);</span><br><span class="line">    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">	<span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">// See _M_release(),</span></span><br><span class="line">	    <span class="comment">// destroy() must observe results of dispose()</span></span><br><span class="line">            __atomic_thread_fence (__ATOMIC_ACQ_REL);</span><br><span class="line">	&#125;</span><br><span class="line">	_M_destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">__weak_count&lt;_Lp&gt;&amp;</span><br><span class="line">operator=(<span class="type">const</span> __shared_count&lt;_Lp&gt;&amp; __r) <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">    <span class="keyword">if</span> (__tmp != <span class="number">0</span>)</span><br><span class="line">        __tmp-&gt;_M_weak_add_ref();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">        _M_pi-&gt;_M_weak_release();</span><br><span class="line">  </span><br><span class="line">    _M_pi = __tmp;  </span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> *this;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">__weak_count&lt;_Lp&gt;&amp;</span><br><span class="line">operator=(<span class="type">const</span> __weak_count&lt;_Lp&gt;&amp; __r) <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">    <span class="keyword">if</span> (__tmp != <span class="number">0</span>)</span><br><span class="line">        __tmp-&gt;_M_weak_add_ref();</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">        _M_pi-&gt;_M_weak_release();</span><br><span class="line">    _M_pi = __tmp;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> *this;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">__weak_count&lt;_Lp&gt;&amp;</span><br><span class="line">operator=(<span class="type">const</span> __shared_count&lt;_Lp&gt;&amp; __r) <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">    <span class="keyword">if</span> (__tmp != <span class="number">0</span>)</span><br><span class="line">      __tmp-&gt;_M_weak_add_ref();</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">      _M_pi-&gt;_M_weak_release();</span><br><span class="line">    _M_pi = __tmp;  </span><br><span class="line">    <span class="keyword">return</span> *this;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">~__weak_count() <span class="comment">// nothrow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">        _M_pi-&gt;_M_weak_release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）-shared-ptr与-weak-ptr管理同一对象"><a href="#（3）-shared-ptr与-weak-ptr管理同一对象" class="headerlink" title="（3）__shared_ptr与__weak_ptr管理同一对象"></a>（3）__shared_ptr与__weak_ptr管理同一对象</h3><p>关系图如下所示：</p>
<p>其中<code>weak_ptr</code>不能直接操作被管理对象，但其仍然持有指向被管理对象的指针（用来初始化内部的<code>__weak_count</code>对象），<code>weak_ptr</code>与被管理对象用虚线联接。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406121521900.png" alt="img"></p>
<h3 id="（4）shared-ptr的两个“大坑”"><a href="#（4）shared-ptr的两个“大坑”" class="headerlink" title="（4）shared_ptr的两个“大坑”"></a>（4）shared_ptr的两个“大坑”</h3><h4 id="A-当一个对象M创建后，如果一个函数f（另一个类的成员函数或是其它自由函数）的形参为M类型的智能指针，如何在对象M内部将对象M的指针作为实参传递给该函数f"><a href="#A-当一个对象M创建后，如果一个函数f（另一个类的成员函数或是其它自由函数）的形参为M类型的智能指针，如何在对象M内部将对象M的指针作为实参传递给该函数f" class="headerlink" title="A. 当一个对象M创建后，如果一个函数f（另一个类的成员函数或是其它自由函数）的形参为M类型的智能指针，如何在对象M内部将对象M的指针作为实参传递给该函数f ?"></a>A. 当一个对象M创建后，如果一个函数f（另一个类的成员函数或是其它自由函数）的形参为M类型的智能指针，如何在对象M内部将对象M的指针作为实参传递给该函数f ?</h4><blockquote>
<p><code>shared_ptr</code>能够管理对象的生命周期，负责对象资源释放，其前提条件是所有<code>shared_ptr</code>共用同一个管理对象。如果<strong>多个<code>shared_ptr</code>使用多个管理对象来管理同一个被管理对象</strong>，这些管理对象在<code>use_count</code>为<code>0</code>时均会释放被管理对象，将会造成多个管理对象多次释放被管理对象，造成<code>twice delete</code>的堆错误。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">defrangulate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transmogrify</span><span class="params">(Thing *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Thing * t1 = <span class="keyword">new</span> Thing;</span><br><span class="line">	t1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">delete</span> t1; <span class="comment">// done with the object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thing::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// we need to transmogrify this object</span></span><br><span class="line">	<span class="built_in">transmogrify</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transmogrify</span><span class="params">(Thing * ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ptr-&gt;<span class="built_in">defrangulate</span>();</span><br><span class="line">	<span class="comment">/* etc. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***** Use shared_ptr***************************//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">defrangulate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transmogrify</span><span class="params">(shared_ptr&lt;Thing&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;Thing&gt; <span class="title">t1</span><span class="params">(<span class="keyword">new</span> Thing)</span></span>; <span class="comment">// create manager object A for the Thing</span></span><br><span class="line">	t1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Thing is supposed to get deleted when t1 goes out of scope</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thing::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// we need to transmogrify this object</span></span><br><span class="line">	<span class="function">shared_ptr&lt;Thing&gt; <span class="title">sp_for_this</span><span class="params">(<span class="keyword">this</span>)</span></span>; <span class="comment">//  create manager object B for the Thing</span></span><br><span class="line">	<span class="built_in">transmogrify</span>(sp_for_this);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Thing is supposed to get deleted when sp_for_this and other shared_ptr goes out of scope</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transmogrify</span><span class="params">(shared_ptr&lt;Thing&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ptr-&gt;<span class="built_in">defrangulate</span>();</span><br><span class="line">	<span class="comment">/* etc. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++引入了<code>enable_shared_from_this</code>，利用<code>weak_ptr</code>的特性解决了这一问题。</p>
<p>其基本思想是：通过<code>M</code>继承模板类<code>enable_shared_from_this</code>，这样对象<code>M</code>内部将会有一个<code>__weak_ptr</code>指针<code>_M_weak_this</code>，在第一次创建指向<code>M</code>的<code>shared_ptr</code>时，通过模板特化，将会初始化<code>_M_weak_this</code>。这样<code>M</code>内部也会产生一个指向自身的<code>weak_ptr</code>，并且该<code>weak_ptr</code>内部的管理对象与Pt的管理对象是相同的（这可以从<code>weak_ptr</code>内部的<code>_M_assign</code>函数看出）。</p>
<p>这样，在<code>M</code>内部，当需要传递指向<code>M</code>的智能指针时，可以通过继承而来的<code>shared_from_this</code>方法获取到指向<code>M</code>的智能指针而不会发生内存泄漏。上面示例中改写后的正确代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span> : <span class="keyword">public</span> enable_shared_from_this&lt;Thing&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">defrangulate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// The following starts a manager object for the Thing and also</span></span><br><span class="line">	<span class="comment">// initializes the weak_ptr member that is now part of the Thing and share same manager object.</span></span><br><span class="line">	<span class="function">shared_ptr&lt;Thing&gt; <span class="title">t1</span><span class="params">(<span class="keyword">new</span> Thing)</span></span>;</span><br><span class="line">	t1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thing::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// get a shared_ptr from the weak_ptr in this object</span></span><br><span class="line">	shared_ptr&lt;Thing&gt; sp_this = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	<span class="built_in">transmogrify</span>(sp_this);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transmogrify</span><span class="params">(shared_ptr&lt;Thing&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ptr-&gt;<span class="built_in">defrangulate</span>();</span><br><span class="line">	<span class="comment">/* etc. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="B-在采用shared-ptr-p-new-M-形式创建p来管理M时，这中间有两次的动态内存分配：一次为创建被管理对象M，一次为创建管理对象；而内存分配通常是比较昂贵的操作"><a href="#B-在采用shared-ptr-p-new-M-形式创建p来管理M时，这中间有两次的动态内存分配：一次为创建被管理对象M，一次为创建管理对象；而内存分配通常是比较昂贵的操作" class="headerlink" title="B. 在采用shared_ptr&lt;M&gt; p(new M)形式创建p来管理M时，这中间有两次的动态内存分配：一次为创建被管理对象M，一次为创建管理对象；而内存分配通常是比较昂贵的操作"></a>B. 在采用<code>shared_ptr&lt;M&gt; p(new M)</code>形式创建p来管理M时，这中间有两次的动态内存分配：一次为创建被管理对象M，一次为创建管理对象；而内存分配通常是比较昂贵的操作</h4><p>如果频繁的需要创建指向多个不同对象的智能指针，可以采用<code>shared_ptr&lt;M&gt; p(make_shared&lt;M&gt;)</code>的方式，采用这种方式<strong>系统将会分配一大块内存同时存放管理对象和被管理对象</strong>，这就避免了上面所说的二次内存分配的问题，同时程序中也不会出现<code>new</code>操作符，符合<code>&quot;no naked new!&quot;</code>的编程倡导。</p>
<p>当然这也有缺点，如果所有指向该对象的智能指针都销毁了，尽管对象的析构函数会被调用，析构被管理对象，但是<strong>如果还有<code>weak_ptr</code>指向该块对象所在的内存，存放管理对象的部分内存仍将不会被释放</strong>，因而导致在所有其他<code>weak_ptr</code>销毁前整块内存（尽管被管理对象已经析构了）将不会进入系统的内存池循环使用。</p>
<h1 id="二、unique-ptr"><a href="#二、unique-ptr" class="headerlink" title="二、unique_ptr"></a>二、unique_ptr</h1><p><code>unique_ptr</code>是智能指针的一种，他<strong>只可移动不可复制</strong>，即一个指针的所有权只能由一个智能指针所占有。</p>
<p><code>unique_ptr</code>内部靠一个<code>tuple</code>来维护<code>raw pointer</code>和<code>deleter</code>。<code>unique_ptr</code>相当于一个对<code>RAII</code>的封装，他在栈上有一个指针，指针指向堆中实际分配的内存，当栈上指针生命周期结束时，自动调用<code>deleter</code>去释放堆上内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _Tp为管理对象的类型，_Dp为析构器的类型</span></span><br><span class="line"><span class="comment">// default_delete是默认析构器，默认析构器中使用delete运算符实现对象的析构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用__uniq_ptr_impl管理要管理的heap对象</span></span><br><span class="line">    <span class="comment">// _Tp为管理对象类型，_Dp为析构器</span></span><br><span class="line">    __uniq_ptr_impl&lt;_Tp, _Dp&gt; _M_t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> pointer    = <span class="keyword">typename</span> __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer;</span><br><span class="line">    <span class="keyword">using</span> element_type  = _Tp;</span><br><span class="line">    <span class="keyword">using</span> deleter_type  = _Dp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1、-uniq-ptr-impl"><a href="#1、-uniq-ptr-impl" class="headerlink" title="1、__uniq_ptr_impl"></a>1、__uniq_ptr_impl</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _Tp为管理对象的类型，_Dp为析构器的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__uniq_ptr_impl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> _Ptr</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> type = _Up*;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// pointer实际上就是_Tp*</span></span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="keyword">typename</span> _Ptr&lt;_Tp, _Dp&gt;::type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 使用tuple管理指针和析构器，通过get&lt;0&gt;获取_Tp*，get&lt;1&gt;获取析构器</span></span><br><span class="line">    tuple&lt;pointer, _Dp&gt; _M_t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    __uniq_ptr_impl() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 先通过_M_t()获取指针，再赋值</span></span><br><span class="line">    __uniq_ptr_impl(pointer __p) : _M_t() &#123; _M_ptr() = __p; &#125;</span><br><span class="line">    <span class="comment">// 自定义析构器</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Del&gt;</span><br><span class="line">    __uniq_ptr_impl(pointer __p, _Del&amp;&amp; __d) : _M_t(__p, std::forward&lt;_Del&gt;(__d)) &#123; &#125;</span><br><span class="line">    <span class="comment">// 获取所管理的对象</span></span><br><span class="line">    pointer&amp;   _M_ptr() &#123; <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(_M_t); &#125;</span><br><span class="line">    <span class="comment">// 获取析构器</span></span><br><span class="line">    _Dp&amp;       _M_deleter() &#123; <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(_M_t); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、构造函数和析构函数"><a href="#2、构造函数和析构函数" class="headerlink" title="2、构造函数和析构函数"></a>2、构造函数和析构函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数，显式创建一个空的unique_ptr对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Up = _Dp, <span class="keyword">typename</span> = _DeleterConstraint&lt;_Up&gt;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span> : _M_t() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指针__p构造一个unique_ptr对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Up = _Dp, <span class="keyword">typename</span> = _DeleterConstraint&lt;_Up&gt;&gt;</span><br><span class="line"><span class="keyword">explicit</span> <span class="built_in">unique_ptr</span>(pointer __p) <span class="keyword">noexcept</span> : _M_t(__p) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指针__p和自定义析构器__d构造一个unique_ptr对象</span></span><br><span class="line"><span class="built_in">unique_ptr</span>(pointer __p,</span><br><span class="line">    <span class="keyword">typename</span> conditional&lt;is_reference&lt;deleter_type&gt;::value,</span><br><span class="line">      deleter_type, <span class="type">const</span> deleter_type&amp;&gt;::type __d) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__p, __d) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Disable copy from lvalue.不允许复制，体现专属所有权语义</span></span><br><span class="line"><span class="comment">// 使用了C++11特性delete</span></span><br><span class="line"><span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move constructor.体现专属所有权语义和只移型别</span></span><br><span class="line"><span class="comment">// 只允许使用移动拷贝构造函数</span></span><br><span class="line"><span class="comment">// 如果复制一个unique_ptr对象，会将源unique_ptr对象管理的资源release掉</span></span><br><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__u.<span class="built_in">release</span>(), std::forward&lt;deleter_type&gt;(__u.<span class="built_in">get_deleter</span>())) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个也是移动拷贝构造函数</span></span><br><span class="line"><span class="comment">// 只是使用的类型是可以隐式转换的其他unique_ptr对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep, <span class="keyword">typename</span> = _Require&lt;</span><br><span class="line">         __safe_conversion_up&lt;_Up, _Ep&gt;,</span><br><span class="line">   <span class="keyword">typename</span> conditional&lt;is_reference&lt;_Dp&gt;::value,</span><br><span class="line">      is_same&lt;_Ep, _Dp&gt;,</span><br><span class="line">      is_convertible&lt;_Ep, _Dp&gt;&gt;::type&gt;&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__u.<span class="built_in">release</span>(), std::forward&lt;_Ep&gt;(__u.<span class="built_in">get_deleter</span>()))</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assignment，也可以说明是专属所有权语义和只移型别</span></span><br><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// __u.release()释放并返回源unique_ptr对象管理的资源</span></span><br><span class="line">    <span class="comment">// reset是将__u.release()返回的资源赋给目标（当前）unique_ptr对象</span></span><br><span class="line">    <span class="built_in">reset</span>(__u.<span class="built_in">release</span>());</span><br><span class="line">    <span class="built_in">get_deleter</span>() = std::forward&lt;deleter_type&gt;(__u.<span class="built_in">get_deleter</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数，调用析构器析构掉管理的资源，并将__ptr指向nullptr</span></span><br><span class="line">~<span class="built_in">unique_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; __ptr = _M_t._M_ptr();</span><br><span class="line">    <span class="keyword">if</span> (__ptr != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">get_deleter</span>()(__ptr);</span><br><span class="line">    __ptr = <span class="built_in">pointer</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get_deleter()(__ptr);的解读</span></span><br><span class="line"><span class="comment">// get_deleter()返回的是析构器，默认的析构器为struct default_delete&lt;_Tp&gt;</span></span><br><span class="line"><span class="comment">// struct default_delete&lt;_Tp&gt;有一个operator()操作符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp* __ptr)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> __ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所以get_deleter()(__ptr);实际上就是delete __ptr;</span></span><br></pre></td></tr></table></figure>

<h2 id="3、成员函数"><a href="#3、成员函数" class="headerlink" title="3、成员函数"></a>3、成员函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以像raw pointer一样，解引用</span></span><br><span class="line"><span class="keyword">typename</span> add_lvalue_reference&lt;element_type&gt;::type <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    __glibcxx_assert(<span class="built_in">get</span>() != <span class="built_in">pointer</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像raw pointer一样获取保存的指针，调用get方法</span></span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    _GLIBCXX_DEBUG_PEDASSERT(<span class="built_in">get</span>() != <span class="built_in">pointer</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> _M_t._M_ptr(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放对所管理资源的所有权</span></span><br><span class="line"><span class="function">pointer <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pointer __p = <span class="built_in">get</span>();</span><br><span class="line">    _M_t._M_ptr() = <span class="built_in">pointer</span>();</span><br><span class="line">    <span class="keyword">return</span> __p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置所管理的资源</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(pointer __p = pointer())</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(_M_t._M_ptr(), __p);</span><br><span class="line">    <span class="keyword">if</span> (__p != <span class="built_in">pointer</span>() <span class="built_in">get_deleter</span>()(__p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、unique-ptr的使用"><a href="#4、unique-ptr的使用" class="headerlink" title="4、unique_ptr的使用"></a>4、unique_ptr的使用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Investment</span> &#123;&#125;; <span class="comment">// 待管理对象</span></span><br><span class="line"><span class="comment">// 默认的析构器struct default_delete&lt;_Tp&gt;实际上是一个仿函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们就可以定义一个lambd作为析构器</span></span><br><span class="line"><span class="keyword">auto</span> delInvmt = [](Investment* pInvestment)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">makeLogEntry</span>(pInvestment); <span class="comment">// 做一些删除前的工作</span></span><br><span class="line">                    <span class="keyword">delete</span> pInvestment;</span><br><span class="line">                &#125;;</span><br><span class="line"><span class="comment">// 使用decltype推到出自定义析构器的类型</span></span><br><span class="line"><span class="function">unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmt)</span>&gt; <span class="title">pInv</span><span class="params">((<span class="keyword">new</span> Investment), delInvmt)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果要自定义析构器，就必须使用构造函数，而无法通过C++14提供的make_unique函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Investment</span></span><br><span class="line">&#123;</span><br><span class="line">  ~<span class="built_in">Investment</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;called ~Investment()...&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> ivmt = [](Investment* pInvestment)</span><br><span class="line">        &#123;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;user-defined delete...&quot;</span> &lt;&lt; endl;</span><br><span class="line">          <span class="keyword">delete</span> pInvestment;</span><br><span class="line">        &#125;;</span><br><span class="line">  <span class="comment">// 包在括号中，方便观察结果</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(ivmt)</span>&gt; <span class="title">pInvestment</span><span class="params">((<span class="keyword">new</span> Investment), ivmt)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">user-defined <span class="keyword">delete</span>...</span><br><span class="line">called ~<span class="built_in">Investment</span>()...</span><br></pre></td></tr></table></figure>

<p>另外<code>unique_ptr</code>不允许以赋值语法将一个<code>raw pointer</code>当作初值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unipue_ptr&lt;<span class="type">int</span>&gt; pInt = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>); <span class="comment">// error</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pInt</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">2</span>))</span></span>;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>不能使用普通的拷贝或者赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pInt1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">2</span>))</span></span>; <span class="comment">// pInt1现在为左值</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pInt2</span><span class="params">(pInt1)</span></span>;      <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要使用移动语义，使用move将左值转为右值</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pInt2</span><span class="params">(std::move(pInt1))</span></span>;</span><br><span class="line"></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; pInt2;</span><br><span class="line">pInt2 = pInt1; <span class="comment">// error</span></span><br><span class="line">pInt2 = std::<span class="built_in">move</span>(pInt1);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>内存</category>
      </categories>
  </entry>
  <entry>
    <title>内存管理机制</title>
    <url>/2024/04/30/1%20C++/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="第一讲-Primitives"><a href="#第一讲-Primitives" class="headerlink" title="第一讲 Primitives"></a>第一讲 Primitives</h1><h2 id="2-内存分配的每一层面"><a href="#2-内存分配的每一层面" class="headerlink" title="2 内存分配的每一层面"></a>2 内存分配的每一层面</h2><blockquote>
<ul>
<li>C++内存分配的深度一般是有五个层面，它们分别是<ul>
<li>C++ application 常见：vector等容器</li>
<li>C++ allocator 常见：vector自带的allocator分配器</li>
<li>C++ primitives 常见：new delete</li>
<li>CRT 常见：malloc free</li>
<li>OS API 常见：heapalloc等等</li>
</ul>
</li>
</ul>
<p>一般情况下，为了保证可移植性质，一般最底层就到了malloc free，如果调用OS API就基本上丧失了可移植性质。每一个层面的对应的基本上都会依次向下调用，然后进行内存的分配。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404301822840.png" alt="4_内存管理_01"></p>
<p>C++ memory primitives</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302008310.png" alt="4_内存管理_02"></p>
<h2 id="3-四个层面的基本用法"><a href="#3-四个层面的基本用法" class="headerlink" title="3 四个层面的基本用法"></a>3 四个层面的基本用法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>				 <span class="comment">//std::allocator  </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext\pool_allocator.h&gt;</span>	 <span class="comment">//欲使用 std::allocator 以外的 allocator, 就得自行 #include &lt;ext/...&gt; </span></span></span><br><span class="line"><span class="keyword">namespace</span> jj01</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_primitives</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\ntest_primitives().......... \n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="type">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">512</span>);	<span class="comment">//512 bytes</span></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">    complex&lt;<span class="type">int</span>&gt;* p2 = <span class="keyword">new</span> complex&lt;<span class="type">int</span>&gt;; <span class="comment">//one object</span></span><br><span class="line">    <span class="keyword">delete</span> p2;             </span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p3 = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="number">512</span>); <span class="comment">//512 bytes</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下使用 C++ 標準庫提供的 allocators。</span></span><br><span class="line"><span class="comment">//其接口雖有標準規格，但實現廠商並未完全遵守；下面三者形式略異。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">    <span class="comment">//以下兩函數都是 non-static，定要通過 object 調用。以下分配 3 個 ints.</span></span><br><span class="line">    <span class="type">int</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">3</span>, (<span class="type">int</span>*)<span class="number">0</span>); </span><br><span class="line">    <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p4,<span class="number">3</span>);           </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __BORLANDC__</span></span><br><span class="line">    <span class="comment">//以下兩函數都是 non-static，定要通過 object 調用。以下分配 5 個 ints.</span></span><br><span class="line">    <span class="type">int</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">5</span>);  </span><br><span class="line">    <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p4,<span class="number">5</span>);       </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line">    <span class="comment">//以下兩函數都是 static，可通過全名調用之。以下分配 512 bytes.(GNUC 2.9)</span></span><br><span class="line">    <span class="comment">//void* p4 = alloc::allocate(512); </span></span><br><span class="line">    <span class="comment">//alloc::deallocate(p4,512);   </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下兩函數都是 non-static，定要通過 object 調用。以下分配 7 個 ints.(GNUC 4.9) </span></span><br><span class="line">	<span class="type">void</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">7</span>); </span><br><span class="line">    <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="type">int</span>*)p4,<span class="number">7</span>);     </span><br><span class="line">	</span><br><span class="line">    <span class="comment">//以下兩函數都是 non-static，定要通過 object 調用。以下分配 9 個 ints.(GNUC 4.9) 	</span></span><br><span class="line">	<span class="type">void</span>* p5 = __gnu_cxx::__pool_alloc&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">9</span>); </span><br><span class="line">    __gnu_cxx::__pool_alloc&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="type">int</span>*)p5,<span class="number">9</span>);	</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;	</span><br><span class="line">&#125; <span class="comment">//namespace</span></span><br></pre></td></tr></table></figure>

<h2 id="4-基本构件之一new-delete-expression上"><a href="#4-基本构件之一new-delete-expression上" class="headerlink" title="4 基本构件之一new delete expression上"></a>4 基本构件之一new delete expression上</h2><ul>
<li>new expression（即new operator）（详见<a href="https://hioomph.github.io/2024/04/24/Computer/C++/new%E4%B8%8Eoperator%20new/">new与operator new</a>）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302012729.png" alt="https://hioomph.github.io/2024/04/24/Computer/C++/new%E4%B8%8Eoperator%20new/"></p>
<ul>
<li><p>右上角的operator new的实现（VC98版）</p>
<ol>
<li>调用malloc函数；</li>
<li>若malloc无法分配内存，就一直在while循环中：调用_callnewh，即一个new handler，用于处理内存分配失败的情况。</li>
</ol>
<blockquote>
<p>_callnewh 不是 C++ 标准中的函数，而是可能是用户定义的一个函数。通常情况下，这类函数的名字以 _new_handler 结尾，用于处理内存分配失败的情况。</p>
<p>在 C++ 中，当 new 表达式无法分配所需的内存时，会调用用户指定的 new_handler 函数。new_handler 是一个函数指针，指向一个用户定义的函数，其原型通常为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数可以尝试释放内存、扩大内存池，或者执行其他操作来尝试解决内存不足的问题。如果 new_handler 能够成功处理内存不足的情况，它返回；如果不能处理，它可以选择抛出异常或者终止程序。</p>
</blockquote>
</li>
</ul>
<h2 id="5-基本构件之一new-delete-expression中"><a href="#5-基本构件之一new-delete-expression中" class="headerlink" title="5 基本构件之一new delete expression中"></a>5 基本构件之一new delete expression中</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302021318.png" alt="4_内存管理_06"></p>
<h2 id="6-基本构件之一new-delete-expression下"><a href="#6-基本构件之一new-delete-expression下" class="headerlink" title="6 基本构件之一new delete expression下"></a>6 基本构件之一new delete expression下</h2><p>下面显示不能直接调用构造函数，而只有编译器会进行隐式调用。调用时在vc6编译通过，在GCC中编译失败。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A* pA = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">1</span>);         	<span class="comment">//ctor. this=000307A8 id=1</span></span><br><span class="line">cout &lt;&lt; pA-&gt;id &lt;&lt; endl;   	<span class="comment">//1</span></span><br><span class="line"><span class="comment">//!	pA-&gt;A::A(3);                //in VC6 : ctor. this=000307A8 id=3</span></span><br><span class="line">  								<span class="comment">//in GCC : [Error] cannot call constructor &#x27;jj02::A::A&#x27; directly</span></span><br><span class="line">  								</span><br><span class="line"><span class="comment">//!	A::A(5);	  				//in VC6 : ctor. this=0013FF60 id=5</span></span><br><span class="line">                      			<span class="comment">//         dtor. this=0013FF60  	</span></span><br><span class="line">  								<span class="comment">//in GCC : [Error] cannot call constructor &#x27;jj02::A::A&#x27; directly</span></span><br><span class="line">  								<span class="comment">//         [Note] for a function-style cast, remove the redundant &#x27;::A&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-Array-new"><a href="#7-Array-new" class="headerlink" title="7 Array new"></a>7 Array new</h2><p>（1）array new和array delete的搭配使用</p>
<p>如果<code>new[]</code>不搭配<code>delete[]</code>的话，实际上是针对<code>class with pointer member</code>的情况造成内存泄漏。<strong>此时若调用<code>delete</code>，带有<code>cookie</code>的动态数组部分实际上仍然会被回收，发生错误的地方是需要调用3次析构函数（如下图右边），但实际上只调用了1次，因此造成内存泄漏</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Complex* pca = <span class="keyword">new</span> Complex[<span class="number">3</span>];  <span class="comment">// 调用三次构造函数</span></span><br><span class="line"><span class="keyword">delete</span>[] pca;  <span class="comment">// 唤起三次析构函数， 这是正确的</span></span><br><span class="line"></span><br><span class="line">string* psa = <span class="keyword">new</span> string[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> psa;  <span class="comment">// 唤起一次析构函数，这是错误的</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302024595.png" alt="4_内存管理_08"></p>
<p>（2）array size in memory size</p>
<ul>
<li>右侧的图是new int[10]的内存布局，其中：<strong>灰色</strong>表示具体数据，<strong>橙色</strong>表示debug模式下添加的内存，最上面和最下面的两个0x61(61H)是cookie，记录整体内存分配的大小；<strong>浅蓝色</strong>的pad表示补齐，填补到16的倍数。<ul>
<li>61H实际上是60H，表示内存分配的大小，后面1H意思是占用最后一位，表示内存分配出去</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302027115.png" alt="4_内存管理_10"></p>
<h2 id="8-placement-new"><a href="#8-placement-new" class="headerlink" title="8 placement new"></a>8 placement new</h2><p>palcement new允许我们将object建构于allocated memory中。<strong>没有所谓的placement new，因为placement new根本没分配memory。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">sizeof</span>(Complex) * <span class="number">3</span>]; <span class="comment">// 已经分配了内存</span></span><br><span class="line">Complex* pc = <span class="built_in">new</span>(buf)<span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 把上面分配的内存位置传进来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br></pre></td></tr></table></figure>

<p>其中<code>Complex* pc = new(buf)Complex(1, 2);</code>这句话会被编译器转换为下图中的1，2，3三行，分别调用operator new（和上文看到的不同，这里需要第二个参数，表示位置，这个函数只是传回这个位置，不再分配内存），指针转型，调用构造函数。</p>
<p>这种用法被称为 “placement new”，它允许程序员在指定的内存位置上创建对象。这通常用于特殊的内存管理场景，例如在预分配的内存池中创建对象。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302031495.png" alt="4_内存管理_12"></p>
<h2 id="9-重载"><a href="#9-重载" class="headerlink" title="9 重载"></a>9 重载</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302031922.png" alt="4_内存管理_13"></p>
<p>（1）C++容器分配内存的途径</p>
<p>容器会走分配器，分配器会调用::operator new和::operator delete，底层也是调用malloc和free。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302033606.png" alt="4_内存管理_14"></p>
<p>在 C++ 中，容器使用分配器（Allocator）来进行内存分配和释放。分配器是负责管理容器内部元素内存的组件。下面是容器分配内存的一般途径：</p>
<ol>
<li><p>容器使用分配器：<br>C++ 容器（如 std::vector、std::list、std::map 等）通常使用分配器来分配和释放内存。分配器是容器的一部分，负责处理元素的内存分配和释放操作。</p>
</li>
<li><p>分配器调用 ::operator new 和 ::operator delete：<br>分配器的实现通常会调用全局作用域下的 ::operator new 来分配内存，并在需要释放内存时调用 ::operator delete。<br>::operator new 和 ::operator delete 是 C++ 中的全局内存分配和释放函数。它们底层可能调用标准库的 malloc 和 free。</p>
</li>
<li><p>底层可能调用 malloc 和 free：<br>malloc 和 free 是 C 标准库中的内存分配和释放函数，用于分配和释放原始的、未构造的内存块。C++ 的 ::operator new 和 ::operator delete 可能在底层调用这些函数。</p>
</li>
</ol>
<p>总体来说，C++ 容器使用分配器来管理内存，而分配器可能在其实现中调用 ::operator new 和 ::operator delete，从而涉及到底层的内存分配函数 malloc 和 free。这种设计允许用户自定义容器的内存管理行为，以适应不同的需求。用户可以通过提供自定义分配器来实现特定的内存分配策略。</p>
<p>（2）重载全局的::operator new 和::operator delete</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302034363.png" alt="4_内存管理_15"></p>
<p>（3）重载operator new和operator delete</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302034714.png" alt="4_内存管理_16"></p>
<p>（3）重载operator new[]和operator delete[]</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302035382.png" alt="4_内存管理_17"></p>
<h2 id="10-重载示例（上）"><a href="#10-重载示例（上）" class="headerlink" title="10 重载示例（上）"></a>10 重载示例（上）</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302036272.png" alt="4_内存管理_18"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302036230.png" alt="4_内存管理_19"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302036668.png" alt="4_内存管理_20"></p>
<h2 id="11-重载示例（下）"><a href="#11-重载示例（下）" class="headerlink" title="11 重载示例（下）"></a>11 重载示例（下）</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302036617.png" alt="4_内存管理_21"></p>
<p>placement new的重载第一参数必须是size_t类型，对于如何区分operator new和placement new，要看调用的时候怎么用。在调用时，编译器会根据传递给new表达式的参数来匹配适当的重载版本。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302038221.png" alt="4_内存管理_22"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302038657.png" alt="4_内存管理_23"></p>
<p>basic_string使用new(extra)扩充申请量</p>
<p>重载了operator new，其实是placement new。因为用法为<code>new(extra) Rep;</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302038299.png" alt="4_内存管理_24"></p>
<h2 id="12-Per-class-allocator"><a href="#12-Per-class-allocator" class="headerlink" title="12 Per class allocator"></a>12 Per class allocator</h2><p>（1）内存池</p>
<p>内存池是一种用于管理和分配内存的机制，它可以提高内存分配的效率，减少内存碎片，并降低动态内存分配的开销。在 C++ 中，内存池通常通过重载 operator new 和 operator delete 来实现。</p>
<p>下面简要描述一下内存池的概念，并提供一个简单的示意图：</p>
<ol>
<li><p>内存池概念：</p>
<ul>
<li>内存池是一块预先分配的内存区域，它被划分为多个小块，每个小块可以被分配给程序使用；</li>
<li>内存池通常由一个或多个链表、堆栈或其他数据结构来管理，以追踪哪些内存块是空闲的，哪些是已分配的；</li>
<li>内存池的目的是减少因频繁的内存分配和释放而引起的性能开销。</li>
</ul>
</li>
<li><p>示意图：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+------------------------------------+</span><br><span class="line">|            Memory Pool             |</span><br><span class="line">+------------------------------------+</span><br><span class="line">|   Free Block <span class="number">1</span>   |   Free Block <span class="number">2</span>  |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">|   Allocated Block <span class="number">1</span>                |</span><br><span class="line">+------------------------------------+</span><br><span class="line">|   Free Block <span class="number">3</span>   |   Free Block <span class="number">4</span>  |</span><br><span class="line">+------------------+-----------------+</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的示意图展示了一个简单的内存池，其中包含多个内存块，有一些是空闲的，有一些是已经分配给程序使用的；</li>
<li>每个内存块的大小可能不同，取决于内存池的设计；</li>
<li>空闲的内存块可以通过链表或其他数据结构连接在一起，以便快速分配。</li>
</ul>
</li>
<li><p>内存池的操作：</p>
<ul>
<li>当程序需要分配内存时，内存池会从空闲块中选择一个合适的块分配给程序；</li>
<li>当程序释放内存时，将相应的内存块标记为空闲，并重新加入空闲块链表，以便下次分配使用。</li>
</ul>
</li>
<li><p>自定义内存池的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> size;</span><br><span class="line">        Block* next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Block* freeList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MemoryPool</span>(<span class="type">size_t</span> poolSize) &#123;</span><br><span class="line">        <span class="comment">// 初始化内存池</span></span><br><span class="line">        <span class="type">void</span>* memory = ::<span class="keyword">operator</span> <span class="built_in">new</span>(poolSize);</span><br><span class="line">        freeList = <span class="built_in">static_cast</span>&lt;Block*&gt;(memory);</span><br><span class="line">        freeList-&gt;size = poolSize;</span><br><span class="line">        freeList-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从内存池中分配内存</span></span><br><span class="line">        <span class="keyword">if</span> (!freeList || freeList-&gt;size &lt; size) &#123;</span><br><span class="line">            <span class="comment">// 内存不足，或者没有空闲块，可以根据实际情况扩展内存池</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Block* allocatedBlock = freeList;</span><br><span class="line">        freeList = freeList-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(allocatedBlock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放内存到内存池</span></span><br><span class="line">        Block* block = <span class="built_in">static_cast</span>&lt;Block*&gt;(ptr);</span><br><span class="line">        block-&gt;next = freeList;</span><br><span class="line">        freeList = block;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述示例为了简洁，省略了一些内存池的管理细节</span></span><br><span class="line"><span class="comment">// 实际的内存池实现可能需要更复杂的数据结构和算法。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>引入内存池的考量：</p>
<p>当需要多次调用new来分配内存时，为了减少malloc分配内存的数量，以及减少cookie的用量，可以选择用malloc分配一大块内存（即内存池），然后将这块内存池分成小块，在实际的分配时直接取用其中的一小块，从而减少malloc的调用次数。</p>
</blockquote>
<p>（2）对类Screen进行内存设置的示例（设计类的内存分配器_版本1）</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302045487.png" alt="4_内存管理_25"></p>
<p>如下图右侧所示：</p>
<ul>
<li>左边间隔8，表示每个Screen对象内存分配的大小为8B，说明每个Screen分配的时候没有cookie；</li>
<li>右边间隔16，表示每个Screen对象内存分配的大小为16B，这是因为对象分配的时候上下加了cookie，最上面和最下面的cookie大小共为8B。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302046008.png" alt="4_内存管理_26"></p>
<h2 id="13-Per-class-allocator-2"><a href="#13-Per-class-allocator-2" class="headerlink" title="13 Per class allocator 2"></a>13 Per class allocator 2</h2><p>（1）设计类的内存分配器_版本2</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302047081.png" alt="4_内存管理_27"></p>
<p>这里和第一版本的最大不同是设计上采用union。</p>
<p>在C++中，union 是一种特殊的数据结构，允许在相同的内存位置存储不同类型的对象。它的每个成员共享相同的内存空间，只能同时使用一个成员。union 提供了一种有效利用内存的方式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AirplaneRep</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> miles;  <span class="comment">// 4B</span></span><br><span class="line">	<span class="type">char</span> type;  <span class="comment">// 1B</span></span><br><span class="line">    <span class="comment">// 由于对齐，这5B会变成8B</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">	AirplaneRep rep;</span><br><span class="line">	Airplane* next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302047903.png" alt="4_内存管理_28"></p>
<h2 id="14-Static-allocator"><a href="#14-Static-allocator" class="headerlink" title="14 Static allocator"></a>14 Static allocator</h2><p>（1）设计类的内存分配器_版本3</p>
<p>下面是内存分配的第三版本。</p>
<p>从软件工程的角度看，上面的operator new和operator delete对于不同 类都要重载，明显不是一个好的解法，下面是将allocator抽象成一个类。</p>
<p>allocator类中定义allocate和deallocate函数，用于分配和回收。</p>
<p>下图中右侧是具体的实现。这里每次分配CHUNK个大小的一大块，然后切割成小块，并用链表串起来。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302049167.png" alt="4_内存管理_29"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302049165.png" alt="4_内存管理_30"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302049639.png" alt="4_内存管理_31"></p>
<h2 id="15-Macro-for-static-allocator"><a href="#15-Macro-for-static-allocator" class="headerlink" title="15 Macro for static allocator"></a>15 Macro for static allocator</h2><p>（1）设计类的内存分配器_版本4</p>
<p>把allocator的部分拿出来用宏来定义。</p>
<p>在C++中，宏（macro）是一种预处理指令，用于在编译过程中执行文本替换。宏通常通过 #define 关键字定义，并在代码中通过宏名称来调用。它们是一种简单的文本替换机制，可以用于创建常量、函数替代、条件编译等。</p>
<p>在宏定义的末尾使用反斜杠是为了告诉编译器该宏定义将在下一行继续。如果在宏定义的最后一行没有使用反斜杠，那么编译器会认为宏定义结束了。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302050403.png" alt="4_内存管理_32"></p>
<p>（2）标准库中的allocator</p>
<p>其中一种分配器有16条自由链表，来应对不同大小的块分配，不同的大小的类对象，分配到不同的链表中。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302050613.png" alt="4_内存管理_34"></p>
<h2 id="16-New-Handler"><a href="#16-New-Handler" class="headerlink" title="16 New Handler"></a>16 New Handler</h2><p>new handler</p>
<p>new handler 是一个与 C++ 内存分配和 new 操作符相关的概念。它是一个函数指针，指向一个用户定义的函数，该函数负责处理 new 操作符无法满足内存分配请求时的情况。</p>
<p>当 new 操作符无法分配所需的内存时，它会调用与之关联的 new handler。new handler 可以执行一些操作，例如释放一些已分配的内存、尝试扩展堆的大小、选择性地抛出异常，或者执行其他用户定义的操作。</p>
<p>使用 set_new_handler 函数设置 new handler：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">customNewHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed! Custom new handler called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::<span class="built_in">terminate</span>();  <span class="comment">// 终止程序或者执行其他处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(customNewHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试分配大块内存</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1000000000000</span>];  <span class="comment">// 如果分配失败，会调用 customNewHandler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，通过 set_new_handler 函数设置了一个自定义的 new handler，即 customNewHandler。当 new 操作符在尝试分配非常大的内存块时失败，会调用这个自定义的 new handler。</p>
<p>注意事项：</p>
<ul>
<li>new handler 是全局的，一旦设置，会在程序的生命周期内一直有效，直到被其他<code>set_new_handler</code>覆盖。</li>
<li>如果 new handler 返回，new 操作符会再次尝试分配内存，如果还失败，则再次调用 new handler。这个过程会一直重复，直到 new handler 抛出异常或者不返回（例如调用 <code>std::terminate()</code>）。</li>
<li>在 C++11 及以后的版本中，可以使用 std::get_new_handler 获取当前的 new handler，以便在需要时进行保存和恢复。</li>
</ul>
<p>使用 new handler 可以提供一些灵活性，允许程序员在内存分配失败的情况下采取定制的操作，而不是默认的行为（即抛出 std::bad_alloc 异常）。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302052495.png" alt="4_内存管理_35"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302052411.png" alt="4_内存管理_36"></p>
<h1 id="第二讲-std-allocator"><a href="#第二讲-std-allocator" class="headerlink" title="第二讲 std::allocator"></a>第二讲 std::allocator</h1><h2 id="17-VC6-malloc"><a href="#17-VC6-malloc" class="headerlink" title="17 VC6 malloc"></a>17 VC6 malloc</h2><p>VC6下的malloc内存块布局：从上往下分别是cookie，debug header, 实际数据的block, debug tail, pad, cookie，对应于下图。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062002434.png" alt="在这里插入图片描述"></p>
<p>在VC6（Visual C++ 6.0）下，malloc 函数分配的内存块的布局包含以下部分：</p>
<ul>
<li><p>Cookie（饼干）：<br>Cookie 是一小段额外的标识信息，用于在边界检查中检测缓冲区溢出。它通常是一个特殊的值，放置在分配的内存块的开始位置。记录内存分配出去的大小。</p>
</li>
<li><p>Debug Header（调试头部）：<br>Debug Header 包含一些调试信息，例如分配的文件名、行号等。这些信息用于调试和跟踪内存分配的源。</p>
</li>
<li><p>实际数据的 Block：<br>这是分配的实际数据块，用于存储程序员请求的数据。</p>
</li>
<li><p>Debug Tail（调试尾部）：<br>Debug Tail 包含与调试信息相关的尾部数据。类似于 Debug Header，它包含一些额外的调试信息。</p>
</li>
<li><p>Pad（填充）：<br>填充是为了确保分配的内存块满足特定的对齐要求。它可能包含一些额外的字节，使得整个内存块的大小满足特定的对齐条件。</p>
</li>
<li><p>Cookie（饼干）：<br>与开头的 Cookie 相对应，是分配的内存块的结束位置。</p>
</li>
</ul>
<p>这样的内存布局在 VC6 中用于调试和检测内存溢出等问题。Cookie 和调试信息是为了帮助调试过程，检测潜在的内存错误。在实际的发布版本中，这些额外的调试信息通常会被省略，以减小内存开销。 VC6 是相对较老的版本，现代的 Visual C++ 版本可能采用了更高效和精简的内存分配方案。</p>
<h2 id="18-VC6标准分配器之实现"><a href="#18-VC6标准分配器之实现" class="headerlink" title="18 VC6标准分配器之实现"></a>18 VC6标准分配器之实现</h2><p>VC6标准分配器allocator的实现，里面的allocate和deallocate的实现只是调用<code>::operator new </code>和<code>::operator delete</code>, 没有任何特殊设计。我们知道它们底层是malloc和free，所以具体分配的时候是带有cookie的，存在内存浪费的现象。</p>
<p>这里分配的单位是具体的类型，比如<code>allocator&lt;int&gt;().allocate(512,(int*)0);</code>分配的就是512个int类型的大小。而后面讲到的一个分配器是以字节为单位，不是以具体类型的大小为单位。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062004430.png" alt="在这里插入图片描述"></p>
<h2 id="19-BC5标准分配器之实现"><a href="#19-BC5标准分配器之实现" class="headerlink" title="19 BC5标准分配器之实现"></a>19 BC5标准分配器之实现</h2><p>Borland5 编译器的allocator的实现，里面的allocate和deallocate的实现只是调用<code>::operator new</code> 和<code>::operator delete</code>, 没有任何特殊设计。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062004019.png" alt="在这里插入图片描述"></p>
<h2 id="20-G2-9标准分配器之实现"><a href="#20-G2-9标准分配器之实现" class="headerlink" title="20 G2.9标准分配器之实现"></a>20 G2.9标准分配器之实现</h2><p>GNU C++2.9标准分配器std::allocator的实现，里面的allocate和deallocate的实现只是调用<code>::operator new </code>和<code>::operator delete</code>, 没有任何特殊设计。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062005939.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>GNU C++2.9容器使用的分配器，不是std::allocator,而是std::alloc</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* p = alloc::<span class="built_in">allocate</span>(<span class="number">512</span>); <span class="comment">// 分配512bytes，不是512个int或者512个double类型等等</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062006939.png" alt="在这里插入图片描述"></p>
<h2 id="21-G2-9-std-alloc-VS-G4-9-pull-alloc"><a href="#21-G2-9-std-alloc-VS-G4-9-pull-alloc" class="headerlink" title="21 G2.9 std::alloc VS G4.9 __pull_alloc"></a>21 G2.9 std::alloc VS G4.9 __pull_alloc</h2><blockquote>
<p>G2.9 std::alloc在G4.9中是 __pull_alloc。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062006172.png" alt="在这里插入图片描述"></p>
<p>G4.9版本中标准分配器std::allocator的实现，里面的allocate和deallocate的实现只是调用::operator new 和::operator delete, 没有任何特殊设计。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062006067.png" alt="在这里插入图片描述"></p>
<h2 id="22-G4-9-pull-alloc用例"><a href="#22-G4-9-pull-alloc用例" class="headerlink" title="22 G4.9 __pull_alloc用例"></a>22 G4.9 __pull_alloc用例</h2><p>这里的alloc（G2.9的叫法, G4.9叫做__pull_alloc）用法, 它在__gnu_cxx这个命名空间内。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>, __gnu_cxx::__pool_alloc&lt;<span class="type">int</span>&gt;&gt; vecPool;</span><br></pre></td></tr></table></figure>

<p>这个分配器是去除了cookie（一个元素带有上下两个cookie，共8B），可以省很多的内存空间。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062007981.png" alt="在这里插入图片描述"></p>
<h2 id="23-G2-9-std-alloc"><a href="#23-G2-9-std-alloc" class="headerlink" title="23 G2.9 std::alloc"></a>23 G2.9 std::alloc</h2><p>（1）alloc的运作模式</p>
<p>第一讲中介绍的Per class allocator类，每个类里面重载了 operator new和operator delete，每个类都单独维护一个链表。如下图所示，<code>std::alloc</code>为所有的类维护16个链表，每个链表负责不同大小的区块分配，从小到大分别为：<code>8B, 16B, 24B, 32B, …, 128B</code>，按8的倍数增长。<strong>当大小不为8的倍数的时候，分配器会自动将其对齐到8的倍数。当大小超过128B时，就交给malloc来单独处理。</strong></p>
<blockquote>
<p>这里可以联系到面经中的问答：malloc函数的底层实现是什么？及相关问题。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011019232.png" alt="4_内存管理_51"></p>
<p><strong>举例：</strong>对于<code>#3</code>链表，每次将分配一大块内存给它（负责32B区块的分配，里面有20个小块，每个都是32B，但是实际分配的时候是20块的两倍大小，剩余的部分可能分配给其他的<code>#x</code>链表）。当一个vector里面存储一个32B的stone类型的对象，会在<code>#3</code>链表里指定一小块给该对象。</p>
<p>（2）embedded pointers</p>
<blockquote>
<p>嵌入式指针工作原理：借用A对象所占用的内存空间中的前4个字节，这4个字节用来 链住这些空闲的内存块；<br>但是，一旦某一块被分配出去，那么这个块的 前4个字节 就不再需要，此时这4个字节可以被正常使用；</p>
<p>参考:<a href="https://blog.csdn.net/qq_42604176/article/details/113871565">https://blog.csdn.net/qq_42604176/article/details/113871565</a></p>
<p>内存的使用方法是,使用的时候看成对象实例,空闲的时候会看成next指针.</p>
<p>参考：<a href="https://github.com/KinWaiYuen/KinWaiYuen.github.io/blob/master/c%2B%2B/%E4%BE%AF%E6%8D%B7%E5%86%85%E5%AD%98.md">https://github.com/KinWaiYuen/KinWaiYuen.github.io/blob/master/c%2B%2B/%E4%BE%AF%E6%8D%B7%E5%86%85%E5%AD%98.md</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011041526.png" alt="4_内存管理_52"></p>
<h2 id="24-G2-9-std-alloc运行一瞥01-05"><a href="#24-G2-9-std-alloc运行一瞥01-05" class="headerlink" title="24 G2.9 std::alloc运行一瞥01-05"></a>24 G2.9 std::alloc运行一瞥01-05</h2><p>（1）源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;                        <span class="comment">//小區塊的上調邊界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;                  <span class="comment">//小區塊的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;; <span class="comment">//free-lists 個數</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// union obj &#123;                   //G291[o],CB5[x],VC6[x]</span></span><br><span class="line"><span class="comment">//   union obj* free_list_link;  //這麼寫在 VC6 和 CB5 中也可以，</span></span><br><span class="line"><span class="comment">// &#125;;                            //但以後就得使用 &quot;union obj&quot; 而不能只寫 &quot;obj&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__obj</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__obj</span>* free_list_link;</span><br><span class="line">&#125; obj;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*   start_free = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>*   end_free = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span>  heap_size = <span class="number">0</span>;</span><br><span class="line">obj* free_list[__NFREELISTS]</span><br><span class="line">     = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="meta"># enum &#123;__ALIGN = 8&#125;;  </span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ROUND_UP</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个常量<code>__ALIGN</code>，它表示内存分配时的对齐边界，设定为8字节。然后，定义了一个函数 <code>ROUND_UP</code>，该函数接受一个大小（<code>bytes</code>）作为参数，然后将其上调到对齐边界。</p>
<p>具体来说，<code>ROUND_UP</code>函数的作用是将传入的大小（<code>bytes</code>）上调到<code>__ALIGN</code>的倍数。这是通过以下步骤实现的：</p>
<ul>
<li>将<code>bytes</code>加上<code> __ALIGN-1</code>，即<code> bytes + 7</code>；</li>
<li>对结果进行按位与操作，通过<code>&amp; ~(__ALIGN - 1)</code>将最低的3位清零，确保结果是<code>__ALIGN</code>的倍数。</li>
</ul>
<blockquote>
<p>这样做的目的是为了满足内存对齐的要求。在一些硬件体系结构中，访问未对齐的内存可能会导致性能问题或者错误，因此内存分配时通常需要对齐到某个特定的边界。这个函数就提供了一种简单的方法来确保分配的内存大小是对齐的。</p>
</blockquote>
<p>（2）std::alloc运行01-05</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053088.png" alt="4_内存管理_53"></p>
<ol start="2">
<li>当一个容器里面存储的元素大小是<code>32B</code>时，它的运作过程如下：</li>
</ol>
<ul>
<li><p>挂在<code>32 / 8 - 1 = #3</code>号链表；</p>
</li>
<li><p>刚开始的时候pool为空，此时要分配<code>32 * 20 *2 + RoundUp(0 &gt;&gt; 4)= 1280B</code>大小的空间为pool，然后从pool里面切割20个小块（共640B）挂在<code>#3</code>链表上。第1个给容器，剩下的19个挂在<code>#3</code>链表；</p>
</li>
<li><p>此时pool的余量为<code>640B</code>。RoundUp是追加量，里面的大小是把上次的累计申请量右移4位(除以16)，由于这里是刚开始，没有累计申请量，故为0&gt;&gt;4。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053848.png" alt="4_内存管理_54"></p>
</li>
</ul>
<ol start="3">
<li>此时，又创建了新的容器，它里面的元素大小为<code>64B</code></li>
</ol>
<ul>
<li>对应#7链表；</li>
<li>此时链表为空。由于上页的pool里面还剩<code>640B</code>，现在将其切分为<code>640/64 = 10</code>个区块，第1个给容器，剩下的9个挂在<code>#7</code>链表；</li>
<li>此时pool的余量为<code>0B</code>，因为被切分挂到链表上了。<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053984.png" alt="4_内存管理_55"></li>
</ul>
<ol start="4">
<li>在上面的基础上，现在新建容器，它的元素大小为<code>96B</code></li>
</ol>
<ul>
<li>对应<code>96 / 8 - 1 = #11</code>链表；</li>
<li>先检查pool是否有余量，由于pool为空，此时调用malloc分配一大块作为pool，总共大小为<code>96x 20 x 2 + RoundUp(1280 &gt;&gt; 4) = 3840 + 80 = 3920B</code>，切割20个区块拿出来用，第1个给容器，另外19个挂在<code>#11</code>链表上；</li>
<li>此时pool的余量为<code>3920−(96×20)=3920−1920=2000 B</code>。累计申请量是1280 + 3920 &#x3D; 5200B。<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053482.png" alt="4_内存管理_56"></li>
</ul>
<ol start="5">
<li>再次新建容器，里面元素大小是<code>88B</code></li>
</ol>
<ul>
<li><p>挂在<code>88 / 8 - 1 = #10</code>号链表；</p>
</li>
<li><p>现在pool中的余量为<code>2000B</code>，将2000B切分为20个区块（每个区块88B），第1个给容器，剩下的19个挂在<code>#10</code>链表上；</p>
</li>
<li><p>此时pool的余量为<code>2000 - 88 x 20 = 240B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053390.png" alt="4_内存管理_57"></p>
</li>
</ul>
<h2 id="25-G2-9-std-alloc运行一瞥06-10"><a href="#25-G2-9-std-alloc运行一瞥06-10" class="headerlink" title="25 G2.9 std::alloc运行一瞥06-10"></a>25 G2.9 std::alloc运行一瞥06-10</h2><ol start="6">
<li>下面这张图表示容器**连续申请3次<code>88B</code>**大小的空间</li>
</ol>
<ul>
<li><p>由于上面已经在<code>#10</code>链表上挂了19个大小为<code>88B</code>的区块，这时候直接从该链表上拿下来3个区块返回给容器即可；</p>
</li>
<li><p>此时pool的余量为<code>240B</code>没变。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021045105.png" alt="4_内存管理_58"></p>
</li>
</ul>
<ol start="7">
<li>又来新的容器，它的元素大小为8B</li>
</ol>
<ul>
<li><p>挂在<code>8 / 8 - 1 = #0</code>号链表；</p>
</li>
<li><p>根据06，pool容量为<code>240B</code>，从pool里面切分出20个区块，共<code>8B x 20 = 160B</code>大小，第1个返回给容器，其余19个区块挂在<code>#0</code>链表上；</p>
</li>
<li><p>此时pool的余量为<code>240 - 160 = 80B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021045366.png" alt="4_内存管理_59"></p>
</li>
</ul>
<ol start="8">
<li>又来新的容器，它的元素大小为<code>104B</code></li>
</ol>
<ul>
<li><p>挂在<code>104 / 8 - 1 = #12</code>链表；</p>
</li>
<li><p>由于此时pool余量为<code>80B</code>，一个大小为<code>104B</code>的区块都切分不了。此时这个<code>80B</code>大小的空间就是碎片，需要将其挂在<code>80 / 8 - 1 = #9</code>链表上。碎片处理完之后， 再来应付现在的需求：<code>104B</code>的分配；</p>
</li>
<li><p>现在再调用<code>malloc</code>分配一大块，大小为<code>104 x 20 x 2 + RoundUp(5200 &gt;&gt; 4) = 4160 + RoundUp(325) = 4160 + 328 = 4488</code>；把第1个分配给容器，切出的19个挂在<code>#12</code>链表上。累计申请量为<code>5200 + 4488 = 9688B</code>；</p>
</li>
<li><p>此时pool的余量为<code>4488 - 104 x 20 = 2408B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021045618.png" alt="4_内存管理_60"></p>
</li>
</ul>
<ol start="9">
<li>现在申请<code>112B</code></li>
</ol>
<ul>
<li><p>挂在<code>112 / 8 - 1 = #13</code>链表上；</p>
</li>
<li><p>根据08，pool容量为<code>2408B</code>，从里面取出<code>112 * 20 = 2240B</code>，第1个返回给容器，留下19个挂在<code>#13</code>链表上；</p>
</li>
<li><p>此时pool的余量为<code>2408 - 2240 = 168B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021045344.png" alt="4_内存管理_61"></p>
</li>
</ul>
<ol start="10">
<li>现在的新需求是申请<code>48B</code></li>
</ol>
<ul>
<li>挂在<code>48 / 8 - 1 = #5</code>链表上；</li>
<li>根据09，pool余量是<code>168B</code>，可以分配<code>168 / 48 = 3</code>个区块，第1个返回给容器，剩下2个挂在<code>#5</code>链表上；</li>
<li>此时pool的余量为<code>24B</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021046301.png" alt="4_内存管理_62"></p>
<h2 id="26-G2-9-std-alloc运行一瞥11-13"><a href="#26-G2-9-std-alloc运行一瞥11-13" class="headerlink" title="26 G2.9 std::alloc运行一瞥11-13"></a>26 G2.9 std::alloc运行一瞥11-13</h2><p>下面看一下内存分配失败的动作。</p>
<ol start="11">
<li>新的容器请求<code>72B</code>的大小</li>
</ol>
<ul>
<li><p>挂在<code>72 / 8 - 1 = #8</code>链表；</p>
</li>
<li><p>pool容量为<code>24B</code>，不足以分配一个大小为<code>72B</code>的区块，于是这个大小为<code>24B</code>的pool就成为碎片，需要先挂在<code>24 / 8 - 1 = #2</code>链表，所以把这个pool余量挂在#2链表, 然后调用malloc分配<code>72 x 20 x 2 + RoundUP(9688 &gt;&gt; 4) = 3488B</code>。在实验过程中把系统heap大小设置为<code>10000B</code>，前面已经累计分配了<code>9688B</code>，因此无法满足本次内存分配。</p>
</li>
<li><p>此时，alloc从手中资源取最接近<code>72B</code>的大小回填pool，这里最接近的是<code>80B</code>(即在<code>#9</code>链表有1个空的区块可用)，然后从其<code>80B</code>中切<code>72B</code>给容器，此时pool的余量为<code>80 - 72 = 8B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021131569.png" alt="4_内存管理_63"></p>
</li>
</ul>
<ol start="12">
<li>容器再申请<code>72B</code></li>
</ol>
<ul>
<li><p><code>#8</code>链表没有区块可用，而pool余量为<code>8B</code>，不足以供应1个区块。因此先将pool余量挂在<code>#0</code>链表上，然后想要调用malloc分配<code>72 x 20 x 2 + RoundUP(9688 &gt;&gt; 4) = 3488B</code>的空间，此时依然无法满足分配；</p>
</li>
<li><p>于是alloc从手中资源取最接近<code>72B</code>的<code>88B</code>（#10链表）回填pool。因为上面的<code>80B</code>（<code>#9</code>链表）已经用完了，从<code>88B</code>中切出<code>72B</code>返回给容器；</p>
</li>
<li><p>此时pool余量为<code>88 - 72 = 16B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021133827.png" alt="4_内存管理_64"></p>
</li>
</ul>
<ol start="13">
<li>新的容器申请<code>120B</code></li>
</ol>
<ul>
<li><p>挂在<code>120 / 8 - 1 = #14</code>链表；</p>
</li>
<li><p>同样的，pool供应不足，先将上面的<code>16B</code>挂在<code>#1</code>链表上，再想要malloc分配一大块也分配不出，无法满足需求；</p>
</li>
<li><p>于是，alloc从手中资源中取最接近<code>120B</code>的区块回填pool，但是<code>#14</code>链表和<code>#15</code>链表都是空的，于是无法分配。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021135087.png" alt="4_内存管理_65"></p>
</li>
</ul>
<ol start="14">
<li>检讨</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021135931.png" alt="4_内存管理_66"></p>
<h2 id="27-G2-9-std-alloc源码剖析（上）"><a href="#27-G2-9-std-alloc源码剖析（上）" class="headerlink" title="27 G2.9 std::alloc源码剖析（上）"></a>27 G2.9 std::alloc源码剖析（上）</h2><p>GNU C++2.9 分配器的设计：分为两级分配器，分别是第一级分配器和第二级分配器.</p>
<ol>
<li>第一级分配器</li>
</ol>
<p>其中<strong>第一级分配器不重要</strong>，主要模拟new handler的作用，处理一下内存分配的情况。下列图片是第一级分配器的代码。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041115341.png" alt="4_内存管理_67"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041115436.png" alt="4_内存管理_68"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041116564.png" alt="4_内存管理_69"></p>
<ol start="2">
<li>第二级分配器</li>
</ol>
<p>（1）定义</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041140479.png" alt="4_内存管理_70"></p>
<ul>
<li><p>ROUND_UP：将分配的大小变成8的倍数；</p>
</li>
<li><p>FREELIST_INDEX：根据bytes的大小指定分配到哪个链表；</p>
</li>
<li><p>几个变量的作用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>*   start_free = <span class="number">0</span>; <span class="comment">// 指向战备池pool的头</span></span><br><span class="line"><span class="type">char</span>*   end_free = <span class="number">0</span>;   <span class="comment">// 指向战备池pool的尾</span></span><br><span class="line"><span class="type">size_t</span>  heap_size = <span class="number">0</span>;  <span class="comment">// 累计分配大小</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>（2）最重要的两个函数：allocate和deallocate</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041141570.png" alt="4_内存管理_71"></p>
<ul>
<li><p><code>allocate</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span>  <span class="comment">//n must be &gt; 0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  obj* <span class="keyword">volatile</span> *my_free_list;    <span class="comment">//obj** my_free_list;</span></span><br><span class="line">  obj* result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>)__MAX_BYTES) &#123; <span class="comment">// 大于128B，交给第一级分配器来分配</span></span><br><span class="line">      <span class="keyword">return</span>(<span class="built_in">malloc_allocate</span>(n));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);  <span class="comment">// 定位到几号链表</span></span><br><span class="line">  result = *my_free_list;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;  <span class="comment">// 该链表为空</span></span><br><span class="line">      <span class="type">void</span>* r = <span class="built_in">refill</span>(<span class="built_in">ROUND_UP</span>(n));  <span class="comment">// 链表充值，从pool中去拿区块，链表有了可用区块</span></span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 指针指向下一个可用区块</span></span><br><span class="line">  *my_free_list = result-&gt;free_list_link;</span><br><span class="line">  <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041143025.png" alt="4_内存管理_72"></p>
</li>
<li><p><code>deallocate</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> n)</span>  <span class="comment">//p may not be 0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  obj* q = (obj*)p;</span><br><span class="line">  obj* <span class="keyword">volatile</span> *my_free_list;  <span class="comment">//obj** my_free_list;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>) __MAX_BYTES) &#123;  <span class="comment">// 大于128B，改用第一级分配器进行回收</span></span><br><span class="line">      <span class="built_in">malloc_deallocate</span>(p, n);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 回收过来的p指针指向的区块，挂在单向链表的头</span></span><br><span class="line">  my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);  <span class="comment">// 指向16个链表中的一个，比如list #6,如下图所示</span></span><br><span class="line">  q-&gt;free_list_link = *my_free_list;  <span class="comment">// q的next指向单向链表的头，就是list #6指向的具体区块的单向链表（free_list_link即next指针）</span></span><br><span class="line">  *my_free_list = q;  <span class="comment">// my_free_list重新指向新的单向链表q，因为头指针被换成新的了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041143591.png" alt="4_内存管理_73"></p>
</li>
</ul>
<h2 id="28-G2-9-std-alloc源码剖析（中）"><a href="#28-G2-9-std-alloc源码剖析（中）" class="headerlink" title="28 G2.9 std::alloc源码剖析（中）"></a>28 G2.9 std::alloc源码剖析（中）</h2><ul>
<li><code>refill</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041150983.png" alt="4_内存管理_75"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="comment">// Returns an object of size n, and optionally adds</span></span><br><span class="line"><span class="comment">// to size n free list. We assume that n is properly aligned.</span></span><br><span class="line"><span class="comment">// We hold the allocation lock.</span></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">refill</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span>* chunk = <span class="built_in">chunk_alloc</span>(n,&amp;nobjs);</span><br><span class="line">    obj* <span class="keyword">volatile</span> *my_free_list;   <span class="comment">//obj** my_free_list;</span></span><br><span class="line">    obj* result;</span><br><span class="line">    obj* current_obj;</span><br><span class="line">    obj* next_obj;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);</span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Build free list in chunk</span></span><br><span class="line">    result = (obj*)chunk;</span><br><span class="line">    *my_free_list = next_obj = (obj*)(chunk + n);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;  ; ++i) &#123;</span><br><span class="line">      current_obj = next_obj;</span><br><span class="line">      next_obj = (obj*)((<span class="type">char</span>*)next_obj + n);</span><br><span class="line">      <span class="keyword">if</span> (nobjs<span class="number">-1</span> == i) &#123;</span><br><span class="line">          current_obj-&gt;free_list_link = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          current_obj-&gt;free_list_link = next_obj;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，next_obj 的计算是为了在内存块（chunk）上构建一个链表，以形成一个自由链表（free list）。这个链表将被用于分配对象。让我们解释一下这行代码的目的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">next_obj = (obj*)((<span class="type">char</span>*)next_obj + n);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>next_obj</code>是一个指向当前空闲块的指针，它一开始指向<code>chunk + n</code>，即第一个可用的内存块；</li>
<li><code>(char*)next_obj</code>将<code>next_obj</code>强制类型转换为<code>char*</code>类型，这是因为我们希望按字节递增，而不是按对象递增；</li>
<li><code>((char*)next_obj + n)</code>表示将指针移动到下一个内存块的起始位置，即当前内存块的末尾加上一个对象的大小<code>n</code>；</li>
<li><code>(obj*)((char*)next_obj + n)</code>将移动后的指针重新转换为<code>obj*</code>类型，以便正确指向下一个空闲块的起始位置。</li>
</ul>
<p>这样，通过不断地按对象大小 n 的步长在内存块上移动，构建了一个包含多个空闲块的链表。这个链表可以有效地用于分配对象。这种处理方式是为了确保链表中相邻的空闲块之间的间隔是 n 字节，从而满足对象的对齐需求。</p>
<p>在上述代码中，for 循环的第二个条件 ; 是一个空语句，表示没有额外的条件来控制循环的执行。这意味着 for 循环会一直执行，直到执行到 break 语句为止。</p>
<p>在这个具体的代码中，循环的目的是为了在内存块上构建一个链表，将多个空闲块连接在一起。循环体中的 if 语句用于判断是否已经遍历了 nobjs-1 个空闲块。如果是，则最后一个空闲块的 free_list_link 设置为 0，表示链表的结束。此时，break 语句被执行，跳出循环。</p>
<p>因此，循环终止的条件是遍历了 nobjs-1 个空闲块，确保链表的正确构建，并在最后一个空闲块处设置了结束标志。循环的终止是由 break 语句触发的，而不是由循环条件控制的。</p>
<ul>
<li><code>chunk_alloc</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041210910.png" alt="4_内存管理_74"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041210501.png" alt="4_内存管理_75"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="comment">// We allocate memory in large chunks in order to</span></span><br><span class="line"><span class="comment">// avoid fragmentingthe malloc heap too much.</span></span><br><span class="line"><span class="comment">// We assume that size is properly aligned.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocates a chunk for nobjs of size &quot;size&quot;.</span></span><br><span class="line"><span class="comment">// nobjs may be reduced if it is inconvenient to</span></span><br><span class="line"><span class="comment">// allocate the requested number.</span></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="comment">//char* chunk_alloc(size_t size, int&amp; nobjs)  //G291[o],VC6[x],CB5[x]</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">chunk_alloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span>* nobjs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span>* result;</span><br><span class="line">  <span class="comment">// 调用chunk_alloc的时候，nobjs为20，所以默认total_bytes为20个区块的大小</span></span><br><span class="line">  <span class="type">size_t</span> total_bytes = size * (*nobjs);   <span class="comment">// 原nobjs改為 (*nobjs)</span></span><br><span class="line">  <span class="type">size_t</span> bytes_left = end_free - start_free; <span class="comment">// pool中剩余的字节个数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. pool空间足以满足20块需求</span></span><br><span class="line">  <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;  </span><br><span class="line">      result = start_free;  <span class="comment">// 将原来的start_free作为结果传回去</span></span><br><span class="line">      start_free += total_bytes;  <span class="comment">// 调整pool水位，下降，战备池pool变小</span></span><br><span class="line">      <span class="keyword">return</span>(result);</span><br><span class="line">  <span class="comment">// 2. pool空间只能满足1个及以上区块的需求，但不足20块</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) &#123; </span><br><span class="line">      *nobjs = bytes_left / size;     <span class="comment">//原nobjs改為 (*nobjs)，改变需求数，看看可以切成几个区块</span></span><br><span class="line">      total_bytes = size * (*nobjs);  <span class="comment">//原nobjs改為 (*nobjs)，改变需求总量</span></span><br><span class="line">      result = start_free;</span><br><span class="line">      start_free += total_bytes;</span><br><span class="line">      <span class="keyword">return</span>(result);</span><br><span class="line">  <span class="comment">// 3. pool空间不足以满足1块需求，pool空间可能是碎片，也可能表示pool大小为0</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">      <span class="type">size_t</span> bytes_to_get =  </span><br><span class="line">                 <span class="number">2</span> * total_bytes + <span class="built_in">ROUND_UP</span>(heap_size &gt;&gt; <span class="number">4</span>);  <span class="comment">// 需要请求的一大块的大小</span></span><br><span class="line">      <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">      <span class="comment">// 先将pool池的碎片挂到对应大小的链表上</span></span><br><span class="line">      <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          obj* <span class="keyword">volatile</span> *my_free_list =  <span class="comment">// 找出应转移到第#号链表</span></span><br><span class="line">                 free_list + <span class="built_in">FREELIST_INDEX</span>(bytes_left);</span><br><span class="line">		  <span class="comment">// 将pool空间编入第#号链表，next指针指向链表的头节点，编入链表的第一个节点</span></span><br><span class="line">          ((obj*)start_free)-&gt;free_list_link = *my_free_list;</span><br><span class="line">          *my_free_list = (obj*)start_free;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 上面处理完pool的碎片，pool为空，开始用malloc为pool分配内存</span></span><br><span class="line">      start_free = (<span class="type">char</span>*)<span class="built_in">malloc</span>(bytes_to_get); <span class="comment">// pool的起点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123;  <span class="comment">// 分配失败，从free list中找区块（向右边更大的区块去找）</span></span><br><span class="line">          <span class="type">int</span> i;</span><br><span class="line">          obj* <span class="keyword">volatile</span> *my_free_list, *p;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//Try to make do with what we have. That can&#x27;t</span></span><br><span class="line">          <span class="comment">//hurt. We do not try smaller requests, since that tends</span></span><br><span class="line">          <span class="comment">//to result in disaster on multi-process machines.</span></span><br><span class="line">          <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123; <span class="comment">// 向右侧的链表去找区块，例如88B，96B，104B， 112B等等</span></span><br><span class="line">              my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(i);</span><br><span class="line">              p = *my_free_list;</span><br><span class="line">              <span class="keyword">if</span> (<span class="number">0</span> != p) &#123; <span class="comment">// 找到右边的list中的可用区块，只释放一块给pool</span></span><br><span class="line">                  *my_free_list = p -&gt; free_list_link;</span><br><span class="line">                  <span class="comment">// start_free 和 end_free是战备池pool的头尾指针，指向这一块空间</span></span><br><span class="line">                  start_free = (<span class="type">char</span>*)p;  </span><br><span class="line">                  end_free = start_free + i;</span><br><span class="line">                  <span class="keyword">return</span>(<span class="built_in">chunk_alloc</span>(size, nobjs)); <span class="comment">// 递归再试一次</span></span><br><span class="line">                  <span class="comment">//Any leftover piece will eventually make it to the</span></span><br><span class="line">                  <span class="comment">//right free list.</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          end_free = <span class="number">0</span>;       <span class="comment">//In case of exception.</span></span><br><span class="line">          start_free = (<span class="type">char</span>*)<span class="built_in">malloc_allocate</span>(bytes_to_get);</span><br><span class="line">          <span class="comment">//This should either throw an exception or</span></span><br><span class="line">          <span class="comment">//remedy the situation. Thus we assume it</span></span><br><span class="line">          <span class="comment">//succeeded.</span></span><br><span class="line">      &#125; <span class="comment">// if结束</span></span><br><span class="line">      </span><br><span class="line">      heap_size += bytes_to_get;  <span class="comment">// 累计总分配量</span></span><br><span class="line">      end_free = start_free + bytes_to_get;  <span class="comment">// 调整pool水位，pool空间变大，pool的终点</span></span><br><span class="line">      <span class="keyword">return</span>(<span class="built_in">chunk_alloc</span>(size, nobjs));  <span class="comment">// 递归再调用一次</span></span><br><span class="line">      <span class="comment">// 不论是58/59行还是72/73行，都是先将空闲放入战备池中，然后再递归调用chunk_aclloc，就可以达到重新分配内存的效果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="29-G2-9-std-alloc源码剖析（下）"><a href="#29-G2-9-std-alloc源码剖析（下）" class="headerlink" title="29 G2.9 std::alloc源码剖析（下）"></a>29 G2.9 std::alloc源码剖析（下）</h2><p>分析chunk_alloc函数在G2.9 std::alloc源码剖析（中）进行。</p>
<p>具体一些数据的初始定义：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041212367.png" alt="在这里插入图片描述"></p>
<h2 id="30-G2-9-std-alloc观念大整理"><a href="#30-G2-9-std-alloc观念大整理" class="headerlink" title="30 G2.9 std::alloc观念大整理"></a>30 G2.9 std::alloc观念大整理</h2><p>（1）观念整理</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041233313.png" alt="4_内存管理_78"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">list&lt;Foo&gt; c;</span><br><span class="line">c.<span class="built_in">push_back</span>(<span class="built_in">Foo</span>(<span class="number">1</span>)); <span class="comment">// Foo(1)临时对象，创建在栈stack中</span></span><br><span class="line"><span class="comment">//容器c使用alloc分配空间，看16条链表中哪一条可以提供区块，分配给它。所以它不带cookie</span></span><br><span class="line"></span><br><span class="line">Foo* p = <span class="keyword">new</span> <span class="built_in">Foo</span>(<span class="number">2</span>); <span class="comment">// 采用new，创建在heap中</span></span><br><span class="line"><span class="comment">// new是调用operator new，底层是调用malloc，它带有cookie</span></span><br><span class="line">c.<span class="built_in">push_back</span>(*p); <span class="comment">// 容器c push_back的时候不带cookie</span></span><br><span class="line"><span class="keyword">delete</span> p; </span><br></pre></td></tr></table></figure>

<p>（2）“批斗”大会</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041234181.png" alt="4_内存管理_79"></p>
<ul>
<li><p>需要学习的地方：比较判断的时候把具体的值写在前面，防止出现将&#x3D;&#x3D;写成&#x3D;赋值的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == start_free)</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> != p)</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == nobjs)        </span><br></pre></td></tr></table></figure>
</li>
<li><p>不好的地方</p>
<ul>
<li><p>变量定义的地方不要和使用的地方间隔太远，尤其是指针的使用；</p>
</li>
<li><p>第一级分配器使用的一个函数：炫技，没有人看得懂；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> (*<span class="built_in">set_malloc_handler</span>(<span class="built_in">void</span> (*f)()))()</span><br><span class="line">&#123; <span class="comment">//類似 C++ 的 set_new_handler().</span></span><br><span class="line">  <span class="built_in">void</span> (*old)() = oom_handler;</span><br><span class="line">  oom_handler = f;</span><br><span class="line">  <span class="keyword">return</span>(old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于 //</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*H)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">H <span class="title">set_malloc_handler</span><span class="params">(H f)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有deallocate的时候并没有free掉，这是由设计的先天缺陷造成的。</p>
</li>
</ul>
</li>
</ul>
<h2 id="31-G4-9-pull-allocator运行观察"><a href="#31-G4-9-pull-allocator运行观察" class="headerlink" title="31 G4.9 pull allocator运行观察"></a>31 G4.9 pull allocator运行观察</h2><p>在GNU C++4.9版本下的测试，由于2.9版本分配内存都是调用malloc，无法重载，即无法接管到我们用户手中，无法记录总分配量和总释放量。而在4.9版本中，它的内存分配动作是调用operator new，这样我们就可以接管operator new，对其进行重载。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041240025.png" alt="4_内存管理_80"></p>
<p>下面测试两个分配器使用情况，分别对list容器进行100万次分配。</p>
<p>由于GNU C++4.9版本标准分配器是allocator，并不是2.9版本alloc，所以容器（客户）分配内存的时候每个元素（100万个）都带cookie（每个cookie占8B）。这个如下图右侧所示。</p>
<p>下图左侧使用4.9版本好的分配器__pool_alloc，这个是2.9版本的alloc，显示分配的次数timesNew为122次（调用malloc的次数），这比右侧标准分配器好上不少。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041240699.png" alt="4_内存管理_81"></p>
<h1 id="第三讲-malloc-free"><a href="#第三讲-malloc-free" class="headerlink" title="第三讲 malloc&#x2F;free"></a>第三讲 malloc&#x2F;free</h1><h2 id="32-VC6和VC10的malloc比较"><a href="#32-VC6和VC10的malloc比较" class="headerlink" title="32 VC6和VC10的malloc比较"></a>32 VC6和VC10的malloc比较</h2><blockquote>
<p> SBH：Small Block Heap</p>
</blockquote>
<p>（1）VC6内存分配</p>
<p>下图为<code>call stack</code>，即调用栈，需要从下往上看。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061116653.png" alt="4_内存管理_86"></p>
<p><code>mainCRTStartup</code>函数是<code>CRT</code>（C Run Time，C标准库）提供的入口点函数，调用一系列函数，后面才是调用<code>main</code>函数。其中，在<code>_heap_alloc_base</code>函数中：</p>
<ul>
<li>当size小于阈值<code>_sbh_thrshold</code>时调用<code>__sbh_alloc_block</code>函数；</li>
<li>否则调用<code>HeapAlloc</code>函数，即操作系统提供的内存分配函数。</li>
</ul>
<blockquote>
<p>在 VC6（Visual C++ 6.0）的内存分配机制中，SBH（Small Block Heap）是用于管理小块内存的一部分。这是一个专门用于分配和释放相对较小内存块的堆管理机制，通常用于提高小对象的内存分配效率。</p>
<p>在调用栈中，从下往上看，mainCRTStartup 函数是 CRT（C Runtime）提供的入口点函数。CRT 是 C++ 程序运行时环境的一部分，负责初始化和管理程序的运行时状态。mainCRTStartup 函数会执行一系列的初始化操作，包括初始化全局变量、调用构造函数等。在这个过程中，可能会涉及到内存分配操作，其中就包括 SBH 的管理。</p>
<p>在 VC6 中，SBH 通常使用一些数据结构（例如内存池、free list 等）来管理小块内存。这有助于减少内存碎片，并提高小对象的分配和释放效率。</p>
<p>整个调用栈的过程可能是这样的：</p>
<ul>
<li>mainCRTStartup 函数初始化 CRT 环境。</li>
<li>在初始化过程中，可能会涉及到 SBH 的初始化或使用。</li>
<li>然后执行 main 函数，开始程序的主要逻辑。</li>
</ul>
<p>总的来说，VC6 的内存分配机制在运行时可能会使用 SBH 等机制来管理小块内存，以提高性能和效率。这些机制通常是底层的、对开发者透明的，但在整个程序运行的过程中发挥着重要的作用。</p>
</blockquote>
<p>（2）VC10内存分配</p>
<p>下图中黑色覆盖的函数表示VC10不再使用，对于<code>_heap_alloc_base</code>函数，它里面直接调用<code>HeapAlloc</code>函数，不再对小块内存进行管理，统统交给操作系统来做。对于VC10版本，它的SHB等小块内存的管理都被包装到<code>HeapAlloc</code>里面来了。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061120640.png" alt="4_内存管理_87"></p>
<p>（3）SBH之始</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061124139.png" alt="4_内存管理_88"></p>
<p><code>_heap_init</code></p>
<ul>
<li><p>调用<code>HeapCreate</code>来分配一块大小为<code>4096</code>的堆空间，命名为<code>_crtheap</code>，后面<code>CRT</code>的动作都要从这一块内存中来拿；</p>
</li>
<li><p>调用<code>__sbh_heap_init</code>，里面是<code>HeapAlloc</code>，从<code>_crtheap</code>中拿内存，准备好<code>16个header</code>。</p>
<ul>
<li><p>header的结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> BITVEC;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagHeader</span></span><br><span class="line">&#123;</span><br><span class="line">    BITVEC bitvEntryHi; <span class="comment">// 32位</span></span><br><span class="line">    BITVEC bitbEntryLo;  <span class="comment">// 32位</span></span><br><span class="line">    BITVEC bitvCommit;  <span class="comment">// 32位</span></span><br><span class="line">    <span class="type">void</span>* pHeapData;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tagRegion</span>* pRegion;</span><br><span class="line">&#125;</span><br><span class="line">HEADER, *PHEADER;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061123323.png" alt="4_内存管理_89"></p>
</li>
</ul>
</li>
</ul>
<h2 id="33-VC6内存分配（1）"><a href="#33-VC6内存分配（1）" class="headerlink" title="33 VC6内存分配（1）"></a>33 VC6内存分配（1）</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061126561.png" alt="4_内存管理_90"></p>
<h3 id="（1）ioinit"><a href="#（1）ioinit" class="headerlink" title="（1）ioinit()"></a>（1）ioinit()</h3><ul>
<li><p>和<code>I/O</code>相关的初始化，其中调用<code>_malloc_crt</code>进行内存分配，这是<code>CRT</code>进行的第一次内存分配，大小为<code>32×8=256B</code>，所有的程序一进来都是分配<code>256B</code>。256在十六进制下是0x100，或者写成<code>100H</code>。</p>
</li>
<li><p>调用了<code>_malloc_dbg</code>，和<code>malloc</code>稍微有所不同，是与调试相关的内存分配函数，</p>
<ul>
<li><p>是 Microsoft Visual C++ 提供的一种扩展版本，用于在调试模式下进行内存分配，并提供额外的调试信息。与标准的<code>malloc</code>函数相比，<code>_malloc_dbg</code>主要用于在调试期间更容易跟踪内存分配和释放的情况。</p>
</li>
<li><p>示例用法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;crtdbg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* ptr = _malloc_dbg(size, _NORMAL_BLOCK, __FILE__, __LINE__);</span><br><span class="line"></span><br><span class="line"><span class="comment">// _malloc_dbg 用于分配带有调试信息的内存块</span></span><br><span class="line"><span class="comment">// _NORMAL_BLOCK 表示内存块的类型</span></span><br><span class="line"><span class="comment">// __FILE__ 和 __LINE__ 分别表示调用该函数的源文件和行号</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="（2）-heap-alloc-dbg"><a href="#（2）-heap-alloc-dbg" class="headerlink" title="（2）_heap_alloc_dbg()"></a>（2）_heap_alloc_dbg()</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061130993.png" alt="4_内存管理_91"></p>
<ul>
<li><code>_CrtMemBlockHeader</code>是一个结构体，可称为<code>debug header</code>；<code>nSize</code>就是上文提到的<code>256B</code>；<code>nNoManLandSize</code>为4；</li>
<li>右侧的图显示了<strong>debug模式下申请nsize&#x3D;256B大小内存</strong>，额外附加了一些东西，debug header和NoMansLand，这是为调试器设计的；</li>
<li><strong>blockSize计算完毕之后，开始调用_heap_alloc_base分配内存空间</strong></li>
<li><strong>所需内存的nSize部分加上调试所加的部分，这个整体称为block，由灰色、深绿色、浅绿色共同构成</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061132445.png" alt="4_内存管理_92"></p>
<ul>
<li><code>_pFirstBlock</code>和<code>_pLastBlock</code>两根指针指向block链表的头尾，<code>malloc</code>分配的内存块都用链表串起来；</li>
<li>右下角的<code>memset</code>是给特定地方填入特定的值。</li>
</ul>
<h2 id="34-VC6内存分配（2）"><a href="#34-VC6内存分配（2）" class="headerlink" title="34 VC6内存分配（2）"></a>34 VC6内存分配（2）</h2><h3 id="（3）-heap-alloc-base"><a href="#（3）-heap-alloc-base" class="headerlink" title="（3）_heap_alloc_base()"></a>（3）_heap_alloc_base()</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061135466.png" alt="4_内存管理_93"></p>
<ul>
<li>调用<code>_heap_alloc_base</code>分配内存，小于阈值的内存交给sbh服务，大于阈值的内存交给操作系统HeapAlloc来服务；</li>
<li>这里<code>_Sbh_threshold</code>的值是<code>1016B</code>，这是因为还没有加cookie（大小为8），两者加起来是<code>1024B</code>。</li>
</ul>
<h3 id="（4）-sbh-alloc-block"><a href="#（4）-sbh-alloc-block" class="headerlink" title="（4）_sbh_alloc_block()"></a>（4）_sbh_alloc_block()</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061136305.png" alt="4_内存管理_94"></p>
<p>在前面<code>block</code>的基础上，上下添加<code>cookie</code>（体现在2*sizeof(int)，以及下图右侧上下两块红色的地方0x131），后面涉及到的(BYTE_PER_PARA-1) 是进行向上调整ROUND_UP，调整到16的倍数。</p>
<ul>
<li><strong>cookie的计算</strong>：<ul>
<li>首先是<code>_ioinit</code>首次需要的内存<code>256B</code>（0x100，浅绿色的部分）;</li>
<li>然后是调试器加的<code>debug header</code>，大小为<code>9 x 4 = 36B</code>（0x24，灰色部分和深绿色部分(4个0xfd)），再加上下两个cookie大小<code>4 x 2 = 8B</code>（0x8），所有的加起来：0x100 + 0x24 + 0x8 &#x3D; 0x12C，<strong>向上调整到16的倍数</strong>，变成<code>0x130</code>；</li>
<li>最后，末位为<code>1</code>表示这块内存分配出去，如果末位为0则表示这块内存还在<code>sbh</code>手上。这里是分配出去的内存，所以<code>cookie</code>里面填的值是<code>0x131</code>。</li>
</ul>
</li>
</ul>
<h2 id="35-VC6内存分配（3）"><a href="#35-VC6内存分配（3）" class="headerlink" title="35 VC6内存分配（3）"></a>35 VC6内存分配（3）</h2><p>上述函数的作用都是确定该分配内存的大小，接下来真正进行内存分配的任务。</p>
<h3 id="（5）-sbh-alloc-new-region"><a href="#（5）-sbh-alloc-new-region" class="headerlink" title="（5）_sbh_alloc_new_region()"></a>（5）_sbh_alloc_new_region()</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061139061.png" alt="4_内存管理_95"></p>
<p>共<code>16</code>个<code>header</code>，每个<code>header</code>负责<code>1MB</code>的内存。</p>
<p><code>header</code>有两个指针：</p>
<ul>
<li>一个指向<strong>真正的内存</strong>；</li>
<li>另一个指向<strong>管理中心（region）</strong>，上图中橙色框圈出来的就是<code>new region</code>，具体细节如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagRegion</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> indGroupUse;                  <span class="comment">// 一个整数</span></span><br><span class="line">	<span class="type">char</span> cntRegionSize[<span class="number">64</span>];           <span class="comment">// 64个char</span></span><br><span class="line">    <span class="comment">// 下面两者合并，共有32组，每组64bits，用来管理区块在链表中存在与否等细节</span></span><br><span class="line">	BITVEC bitvGroupHi[<span class="number">32</span>];           <span class="comment">// unsigned int</span></span><br><span class="line">	BITVEC bitvGroupLo[<span class="number">32</span>];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tagGroup</span> grpHeadList[<span class="number">32</span>];  <span class="comment">// 32个group</span></span><br><span class="line">&#125;</span><br><span class="line">REGION, *REGION;</span><br></pre></td></tr></table></figure>

<ul>
<li>每一个<code>group</code>是<code>64</code>个<code>ListHead</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagGroup</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> cntEntries;                   <span class="comment">// 记录累计分配出去的区块</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tagListHead</span> listHead[<span class="number">64</span>];  <span class="comment">// 64个ListHead</span></span><br><span class="line">&#125;</span><br><span class="line">GROUP, *PGROUP;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ListHead</code>里面有两个指针，双向链表</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagListHead</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tagEntry</span>* pEntryNext;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tagEntry</span>* pEntryPrev;</span><br><span class="line">&#125;</span><br><span class="line">LISTHEAD, *PLISTHEAD;	</span><br></pre></td></tr></table></figure>

<p>一个<code>region</code>的大小大概有<code>16K</code>左右。管理右侧的虚拟地址空间的成本即为<code>region</code>的大小，<code>16K</code>。</p>
<h2 id="36-VC6内存分配（4）"><a href="#36-VC6内存分配（4）" class="headerlink" title="36 VC6内存分配（4）"></a>36 VC6内存分配（4）</h2><p>接下来就是如何从<code>1MB</code>内存中切出一块。</p>
<h3 id="（6）-sbh-alloc-new-group"><a href="#（6）-sbh-alloc-new-group" class="headerlink" title="（6）_sbh_alloc_new_group()"></a>（6）_sbh_alloc_new_group()</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061241209.png" alt="4_内存管理_96"></p>
<p>将右侧的虚拟内存空间（大小为<code>1MB</code>），分成<code>32</code>块，每个<code>group</code>管理<code>1</code>块，每一块大小为<code>1MB / 32 = 32KB</code>。然后再将每一块细分为<code>8</code>个<code>page</code>，每个<code>page</code>大小为<code>32KB / 8 = 4KB</code>，如上图<code>page1, page2, …, page8</code>所示。</p>
<p>第<code>1</code>块由<code>group0</code>进行管理。<code>group0</code>里面有<code>64</code>条链表。<code>SBH</code>中用链表把第<code>1</code>块的<code>8</code>个<code>page</code>串起来，挂在<code>group0</code>里面<code>64</code>条链表的最后一条上。</p>
<p>当<code>_ioinit</code>第一次来要内存的时候，就从<code>group0</code>的<code>page1</code>挖一块给它。后面又有要内存的时候，就一直往后挖，如果<code>page1</code>到<code>page8</code>都被分配出去了，之后还是要内存，就到<code>group1</code>中去处理。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061241234.png" alt="4_内存管理_97"></p>
<ul>
<li><p><strong>黄色部分</strong>：这<code>32KB</code>（8个page）是一次性从操作系统分配过来的。每一个<code>page</code>的偏移值地方设置为<code>0xffffffff</code>，也就是<code>-1</code>（上图中黄色的部分），设置为<code>-1</code>的作用是合并的时候做分隔符（栅栏），分隔符（栅栏）之内的合并在一起。</p>
</li>
<li><p><strong>红色部分</strong>：有三个小块，下面两个红色的小块是两个指针，将8个page串起来，上面的一个红色小块是记录可用空间的大小，这里是<code>4080</code>（由4KB &#x3D; 4096B，4096减去两个黄色的部分（栅栏，分隔符）8B，剩下4088B，但是要下调到16的倍数，变成4080B，剩余的放到保留区），这上下两块<code>4080</code>是cookie，记录自己这一块的大小。</p>
</li>
</ul>
<p>64条链表负责不同大小的区块，分别是<code>16B， 32B， 64B,…, </code>每次增加16B，一直到最后一条链表，最后一条应该负责<code>64 x 16 = 1024B</code>的区块分配。<strong>另外最后一根链表还有一个任务，就是所有大于1024B的区块都由它负责</strong>。当切分完之后如果剩下的空间小于1024B，就要挂载到对应区块大小的那根链表上。</p>
<p>这64条链表上面还有一个整数<code>cntEntries</code>，表示分配的累积量，分配出去一个区块就<code>+1</code>，回收回来一个区块就<code>-1</code>。</p>
<h2 id="37-VC6内存分配（5）"><a href="#37-VC6内存分配（5）" class="headerlink" title="37 VC6内存分配（5）"></a>37 VC6内存分配（5）</h2><p>下面分析第一个<code>page</code>怎么切分。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061248201.png" alt="4_内存管理_98"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4080 = 0xff0</span><br></pre></td></tr></table></figure>

<p>上面<code>_ioinit</code>第一次要的内存是<code>256B</code>（0x110），然后加上各种<code>debug header</code>和其他，总共是<code>0x130</code>，所以给出去的内存是<code>0x130</code>，<code>cookie</code>记录的值是<code>0x131</code>。</p>
<p>剩下的大小为<code>0xff0 - 0x130 = 0xec0</code>。</p>
<ul>
<li><p>上图左侧<strong>红色的地址0x007d0ed0</strong>是传出去的指针，<strong>指向的是客户要的<code>0x130</code>大小（加上各种debug header等）的内存</strong>。<strong>然后0x130内部还要调整指针，指向实际要的大小0x100大小的位置，就是图中的纯绿色（fill 0xcd）位置。这就是_ioinit获得的空间的位置。</strong></p>
</li>
<li><p>上图右侧的<code>_NORMAL_BLOCK </code>和<code>_CRT_BLOCK</code>指的是不同类型的<code>block</code></p>
<ul>
<li><p><code>_NORMAL_BLOCK</code>是<code>main</code>函数里面具体用的<code>block</code>，它在<code>main</code>函数结束的时候应该全部被归还，否则就是内存泄漏；</p>
</li>
<li><p><code>_CRT_BLOCK</code>在<code>main</code>函数运行结束之后还会存在，它会由<code>CRT</code>进行释放。</p>
</li>
</ul>
</li>
</ul>
<h2 id="38-SBH行为分析-分配-释放之连续动作图解（1）"><a href="#38-SBH行为分析-分配-释放之连续动作图解（1）" class="headerlink" title="38 SBH行为分析 分配+释放之连续动作图解（1）"></a>38 SBH行为分析 分配+释放之连续动作图解（1）</h2><p>（1）首次需求</p>
<p><strong>首次需求</strong>是由<code>ioinit.c</code>第<code>81</code>行代码发出，申请<code>100H</code>的空间，加上各种<code>debug header</code>，它的区块大小变成<code>130H</code>（十进制是304），应该由<code>64</code>条链表中的第<code>304 / 16 - 1 = 18</code>号链表进行供应（不同链表区块大小是16的倍数）。<strong>但是前63条链表都为空，只有最后一条（#63）有空间。下面就是以最后一条链表（#63）来讲解。</strong></p>
<p><code>SBH</code>面对这样的需求，它在初始化的时候已经有<code>16</code>个<code>header</code>，现在<code>0</code>号<code>header</code>来进行处理。</p>
<ol>
<li>它首先分配<code>1MB</code>的地址空间，这个动作是由<code>VirtualAlloc</code>去拿到的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, <span class="number">1</span>MB, MEM_RESERVE, ...)</span><br></pre></td></tr></table></figure>

<p>这段代码使用了<code>VirtualAlloc</code>函数，该函数是 Windows API 提供的用于虚拟内存操作的函数之一。在这里，<code>VirtualAlloc</code>用于分配 1MB 的地址空间，并且使用<code>MEM_RESERVE</code>标志表示要保留这个地址空间，而不分配物理内存。</p>
<ul>
<li>0：表示欲分配或保留的内存区域的起始地址。在这里，设置为 0，表示让系统决定分配的地址。</li>
<li>1MB：表示要分配或保留的内存区域的大小，这里是 1MB。</li>
<li>MEM_RESERVE：表示要保留而不是分配物理内存。这样做可以预留地址空间，但只有在访问这些地址空间时才会分配物理内存。</li>
<li>…：其他参数，这里没有提供具体的细节。</li>
</ul>
<p><strong>所以，这个调用的目的是在虚拟地址空间中保留 1MB 的地址区域，但实际上并没有分配物理内存。这样的操作通常用于预留地址空间，以便在需要时再分配实际的物理内存。</strong></p>
<ol start="2">
<li>其次，<code>header0</code>有另外一根指针分配出<code>region</code>，这个动作是由<code>HeapAlloc</code>进行</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">HeapAlloc</span>(_crtheap, <span class="built_in">sizeof</span>(REGION));</span><br></pre></td></tr></table></figure>

<p>这个<code>region</code>里面就是上文介绍的，里面有一些<code>bit</code>，还有<code>32</code>个<code>group</code>，每个<code>group</code>有<code>64</code>条链表。</p>
<p>上述动作准备好之后，要从虚拟地址空间中分配<code>32KB</code>（被分成8个page，每个page大小为4KB），8个page由指针串起来，这次内存分配是用<code>VirtualAlloc</code>进行的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">VirtualAlloc</span>(addr, <span class="number">32</span>KB, MEM_COMMIT, ...)  <span class="comment">// MEM_COMMIT表示真的分配内存</span></span><br></pre></td></tr></table></figure>

<p>万事俱备，开始在page1上分配刚开始的需求：申请的<code>100h</code>，区块大小<code>130h</code>，十进制大小<code>4080</code>。剩下的大小为<code>0xff0 - 0x130 = 0xec0</code>，这部分还在<code>SBH</code>控制之中，<code>130h</code>被分配出去，所以cookie记为<code>131h</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061255241.png" alt="4_内存管理_99"></p>
<p>下面红色方框中是32组64bits，64bits分别对应64根链表的状态，哪一条链表有挂区块，对应的bit就设置为1。32组表示的是32个group</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061255415.png" alt="在这里插入图片描述"></p>
<p>（2）第二次需求</p>
<p><strong>第二次需求，这个需求是<code>CRT</code>里面谁发出来的需求呢？是上面讲的<code>call stack</code>中的<code>__crtGetEnvironmentStringsA()</code>发出的。</strong></p>
<p>这次需求是且分出<code>240H</code>的大小（包含各种debug header，调整16的边界等之后的大小），这个240h的区块应该由哪条链表提供服务呢？240h &#x3D; 576d（d表示十进制）,576 &#x2F; 16 -1 &#x3D; 35, 所以由#35号链表提供服务。然后去检查64bits中35号对应的bit，看看是否挂有区块，这里的情况是#35链表是空的。 然后退而求其次逐渐遍历更大容量的链表，这里只能找到最大的那条链表，这里最后一条是#63（从0开始编号）。</p>
<p>和前面一样，检查#63链表发现它有8个page，page1还有空间可用。从这里切出<code>240h</code>的大小，经过两次切割之后，<code>page1</code>还剩<code>c80h</code>大小，<code>ec0h - 240h = c80h</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061256770.png" alt="4_内存管理_100"></p>
<p>（3）第三次需求</p>
<p><strong>第三次需求分配<code>70h</code>的大小。</strong>首先先检查应该是几号链表服务刚刚好？这里是<code>70h = 112D</code>, <code>112 / 16 - 1 = 6</code>, 应该由6号链表服务，但是它是空的，往上寻找只发现最后一个链表有区块。</p>
<p><code>page1</code>继续分配空间，这次分配之后还剩下<code>c80h - 70h = c10h</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061256560.png" alt="4_内存管理_101"></p>
<h2 id="39-SBH行为分析-分配-释放之连续动作图解（2）"><a href="#39-SBH行为分析-分配-释放之连续动作图解（2）" class="headerlink" title="39 SBH行为分析 分配+释放之连续动作图解（2）"></a>39 SBH行为分析 分配+释放之连续动作图解（2）</h2><p>上面是分析内存分配的情况，下面分析一下内存回收的阶段。</p>
<p>下图是第<code>15</code>次的动作，它前面有<code>14</code>次内存分配，这次是内存释放（回收），右上角可以看到<code>cntEntries</code>由<code>14</code>变成<code>13</code>，内存释放会<code>-1</code>.</p>
<p>这次释放的是大小为<code>240h</code>的区块，这一块应该回收到<code>64</code>条链表中的哪一条呢？<code>240h = 576D， 576 / 16 - 1 = 35</code>，所以应该还到<code>#35</code>号链表。由于分配出去的<code>cookie</code>为<code>241h</code>，现在将其变为<code>240h</code>，就表示回收回来，在<code>SBH</code>的掌控之下。然后<code>64bits</code>中<strong>第35号bit需要由0变成1</strong>。</p>
<blockquote>
<p>切割实际上只是cookie的调整。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061257419.png" alt="4_内存管理_102"></p>
<h2 id="40-SBH行为分析-分配-释放之连续动作图解（3）"><a href="#40-SBH行为分析-分配-释放之连续动作图解（3）" class="headerlink" title="40 SBH行为分析 分配+释放之连续动作图解（3）"></a>40 SBH行为分析 分配+释放之连续动作图解（3）</h2><p>下图是第<code>16</code>次的动作，还是内存分配的动作</p>
<p>这次分配的是<code>b0h</code>，应该由哪条链表来服务呢？<code>b0h = 176D， 176 / 16 - 1 = 10</code>，所以应该由<code>#10</code>号链表服务，但是它是空的。此时需要向右寻求拥有更大区块的链表的帮助，这里从<code>#10</code>号往右逐个查找，发现上次回收了回来第<code>#35</code>号链表，它是可用的，所以这次应该由#35号链表提供服务。</p>
<p>上次刚回收回来<code>240h</code>，分配出去<code>b0h</code>，这块空间还剩多大？<code>240h - b0h = 190h</code>。</p>
<p>这里的<code>190h</code>，应该挂到哪条链表呢？ <code>190h = 400D, 400 / 16 - 1= 24</code>，所以应该挂到<code>#24</code>号链表。此时<code>64bits</code>中的<code>24号bit</code>需要变成<code>1</code>，表示该号链表有区块可分配。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061257265.png" alt="4_内存管理_103"></p>
<p>一直进行下去，不断的进行内存分配和回收。</p>
<p><code>group1</code>共有<code>32KB</code>，下面的第一行表示的就是<code>group1</code>的<code>64</code>条链表的使用情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">02000014</span> <span class="number">00000000</span>H  <span class="comment">// 共64bits，表示的是第几号链表时候有区块</span></span><br></pre></td></tr></table></figure>

<p>展开成二进制，发现有3个链表挂有区块，有可用空间供分配。</p>
<p>现在要分配的大小为<code>230h</code>，上面的<code>group1</code>中的可用链表都不能满足它的需求</p>
<p>现在用的是<code>group2</code>，对于<code>group2</code>中，<code>230h</code>应该由几号链表来服务呢？ <code>230h = 560D， 560 / 16 - 1 = 34</code>，理想的状况是由<code>34</code>号链表服务，它检查下面的表示链表状态的64bits，</p>
<p>这里第二行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000001</span>H  <span class="comment">// 表示只有最后一条链表有可用空间供分配</span></span><br></pre></td></tr></table></figure>

<p>表示只有最后一条链表有可用空间供分配，最后一条链表的编号为<code>#63</code>， 每个大小<code>page</code>还是<code>4080D = ff0H</code>。</p>
<p>现在<code>ff0H</code>分配出去<code>230H</code>，还剩<code>ff0h - 230h = dc0h</code>，<code>dc0h</code>应该挂在哪个链表上呢？<code>dc0h = 3520D</code>，表示空间大小为<code>3520B</code>，比前<code>63</code>条链表的区块（小于<code>1024B</code>）还要大，它只能还挂在<code>#63</code>号链表上。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061258561.png" alt="4_内存管理_104"></p>
<h2 id="41-SBH行为分析-分配-释放之连续动作图解（4）"><a href="#41-SBH行为分析-分配-释放之连续动作图解（4）" class="headerlink" title="41 SBH行为分析 分配+释放之连续动作图解（4）"></a>41 SBH行为分析 分配+释放之连续动作图解（4）</h2><p><strong>VC6内存管理：区块的合并</strong></p>
<p>如果回收的是相邻的空间，则应该合并。这里的上cookie表示的是上面的cookie，下cookie表示的是下面的cookie。下图左侧第一张图中灰色部分表示待收回的区块300h，它的上下两部分为白色，表示已经回收过来的区块，可以合并。</p>
<p>（1）首先往下看，怎么往下看呢？</p>
<p>指针找到自己的cookie大小，这里是300h，指针移动300h，就到了下面一个区块的cookie位置，看最后1bit是否是为0，如果为0，表示可以和下面的区块合并。</p>
<p>现在发现，下方区块为free，也为300h，合并之，合并为600h，如第二张图中间灰色部分所示。</p>
<p>总之，往下合并，用的就是上cookie，根据上cookie的大小，指针移动cookie个大小，就可以找到下一个区块的位置。</p>
<p>（2）其次往上看，怎么往上看呢？</p>
<p>指针还在自己cookie的位置，往上移动4字节，就找到上方区块的下cookie，判断最后1bit是否为0，若为0，就表示可以和上面的区块合并。</p>
<p>现在发现，上方区块也为free，大小也为300h，合并之。</p>
<p>总之，往上合并，用的是上面区块的下cookie，根据这个值，往上跳cookie个大小，找到上面区块的起始位置。如果没有下cookie，就不能往上合并。</p>
<p>（3）三个300h合并大小为900h，然后去找900h应该挂在几号链表上，900h &#x3D; 2304D， 2304大于1024，所以它应该挂在最后一个链表#63上，它用来处理大于1024B的区块。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061258046.png" alt="4_内存管理_105"></p>
<h2 id="42-VC6内存管理free（p）"><a href="#42-VC6内存管理free（p）" class="headerlink" title="42 VC6内存管理free（p）"></a>42 VC6内存管理free（p）</h2><p><code>free</code>回收，<code>SBH</code>要确定落在哪个<code>header</code>（共16个header）指定的<code>1MB</code>空间中，然后确定是这个<code>header</code>中的哪个<code>group</code>，然后确定这个<code>group</code>中的<code>64</code>条链表中的哪个链表。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061258074.png" alt="4_内存管理_106"></p>
<h2 id="43-VC6内存管理总结（上）"><a href="#43-VC6内存管理总结（上）" class="headerlink" title="43 VC6内存管理总结（上）"></a>43 VC6内存管理总结（上）</h2><p>分成<code>16</code>个<code>header</code>，每个<code>header</code>管理<code>1MB</code>的虚拟空间，这个虚拟空间分成<code>32</code>个<code>group</code>（每个<code>group</code>管理大小为32KB的空间），每个<code>group</code>里有<code>64</code>个链表。</p>
<p>这里的管理是分段管理（一段是<code>32KB</code>），分段的时候便于一段全部回收，然后还给操作系统。</p>
<p><strong>如何判断全回收？</strong></p>
<p>因为每个<code>group</code>中都有一个<code>cntEntries</code>，统计分配和回收的区块数量，当它为<code>0</code>的时候，意味着这个<code>group</code>全回收，这一段<code>32KB</code>就可以还给操作系统。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagGroup</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> cntEntries; <span class="comment">// 记录累计分配出去的区块</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tagListHead</span> listHead[<span class="number">64</span>];  <span class="comment">// 64个ListHead</span></span><br><span class="line">&#125;</span><br><span class="line">GROUP, *PGROUP;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061259550.png" alt="4_内存管理_107"></p>
<p><code>cntEntries = 0</code>的时候，这些区块是什么样子呢？它们已经进行了合并，合并到初始状态，即<code>8</code>个<code>page</code>分别挂载<code>4080B</code>那个状态，如下图所示，然后挂在<code>#63</code>号链表上。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061259316.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>不急着还给操作系统，有一个<code>defering</code>，延缓归还的操作。</p>
<p>有一个全回收的<code>group</code>时，先暂存，当有第二个全回收的<code>group</code>时，才释放前面那个<code>group</code>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061300668.png" alt="4_内存管理_108"></p>
<h2 id="44-VC6内存管理总结（下）"><a href="#44-VC6内存管理总结（下）" class="headerlink" title="44 VC6内存管理总结（下）"></a>44 VC6内存管理总结（下）</h2><p>释放所有的内存块，SBH系统的面貌就是初始状态，如前面所述。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061300128.png" alt="4_内存管理_109"></p>
<blockquote>
<p>第二讲讲的是GNU C++的分配器，这里的第三讲涉及的是VC的malloc函数，可以把它们混在一起吗？其实GNU C++的malloc实现差不多。</p>
<p>这里再系统化一遍。</p>
<p>allocator要内存，底部还是向malloc要内存。</p>
<p>allocator设计成16个链表的目的不是提升分配的速度，而是为了去除malloc的cookie开销，减少malloc的次数，每一次malloc要一大块内存，然后切分成相等的区块，这样就可以去除每一小块的cookie。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061301504.png" alt="4_内存管理_111"></p>
<p><strong>从操作系统的API(这里是windows系统，比如HeapAlloc， VirtualAlloc)，到CRT的malloc设计，再到std::allocator的底部实现，都有类似的链表管理结构。</strong><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061301013.png" alt="4_内存管理_112"></p>
<h1 id="第四讲-loki-allocator"><a href="#第四讲-loki-allocator" class="headerlink" title="第四讲 loki::allocator"></a>第四讲 loki::allocator</h1><h2 id="45-上中下三个classes分析"><a href="#45-上中下三个classes分析" class="headerlink" title="45 上中下三个classes分析"></a>45 上中下三个classes分析</h2><p>Loki 是 C++ 中一个开源的库，其中包含一组通用的 C++ 组件。在 Loki 库中，有一个称为 Loki::Allocator 的组件，它是一个用于内存分配的工具。讲这个分配器是为了和GNU C++中的alloc分配器作比较，alloc分配器最后的内存并没有还给操作系统。</p>
<p>Loki allocator的三个类，从低阶到高阶分别为：<code>Chunk, FixedAllocator, SmallObjAllocator</code>。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061930580.png" alt="4_内存管理_117"></p>
<ul>
<li>Chunk</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pData_: <span class="type">unsigned</span> <span class="type">char</span>* <span class="comment">// 指针，指向分配的一个chunk</span></span><br><span class="line">firstAvailableBlock_：<span class="type">unsigned</span> <span class="type">char</span> <span class="comment">// 第一个可用区块</span></span><br><span class="line">blocksAvailable_: <span class="type">unsigned</span> <span class="type">char</span> <span class="comment">// 目前还可以供应几个区块</span></span><br></pre></td></tr></table></figure>

<ul>
<li>FixedAllocator</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">chunks_: vector&lt;Chunk&gt; <span class="comment">// vector里面放了很多chunk</span></span><br><span class="line"><span class="comment">// 两个指针，指向某两个Chunk</span></span><br><span class="line">allocChunk_: Chunk* </span><br><span class="line">deallocChunk_: Chunk*</span><br></pre></td></tr></table></figure>

<ul>
<li>SmallObjectAllocator</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pool_: vector&lt;FixedAllocator&gt;  <span class="comment">// 里面放了很多FixedAllocator</span></span><br><span class="line"><span class="comment">// 两个指针，指向某两个FixedAllocator</span></span><br><span class="line">pLastAlloc: FixedAllocator*</span><br><span class="line">pLastDealloc: FixedAllocator*</span><br><span class="line">chunkSize: <span class="type">size_t</span></span><br><span class="line">maxObjectSize: <span class="type">size_t</span></span><br></pre></td></tr></table></figure>

<h2 id="46-Class-Chunk分析"><a href="#46-Class-Chunk分析" class="headerlink" title="46 Class Chunk分析"></a>46 Class Chunk分析</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061935095.png" alt="4_内存管理_125"></p>
<ul>
<li><code>Init()</code><ul>
<li>动态分配一大块Chunk；</li>
<li>调用<code>Reset()</code><ul>
<li>上图中可用的block个数为64，第一个可用的block编号为0；</li>
<li>for循环把每个block的第一个字节当作索引index使用（类似于嵌入式指针）</li>
</ul>
</li>
</ul>
</li>
<li><code>Release()</code><ul>
<li>调用<code>delete[]</code>释放空间，归还操作系统。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061936225.png" alt="4_内存管理_126"></p>
<ul>
<li><code>Allocate()</code><ul>
<li>分配一个可用区块，并赋予其最高优先权；</li>
<li><code>firstAvailableBlock_</code>对应指向下一个可用区块，比如这里可用区块的索引从左边的4变成了右边的3，剩余区块个数也相应调整。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061938608.png" alt="4_内存管理_127"></p>
<ul>
<li><code>Deallocate()</code><ul>
<li>用p指针减去头指针然后除以每个block的大小，得到该释放的block的索引（即该block为第几个block）；</li>
<li>这个释放回收的block赋予最高优先权，成为<code>firstAvailableBlock_</code>;</li>
<li>最后，可利用的block个数<code>+1</code>。</li>
</ul>
</li>
</ul>
<h2 id="47-class-FixedAllocator分析（上）"><a href="#47-class-FixedAllocator分析（上）" class="headerlink" title="47 class FixedAllocator分析（上）"></a>47 class FixedAllocator分析（上）</h2><p>FixedAllocator</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">chunks_: vector&lt;Chunk&gt;  <span class="comment">// vector里面放了很多chunk</span></span><br><span class="line">allocChunk_: Chunk* 	<span class="comment">// 指向最近一次满足分配动作的chunk</span></span><br><span class="line">deallocChunk_: Chunk*	<span class="comment">// 指向最近一次回收的chunk</span></span><br><span class="line"><span class="comment">// 这两个chunk的指定符合数据的局部性原理</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Allocate的逻辑如下图所示：如果有最近的allocChunk_，那么直接取区块，</span></span><br><span class="line"><span class="comment">// 否则就要for循环从头开始遍历每个chunk，直到找到有可用空间的chunk。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061940593.png" alt="4_内存管理_128"></p>
<h2 id="48-class-FixedAllocator分析（下）"><a href="#48-class-FixedAllocator分析（下）" class="headerlink" title="48 class FixedAllocator分析（下）"></a>48 class FixedAllocator分析（下）</h2><ul>
<li>第二级FixedAllocator类的Deallocate函数，调用VicinityFind函数查找还回来的指针p落在哪个chunk，找到之后交给第一级Chunk类的Deallocate来处理。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061942795.png" alt="4_内存管理_129"></p>
<ul>
<li>VicinityFind()（临近搜寻）<ul>
<li>chunkLength是chunk的大小；lo是上次还回来的chunk，hi是下一个chunk；loBound和hiBound是vector的头跟尾</li>
<li>整体思路是：兵分两路，一路往上查找，一路往下查找。<ul>
<li>在lo里面找，找不到的话就往上面的chunk去查找，一直往上，一个接一个的chunk去找。</li>
<li>然后在hi里面找，找不到就往下面的chunk去查找，一直往下，一个接一个的chunk去找。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061943323.png" alt="4_内存管理_130"></p>
<ul>
<li>调用Deallocate()进行回收时，进行分情况处理。注意全回收时，需要确认有2个chunk，才会回收其中一个，也就是上文提到的<strong>deferring延缓回收</strong>。</li>
</ul>
<h2 id="49-Loki-allocator总结"><a href="#49-Loki-allocator总结" class="headerlink" title="49 Loki::allocator总结"></a>49 Loki::allocator总结</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061943975.png" alt="4_内存管理_131"></p>
<h1 id="第五讲-other-issues"><a href="#第五讲-other-issues" class="headerlink" title="第五讲 other issues"></a>第五讲 other issues</h1><h2 id="50-GNU-C-对allocators的描述"><a href="#50-GNU-C-对allocators的描述" class="headerlink" title="50 GNU C++对allocators的描述"></a>50 GNU C++对allocators的描述</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061944785.png" alt="4_内存管理_138"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061944147.png" alt="4_内存管理_139"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061944623.png" alt="4_内存管理_140"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061944227.png" alt="4_内存管理_141"></p>
<p><img src="C:/Users/86135/Desktop/内存管理/4_内存管理_142.png" alt="4_内存管理_142"></p>
<h2 id="51-VS2013标准分配器-G4-9标准分配器与new-allocator以及G4-9malloc"><a href="#51-VS2013标准分配器-G4-9标准分配器与new-allocator以及G4-9malloc" class="headerlink" title="51 VS2013标准分配器&amp;G4.9标准分配器与new_allocator以及G4.9malloc"></a>51 VS2013标准分配器&amp;G4.9标准分配器与new_allocator以及G4.9malloc</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061945904.png" alt="4_内存管理_143"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061945669.png" alt="4_内存管理_144"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061946198.png" alt="4_内存管理_145"></p>
<h2 id="52-G4-9-array-allocator"><a href="#52-G4-9-array-allocator" class="headerlink" title="52 G4.9 array_allocator"></a>52 G4.9 array_allocator</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061947049.png" alt="4_内存管理_146"></p>
<ul>
<li>指针<code>_M_array</code>指向一个C++数组，静态数组不需要释放与归还</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061947075.png" alt="4_内存管理_148"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061948852.png" alt="4_内存管理_147"></p>
<h2 id="53-G4-9-debug-allocator"><a href="#53-G4-9-debug-allocator" class="headerlink" title="53 G4.9 debug_allocator"></a>53 G4.9 debug_allocator</h2><p><code>debug_allocator</code>是一个包装器，把另一个分配器包装进来，这里是<code>_Alloc</code>分配器，定义为<code>_M_allocator</code>，实际分配的时候就是调用这个分配器的<code>allocate</code>，分配<code>n + extra</code>个大小的空间。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061948633.png" alt="4_内存管理_149"></p>
<h2 id="54-bitmap-allocator（上）"><a href="#54-bitmap-allocator（上）" class="headerlink" title="54 bitmap_allocator（上）"></a>54 bitmap_allocator（上）</h2><p>（1）介绍bitmap_allocator</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061949227.png" alt="4_内存管理_153"></p>
<ul>
<li><code>_M_allocate_single_object</code>和<code>_M_deallocate_single_object</code>：所有的<code>allocator</code>都是供给容器使用的，容器每次请求的都是一个元素的内存分配，所以这里就是<strong>单独处理一个<code>object</code>的请求</strong>。<strong>当不是一个object的时候，就会退化到operator new和operator delete</strong>，但是这种情况一般遇不到。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061950407.png" alt="4_内存管理_154"></p>
<p>当使用容器时，容器中一个元素的内存空间就是<code>block</code>，如果是<code>std::list</code>的时候，这个<code>block</code>还包括<code>node</code>里面的指针。上图中的<code>64blocks</code>指的是一次性挖<code>64个blocks</code>开始供应，注意这里是两倍成长，下次挖<code>128</code>个，再是<code>256</code>个，…。<strong>挖的这些blocks，加上前面的bitmap，还有前面的数值，一起称为super block。</strong></p>
<ul>
<li><code>bitmap</code>中是<code>64bits</code>（对应于blocks的数量），每个<code>bit</code>表示单个<code>block</code>的状态，<code>bitmap</code>是<code>unsigned int</code>，一个<code>bitmap</code>是<code>32</code>位，只能记录<code>32</code>个blocks的情况。这里是<code>64</code>个<code>blocks</code>，需要<code>2</code>个<code>bitmap</code>来记录。</li>
<li>前面还有一个整数<code>use count</code>，记录有几个block被分配。</li>
<li>最前面还有一个整数，记录<code>super block</code>的大小。</li>
<li>有一个<code>mini vector</code>（模拟标准库中的vector写出来的）来操纵<code>super block</code>，里面的<code>start</code>指针和<code>finish</code>指针分别指向<code>super block</code>的头和尾。</li>
</ul>
<p>（2）示例分析</p>
<ol>
<li>现在客户需要分配内存，此时深灰色这个block被分配出去：<ul>
<li>use count &#x3D; 1；</li>
<li>bitmap[0]最后一位变成0，表示已经分配出去</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061955406.png" alt="4_内存管理_155"></p>
<ol start="2">
<li>然后请求分配第二个block，下面两个灰色的block表示被分配出去：<ul>
<li>use count &#x3D; 2；</li>
<li>bitmap[0]后两位变成0，表示这两个block被分配出去。</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061955242.png" alt="4_内存管理_156"></p>
<ol start="3">
<li>后面一直分配block出去，下图表示已经分配出去63个block：<ul>
<li>对应的use count &#x3D; 63；</li>
<li>bitmap[1]和bitmap[0]变成80000000H和00000000H，只有最后一个block对应的bitmap中的bit才为1,表示未被分配出去。</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061957215.png" alt="4_内存管理_157"></p>
<ol start="4">
<li>下面客户归还其中一个block：<ul>
<li>对应的bitmap要变成1，表示未分配（回收回来）；</li>
<li>use count由63变成62。</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061957438.png" alt="4_内存管理_158"></p>
<ol start="5">
<li>当一个super block(有64个blocks)用完后，开始启用第二号super block，<strong>这时候super block中的block块数由64扩大两倍变成128个</strong>，由4个bitmap整数表示。而且mini vector中由一个单元变成两个单元，每个单元指向一个super block。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061957540.png" alt="4_内存管理_159"></p>
<ol start="6">
<li>第二个super block用完（前面已经用完第一个super block，其含有64个blocks，第二个super block包含128个blocks，也已经用完），<strong>启用第三个super bloc，其包含的blocks为128 x 2 &#x3D; 256个</strong>。mini vector中也有第三个单元来控制这个super block。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061958956.png" alt="4_内存管理_160"></p>
<h2 id="55-bitmap-allocator（下）"><a href="#55-bitmap-allocator（下）" class="headerlink" title="55 bitmap_allocator（下）"></a>55 bitmap_allocator（下）</h2><p>上面谈的是bitmap_allocator的分配，下面谈它的回收（容器归还元素空间）机制。</p>
<ol>
<li><p>第一个super block全回收，用另一个mini vector（称为free list）中的entry指针指向这个super block，表示已经回收。<strong>如果下次新分配一个super block，它其中blocks的数量要减半</strong>。</p>
<p>如下图所示，前三个superblocks大小分别为64个，128个，256个，由于第一个superblock被回收，那么下次分配的superblock大小由已经分配的最大值256变成一半，为128个blocks。原来的mini vector里面的指向回收的这个superblock头和尾的entry被删除。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061959663.png" alt="4_内存管理_161"></p>
<ol start="2">
<li>第二个super block也全回收，则free list里的entry加一个，指向这个super block。原来的mini vector里面指向这个superblock头尾的entry被删除。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062000036.png" alt="4_内存管理_162"></p>
<ol start="3">
<li>第三个super block被全回收，被free list的指针指向。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062000522.png" alt="4_内存管理_163"></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>侯捷C++系列</category>
      </categories>
  </entry>
  <entry>
    <title>Ch1 计算机系统漫游</title>
    <url>/2024/04/03/3%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CSAPP/CSAPP_Ch1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Ch1-计算机系统漫游"><a href="#Ch1-计算机系统漫游" class="headerlink" title="Ch1 计算机系统漫游"></a>Ch1 计算机系统漫游</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031123622.png" alt="CSAPP Ch1-Ch3_00"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031124622.png" alt="CSAPP Ch1-Ch3_01"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Ch2 信息的表示和处理</title>
    <url>/2024/04/03/3%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CSAPP/CSAPP_Ch2%20%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Ch2-信息的表示和处理"><a href="#Ch2-信息的表示和处理" class="headerlink" title="Ch2 信息的表示和处理"></a>Ch2 信息的表示和处理</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031130352.png" alt="CSAPP Ch1-Ch3_02"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031130692.png" alt="CSAPP Ch1-Ch3_03"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031130543.png" alt="CSAPP Ch1-Ch3_04"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031131731.png" alt="CSAPP Ch1-Ch3_05"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031131498.png" alt="CSAPP Ch1-Ch3_06"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Ch10 系统级I/O</title>
    <url>/2024/04/03/3%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CSAPP/CSAPP_Ch10%20%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Ch10-系统级I-O"><a href="#Ch10-系统级I-O" class="headerlink" title="Ch10 系统级I&#x2F;O"></a>Ch10 系统级I&#x2F;O</h1><p><strong>I-Input&#x2F;O-Output：外设和内存之间进行数据交互的过程</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052201601.png" alt="image-20240405220142526"></p>
<h2 id="1、系统级I-O"><a href="#1、系统级I-O" class="headerlink" title="1、系统级I&#x2F;O"></a>1、系统级I&#x2F;O</h2><h3 id="（1）Unix-I-O"><a href="#（1）Unix-I-O" class="headerlink" title="（1）Unix I&#x2F;O"></a>（1）Unix I&#x2F;O</h3><ul>
<li>Opening files——返回文件描述符（file discripitor，fd）<ul>
<li>standard unput</li>
<li>standard output</li>
<li>standard err</li>
</ul>
</li>
<li>Changing the current file（改变当前文件的位置）</li>
<li>Reading and Writing files</li>
<li>Closing files</li>
</ul>
<h3 id="（2）Files"><a href="#（2）Files" class="headerlink" title="（2）Files"></a>（2）Files</h3><ul>
<li><p><strong>Regular file</strong>（普通文件）</p>
</li>
<li><p><strong>Directory</strong>（目录文件）</p>
<ul>
<li>相当于文件夹，是一个<strong>存储链接信息</strong>的数组，即<strong>文件和文件名的映射</strong></li>
</ul>
</li>
<li><p><strong>Socket</strong>（套接字）</p>
</li>
<li><p><strong>named pipe</strong>（命名管道），<strong>symbolic link</strong>（符号链接），<strong>character and block device</strong>（字符和块设备）</p>
<ul>
<li>如键盘、鼠标等为字符设备；硬盘为块设备</li>
</ul>
</li>
<li><p><strong>usr</strong>——Unix Software Resources的缩写</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052220580.png" alt="image-20240405222033196"></p>
<h3 id="（3）Opening-and-Closing-Files"><a href="#（3）Opening-and-Closing-Files" class="headerlink" title="（3）Opening and Closing Files"></a>（3）Opening and Closing Files</h3><ul>
<li><p>打开文件</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052222286.png" alt="image-20240405222257203"></p>
</li>
<li><p>关闭文件</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052223245.png" alt="image-20240405222318176"></p>
</li>
</ul>
<h3 id="（4）File-Permission"><a href="#（4）File-Permission" class="headerlink" title="（4）File Permission"></a>（4）File Permission</h3><ul>
<li><p>User（文件拥有者）</p>
</li>
<li><p>Group（群组）</p>
</li>
<li><p>Others（其他人）</p>
</li>
<li><p>观察下图，可以看出：</p>
<ul>
<li>普通文件由<code>-</code>开头；目录文件由<code>d</code>开头</li>
<li><code>rwx</code>：<ul>
<li><code>r</code>：read</li>
<li><code>w</code>：write</li>
<li><code>x</code>：execute</li>
</ul>
</li>
<li>一共有三组，如hello.c：<code>-rw-rw-r--</code>，可以看作是：<code>-|rw-|rw-|r--</code>，分别对应User、Group和Others的权限</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052227053.png" alt="image-20240405222704994"></p>
<h3 id="（5）Reading-and-Writing-Files"><a href="#（5）Reading-and-Writing-Files" class="headerlink" title="（5）Reading and Writing Files"></a>（5）Reading and Writing Files</h3><ul>
<li><code>EOF</code>：End of File</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052233018.png" alt="image-20240405223313949"></p>
<h3 id="（6）Reading-File-Metadata"><a href="#（6）Reading-File-Metadata" class="headerlink" title="（6）Reading File Metadata"></a>（6）Reading File Metadata</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052235910.png" alt="image-20240405223528846"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052235669.png" alt="image-20240405223540586"></p>
<h2 id="2、Robust-I-O"><a href="#2、Robust-I-O" class="headerlink" title="2、Robust I&#x2F;O"></a>2、Robust I&#x2F;O</h2><p><strong>Robust I&#x2F;O主要用于网络中。</strong></p>
<blockquote>
<p>Robust I&#x2F;O（健壮的I&#x2F;O）是一种设计模式，旨在提高程序对输入输出（I&#x2F;O）操作的稳健性和可靠性。具体来说，Robust I&#x2F;O 的作用包括以下几个方面：</p>
<ol>
<li><strong>错误处理：</strong> Robust I&#x2F;O 强调对I&#x2F;O操作的错误处理。它会在发生错误时进行适当的处理，例如捕获异常、返回错误码或者记录日志，从而确保程序在出现异常情况时能够做出合适的应对，而不会导致程序崩溃或者数据丢失。</li>
<li><strong>超时处理：</strong> Robust I&#x2F;O 考虑到可能发生的网络超时、设备故障等情况，会设置适当的超时时间，并在超时发生时进行处理，例如重新尝试连接或者报告错误，以保证程序能够及时响应并继续执行。</li>
<li><strong>资源释放：</strong> Robust I&#x2F;O 确保在完成I&#x2F;O操作后及时释放资源，避免资源泄露和内存溢出等问题，提高程序的稳定性和性能。</li>
<li><strong>容错机制：</strong> Robust I&#x2F;O 通过实现容错机制，可以在遇到部分错误或异常情况时，仍然保持程序的正常运行，尽量避免中断整个操作流程。</li>
<li><strong>重试机制：</strong> Robust I&#x2F;O 可能会实现重试机制，以确保在出现一次性错误时，能够尝试多次重复操作，从而提高操作的成功率。</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052239600.png" alt="image-20240405223951531"></p>
<ul>
<li><p>rio_t结构体</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052240176.png" alt="image-20240405224031108"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Ch3 程序的机器级表示</title>
    <url>/2024/04/03/3%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CSAPP/CSAPP_Ch3%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Ch3-程序的机器级表示"><a href="#Ch3-程序的机器级表示" class="headerlink" title="Ch3 程序的机器级表示"></a>Ch3 程序的机器级表示</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031125101.png" alt="CSAPP Ch1-Ch3_07"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031125684.png" alt="CSAPP Ch1-Ch3_08"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031125146.png" alt="CSAPP Ch1-Ch3_09"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031125670.png" alt="CSAPP Ch1-Ch3_10"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031126892.png" alt="CSAPP Ch1-Ch3_11"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031126616.png" alt="CSAPP Ch1-Ch3_12"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031126789.png" alt="CSAPP Ch1-Ch3_13"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Ch4 处理器体系结构</title>
    <url>/2024/04/01/3%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CSAPP/CSAPP_Ch4%20%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Ch4-处理器体系结构"><a href="#Ch4-处理器体系结构" class="headerlink" title="Ch4 处理器体系结构"></a>Ch4 处理器体系结构</h1><p>CSAPP自定义了一个Y86-64</p>
<h2 id="1、指令系统结构"><a href="#1、指令系统结构" class="headerlink" title="1、指令系统结构"></a>1、指令系统结构</h2><h3 id="（1）Programmer-Visible-State"><a href="#（1）Programmer-Visible-State" class="headerlink" title="（1）Programmer-Visible State"></a>（1）Programmer-Visible State</h3><p>可见状态：每条指令都会去读取或修改处理器某些部分，如下图所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011539557.png" alt="image-20240401153926464" style="zoom:33%;" />

<h3 id="（2）指令编码"><a href="#（2）指令编码" class="headerlink" title="（2）指令编码"></a>（2）指令编码</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011540371.png" alt="image-20240401154030167" style="zoom:33%;" />

<p>如上图最后一条：</p>
<ul>
<li><p>5 指令代码</p>
</li>
<li><p>0 指令功能</p>
</li>
<li><p>rA&#x2F;rB 寄存器指示符字节</p>
<ul>
<li><p>对寄存器编码，用16进制数<strong>0~0xE</strong>表示</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011531970.png" alt="image-20240401153138807" style="zoom:33%;" /></li>
</ul>
</li>
</ul>
<p>举例：（小端法存储）</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011536946.png" alt="image-20240401153606853" style="zoom:33%;" />

<h3 id="（3）处理异常"><a href="#（3）处理异常" class="headerlink" title="（3）处理异常"></a>（3）处理异常</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011540188.png" alt="image-20240401154055033" style="zoom:33%;" />

<h2 id="2、数字电路与处理器设计"><a href="#2、数字电路与处理器设计" class="headerlink" title="2、数字电路与处理器设计"></a>2、数字电路与处理器设计</h2><p>Register File 寄存器文件（寄存器堆）输出端口与ALU的输入端口串联。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011545861.png" alt="image-20240401154517784" style="zoom:33%;" />

<ul>
<li>读写操作共用地址线；</li>
<li>定义15个寄存器，因此地址线设计成4为即可；</li>
<li>we_（写使能信号）&#x2F;reeset（复位信号）</li>
</ul>
<p>下图为Register File的内部结构：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011547329.png" alt="image-20240401154700867" style="zoom: 50%;" />

<p>逻辑门，这些门结构可通过P管和N管（CMOS管）组合表现。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011548500.png" alt="image-20240401154803404" style="zoom: 33%;" />

<h2 id="3、Y86-64的顺序实现"><a href="#3、Y86-64的顺序实现" class="headerlink" title="3、Y86-64的顺序实现"></a>3、Y86-64的顺序实现</h2><p>举例：sum程序对应的汇编代码和二进制指令：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011554476.png" alt="image-20240401155427243" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011554403.png" alt="image-20240401155410294" style="zoom:50%;" />

<h3 id="（1）处理器六大阶段"><a href="#（1）处理器六大阶段" class="headerlink" title="（1）处理器六大阶段"></a>（1）处理器六大阶段</h3><ul>
<li><p>取指：分析指令；</p>
</li>
<li><p>译码：读寄存器文件；</p>
</li>
<li><p>执行：ALU执行 1)算术逻辑运算； 2)计算内存引用的有效地址； 3)执行push和pop指令；</p>
</li>
<li><p>访存：针对内存的读写操作；</p>
</li>
<li><p>写回：写寄存器文件；</p>
</li>
<li><p>更新PC：将PC的内容设置为下一条指令的地址。</p>
</li>
</ul>
<h3 id="（2）各阶段的硬件结构"><a href="#（2）各阶段的硬件结构" class="headerlink" title="（2）各阶段的硬件结构"></a>（2）各阶段的硬件结构</h3><p>总体结构（<strong>其中从valP到Data的橙色线错误，应该为从valC到Data！</strong>），对于顺序操作，这6个阶段在一个时钟周期内完成。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011906322.png" alt="image-20240401190602950"></p>
<ul>
<li><p>取指</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011619659.png" alt="image-20240401161926457" style="zoom: 33%;" />
</li>
<li><p>译码</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011621480.png" alt="image-20240401162105328" style="zoom: 33%;" />
</li>
<li><p>执行</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011622684.png" alt="image-20240401162222519" style="zoom: 33%;" />
</li>
<li><p>访存</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011622546.png" alt="image-20240401162255349" style="zoom: 33%;" />
</li>
<li><p>写回</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011623806.png" alt="image-20240401162342626" style="zoom: 33%;" />
</li>
<li><p>更新PC</p>
<ol>
<li>call指令常数字段；</li>
<li>在访存阶段从内存（栈）中读出的返回地址；</li>
<li>跳转指令的常数字段；</li>
<li>当前PC+当前指令长度。</li>
</ol>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011624170.png" alt="image-20240401162430019" style="zoom: 33%;" /></li>
</ul>
<h3 id="（3）举例"><a href="#（3）举例" class="headerlink" title="（3）举例"></a>（3）举例</h3><p>举例1：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011600331.png" alt="image-20240401160018132" style="zoom: 33%;" />

<p>举例2：（下图中的<strong>valE&#x3D;0+8</strong>是因为寄存器文件的写入端与ALU的输出端相连）</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011605541.png" alt="image-20240401160504446" style="zoom:33%;" />

<p>举例3：</p>
<p>该指令为<strong>将寄存器 <code>%rsp</code> 中的值存储到以 <code>%rbx</code> 寄存器的值为基地址偏移100个字节的内存单元中</strong>，因此不涉及写寄存器操作。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011608224.png" alt="image-20240401160808121" style="zoom:33%;" />

<p>举例4：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011612305.png" alt="image-20240401161239187" style="zoom:33%;" />

<p>举例5：跳转指令</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011613911.png" alt="image-20240401161359730" style="zoom:33%;" />

<h2 id="4、流水线"><a href="#4、流水线" class="headerlink" title="4、流水线"></a>4、流水线</h2><h3 id="（1）属性及原理"><a href="#（1）属性及原理" class="headerlink" title="（1）属性及原理"></a>（1）属性及原理</h3><p>假设有一个非流水线设计，如下图所示，该系统的吞吐量约为<strong>3.12GIPS</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011659177.png" alt="image-20240401165925089" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011659832.png" alt="image-20240401165943770" style="zoom:33%;" />

<p>若采用流水线设计，将组合逻辑单元阶段分为三个阶段，每个阶段120ps，此时吞吐量为<strong>8.33GIPS</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011701350.png" alt="image-20240401170120155" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011702592.png" alt="image-20240401170206480" style="zoom:33%;" />

<ul>
<li>流水线的局限性：此时各个阶段的延迟可能都是不等的，此时时钟的速率受最慢阶段的限制（木桶效应）：</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011706596.png" alt="image-20240401170631392" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011836974.png" alt="image-20240401183610851" style="zoom:33%;" />

<ul>
<li>此外，过深的流水线会导致系统性能的下降。实际中的指令间存在数据依赖，以及指令控制流造成的控制依赖。</li>
</ul>
<h3 id="（2）硬件结构"><a href="#（2）硬件结构" class="headerlink" title="（2）硬件结构"></a>（2）硬件结构</h3><p>在顺序实现的硬件结构中，取指发生在时钟周期刚开始时，而更新PC发生在时钟快要结束时，如下图所示（<strong>橙色线需勘误</strong>）。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011906322.png" alt="image-20240401190602950"></p>
<p>为了实现流水线的硬件结构，将更新PC的操作从时钟周期快要结束时移动到时钟刚开始执行时（即最左侧新增的寄存器）</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011910589.png" alt="image-20240401191048453"></p>
<p>从宏观上来说，也就是在各个阶段前加入流水线寄存器。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011911529.png" alt="image-20240401191145449"></p>
<p>其展开后的整体逻辑如下：</p>
<ul>
<li>寄存器F保存PC的预测值；</li>
<li>寄存器D保存刚取出的指令信息；</li>
<li>寄存器E保存最新译码指令的状态以及从寄存器文件中读出的数值；</li>
<li>寄存器M保存最新执行指令的结果，包含ALU处理的那三类；</li>
<li>寄存器W保存访存执行的结果，而反馈路径将结果写回寄存器文件。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011924576.png" alt="image-20240401192450295"></p>
<h3 id="（3）数据冒险"><a href="#（3）数据冒险" class="headerlink" title="（3）数据冒险"></a>（3）数据冒险</h3><p>在下图的时钟周期4中，读取到的值并非所期望的10和3，而是默认值0，这是因为此时指令1处于访存阶段，10仍未写回%rdx中；而指令2处于执行阶段，3也未写回%rax。这种情况称为<strong>冒险&#x2F;冲突</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011937082.png" alt="image-20240401193745913" style="zoom:50%;" />

<p>解决方法：</p>
<ul>
<li><p>暂停技术</p>
<ul>
<li><p>在D阶段读取寄存器的ID值，分别于执行阶段、访存阶段及写回阶段所执行指令的目的寄存器ID比较，若相等，则存在数据相关，需要在译码阶段等待；</p>
</li>
<li><p>方式为插入气泡：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011941588.png" alt="image-20240401194157407"></p>
</li>
</ul>
</li>
<li><p>数据转发&#x2F;旁路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011943090.png" alt="image-20240401194351754"></p>
</li>
</ul>
<h3 id="（4）控制冒险"><a href="#（4）控制冒险" class="headerlink" title="（4）控制冒险"></a>（4）控制冒险</h3><p>控制冒险的情况例举如下：</p>
<ul>
<li>若取出的是ret指令，下一条指令的地址需要等到访存结束后才能从栈中取出；  —— 解决：暂停处理新指令</li>
<li>若取出的是分支条件指令，需要经过执行阶段后才能确定是否跳转。—— 解决：分支预测（预测其总是跳转或总是不跳转）</li>
</ul>
<p>暂停和插入气泡是如何实现的？</p>
<p>流水线寄存器是通过时钟的上升沿来改变输出的值，遇到上升沿时，加载其输入作为新的输出。因此，给每个流水线寄存器引入stall信号和bubble信号，<strong>当需要暂停时</strong>，将halt信号设为1，寄存器保存原状态；<strong>当需要插入气泡时</strong>，将bubble信号设为1，寄存器的状态设置成某个固定的复位配置，等效于nop。</p>
<h2 id="5、Y86-64的流水线实现"><a href="#5、Y86-64的流水线实现" class="headerlink" title="5、Y86-64的流水线实现"></a>5、Y86-64的流水线实现</h2><h3 id="（1）取指阶段"><a href="#（1）取指阶段" class="headerlink" title="（1）取指阶段"></a>（1）取指阶段</h3><ul>
<li><p>顺序执行：valP &#x3D; 当前PC + 指令长度</p>
</li>
<li><p>跳转执行：valP &#x3D; （指令中的常数字段）valC</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404012055519.png" alt="image-20240401205520162" style="zoom:50%;" />
</li>
<li><p>为了应对出错的情况，设置<strong>select PC部件</strong>纠错：</p>
<ul>
<li><p>若取到<strong>ret</strong>，需要等到译码、执行和访存后，才能从内存中读到正确的返回地址，此时的改正方法为：<strong>将流水线寄存器W中的访存结果（W_valM）作为下一条指令的地址；</strong></p>
</li>
<li><p>若取到<strong>条件分支指令</strong>，需要等到译码、执行后才能判断是否跳转，此时的改正方法为：<strong>根据Cnd信号判断是否跳转，若不跳转，则从流水线寄存器M读取（M_valA）下一条指令的地址</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404012104691.png" alt="image-20240401210442459"></p>
</li>
</ul>
</li>
</ul>
<h3 id="（2）译码阶段"><a href="#（2）译码阶段" class="headerlink" title="（2）译码阶段"></a>（2）译码阶段</h3><ul>
<li><p>需要判断是1）<strong>直接使用转发的数据</strong>；还是2）<strong>从寄存器文件中读取数据</strong>。</p>
</li>
<li><p>哪些数据需要转发？</p>
<ul>
<li><strong>ALU的输出结果</strong><ul>
<li>正常需要经访存和写回后，才能完成寄存器的数据更新；</li>
<li>采用转发设计时，ALU的输出结果可以马上作为译码阶段的结果。</li>
</ul>
</li>
<li><strong>内存的输出数据</strong><ul>
<li>和ALU类似</li>
</ul>
</li>
<li><strong>访存阶段时，寄存器写入端口E还没有写入的数据</strong></li>
<li><strong>写回阶段时，寄存器写入端口M还没有写入的数据</strong></li>
<li><strong>写回阶段时，寄存器写入端口E还没有写入的数据</strong></li>
</ul>
</li>
<li><p>每个转发源包括：1）<strong>寄存器的ID值</strong>；2）<strong>转发数据</strong>。</p>
</li>
<li><p>Sel+Fwd A与Fwd B相比，<strong>多了一个valP输入</strong>。这里将valA与valP合并，可以合并的原因是只有函数调用指令和跳转指令在后面的阶段才需要用到valP，而这两类指令并不需要从A端口读取数据（见3(3).举例5.跳转指令）</p>
<ul>
<li>valP是顺序执行时下一条指令的地址，而跳转执行指令在译码阶段不需要valP；</li>
<li>根据icode判断是否为这两类指令，如果是则可以进行合并。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404012117651.png" alt="image-20240401211720521"></p>
</li>
</ul>
<p>其他阶段和顺序设计相差不大，不再赘述。</p>
<h2 id="6、流水线的控制逻辑"><a href="#6、流水线的控制逻辑" class="headerlink" title="6、流水线的控制逻辑"></a>6、流水线的控制逻辑</h2><h3 id="（1）加载-使用冒险"><a href="#（1）加载-使用冒险" class="headerlink" title="（1）加载&#x2F;使用冒险"></a>（1）加载&#x2F;使用冒险</h3><h3 id="（2）分支预测发生错误"><a href="#（2）分支预测发生错误" class="headerlink" title="（2）分支预测发生错误"></a>（2）分支预测发生错误</h3><h3 id="（3）返回阶段的处理"><a href="#（3）返回阶段的处理" class="headerlink" title="（3）返回阶段的处理"></a>（3）返回阶段的处理</h3>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Ch5 优化程序性能</title>
    <url>/2024/04/03/3%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CSAPP/CSAPP_Ch5%20%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<span id="more"></span>



<h1 id="Ch5-优化程序性能"><a href="#Ch5-优化程序性能" class="headerlink" title="Ch5 优化程序性能"></a>Ch5 优化程序性能</h1><h2 id="1、优化程序性能"><a href="#1、优化程序性能" class="headerlink" title="1、优化程序性能"></a>1、优化程序性能</h2><h3 id="（1）局限性"><a href="#（1）局限性" class="headerlink" title="（1）局限性"></a>（1）局限性</h3><ul>
<li><strong>如果编译器无法确定两个指针是否指向同一个位置，那么编译器会假设所有情况都有可能发生，反而限制了优化策略。</strong></li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404012134539.png" alt="image-20240401213441380" style="zoom:33%;" />

<p>当编译器在优化代码时，会假设xp和yp有可能指向同一个内存位置，如下图所示，此时add1 res&#x3D;4x，add2 res&#x3D;3x，因此不能将add2用于优化add1。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404012134793.png" alt="image-20240401213457648" style="zoom:33%;" />

<ul>
<li><strong>函数调用影响优化策略</strong></li>
</ul>
<p>如下图所示，大多数编译器不会把func1优化为func2（注意func2返回0是因为counter为后++，先返回再++）。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021006812.png" alt="image-20240402100639099" style="zoom:33%;" />

<h3 id="（2）优化方式"><a href="#（2）优化方式" class="headerlink" title="（2）优化方式"></a>（2）优化方式</h3><ul>
<li><p>1）代码移动</p>
<ul>
<li>循环不变式外提，比如在执行for循环前先计算出数组长度；</li>
</ul>
</li>
<li><p>2）优化函数调用</p>
<ul>
<li><p>举例：在循环中将函数get_vec_element变为直接数组访问，这样反而降低了效率，这是因为每次操作数组时需要两次读内存和一次写内存：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021022591.png" alt="image-20240402102218521"></p>
</li>
<li><p>基于此再进行优化，设置临时变量，直到循环结束再写入，此时只需要一次读内存，性能得到了很大的提升：</p>
<ul>
<li><strong>这里的acc是临时变量， 通常情况下，临时变量会被保存在栈帧（栈帧是用来存储函数调用期间的局部变量和其他临时数据的一块内存区域）中， 由于 acc 在循环中频繁使用，并且在每次迭代中都需要更新，将其保存在寄存器中可以提高访问速度，避免了频繁的内存访问操作。寄存器的访问速度比内存更快，因此可以加快循环的执行速度；</strong></li>
<li><strong>由于循环中的代码会被频繁执行，对循环内的变量进行优化以提高性能尤为重要。将累加器保存在寄存器中可以减少内存访问次数，从而提高代码的执行效率。</strong></li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021022289.png" alt="image-20240402102255146" style="zoom:33%;" /></li>
</ul>
</li>
</ul>
<h2 id="2、现代处理器"><a href="#2、现代处理器" class="headerlink" title="2、现代处理器"></a>2、现代处理器</h2><p>在1的基础上，考虑利用处理器的微体系结构进行优化。现代处理器可以实现多指令并行。</p>
<h3 id="（1）功能单元"><a href="#（1）功能单元" class="headerlink" title="（1）功能单元"></a>（1）功能单元</h3><ul>
<li>指令控制单元（Instruction Control Unit，ICU）<ul>
<li>从内存中读取指令序列并译码，之后进行一系列操作</li>
<li>退役单元，控制着寄存器文件<ul>
<li>若指令执行完毕，相应更新寄存器文件；</li>
<li>若不该执行该条指令，则丢弃所有运算结果。</li>
</ul>
</li>
</ul>
</li>
<li>执行单元（Execution Unit，EU）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021039315.png" alt="image-20240402103925031"></p>
<h3 id="（2）功能单元的性能衡量指标"><a href="#（2）功能单元的性能衡量指标" class="headerlink" title="（2）功能单元的性能衡量指标"></a>（2）功能单元的性能衡量指标</h3><ul>
<li>延迟（Latency）：完成运算需要的总时间</li>
<li>发射（Isuue）：两次运算间间隔的最小周期数</li>
<li>容量（Capacity）：执行该运算的功能单元的数量</li>
</ul>
<p>CPE&#x2F;Clocks Per Instruction，每条指令所需的时钟周期数，衡量计算机指令执行效率的一个指标。</p>
<p>延迟界限和吞吐量界限的CPE值</p>
<ul>
<li>延迟界限：在给定的工作负载下，系统性能受到的主要限制是每个任务或指令的执行时间（延迟）的上限<ul>
<li>对于任何必须严格按照顺序执行的合并运算，延迟界限给出了所需要的最小的CPE值</li>
</ul>
</li>
</ul>
<p>吞吐量界限：在给定的工作负载下，系统性能受到的主要限制是系统的总体吞吐量（Throughput）的上限</p>
<ul>
<li>吞吐量是指单位时间内完成的任务数或指令数，它反映了系统的处理能力和效率</li>
<li>吞吐量界限通常与系统资源的利用率相关联，包括处理器的吞吐量、内存带宽、缓存命中率等因素</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Ch6 存储器层次结构</title>
    <url>/2024/04/03/3%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CSAPP/CSAPP_Ch6%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Ch6-存储器层次结构"><a href="#Ch6-存储器层次结构" class="headerlink" title="Ch6 存储器层次结构"></a>Ch6 存储器层次结构</h1><h2 id="1、存储技术"><a href="#1、存储技术" class="headerlink" title="1、存储技术"></a>1、存储技术</h2><h3 id="（1）随机访问存储器（RAM）"><a href="#（1）随机访问存储器（RAM）" class="headerlink" title="（1）随机访问存储器（RAM）"></a>（1）随机访问存储器（RAM）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021437441.png" alt="image-20240402143708229"></p>
<ul>
<li><p>静态RAM（SRAM）</p>
<ul>
<li>将每个bit位的信息存储在一个双稳态的存储器单元内，每个存储体单元由6个晶体管实现</li>
</ul>
</li>
<li><p>动态RAM（DRAM）</p>
<ul>
<li><p>电容充电，将每个bit位的存储对应1个电容和1个晶体管</p>
</li>
<li><p>存在缺陷：漏电时在10-100毫秒失去电荷，内存系统需要不断读出数据并重写，通过刷新来保存数据</p>
</li>
<li><p>举例：</p>
<ul>
<li>16：超单元（即supercell，DRAM的单个存储单元）个数</li>
<li>8：每个超单元存储8比特数据</li>
<li>下图分行、列两次发送地址，虽然增加了访问时间，原因<strong>DRAM存储结构为二位阵列而非一维数组，可以减少地址引脚数量</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021444685.png" alt="image-20240402144425635"></p>
</li>
<li><p>DRAM0-DRAM7以此存储低八位字节至最高八位字节，当处理器向内存控制器发起读取数据的请求时，内存控制器将地址转换为超单元地址，内存模块将i和j广播给每个DRAM，从而找到对应的数据，最终返回一个64bit的数据：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021450063.png" alt="image-20240402145000491"></p>
</li>
</ul>
</li>
</ul>
<h3 id="（2）机械磁盘"><a href="#（2）机械磁盘" class="headerlink" title="（2）机械磁盘"></a>（2）机械磁盘</h3><p>依靠盘片存储数据，表面涂有磁性记录材料。如下图共3个盘片，即6个盘面存储数据。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021453039.png" alt="image-20240402145348856" style="zoom: 50%;" />

<p>盘片表面由一圈圈的磁道组成。每一圈磁盘划分为多个扇区（通常存储512字节），扇区间存在间隙用于存储扇区的标识信息。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021457089.png" alt="image-20240402145714941" style="zoom:33%;" />

<p>每个盘片有独立的读&#x2F;写头，所有读&#x2F;写头连接在一个<strong>传动臂</strong>上，只能在半径方向上移动来读写数据，称为<strong>寻道</strong>。所有的读&#x2F;写头必须垂直排列、一致行动。读&#x2F;写头距离表盘的距离约0.1微米。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021458391.png" alt="image-20240402145841146" style="zoom: 33%;" />

<p>磁盘访问数据花费时间：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021513461.png" alt="image-20240402151318110" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021515859.png" alt="image-20240402151514499" style="zoom:50%;" />

<h3 id="（3）固态硬盘"><a href="#（3）固态硬盘" class="headerlink" title="（3）固态硬盘"></a>（3）固态硬盘</h3><p>固态磁盘由一个或多个闪存芯片组成，使用闪存芯片替代传动臂加盘片这种机械工作方式。</p>
<p>Flash translation layer：FTL，闪存转换层，将操作系统对逻辑块的请求翻译成对底层物理设备的访问。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021515854.png" alt="image-20240402151543579"></p>
<ul>
<li><p>闪存芯片（falsh chip）</p>
<ul>
<li><p>基于Nand Flash实现，下图的block与逻辑块无关。</p>
</li>
<li><p>包含读、写和擦除三个操作。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021521937.png" alt="image-20240402152128719"></p>
</li>
</ul>
</li>
</ul>
<h3 id="（4）程序的局部性"><a href="#（4）程序的局部性" class="headerlink" title="（4）程序的局部性"></a>（4）程序的局部性</h3><ul>
<li>时间局部性<ul>
<li>若被引用过的内存位置很可能在不远的将来还会被多次引用，则具有较好的时间局部性；</li>
</ul>
</li>
<li>空间局部性<ul>
<li>若一个内存位置被引用一次后，程序在不远的将来引用其附近的一个内存位置，则具有较好的时间局部性；</li>
</ul>
</li>
</ul>
<h2 id="2、存储器层次结构"><a href="#2、存储器层次结构" class="headerlink" title="2、存储器层次结构"></a>2、存储器层次结构</h2><p>结构如下图所示，基本思想是上层存储设备作为下层存储设备的缓存。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021433966.png" alt="image-20240402143353405"></p>
<h3 id="（1）cache"><a href="#（1）cache" class="headerlink" title="（1）cache"></a>（1）cache</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021603503.png" alt="image-20240402160342276"></p>
<ul>
<li><p>缓存命中（cache Hit）</p>
<ul>
<li>当程序需要第k+1层的某个数据对象d时，它首先从第k层的数据块中检索是否包含目标数据d的副本。若第k层包含目标数据d，称为缓存明中，否则称之为缓存不命中（cache Miss）</li>
<li>当发生不命中时，第k层的缓存要从第k+1层取出包含目标数据的块；若第k层缓存已满，会覆盖已有的块，被替换的块称为牺牲块。</li>
<li>步骤分三步：<ul>
<li>set selection（组选择）</li>
<li>line matching（行匹配）</li>
<li>word extraction（字抽取）</li>
</ul>
</li>
</ul>
</li>
<li><p>内部结构</p>
<ul>
<li><p>划分为S个Set，每个Set包含E行cache Line，地址为m位。</p>
</li>
<li><p>每行cache Line包含valid（数据是否有效）、Tag（目标数据是否存在在当前cache Line中）和大小为B的数据副本</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021607690.png" alt="image-20240402160725448" style="zoom: 50%;" />
</li>
<li><p>cache通过下面的方式知道自己是否包含目标数据的副本</p>
<ul>
<li>假设目标数据的地址A长度为m位，该地址会被S和B分为3个字段，如下图所示。<ul>
<li><strong>Set index确定目标数据存储在哪个set中</strong></li>
<li><strong>Tag确定目标数据在set的哪一行（此时valid必须为1）</strong></li>
<li><strong>Block index指示块偏移量，确定目标数据的确切数据</strong></li>
</ul>
</li>
<li>cache用中间的位作为Set索引，是为了避免使用高位作为索引时造成映射到相同的区域。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021609317.png" alt="image-20240402160935274" style="zoom: 50%;" />
</li>
<li><p>Issues With Writes</p>
<ul>
<li>写命中（Write Hit）<ul>
<li>写穿透（write-through）：写入cache的同时写回内存（更低一级cache），这样cache在替换可以直接丢掉旧的</li>
<li>写回（write-back）：只写入cache，在cache需要替换时才写回内存</li>
</ul>
</li>
<li>写不命中（Write Miss）<ul>
<li>写分配（write-allocate）：先把目标数据所在的块从内存（更低一级cache）加载到cache中，然后再往cache中写</li>
<li>写不分配（no-write-allocate）：绕开cache，直接把要写的内容写到内存里</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（2）直接映射高速缓存"><a href="#（2）直接映射高速缓存" class="headerlink" title="（2）直接映射高速缓存"></a>（2）直接映射高速缓存</h3><ul>
<li><p>直接映射：每个Set只包含1行cache line</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021611962.png" alt="image-20240402161142799" style="zoom:50%;" />
</li>
<li><p>举例说明：假设存在一个cache，大小为(4, 1, 2, 4)，则整个地址空间可以由0-15标记，而标记位Tag和索引位Index连起来可以唯一的标识每一个内存块。</p>
<ul>
<li><p><strong>s1、组选择</strong>：根据Set index进行选择</p>
</li>
<li><p><strong>s2、行匹配</strong>：</p>
<ul>
<li>1、valid是否为1？</li>
<li>2、对比cache Line中的Tag与地址中的Tag是否一致</li>
</ul>
</li>
<li><p><strong>s3、字抽取</strong></p>
<ul>
<li>若一致，根据Block offset找到确切的地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021620864.png" alt="image-20240402162006768" style="zoom: 50%;" />

<ul>
<li><p>举例说明：假设有一个cache如下图所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021640771.png" alt="image-20240402164025528" style="zoom: 50%;" />

<ul>
<li>当地址是4位时，整个地址空间用编号0-15表示</li>
<li>地址中的Tag和Index二者结合标识唯一的内存块（即右侧的Block number）。由于<strong>每个内存块由两个字节组成</strong>，因此整个内存空间被分成8个块</li>
<li>由于cache中仅包含4个Set，因此会出现两个内存块映射到同一个Set的情况</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021636016.png" alt="image-20240402163600762"></p>
</li>
<li><p><strong>冲突不命中</strong>：内存中的不同块映射到cache的同一个Set中，此时不同块之间交替引用，即使cache中还存在空闲的块，也依旧造成不命中。</p>
</li>
</ul>
<h3 id="（3）组相联-全相联高速缓存"><a href="#（3）组相联-全相联高速缓存" class="headerlink" title="（3）组相联&#x2F;全相联高速缓存"></a>（3）组相联&#x2F;全相联高速缓存</h3><ul>
<li><p>组相联cache的每个set包含多个cache line，下图是一个2路组相联，其中C为cache的容量。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021659281.png" alt="image-20240402165930042" style="zoom:50%;" />
</li>
<li><p>全相联cache只有一个set</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021859412.png" alt="image-20240402185940143" style="zoom:50%;" /></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Ch7 链接</title>
    <url>/2024/04/03/3%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CSAPP/CSAPP_Ch7%20%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Ch7-链接"><a href="#Ch7-链接" class="headerlink" title="Ch7 链接"></a>Ch7 链接</h1><h2 id="1、编译器驱动程序"><a href="#1、编译器驱动程序" class="headerlink" title="1、编译器驱动程序"></a>1、编译器驱动程序</h2><p>链接（Linking）：<strong>将可重定位目标文件以及必要的系统文件组合起来，生成一个可执行文件</strong>，并加载到内存执行。</p>
<ul>
<li>构造大型程序时，容易遇到<strong>缺少库文件或库文件的版权不兼容导致连接错误</strong>的问题，因此需要理解链接器是如何用库文件来解析引用的；</li>
<li>遇到一些危险的编译错误；</li>
<li>理解语言的作用域如何实现；</li>
<li>理解其他重要的系统概念；</li>
<li>更好地利用共享库。</li>
</ul>
<p>编译系统四步：</p>
<ul>
<li><p>预处理</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021919552.png" alt="image-20240402191932454" style="zoom: 33%;" />
</li>
<li><p>编译</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021920420.png" alt="image-20240402192004172" style="zoom:33%;" />
</li>
<li><p>汇编</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021920745.png" alt="image-20240402192028410" style="zoom:33%;" />
</li>
<li><p>链接</p>
<ul>
<li><p>crt  –  c runtime</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021920762.png" alt="image-20240402192057662" style="zoom:33%;" />
</li>
<li><p>ld  –  链接器</p>
</li>
<li><p>-static – 静态链接</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021921378.png" alt="image-20240402192107260" style="zoom:33%;" /></li>
</ul>
</li>
</ul>
<h2 id="2、可重定位目标文件"><a href="#2、可重定位目标文件" class="headerlink" title="2、可重定位目标文件"></a>2、可重定位目标文件</h2><p>可重定位文件的组成：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021927625.png" alt="image-20240402192742394" style="zoom: 50%;" />

<p>本节举例用到的程序：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022023749.png" alt="image-20240402202308661" style="zoom:33%;" />

<h3 id="（1）ELF-header"><a href="#（1）ELF-header" class="headerlink" title="（1）ELF header"></a>（1）ELF header</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021928876.png" alt="image-20240402192847629" style="zoom:50%;" />

<ul>
<li><p>Magic（魔数），用于确定文件类型，操作系统在加载可执行文件时会确认魔数是否正确。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021930868.png" alt="image-20240402193033694" style="zoom:33%;" />
</li>
<li><p>start of section headers：为section header table的起始地址</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021936802.png" alt="image-20240402193640661" style="zoom:33%;" /></li>
</ul>
<h3 id="（2）Section-header-table"><a href="#（2）Section-header-table" class="headerlink" title="（2）Section header table"></a>（2）Section header table</h3><p>查看表的全部内容：<code>readelf -S main.o</code></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022030317.png" alt="image-20240402203056995" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022020376.png" alt="image-20240402202016269" style="zoom:50%;" />

<ul>
<li><p><strong><code>.text</code> Section：</strong>存放<strong>已经编译好的机器代码</strong>，使用<code>objdump -s -d main.o</code>查看</p>
</li>
<li><p><strong><code>.data</code> Section：</strong>存放<strong>已初始化的全局变量和静态变量</strong>的值</p>
</li>
<li><p><strong><code>.bss</code> Section：</strong>存放<strong>未初始化的全局变量和静态变量</strong>的值</p>
<ul>
<li>实际上bss section并不占据实际的空间，它仅仅只是一个占位符</li>
<li>区分已初始化和未初始化的变量是为了节省空间<ul>
<li><strong>节省空间</strong>的含义：在可执行文件中不存储未初始化的全局变量和静态变量的实际初始值，而是延迟到程序运行时动态分配内存并初始化为零，从而减小可执行文件的体积。</li>
</ul>
</li>
<li><strong>和COMMON的区别</strong><ul>
<li>COMMON：未初始化的全局变量</li>
<li>.bss：未初始化的静态变量，初始化为0的全局或静态变量</li>
</ul>
</li>
</ul>
</li>
<li><p><code>.rodata</code> Section：ro-read only，如printf语句中的格式串和switch语句中的跳转表</p>
</li>
<li><p><strong>其余Section：</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022020768.png" alt="image-20240402202046576" style="zoom: 50%;" />
</li>
<li><p><strong><code>.symtab</code> Section</strong></p>
<ul>
<li><p>使用<code>readelf -s main.o</code>命令查看符号表的内容</p>
<ul>
<li>ndx 字段则用于指示该 section 在 section header table 中的索引</li>
<li>由于printf只是在main.c中被引用，并非定义在main.c中，因此其Ndx为UND(Undefine)类型</li>
<li>OBJECT类型表示符号为数据对象</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022030660.png" alt="image-20240402203002144"></p>
</li>
<li><p><strong>有三种类型的符号</strong></p>
<ul>
<li>全局符号：由<strong>该模块</strong>定义，同时能被其他模块引用</li>
<li>外部符号：由<strong>其他模块</strong>定义，同时能被其他模块引用</li>
<li>局部符号：由<strong>该模块</strong>定义，不能被其他模块引用<ul>
<li>任何带有<code>static</code>属性声明的全局变量或函数都是模块私有的</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>强符号与弱符号</strong></p>
<ul>
<li>强符号：函数和已初始化的全局变量</li>
<li>弱符号：未初始化的全局变量</li>
</ul>
</li>
<li><p><strong>符号解析</strong></p>
<ul>
<li><p><strong>当编译器遇到一个不是在当前模块中定义的符号时，会假设该符号是在其他模块中定义的。此时仅执行编译和汇编，而不执行链接的话是没有问题的</strong></p>
</li>
<li><p>找不到符号定义时的报错：</p>
<p><img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240402204455103.png" alt="image-20240402204455103"></p>
</li>
<li><p>多个可重定位文件中定义了同名的全局符号，有以下三种情况：</p>
<ul>
<li><p><strong>多个同名强符号一起出现——不允许</strong></p>
</li>
<li><p>一个强符号和多个同名弱符号——允许</p>
</li>
<li><p>多个同名弱符号——允许</p>
<ul>
<li><p>但容易发生不易发现的错误，如下图所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022103873.png" alt="image-20240402210359483" style="zoom: 33%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（3）静态库"><a href="#（3）静态库" class="headerlink" title="（3）静态库"></a>（3）静态库</h3><ul>
<li><p>定义：在Linux系统中，静态库以一种称为archive的特殊文件格式存放在磁盘上，如<code>libc.a</code>。<strong>archive文件是一组可重定位目标文件的集合。</strong></p>
</li>
<li><p>举例：如何构造一个静态库文件<code>libvector.a</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022111482.png" alt="image-20240402211100296"></p>
<p>​	之后就可以在链接时使用该静态库文件：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022111559.png" alt="image-20240402211151493" style="zoom:50%;" />
</li>
<li><p><strong>静态库的链接过程</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022113150.png" alt="image-20240402211346051" style="zoom:50%;" />
</li>
<li><p><strong>静态库的解析过程</strong></p>
<ul>
<li><p>链接器<strong>从左到右</strong>按命令行中出现的顺序来扫描可重定位文件和静态库文件（libc.a可以不用显式写出）</p>
<ul>
<li><p>由于是按从左到右的顺序扫描，因此命令行中各文件的输入顺序十分重要，遵循<strong>调用者在前</strong>的顺序</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022125679.png" alt="image-20240402212530449" style="zoom:50%;" /></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">linux&gt; gcc -<span class="type">static</span> -o prog main.o ./libvector.a [libc.a]</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理三个集合，直至集合U和D不再发生变化，<strong>仅当集合U为空时才会链接正确</strong></p>
<ul>
<li>集合E：扫描中发现的可重定位目标文件</li>
<li>集合U：引用了但尚未定义的符号（也即是在其他模块中定义的符号）<ul>
<li>放入目标文件的符号表中未定义，仅引用的符号</li>
<li><strong>而尝试会用扫描到的静态库文件解析集合U中未定义的符号，找到其相关定义后转移到集合D中</strong></li>
</ul>
</li>
<li>集合D：已经定义了的符号</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>重定位（Relocation）</strong></p>
<ul>
<li><p>链接器合并输入模块，并为每个符号分配运行时地址</p>
</li>
<li><p>步骤</p>
<ul>
<li><p>重定位section和符号定义</p>
<ul>
<li>将所有可重定位目标文件中<strong>相同类型的section合并为一个新的section</strong></li>
</ul>
</li>
<li><p>重定位section中的符号引用，使其指向正确的运行地址</p>
<ul>
<li><p>依赖于可重定位条目的数据结构</p>
</li>
<li><p>由于汇编器在生成可重定位目标文件时，并不知道数据和代码在内存的什么位置，同时也不知道该模块所引用的外部定义的函数以及全局变量的位置。因此，<strong>当遇到最终位置不确定的符号引用时，就产生一个可重定位条目，告诉链接器在合成可执行文件时应该如何修改这个引用</strong></p>
<ul>
<li><p>关于代码的重定位条目放在<code>.rel.text</code>；已初始化数据的重定位条目放在<code>.rel.data</code></p>
</li>
<li><p>重定位条目的结构体定义</p>
<ul>
<li>offset：被修改的引用的section偏移量</li>
<li>type：重定位条目的类型，此处仅关心图中两种类型</li>
<li>symbol：表示被修改的引用时是哪一个符号</li>
<li>addend：常数，用于对某些类型的重定位条目进行偏移调整</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031016083.png" alt="image-20240403101650663" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>举例说明：此处ref_addr为运行时的地址；而*ref_ptr相当于计算的是当前PC要加上多少才能跳转到sum函数的地址处</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031022768.png" alt="image-20240403102210671" style="zoom: 80%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>举例：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031034256.png" alt="image-20240403103405171" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031034682.png" alt="image-20240403103432537" style="zoom:50%;" />

<h3 id="（4）可执行目标文件"><a href="#（4）可执行目标文件" class="headerlink" title="（4）可执行目标文件"></a>（4）可执行目标文件</h3><ul>
<li><strong>总体概述</strong></li>
</ul>
<p>下图左侧为可执行（目标）文件，右图为可重定位目标文件</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031035608.png" alt="image-20240403103531280"></p>
<p>具体来说，<strong>代码段和数据段会在执行时加入内存，而剩余的如符号表、调试信息等不会加入内存。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031036213.png" alt="image-20240403103641109" style="zoom:50%;" />

<ul>
<li><p><strong>段头部表（Segment header table）</strong></p>
<ul>
<li><p>描述代码段、数据段与内存的映射关系</p>
</li>
<li><p>末尾的<code>r-x/rw-</code>表示是否可读、可写以及可执行；</p>
</li>
<li><p><code>off</code>表示这个段在可执行文件中的偏移量</p>
</li>
<li><p><code>vaddr/paddr</code>表示该段在内存中的开始地址</p>
</li>
<li><p><code>filesz</code>表示该段的大小</p>
</li>
<li><p><code>memsz</code>表示运行时该段在内存中的大小，包括ELF header、程序头部表以及.init、.text和.rodata section的内容。<strong>注意：数据段中memsz比filesz多8个字节，是为了存储.bss的数据（仅运行时分配内存）</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031044703.png" alt="image-20240403104441234"></p>
</li>
</ul>
</li>
<li><p><strong>程序的加载过程（大致）</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031049727.png" alt="image-20240403104941601"></p>
</li>
</ul>
<h3 id="（5）动态链接共享库"><a href="#（5）动态链接共享库" class="headerlink" title="（5）动态链接共享库"></a>（5）动态链接共享库</h3><p>Linux中的<code>.so</code>文件和Windows中的<code>.dll</code>文件。</p>
<ul>
<li><p><strong>如何构造共享库</strong></p>
<ul>
<li><p>-shared</p>
</li>
<li><p>-fpic：位置无关选项，这样共享库才能被加载到任意的内存位置</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031113305.png" alt="image-20240403111355228" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031114886.png" alt="image-20240403111421652" style="zoom:50%;" /></li>
</ul>
</li>
<li><p><strong>动态链接过程</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031115921.png" alt="image-20240403111521660" style="zoom: 50%;" /></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032057373.png" alt="image-20240403205722302"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Ch8 异常控制流</title>
    <url>/2024/04/03/3%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CSAPP/CSAPP_Ch8%20%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Ch8-异常控制流"><a href="#Ch8-异常控制流" class="headerlink" title="Ch8 异常控制流"></a>Ch8 异常控制流</h1><h2 id="1、异常控制流"><a href="#1、异常控制流" class="headerlink" title="1、异常控制流"></a>1、异常控制流</h2><h3 id="（1）控制流"><a href="#（1）控制流" class="headerlink" title="（1）控制流"></a>（1）控制流</h3><p>处理器上电运行到断点关机的过程中，如下图，从ak到ak+1的过渡称为控制转移。最简单的控制流是平滑序列，其中平滑指内存中地址相邻，当出现跳转、函数调用和返回这类指令时会造成“不平滑”，会导致突变。</p>
<p><strong>异常控制流（Exception Control Flow）</strong>指的是程序执行过程中由于发生异常而导致的控制流程的变化。在计算机系统中，异常是一种特殊的事件，它表示了一种不寻常的情况，可能需要程序或者操作系统采取相应的措施来处理。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031243585.png" alt="image-20240403124332377" style="zoom: 33%;" />

<h2 id="2、异常"><a href="#2、异常" class="headerlink" title="2、异常"></a>2、异常</h2><ul>
<li>定义：在执行某个指令时，可能发生一个与当前指令有关或无关的<strong>事件</strong>，此时处理器将从执行应用程序切换到<strong>异常处理程序</strong>，待起处理完成后，根据引起异常的事件类型选择是否返回。</li>
<li>对异常的处理类似于一个间接的函数调用，但存在一些细微的差异：<ul>
<li>函数调用时，在跳转到目前函数之前，处理器首先将返回地址压入栈中；而处理器在处理异常时，会<strong>把处理器额外的一些状态压到栈中</strong></li>
<li>此外，若控制是从用户态转向内核态，那么所有的这些内容会被压到<strong>内核栈</strong>中，而不是用户栈中</li>
<li><strong>异常处理程序运行在内核态</strong>，因此对所有的系统资源都有访问权限</li>
</ul>
</li>
</ul>
<p>​	<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031250335.png" alt="image-20240403125006994"  /></p>
<ul>
<li>当异常处理程序处理完事件后，有以下三种情况：<ul>
<li>将控制交还给之前正在执行的指令</li>
<li>将控制返回给如果未发生异常时将会执行的下一条指令</li>
<li>终止程序</li>
</ul>
</li>
</ul>
<h3 id="（1）异常的分类"><a href="#（1）异常的分类" class="headerlink" title="（1）异常的分类"></a>（1）异常的分类</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031334140.png" alt="image-20240403133440480"></p>
<ul>
<li><p>中断（异步，即由处理器，即<strong>CPU外部</strong>的I&#x2F;O设备产生的）	</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031340026.png" alt="image-20240403134055559"></p>
</li>
<li><p>陷阱（同步）</p>
<ul>
<li>故意触发异常，是执行一条指令的结果，为用户程序和操作系统内核之间提供一个类似函数的接口</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031343706.png" alt="image-20240403134303996"></p>
</li>
<li><p>故障（同步）</p>
<ul>
<li>由错误情况引起，故障处理程序会尝试修复</li>
<li>经典示例：缺页异常</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031344402.png" alt="image-20240403134407074"></p>
</li>
<li><p>终止（同步）</p>
<ul>
<li>由不可恢复的致命错误导致</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031345806.png" alt="image-20240403134503470"></p>
</li>
</ul>
<h3 id="（2）x86-64系统中的异常"><a href="#（2）x86-64系统中的异常" class="headerlink" title="（2）x86-64系统中的异常"></a>（2）x86-64系统中的异常</h3><p>共定义256种异常，其中编号0-31所对应的异常由Intel的架构师定义，因此对于任意的x86-64系统都是一样的。编号32-255所对应的异常由操作系统定义。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031346638.png" alt="image-20240403134638369"></p>
<h2 id="3、进程"><a href="#3、进程" class="headerlink" title="3、进程"></a>3、进程</h2><p>进程即一个正在执行的程序实例。</p>
<h3 id="（1）逻辑控制流"><a href="#（1）逻辑控制流" class="headerlink" title="（1）逻辑控制流"></a>（1）逻辑控制流</h3><p>当使用调试器来控制程序单步执行时，会得到一系列的程序计数器的数值，这些数值与可执行程序中的指令一一对应。把这个<strong>PC值的序列</strong>叫做<strong>逻辑控制流</strong>，简称逻辑流。</p>
<ul>
<li>区分并发和并行：<ul>
<li><strong>并发</strong>：并发指的是，在<strong>同一个处理器核</strong>上，多个任务<strong>同一时间段内交替地执行</strong>，它们共享系统资源</li>
<li><strong>并行</strong>：两个进程<strong>在不同的处理器核上同时运行</strong></li>
</ul>
</li>
</ul>
<h3 id="（2）用户态和内核态"><a href="#（2）用户态和内核态" class="headerlink" title="（2）用户态和内核态"></a>（2）用户态和内核态</h3><p>为了限制应用程序执行某些特殊的指令以及限制可以访问的地址空间范围，通常处理器通过<strong>控制寄存器（Control Register）的模式位</strong>实现这些限制功能。</p>
<ul>
<li><p>控制寄存器：描述进程当前的权限</p>
</li>
<li><p><strong>用户程序可以通过系统调用来间接地访问内核的代码和数据</strong></p>
</li>
<li><p>从User Mode到Kernel Mode：中断&#x2F;故障&#x2F;系统调用</p>
</li>
<li><p>上下文（Context）</p>
<ul>
<li><p><strong>内核为每个进程维持了一个上下文</strong>，是内核重启一个被抢占的进程所需的状态，状态包括如下：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032014836.png" alt="image-20240403201459671" style="zoom: 67%;" />
</li>
<li><p>内核调度进程时使用上下文切换的机制将控制转移到新的进程，分为以下三步：</p>
<ul>
<li>保存当前进程的上下文；</li>
<li>恢复某个先前被抢占进程的上下文；</li>
<li>将控制传递给这个新恢复的进程。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（3）进程的创建"><a href="#（3）进程的创建" class="headerlink" title="（3）进程的创建"></a>（3）进程的创建</h3><ul>
<li><p>进程的状态：运行、暂停、终止</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032028003.png" alt="image-20240403202844940" style="zoom:50%;" /></li>
</ul>
<h2 id="4、进程相关函数"><a href="#4、进程相关函数" class="headerlink" title="4、进程相关函数"></a>4、进程相关函数</h2><h3 id="（1）fork函数"><a href="#（1）fork函数" class="headerlink" title="（1）fork函数"></a>（1）fork函数</h3><p>调用该函数会返回两次：1）返回到父进程；2）返回到创建的子进程。<strong>父子进程各有一份副本，不同的进程有各自的栈（即各自的地址空间）。父子进程并发执行。</strong>以下图为例，父子进程有各自的x。</p>
<ul>
<li><p>父进程中fork的返回值是<strong>子进程的PID</strong>；</p>
</li>
<li><p>子进程中fork的返回值是<strong>0</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032031897.png" alt="image-20240403203131780"></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032050294.png" alt="image-20240403205019101"></p>
<h3 id="（2）execve-waitpid函数"><a href="#（2）execve-waitpid函数" class="headerlink" title="（2）execve&#x2F;waitpid函数"></a>（2）execve&#x2F;waitpid函数</h3><ul>
<li><p>execve函数</p>
<ul>
<li><code>*argv[]</code>：参数列表</li>
<li><code>*envp[]</code>：环境变量列表，包括当前的工作目录PWD、用户名等信息</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032052443.png" alt="image-20240403205217368" style="zoom: 67%;" />

<ul>
<li>作用：调用加载器，在执行可执行程序的main函数之前，启动代码需要设置的用户栈，并将控制传递给新程序的主函数。</li>
</ul>
</li>
<li><p>waitpid函数</p>
<ul>
<li><p>僵尸进程(<code>zombie</code>)：一个终止运行但是还未被父进程回收的进程。</p>
<blockquote>
<p>在大多数情况下，僵尸进程的大部分内存资源都会被回收，因为进程的地址空间、堆栈和数据段等资源都会在进程终止时由操作系统回收。但是，还有一些资源可能没有被完全回收：</p>
<ol>
<li><strong>进程描述符（Process Descriptor）：</strong> 操作系统仍然会保留僵尸进程的进程描述符，其中包含了一些关于进程的信息，比如进程 ID、父进程 ID、状态等。这些信息可以被父进程使用 <code>wait()</code> 或 <code>waitpid()</code> 函数来获取。</li>
<li><strong>进程表项（Process Table Entry）：</strong> 操作系统的进程表中仍然会保留僵尸进程的表项，这是因为操作系统需要跟踪所有进程的状态信息。</li>
</ol>
</blockquote>
</li>
<li><p>但父进程需要获取子进程的某些信息时，通过**waitpid()**等待它的子进程终止或者停止。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032103323.png" alt="image-20240403210325217"></p>
<ul>
<li>（1）pid &gt; 0<ul>
<li>表示等待的进程是一个单独的子进程，那么该子进程的ID即为该pid的值</li>
</ul>
</li>
<li>（2）pid &#x3D; -1<ul>
<li>表示等待的进程是由父进程创建的所有进程组成的集合</li>
</ul>
</li>
<li>status中存放导致返回的子进程的状态信息，用<code>statusp</code>指向</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032110406.png" alt="image-20240403211011042"></p>
</li>
</ul>
<h2 id="5、Linux信号"><a href="#5、Linux信号" class="headerlink" title="5、Linux信号"></a>5、Linux信号</h2><p>信号是软件形式的异常。</p>
<ul>
<li>进程组：默认情况下，父子进程属于一个进程组。可通过<code>setpgrp()</code>修改进程组。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>多态与虚函数</title>
    <url>/2024/04/24/1%20C++/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241537916.png" alt="1_面向对象高级编程_Part2_32"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241537211.png" alt="1_面向对象高级编程_Part2_33"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241538877.png" alt="1_面向对象高级编程_Part2_34"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241538329.png" alt="1_面向对象高级编程_Part2_35"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241538101.png" alt="1_面向对象高级编程_Part2_36"></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>继承与多态</category>
      </categories>
  </entry>
  <entry>
    <title>Ch9 虚拟内存</title>
    <url>/2024/04/03/3%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CSAPP/CSAPP_Ch9%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Ch9-虚拟内存"><a href="#Ch9-虚拟内存" class="headerlink" title="Ch9 虚拟内存"></a>Ch9 虚拟内存</h1><p>计算机系统三大件：CPU&#x2F;内存&#x2F;Disk</p>
<h2 id="1、虚拟内存"><a href="#1、虚拟内存" class="headerlink" title="1、虚拟内存"></a>1、虚拟内存</h2><p>“虚拟”这两个字究竟指的是什么？</p>
<h3 id="（1）两种寻址方法"><a href="#（1）两种寻址方法" class="headerlink" title="（1）两种寻址方法"></a>（1）两种寻址方法</h3><ul>
<li><p>物理地址</p>
<ul>
<li><p>将内存看作一个非常大的数组，将地址看作下标。</p>
</li>
<li><p>CPU访问时通过总线将物理地址发给内存控制器，取出具体的数据并返回给CPU。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032355663.png" alt="image-20240403235534488" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>虚拟寻址</p>
<ul>
<li><p>在CPU和内存中加入MMU（Memory Management Unit），通过MMU将物理地址转换为虚拟地址</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032355710.png" alt="image-20240403235558629"></p>
</li>
</ul>
</li>
</ul>
<h3 id="（2）虚拟内存"><a href="#（2）虚拟内存" class="headerlink" title="（2）虚拟内存"></a>（2）虚拟内存</h3><ul>
<li><p><strong>地址空间</strong></p>
<ul>
<li><p>虚拟地址空间：用于存放进程运行时所需的代码、数据和堆栈等信息</p>
</li>
<li><p>如下图所示，<strong>8位</strong>的虚拟地址位数可以表示<strong>2^8个</strong>虚拟地址</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040006809.png" alt="image-20240404000647696"></p>
</li>
<li><p>物理地址空间</p>
</li>
</ul>
</li>
<li><p>CPU-Cache-内存-Disk</p>
</li>
<li><p>如下图所示的Virtual Pages，共N个字节，每个字节成为一个页（Page），每个页约为4KB-2MB。<strong>页是内存和磁盘间数据交换的单位。在虚拟内存中，数据通常被分割成称为页面（Page）或者页面帧（Page Frame）的固定大小的块，这些页面可以存储在物理内存中，也可以存储在磁盘上。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040017251.png" alt="image-20240404001727055"></p>
</li>
<li><p>虚拟内存中页的状态：</p>
<ul>
<li><p><code>Unallocated</code>：未分配数据，不占用磁盘空间；当调用<code>malloc()</code>函数时会用到这些未分配的页</p>
<blockquote>
<p><strong>malloc()分配的内存在堆上，为什么会分配一个虚拟页呢？</strong></p>
</blockquote>
</li>
<li><p><code>Cached</code>：该页的数据已经缓存到物理内存中，访问时CPU直接访问内存即可</p>
</li>
<li><p><code>UnCached</code>：已分配数据，但仍未缓存到物理内存中</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040020594.png" alt="image-20240404002021516"></p>
</li>
<li><p><strong>区分SRAM缓存和DRAM缓存</strong></p>
<ul>
<li>其中DRAM执行的是<strong>写回策略</strong>而非写穿透策略</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040022266.png" alt="image-20240404002223222" style="zoom:50%;" /></li>
</ul>
<h3 id="（3）页表"><a href="#（3）页表" class="headerlink" title="（3）页表"></a>（3）页表</h3><ul>
<li><p><strong>页表中的每一项页表项</strong>与<strong>虚拟内存中的每一页</strong>是一一对应的</p>
</li>
<li><p>MMU使用页表做虚拟地址到物理地址的映射</p>
</li>
<li><p><strong>页命中</strong>：要访问的目的数据页已经缓存到物理内存中</p>
<ul>
<li>若未命中，会触发缺页故障&#x2F;缺页异常，异常处理程序将页加载到物理内存中</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040029732.png" alt="image-20240404002955643" style="zoom:67%;" /></li>
</ul>
<h2 id="2、地址翻译"><a href="#2、地址翻译" class="headerlink" title="2、地址翻译"></a>2、地址翻译</h2><p><strong>地址翻译即为：将虚拟地址映射到真实物理地址</strong></p>
<ul>
<li>虚拟地址（VA） &#x3D; 虚拟页号（VPN）+ 虚拟页偏移量（VPO）<ul>
<li>虚拟页号：虚拟地址中用来索引页表的部分，<strong>表示了虚拟页在页表中的索引位置，用于确定对应的物理页框</strong></li>
<li>虚拟页偏移量：虚拟地址中用于表示页内偏移的部分，<strong>表示了虚拟页内的地址偏移量，用于在物理页框中定位具体的数据</strong>；每个页通常为<strong>4KB(&#x3D;4096Byte&#x3D;2^12，即12位)</strong></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040038957.png" alt="image-20240404003849872"></p>
<ul>
<li><p><strong>页命中的情况</strong></p>
<ul>
<li>VA：虚拟地址 &#x2F; PA：物理地址</li>
<li>PTEA：页表项地址 &#x2F; PTE：页表项</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040053564.png" alt="image-20240404005347498"></p>
</li>
<li><p><strong>缺页的情况</strong></p>
<ul>
<li>牺牲页（victim page）需要写回磁盘</li>
<li><strong>注意步骤7</strong>：<ul>
<li>步骤7在此处是因为当发现异常并处理完成后，会返回到原来引发异常的那条指令</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040054592.png" alt="image-20240404005427513"></p>
</li>
<li><p><strong>TLB&#x2F;Translation Lookaside Buffer</strong></p>
<ul>
<li>高速缓存，用于存储虚拟地址到物理地址的转换信息。它位于CPU和内存之间，用于加速虚拟地址到物理地址的转换过程。</li>
<li><strong>虚拟页号(VPN) &#x3D; TLBT(TLB Tag) + TLBI(TLB Index)</strong></li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040102671.png" alt="image-20240404010233622" style="zoom: 67%;" />
</li>
<li><p><strong>TLB Hit</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040106432.png" alt="image-20240404010601364"></p>
</li>
<li><p><strong>TLB Miss</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040106189.png" alt="image-20240404010620118"></p>
</li>
<li><p>多级页表</p>
<ul>
<li><p>多级页表（Multi-level Page Tables）是一种用于管理大型虚拟内存空间的技术，它将整个虚拟地址空间分割成多个级别的页表，从而降低了页表的大小和访问时间。</p>
</li>
<li><p>下图是一个<strong>2级页表</strong>的示例。其中2级页表才指向真正的虚拟页的地址。 </p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041446551.png" alt="image-20240404144628382"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041508429.png" alt="image-20240404150817364"></p>
</li>
</ul>
</li>
</ul>
<h2 id="3、Inter-Core-i7"><a href="#3、Inter-Core-i7" class="headerlink" title="3、Inter Core i7"></a>3、Inter Core i7</h2><h3 id="（1）Cache-Hierarchy"><a href="#（1）Cache-Hierarchy" class="headerlink" title="（1）Cache Hierarchy"></a>（1）Cache Hierarchy</h3><ul>
<li>共4个Core(核心)，每个Core有自己的L1 d-cache(数据cache)、L1 i-cache(指令cache)和L2 cache</li>
<li>4个Core共享L3 cache</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041509298.png" alt="image-20240404150908225"></p>
<ul>
<li><p>单个Core中的结构（包含TLB）</p>
<ul>
<li><strong>L2 unified TLB直接连到了DDR3 memory controller上，访问内存</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041511470.png" alt="image-20240404151102359"></p>
</li>
</ul>
<h3 id="（2）i7中如何进行地址翻译"><a href="#（2）i7中如何进行地址翻译" class="headerlink" title="（2）i7中如何进行地址翻译"></a>（2）i7中如何进行地址翻译</h3><ul>
<li><p>CPU发出一个虚拟地址去访存（-48位）</p>
<ul>
<li><p><strong>VPN</strong>(&#x3D;TLBT(-32位)+TLBI(-4位))：-36位； <strong>VPO</strong>：-12位(&#x3D;2^12&#x3D;4096B&#x3D;4KB)</p>
</li>
<li><p>根据TLBI查询相应的Set</p>
</li>
<li><p>组成52位的物理地址</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041536104.png" alt="image-20240404153626039"></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041535284.png" alt="image-20240404153537221"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041537071.png" alt="image-20240404153719985"></p>
</li>
</ul>
<h3 id="（3）Page-Memory-Area（段-Segment）"><a href="#（3）Page-Memory-Area（段-Segment）" class="headerlink" title="（3）Page Memory Area（段&#x2F;Segment）"></a>（3）Page Memory Area（段&#x2F;Segment）</h3><blockquote>
<ol>
<li><strong>进程私有部分（Process Private Memory）：</strong> 每个进程拥有自己独立的虚拟内存空间，包括代码、数据、堆、栈等部分。这些内存区域是进程私有的，不同进程之间互不干扰。当进程被创建时，操作系统会为其分配一定的虚拟地址空间，进程可以在这个地址空间中进行内存操作。</li>
<li><strong>内核部分（Kernel Space）：</strong> 所有进程共享一份内核虚拟内存空间，其中包含了操作系统的内核代码和数据。这部分内存空间被所有进程共享，用于执行操作系统提供的系统调用、管理硬件资源等操作。进程无法直接访问内核空间，需要通过系统调用等方式请求操作系统执行相应的操作。</li>
</ol>
<p>总之，每个进程都有自己独立的虚拟内存空间，但所有进程共享一份内核虚拟内存空间。这种设计既保证了进程间的隔离和安全性，又能够高效地共享操作系统提供的资源和功能。</p>
</blockquote>
<ul>
<li>pdg——page global directory</li>
<li>mmap——结构体<ul>
<li>vm_start-vm_end——该段的起始地址到结束地址，如：共享库&#x2F;Data<ul>
<li>若在这个vm_area_struct中找不到合法的起始地址，将报错<code>segment fault</code></li>
</ul>
</li>
<li>vm_prot——protect 段的权限信息<ul>
<li>若找到了对应的地址，但和段的当前权限不匹配，如需要写，但该段仅可读，也会报错</li>
</ul>
</li>
<li>vm_flags——段的某些属性</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041539849.png" alt="image-20240404153947715"></p>
<h2 id="4、内存映射"><a href="#4、内存映射" class="headerlink" title="4、内存映射"></a>4、内存映射</h2><p>通俗来讲，内存映射（Memory Mapping）是指要把段（Virtual Memory Area）上的内容（比如共享库、数据、代码等）与磁盘中的页关联起来。也即是将磁盘上的页加载到内存中的过程。</p>
<blockquote>
<p>内存映射是一种操作系统的内存管理技术，它允许将文件或其他设备映射到进程的虚拟地址空间，使得进程可以通过内存访问的方式来操作文件或设备。</p>
<p>在内存映射中，操作系统会在进程的虚拟地址空间中创建一个映射区域（Memory-mapped region），将文件的内容或设备的数据映射到这个区域中。进程可以像访问内存一样对这个映射区域进行读写操作，而不需要显式地进行文件的读写或设备的输入输出。</p>
</blockquote>
<p>对于如下图所示的ELF（Executable and Linkable Format）文件，将磁盘中的数据按照4KB的大小抽象成一页一页的虚拟页，映射到相应的虚拟地址空间中。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042220837.png" alt="image-20240404222055630"></p>
<p>这个过程也就是下图所示的<code>Loaded from the executable file</code>，<strong>这个过程只是做了一个映射，而并没有把实际的代码&#x2F;数据等写入真实物理内存。真正执行这一步是依靠缺页处理程序来实现的。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042221907.png" alt="image-20240404222120839"></p>
<p><strong>这里有个问题，那就是针对下图，对于代码段、数据段以及共享库段等，ELF文件（磁盘上）是有对应的数据对其进行映射的，但对于其他的部分，诸如用户栈、堆等，是没有可以与之映射的。</strong></p>
<ul>
<li>解决方法是将栈和堆映射到一个<strong>匿名文件（由内核创建）</strong>，也叫<strong>请求二进制（demand-zero）</strong>，其存储的全是二进制的0。当需要使用堆中的数据时（如malloc()），内核就去物理页中找一个页，用二进制0做覆盖并更新页表。</li>
</ul>
<p>也就是说：<strong>操作系统用匿名文件来映射栈和堆区域。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042226192.png" alt="image-20240404222601119"></p>
<ul>
<li><p>对于进程间的<strong>共享对象</strong>（如libc.so），不需要再复制一份到内存中，<strong>只需多个进程映射到一个相同的物理地址空间即可</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042234474.png" alt="image-20240404223431408"></p>
</li>
<li><p>对于<strong>私有对象</strong>，采用<code>copy-on-write</code>的策略</p>
<ul>
<li>在读数据时，和共享对象的映射策略一致；</li>
<li>一旦某个进程触发了一个写操作，则在写时需要<strong>先将其复制到内存上再进行修改</strong>，如下图2</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042235045.png" alt="image-20240404223543989"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042237697.png" alt="image-20240404223756633"> </p>
</li>
<li><p>用户级的内存映射函数：<code>mmap()</code></p>
<ul>
<li><code>*start</code>：一般为null，是由内核选择的虚拟地址空间的起始位置</li>
<li><code>length</code>：要映射的长度</li>
<li><code>prot</code>：权限问题</li>
<li><code>fd(file discriptor)</code></li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042303799.png" alt="image-20240404230341734" style="zoom: 50%;" /></li>
</ul>
<h2 id="5、动态内存分配"><a href="#5、动态内存分配" class="headerlink" title="5、动态内存分配"></a>5、动态内存分配</h2><p>示例：<code>array = (int *)malloc(n * sizeof(int));</code>其中malloc()申请到的地址空间位于堆中。</p>
<p><code>brk</code>指针指向堆的最底端，<strong>堆的生长空间是从低地址到高地址</strong>，与之相区别的，<strong>栈的生长空间是从高地址到低地址</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404050001970.png" alt="image-20240405000133888" style="zoom:50%;" />

<ul>
<li><p><strong><code>malloc()</code>的地址返回需要对齐，32位要求为8的倍数，64位要求为16的倍数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> incr)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Allocator动态分配时的要求</p>
<ul>
<li>处理任意请求序列</li>
<li>立即响应请求</li>
<li>只使用堆</li>
<li>对齐块</li>
<li>不修改已分配的块</li>
</ul>
</li>
<li><p>Allocator动态分配时的目标</p>
<ul>
<li>最大化吞吐率</li>
<li>最大化内存利用率<ul>
<li>存在<strong>内部碎片（internal fragmentation）</strong>和<strong>外部碎片（external fragmentation）</strong><ul>
<li><strong>内部碎片：</strong> 当一个分配的内存块的实际大小大于请求的大小时，产生了内部碎片，分配的内存块中存在的一部分空闲的空间</li>
<li><strong>外部碎片：</strong> 外部碎片是指由于连续的空闲内存块分散在内存中，导致无法满足一个新的内存分配请求。即使系统总的空闲内存足够大，但由于空闲内存块分布不连续，导致无法找到一个足够大的连续空间来满足新的内存分配请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用malloc()申请到的一块内存的数据结构：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404050020437.png" alt="image-20240405002017373"></p>
<ul>
<li><p>Header：头部信息，用户成员无法访问该信息</p>
<ul>
<li><p>29个bit表示整个Header的大小</p>
</li>
<li><p>0-2位仅0位上有有效信息，表明该块是否被分配</p>
</li>
<li><p>这里用29位表示大小，而留下了最后3位，是由于内存对齐的要求下，要求大小为8的倍数，因此对于任意8的倍数的二进制表示，其最低三位都为0</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404050026188.png" alt="image-20240405002607101"  /></li>
</ul>
</li>
<li><p>Payload：有效载荷，即实际存放的数据，其大小为请求的内存空间大小</p>
</li>
<li><p>Padding：用于内存对齐，用户成员无法访问该信息</p>
</li>
</ul>
</li>
<li><p>隐式空闲链表（Implicit Free List）</p>
<ul>
<li>隐式空闲链表是动态内存分配中一种常见的内存管理数据结构，用于管理堆中的空闲内存块。在隐式空闲链表中，空闲的内存块不是显式地维护在一个链表中，而是通过在堆中连续的空闲内存块之间插入一个特殊的标记来隐式地表示空闲空间的位置和大小</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404050028163.png" alt="image-20240405002833100"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>运行时类型识别 RTTI</title>
    <url>/2024/07/16/1%20C++/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB%20RTTI/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="1、运行时类型识别-RTTI"><a href="#1、运行时类型识别-RTTI" class="headerlink" title="1、运行时类型识别 RTTI"></a>1、运行时类型识别 RTTI</h2><p>C++ 的 RTTI（Run-Time Type Information）是一种运行时类型信息机制，用于在程序运行时获取对象的类型信息。每个具有多态性的类（包括虚函数或虚基类）都会生成一个类型信息对象（Type Information Object），其中包含了有关该类的类型信息，例如类的名称、继承关系、虚函数表等。这些类型信息对象在编译时生成，并与每个类的对象关联起来。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407161554569.webp" alt="img"></p>
<p>RTTI 主要包括两个关键字：typeid 和 dynamic_cast。</p>
<ul>
<li>typeid 运算符，用于返回表达式的类型。  </li>
<li>dynamic_cast 运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。</li>
</ul>
<p>一般来说<strong>动态类型指的是某个基类指针或引用指向一个派生类对象，且基类中有虚函数，此时会绑定对象的动态类型。</strong></p>
<h2 id="2、dynamic-cast"><a href="#2、dynamic-cast" class="headerlink" title="2、dynamic_cast"></a>2、dynamic_cast</h2><p><code>dynamic_cast</code> 可以将指向基类的指针或引用转换为指向派生类的指针或引用，同时会进行类型检查，确保类型转换的安全性。</p>
<p>基本用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dynamic_cast</span>&lt;type*&gt;(e)   <span class="comment">// e必须是有效的指针</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&gt;(e)   <span class="comment">// e必须是个左值</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e)  <span class="comment">// e不能是左值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rtti/dynamic_cast.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> _i) : <span class="built_in">i</span>(_i) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive</span>(<span class="type">int</span> i) : <span class="built_in">Base</span>(i) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一种情况，Base指针指向Derive对象，可以将Base指针转为Derive指针</span></span><br><span class="line">    <span class="function">Derive <span class="title">derive</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    Base *bp = &amp;derive;</span><br><span class="line">    <span class="keyword">if</span> (Derive *dp = <span class="built_in">dynamic_cast</span>&lt;Derive*&gt;(bp)) &#123; <span class="comment">// 可以成功转型</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;dynamic cast succeed~ &quot;</span>;</span><br><span class="line">        dp-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;dynamic cast failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种情况，Base指针指向Base对象，不能将Base指针转为Derive指针</span></span><br><span class="line">    <span class="function">Base <span class="title">base</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">    bp = &amp;base;</span><br><span class="line">    <span class="keyword">if</span> (Derive *dp = <span class="built_in">dynamic_cast</span>&lt;Derive*&gt;(bp)) &#123; <span class="comment">// 转型失败</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;dynamic cast succeed~ &quot;</span>;</span><br><span class="line">        dp-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;dynamic cast failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种情况，Derive指针指向Derive对象，可以将Derive指针转为Base指针</span></span><br><span class="line">    Derive *dp = <span class="keyword">new</span> <span class="built_in">Derive</span>(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">if</span> (Base *bp = <span class="built_in">dynamic_cast</span>&lt;Base*&gt;(dp)) &#123; <span class="comment">// 转型成功</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;dynamic cast succeed~ &quot;</span>;</span><br><span class="line">        bp-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;dynamic cast failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下代码不能运行，不能将Derive指针指向Base对象</span></span><br><span class="line">    <span class="comment">// Derive *dp = new Base(20);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$ g++ dynamic_cast.cpp &amp;&amp; ./a.out</span></span><br><span class="line"><span class="comment">dynamic cast succeed~  i = 10</span></span><br><span class="line"><span class="comment">dynamic cast failed!</span></span><br><span class="line"><span class="comment">dynamic cast succeed~  i = 15</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>想通过 dynamic_cast 进行动态的转型，基类必须有虚函数；</li>
<li>基类指针必须指向派生类对象，才可以将其转为派生类指针；</li>
<li>指向派生类对象的派生类指针，自然可以转为基类指针； </li>
<li>不能将派生类指针指向基类对象；</li>
</ul>
<blockquote>
<p><strong>什么情况下应该用 dynamic_cast 替代虚函数？</strong></p>
<p>如果我们需要在派生类中增加新的成员函数 f，但又无法取得基类的源代码，因而无法在基类中增加相应的虚函数，这时，可以在派生类中增加非虚成员函数。但这样一来，就无法用基类指针调用函数  f。如果在程序中需要通过基类指针（如使用该继承层次的某个类中所包含的指向基类对象的指针数据成员 p）来调用 f，则必须使用  dynamic_cast 将 p 转换为指向派生类的指针，才能调用 f。</p>
<p><strong>也就是说，如果无法为基类增加虚函数，就可以使用 dynamic_cast 代替虚函数。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived1 show&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived2 show&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived2 specific function f&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_f_if_derived2</span><span class="params">(Base* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Derived2* d2 = <span class="built_in">dynamic_cast</span>&lt;Derived2*&gt;(p)) &#123;</span><br><span class="line">        d2-&gt;<span class="built_in">f</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Not a Derived2 instance&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Base&gt;&gt; objects;</span><br><span class="line">    objects.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;Derived1&gt;());</span><br><span class="line">    objects.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;Derived2&gt;());</span><br><span class="line">    objects.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;Derived1&gt;());</span><br><span class="line">    objects.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;Derived2&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; obj : objects) &#123;</span><br><span class="line">        obj-&gt;<span class="built_in">show</span>();</span><br><span class="line">        <span class="built_in">call_f_if_derived2</span>(obj.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Derived1 show</span></span><br><span class="line"><span class="comment">Not a Derived2 instance</span></span><br><span class="line"><span class="comment">Derived2 show</span></span><br><span class="line"><span class="comment">Derived2 specific function f</span></span><br><span class="line"><span class="comment">Derived1 show</span></span><br><span class="line"><span class="comment">Not a Derived2 instance</span></span><br><span class="line"><span class="comment">Derived2 show</span></span><br><span class="line"><span class="comment">Derived2 specific function f</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="3、typeid-运算符"><a href="#3、typeid-运算符" class="headerlink" title="3、typeid 运算符"></a>3、typeid 运算符</h2><p><code>typeid </code>运算符用于获取表达式的实际类型信息。可以通过 <code>typeid</code> 运算符获取对象的类型信息，也可以获取类型的名称。<code>typeid</code> 运算符返回一个 <code>std::type_info</code> 对象，该对象包含有关类型的信息。可以使用 <code>std::type_info</code> 对象进行类型比较或查询类型的名称。</p>
<ul>
<li>e 可以是任意表达式或类类型；</li>
<li>typeid 返回值是<strong>对一个常量对象的引用</strong>，该对象的类型是标准库类型 type_info 或者 type_info 的公有派生类型；</li>
<li>e 如果是引用，typeid 会返回该引用所引用的对象类型；</li>
<li>typeid 作用在数组上时，返回的是数组类型，而不是指针类型；</li>
<li>运算对象不是类类型，或者不包含虚函数的类，指示的是静态类型；</li>
<li>如果是定义了一个虚函数的类型，typeid 的结果运行时才会求得。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rtti/typeid.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> _i) : <span class="built_in">i</span>(_i) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive</span>(<span class="type">int</span> i) : <span class="built_in">Base</span>(i) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derive *dp = <span class="keyword">new</span> <span class="built_in">Derive</span>(<span class="number">10</span>);</span><br><span class="line">    Base *bp = dp; <span class="comment">// 两个指针都指向Derive对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(*bp) == <span class="built_in">typeid</span>(*dp)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bp和dp指向同一个类型的对象&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(*bp) == <span class="built_in">typeid</span>(Derive)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bp指向的是Derive对象&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$ g++ rtti2.cpp &amp;&amp; ./a.out</span></span><br><span class="line"><span class="comment">bp和dp指向同一个类型的对象</span></span><br><span class="line"><span class="comment">bp指向的是Derive对象</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注： </p>
<ul>
<li>typeid 应该作用于对象，而不是指针本身，因此需要使用 <code>*bp</code> </li>
<li>只有当类型有虚函数的时候，编译器才会在运行时对表达式进行求值； </li>
<li>如果类型没有虚函数，typeid 返回的是静态类型，编译器无须求值也知道表达式的静态类型； </li>
<li>如果指针 p 指向的类型<strong>没有虚函数</strong>，则计算 <code>typeid(*p)</code> 的时候 <code>*p</code> 可以不是一个有效的对象； </li>
<li>如果指针 p 指向的类型<strong>有虚函数</strong>， <code>*p</code> 会在运行时求值，如果 p 是一个空指针，会抛出 bad_typeid 的异常。</li>
</ul>
<h2 id="4、应用举例"><a href="#4、应用举例" class="headerlink" title="4、应用举例"></a>4、应用举例</h2><p>现有一个基类和一个派生类，我们需要为其实现相等运算符。</p>
<p>一种考虑的方法是定义一套虚函数，然后各自在判断是否相等。这样的问题是因为虚函数中基类和派生类必须有相同的形参，如果我们想定义一个虚函数 equal，则该函数的形参必须是基类的引用。此时，equal 函数将只能使用基类的成员，而不能比较派生类独有的成员。</p>
<p>下面是解决方法，<strong>可以利用 typeid 先判断类型是否相同，然后再调用各自版本的 equal 函数</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Base&amp;, <span class="type">const</span> Base&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> _i, <span class="type">int</span> _j) : <span class="built_in">i</span>(_i), <span class="built_in">j</span>(_j) &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">const</span> Base&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive</span>(<span class="type">int</span> _i, <span class="type">int</span> _j, <span class="type">int</span> _k) : <span class="built_in">Base</span>(_i, _j), <span class="built_in">k</span>(_k) &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">const</span> Base&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Base &amp;lhs, <span class="type">const</span> Base &amp;rhs) &#123;</span><br><span class="line">    <span class="comment">// 如果typeid不相等返回false；否则调用equal()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">typeid</span>(lhs) == <span class="built_in">typeid</span>(rhs) &amp;&amp; lhs.<span class="built_in">equal</span>(rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Derive::equal</span><span class="params">(<span class="type">const</span> Base &amp;rhs)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Derive::equal()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 我们清楚这两个类型是相等的，所以转换过程不会抛出异常</span></span><br><span class="line">    Derive r = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derive&amp;&gt;(rhs);</span><br><span class="line">    <span class="comment">// 执行比较两个Derive对象的操作并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;i == r.i &amp;&amp; <span class="keyword">this</span>-&gt;j == r.j &amp;&amp; <span class="keyword">this</span>-&gt;k == r.k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Base::equal</span><span class="params">(<span class="type">const</span> Base &amp;rhs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base::equal()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 执行比较Base对象的操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;i == rhs.i &amp;&amp; <span class="keyword">this</span>-&gt;j == rhs.j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一种情况：两个基类指针进行判断</span></span><br><span class="line">    Base *b1 = <span class="keyword">new</span> <span class="built_in">Base</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    Base *b2 = <span class="keyword">new</span> <span class="built_in">Base</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (*b1 == *b2) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b1和b2相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种情况：一个基类指针和一个派生类指针，都指向派生类对象</span></span><br><span class="line">    Base *b3 = <span class="keyword">new</span> <span class="built_in">Derive</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    Derive *d1 = <span class="keyword">new</span> <span class="built_in">Derive</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (*b3 == *d1) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b3和d1相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b3和d1不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种情况：两个指针分别指向基类对象和派生类对象，他两不能直接判断</span></span><br><span class="line">    Base *b4 = <span class="keyword">new</span> <span class="built_in">Base</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    Derive *d2 = <span class="keyword">new</span> <span class="built_in">Derive</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (*b4 == *d2) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b4和d2相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b4和d2不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@iisayhi:~/Documents/Test_for_Use<span class="comment"># ./test</span></span><br><span class="line">Base::equal()</span><br><span class="line">b1和b2相等</span><br><span class="line">Derive::equal()</span><br><span class="line">b3和d1不相等</span><br><span class="line">b4和d2不相等</span><br></pre></td></tr></table></figure>

<p>可以看出:</p>
<ul>
<li>相同动态类型在判断的时候会调用各自版本的 equal 函数;</li>
<li>而类型不相同的 typeid 判断相等直接返回 false。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>继承与多态</category>
      </categories>
  </entry>
  <entry>
    <title>对含有虚函数的类进行sizeof</title>
    <url>/2024/06/13/1%20C++/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/%E5%AF%B9%E5%90%AB%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E8%BF%9B%E8%A1%8Csizeof/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoMember</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i1;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g3</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h3</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * B3继承空类和B2：</span></span><br><span class="line"><span class="comment"> *  由于本身有数据成员，所以空类的大小并未计算进来；</span></span><br><span class="line"><span class="comment"> *  继承B2的数据成员i1</span></span><br><span class="line"><span class="comment"> * 最终的大小为：4(i2) + 8(vptr) + 4(i1) = 16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B3</span> : <span class="keyword">public</span> NoMember, <span class="keyword">public</span> B2 &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h1</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * B4继承B1和B2：</span></span><br><span class="line"><span class="comment"> *  继承B1的数据成员ch</span></span><br><span class="line"><span class="comment"> *  继承B2的数据成员i1</span></span><br><span class="line"><span class="comment"> * 4(i3) + 8(vptr_B1) + 1(ch) + 4(i1) + 8(vptr_B2) = 25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B4</span> : <span class="keyword">public</span> B1, <span class="keyword">public</span> B2 &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i3;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g2</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h2</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共用虚基类A的虚表指针，内存大小为 4(int) + 8(指向虚基类A的指针) = 12</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfunB</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共用虚基类A的虚表指针，内存大小为 4(int) + 8(指向虚基类A的指针) = 12</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfunC</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于B,C都是虚继承，因此D只包含一个A的副本</span></span><br><span class="line"><span class="comment">// 内存大小为 4(int) + 8(B类中指向虚基类A的指针) + 8(C类中指向虚基类A的指针) = 20</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfunD</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(char b[10]) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="number">10</span>; <span class="comment">// 定义数组大小</span></span><br><span class="line">    std::array&lt;<span class="type">int</span>, n&gt; arr; <span class="comment">// 创建 std::array 对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(std::array&lt;int, &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;&gt;) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::string s1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(std::string s1) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s1) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(Base) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(NoMember) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(NoMember) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B1) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B1) &lt;&lt; std::endl;  <span class="comment">// 9    |   16</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B2) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B2) &lt;&lt; std::endl;  <span class="comment">// 12   |   16</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B3) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B3) &lt;&lt; std::endl;  <span class="comment">// 16   |   16</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B4) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B4) &lt;&lt; std::endl;  <span class="comment">// 25   |   32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(A) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; std::endl;  <span class="comment">// 4</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; std::endl;  <span class="comment">// 12</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(C) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(C) &lt;&lt; std::endl;  <span class="comment">// 12</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(D) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(D) &lt;&lt; std::endl;  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>继承与多态</category>
      </categories>
  </entry>
  <entry>
    <title>cmu15-445 Project 0 (Spring 2023)</title>
    <url>/2024/02/28/6%20%E9%A1%B9%E7%9B%AE/cmu15-445/cmu15-445%20Project%200%20(Spring%202023)%20%20/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Task-1-Copy-On-Write-Trie"><a href="#Task-1-Copy-On-Write-Trie" class="headerlink" title="Task #1 - Copy-On-Write Trie"></a>Task #1 - Copy-On-Write Trie</h1><p>在<code>trie.cpp</code>中实现<code>COW Trie</code>。</p>
<p><code>COW</code>即代表，对<code>Trie</code>的添加&#x2F;删除操作不会在原<code>Trie</code>上进行，而是对原<code>Trie</code>进行拷贝后再进行修改。</p>
<p><code>trie.h</code>中共有三个类：</p>
<ul>
<li>​	<code>TrieNode</code>：表示Trie树不包含value的普通节点。<ul>
<li>组成：<ul>
<li><code>bool is_value_node_&#123;false&#125;;</code></li>
<li><code>std::map&lt;char, std::shared_ptr&lt;const TrieNode&gt;&gt; children_;</code></li>
</ul>
</li>
</ul>
</li>
<li><code>TrieNodeWithValue</code>：<code>Trie</code>树包含<code>value</code>的节点，由<code>TrieNode</code>派生而来。<ul>
<li>新增组成：<ul>
<li><code>std::shared_ptr&lt;T&gt; value_;</code></li>
</ul>
</li>
</ul>
</li>
<li><code>Trie</code>：<code>Trie</code> 树的本体，<ul>
<li>组成：<ul>
<li><code>std::shared_ptr&lt;const TrieNode&gt; root_&#123;nullptr&#125;;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注意：</p>
<p>1、一个 <code>shared_ptr&lt;const TrieNode&gt;</code> 智能指针（<code>root</code>）指向一个 <code>TrieNode</code> 节点，而 <code>TrieNode</code> 节点中的 <code>map</code> 则含有多个可以指向下一个 <code>TrieNode</code> 节点的智能指针。也就是说，当 <code>TrieNode</code> 调用 <code>Clone()</code> 时，会复制一份<strong>当前节点</strong>并返回。由于返回的是 <code>unique_ptr</code>，因此我们只能用 <code>shared_ptr</code> 的构造函数来接收，然后再对 <code>shared_ptr</code> 进行赋值，类似于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;TrieNode&gt; new_root = std::<span class="built_in">shared_ptr</span>&lt;TrieNode&gt;(<span class="keyword">this</span>-&gt;root_-&gt;<span class="built_in">Clone</span>());</span><br></pre></td></tr></table></figure>

<h2 id="1、Get-key"><a href="#1、Get-key" class="headerlink" title="1、Get(key)"></a>1、<code>Get(key)</code></h2><p>（1）考虑<code>key</code>为空的边界情况，此时看<code>root</code>是否是一个<code>TrieNodeWithVal</code>节点；</p>
<p>（2）考虑<code>root</code>为空的边界情况，此时直接返回一个<code>nullptr</code>；</p>
<p>（3）若非上述两种边界情况，则通过遍历进行<code>Get</code>操作：</p>
<ul>
<li>定义一个<code>cur</code>指向当前根节点，注意<code>root</code>的类型是<code>std::shared_ptr&lt;const bustub::TrieNode&gt;</code></li>
<li>对<code>key</code>的所有字符进行遍历，<code>cur</code>不断更新迭代指向<code>cur-&gt;children-&gt;second</code>，直到找到<code>key</code>的键尾为止；</li>
<li>判断此时的<code>cur</code>是否是一个<code>TrieNodeWithVal</code>节点</li>
</ul>
<p>注意：返回的<code>value</code>——<code>std::shared_ptr&lt;T&gt; value_</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> *twnv = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> bustub::TrieNodeWithValue&lt;T&gt; *&gt;(root_.<span class="built_in">get</span>());</span><br><span class="line"><span class="comment">// const确保twnv是一个指向常量对象的指针，最好保留以明确这种限制</span></span><br><span class="line"><span class="comment">// dynamic_cast的目的是为了检查在运行时root_所指向的对象是否实际上是TrieNodeWithValue&lt;T&gt;或其派生类型</span></span><br></pre></td></tr></table></figure>

<h2 id="2、Put-key-value"><a href="#2、Put-key-value" class="headerlink" title="2、Put(key, value)"></a>2、<code>Put(key, value)</code></h2><p><code>Put</code>操作最需要注意的点在于：在插入时，已有的节点执行<code>Clone()</code>操作，新建的节点执行<code>make_shared</code>操作，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/b8962d07c7484d00bdb71214b75ea157.png#pic_center" alt="在这里插入图片描述"></p>
<p>逻辑如下：</p>
<p>（1）考虑<code>key</code>为空的边界情况，此时在<code>root</code>处插入</p>
<ul>
<li>创建新的<code>shared_ptr</code>指针指向<code>value</code>和为空的<code>new_root</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;T&gt; val_p = std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">std::shared_ptr&lt;bustub::TrieNodeWithValue&lt;T&gt;&gt; new_root = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>判断原<code>root</code>是否有子节点，处理后返回新的<code>Trie</code>的根结点<code>new_root</code></p>
<ul>
<li><p>若无，则直接对<code>new_root</code>进行修改；</p>
</li>
<li><p>若有，则构造一个新节点指向<code>root</code>的<code>children</code>，如图</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403011541108.png" alt="image-20240301154103793"></p>
</li>
</ul>
</li>
</ul>
<p>（2）若<code>key</code>非空</p>
<ul>
<li><p>首先拷贝根节点<code>root</code></p>
<ul>
<li>若<code>root</code>空，直接新建空的<code>Trie</code></li>
<li>若<code>root</code>非空，调用<code>Clone()</code>操作，拷贝<code>root</code>的已有<code>children</code>给<code>new_root</code></li>
</ul>
</li>
<li><p><code>Put1()</code>函数递归插入</p>
<ul>
<li><p>遍历<code>new_root</code>的<code>children</code>，找到是否有哪一个<code>children</code>的<code>key</code>等于传入<code>key</code>的<code>key[0]</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pair : new_root-&gt;children_) &#123;&#125;</span><br><span class="line"><span class="comment">// pari类型：std::map&lt;char, std::shared_ptr&lt;const TrieNode&gt;&gt; children</span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断完<code>key[0]</code>后，对<code>key</code>剩余的值进行判断<ul>
<li>若到达<code>key</code>的键尾，新建一个节点并覆盖掉<code>pair</code>的<code>second</code></li>
<li>若未到达键尾，拷贝已有节点、递归调用<code>Put1</code>写入<code>key</code>、将写入完成后的节点重新拷贝给<code>pair.second</code></li>
</ul>
</li>
</ul>
</li>
<li><p>若未找到匹配的<code>key[0]</code>，则直接新建节点插入。注意判断<code>key</code>的长度以决定是否需要递归操作。</p>
</li>
</ul>
</li>
<li><p>返回新的<code>Trie</code></p>
</li>
</ul>
<p>注意：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;bustub::TrieNode&gt; ptr = pair.second-&gt;<span class="built_in">Clone</span>();</span><br><span class="line"><span class="comment">// Clone()返回的对象是std::unique_ptr&lt;TrieNode&gt;类型，为了确保ptr能够在程序的其他地方被共享所有权，因此</span></span><br><span class="line"><span class="comment">// 用std::shared_ptr&lt;bustub::TrieNode&gt;接收</span></span><br></pre></td></tr></table></figure>

<h2 id="3、Remove-key"><a href="#3、Remove-key" class="headerlink" title="3、Remove(key)"></a>3、<code>Remove(key)</code></h2><p><code>Remove</code>的思想和<code>Put</code>一致，不再赘述。</p>
<h1 id="Task-2-Concurrent-Key-Value-Store"><a href="#Task-2-Concurrent-Key-Value-Store" class="headerlink" title="Task #2 - Concurrent Key-Value Store"></a>Task #2 - Concurrent Key-Value Store</h1><p>注意加锁的时机即可。</p>
<p><code>read</code>操作只需要在获取根节点时加锁。</p>
<p><code>write</code>操作则需要全程添加写锁，从而保证只有一名<code>writer</code>。此外，在获取根节点和更新修改后的根结点时，需要添加读锁。</p>
]]></content>
      <categories>
        <category>项目</category>
        <category>cmu15-445</category>
      </categories>
  </entry>
  <entry>
    <title>cmu15-445 Course Related (Spring 2023)</title>
    <url>/2024/03/02/6%20%E9%A1%B9%E7%9B%AE/cmu15-445/cmu15-445%20Course%20Related%20(Spring%202023)/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>PPT</th>
<th>Project</th>
<th>Date</th>
</tr>
</thead>
<tbody><tr>
<td>1-5</td>
<td>P0 &amp; P1</td>
<td>2.26-3.24</td>
</tr>
<tr>
<td>6-9</td>
<td>P2</td>
<td>3.24-</td>
</tr>
<tr>
<td>10-14</td>
<td>P3</td>
<td></td>
</tr>
<tr>
<td>15-21</td>
<td>P4</td>
<td></td>
</tr>
</tbody></table>
<p><code>DBMS</code>的磁盘管理模块主要解决两个问题：</p>
<ul>
<li>如何使用磁盘文件来表示数据库的数据（元数据、索引、数据表等）；</li>
<li>（<code>Buffer Pool</code>）如何管理数据在内存与磁盘之间的移动<ul>
<li>空间控制（<code>Spatio Control</code>）：决定将<code>pages</code>写入磁盘的哪个位置，使得尝尝一起使用的<code>pages</code>能离得更近，提高<code>I/O</code>效率；</li>
<li>时间控制（<code>Temporal Control</code>）：决定何时将<code>pages</code>读入内存，写回磁盘，使得读写的次数最小，从而提高<code>I/O</code>效率。</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p>整体图片：</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-LZUa28zEosfmp4uFA77%2F-LZUJRryGLyHUdcOnhD0%2FScreen%20Shot%202019-02-24%20at%207.43.51%20PM.jpg?alt=media&token=5ca91d06-1e09-43be-afd2-5a52918ad9c9" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242055708.png" alt="image-20240324205507545"></p>
<h1 id="1-Buffer-Pool"><a href="#1-Buffer-Pool" class="headerlink" title="1 Buffer Pool"></a>1 Buffer Pool</h1><h2 id="1-1-Buffer-Pool-Manager"><a href="#1-1-Buffer-Pool-Manager" class="headerlink" title="1.1 Buffer Pool Manager"></a>1.1 Buffer Pool Manager</h2><p><code>DBMS</code>启动时，从<code>OS</code>申请一片<strong>内存区域</strong>，即<code>Buffer Pool</code>，并把这块区域划分成大小相同的<code>pages</code>，通常称为 <code>frames</code>，当<code>DBMS</code>请求一个<code>disk page</code>时，它首先需要被复制到<code>Buffer Pool</code>的一个<code>frame</code>中。</p>
<p><code>Page Table</code>中存储的<code>meta-data</code>包括：</p>
<ul>
<li><p><code>page_table</code>：内存中的哈希表，跟踪当前在内存中的页面；</p>
</li>
<li><p><code>dirty flag</code>：当线程修改页面时设置（需要回写）；</p>
</li>
<li><p><code>pin count</code>：在有线程<strong>读页面</strong>时加<code>1</code>。</p>
</li>
</ul>
<p>当有线程需要**写<code>Page Table</code>**时，需要加一个<code>latch</code>。</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-LZUa28zEosfmp4uFA77%2F-LZUP5rlT7qWNo8qYSuD%2FScreen%20Shot%202019-02-24%20at%208.08.44%20PM.jpg?alt=media&token=f492f425-12b9-47bc-af9a-b4e2430e12bf" alt="img"></p>
<h3 id="locks和latches"><a href="#locks和latches" class="headerlink" title="locks和latches"></a>locks和latches</h3><p><code>Locks</code>（逻辑上的）</p>
<ul>
<li>保护<strong>数据库逻辑内容</strong>免受其他事务的影响</li>
<li>持有直到事务结束</li>
<li><strong>需要支持回滚</strong>（回滚即回到之前的版本状态）</li>
<li>保护元组（行），表，索引</li>
</ul>
<p><code>Latches/Mutex</code>（偏底层的）</p>
<ul>
<li>保护**<code>DBMS</code>内部数据结构**的关键部分不受其他线程的影响</li>
<li>持有直到一个操作结束</li>
<li><strong>不需要支持回滚</strong></li>
</ul>
<h3 id="scan-sharing"><a href="#scan-sharing" class="headerlink" title="scan sharing"></a>scan sharing</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403021705443.png" alt="image-20240302170551246" style="zoom:33%;" />

<p>图中的查询语句可能会导致<code>Q2</code>得不到自己真实想要的结果，需要加上<code>ORDER BY</code>限制才行。</p>
<p>假如有<code>Page0-Page199</code>，<code>scan sharing</code>可能导致：</p>
<ul>
<li><code>Q1</code>-&gt;<code>Page0-Page99</code></li>
<li><code>Q2</code>-&gt;<code>Page40-Page139</code></li>
</ul>
<h3 id="buffer-pool-bypass"><a href="#buffer-pool-bypass" class="headerlink" title="buffer pool bypass"></a>buffer pool bypass</h3><p>只需要调用一次的<code>page</code>，用完后直接丢弃，则可以不放入<code>buffer pool</code>。</p>
<h2 id="1-2-Buffer-Replacement-Policies"><a href="#1-2-Buffer-Replacement-Policies" class="headerlink" title="1.2 Buffer Replacement Policies"></a>1.2 Buffer Replacement Policies</h2><p>当<code>Buffer Pool</code>空间不足时，选择移除其中的哪些<code>pages</code>的问题。</p>
<h3 id="Least-Recently-Used-LRU"><a href="#Least-Recently-Used-LRU" class="headerlink" title="Least-Recently Used(LRU)"></a>Least-Recently Used(LRU)</h3><p><code>LRU</code>维护每个<code>page</code>上一次被访问的时间戳，每次移除时间戳最早的<code>page</code>。</p>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p><code>LRU</code>的近似实现。快速的<code>LRU</code>实现。</p>
<blockquote>
<p>但<code>LRU</code>和<code>Clock</code>容易被<code>sequential flooding</code>现象影响，从而导致最近被访问的<code>page</code>实际上却是最不可能需要的<code>page</code>。<strong>比如在全表扫描时，刚被访问的<code>page</code>实际上再访问完成后就不再需要了，因此反而成为了最不需要的<code>page</code>。</strong></p>
<p>为了解决这个问题，提出了<code>LRU-K</code>策略。</p>
</blockquote>
<h3 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h3><p><code>LRU-K</code>保存每个<code>page</code>的最后<code>K</code>次访问时间戳，利用这些时间戳来估计它们下次被访问的时间，通常<code>K</code>取<code>1</code>就能获得很好的效果。</p>
<p><strong>时间局部性原理：程序最近访问的地址在不久的将来很可能再次被访问。</strong></p>
<p><code>K</code>指的是最后第<code>K</code>次访问的距离，也就是倒数第<code>K</code>次访问时和最近一次访问的时间差。<code>LRU-K</code>算法主要是对比最后第<code>K</code>次的访问距离，访问距离越大则代表每次的访问间隔越长，因此更容易被替换出<code>cahce</code>。</p>
<ul>
<li><code>Correlated References Period</code>：指的是块首次访问后的一段时间。在这段时间以内的多次访问不会被记录，只有这段时间过后再次访问才会被记录。</li>
<li><code>Reference Retained Information Period</code>：指的是块被替换出<code>cache</code>后的一段时间。为了避免块被替换出<code>cache</code>后短时间内被反复重新访问、替换，因此对于替换出<code>cache</code>后的块会继续保留访问信息一段时间。</li>
</ul>
<h3 id="Dirty-Page"><a href="#Dirty-Page" class="headerlink" title="Dirty Page"></a>Dirty Page</h3><p><code>Dirty</code>：内存中的<code>page</code>和磁盘中的<code>page</code>有差别。</p>
<ul>
<li><p><code>FAST</code>：如果缓冲池中的页面不脏，那么<code>DBMS</code>可以简单地“删除”它；</p>
</li>
<li><p><code>SLOW</code>：如果页面是脏的，则<code>DBMS</code>必须写回磁盘以确保其更改是持久的。</p>
</li>
</ul>
<p><a href="https://www.jianshu.com/p/f242bc1e95ff">MySQL的WAL（Write-Ahead Logging）机制</a></p>
<h2 id="1-3-Other-Memory-Pools"><a href="#1-3-Other-Memory-Pools" class="headerlink" title="1.3 Other Memory Pools"></a>1.3 Other Memory Pools</h2><p>除了存储<code>tuples</code>和<code>indexes</code>，<code>DBMS</code>还需要<code>Memory Pools</code>来存储其它数据：</p>
<ul>
<li><code>Sorting + Join Buffers</code></li>
<li><code>Query Caches</code></li>
<li><code>Maintenance Buffers</code></li>
<li><code>Log Buffers</code></li>
<li><code>Dictionary Caches</code></li>
</ul>
<h1 id="2-B-Tree-Index"><a href="#2-B-Tree-Index" class="headerlink" title="2 B+Tree Index"></a>2 B+Tree Index</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271651204.png" alt="image-20240327165111130"></p>
<h2 id="2-1-Hash-Tables"><a href="#2-1-Hash-Tables" class="headerlink" title="2.1 Hash Tables"></a>2.1 Hash Tables</h2><h3 id="2-1-1-Hash-Functions"><a href="#2-1-1-Hash-Functions" class="headerlink" title="2.1.1 Hash Functions"></a>2.1.1 Hash Functions</h3><p>由于<code>DBMS</code>内使用的<code>Hash Function</code>并不会暴露在外，因此<strong>没必要使用加密（<code>cryptographic</code>）哈希函数</strong>，我们希望它速度越快，<code>collision rate</code>越低越好。</p>
<p>目前各 DBMS 主要在用的 Hash Functions 包括：</p>
<ul>
<li><a href="https://github.com/aappleby/smhasher">MurmurHash (2008)</a></li>
<li><a href="https://github.com/google/cityhash">Google CityHash (2011)</a></li>
<li><a href="https://github.com/google/farmhash">Google FarmHash (2014)</a></li>
<li><a href="https://github.com/lemire/clhash">CLHash (2016)</a></li>
</ul>
<h4 id="SHA256算法"><a href="#SHA256算法" class="headerlink" title="SHA256算法"></a>SHA256算法</h4><h3 id="2-1-2-Static-Hashing-Scheme"><a href="#2-1-2-Static-Hashing-Scheme" class="headerlink" title="2.1.2 Static Hashing Scheme"></a>2.1.2 Static Hashing Scheme</h3><p>（1）Linear Probe Hashing 开放地址哈希</p>
<p>“开放”的意思就是说：对于所有的key来说地址是开放的。碰撞时则往下一个地址存。</p>
<p>在删除时可能会因为前项被删除导致的空白，造成找不到当前项，这时有两个解决思路：</p>
<ul>
<li>Tombstone；</li>
<li>Movement</li>
</ul>
<p>重复key出现时的解决思路：</p>
<ul>
<li>Separate Linked List，把当前key作为指针指向一个新的区域：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242120365.png" alt="image-20240324212003301"></p>
<ul>
<li>Redundant Keys，把key和value拼在一起作为新的key：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242120828.png" alt="image-20240324212049757"></p>
<p>（2）Robin Hood Hashing，是开放地址哈希的变种，其基本思想是“劫富济贫”。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242123712.png" alt="image-20240324212329536"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242123232.png" alt="image-20240324212342001"></p>
<p>简单来说就是，当E和A碰撞时，正常E偏移3位，但为了不让自己比D“惨”太多，它就把D推到后面去，自己占了D的位置。此时D和E均为2。</p>
<p>（3）Cuckoo Hashing</p>
<blockquote>
<p>静态的哈希结构的问题在于需要DBMS能够预判所存数据的总量，否则每次数量超过范围时都需要重建 Hash Table。这显然是很困难的。</p>
</blockquote>
<h3 id="2-1-3-Dynamic-Hash-Tables"><a href="#2-1-3-Dynamic-Hash-Tables" class="headerlink" title="2.1.3 Dynamic Hash Tables"></a>2.1.3 Dynamic Hash Tables</h3><p>（1）Chained Hashing（※）</p>
<p>每个 key 对应一个链表，每个节点是一个 bucket，装满了就再往后挂一个 bucket。需要写操作时，需要请求 latch。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242129786.png" alt="image-20240324212955629"></p>
<ul>
<li>好处：简单；</li>
<li>坏处：最坏的情况下Hash Table可能降级为链表，操作的时间复杂度降格为 O(n)。</li>
</ul>
<p>（2）Extendible Hashing</p>
<p>Extendible Hashing 的基本思路是一边扩容，一边 rehash。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242134200.png" alt="image-20240324213443953"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242134195.png" alt="image-20240324213451869"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242134845.png" alt="image-20240324213459513"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242135620.png" alt="image-20240324213509210"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242135275.png" alt="image-20240324213516681"></p>
<p>（3）Linear Hashing</p>
<p>基本思想：维护一个指针，指向下一个将被拆分的 bucket，每当任意一个 bucket 溢出（标准自定，如利用率到达阈值等）时，将指针指向的 bucket 拆分。</p>
<h3 id="2-1-4-总结"><a href="#2-1-4-总结" class="headerlink" title="2.1.4 总结"></a>2.1.4 总结</h3><p>Hash Tables 提供 O(1)O(1) 的访问效率，因此它被大量地应用于 DBMS 的内部实现中。即便如此，它并不适合作为 table index 的数据结构，而 table index 的首选就是下节将介绍的 B+ Tree。</p>
<p><strong>哈希表对于范围索引是效率极低的。</strong></p>
<h2 id="2-2-Tree-Indexes（B-索引）"><a href="#2-2-Tree-Indexes（B-索引）" class="headerlink" title="2.2 Tree Indexes（B+索引）"></a>2.2 Tree Indexes（B+索引）</h2><blockquote>
<p>table index 为提供 DBMS 数据查询的快速索引，它本身存储着某表某列排序后的数据，并包含指向相应 tuple 的指针。DBMS 需要保证表信息与索引信息在逻辑上保持同步。用户可以在 DBMS 中为任意表建立多个索引，DBMS 负责选择最优的索引提升查询效率。但索引自身需要占用存储空间，因此在索引数量与索引存储、维护成本之间存在权衡。</p>
</blockquote>
<p>索引本质上就是一种小表，是把大表中的某些列抽取出来。</p>
<h3 id="2-2-1-B-Tree"><a href="#2-2-1-B-Tree" class="headerlink" title="2.2.1 B+ Tree"></a>2.2.1 B+ Tree</h3><p>B+ Tree 是一种自平衡树，它将数据有序地存储，且在 search、sequential access、insertions 以及 deletions 操作的复杂度上都满足 O(logn)，其中 sequential access 的最终复杂度还与所需数据总量有关。</p>
<blockquote>
<p>这里的O(logn)的意义在于，随着数据的增长，操作的复杂度增长是要慢于数据的增长速度的。比如数据增长到原来的2倍，但搜索时间不会变成原来的2倍。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242151303.png" alt="image-20240324215134042"></p>
<h4 id="B-Tree-Nodes"><a href="#B-Tree-Nodes" class="headerlink" title="B+ Tree Nodes"></a>B+ Tree Nodes</h4><p>B+ Tree 中的每个 node 都包含一列按 key 排好序的 key&#x2F;value pairs，key 就是 table index 对应的 column，value 的取值与 node 类型相关，在 inner nodes 和 leaf nodes 中存的内容不同。</p>
<p>values主要有两种存法：</p>
<ul>
<li>Record IDs，存储指向最终 tuple 的指针。</li>
<li>Tuple Data，直接将 tuple data 存在 leaf node 中。key为ID，v为整个行数据。如主键索引，其key为主键，value即为这张表的全部内容。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242154259.png" alt="image-20240324215455186"></p>
<h4 id="B-Tree-Operations"><a href="#B-Tree-Operations" class="headerlink" title="B+ Tree Operations"></a>B+ Tree Operations</h4><p><em>Insert</em></p>
<ol>
<li>找到对应的 leaf node，L</li>
<li>将 key&#x2F;value pair 按顺序插入到 L 中</li>
<li>如果 L 还有足够的空间，操作结束；如果空间不足，则需要将 L 分裂成两个节点，同时在 parent node 上新增 entry，若 parent node 也空间不足，则递归地分裂，直到 root node 为止。</li>
</ol>
<p><em>Delete</em></p>
<ol>
<li>从 root 开始，找到目标 entry 所处的 leaf node, L</li>
<li>删除该 entry</li>
<li>如果 L 仍然至少处于半满状态，则操作结束；否则先尝试从 siblings 那里拆借 entries，如果失败，则将 L 与相应的 sibling 合并</li>
<li>如果合并发生了，则可能需要递归地删除 parent node 中的 entry</li>
</ol>
<h4 id="Clustered-Indexes-聚簇索引"><a href="#Clustered-Indexes-聚簇索引" class="headerlink" title="Clustered Indexes 聚簇索引"></a>Clustered Indexes 聚簇索引</h4><h3 id="2-2-2-B-Tree-Design-Choices"><a href="#2-2-2-B-Tree-Design-Choices" class="headerlink" title="2.2.2 B+ Tree Design Choices"></a>2.2.2 B+ Tree Design Choices</h3><h4 id="Node-Size"><a href="#Node-Size" class="headerlink" title="Node Size"></a>Node Size</h4><p>通常来说，disk 的数据读取速度越慢，node size 就越大：</p>
<table>
<thead>
<tr>
<th>Disk Type</th>
<th>Node Size</th>
</tr>
</thead>
<tbody><tr>
<td>HDD</td>
<td>~1MB</td>
</tr>
<tr>
<td>SSD</td>
<td>~10KB</td>
</tr>
<tr>
<td>In-Memory</td>
<td>~512B</td>
</tr>
</tbody></table>
<p>具体情境下的最优大小由 workload 决定。</p>
<h4 id="Merge-Threshold"><a href="#Merge-Threshold" class="headerlink" title="Merge Threshold"></a>Merge Threshold</h4><p>由于 merge 操作引起的修改较大，有些 DBMS 选择延迟 merge 操作的发生时间，甚至可以利用其它进程来负责周期性地重建 table index。</p>
<h4 id="Variable-Length-Keys"><a href="#Variable-Length-Keys" class="headerlink" title="Variable Length Keys"></a>Variable Length Keys</h4><p>B+ Tree 中存储的 key 经常是变长的，通常有三种手段来应对：</p>
<ul>
<li>Pointers：存储指向 key 的指针；</li>
<li>Variable Length Nodes：需要精细的内存管理操作，不推荐；</li>
<li>Padding：给每个变长的key都强制转成一致的长度；</li>
<li>key Map：内嵌一个指针数组，指向 node 中的 key&#x2F;val list</li>
</ul>
<h4 id="Non-unique-Indexes-变长字段"><a href="#Non-unique-Indexes-变长字段" class="headerlink" title="Non-unique Indexes 变长字段"></a>Non-unique Indexes 变长字段</h4><p>索引针对的 key 可能是非唯一的，通常有两种手段来应对：</p>
<ul>
<li><p>Duplicate Keys：存储多次相同的 key；</p>
</li>
<li><p>Value Lists：每个 key 只出现一次，但同时维护另一个链表，存储 key 对应的多个 values，类似 chained hashing</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251235897.png" alt="image-20240325123534595"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251235251.png" alt="image-20240325123553069"></p>
<h4 id="Intra-node-Search-结点的内部搜素"><a href="#Intra-node-Search-结点的内部搜素" class="headerlink" title="Intra-node Search 结点的内部搜素"></a>Intra-node Search 结点的内部搜素</h4><p>在节点内部搜索，就是在排好序的序列中检索元素，手段通常有：</p>
<ul>
<li>Linear Scan，这种线性扫描虽然似乎很费时，但相比把page从磁盘读到内存的时间来看几乎已经不算什么了；</li>
<li>Binary Search，用二分来优化线性搜索；</li>
<li>Interpolation：通过 keys 的分布统计信息来估计大概位置进行检索</li>
</ul>
<h3 id="2-2-3-Optimizations"><a href="#2-2-3-Optimizations" class="headerlink" title="2.2.3 Optimizations"></a>2.2.3 Optimizations</h3><h4 id="Prefix-Compression"><a href="#Prefix-Compression" class="headerlink" title="Prefix Compression"></a>Prefix Compression</h4><p>同一个 leaf node 中的 keys 通常有相同的 prefix，如下图所示。为了节省空间，可以只存所有 keys 的不同的 suffix。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251240293.png" alt="image-20240325124020194"></p>
<h4 id="Suffix-Truncation"><a href="#Suffix-Truncation" class="headerlink" title="Suffix Truncation"></a>Suffix Truncation</h4><p>由于 inner nodes 只用于引导搜索，因此没有必要在 inner nodes 中储存完整的 key，我们可以<strong>只存储足够的 prefix 即可</strong>，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251241456.png" alt="image-20240325124132291"></p>
<h4 id="Bulk-Insert"><a href="#Bulk-Insert" class="headerlink" title="Bulk Insert"></a>Bulk Insert</h4><p>建 B+ Tree 的最快方式是先将 keys 排好序后，再从下往上建树，如下图所示。因此如果有<strong>大量插入操作</strong>，可以利用这种方式提高效率。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251241413.png" alt="image-20240325124150282"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251242426.png" alt="image-20240325124207283"></p>
<h4 id="Pointer-Swizzling"><a href="#Pointer-Swizzling" class="headerlink" title="Pointer Swizzling"></a>Pointer Swizzling</h4><p>Nodes 使用 page id 来存储其它 nodes 的引用，DBMS 每次需要首先从 page table 中获取对应的内存地址，然后才能获取相应的 nodes 本身，如果 page 已经在 buffer pool 中，我们可以直接存储其它 page 在 buffer pool 中的内存地址作为引用，从而提高访问效率。</p>
<h2 id="2-3-Index-Concurrency-Control"><a href="#2-3-Index-Concurrency-Control" class="headerlink" title="2.3 Index Concurrency Control"></a>2.3 Index Concurrency Control</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251246471.png" alt="image-20240325124646316"></p>
<h3 id="2-3-1-Latch-Modes"><a href="#2-3-1-Latch-Modes" class="headerlink" title="2.3.1 Latch Modes"></a>2.3.1 Latch Modes</h3><h4 id="Read-Mode"><a href="#Read-Mode" class="headerlink" title="Read Mode"></a>Read Mode</h4><ul>
<li>多个线程可以同时读取相同的数据</li>
<li>针对相同的数据，当别的线程已经获得处于 read mode 的 latch，新的线程也可以继续获取 read mode 的 latch</li>
</ul>
<h4 id="Write-Mode"><a href="#Write-Mode" class="headerlink" title="Write Mode"></a>Write Mode</h4><ul>
<li>同一时间只有单个线程可以访问</li>
<li>针对相同的数据，如果获取前已经有别的线程获得任何 mode 的 latch，新的线程就无法获取 write mode  的 latch</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251249774.png" alt="image-20240325124932586"></p>
<p><strong>锁的实现：</strong></p>
<ul>
<li><p>Blocking OS Mutex：如std::mutex，好处是竞争的线程会陷入sleep，但坏处是需要OS去进行唤醒，极度浪费资源；</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251251222.png" alt="image-20240325125111105"></p>
</li>
<li><p>Test-ans-Set Spin Latch(TAS)：自旋锁，如std::atomic<T>，不需要OS操作，自己在死循环内不断旋转，直到可以获取到该锁；</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251253634.png" alt="image-20240325125323436"></p>
</li>
<li><p>Reader-Writer Latches：自旋锁的基础上实现。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251255541.png" alt="image-20240325125549330"></p>
<p>这里注意：若有线程需要加写锁，那么此时如果再有线程希望加读锁也会被阻塞。只有等之前的读锁都释放，写锁成功加上后，后续的读锁才能正常上锁。（这样做是为了避免写锁被无止境地锁住）</p>
</li>
</ul>
<h4 id="hash-table-latching"><a href="#hash-table-latching" class="headerlink" title="hash table latching"></a><strong>hash table latching</strong></h4><p>相较于B+ Tree，Hash Table不容易遇到死锁，尤其是开放地址哈希，因为大家都是朝着一个方向去进行的。一般在扩容（resize）操作时，加一个全局的写锁，因为此时哈希表内部的数据需要进行一个整理。</p>
<ul>
<li>page latches：块与块之间的锁独立。线程会给所有块加分段锁。例如下图，块1的写锁和块2的读锁独立。这样的优势是：1）锁的粒度不会太细；2）支持一定的并发操作。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271610143.png" alt="image-20240327161025853"></p>
<ul>
<li><p>slot latches：以槽为单位进行加锁。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271611923.png" alt="image-20240327161157762"></p>
</li>
<li><p>compare-and-swap，CAS，使得hash table实现无锁插入。例如下图：让os先0判断是否为20，若是再加到30，属于原子操作。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271629958.png" alt="image-20240327162902774"></p>
</li>
</ul>
<h3 id="2-3-2-Index-Crabbing-Coupling"><a href="#2-3-2-Index-Crabbing-Coupling" class="headerlink" title="2.3.2 Index Crabbing&#x2F;Coupling"></a>2.3.2 Index Crabbing&#x2F;Coupling</h3><p>B+Tree考虑两方面的并发问题：</p>
<ul>
<li>1）结点内部的数据，即多个线程同时修改一个node；</li>
<li>2）结点间的合并和分裂操作，即一个线程正在遍历 B+ Tree 的同时，另一个线程正在 splits&#x2F;merges nodes。</li>
</ul>
<p><strong>Latch Crabbing 的基本思想如下：</strong></p>
<ul>
<li>获取 parent 的 latch</li>
<li>获取 child 的 latch</li>
<li>如果<strong>安全</strong>，可以释放 parent 的 latch</li>
</ul>
<p><strong>这里的“安全”指的是，当发生更新操作时，该节点不会发生 split 或 merge 的操作，即：</strong></p>
<ul>
<li>在插入元素时，节点未满</li>
<li>在删除元素时，节点超过半满</li>
</ul>
<p>按照上述方法，无论对叶子结点执行何种操作，第一步都是先锁住根节点，这是一种“悲观”的做法。“乐观”的做法是：一路加读锁，最后加写锁。当然也有可能出现到了最后一步，发现会改动前面的parent，因此需要放弃当前的操作，重新从root开始加写锁。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271638410.png" alt="image-20240327163836210"></p>
<h3 id="2-3-3-Leaf-Scans"><a href="#2-3-3-Leaf-Scans" class="headerlink" title="2.3.3 Leaf Scans"></a>2.3.3 Leaf Scans</h3><p>之前的分析中我们仅仅关注了从上到下的访问模式，而没有考虑到左右方向的访问模式，在 range query 中，常常需要横向访问相邻的 nodes。</p>
<p>当遇到横向扫描无法获取下一个节点的 latch 时，该线程将释放 latch 后自杀。这种策略逻辑简单，尽管有理论上的优化空间，但在实践中是常见的避免死锁的方式。</p>
<h3 id="2-3-4-Delayed-Parent-Updates"><a href="#2-3-4-Delayed-Parent-Updates" class="headerlink" title="2.3.4 Delayed Parent Updates"></a>2.3.4 Delayed Parent Updates</h3><p>从上文中，我们可以观察到：每当 leaf node 溢出时，我们都需要更新至少 3 个节点：</p>
<ul>
<li>即将被拆分的 leaf node</li>
<li>新的 leaf node</li>
<li>parent node</li>
</ul>
<p>修改的成本较高，因此 B-link Tree 提出了一种优化策略：<strong>每当 leaf node 溢出时，只是标记一下而暂时不更新 parent node，等下一次有别的线程获取 parnet node 的 write latch 时，一并修改。</strong></p>
<h2 id="2-4-Sorting-and-Aggregations"><a href="#2-4-Sorting-and-Aggregations" class="headerlink" title="2.4 Sorting and Aggregations"></a>2.4 Sorting and Aggregations</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271648356.png" alt="image-20240327164819130"></p>
<p>一个disk-oriented DBMS不能假定query results和内存大小完全适配。有可能筛选出来的query results也需要存到磁盘中，和buffer pool互相配合来实现操作。需要最大化利用sequential I&#x2F;O。</p>
<p><strong>为什么需要排序：关系型数据库是unsorted的。</strong></p>
<h3 id="2-4-1-Sorting-Algorithm"><a href="#2-4-1-Sorting-Algorithm" class="headerlink" title="2.4.1 Sorting Algorithm"></a>2.4.1 Sorting Algorithm</h3><ul>
<li>early materialization：排序时value直接存储当前key那一行的剩余数据；</li>
<li>later materialization：排序时value存储ID值。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271703469.png" alt="image-20240327170300327"></p>
<h4 id="External-Merge-Sort"><a href="#External-Merge-Sort" class="headerlink" title="External Merge Sort"></a>External Merge Sort</h4><p>外部排序通常有两个步骤：</p>
<p>1、Sorting Phase：将数据分成多个 chunks，每个 chunk 可以完全读入到 memory 中，在 memory 中排好序后再写回到 disk 中</p>
<p>2、Merge Phase：将多个子文件合并成一个大文件</p>
<ul>
<li><p>2-Way External Merge Sort：这里的“2-way”即是指每次读入两页。</p>
</li>
<li><p>General External Merge Sort：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271947535.png" alt="image-20240327194734264"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271949041.png" alt="image-20240327194933847"></p>
</li>
</ul>
<h4 id="Using-B-Tree-for-Sorting"><a href="#Using-B-Tree-for-Sorting" class="headerlink" title="Using B+Tree for Sorting"></a>Using B+Tree for Sorting</h4><p>注意包含聚簇和非聚簇两种情况。</p>
<h3 id="2-4-2-Aggregations"><a href="#2-4-2-Aggregations" class="headerlink" title="2.4.2 Aggregations"></a>2.4.2 Aggregations</h3><h4 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271953093.png" alt="image-20240327195346706"></p>
<p>但很多时候我们并不需要排好序的数据，如：</p>
<ul>
<li>Forming groups in GROUP BY</li>
<li>Removing duplicates in DISTINCT</li>
</ul>
<p>在这样的场景下 hashing 是更好的选择，它能有效减少排序所需的额外工作。</p>
<h4 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h4><p>利用一个临时 (ephemeral) 的 hash table 来记录必要的信息，即检查 hash table 中是否存在已经记录过的元素并作出相应操作：</p>
<ul>
<li>DISTINCT: Discard duplicate</li>
<li>GROUP BY: Perform aggregate computation</li>
</ul>
<p>如果所有信息都能一次性读入内存，那事情就很简单了，但如若不然，我们就得变得更聪明。</p>
<p>hashing aggregation 同样分成两步：</p>
<ul>
<li>Partition Phase: 将 tuples 根据 hash key 放入不同的 buckets<ul>
<li>use a hash function h1 to split tuples into partitions on disk<ul>
<li>all matches live in the same partition</li>
<li>partitions are “spilled” to disk via output buffers</li>
</ul>
</li>
<li>这里有个额外的假设，即每个 partition 能够被放到 memory 中</li>
</ul>
</li>
<li>ReHash Phase: 在内存中针对每个 partition 利用 hash table 计算 aggregation 的结果</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403272000471.png" alt="image-20240327200043163"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403272000726.png" alt="image-20240327200052468"></p>
<p>在 ReHash phase 中，存着 (GroupKey→RunningVal)(GroupKey→RunningVal) 的键值对，当我们需要向 hash table 中插入新的 tuple 时：</p>
<ul>
<li>如果我们发现相应的 GroupKey 已经在内存中，只需要更新 RunningVal 就可以</li>
<li>反之，则插入新的 GroupKey 到 RunningVal 的键值对</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403272001082.png" alt="image-20240327200117774"></p>
]]></content>
      <categories>
        <category>项目</category>
        <category>cmu15-445</category>
      </categories>
  </entry>
  <entry>
    <title>cmu15-445 Homework1_SQL (Spring 2023)</title>
    <url>/2024/02/28/6%20%E9%A1%B9%E7%9B%AE/cmu15-445/cmu15-445%20Homework1_SQL/</url>
    <content><![CDATA[<h1 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> CategoryName <span class="keyword">FROM</span> Category <span class="keyword">ORDER</span> <span class="keyword">BY</span> CategoryName;</span><br><span class="line"></span><br><span class="line">Beverages</span><br><span class="line">Condiments</span><br><span class="line">Confections</span><br><span class="line">Dairy Products</span><br><span class="line">Grains<span class="operator">/</span>Cereals</span><br><span class="line">Meat<span class="operator">/</span>Poultry</span><br><span class="line">Produce</span><br><span class="line">Seafood</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> ShipName <span class="keyword">FROM</span> <span class="string">&#x27;Order&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span>  ShipName <span class="keyword">LIKE</span> <span class="string">&#x27;%-%&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> ShipName;</span><br><span class="line"></span><br><span class="line">Bottom<span class="operator">-</span>Dollar Markets</span><br><span class="line">Chop<span class="operator">-</span>suey Chinese</span><br><span class="line">GROSELLA<span class="operator">-</span>Restaurante</span><br><span class="line">HILARION<span class="operator">-</span>Abastos</span><br><span class="line">Hungry Owl <span class="keyword">All</span><span class="operator">-</span>Night Grocers</span><br><span class="line">LILA<span class="operator">-</span>Supermercado</span><br><span class="line">LINO<span class="operator">-</span>Delicateses</span><br><span class="line">QUICK<span class="operator">-</span>Stop</span><br><span class="line">Save<span class="operator">-</span>a<span class="operator">-</span>lot Markets</span><br><span class="line"></span><br><span class="line">DETAILS:</span><br><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> ShipName <span class="operator">||</span> <span class="string">&#x27;|&#x27;</span> <span class="operator">||</span> SUBSTR(ShipName, <span class="number">1</span>, INSTR(ShipName, <span class="string">&#x27;-&#x27;</span>) <span class="operator">-</span> <span class="number">1</span>) <span class="keyword">AS</span> formatted_res</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="string">&#x27;Order&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> ShipName <span class="keyword">like</span> <span class="string">&#x27;%-%&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> ShipName;</span><br><span class="line"></span><br><span class="line">Bottom<span class="operator">-</span>Dollar Markets<span class="operator">|</span>Bottom</span><br><span class="line">Chop<span class="operator">-</span>suey Chinese<span class="operator">|</span>Chop</span><br><span class="line">GROSELLA<span class="operator">-</span>Restaurante<span class="operator">|</span>GROSELLA</span><br><span class="line">HILARION<span class="operator">-</span>Abastos<span class="operator">|</span>HILARION</span><br><span class="line">Hungry Owl <span class="keyword">All</span><span class="operator">-</span>Night Grocers<span class="operator">|</span>Hungry Owl <span class="keyword">All</span></span><br><span class="line">LILA<span class="operator">-</span>Supermercado<span class="operator">|</span>LILA</span><br><span class="line">LINO<span class="operator">-</span>Delicateses<span class="operator">|</span>LINO</span><br><span class="line">QUICK<span class="operator">-</span>Stop<span class="operator">|</span>QUICK</span><br><span class="line">Save<span class="operator">-</span>a<span class="operator">-</span>lot Markets<span class="operator">|</span>Save</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> INSTR(ShipName, <span class="string">&#x27;-&#x27;</span>)：该函数找到在 ShipName 字符串中连字符（<span class="string">&#x27;-&#x27;</span>）的位置</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> SUBSTR(ShipName, <span class="number">1</span>, INSTR(ShipName, <span class="string">&#x27;-&#x27;</span>) <span class="operator">-</span> <span class="number">1</span>)：该 SUBSTR 函数从 ShipName 字符串的开头（位置<span class="number">1</span>）提取子字符串，直到连字符的位置减<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Id <span class="operator">||</span> <span class="string">&#x27;|&#x27;</span> <span class="operator">||</span> ShipCountry <span class="operator">||</span> <span class="string">&#x27;|&#x27;</span> <span class="operator">||</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">CASE</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">WHEN</span> ShipCountry <span class="keyword">IN</span> (<span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Mexico&#x27;</span>, <span class="string">&#x27;Canada&#x27;</span>) <span class="keyword">THEN</span> <span class="string">&#x27;NorthAmerica&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">ELSE</span> <span class="string">&#x27;OtherPlace&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">END</span> <span class="keyword">AS</span> Region</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="string">&#x27;Order&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> Id<span class="operator">&gt;=</span><span class="number">15445</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> Id</span><br><span class="line">   ...<span class="operator">&gt;</span> LIMIT <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">15445</span><span class="operator">|</span>France<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15446</span><span class="operator">|</span>Italy<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15447</span><span class="operator">|</span>Portugal<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15448</span><span class="operator">|</span>Argentina<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15449</span><span class="operator">|</span>Portugal<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15450</span><span class="operator">|</span>Venezuela<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15451</span><span class="operator">|</span>Brazil<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15452</span><span class="operator">|</span>France<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15453</span><span class="operator">|</span>France<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15454</span><span class="operator">|</span>Canada<span class="operator">|</span>NorthAmerica</span><br><span class="line"><span class="number">15455</span><span class="operator">|</span>USA<span class="operator">|</span>NorthAmerica</span><br><span class="line"><span class="number">15456</span><span class="operator">|</span>France<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15457</span><span class="operator">|</span>Mexico<span class="operator">|</span>NorthAmerica</span><br><span class="line"><span class="number">15458</span><span class="operator">|</span>USA<span class="operator">|</span>NorthAmerica</span><br><span class="line"><span class="number">15459</span><span class="operator">|</span>Germany<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15460</span><span class="operator">|</span>Argentina<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15461</span><span class="operator">|</span>Austria<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15462</span><span class="operator">|</span>Austria<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15463</span><span class="operator">|</span>Finland<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15464</span><span class="operator">|</span>Brazil<span class="operator">|</span>OtherPlace</span><br></pre></td></tr></table></figure>

<h1 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span></span><br><span class="line">   ...<span class="operator">&gt;</span> s.CompanyName <span class="operator">||</span> <span class="string">&#x27;|&#x27;</span> <span class="operator">||</span></span><br><span class="line">   ...<span class="operator">&gt;</span> ROUND(<span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> o.ShippedDate <span class="operator">&gt;</span> o.RequiredDate <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="operator">*</span> <span class="number">100.0</span> <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>), <span class="number">2</span>) <span class="keyword">AS</span> Percentage</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> Shipper <span class="keyword">as</span> s</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">JOIN</span> [<span class="keyword">Order</span>] <span class="keyword">as</span> o <span class="keyword">ON</span> s.Id <span class="operator">=</span> o.ShipVia</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> s.CompanyName</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> Percentage <span class="keyword">DESC</span>; </span><br><span class="line"></span><br><span class="line">United Package<span class="operator">|</span><span class="number">23.44</span></span><br><span class="line">Speedy Express<span class="operator">|</span><span class="number">23.46</span></span><br><span class="line">Federal Shipping<span class="operator">|</span><span class="number">23.61</span></span><br></pre></td></tr></table></figure>

<h1 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span></span><br><span class="line">   ...<span class="operator">&gt;</span> a.CategoryName,</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="built_in">COUNT</span>(a.Id) <span class="keyword">AS</span> TotalCategoryCount,</span><br><span class="line">   ...<span class="operator">&gt;</span> ROUND(((<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(UnitPrice) <span class="keyword">FROM</span> Category b, Product c <span class="keyword">WHERE</span> b.Id <span class="operator">=</span> c.CategoryId <span class="keyword">AND</span> b.CategoryName <span class="operator">=</span> a.CategoryName) <span class="operator">*</span> <span class="number">1.0</span>) <span class="operator">/</span> ((<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> Category d, Product e <span class="keyword">WHERE</span> d.Id <span class="operator">=</span> e.CategoryId <span class="keyword">AND</span> d.CategoryName <span class="operator">=</span> a.CategoryName) <span class="operator">*</span> <span class="number">1.0</span>) , <span class="number">2</span>),</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="built_in">MIN</span>(f.UnitPrice),</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="built_in">MAX</span>(f.UnitPrice),</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="built_in">SUM</span>(f.UnitsOnOrder)</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> Category a, Product f</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> a.Id <span class="operator">=</span> f.CategoryId</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.CategoryName</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">HAVING</span> TotalCategoryCount <span class="operator">&gt;</span> <span class="number">10</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a.Id <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">Beverages<span class="operator">|</span><span class="number">12</span><span class="operator">|</span><span class="number">37.98</span><span class="operator">|</span><span class="number">4.5</span><span class="operator">|</span><span class="number">263.5</span><span class="operator">|</span><span class="number">60</span></span><br><span class="line">Condiments<span class="operator">|</span><span class="number">12</span><span class="operator">|</span><span class="number">23.06</span><span class="operator">|</span><span class="number">10</span><span class="operator">|</span><span class="number">43.9</span><span class="operator">|</span><span class="number">170</span></span><br><span class="line">Confections<span class="operator">|</span><span class="number">13</span><span class="operator">|</span><span class="number">25.16</span><span class="operator">|</span><span class="number">9.2</span><span class="operator">|</span><span class="number">81</span><span class="operator">|</span><span class="number">180</span></span><br><span class="line">Seafood<span class="operator">|</span><span class="number">12</span><span class="operator">|</span><span class="number">20.68</span><span class="operator">|</span><span class="number">6</span><span class="operator">|</span><span class="number">62.5</span><span class="operator">|</span><span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> b.CategoryName <span class="operator">=</span> a.CategoryName 这个条件确保了在计算每个类别的商品价格总和时，只考虑了与当前类别相关的商品</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 这是为了满足 <span class="keyword">HAVING</span> TotalCategoryCount <span class="operator">&gt;</span> <span class="number">10</span> 中的条件</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">*</span><span class="number">1.0</span> 的目的是将整数值转换为浮点数。这是为了确保在计算平均商品价格时，得到的结果是一个浮点数，而不是整数</span><br></pre></td></tr></table></figure>

<h1 id="Q6"><a href="#Q6" class="headerlink" title="Q6*"></a>Q6*</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">SELECT</span> p.ProductName, </span><br><span class="line">(<span class="keyword">SELECT</span> </span><br><span class="line">  c1.CompanyName <span class="operator">||</span> <span class="string">&#x27;|&#x27;</span> <span class="operator">||</span> c1.ContactName </span><br><span class="line">  <span class="keyword">FROM</span> Customer c1 </span><br><span class="line">  <span class="keyword">JOIN</span> [<span class="keyword">Order</span>] o1 <span class="keyword">ON</span> o1.CustomerId <span class="operator">=</span> c1.Id</span><br><span class="line">  <span class="keyword">JOIN</span> OrderDetail od1 <span class="keyword">ON</span> o1.Id <span class="operator">=</span> od1.OrderID</span><br><span class="line">  <span class="keyword">WHERE</span> od1.ProductId <span class="operator">=</span> p.Id</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> o1.OrderDate <span class="keyword">ASC</span> LIMIT <span class="number">1</span>) <span class="keyword">AS</span> CustomerInfo</span><br><span class="line"><span class="keyword">FROM</span> Product p</span><br><span class="line"><span class="keyword">JOIN</span> OrderDetail od <span class="keyword">ON</span> p.Id <span class="operator">=</span> od.ProductId</span><br><span class="line"><span class="keyword">JOIN</span> [<span class="keyword">Order</span>] o <span class="keyword">ON</span> od.OrderId <span class="operator">=</span> o.Id</span><br><span class="line"><span class="keyword">JOIN</span> CUSTOMER c <span class="keyword">ON</span> o.CustomerID <span class="operator">=</span> c.Id</span><br><span class="line"><span class="keyword">WHERE</span> p.Discontinued <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> p.ProductName;</span><br><span class="line"></span><br><span class="line">Alice Mutton<span class="operator">|</span>Consolidated Holdings<span class="operator">|</span>Elizabeth Brown</span><br><span class="line">Chef Anton<span class="string">&#x27;s Gumbo Mix|Piccolo und mehr|Georg Pipps</span></span><br><span class="line"><span class="string">Guaraná Fantástica|Piccolo und mehr|Georg Pipps</span></span><br><span class="line"><span class="string">Mishi Kobe Niku|Old World Delicatessen|Rene Phillips</span></span><br><span class="line"><span class="string">Perth Pasties|Piccolo und mehr|Georg Pipps</span></span><br><span class="line"><span class="string">Rössle Sauerkraut|Piccolo und mehr|Georg Pipps</span></span><br><span class="line"><span class="string">Singaporean Hokkien Fried Mee|Vins et alcools Chevalier|Paul Henriot</span></span><br><span class="line"><span class="string">Thüringer Rostbratwurst|Piccolo und mehr|Georg Pipps</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// c1		==&gt; FROM Customer c1 </span></span><br><span class="line"><span class="string">// c1-&gt;o1	==&gt; JOIN [Order] o1 ON o1.CustomerId = c1.Id</span></span><br><span class="line"><span class="string">// o1-&gt;od1	==&gt; JOIN OrderDetail od1 ON o1.Id = od1.OrderID</span></span><br><span class="line"><span class="string">// od1-&gt;p	==&gt; (将子查询和外部主查询联系起来)WHERE od1.ProductId = p.Id</span></span><br></pre></td></tr></table></figure>

<h2 id="Q7"><a href="#Q7" class="headerlink" title="Q7*"></a>Q7*</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Id, Orderdate, pre_OrderDate, ROUND(julianday(OrderDate)<span class="operator">-</span>julianday(pre_orderdate) , <span class="number">2</span>)</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> Id, OrderDate, <span class="built_in">LAG</span>(Orderdate, <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> CustomerId <span class="keyword">ORDER</span> <span class="keyword">BY</span> OrderDate <span class="keyword">ASC</span>) pre_OrderDate</span><br><span class="line">      <span class="keyword">FROM</span> [<span class="keyword">Order</span>]</span><br><span class="line">      <span class="keyword">WHERE</span> CustomerId <span class="operator">=</span> <span class="string">&#x27;BLONP&#x27;</span></span><br><span class="line">      LIMIT <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">16766</span><span class="operator">|</span><span class="number">2012</span><span class="number">-07</span><span class="number">-22</span> <span class="number">23</span>:<span class="number">11</span>:<span class="number">15</span><span class="operator">|</span><span class="number">0</span><span class="operator">|</span><span class="number">2456131.47</span></span><br><span class="line"><span class="number">10265</span><span class="operator">|</span><span class="number">2012</span><span class="number">-07</span><span class="number">-25</span><span class="operator">|</span><span class="number">2012</span><span class="number">-07</span><span class="number">-22</span> <span class="number">23</span>:<span class="number">11</span>:<span class="number">15</span><span class="operator">|</span><span class="number">2.03</span></span><br><span class="line"><span class="number">12594</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-16</span> <span class="number">12</span>:<span class="number">35</span>:<span class="number">15</span><span class="operator">|</span><span class="number">2012</span><span class="number">-07</span><span class="number">-25</span><span class="operator">|</span><span class="number">22.52</span></span><br><span class="line"><span class="number">20249</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">52</span>:<span class="number">23</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-16</span> <span class="number">12</span>:<span class="number">35</span>:<span class="number">15</span><span class="operator">|</span><span class="number">0.18</span></span><br><span class="line"><span class="number">20882</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-18</span> <span class="number">19</span>:<span class="number">11</span>:<span class="number">48</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">52</span>:<span class="number">23</span><span class="operator">|</span><span class="number">2.1</span></span><br><span class="line"><span class="number">18443</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-28</span> <span class="number">05</span>:<span class="number">34</span>:<span class="number">03</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-18</span> <span class="number">19</span>:<span class="number">11</span>:<span class="number">48</span><span class="operator">|</span><span class="number">9.43</span></span><br><span class="line"><span class="number">10297</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-04</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-28</span> <span class="number">05</span>:<span class="number">34</span>:<span class="number">03</span><span class="operator">|</span><span class="number">6.77</span></span><br><span class="line"><span class="number">11694</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-17</span> <span class="number">00</span>:<span class="number">27</span>:<span class="number">14</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-04</span><span class="operator">|</span><span class="number">13.02</span></span><br><span class="line"><span class="number">25613</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-18</span> <span class="number">22</span>:<span class="number">37</span>:<span class="number">15</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-17</span> <span class="number">00</span>:<span class="number">27</span>:<span class="number">14</span><span class="operator">|</span><span class="number">1.92</span></span><br><span class="line"><span class="number">17361</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">13</span>:<span class="number">21</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-18</span> <span class="number">22</span>:<span class="number">37</span>:<span class="number">15</span><span class="operator">|</span><span class="number">0.57</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> julianday(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">Result</span>: <span class="number">2458220.59892027</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 返回从格林尼治时间的公元前 <span class="number">4714</span> 年 <span class="number">11</span> 月 <span class="number">24</span> 日正午算起的天数</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="built_in">LAG</span>(expr, <span class="keyword">offset</span>, <span class="keyword">default</span>) <span class="keyword">OVER</span> (partition_by_clause order_by_clause)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 计算当前行向前数若干行的值，该函数专门用作窗口函数(<span class="keyword">window</span> functions)，<span class="keyword">partition</span> <span class="keyword">by</span>功能类似<span class="keyword">group</span> <span class="keyword">by</span></span><br></pre></td></tr></table></figure>

<h1 id="Q8"><a href="#Q8" class="headerlink" title="Q8*"></a>Q8*</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">WITH</span> expenditures <span class="keyword">AS</span>(</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">SELECT</span> </span><br><span class="line">   ...<span class="operator">&gt;</span>                        IFNULL(c.CompanyName, <span class="string">&#x27;MISSING_NAME&#x27;</span>) <span class="keyword">AS</span> CompanyName,</span><br><span class="line">   ...<span class="operator">&gt;</span>                        o.CustomerId,</span><br><span class="line">   ...<span class="operator">&gt;</span>                        ROUND((<span class="built_in">SUM</span>(od.Quantity <span class="operator">*</span> od.UnitPrice)) , <span class="number">2</span>) <span class="keyword">AS</span> totalcost</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">FROM</span> [<span class="keyword">Order</span>] o</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">JOIN</span> OrderDetail od <span class="keyword">ON</span> od.OrderId <span class="operator">=</span> o.Id</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Customer c <span class="keyword">ON</span> c.Id <span class="operator">=</span> o.CustomerId</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">GROUP</span> <span class="keyword">BY</span> o.CustomerId),</span><br><span class="line">   ...<span class="operator">&gt;</span>      quartiles <span class="keyword">AS</span>(</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">SELECT</span></span><br><span class="line">   ...<span class="operator">&gt;</span>                        <span class="operator">*</span>,</span><br><span class="line">   ...<span class="operator">&gt;</span>                        <span class="built_in">NTILE</span>(<span class="number">4</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> totalcost <span class="keyword">ASC</span>) <span class="keyword">AS</span> ExpenditureQuartile</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">FROM</span> expenditures)</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">SELECT</span> CompanyName, CustomerId, totalcost</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> quartiles</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> ExpenditureQuartile <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> totalcost <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">MISSING_NAME<span class="operator">|</span>DUMO<span class="operator">|</span><span class="number">1615.9</span></span><br><span class="line">MISSING_NAME<span class="operator">|</span>OCEA<span class="operator">|</span><span class="number">3460.2</span></span><br><span class="line">MISSING_NAME<span class="operator">|</span>ANTO<span class="operator">|</span><span class="number">7515.35</span></span><br><span class="line">MISSING_NAME<span class="operator">|</span>QUEE<span class="operator">|</span><span class="number">30226.1</span></span><br><span class="line">Trail<span class="string">&#x27;s Head Gourmet Provisioners|TRAIH|3874502.02</span></span><br><span class="line"><span class="string">Blondesddsl père et fils|BLONP|3879728.69</span></span><br><span class="line"><span class="string">Around the Horn|AROUT|4395636.28</span></span><br><span class="line"><span class="string">Hungry Owl All-Night Grocers|HUNGO|4431457.1</span></span><br><span class="line"><span class="string">Bon app|BONAP|4485708.49</span></span><br><span class="line"><span class="string">Bólido Comidas preparadas|BOLID|4520121.88</span></span><br><span class="line"><span class="string">Galería del gastrónomo|GALED|4533089.9</span></span><br><span class="line"><span class="string">FISSA Fabrica Inter. Salchichas S.A.|FISSA|4554591.02</span></span><br><span class="line"><span class="string">Maison Dewey|MAISD|4555931.37</span></span><br><span class="line"><span class="string">Cactus Comidas para llevar|CACTU|4559046.87</span></span><br><span class="line"><span class="string">Spécialités du monde|SPECD|4571764.89</span></span><br><span class="line"><span class="string">Magazzini Alimentari Riuniti|MAGAA|4572382.35</span></span><br><span class="line"><span class="string">Toms Spezialitäten|TOMSP|4628403.36</span></span><br><span class="line"><span class="string">Split Rail Beer &amp; Ale|SPLIR|4641383.53</span></span><br><span class="line"><span class="string">Santé Gourmet|SANTG|4647668.15</span></span><br><span class="line"><span class="string">Morgenstern Gesundkost|MORGK|4676234.2</span></span><br><span class="line"><span class="string">White Clover Markets|WHITC|4681531.74</span></span><br><span class="line"><span class="string">La corne d&#x27;</span>abondance<span class="operator">|</span>LACOR<span class="operator">|</span><span class="number">4724494.22</span></span><br><span class="line">Victuailles en stock<span class="operator">|</span>VICTE<span class="operator">|</span><span class="number">4726476.33</span></span><br><span class="line">Lonesome Pine Restaurant<span class="operator">|</span>LONEP<span class="operator">|</span><span class="number">4735780.66</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> IFNULL(c.CompanyName, <span class="string">&#x27;MISSING_NAME&#x27;</span>) <span class="keyword">AS</span> CompanyName  </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 处理<span class="keyword">NULL</span>值</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Customer c <span class="keyword">ON</span> c.Id <span class="operator">=</span> o.CustomerId</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 这种连接类型包含左表的所有行，以及右表中满足连接条件的行。如果右表中没有匹配的行，那么结果集中将包含 <span class="keyword">NULL</span> 值</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="built_in">NTILE</span>(<span class="number">4</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> totalcost <span class="keyword">ASC</span>) <span class="keyword">AS</span> ExpenditureQuartile</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 它将结果集划分为指定数量的桶（buckets），并为每个桶分配一个标识号（bucket number）</span><br></pre></td></tr></table></figure>
<p>现在，假设有以下支出数据：</p>
<table>
<thead>
<tr>
<th>CompanyName</th>
<th>CustomerId</th>
<th>totalcost</th>
</tr>
</thead>
<tbody><tr>
<td>Company1</td>
<td>1</td>
<td>100</td>
</tr>
<tr>
<td>Company2</td>
<td>2</td>
<td>150</td>
</tr>
<tr>
<td>Company3</td>
<td>3</td>
<td>200</td>
</tr>
<tr>
<td>Company4</td>
<td>4</td>
<td>250</td>
</tr>
<tr>
<td>Company5</td>
<td>5</td>
<td>300</td>
</tr>
</tbody></table>
<p><code>NTILE(4) OVER (ORDER BY totalcost ASC) AS ExpenditureQuartile</code>将分配 ExpenditureQuartile 值，结果如下：</p>
<table>
<thead>
<tr>
<th>CompanyName</th>
<th>CustomerId</th>
<th>totalcost</th>
</tr>
</thead>
<tbody><tr>
<td>Company1</td>
<td>1</td>
<td>100</td>
</tr>
<tr>
<td>Company2</td>
<td>2</td>
<td>150</td>
</tr>
<tr>
<td>Company3</td>
<td>3</td>
<td>200</td>
</tr>
<tr>
<td>Company4</td>
<td>4</td>
<td>250</td>
</tr>
<tr>
<td>Company5</td>
<td>5</td>
<td>300</td>
</tr>
</tbody></table>
<h1 id="Q9"><a href="#Q9" class="headerlink" title="Q9"></a>Q9</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> r.RegionDescription, e.FirstName, e.LastName, <span class="built_in">MAX</span>(e.BirthDate)</span><br><span class="line"><span class="keyword">FROM</span> Region r</span><br><span class="line"><span class="keyword">JOIN</span> Territory t <span class="keyword">ON</span> t.RegionId <span class="operator">=</span> r.Id</span><br><span class="line"><span class="keyword">JOIN</span> EmployeeTerritory et <span class="keyword">ON</span> et.TerritoryId <span class="operator">=</span> t.Id</span><br><span class="line"><span class="keyword">JOIN</span> Employee e <span class="keyword">On</span> e.Id <span class="operator">=</span> et.EmployeeId</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t.RegionId;</span><br><span class="line"></span><br><span class="line">Eastern<span class="operator">|</span>Steven<span class="operator">|</span>Buchanan<span class="operator">|</span><span class="number">1987</span><span class="number">-03</span><span class="number">-04</span></span><br><span class="line">Western<span class="operator">|</span>Michael<span class="operator">|</span>Suyama<span class="operator">|</span><span class="number">1995</span><span class="number">-07</span><span class="number">-02</span></span><br><span class="line">Northern<span class="operator">|</span>Anne<span class="operator">|</span>Dodsworth<span class="operator">|</span><span class="number">1998</span><span class="number">-01</span><span class="number">-27</span></span><br><span class="line">Southern<span class="operator">|</span>Janet<span class="operator">|</span>Leverling<span class="operator">|</span><span class="number">1995</span><span class="number">-08</span><span class="number">-30</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="built_in">MAX</span>(e.BirthDate)</span><br></pre></td></tr></table></figure>

<h1 id="Q10"><a href="#Q10" class="headerlink" title="Q10"></a>Q10</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> temptable <span class="keyword">AS</span>(</span><br><span class="line">                  <span class="keyword">SELECT</span> </span><br><span class="line">                    d.ProductName myproductname,</span><br><span class="line">                    strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>, b.OrderDate) <span class="type">date</span></span><br><span class="line">                  <span class="keyword">FROM</span> Customer a, [<span class="keyword">Order</span>] b, OrderDetail c, Product d</span><br><span class="line">                  <span class="keyword">WHERE</span> a.Id <span class="operator">=</span> b.CustomerId </span><br><span class="line">                    <span class="keyword">AND</span> b.Id <span class="operator">=</span> c.OrderId </span><br><span class="line">                    <span class="keyword">AND</span> c.ProductId <span class="operator">=</span> d.Id </span><br><span class="line">                    <span class="keyword">AND</span> a.CompanyName <span class="operator">=</span> <span class="string">&#x27;Queen Cozinha&#x27;</span> </span><br><span class="line">                    <span class="keyword">AND</span> <span class="type">date</span> <span class="operator">=</span> <span class="string">&#x27;2014-12-25&#x27;</span></span><br><span class="line">                  <span class="keyword">ORDER</span> <span class="keyword">BY</span> d.Id <span class="keyword">ASC</span>)</span><br><span class="line"><span class="keyword">SELECT</span> group_concat(myproductname)</span><br><span class="line"><span class="keyword">FROM</span> temptable;</span><br><span class="line"></span><br><span class="line">Mishi Kobe Niku,NuNuCa Nuß<span class="operator">-</span>Nougat<span class="operator">-</span>Creme,Schoggi Schokolade,Mascarpone Fabioli,Sasquatch Ale,Boston Crab Meat,Manjimup Dried Apples,Longlife Tofu,Lakkalikööri</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>, b.OrderDate) <span class="type">date</span>  </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 将日期和时间格式化为字符串，将原始日期格式转换为 &quot;年-月-日&quot; 的字符串格式</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目</category>
        <category>cmu15-445</category>
      </categories>
  </entry>
  <entry>
    <title>cmu15-445 Project 1 (Spring 2023)</title>
    <url>/2024/03/02/6%20%E9%A1%B9%E7%9B%AE/cmu15-445/cmu15-445%20Project%201%20(Spring%202023)/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Task-1-LRU-K-Replacement-Policy"><a href="#Task-1-LRU-K-Replacement-Policy" class="headerlink" title="Task #1 - LRU-K Replacement Policy"></a>Task #1 - LRU-K Replacement Policy</h1><p>跟踪缓冲池中页面的使用情况，用于记录、更新以及删除页<code>(frame)</code>。</p>
<p><code>src/include/buffer/lru_k_replacer.h</code>  &#x3D;&#x3D;&gt; 实现<code>LRUKReplacer</code>的新类，且独立</p>
<p><code>src/buffer/lru_k_replacer.cpp</code> &#x3D;&#x3D;&gt; 对应实现，实现<code>LRU-K</code>替换策略。</p>
<p><code>LRU-K</code>将替换帧中<code>backward k-distance</code>最大的帧剔除。<code>backward k-distance</code>计算的是当前时间戳与前<code>k</code>次访问的时间戳之差。</p>
<p>历史链表：记录出现的历史时间戳，新的时间戳追加到链表尾部；</p>
<p><code>k-distance</code>：若出现此时小于<code>k</code>，则为无穷大；若大于等于<code>k</code>，则对应为历史链表头部；</p>
<p>驱逐方法：1）优先驱逐<code>k-distance</code>为无穷大的页，且按照<code>FIFO</code>的策略进行驱逐；2）若无无穷大的页，则驱逐<code>k-distance</code>最小的页（说明其倒数第<code>k</code>次出现最遥远，时间局部性更弱）。</p>
<h2 id="Task1踩坑处"><a href="#Task1踩坑处" class="headerlink" title="Task1踩坑处"></a>Task1踩坑处</h2><h3 id="（1）-15634-ERROR-AddressSanitizer-attempting-free-on-address-which-was-not-malloc-ed-0x7ffd62284260-in-thread-T0"><a href="#（1）-15634-ERROR-AddressSanitizer-attempting-free-on-address-which-was-not-malloc-ed-0x7ffd62284260-in-thread-T0" class="headerlink" title="（1）&#x3D;&#x3D;15634&#x3D;&#x3D;ERROR: AddressSanitizer: attempting free on address which was not malloc()-ed: 0x7ffd62284260 in thread T0"></a>（1）&#x3D;&#x3D;15634&#x3D;&#x3D;ERROR: AddressSanitizer: attempting free on address which was not malloc()-ed: 0x7ffd62284260 in thread T0</h3><p>表明在试图释放一个未经 malloc 分配的地址。</p>
<p>错误代码处为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// history 已满，更新 history</span></span><br><span class="line">node.history_.<span class="built_in">pop_front</span>();</span><br><span class="line">node.history_.<span class="built_in">push_back</span>(current_timestamp_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 more</span></span><br><span class="line">node_more_k_.<span class="built_in">erase</span>(node_more_k_.<span class="built_in">find</span>(&amp;node)); </span><br><span class="line">node_more_k_.<span class="built_in">insert</span>(&amp;node);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">node_more_k_.<span class="built_in">erase</span>(node_more_k_.<span class="built_in">find</span>(&amp;node));  <span class="comment">// here</span></span><br></pre></td></tr></table></figure>

<p>在 C++ 的 <code>std::set</code> 中，<code>erase</code> 函数会删除指定的元素，但不会直接释放其内存。相反，它会调用元素类型的析构函数，然后将元素从 <code>std::set</code> 中移除。然而这里尝试擦除的是一个指向局部对象 <code>node</code> 的指针，而不是指向 <code>std::set</code> 中元素的指针。一旦 <code>node</code> 超出作用域，其地址将变为无效地址。因此，这样的写法可能导致悬垂指针问题，当再次访问 <code>node_more_k_</code> 时，可能会引发未定义行为或崩溃。</p>
<p>修正后为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// history 已满，更新 history</span></span><br><span class="line">LRUKNode&amp; tmp = node;</span><br><span class="line">node_more_k_.<span class="built_in">erase</span>(&amp;node);</span><br><span class="line"><span class="comment">// 更新 more</span></span><br><span class="line">tmp.history_.<span class="built_in">pop_front</span>();</span><br><span class="line">tmp.history_.<span class="built_in">push_back</span>(current_timestamp_);</span><br><span class="line">node_more_k_.<span class="built_in">insert</span>(&amp;tmp);</span><br></pre></td></tr></table></figure>

<h3 id="（2）-17474-ERROR-LeakSanitizer-detected-memory-leaks"><a href="#（2）-17474-ERROR-LeakSanitizer-detected-memory-leaks" class="headerlink" title="（2）&#x3D;&#x3D;17474&#x3D;&#x3D;ERROR: LeakSanitizer: detected memory leaks"></a>（2）&#x3D;&#x3D;17474&#x3D;&#x3D;ERROR: LeakSanitizer: detected memory leaks</h3><p>表明存在内存泄漏问题。</p>
<p>错误代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果在node_store_中没有找到对应的元素，创建一个新的LRUKNode</span></span><br><span class="line"><span class="keyword">auto</span> *new_node = <span class="keyword">new</span> <span class="built_in">LRUKNode</span>();</span><br><span class="line">new_node-&gt;fid_ = frame_id;</span><br><span class="line">new_node-&gt;history_.<span class="built_in">push_back</span>(current_timestamp_);</span><br><span class="line">new_node-&gt;k_ = <span class="keyword">this</span>-&gt;k_;</span><br><span class="line"></span><br><span class="line">node_store_[frame_id] = *new_node;</span><br><span class="line">node_less_k_.<span class="built_in">insert</span>(node_less_k_.<span class="built_in">end</span>(), new_node);</span><br><span class="line">node_store_[frame_id].pos_ = std::<span class="built_in">prev</span>(node_less_k_.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>上述代码中，由于<code>node_store_</code> 的声明是 <code>std::unordered_map&lt;frame_id_t, LRUKNode&gt;</code>，这表示它存储的是 <code>LRUKNode</code> 对象的副本而不是指针。因此在使用<code>new</code>运算符分配内存后，将对象的副本赋值给了<code>node_store_[frame_id]</code>，而不是直接将指针存储在<code>node_store_</code>中。</p>
<p>改正的方式是直接存储指向动态分配的对象的指针，而不是对象的副本。同时，应该考虑采用智能指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::unordered_map&lt;<span class="type">frame_id_t</span>, std::shared_ptr&lt;LRUKNode&gt;&gt; node_store_;</span><br><span class="line">std::list&lt;std::shared_ptr&lt;LRUKNode&gt;&gt; node_less_k_;  <span class="comment">// 访问 k 次以下的页面，FIFO 队列</span></span><br><span class="line">std::set&lt;std::shared_ptr&lt;LRUKNode&gt;, MyCompare&gt; node_more_k_;  <span class="comment">// 访问 k 次以上的页面，LRU 队列</span></span><br></pre></td></tr></table></figure>

<p>此时上述代码可修改为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> new_node = std::<span class="built_in">make_shared</span>&lt;LRUKNode&gt;();</span><br><span class="line">new_node-&gt;fid_ = frame_id;</span><br><span class="line">new_node-&gt;history_.<span class="built_in">push_back</span>(current_timestamp_);</span><br><span class="line">new_node-&gt;k_ = <span class="keyword">this</span>-&gt;k_;</span><br><span class="line"></span><br><span class="line">node_store_[frame_id] = new_node;</span><br><span class="line">node_less_k_.<span class="built_in">insert</span>(node_less_k_.<span class="built_in">end</span>(), new_node);</span><br><span class="line">node_store_[frame_id]-&gt;pos_ = std::<span class="built_in">prev</span>(node_less_k_.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h1 id="Task-2-Buffer-Pool-Manager"><a href="#Task-2-Buffer-Pool-Manager" class="headerlink" title="Task #2 - Buffer Pool Manager"></a>Task #2 - Buffer Pool Manager</h1><blockquote>
<p><code>BufferPoolManager</code>负责从<code>DiskManager</code>抓取数据库页面并将其存储到内存中。<code>BufferPoolManager</code>还可以在收到明确指示或需要删除页面以便为新页面腾出空间时，将脏页面写入磁盘。</p>
<p>实际读取和写入磁盘数据的代码已经写好，不需要自己实现（<code>DiskManager</code>）。</p>
<p>系统中的所有内存页面都由<code>Page</code>对象表示。缓冲池管理器无需了解这些页面的内容。但作为系统开发人员，您必须明白，<code>Page</code>对象只是缓冲池中内存的容器，因此并不特定于某个页面。也就是说，每个页面对象都包含一个内存块，<code>DiskManager</code>将把它用作从磁盘读取物理页面内容的复制位置。<strong>缓冲池管理器（<code>BufferPoolManager</code>）会重复使用同一个页面对象来存储数据，因为数据会在磁盘上来回移动。这意味着，在系统的整个生命周期中，同一个页面对象可能包含不同的物理页面。</strong>页面对象的标识符（<code>page_id</code>）可追踪其包含的物理页面；如果页面对象不包含物理页面，则其<code>page_id</code>必须设置为<code>INVALID_PAGE_ID</code>。每个页面对象还维护一个计数器，用于记录 “钉住 “该页面的线程数。缓冲池管理器不允许释放被钉住的页面。每个页面对象也会记录它是否变脏。你的工作就是记录页面在解除固定前是否被修改过。<code>BufferPoolManager</code>必须先将脏页面的内容写回磁盘，然后才能重新使用该对象。</p>
<p>您的<code>BufferPoolManager</code>实现将使用您在本作业前几步中创建的<code>LRUKReplacer</code>类。<code>LRUKReplacer</code>将跟踪页面对象被访问的时间，以便在必须释放帧以腾出空间从磁盘复制新的物理页面时，决定驱逐哪个页面对象。在<code>BufferPoolManager</code>中将<code>page_id</code>映射到<code>frame_id</code>时，请再次注意 STL 容器不是线程安全的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Page *pages_;  <span class="comment">// 数组，索引为frame_id</span></span><br><span class="line">std::unordered_map&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; page_table_;  <span class="comment">// 即内存，存放page_id与frame_id的映射</span></span><br><span class="line">std::unique_ptr&lt;LRUKReplacer&gt; replacer_;</span><br><span class="line">std::list&lt;<span class="type">frame_id_t</span>&gt; free_list_;  <span class="comment">// 记录哪些位置为空</span></span><br><span class="line">std::mutex latch_;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>NewPage</code>：<ul>
<li>先在内存里(<code>free_list_</code>)找到一个空<code>frame</code>;</li>
<li>若没有，则替换出一个可驱逐的<code>replacement frame</code>，并更新访问历史和不可驱逐状态，注意若包含<code>dirty page</code>，则先将脏数据写回<code>disk</code>；</li>
<li>创建新<code>page</code>；</li>
<li>写回内存（<code>page_table_</code>）。</li>
</ul>
</li>
<li><code>FetchPage</code>：<ul>
<li>找<code>page_id</code>对应的页：<ul>
<li>先在<code>page_table_</code>中查找是否有<code>page_id</code>对应的页：<ul>
<li>若找到，<code>pin_count_</code>自增；</li>
<li>更新<code>frame</code>的访问历史，设置不可驱逐状态；</li>
</ul>
</li>
<li>若内存没有，则在<code>disk</code>中找，并在内存中腾出一个空位（<code>replacer_</code>）：<ul>
<li>若<code>replacement frame</code>包含<code>dirty page</code>，则先将脏数据写回<code>disk</code>；</li>
<li>更新<code>frame</code>的访问历史，设置不可驱逐状态；</li>
<li>在<code>disk</code>中读取该<code>page</code>的内容并写入；</li>
<li>写回内存（<code>page_table_</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>UnpinPage</code>：<ul>
<li>若<code>page_id</code>不存在，直接返回；</li>
<li>若存在，但<code>unpin</code>后<code>pin_count_</code>为<code>0</code>，也直接返回，并设置<code>frame</code>可驱逐；</li>
<li>除此之外，注意此处应该为：<code>pages_[frame_id].is_dirty_ |= is_dirty;</code>。</li>
</ul>
</li>
</ul>
<h2 id="Task2踩坑处"><a href="#Task2踩坑处" class="headerlink" title="Task2踩坑处"></a>Task2踩坑处</h2><h3 id="（1）unknown-file-Failure-C-exception-with-description-“The-id-not-found-in-cache”-thrown-in-the-test-body"><a href="#（1）unknown-file-Failure-C-exception-with-description-“The-id-not-found-in-cache”-thrown-in-the-test-body" class="headerlink" title="（1）unknown file: Failure C++ exception with description “The id not found in cache” thrown in the test body."></a>（1）unknown file: Failure C++ exception with description “The id not found in cache” thrown in the test body.</h3><p>一个很粗心的错误，那就是<code>RecordAccess</code>和<code>SetEvictable</code>的顺序搞反了。</p>
<p>正确的顺序应该是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">replacer_-&gt;<span class="built_in">RecordAccess</span>(frame_id);</span><br><span class="line">replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="（2）ERROR-AddressSanitizer-SEGV-on-unknown-address-0x000000000000-pc-0x7fb0fb78fdbe-bp-0x61a0000002d0-sp-0x7ffd1c504cc0-T0-、"><a href="#（2）ERROR-AddressSanitizer-SEGV-on-unknown-address-0x000000000000-pc-0x7fb0fb78fdbe-bp-0x61a0000002d0-sp-0x7ffd1c504cc0-T0-、" class="headerlink" title="（2）ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7fb0fb78fdbe bp 0x61a0000002d0 sp 0x7ffd1c504cc0 T0)、"></a>（2）ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7fb0fb78fdbe bp 0x61a0000002d0 sp 0x7ffd1c504cc0 T0)、</h3><p>这个错误是由于在程序执行期间发生了段错误（<code>Segmentation Fault</code>），导致程序崩溃。</p>
<p>根据错误信息，问题出现在调用 <code>std::basic_streambuf&lt;char, std::char_traits&lt;char&gt;&gt;::xsgetn(char*, long)</code> 函数时，发生了对未知地址的写操作，这可能是由于访问了空指针或者其他非法内存区域引起的。</p>
<p>引起错误的代码行为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">page0 = bpm-&gt;<span class="built_in">FetchPage</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"><span class="type">char</span> *page_data = <span class="literal">nullptr</span>;</span><br><span class="line">disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, page_data);</span><br></pre></td></tr></table></figure>

<p>报错的原因可能是因为 <code>disk_manager_-&gt;ReadPage</code> 函数中的 <code>page_data</code> 参数被传入了空指针。在 C&#x2F;C++ 中，如果要通过函数修改指针指向的内存内容，需要确保传入的指针指向有效的内存空间，而不是空指针。</p>
<p>这里实际上应该直接传入<code>pages_[frame_id].dara_</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, pages_[frame_id].data_);</span><br></pre></td></tr></table></figure>

<h1 id="Task-3-Read-Write-Page-Guards"><a href="#Task-3-Read-Write-Page-Guards" class="headerlink" title="Task #3 - Read&#x2F;Write Page Guards"></a>Task #3 - Read&#x2F;Write Page Guards</h1><blockquote>
<p>您将实现BasicPageGuard，它存储指向BufferPoolManager和Page对象的指针。页面保护确保在相应的page对象超出作用域时立即在其上调用UnpinPage。注意，它仍然应该为程序员提供一个方法来手动解除页面的锁定。</p>
<p>由于BasicPageGuard隐藏了底层的Page指针，它还可以提供只读&#x2F;写数据api，提供编译时检查，以确保针对每种用例正确设置is_dirty标志。</p>
<p>在未来的项目中，多个线程将从同一个页面读取和写入，因此需要读写锁存器来确保数据的正确性。请注意，在Page类中，有用于此目的的相关锁存方法。与页面的解锁类似，程序员在使用页面后可能会忘记解锁页面。为了缓解这个问题，你将实现ReadPageGuard和WritePageGuard，它们会在页面超出范围时自动解锁。</p>
<p>你需要为所有的BasicPageGuard, ReadPageGuard和WritePageGuard实现以下函数。</p>
<ul>
<li><code>PageGuard(PageGuard &amp;&amp;that)</code> : Move constructor.</li>
<li><code>operator=(PageGuard &amp;&amp;that)</code> : Move operator.</li>
<li><code>Drop()</code> : Unpin and&#x2F;or unlatch.</li>
<li><code>~PageGuard()</code> : Destructor.</li>
</ul>
<p>使用新的页面保护，在BufferPoolManager中实现以下wrappers。</p>
<ul>
<li><code>FetchPageBasic(page_id_t page_id)</code></li>
<li><code>FetchPageRead(page_id_t page_id)</code></li>
<li><code>FetchPageWrite(page_id_t page_id)</code></li>
<li><code>NewPageGuarded(page_id_t *page_id)</code></li>
</ul>
</blockquote>
<p>这个<code>task</code>的重点就是实现移动构造、移动幅值、<code>Drop</code>和析构这四个函数。</p>
<h1 id="GradeScope在线测试"><a href="#GradeScope在线测试" class="headerlink" title="GradeScope在线测试"></a>GradeScope在线测试</h1><h2 id="1、LRUKReplacerTest-Evict"><a href="#1、LRUKReplacerTest-Evict" class="headerlink" title="1、LRUKReplacerTest.Evict"></a>1、LRUKReplacerTest.Evict</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19: /autograder/source/bustub/test/buffer/grading_lru_k_replacer_test.cpp:276: Failure</span><br><span class="line">19: Expected equality of these values:</span><br><span class="line">19:   i</span><br><span class="line">19:     Which is: 100</span><br><span class="line">19:   result</span><br><span class="line">19:     Which is: 0</span><br><span class="line">19: Check your return value behavior for LRUKReplacer::Evict</span><br></pre></td></tr></table></figure>

<p>这个问题我真的研究了很久，本地测试和前面的一大部分在线测试都可以过，但是就是卡在这里。后来查了很久，知乎上有一个博主说是发现他的<code>LRUKReplacer::Remove</code>。于是我去检查了我的<code>Remove</code>函数，发现我也没有写完……我只在<code>node_store_</code>中进行了删除，而没有在<code>node_less_k_</code>或者<code>node_more_k_</code>中删除，补上后这个测试就通过了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (it-&gt;second-&gt;is_evictable_) &#123;</span><br><span class="line">      <span class="comment">// 该帧为可驱逐状态，继续操作</span></span><br><span class="line">      it-&gt;second-&gt;history_.<span class="built_in">clear</span>();</span><br><span class="line">      <span class="comment">// -------- add ------------------------------ //</span></span><br><span class="line">      <span class="keyword">if</span> (it-&gt;second-&gt;pos_ != node_less_k_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        node_less_k_.<span class="built_in">erase</span>(it-&gt;second-&gt;pos_);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node_more_k_.<span class="built_in">erase</span>(it-&gt;second);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// -------- add ------------------------------ //</span></span><br><span class="line">      node_store_.<span class="built_in">erase</span>(it);</span><br><span class="line">      curr_size_--;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、BufferPoolManagerTest-UnpinPage"><a href="#2、BufferPoolManagerTest-UnpinPage" class="headerlink" title="2、BufferPoolManagerTest.UnpinPage"></a>2、BufferPoolManagerTest.UnpinPage</h2><h3 id="DeletePage"><a href="#DeletePage" class="headerlink" title="DeletePage"></a>DeletePage</h3><p>[*]Bug:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">------------------------------------------</span><br><span class="line"><span class="number">7</span>: UnpinPage: <span class="number">0</span></span><br><span class="line"><span class="number">7</span>: --- Before UnpinPage: --- </span><br><span class="line"><span class="number">7</span>: ---page_table size: <span class="number">2</span></span><br><span class="line"><span class="number">7</span>: ---page_table content:</span><br><span class="line"><span class="number">7</span>: page_id: <span class="number">1</span>, frame_id: <span class="number">1</span>, pin_count: <span class="number">1</span>, page_data: page1</span><br><span class="line"><span class="number">7</span>: page_id: <span class="number">0</span>, frame_id: <span class="number">0</span>, pin_count: <span class="number">1</span>, page_data: page0</span><br><span class="line"><span class="number">7</span>: ---free_list size: <span class="number">0</span></span><br><span class="line"><span class="number">7</span>: ---free_list Content:</span><br><span class="line"><span class="number">7</span>: </span><br><span class="line"><span class="number">7</span>: --- After UnpinPage: --- </span><br><span class="line"><span class="number">7</span>: ---page_table size: <span class="number">1</span></span><br><span class="line"><span class="number">7</span>: ---page_table content:</span><br><span class="line"><span class="number">7</span>: page_id: <span class="number">1</span>, frame_id: <span class="number">1</span>, pin_count: <span class="number">1</span>, page_data: page1</span><br><span class="line"><span class="number">7</span>: ---free_list size: <span class="number">0</span></span><br><span class="line"><span class="number">7</span>: ---free_list Content:  <span class="comment">// free_list的更新出错</span></span><br></pre></td></tr></table></figure>

<p>要在DeletePage中实现将不再使用的frame从Replacer中删除，并重新放入free_list中</p>
<h3 id="NewPage"><a href="#NewPage" class="headerlink" title="NewPage"></a>NewPage</h3><ul>
<li>通过evict获取frame时，要先删除其上的old page</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">page_table_.<span class="built_in">erase</span>(pages_[frame_id].page_id_);  <span class="comment">// debug</span></span><br></pre></td></tr></table></figure>

<h3 id="FetchPage"><a href="#FetchPage" class="headerlink" title="FetchPage"></a>FetchPage</h3><ul>
<li><p>同NewPage，通过evict获取frame时，要先删除其上的old page；</p>
</li>
<li><p>若在内存中没找到对应的page，而需要从disk中获取时，注意除了要在page_table中绑定page_id和frame_id，还要在pages_对象中更新page_id和frame_id的绑定关系</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pages_[frame_id].page_id_ = page_id;  <span class="comment">// debug</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在fetch一个page后，更新其dirty状态为false，因为此时的page刚从disk写完数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pages_[frame_id].is_dirty_ = <span class="literal">false</span>;  <span class="comment">// debug</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、BufferPoolManagerTest-ConcurrencyTest"><a href="#3、BufferPoolManagerTest-ConcurrencyTest" class="headerlink" title="3、BufferPoolManagerTest.ConcurrencyTest"></a>3、BufferPoolManagerTest.ConcurrencyTest</h2><p>问题出在每个函数的加锁写在了日志打印后面，因此出现并发错误。</p>
<h2 id="4、PageGuardTest-DropTest-PageGuardTest-MoveTest"><a href="#4、PageGuardTest-DropTest-PageGuardTest-MoveTest" class="headerlink" title="4、PageGuardTest.DropTest &amp;&amp; PageGuardTest.MoveTest"></a>4、PageGuardTest.DropTest &amp;&amp; PageGuardTest.MoveTest</h2><blockquote>
<p>PageGuardTest.DropTest (0&#x2F;8)<br>PageGuardTest.MoveTest (0&#x2F;8)<br>PageGuardTest.BPMTest (0&#x2F;9)</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403241940804.png" alt="image-20240324194001569"></p>
<p>经过研究，我重写了PageGuard.cpp中几个函数的逻辑：</p>
<h3 id="BasicPageGuard"><a href="#BasicPageGuard" class="headerlink" title="BasicPageGuard"></a>BasicPageGuard</h3><h4 id="（1）Drop"><a href="#（1）Drop" class="headerlink" title="（1）Drop()"></a>（1）Drop()</h4><p>忘记了对bpm_重置为nullptr;</p>
<h4 id="（2）operator-BasicPageGuard-that"><a href="#（2）operator-BasicPageGuard-that" class="headerlink" title="（2）operator&#x3D;(BasicPageGuard &amp;&amp;that)"></a>（2）operator&#x3D;(BasicPageGuard &amp;&amp;that)</h4><p>注意要先调用<code>Drop()</code>来drop掉当前的old guarded page，然后再进行资源转移。</p>
<h3 id="ReadPageGuard"><a href="#ReadPageGuard" class="headerlink" title="ReadPageGuard"></a>ReadPageGuard</h3><h4 id="（1）ReadPageGuard-ReadPageGuard-that"><a href="#（1）ReadPageGuard-ReadPageGuard-that" class="headerlink" title="（1）ReadPageGuard(ReadPageGuard &amp;&amp;that)"></a>（1）ReadPageGuard(ReadPageGuard &amp;&amp;that)</h4><p>虽然.cpp文件中写的是<code>=default</code>，但.h文件中又要求实现，所以还是实现了一下。</p>
<h4 id="（2）operator-ReadPageGuard-that"><a href="#（2）operator-ReadPageGuard-that" class="headerlink" title="（2）operator&#x3D;(ReadPageGuard &amp;&amp;that)"></a>（2）operator&#x3D;(ReadPageGuard &amp;&amp;that)</h4><p>这里我最开始只调用了<code>std::move(that.guard_)</code>，实际上应该1)先在page_不为空时进行解读锁；2)然后进行资源转移。</p>
<h4 id="（3）Drop"><a href="#（3）Drop" class="headerlink" title="（3）Drop()"></a>（3）Drop()</h4><p>这里和重载移动赋值运算符一样，最开始只调用了<code>Drop()</code>，而实际上也应该先解读锁。</p>
<h3 id="WritePageGuard"><a href="#WritePageGuard" class="headerlink" title="WritePageGuard"></a>WritePageGuard</h3><p>和ReadPageGuard同理。</p>
<p>最后，历时许久，第一个Project终于通过了！</p>
]]></content>
      <categories>
        <category>项目</category>
        <category>cmu15-445</category>
      </categories>
  </entry>
  <entry>
    <title>cmu15-445 Project 2 (Spring 2023)</title>
    <url>/2024/03/27/6%20%E9%A1%B9%E7%9B%AE/cmu15-445/cmu15-445%20Project%202%20(Spring%202023)/</url>
    <content><![CDATA[<p>Overview：</p>
<blockquote>
<p>In this programming project you will implement a <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+Tree</a> index in your database system. <strong>A B+Tree is a balanced search tree in which the internal pages direct the search and leaf pages contain the actual data entries.</strong> The index provides fast data retrieval without needing to search every row in a database table, enabling rapid random lookups and efficient scans of ordered records. Your implementation will support thread-safe search, insertion, deletion (including splitting and merging nodes), and an iterator to support in-order leaf scans.</p>
<p>在这个编程项目中，您将在数据库系统中实现B+树索引。B+树是一种平衡搜索树，其中internal pages指导搜索，leaf pages包含实际的数据项。索引提供了快速的数据检索，而不需要搜索数据库表中的每一行，支持快速随机查找和高效的有序记录扫描。你的实现将支持<strong>线程安全</strong>的搜索、插入、删除(包括节点拆分和合并)，以及一个支持按序叶扫描的迭代器。</p>
</blockquote>
<p>Project2的实现依赖于Project1的buffer pool和page guards。</p>
<span id="more"></span>

<h1 id="Checkpoint-1-15-points"><a href="#Checkpoint-1-15-points" class="headerlink" title="Checkpoint #1 (15 points)"></a><strong>Checkpoint #1 (15 points)</strong></h1><h2 id="Task-1-B-Tree-Pages"><a href="#Task-1-B-Tree-Pages" class="headerlink" title="Task #1 - B+Tree Pages"></a>Task #1 - B+Tree Pages</h2><p>实现三个Page Classes去存储B+Tree的数据：</p>
<ul>
<li><p>B+Tree Page</p>
<ul>
<li>Base class，以供下面两个类继承。</li>
</ul>
</li>
<li><p>B+Tree Internal Page</p>
<ul>
<li><strong>存储m个ordered keys和m+1个child pointers</strong>（即page_ids，指向其他的B+Tree Pages），表现为<code>key/page_id</code>pairs；</li>
</ul>
<blockquote>
<p>Because the number of pointers does not equal the number of keys, the first key is set to be invalid, and lookups should always start with the second key.</p>
</blockquote>
<ul>
<li>在任意时刻，internal page必须至少为<code>half full</code>。<ul>
<li>删除时，两个<code>half full pages</code>可以合并，或<code>keys and pointers</code>重新分布来避免合并；</li>
<li>插入时，一个<code>full pages</code>可以拆分成两个，或<code>keys and pointers</code>重新分布来避免拆分。</li>
</ul>
</li>
</ul>
</li>
<li><p>B+Tree Leaf Page</p>
<ul>
<li><strong>存储m个ordered keys和m个相对应的value。</strong>value需要被设置为<strong>64-bit record-id</strong>。</li>
<li>其余设置和internal pages一致。</li>
</ul>
<blockquote>
<p>即使叶子页和内部页包含相同类型的键，它们的值类型也可能不同。因此，max_size 也可能不同。</p>
</blockquote>
</li>
</ul>
<p>注意：</p>
<p>1、每个 B+Tree 的叶子页&#x2F;内部页都与缓冲池获取的内存页的内容（即 data_ 部分）相对应；</p>
<p>2、每次read&#x2F;write一个leaf&#x2F;internal page时：</p>
<p>（1）从buffer pool中fetch该页；（page id）</p>
<p>（2）reinterpret cast to leaf&#x2F;internal page；</p>
<p>（3）读&#x2F;写完后Unpin该page。</p>
<ul>
<li><p>flexible array</p>
<ul>
<li><p>flexible array 必须是类中的最后一个成员，并且仅能有一个。在为对象分配内存时，flexible array 会自动填充，占用未被其他变量使用的内存。这样就可以确定自己的长度了。</p>
</li>
<li><p>举例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如有一个类 C：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">// 4 byte</span></span><br><span class="line">    <span class="type">int</span> array[<span class="number">1</span>]; <span class="comment">// unknown size</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在初始化一个 C 的对象，并为其分配了 24 byte 的内存。a 占了 4 byte 内存</span></span><br><span class="line"><span class="comment">// 那么 array 会尝试填充剩下的内存，大小变为 5。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="B-PLUS-TREE-INTERNAL-PAGE"><a href="#B-PLUS-TREE-INTERNAL-PAGE" class="headerlink" title="B_PLUS_TREE_INTERNAL_PAGE"></a><strong>B_PLUS_TREE_INTERNAL_PAGE</strong></h3><ul>
<li><p>对于 Internal Page 其储存的节点数最大正好是 internal_max_size，可能被存满</p>
<ul>
<li>由于先插入会导致空间溢出，因此考虑单独开辟一块内存空间，在完成插入与分裂后释放。</li>
</ul>
</li>
<li><p>要求第一个key为空的原因：在 internal page 中，n 个 key 可以将数轴划分为 n+1 个区域，也就对应着 n+1 个 value。</p>
</li>
<li><p>internal page 中的 key 并不代表实际上的索引值，仅仅是作为一个向导，引导需要插入&#x2F;删除&#x2F;查询的 key 找到这个 key 真正所在的 leaf page。</p>
</li>
<li><p>Header大小为24Byte：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">IndexPageType page_type_;   <span class="comment">// leaf or internal. 4 Byte</span></span><br><span class="line"><span class="type">lsn_t</span> lsn_  <span class="comment">// temporarily unused. 4 Byte</span></span><br><span class="line"><span class="type">int</span> size_;  <span class="comment">// tree page data size(not in byte, in count). 4 Byte</span></span><br><span class="line"><span class="type">int</span> max_size_;  <span class="comment">// tree page data max size(not in byte, in count). 4 Byte</span></span><br><span class="line"><span class="type">page_id_t</span> parent_page_id_; <span class="comment">// 4 Byte</span></span><br><span class="line"><span class="type">page_id_t</span> page_id_; <span class="comment">// 4 Byte</span></span><br><span class="line"><span class="comment">// 24 Byte in total</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>internal page的KV对</strong>中：</p>
<ul>
<li>K-比较大小的索引；</li>
<li>V-page_id，指向下一层的节点。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403291930057.png" alt="image-20240329193009583"></p>
<h3 id="B-PLUS-TREE-LEAF-PAGE"><a href="#B-PLUS-TREE-LEAF-PAGE" class="headerlink" title="B_PLUS_TREE_LEAF_PAGE"></a><strong>B_PLUS_TREE_LEAF_PAGE</strong></h3><ul>
<li>对于 Leaf Page 其储存的节点数最大永远是 leaf_max_size - 1，永远存不满、<ul>
<li>对于Leaf Page，直接先插入再分裂；</li>
</ul>
</li>
<li>Header大小为28Byte，多了一个成员变量 <code>next_page_id</code>。</li>
<li><strong>leaf page的KV对</strong>中：<ul>
<li>K-实际的索引；</li>
<li>V-Record ID，用于识别表中的某一条数据。</li>
</ul>
</li>
</ul>
<h2 id="Task-2a-B-Tree-Data-Structure-Insertion-Point-Search"><a href="#Task-2a-B-Tree-Data-Structure-Insertion-Point-Search" class="headerlink" title="Task #2a - B+Tree Data Structure (Insertion, Point Search)"></a>Task #2a - B+Tree Data Structure (Insertion, Point Search)</h2><ul>
<li>目标：实现1）<code>insertion：Insert()</code>；2）<code>Search：Getvalue()</code></li>
</ul>
<blockquote>
<p>index仅支持unique keys。</p>
<p>如果插入会改变树的不变形，需要进行结点的拆分或keys的重组。</p>
<p>若改变了root的page ID，必须更新<code>root_page_id</code>。为此，可以访问构造函数中给出的 <code>header_page_id_</code> 页面。然后，通过使用 <code>reinterpret cast</code>，可以将该页面解释为 <code>BPlusTreeHeaderPage</code>，并从这里更新root的page ID。此外，必须实现 <code>GetRootPageId</code>（目前默认返回 0）。</p>
<p>推荐使用<code>FetchPageBasic</code>来访问页。</p>
</blockquote>
<ul>
<li><p>对于取得的页进行操作：1）根据page_id取得guard；2）将其数据部分<code>data_</code>强制转换成对应的类型（reinterpret_cast&#x2F;As&#x2F;AsMut）。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将内部存储的指针按照指定的类型进行类型转换</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">As</span><span class="params">()</span> -&gt; <span class="type">const</span> T * </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> guard_.<span class="built_in">As</span>&lt;T&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><em><strong>（under analyze）补充</strong></em></p>
<h3 id="src-storage-page-b-plus-tree-internal-page-cpp"><a href="#src-storage-page-b-plus-tree-internal-page-cpp" class="headerlink" title="src&#x2F;storage&#x2F;page&#x2F;b_plus_tree_internal_page.cpp"></a>src&#x2F;storage&#x2F;page&#x2F;b_plus_tree_internal_page.cpp</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ==under analyze 1: FindValue的逻辑</span><br><span class="line">// ==under analyze 2: lambda 表达式 &amp; [comparator]</span><br><span class="line">// ==under analyze 2: std::lower_bound &amp; std::prev</span><br></pre></td></tr></table></figure>

<h3 id="src-storage-page-b-plus-tree-leaf-page-cpp"><a href="#src-storage-page-b-plus-tree-leaf-page-cpp" class="headerlink" title="src&#x2F;storage&#x2F;page&#x2F;b_plus_tree_leaf_page.cpp"></a>src&#x2F;storage&#x2F;page&#x2F;b_plus_tree_leaf_page.cpp</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ==under analyze 1: FindValue的逻辑</span><br></pre></td></tr></table></figure>

<h3 id="src-storage-index-b-plus-tree-cpp"><a href="#src-storage-index-b-plus-tree-cpp" class="headerlink" title="src&#x2F;storage&#x2F;index&#x2F;b_plus_tree.cpp"></a>src&#x2F;storage&#x2F;index&#x2F;b_plus_tree.cpp</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ==under analyze1: emplace_back()</span><br></pre></td></tr></table></figure>

<h1 id="Checkpoint-2-85-points"><a href="#Checkpoint-2-85-points" class="headerlink" title="Checkpoint #2 (85 points)"></a><strong>Checkpoint #2 (85 points)</strong></h1><h2 id="Task-2b-B-Tree-Data-Structure-Deletion"><a href="#Task-2b-B-Tree-Data-Structure-Deletion" class="headerlink" title="Task #2b - B+Tree Data Structure (Deletion)"></a>Task #2b - B+Tree Data Structure (Deletion)</h2><h2 id="Task-3-Index-Iterator"><a href="#Task-3-Index-Iterator" class="headerlink" title="Task #3 - Index Iterator"></a>Task #3 - Index Iterator</h2><h2 id="Task-4-Concurrency-Control"><a href="#Task-4-Concurrency-Control" class="headerlink" title="Task #4 - Concurrency Control"></a>Task #4 - Concurrency Control</h2>]]></content>
      <categories>
        <category>项目</category>
        <category>cmu15-445</category>
      </categories>
  </entry>
</search>
