<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>OpenPose原理</title>
    <url>/2023/12/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/OpenPose%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-前提思考"><a href="#1-前提思考" class="headerlink" title="1 前提思考"></a>1 前提思考</h2><p>1、姿态估计中的关键任务是什么？</p>
<p>识别人体骨干躯干的关键点，并进行定位与拼接。</p>
<p>2、姿态估计中的难点是什么？</p>
<p><strong>（1）遮挡；（2）匹配。</strong></p>
<p>3、COCO数据集的关键点有几个，分别是？</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251524168.png" alt="COCO数据集关键点" style="zoom: 50%;" />

<p>数据集中是<code>17</code>个点，实际上训练时候还要加上<code>1</code>个脖子的点，共<code>18</code>个点。</p>
<p>4、姿态估计方法分为几个大类？</p>
<p>（1）<code>Top-down</code>（自顶向下）：先检测所有的人，再对每个框的人进行姿态估计输出结果</p>
<p>优点：准确率高，点的回归率高；</p>
<p>缺点：算法性能依赖检测效果，复杂度较高，实时性比较差。</p>
<p>主要用于一些离线的项目，对实时性没要求。</p>
<p>（2）<code>bottom-up</code>（自底向上）：先检测所有关键点，再进行匹配连接</p>
<p>优点：计算量较小，可以达到实时性的效果；</p>
<p>缺点：精度较差，匹配策略比较复杂。</p>
<h2 id="2-论文解读"><a href="#2-论文解读" class="headerlink" title="2 论文解读"></a>2 论文解读</h2><p>论文地址：<a href="https://arxiv.org/pdf/1611.08050.pdf">https://arxiv.org/pdf/1611.08050.pdf</a></p>
<h3 id="1、网络框架"><a href="#1、网络框架" class="headerlink" title="1、网络框架"></a>1、网络框架</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251524273.png" alt="网络整体流程图">	<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251532476.jpg" alt="网络框架1"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251534898.png" alt="网络框架2"></p>
<p>其中的重点：</p>
<p>（1）关键点的<code>heatmap</code>标注生成，采用高斯热度图的方式；</p>
<p>（2）<code>PAF</code>：部分亲和域。这也是论文中的重点和难点；</p>
<p>（3）匹配策略：匈牙利匹配。</p>
<h3 id="2、数据制作"><a href="#2、数据制作" class="headerlink" title="2、数据制作"></a>2、数据制作</h3><p>采用的数据集为<code>COCO</code>数据集，其中人体骨骼点的标注信息为<code>[x, y, label]</code>。</p>
<p><code>label</code>取值为<code>0</code>、<code>1</code>、<code>2</code>，分别表示不存在、遮挡、正常，其中不存在的关键点是需要去除的。</p>
<p>（1）关键点高斯热力图实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">putGaussianMaps</span>(<span class="params">center, accumulate_confid_map, sigma, grid_y, grid_x, stride</span>):</span><br><span class="line"></span><br><span class="line">    start = stride / <span class="number">2.0</span> - <span class="number">0.5</span></span><br><span class="line">    y_range = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(grid_y))]</span><br><span class="line">    x_range = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(grid_x))]</span><br><span class="line">    xx, yy = np.meshgrid(x_range, y_range)      <span class="comment"># 构建棋盘</span></span><br><span class="line">    xx = xx * stride + start                    <span class="comment"># 每个点在原始图像上的位置</span></span><br><span class="line">    yy = yy * stride + start</span><br><span class="line">    d2 = (xx - center[<span class="number">0</span>]) ** <span class="number">2</span> + (yy - center[<span class="number">1</span>]) ** <span class="number">2</span>  <span class="comment"># 计算每个点和GT点的距离</span></span><br><span class="line">    exponent = d2 / <span class="number">2.0</span> / sigma / sigma                 <span class="comment"># 这里在做一个高斯计算</span></span><br><span class="line">    mask = exponent &lt;= <span class="number">4.6052</span>                           <span class="comment"># 将在这个阈值范围内的点用True记录</span></span><br><span class="line">    cofid_map = np.exp(-exponent)                       <span class="comment"># 这里做一个标准化</span></span><br><span class="line">    cofid_map = np.multiply(mask, cofid_map)            <span class="comment"># 取出对应关系为True的点</span></span><br><span class="line">    accumulate_confid_map += cofid_map                  <span class="comment"># 将每个点计算的结果都累加到上一次的特征中</span></span><br><span class="line">    accumulate_confid_map[accumulate_confid_map &gt; <span class="number">1.0</span>] = <span class="number">1.0</span>      <span class="comment"># 对结果大于1的值，只取1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> accumulate_confid_map    <span class="comment"># 返回热力图（heatmap）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）PAF数据计算的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">putVecMaps</span>(<span class="params">centerA, centerB, accumulate_vec_map, count, grid_y, grid_x, stride</span>):</span><br><span class="line">    centerA = centerA.astype(<span class="built_in">float</span>)</span><br><span class="line">    centerB = centerB.astype(<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line">    thre = <span class="number">1</span>  <span class="comment"># 表示宽度，也就是一个设定好的参数</span></span><br><span class="line">    centerB = centerB / stride  <span class="comment"># 缩放比例特定到特征图中</span></span><br><span class="line">    centerA = centerA / stride</span><br><span class="line"></span><br><span class="line">    limb_vec = centerB - centerA  <span class="comment"># 求出两个点的向量</span></span><br><span class="line">    norm = np.linalg.norm(limb_vec)  <span class="comment"># 是需要求单位向量，所以先计算范数，也就是向量模长</span></span><br><span class="line">    <span class="keyword">if</span> (norm == <span class="number">0.0</span>):  <span class="comment"># 这里表示两个点基本重合了</span></span><br><span class="line">        <span class="comment"># print &#x27;limb is too short, ignore it...&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> accumulate_vec_map, count</span><br><span class="line">    limb_vec_unit = limb_vec / norm  <span class="comment"># 向量除以模长，得到单位向量</span></span><br><span class="line">    <span class="comment"># print &#x27;limb unit vector: &#123;&#125;&#x27;.format(limb_vec_unit)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># To make sure not beyond the border of this two points</span></span><br><span class="line">    <span class="comment"># 得到所有可能存在方向的区域(这里就用到了之前的超参数阈值)</span></span><br><span class="line">    min_x = <span class="built_in">max</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="built_in">min</span>(centerA[<span class="number">0</span>], centerB[<span class="number">0</span>]) - thre)), <span class="number">0</span>)</span><br><span class="line">    max_x = <span class="built_in">min</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="built_in">max</span>(centerA[<span class="number">0</span>], centerB[<span class="number">0</span>]) + thre)), grid_x)</span><br><span class="line">    min_y = <span class="built_in">max</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="built_in">min</span>(centerA[<span class="number">1</span>], centerB[<span class="number">1</span>]) - thre)), <span class="number">0</span>)</span><br><span class="line">    max_y = <span class="built_in">min</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="built_in">max</span>(centerA[<span class="number">1</span>], centerB[<span class="number">1</span>]) + thre)), grid_y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 得到一个可能存在向量的矩形框</span></span><br><span class="line">    range_x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">int</span>(min_x), <span class="built_in">int</span>(max_x), <span class="number">1</span>))</span><br><span class="line">    range_y = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">int</span>(min_y), <span class="built_in">int</span>(max_y), <span class="number">1</span>))</span><br><span class="line">    xx, yy = np.meshgrid(range_x, range_y)  <span class="comment"># 制作一个网格</span></span><br><span class="line">    ba_x = xx - centerA[<span class="number">0</span>]  <span class="comment"># the vector from (x,y) to centerA 根据位置判断是否在该区域上（分别得到X和Y方向的）</span></span><br><span class="line">    ba_y = yy - centerA[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 向量叉乘根据阈值选择赋值区域，任何向量与单位向量的叉乘即为四边形的面积</span></span><br><span class="line">    <span class="comment"># 这里是重点步骤，也就是论文中的公式，表示计算出两个向量组成四边形的面积</span></span><br><span class="line">    limb_width = np.<span class="built_in">abs</span>(ba_x * limb_vec_unit[<span class="number">1</span>] - ba_y * limb_vec_unit[<span class="number">0</span>])</span><br><span class="line">    mask = limb_width &lt; thre  <span class="comment"># mask is 2D （小于阈值的表示在该区域上）</span></span><br><span class="line"></span><br><span class="line">    vec_map = np.copy(accumulate_vec_map) * <span class="number">0.0</span>  <span class="comment"># 构建一个全为0的矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这行代码主要作用是将mask扩展一个维度并且赋值给vec_map数组</span></span><br><span class="line">    vec_map[yy, xx] = np.repeat(mask[:, :, np.newaxis], <span class="number">2</span>, axis=<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 在该区域上的都用对应的方向向量表示（根据mask结果表示是否在，通过乘法的方式）</span></span><br><span class="line">    vec_map[yy, xx] *= limb_vec_unit[np.newaxis, np.newaxis, :]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># #在特征图中（46*46）中 哪些区域是该躯干所在区域，判断x或者y向量都不为0</span></span><br><span class="line">    mask = np.logical_or.reduce(</span><br><span class="line">        (np.<span class="built_in">abs</span>(vec_map[:, :, <span class="number">0</span>]) &gt; <span class="number">0</span>, np.<span class="built_in">abs</span>(vec_map[:, :, <span class="number">1</span>]) &gt; <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每次返回的accumulate_vec_map都是平均值，现在还原成实际值</span></span><br><span class="line">    accumulate_vec_map = np.multiply(</span><br><span class="line">        accumulate_vec_map, count[:, :, np.newaxis])</span><br><span class="line">    accumulate_vec_map += vec_map  <span class="comment"># 加上当前关键点位置形成的向量</span></span><br><span class="line">    count[mask == <span class="literal">True</span>] += <span class="number">1</span>  <span class="comment"># 该区域计算次数都+1</span></span><br><span class="line"></span><br><span class="line">    mask = count == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    count[mask == <span class="literal">True</span>] = <span class="number">1</span>  <span class="comment"># 没有被计算过的地方就等于自身（因为一会要除法）</span></span><br><span class="line"></span><br><span class="line">    accumulate_vec_map = np.divide(accumulate_vec_map, count[:, :, np.newaxis])  <span class="comment"># 算平均向量</span></span><br><span class="line">    count[mask == <span class="literal">True</span>] = <span class="number">0</span>  <span class="comment"># 还原回去</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> accumulate_vec_map, count</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两个函数是最重要的两个部分，也就是对训练数据的处理，生成出需要的训练数据。</p>
<h3 id="3、预测推理"><a href="#3、预测推理" class="headerlink" title="3、预测推理"></a>3、预测推理</h3><p>预测模型这里，在官方源码中是将<code>paf</code>的处理封装在一个<code>cpp</code>库中，<strong>通过编译得到静态库，代码中可以调用</strong>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">swig -python -c++ pafprocess.i</span><br><span class="line">python3 setup.py build_ext --inplace</span><br></pre></td></tr></table></figure>

<p>这里PAF的处理主要是采用积分计算的方式，也就是对于连线的点的方向选择，采用积分的方式计算最佳连线策略。</p>
]]></content>
      <categories>
        <category>深度学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>vscode相关</title>
    <url>/2023/08/01/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF/vscode%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="1、-vscode连接阿里云如何免密？"><a href="#1、-vscode连接阿里云如何免密？" class="headerlink" title="1、 vscode连接阿里云如何免密？"></a>1、 vscode连接阿里云如何免密？</h1><h2 id="windows端："><a href="#windows端：" class="headerlink" title="windows端："></a><code>windows</code>端：</h2><p>1）在<code>cmd</code>中输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>

<p>在<code>c:\Users\用户名\\.ssh</code>下会生成私钥和公钥。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308021257775.png" alt="image-20230802125702563"></p>
<p>2）复制<code>id_rsa.pub</code>中的内容</p>
<span id="more"></span>

<h2 id="linux端："><a href="#linux端：" class="headerlink" title="linux端："></a><code>linux</code>端：</h2><p>1）输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>生成<code>linux</code>端的密钥，进入<code>/root/.ssh/id_rsa</code>路径下。</p>
<p>2）创建一个文件，名字叫<code>authorized_keys</code></p>
<p>3）把复制的<code>windows</code>公钥粘贴到<code>authorized_keys</code>中，保存退出</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308012055885.png" alt="Snipaste_2023-08-01_20-46-53"></p>
<h1 id="2、Linux环境使用VSCode调试简单C-代码"><a href="#2、Linux环境使用VSCode调试简单C-代码" class="headerlink" title="2、Linux环境使用VSCode调试简单C++代码"></a>2、Linux环境使用VSCode调试简单C++代码</h1><p>参考教程：<a href="https://blog.csdn.net/hypc9709/article/details/129413482?ops_request_misc=&request_id=&biz_id=102&utm_term=vscode%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-129413482.142%5Ev96%5Epc_search_result_base7&spm=1018.2226.3001.4187">Linux环境使用VSCode调试简单C++代码</a></p>
<h2 id="1）终端命令行进行编译、调试"><a href="#1）终端命令行进行编译、调试" class="headerlink" title="1）终端命令行进行编译、调试"></a>1）终端命令行进行编译、调试</h2><h2 id="2）通过VSCode进行编译、调试"><a href="#2）通过VSCode进行编译、调试" class="headerlink" title="2）通过VSCode进行编译、调试"></a>2）通过VSCode进行编译、调试</h2><h3 id="（1）前置条件"><a href="#（1）前置条件" class="headerlink" title="（1）前置条件"></a>（1）前置条件</h3><p>插件<code>C/C++</code>已安装；<code>g++编译器</code>和<code>gdb调试器</code>已安装。</p>
<h3 id="（2）配置tasks-json"><a href="#（2）配置tasks-json" class="headerlink" title="（2）配置tasks.json"></a>（2）配置<code>tasks.json</code></h3><ul>
<li><p>在<code>VSCode</code>的主菜单中，选择<code>Terminal&gt;Configure Default Build Task</code></p>
</li>
<li><p>出现一个下拉菜单，显示<code>C++</code>编译器的各种预定义编译任务。选择<code>C/C++: g++ build active file</code>（如果配置了中文，会显示<code>C/C++: g++ 生成活动文件</code>）</p>
</li>
<li><p>选择后，<code>VSCode</code>会自动生成一个<code>.vscode</code>文件夹和<code>tasks.json</code>文件，如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312071610116.png" alt="image-20231207144919415"></p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++ 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/g++&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>tasks.json</code>的作用是告诉<code>VSCode</code>如何编译程序，因此从其中的<code>Command</code>和<code>args</code>可以看出，实际上是执行了以下命令：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/usr/bin/g++ -g $&#123;file&#125; -o $&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li><code>$&#123;file&#125;</code>：当前活动文件是<code>VSCode</code>当前查看的文件，如<code>Main.cpp</code>；</li>
<li><code>$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;</code>：用于获取当前文件的目录和不包含扩展名的文件名，如<code>Main</code>。</li>
</ul>
<h3 id="（3）执行编译"><a href="#（3）执行编译" class="headerlink" title="（3）执行编译"></a>（3）执行编译</h3><ul>
<li><p><strong>回到需要执行编译的文件</strong>（这一步很重要，否则<code>\$&#123;file&#125;</code>和<code>$&#123;fileDirname&#125;</code>这些变量都会错）；</p>
</li>
<li><p>快捷键<code>ctrl+shift+B</code>或从菜单中选择运行：<strong>Terminal -&gt; Run Build Task</strong>，即可执行<code>tasks.json</code>中指定的编译过程；</p>
<p>编译任务完成后，会出现终端提示，对于成功的g++编译，输出如下：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312071609602.png" alt="image-20231207150223290"></p>
<p>（这里我将<code>tasks.json</code>中的<code>&quot;$&#123;file&#125;&quot;</code>项更改为<code>&quot;$&#123;fileDirname&#125;/*.cpp&quot;</code></p>
<h3 id="（4）调试文件"><a href="#（4）调试文件" class="headerlink" title="（4）调试文件"></a>（4）调试文件</h3><p>对需要调试的文件设置断点，选择<code>Debug C/C++ file</code>进行调试。</p>
<h3 id="（5）个性化配置launch-json"><a href="#（5）个性化配置launch-json" class="headerlink" title="（5）个性化配置launch.json"></a>（5）个性化配置<code>launch.json</code></h3><blockquote>
<p>这里<code>launch.json</code>的作用就是告诉<code>VSCode</code>如何调用<code>gdb调试器</code>。</p>
</blockquote>
<p>如果想要在调试&#x2F;运行程序时添加参数，只需要把参数添加在<code>&quot;args&quot;</code>选项中即可。</p>
<h4 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h4><p>在<code>VSCode</code>中编译、调试一个简单的<code>.cpp</code>文件，所需要做的就是：</p>
<ol>
<li>在<code>tasks.json</code>中调用<code>g++</code>生成一个可执行二进制文件；</li>
<li>在<code>launch.json</code>中调用<code>gdb</code>对生成的可执行文件进行调试。</li>
</ol>
<h3 id="（7）复用C-配置"><a href="#（7）复用C-配置" class="headerlink" title="（7）复用C++配置"></a>（7）复用C++配置</h3><p>上面的过程已经完成了在<code>VSCode</code>中调试<code>Linux</code>环境下的<code>C++</code>代码的配置，但只适用于当前工作空间。</p>
<p>如果想要在其他的工程文件夹下复用这种配置，只需要把<code>tasks.json</code>和<code>launch.json</code>文件复制到新文件夹下的<code>.vscode</code>目录下，然后根据需要改变对应的源文件和可执行文件的名称即可。</p>
<h1 id="3、VSCode自动生成头文件的-ifndef-define-endif"><a href="#3、VSCode自动生成头文件的-ifndef-define-endif" class="headerlink" title="3、VSCode自动生成头文件的 #ifndef #define #endif"></a>3、VSCode自动生成头文件的 #ifndef #define #endif</h1><p>参考这篇博客：<a href="https://blog.csdn.net/p1279030826/article/details/123851420">VSCode自动生成头文件的 #ifndef #define #endif</a></p>
]]></content>
      <categories>
        <category>报错信息</category>
      </categories>
  </entry>
  <entry>
    <title>hexo相关报错</title>
    <url>/2023/07/30/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF/hexo%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="1、OpnSSL-SSL-read-Connection-was-reset-errno-10054"><a href="#1、OpnSSL-SSL-read-Connection-was-reset-errno-10054" class="headerlink" title="1、OpnSSL SSL_read: Connection was reset, errno 10054"></a>1、OpnSSL SSL_read: Connection was reset, errno 10054</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/hioomph/hioomph.github.io.git/&#x27;: OpnSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure>

<h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>一般是这是因为服务器的SSL证书没有经过第三方机构的签署，所以才报错</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>解除ssl验证后，再上传就OK了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2、Error-Spawn-failed"><a href="#2、Error-Spawn-failed" class="headerlink" title="2、Error: Spawn failed"></a>2、Error: Spawn failed</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error: Spawn failed</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (D:\blog\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">    at ChildProcess.emit (node:events:514:28)</span><br><span class="line">    at cp.emit (D:\blog\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">    at ChildProcess._handle.onexit (node:internal/child_process:291:12)</span><br></pre></td></tr></table></figure>

<h3 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h3><p>hexo的_config.yml配置里git仓库地址填写错误，应将https方式改成ssh方式</p>
<h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  # repository: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git  # https方式</span><br><span class="line">  repository: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git		  # ssh方式</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>报错信息</category>
      </categories>
  </entry>
  <entry>
    <title>《操作系统》</title>
    <url>/2023/08/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="1、终端与进程组"><a href="#1、终端与进程组" class="headerlink" title="1、终端与进程组"></a>1、终端与进程组</h2><h3 id="（1）终端"><a href="#（1）终端" class="headerlink" title="（1）终端"></a>（1）终端</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031335344.png" alt="image-20230803133540713"></p>
<h4 id="1）运行前台进程-sleep-3000"><a href="#1）运行前台进程-sleep-3000" class="headerlink" title="1）运行前台进程 sleep 3000"></a>1）运行前台进程 <code>sleep 3000</code></h4><h4 id="2）运行后台进程-sleep-3000"><a href="#2）运行后台进程-sleep-3000" class="headerlink" title="2）运行后台进程 sleep 3000 &amp;"></a>2）运行后台进程 <code>sleep 3000 &amp;</code></h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031337505.png" alt="image-20230803133741336"></p>
<h4 id="3）查看后台进程-jobs"><a href="#3）查看后台进程-jobs" class="headerlink" title="3）查看后台进程 jobs"></a>3）查看后台进程 <code>jobs</code></h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031340236.png" alt="image-20230803134010984"></p>
<h4 id="4）将后台进程变为前台进程-fg"><a href="#4）将后台进程变为前台进程-fg" class="headerlink" title="4）将后台进程变为前台进程 fg +%&lt;进程编号&gt;"></a>4）将后台进程变为前台进程 <code>fg +%&lt;进程编号&gt;</code></h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031340037.png" alt="image-20230803134030968"></p>
<h4 id="5）查看当前终端名字-tty"><a href="#5）查看当前终端名字-tty" class="headerlink" title="5）查看当前终端名字 tty"></a>5）查看当前终端名字 <code>tty</code></h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031341611.png" alt="image-20230803134150192"></p>
<h3 id="（2）进程组"><a href="#（2）进程组" class="headerlink" title="（2）进程组"></a>（2）进程组</h3><p>其中，<code>PGID</code>即为进程组<code>ID</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031346173.png" alt="image-20230803134636774"></p>
<span id="more"></span>

<h2 id="2、会话"><a href="#2、会话" class="headerlink" title="2、会话"></a>2、会话</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 测试setsid和geysid</span><br><span class="line">int main() &#123;</span><br><span class="line">    pid_t pid = -1;</span><br><span class="line"></span><br><span class="line">    // 获取当前进程组会话ID</span><br><span class="line">    pid = getsid(0);</span><br><span class="line">    if(-1 == pid)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;getsid&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;sid:%d\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sid:620400</span><br></pre></td></tr></table></figure>

<p>此时，若以当前进程创建会话，会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 测试setsid和geysid</span><br><span class="line">int main() &#123;</span><br><span class="line">    pid_t pid = -1;</span><br><span class="line"></span><br><span class="line">    // 获取当前进程组会话ID</span><br><span class="line">    pid = getsid(0);</span><br><span class="line">    if(-1 == pid)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;getsid&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;sid:%d\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    // 新建一个会话</span><br><span class="line">    pid = setsid();</span><br><span class="line">    if(-1 == pid)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;setsid&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;sid:%d\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>报错为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sid:620400</span><br><span class="line">setsid: Operation not permitted</span><br></pre></td></tr></table></figure>

<p>查看当前进程的<code>PID</code>和<code>PGID</code>可以发现</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031401546.png" alt="image-20230803140116366"></p>
<p>当前<code>test</code>本身就是一个组长（<code>PID</code>和<code>PGID</code>一致），所以新建一个会话时报错，因为<strong>创建会话时，调用进程不能是进程组的组长，因为这个进程会变成新会话的首进程（组长）</strong>。</p>
<h2 id="3、daemon进程"><a href="#3、daemon进程" class="headerlink" title="3、daemon进程"></a>3、daemon进程</h2><p>又称守护进程、精灵进程。</p>
<p><code>daemon进程</code>的特点：</p>
<p>1）独立于控制终端；</p>
<p>2）名字一般以<code>d</code>结尾；</p>
<p>3）所有的服务存在于<code>etc/init.d</code></p>
<p>4）是一个特殊的孤儿进程；</p>
<p>5）输入被关闭，输出存在于日志中：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031134687.png" alt="image-20230803113433643"></p>
<h2 id="4、nohup和-命令使进程忽略hangup（挂起）信号"><a href="#4、nohup和-命令使进程忽略hangup（挂起）信号" class="headerlink" title="4、nohup和&amp;命令使进程忽略hangup（挂起）信号"></a>4、nohup和&amp;命令使进程忽略hangup（挂起）信号</h2><p>1）创建一个一般进程</p>
<p>使用<code>tail</code>命令跟踪<code>/var/log/syslog</code>文件</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031135972.png" alt="image-20230803113507931"></p>
<p>2）查看当前<code>tail</code>进程是否存在</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031136769.png" alt="image-20230803113609741"></p>
<p>3）此时若关闭掉<code>tail</code>进程所在的终端，则该进程自动结束。为了使得关闭终端进程依旧可以运行，使用<code>nohup+&amp;</code>指令（此时处于关闭掉tail进程所在终端的状态）</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031148740.png" alt="image-20230803114850706"></p>
<p>输出被追加到<code>nohup.out</code>中</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031149569.png" alt="image-20230803114920537"></p>
<p>此时用<code>ps -ef</code>过滤，仍然有<code>tail</code>进程</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031149918.png" alt="image-20230803114957901"></p>
<p>此时，关闭终端（执行<code>nohup</code>的那个终端），再调用<code>ps -ef</code>，<code>tail</code>进程仍存在，但此时它变为孤儿进程，其父进程分配为<code>1</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031258186.png" alt="image-20230803125857148"></p>
<p>查看当前进程的标准输入和标准输出，可以看到，输入<code>（0）</code>被关闭，输出<code>（1、2）</code>被定向到<code>nohup.out</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031301970.png" alt="image-20230803130115916"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>《数据结构（严蔚敏）》_b站鲍松山</title>
    <url>/2023/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%A5%E8%94%9A%E6%95%8F%EF%BC%89%E3%80%8B_b%E7%AB%99%E9%B2%8D%E6%9D%BE%E5%B1%B1/</url>
    <content><![CDATA[<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><p>数据结构（Data Struct）：数据之间的组织架构&#x2F;结构。</p>
<blockquote>
<p><strong>DS：</strong></p>
<ul>
<li><strong>线性结构</strong><ul>
<li><strong>SeqList&#x2F;List&#x2F;Stack&#x2F;Queue&#x2F;String&#x2F;Array</strong></li>
</ul>
</li>
<li><strong>非线性结构</strong><ul>
<li><strong>Tree&#x2F;Graph</strong></li>
</ul>
</li>
<li><strong>排序&#x2F;搜索</strong></li>
<li><strong>算法</strong></li>
</ul>
</blockquote>
<span id="more"></span>

<h1 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2 线性表"></a>2 线性表</h1><h2 id="2-1-顺序表（SeqList）"><a href="#2-1-顺序表（SeqList）" class="headerlink" title="2.1 顺序表（SeqList）"></a>2.1 顺序表（SeqList）</h2><p>顺序表通过一组地址连续的空间对数据进行存储。</p>
<h2 id="2-2-单链表（List）"><a href="#2-2-单链表（List）" class="headerlink" title="2.2 单链表（List）"></a>2.2 单链表（List）</h2><p>不要求逻辑上相邻的元素在物理位置上也相邻，因此无法实现随机存取。</p>
<p>分清“谁的谁是谁”。 </p>
<p>操作时要时刻注意<code>last</code>这一项。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120918067.png" alt="image-20231212091813193" style="zoom: 33%;" />

<p><strong>头部插入时易错：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(List *<span class="built_in">list</span>, ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *s = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    assert(s != <span class="literal">NULL</span>);</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="built_in">list</span>-&gt;first-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;first-&gt;next = s;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下图所示，当使用头插法向<code>空list</code>中插入<code>1</code>后，<code>list-&gt;last</code>仍然指向头结点。‘</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915222.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915816.png" alt="2"></p>
<p> 对<code>pop_front</code>进行修改，加入对<code>size</code>的判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">list</span>-&gt;last = s; <span class="comment">// 当list为空时，对last进行移动</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915584.png" alt="3"></p>
<p><strong>头部删除时同理</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_front</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Node *p = <span class="built_in">list</span>-&gt;first-&gt;next;</span><br><span class="line">    <span class="built_in">list</span>-&gt;first-&gt;next = <span class="built_in">list</span>-&gt;first-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">list</span>-&gt;last = <span class="built_in">list</span>-&gt;first;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-静态链表（StaticList）"><a href="#2-3-静态链表（StaticList）" class="headerlink" title="2.3 静态链表（StaticList）"></a>2.3 静态链表（StaticList）</h2><p>使用<strong>静态链表</strong>可以便于在不设<em>指针</em>类型的高级程序设计语言中使用链表结构。</p>
<p>静态链表实际上就是用数组去模拟链表。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915948.png" alt="4" style="zoom: 67%;" />

<p>这里的<code>pool</code>指明下一个备用空间的地址。</p>
<h2 id="2-4-单循环链表（SCList）"><a href="#2-4-单循环链表（SCList）" class="headerlink" title="2.4 单循环链表（SCList）"></a>2.4 单循环链表（SCList）</h2><p>特点：尾节点指向头节点，整个链表形成一个环。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312121129584.png" alt="image-20231212112956184" style="zoom:33%;" />

<p>循环链表的操作和线性链表基本一致,差别仪在于算法中的循环条件不是<code>p</code>或<code>p-&gt;next</code>是否为空，而是它们是否等于头指针。但有的时候，若在循环链表中设立尾指针而不设头指针，可使某些操作简化。例如将两个线性表合并成一个表时，仅需将一个表的表尾和另一个表的表头相接。</p>
<p>初始化时，注意：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>-&gt;first = <span class="built_in">list</span>-&gt;last = s;</span><br><span class="line"><span class="built_in">list</span>-&gt;last-&gt;next = <span class="built_in">list</span>-&gt;first;</span><br><span class="line"><span class="built_in">list</span>-&gt;size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120928507.png" alt="image-20231212092812466"></p>
<p>尾插时的各节点地址：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120954889.png" alt="image-20231212095457800"  />

<p><strong>掌握按值删除这里的的思想：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按值删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_val</span><span class="params">(List *<span class="built_in">list</span>, ElemType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Node *p = find(<span class="built_in">list</span>, key);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;要删除的数据不存在！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p == <span class="built_in">list</span>-&gt;last)</span><br><span class="line">        pop_back(<span class="built_in">list</span>);</span><br><span class="line">    <span class="comment">////////////////////////////////***</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 即不是删除当前节点，而是将下一个节点的值赋值给当前节点，然后删除下一个节点</span></span><br><span class="line">        <span class="comment">// 这样做避免从头遍历链表</span></span><br><span class="line">        Node *q = p-&gt;next;</span><br><span class="line">        p-&gt;data = q-&gt;data;</span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        <span class="built_in">list</span>-&gt;size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">////////////////////////////////***</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>申请节点：Node *s<br>遍历节点：Node *p<br>删除节点：Node *q</p>
</blockquote>
<h2 id="2-5-双向链表（DList）"><a href="#2-5-双向链表（DList）" class="headerlink" title="2.5 双向链表（DList）"></a>2.5 双向链表（DList）</h2><p>每次操作时涉及4个指针：</p>
<ul>
<li>当前节点的前驱；</li>
<li>当前节点的后继；</li>
<li>前一个节点的后继；</li>
<li>后一个节点的前驱。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312131154818.png" alt="image-20231213115430268" style="zoom:33%;" />

<h2 id="2-6-双向循环链表（DCList）"><a href="#2-6-双向循环链表（DCList）" class="headerlink" title="2.6 双向循环链表（DCList）"></a>2.6 双向循环链表（DCList）</h2><p>存在两个环。</p>
<p><strong>环1是<code>list-&gt;last-&gt;next</code></strong></p>
<p><strong>环2是<code>list-&gt;first-&gt;prev</code></strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312140920009.png" alt="image-20231214092024742" style="zoom: 25%;" />

<h1 id="3-栈和队列"><a href="#3-栈和队列" class="headerlink" title="3 栈和队列"></a>3 栈和队列</h1><h2 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h2><p><strong>栈和队列的基本操作是线性表操作的子集，是操作受限的线性表。</strong></p>
<p>栈：限定仅在表尾插入或删除操作的线性表。表尾称为<strong>栈顶</strong>，表头称为<strong>栈底</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312141056107.png" alt="image-20231214105656926" style="zoom: 25%;" />

<h3 id="3-1-1-顺序栈（SeqStack）"><a href="#3-1-1-顺序栈（SeqStack）" class="headerlink" title="3.1.1 顺序栈（SeqStack）"></a>3.1.1 顺序栈（SeqStack）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312141103006.png" alt="image-20231214110346157" style="zoom:25%;" />

<h3 id="3-1-2-链栈（LinkStack）"><a href="#3-1-2-链栈（LinkStack）" class="headerlink" title="3.1.2 链栈（LinkStack）"></a>3.1.2 链栈（LinkStack）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312151207109.png" alt="image-20231215120659701" style="zoom:25%;" />

<h3 id="3-1-3-栈的应用"><a href="#3-1-3-栈的应用" class="headerlink" title="3.1.3 栈的应用"></a>3.1.3 栈的应用</h3><h4 id="1、数制转换"><a href="#1、数制转换" class="headerlink" title="1、数制转换"></a>1、数制转换</h4><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312151258969.png" alt="image-20231215125804838" style="zoom:67%;" />

<p>由于结果要从下往上读取，因此用一个栈来依次存放余数。最终依次取栈顶元素，就可以得到转换后的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;SeqStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数制转换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Convert_8</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqStack st;</span><br><span class="line">    InitStack(&amp;st);</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;st, value%<span class="number">8</span>);</span><br><span class="line">        value /= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Show(&amp;st);</span></span><br><span class="line">    <span class="keyword">while</span> (!(IsEmpty(&amp;st)))</span><br><span class="line">    &#123;</span><br><span class="line">        GetTop(&amp;st, &amp;v);</span><br><span class="line">        Pop(&amp;st);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.数制转换 ElemType int</span></span><br><span class="line">    <span class="type">int</span> value = <span class="number">47183</span>;</span><br><span class="line">    Convert_8(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、括号匹配"><a href="#2、括号匹配" class="headerlink" title="2、括号匹配"></a>2、括号匹配</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 括号匹配</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Check</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqStack st;</span><br><span class="line">    InitStack(&amp;st);</span><br><span class="line">    <span class="type">char</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">&#x27;[&#x27;</span> || *str == <span class="string">&#x27;&#123;&#x27;</span> || *str == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            Push(&amp;st, *str);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetTop(&amp;st, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Pop(&amp;st);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetTop(&amp;st, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Pop(&amp;st);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetTop(&amp;st, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Pop(&amp;st);</span><br><span class="line">        &#125; </span><br><span class="line">        *str++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IsEmpty(&amp;st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2.括号匹配 ElemType char</span></span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;[([][])]&quot;</span>; <span class="comment">// char *str    str是一个指向字符数组的指针</span></span><br><span class="line">    <span class="type">bool</span> flag = Check(str);</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Ok!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、行编辑程序"><a href="#3、行编辑程序" class="headerlink" title="3、行编辑程序"></a>3、行编辑程序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 3.行编辑程序</span></span><br><span class="line">    SeqStack st;</span><br><span class="line">    InitStack(&amp;st);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch != <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(ch !=<span class="string">&#x27;$&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(ch)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    Pop(&amp;st);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">                    Clear(&amp;st);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    Push(&amp;st, ch);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        Print(&amp;st);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    Destroy(&amp;st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-队列（LinkQueue）"><a href="#3-2-队列（LinkQueue）" class="headerlink" title="3.2 队列（LinkQueue）"></a>3.2 队列（LinkQueue）</h2><p>先进先出的结构。</p>
<p>最典型的队列例子是<strong>操作系统中的作业排队</strong>。</p>
<p>队列可分为单端队列和双端队列，但双端队列实际上远不及栈和单端队列有用。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161259625.png" alt="image-20231216125953859" style="zoom: 25%;" />

<h3 id="3-2-1-链队列（LinkQueue）"><a href="#3-2-1-链队列（LinkQueue）" class="headerlink" title="3.2.1 链队列（LinkQueue）"></a>3.2.1 链队列（LinkQueue）</h3><p>由两个分别指向队头和队尾的指针唯一确定一个队列。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161300828.png" alt="image-20231216130008621" style="zoom:20%;" />

<h3 id="3-2-2-顺序队列（SeqQueue）实现循环队列"><a href="#3-2-2-顺序队列（SeqQueue）实现循环队列" class="headerlink" title="3.2.2 顺序队列（SeqQueue）实现循环队列"></a>3.2.2 顺序队列（SeqQueue）实现循环队列</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161300215.png" alt="image-20231216130020025" style="zoom:25%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161300091.png" alt="image-20231216130034444" style="zoom: 33%;" />

<h1 id="4-串"><a href="#4-串" class="headerlink" title="4 串"></a>4 串</h1><p><code>C</code>语言实际上不存在字符串的概念。它是通过相应的字符指针指向一串字符。</p>
<p>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>而在<code>C++</code>中则出现了<code>string</code>类型，它实际上是一个用类实现的数据结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>串的定义：串（<code>string</code>）（或字符串）是由零个或多个字符组成的有限序列。</p>
<p>一般对串的整体进行操作，而不是对其中的单个元素进行操作。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312182049251.png" alt="image-20231218204922589" style="zoom: 25%;" />

<h2 id="4-1-定长顺序存储方式（StackString）"><a href="#4-1-定长顺序存储方式（StackString）" class="headerlink" title="4.1 定长顺序存储方式（StackString）"></a>4.1 定长顺序存储方式（StackString）</h2><p>定长的方式：<strong>先开辟的定长数组</strong>描述字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRLEN 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> u_char unsigned char</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> u_char SString[MAXSTRLEN+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<h2 id="4-2-堆分配存储方式（HeapString）"><a href="#4-2-堆分配存储方式（HeapString）" class="headerlink" title="4.2 堆分配存储方式（HeapString）"></a>4.2 堆分配存储方式（HeapString）</h2><p>仍以一组地址连续的存储单元存放串值字符序列，但其存储空间在程序执行过程中动态分配而得。用<code>malloc()</code>来为新产生的串分配存储空间，并约定串长也作为存储结构的一部分。</p>
<p>函数内部四步：</p>
<ul>
<li>条件判断（不满足条件直接返回）</li>
<li>空间判断（涉及操作的串的空间是否需要赋空，<code>free</code>）</li>
<li>空间分配（给串分配空间，<code>malloc</code>)</li>
<li>赋值操作</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312182049570.png" alt="image-20231218204932225" style="zoom: 33%;" />

<h1 id="5-数组和广义表"><a href="#5-数组和广义表" class="headerlink" title="5 数组和广义表"></a>5 数组和广义表</h1><h2 id="5-1-矩阵的压缩存储（SparseMatrix）"><a href="#5-1-矩阵的压缩存储（SparseMatrix）" class="headerlink" title="5.1 矩阵的压缩存储（SparseMatrix）"></a>5.1 矩阵的压缩存储（SparseMatrix）</h2><p>感兴趣的不是矩阵本身，而是如何存储矩阵的元，使得矩阵进行各项运算。</p>
<p>压缩存储：为多个值相同的元只分配一个存储空间；对零元不分配存储空间。假若值相同的元素或者零元素在矩阵中的分布有一定规律，称为<strong>特殊矩阵</strong>；反之，称为<strong>稀疏矩阵</strong>。</p>
<p><strong>压缩存储时，需要用一个三元组<code>(i,j,aij)</code>唯一确定矩阵A的一个非零元，即除了存储非零元的值<code>aij</code>外，还需要存储其所在行和列的位置<code>(i,j)</code>。</strong></p>
<p>稀疏矩阵的压缩存储示例：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312191547788.png" alt="image-20231219154712437" style="zoom:80%;" />

<h2 id="5-2-矩阵的快速转置算法实现"><a href="#5-2-矩阵的快速转置算法实现" class="headerlink" title="5.2 矩阵的快速转置算法实现"></a>5.2 矩阵的快速转置算法实现</h2><ul>
<li><p>（1）交换矩阵的行列值；</p>
</li>
<li><p>（2）交换三元组中的<code>i</code>和<code>j</code>；</p>
</li>
<li><p><strong>（3）重排三元组之间的次序。—-重点！</strong></p>
<ul>
<li>实现方法1：较为笨拙的重复遍历</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312192015890.png" alt="image-20231219201524473" style="zoom: 33%;" />

<ul>
<li><p>实现方法2：快速转置算法</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312192039855.png" alt="image-20231219203949650" style="zoom: 50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矩阵快速转置（实现方法2）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FastTransposeMatrix</span><span class="params">(SparseMatrix *M, SparseMatrix *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    T-&gt;mu = M-&gt;nu;</span><br><span class="line">    T-&gt;nu = M-&gt;mu;</span><br><span class="line">    T-&gt;tu = M-&gt;tu;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *num = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * M-&gt;nu);  <span class="comment">// M中每一列非零元的个数</span></span><br><span class="line">    assert(num != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">int</span> *cpot = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * M-&gt;nu);  <span class="comment">// M中每一列的第一个非零元对应三元组空间所在位置</span></span><br><span class="line">    assert(cpot != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;tu != <span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 初始化num数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>; col&lt;M-&gt;nu; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            num[col] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>; t&lt;M-&gt;tu; ++t)</span><br><span class="line">        &#123;</span><br><span class="line">            num[M-&gt;data[t].j]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化cpot数组</span></span><br><span class="line">        cpot[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">1</span>; col&lt;M-&gt;nu; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            cpot[col] = cpot[col<span class="number">-1</span>] + num[col<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行转置映射</span></span><br><span class="line">        <span class="type">int</span> col = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> kt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> km=<span class="number">0</span>; km&lt;M-&gt;tu; ++km)</span><br><span class="line">        &#123;</span><br><span class="line">            col = M-&gt;data[km].j;</span><br><span class="line">            kt = cpot[col];</span><br><span class="line">            T-&gt;data[kt].i = M-&gt;data[km].j;</span><br><span class="line">            T-&gt;data[kt].j = M-&gt;data[km].i;</span><br><span class="line">            T-&gt;data[kt].e = M-&gt;data[km].e;</span><br><span class="line">            cpot[col]++; <span class="comment">// 重要步骤</span></span><br><span class="line">            kt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在C中，如果使用了动态内存分配函数如malloc、calloc或realloc来分配内存</span></span><br><span class="line">    <span class="comment">// 那么最终应该使用 free 函数来释放已分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(num);</span><br><span class="line">    <span class="built_in">free</span>(cpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="5-3-广义表（GenList"><a href="#5-3-广义表（GenList" class="headerlink" title="5.3 广义表（GenList)"></a>5.3 广义表（GenList)</h2><blockquote>
<p><strong>所谓的广义表实际上就是一个递归概念。</strong></p>
<p><strong>1、处理tag&#x3D;&#x3D;ATOM的节点；</strong></p>
<p><strong>2、对子表进行递归操作；</strong></p>
<ul>
<li><strong>找到子表中的tag&#x3D;&#x3D;ATOM的节点并处理；</strong></li>
<li><strong>对剩下的节点组成的新的子表重复步骤2，直至子表中不存在节点。</strong></li>
</ul>
</blockquote>
<h3 id="1、含义"><a href="#1、含义" class="headerlink" title="1、含义"></a>1、含义</h3><p>线性表的推广。简单来说就是<strong>表中有表</strong>。</p>
<p>因此，有一个概念要尤其注意，<strong>即广义表是由无数个广义表组成的自身。</strong></p>
<h3 id="2、定义"><a href="#2、定义" class="headerlink" title="2、定义"></a>2、定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LS=(a1,a2,...an)</span><br></pre></td></tr></table></figure>

<p>其中，<code>ai(1&lt;=i&lt;=n)</code>可以是单个元素，也可以是广义表，分别称为<strong>原子</strong>和<strong>子集</strong>。当广义表非空时，<code>a1</code>称为表头（<code>Head</code>），其余元素组成的表<code>(a2,a3,...,an)</code>称为表尾（<code>Tail</code>）。</p>
<p><strong>举例：</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312200930160.png" alt="image-20231220093015065"></p>
<p><strong>注意：</strong>           </p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312200931491.png" alt="image-20231220093159352"></p>
<h3 id="3、存储结构"><a href="#3、存储结构" class="headerlink" title="3、存储结构"></a>3、存储结构</h3><p>由于表中的数据元素可以具有不同结构，因此一般采用<strong>链式存储方式</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312201010034.png" alt="image-20231220101006602" style="zoom: 33%;" />

<h2 id="5-4-表头分割算法"><a href="#5-4-表头分割算法" class="headerlink" title="5.4 表头分割算法"></a>5.4 表头分割算法</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312201628127.png" alt="image-20231220162815397" style="zoom: 33%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建广义表：通过字符串str来创建广义表gl</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateGenList</span><span class="params">(GenList &amp;gl, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(str);  <span class="comment">// 求解字符串长度</span></span><br><span class="line">	<span class="comment">// 存储表内元素</span></span><br><span class="line">	<span class="type">char</span> *sub = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (n<span class="number">-2</span>));</span><br><span class="line">	<span class="comment">// 存储表头</span></span><br><span class="line">	<span class="type">char</span> *hsub = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (n<span class="number">-2</span>));</span><br><span class="line">	assert(sub!=<span class="literal">NULL</span> &amp;&amp; hsub!=<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &quot;1,2,3&quot;</span></span><br><span class="line">	<span class="comment">// 去掉sub左右两边的括号</span></span><br><span class="line">	<span class="built_in">strncpy</span>(sub,str+<span class="number">1</span>,n<span class="number">-2</span>); </span><br><span class="line">	sub[n<span class="number">-2</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//加上结束符</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断广义表是否为空</span></span><br><span class="line">	<span class="keyword">if</span>(gl == <span class="literal">NULL</span>)  <span class="comment">// 为空</span></span><br><span class="line">	&#123;   </span><br><span class="line">		<span class="comment">//  创建头结点(广义表的第一个结点为头结点，其余都为尾结点)</span></span><br><span class="line">		gl = (GLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GLNode));</span><br><span class="line">		assert(gl != <span class="literal">NULL</span>);</span><br><span class="line">		gl-&gt;tag = HEAD;  <span class="comment">// 结点标记为头结点</span></span><br><span class="line">		gl-&gt;hp = gl-&gt;tp = <span class="literal">NULL</span>;  <span class="comment">// 把子表指针和尾指针都指向空</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	GLNode *p = gl;  <span class="comment">// 为了不丢失gl的指向，定义一个指针来操作</span></span><br><span class="line">	<span class="comment">// 求子串长度，当sub长度不为零时，说明广义表还未创建完成</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">strlen</span>(sub) != <span class="number">0</span>)</span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="comment">//  采用尾插法,在后面插入结点</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			1、创建一个结点</span></span><br><span class="line"><span class="comment">			2、让p所指结点的尾指针指向新建的结点</span></span><br><span class="line"><span class="comment">			3、让p指向新建结点</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		p = p-&gt;tp = (GLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GLNode));</span><br><span class="line">		assert(p != <span class="literal">NULL</span>);</span><br><span class="line">		p-&gt;hp = p-&gt;tp = <span class="literal">NULL</span>;  <span class="comment">// 将新建结点的子表指针和尾指针都赋空</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//  &quot;1,2,3&quot;     ==&gt;  &quot;1&quot;      hsub=&quot;1&quot;  sub=&quot;2,3&quot;;</span></span><br><span class="line">		<span class="comment">//  &quot;(1,2),3,4&quot; ==&gt;  &quot;(1,2)&quot;  hsub=&quot;(1,2)&quot; sub=&quot;3,4&quot;</span></span><br><span class="line">		<span class="keyword">if</span>(sever(sub,hsub))  <span class="comment">// sever函数分离表头，并将表头存入hsub中</span></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 对分离出来的表头进行判断，是否包含括号</span></span><br><span class="line">			<span class="keyword">if</span>(hsub[<span class="number">0</span>] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 说明要创建的结点是子表类型</span></span><br><span class="line">				p-&gt;tag = CHILDLIST;  <span class="comment">// 设置子表标记</span></span><br><span class="line">				CreateGenList(p-&gt;hp,hsub);  <span class="comment">// 在p的表头结点处，创建hsub子表</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 说明要创建的结点是原子类型</span></span><br><span class="line">				p-&gt;tag = ATOM;  <span class="comment">// 设置原子标记</span></span><br><span class="line">				p-&gt;atom = atoi(hsub);  <span class="comment">// 将表头字符串转换成整型数据，赋值给原子数据</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广义表表头分割函数，将sub中的表头分割到hsub中</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sever</span><span class="params">(<span class="type">char</span> *sub, <span class="type">char</span> *hsub)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//  判断sub是否为空</span></span><br><span class="line">	<span class="keyword">if</span>(*sub==<span class="string">&#x27;\0&#x27;</span> || <span class="built_in">strcmp</span>(sub,<span class="string">&quot;()&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 是 情况：&quot;&quot;  或  &quot;()&quot;</span></span><br><span class="line">		hsub[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 将hsub赋空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(sub);  <span class="comment">// 求sub的长度</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch = sub[<span class="number">0</span>];  <span class="comment">// 获取第一个字符</span></span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;  <span class="comment">// 表示括号的信息</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        当sub还没遍历完成且还未检测到括号外的逗号，继续遍历</span></span><br><span class="line"><span class="comment">	    注：当检测到括号外的逗号时，说明找到表头分割点，如：&quot;(1,2),3,4&quot; 表头即为(1,2)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;n &amp;&amp; (ch!=<span class="string">&#x27;,&#x27;</span>|| k!=<span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 判断是否运到左括号</span></span><br><span class="line">		<span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">			k++;  <span class="comment">// k++表示进入一层括号</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;)&#x27;</span>)  <span class="comment">// 判断是否遇到右括号</span></span><br><span class="line">			k--;   <span class="comment">// k--表示退出一层括号</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取下一个元素</span></span><br><span class="line">		i++;</span><br><span class="line">		ch = sub[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断是否是因为检测到括号外的逗号而结束的</span></span><br><span class="line">	<span class="keyword">if</span>(i &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 是</span></span><br><span class="line">		<span class="comment">// 在i位置截断，前面部分就是表头</span></span><br><span class="line">		sub[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="comment">// 将取得的表头放入hsub中</span></span><br><span class="line">		<span class="built_in">strcpy</span>(hsub,sub);</span><br><span class="line">		<span class="comment">// 更新sub的值：此时的sub应该去掉表头hsub</span></span><br><span class="line">		<span class="built_in">strcpy</span>(sub,sub+i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(k != <span class="number">0</span>)  <span class="comment">// 判断是否是因为内部括号不匹配</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 是，分割失败</span></span><br><span class="line">	<span class="keyword">else</span>  <span class="comment">// 判断是否是因为i&gt;=n而结束</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 是，情况 &quot;(1,2)&quot;  ==&gt; hsub =&quot;(1,2)&quot;  sub = &quot;&quot;</span></span><br><span class="line">		<span class="comment">// 说明sub整个就是表头</span></span><br><span class="line">		<span class="built_in">strcpy</span>(hsub,sub);  <span class="comment">// 把sub整个赋值给hsub</span></span><br><span class="line">		sub[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// sub赋给hsub后，此时sub为空</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-树和二叉树"><a href="#6-树和二叉树" class="headerlink" title="6 树和二叉树"></a>6 树和二叉树</h1><h2 id="6-1-树及二叉树的概念与性质"><a href="#6-1-树及二叉树的概念与性质" class="headerlink" title="6.1 树及二叉树的概念与性质"></a>6.1 树及二叉树的概念与性质</h2><p><strong>树</strong>：</p>
<ul>
<li><p>结点拥有的子树数称为结点的<strong>度</strong>；</p>
</li>
<li><p>树种结点的最大层次（横向）称为树的<strong>深度****或</strong>高度**；</p>
</li>
<li><p><strong>森林</strong>是<code>m(m&gt;=0)</code>棵互不相交的树的集合。</p>
</li>
</ul>
<p><strong>二叉树</strong></p>
<ul>
<li><p>每个结点至多只有两颗子树，且有左右之分；</p>
<ul>
<li><strong>性质1：</strong>第<code>i</code>层（层次）至多有<code>2^(i-1)</code>个结点；</li>
<li><strong>性质2：</strong>深度为<code>k</code>的二叉树至多有<code>2^k-1</code>个结点；</li>
<li><strong>性质3：</strong>对任何一棵二叉树<code>T</code>，其终端结点数为<code>n0</code>，度为<code>2</code>的结点数为<code>n2</code>，则<code>n0=n2+1</code>；</li>
</ul>
</li>
<li><p>满二叉树：所有结点（除叶子结点外）均有左右分支；</p>
</li>
<li><p>完全二叉树：基于满二叉树实现，<em><strong>性质4&#x2F;5代表从<code>1</code>开始编号的情况。</strong></em></p>
<ul>
<li><strong>性质4：</strong>具有<code>n</code>个结点的<strong>完全二叉树</strong>的深度为<code>[log2n]+1</code>(<code>&quot;[]&quot;</code>表示向下取整)；</li>
<li><strong>性质5：</strong>对一棵有<code>n</code>个结点的<strong>完全二叉树</strong>的结点按层序编号，对任一结点<code>i(1&lt;=i&lt;=n)</code>：<ul>
<li><strong>（1）</strong>若<code>i=1</code>，则结点i是二叉树的根，无双亲；若<code>i&gt;1</code>，则其双亲<code>PARENT(i)</code>是结点<code>[i/2]</code>；</li>
<li><strong>（2）</strong>若<code>2i&gt;n</code>，则结点<code>i</code>无左孩子；否则左孩子是<code>2i</code>；</li>
<li><strong>（3）</strong>若<code>2i+1&gt;n</code>，则结点<code>i</code>无右孩子；否则右孩子是<code>2i+1</code>；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-2-二叉树的链式存储方式（二叉链表，BinTree）"><a href="#6-2-二叉树的链式存储方式（二叉链表，BinTree）" class="headerlink" title="6.2 二叉树的链式存储方式（二叉链表，BinTree）"></a>6.2 二叉树的链式存储方式（二叉链表，BinTree）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType BinTreeNode*</span></span><br></pre></td></tr></table></figure>

<h2 id="6-3-二叉树的非递归遍历"><a href="#6-3-二叉树的非递归遍历" class="headerlink" title="6.3 二叉树的非递归遍历"></a>6.3 二叉树的非递归遍历</h2><p>用<strong>栈</strong>实现。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221544737.png" alt="image-20231222154427982"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221544992.png" alt="image-20231222154440257"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221544658.png" alt="image-20231222154447677"></p>
<h2 id="6-4-二叉树的恢复实现"><a href="#6-4-二叉树的恢复实现" class="headerlink" title="6.4 二叉树的恢复实现"></a>6.4 二叉树的恢复实现</h2><p>两个概念：二叉树的<strong>相似</strong>和<strong>等价</strong>。</p>
<ul>
<li>相似：形状相同，内容不同</li>
<li>等价：形状和内容均相同。</li>
</ul>
<p>二叉树的计数问题：讨论具有<code>n</code>个结点、互不相似的二叉树的数目<code>b</code>。</p>
<p>含有<code>n</code>个结点的不相似的二叉树有：<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221413095.png" alt="image-20231222141353060" style="zoom: 50%;" />棵。</p>
<blockquote>
<p>1、前序+中序唯一恢复一棵二叉树。</p>
<p>2、中序+后序唯一恢复一棵二叉树。</p>
<p>注意：<strong>恢复二叉树时一定要有中序存在</strong>，因为通过中序遍历可以得知这棵二叉树的左右分布。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序+中序恢复二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_5</span><span class="params">(BinTree *bt, <span class="type">char</span> *VLR, <span class="type">char</span>*LVR, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    CreateBinTree_5(bt-&gt;root, VLR, LVR, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_5</span><span class="params">(BinTreeNode *&amp;t, <span class="type">char</span> *VLR, <span class="type">char</span>*LVR, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(VLR[<span class="number">0</span>] != LVR[k])</span><br><span class="line">            k++;</span><br><span class="line"></span><br><span class="line">        t = (BinTreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTreeNode));</span><br><span class="line">        assert(t != <span class="literal">NULL</span>);</span><br><span class="line">        t-&gt;data = LVR[k];</span><br><span class="line"></span><br><span class="line">        CreateBinTree_5(t-&gt;leftChild, VLR+<span class="number">1</span>, LVR, k);</span><br><span class="line">        CreateBinTree_5(t-&gt;rightChild, VLR+k+<span class="number">1</span>, LVR+k+<span class="number">1</span>, n-k<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序+后序恢复二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_6</span><span class="params">(BinTree *bt, <span class="type">char</span> *LVR, <span class="type">char</span>*LRV, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    CreateBinTree_6(bt-&gt;root, LVR, LRV, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_6</span><span class="params">(BinTreeNode *&amp;t, <span class="type">char</span> *LVR, <span class="type">char</span>*LRV, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(LRV[n<span class="number">-1</span>] != LVR[k])</span><br><span class="line">            k++;</span><br><span class="line">        </span><br><span class="line">        t = (BinTreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTreeNode));</span><br><span class="line">        assert(t != <span class="literal">NULL</span>);</span><br><span class="line">        t-&gt;data = LVR[k];</span><br><span class="line"></span><br><span class="line">        CreateBinTree_6(t-&gt;rightChild, LVR+k+<span class="number">1</span>, LRV+k, n-k<span class="number">-1</span>);</span><br><span class="line">        CreateBinTree_6(t-&gt;leftChild, LVR, LRV, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-5-线索二叉树"><a href="#6-5-线索二叉树" class="headerlink" title="6.5 线索二叉树"></a>6.5 线索二叉树</h2><blockquote>
<p>同时保存节点的<strong>前驱和后继</strong>信息。由于<code>n</code>个结点必然存在<code>n+1</code>个空链，实际上并未完全保存所有的前驱后继信息，而只是利用了这<code>n+1</code>个空链。</p>
</blockquote>
<p>举例：对下面这棵二叉树按照中序遍历线索化</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312232026443.png" alt="image-20231223202641174"></p>
<h2 id="6-6-树和森林"><a href="#6-6-树和森林" class="headerlink" title="6.6 树和森林"></a>6.6 树和森林</h2><p>讨论树的表示及其遍历操作，并建立森林与二叉树的对应关系。</p>
<p>注意这里的树<em>不局限于二叉树</em>。</p>
<h3 id="1、双亲表示法（仅了解即可）"><a href="#1、双亲表示法（仅了解即可）" class="headerlink" title="1、双亲表示法（仅了解即可）"></a>1、双亲表示法（仅了解即可）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241441068.png" alt="image-20231224144144837" style="zoom: 80%;" />

<p><strong>缺点</strong>：求父结点很方便，但求孩子结点时需要遍历整个结构。</p>
<h3 id="2、孩子表示法（仅了解即可）"><a href="#2、孩子表示法（仅了解即可）" class="headerlink" title="2、孩子表示法（仅了解即可）"></a>2、孩子表示法（仅了解即可）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241517749.png" alt="image-20231224151751633"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241518866.png" alt="image-20231224151800720"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241517901.png" alt="image-20231224151730578"></p>
<h3 id="3、孩子兄弟表示法（重要）"><a href="#3、孩子兄弟表示法（重要）" class="headerlink" title="3、孩子兄弟表示法（重要）"></a>3、孩子兄弟表示法（重要）</h3><p>又称二叉树表示法或二叉链表表示法。即以二叉链表作为树的存储结构。</p>
<p>链表中结点的两个链域分别指向该结点的第一个<strong>孩子结点</strong>和下一个<strong>兄弟结点</strong>。<em>（即左孩子，右兄弟）</em></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241541154.png" alt="image-20231224154137327" style="zoom: 33%;" />

<p>对其进行遍历可得：</p>
<p>（1）先序遍历<strong>（先访问根，再依次访问根的每棵子树）</strong>：<code>A B C D E</code></p>
<p>（2）后序遍历<strong>（先依次访问根的每棵子树，再访问根）</strong>：<code>B D C E A</code></p>
<p><strong>树不包含中序遍历！</strong></p>
<h3 id="4、森林和二叉树的转换"><a href="#4、森林和二叉树的转换" class="headerlink" title="4、森林和二叉树的转换"></a>4、森林和二叉树的转换</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241530772.png" alt="image-20231224153024529" style="zoom: 67%;" />

<p>上图依然遵循“左孩子右兄弟”的概念。当三棵树的树根相连时，树根结点之间的关系即为“兄弟”的关系。</p>
<p>对其进行遍历可得：</p>
<p>（1）先序遍历：<code>A B C D E F G H I J</code></p>
<ul>
<li>访问第一棵树的根结点；</li>
<li>先序遍历第一棵树的根结点的子树森林；</li>
<li>先序遍历除去第一棵树之后剩余的树构成的森林。</li>
</ul>
<p>（2）中序遍历：<code>B C D A F E H J I G</code></p>
<ul>
<li>中序遍历森林中第一棵树的根结点的子树森林；</li>
<li>访问第一棵树的根结点；</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林。</li>
</ul>
<blockquote>
<p>对比图6.15和图6.17可以发现，若以二叉链表的形式表示时：</p>
<ul>
<li>如果仅包含左孩子，则为一棵树的二叉链表表示；</li>
<li>否则，则是森林的二叉链表表示。</li>
</ul>
</blockquote>
<h3 id="5、在树中查找父结点和在二叉树中查找父结点"><a href="#5、在树中查找父结点和在二叉树中查找父结点" class="headerlink" title="5、在树中查找父结点和在二叉树中查找父结点"></a>5、在树中查找父结点和在二叉树中查找父结点</h3><h4 id="（1）在树中查找父结点"><a href="#（1）在树中查找父结点" class="headerlink" title="（1）在树中查找父结点"></a>（1）在树中查找父结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找父结点</span></span><br><span class="line">TreeNode* <span class="title function_">Parent</span><span class="params">(Tree *tree, TreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Parent(tree-&gt;root, p);</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* <span class="title function_">Parent</span><span class="params">(TreeNode *t, TreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span> || p == <span class="literal">NULL</span> || p == t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode *q = t-&gt;firstChild;</span><br><span class="line">    TreeNode *parent;</span><br><span class="line">    <span class="keyword">while</span>(q != <span class="literal">NULL</span> &amp;&amp; q != p)</span><br><span class="line">    &#123;</span><br><span class="line">        parent = Parent(q, p);  <span class="comment">// 在第一个孩子结点中查找parent结点</span></span><br><span class="line">        <span class="keyword">if</span>(parent != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        q = q-&gt;nextSilbing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(q != <span class="literal">NULL</span> &amp;&amp; q == p)  <span class="comment">// q(t-&gt;firstChild)==p说明要查找的结点p的父结点即为t</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241742171.png" alt="image-20231224174224376" style="zoom: 33%;" />

<h4 id="（2）在二叉树中查找父结点"><a href="#（2）在二叉树中查找父结点" class="headerlink" title="（2）在二叉树中查找父结点"></a>（2）在二叉树中查找父结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找父节点</span></span><br><span class="line">BinTreeNode* <span class="title function_">Parent</span><span class="params">(BinTree *bt, BinTreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Parent(bt-&gt;root, p);</span><br><span class="line">&#125;</span><br><span class="line">BinTreeNode* <span class="title function_">Parent</span><span class="params">(BinTreeNode *t, BinTreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span> || p == <span class="literal">NULL</span>)  <span class="comment">// 树为空或查找的节点为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">if</span>(t-&gt;leftChild == p || t-&gt;leftChild == p)</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    </span><br><span class="line">    BinTreeNode *q = Parent(t-&gt;leftChild, p);</span><br><span class="line">    <span class="keyword">if</span>(q != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    <span class="keyword">return</span> Parent(t-&gt;rightChild, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-图"><a href="#7-图" class="headerlink" title="7 图"></a>7 图</h1><h2 id="7-1-图的定义与概念"><a href="#7-1-图的定义与概念" class="headerlink" title="7.1 图的定义与概念"></a>7.1 图的定义与概念</h2><p>图中的数据元素称为<strong>顶点</strong>(<code>Vertex</code>)，<code>V</code>是顶点的有穷非空集合。<code>E</code>是两个顶点之间的集合。</p>
<ul>
<li><p><code>&lt;v, w&gt;</code>：从顶点<code>v</code>到顶点<code>w</code>的有向边；</p>
</li>
<li><p><code>(v, w)</code>：从顶点<code>v</code>到顶点<code>w</code>的无向边。</p>
</li>
</ul>
<p>图中共<code>n</code>个顶点，此时：</p>
<ul>
<li>对无向图来说边的个数范围为<code>0~1/2(n(n-1))</code>，当有<code>1/2(n(n-1)</code>条边时为<strong>无向完全图</strong>。</li>
<li>对有向图来说边的个数范围为<code>0~n(n-1)</code>，当有<code>n(n-1)</code>条边时为<strong>有向完全图</strong>。</li>
</ul>
<p>图（<code>Graph</code>）与子图（<code>Subgraph</code>）</p>
<p>权（<code>Weight</code>）</p>
<p>邻接点</p>
<p>顶点<code>v</code>的度（<code>Degree</code>）是和<code>v</code>相关联的边的数目。在有向图中还要分<strong>入度</strong>和<strong>出度</strong>。</p>
<p>从顶点<code>v</code>到顶点<code>v&#39;</code>的路径（<code>Path</code>）是一个顶点序列。路径的长度是路径上的边或弧的数目。第一个顶点和最后一个顶点相同的路径称为回路或环（<code>Cycle</code>）。在无向图<code>G</code>中，若从顶点<code>v</code>到顶点<code>v&#39;</code>有路径，则称<code>v</code>和<code>v&#39;</code>是连通的。若图中任意两个顶点都是连通的，则称<code>G</code>为<strong>连通图</strong>。而<strong>连通分量</strong>（<code>Connected Component</code>）是指无向图中的<strong>极大连通子图</strong>。</p>
<p>一个连通图的<strong>生成树</strong>是一个极小连通子图。如果在一棵生成树上添加一条边，必定形成一个环。</p>
<h2 id="7-2-图的存储方式"><a href="#7-2-图的存储方式" class="headerlink" title="7.2 图的存储方式"></a>7.2 图的存储方式</h2><h3 id="1、邻接矩阵表示方式（数组形式，重要）"><a href="#1、邻接矩阵表示方式（数组形式，重要）" class="headerlink" title="1、邻接矩阵表示方式（数组形式，重要）"></a>1、邻接矩阵表示方式（数组形式，重要）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251216684.png" alt="image-20231225121641478"></p>
<p>两个数组分别存储数据元素（顶点）的信息和数据元素之间的关系（边或弧）的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Default_Vertex_Size 10  <span class="comment">// 默认顶点数大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T char</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphMtx</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span>   MaxVertices;    <span class="comment">// 最大顶点数，即容量</span></span><br><span class="line">    <span class="type">int</span>   NumVertices;    <span class="comment">// 当前顶点数，即真实大小</span></span><br><span class="line">    <span class="type">int</span>   NumEdges;       <span class="comment">// 当前边数</span></span><br><span class="line"></span><br><span class="line">    T    *VerticesList;   <span class="comment">// 顶点列表</span></span><br><span class="line">    <span class="type">int</span> **Edge;           <span class="comment">// 指向邻接矩阵，二维数组（？）</span></span><br><span class="line"></span><br><span class="line">&#125;GraphMtx;</span><br></pre></td></tr></table></figure>

<h3 id="2、邻接表表示方式（链表形式，重要）"><a href="#2、邻接表表示方式（链表形式，重要）" class="headerlink" title="2、邻接表表示方式（链表形式，重要）"></a>2、邻接表表示方式（链表形式，重要）</h3><h3 id="3、十字链表（仅了解即可）"><a href="#3、十字链表（仅了解即可）" class="headerlink" title="3、十字链表（仅了解即可）"></a>3、十字链表（仅了解即可）</h3><h3 id="4、多重邻接表（仅了解即可）"><a href="#4、多重邻接表（仅了解即可）" class="headerlink" title="4、多重邻接表（仅了解即可）"></a>4、多重邻接表（仅了解即可）</h3>]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>零散程序</title>
    <url>/2023/08/03/code%E7%9B%B8%E5%85%B3/Python/%E9%9B%B6%E6%95%A3%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="1、读取图片"><a href="#1、读取图片" class="headerlink" title="1、读取图片"></a>1、读取图片</h2><h3 id="（1）PIL库读取"><a href="#（1）PIL库读取" class="headerlink" title="（1）PIL库读取"></a>（1）PIL库读取</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img0 = Image.<span class="built_in">open</span>((<span class="string">&#x27;pic0.jpg&#x27;</span>))  <span class="comment"># pic0.bmp</span></span><br><span class="line">img1 = img0.convert(<span class="string">&quot;RGB&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="（2）cv2库读取"><a href="#（2）cv2库读取" class="headerlink" title="（2）cv2库读取"></a>（2）cv2库读取</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取BMP图像</span></span><br><span class="line">img0 = cv2.imread(<span class="string">&#x27;pic0.bmp)&#x27;</span></span><br><span class="line">img1 = cv2.cvtColor(img0, cv2.COLOR_BGR2RGB)  <span class="comment"># BGR转RGB格式</span></span><br></pre></td></tr></table></figure>

<p><strong>cv2.cvtColor(p1, p2) 是颜色空间转换函数，p1是需要转换的图片，p2是转换成何种格式。</strong></p>
<ul>
<li>cv2.COLOR_BGR2RGB 将BGR格式转换成RGB格式</li>
<li>cv2.COLOR_BGR2GRAY 将BGR格式转换成灰度图片</li>
</ul>
<span id="more"></span>

<h2 id="2、txt文件转excel文件"><a href="#2、txt文件转excel文件" class="headerlink" title="2、txt文件转excel文件"></a>2、txt文件转excel文件</h2><p>txt文件：</p>
<img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20231113194751011.png" alt="image-20231113194751011"  />

<p>其中数据间以逗号和空格分割。</p>
<p>程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文本文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/root/autodl-tmp/STGA/data/SHT/tpr.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data_lines = file.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据解析成二维列表</span></span><br><span class="line">data = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, line.strip().split(<span class="string">&#x27;, &#x27;</span>))) <span class="keyword">for</span> line <span class="keyword">in</span> data_lines]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Pandas DataFrame</span></span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line">df = df.transpose()  <span class="comment"># 将数据按行存储，不加这一句会把所有数据存储在一行中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 DataFrame 写入 Excel 文件</span></span><br><span class="line">df.to_excel(<span class="string">&#x27;/root/autodl-tmp/STGA/data/SHT/output.xlsx&#x27;</span>, index=<span class="literal">False</span>, header=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>解析<code>data = [list(map(float, line.strip().split(&#39;, &#39;))) for line in data_lines]</code>：</p>
<ul>
<li><code>for line in data_lines</code>: 这是一个循环语句，遍历了从文本文件中读取的每一行。</li>
<li><code>line.strip()</code>: <code>strip()</code> 方法用于去除字符串两端的空白字符（包括换行符 <code>\n</code>），确保数据不包含额外的空格或换行。</li>
<li><code>line.strip().split(&#39;, &#39;)</code>: <code>split(&#39;, &#39;)</code> 方法将字符串按照逗号和空格进行分割，返回一个由分割后的字符串组成的列表。</li>
<li><code>list(map(float, ...))</code>: <code>map(float, ...)</code> 将分割后的字符串列表中的每个元素转换为浮点数，<code>list(...)</code> 将其转换为列表。</li>
</ul>
]]></content>
      <categories>
        <category>code相关</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>webserver</title>
    <url>/2023/08/04/%E9%A1%B9%E7%9B%AE/webserver/webserver/</url>
    <content><![CDATA[<h1 id="一、项目基础"><a href="#一、项目基础" class="headerlink" title="一、项目基础"></a>一、项目基础</h1><h2 id="1、Reactor的关键结构"><a href="#1、Reactor的关键结构" class="headerlink" title="1、Reactor的关键结构"></a>1、Reactor的关键结构</h2><p><code>Reactor</code>核心的事件分发机制，即将<code>IO multiplexing</code>拿到的<code>IO</code>事件分发给各个文件描述符<code>fd</code>的事件处理函数。</p>
<p><code>Reactor</code>是一种事件驱动机制，和普通函数调用的不同之处在于：</p>
<ul>
<li>应用程序不是主动地调用某个<code>API</code>来完成处理；其逆置了事件处理流程，<strong>应用程序需要提供相应的接口并注册到<code>Reactor</code>上</strong>，如果相应的事件发生，<code>Reactor</code>将主动调用应用程序注册的接口，这些接口又称为<strong>回调函数</strong>。</li>
</ul>
<span id="more"></span>

<h3 id="（1）EventLoop：-事件循环"><a href="#（1）EventLoop：-事件循环" class="headerlink" title="（1）EventLoop： 事件循环"></a>（1）EventLoop： 事件循环</h3><p>从<code>EventLoop</code>的类定义中可以看出，除了⼀些状态量以外，每个<code>EventLoop</code>持有⼀个<code>Poller</code>的智能指针（对<code>epoll / poll</code>的封装），⼀个⽤于<code>EventLoop</code>之间通信的<code>Channel</code>，⾃⼰的线程<code>id</code>，互斥锁以及装有等待处理函数的<code>vector</code>。很明显，<code>EventLoop</code>并不直接管理各个连接的<code>Channel</code>（⽂件描述符的封装），⽽是通过<code>Poller</code>来进⾏的。<code>EventLoop</code>中最核⼼的函数就是<code>EventLoop::Loop()</code>。</p>
<p><code>EventLoop</code>不可拷贝，且每个线程只能有一个<code>EventLoop</code>对象。<code>EventLoop</code>对象的生命周期通常和其所属的线程一样长。</p>
<p><code>EventLoop</code>的头文件定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class EventLoop : boost::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line"></span><br><span class="line">  EventLoop();</span><br><span class="line">  ~EventLoop();</span><br><span class="line"></span><br><span class="line">  void loop();</span><br><span class="line"></span><br><span class="line">  void assertInLoopThread()</span><br><span class="line">  &#123;</span><br><span class="line">    if (!isInLoopThread())</span><br><span class="line">    &#123;</span><br><span class="line">      abortNotInLoopThread();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool isInLoopThread() const &#123; return threadId_ == CurrentThread::tid(); &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  void abortNotInLoopThread();</span><br><span class="line"></span><br><span class="line">  bool looping_; /* atomic */</span><br><span class="line">  const pid_t threadId_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>loop()</code>的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /*</span><br><span class="line">  	在该函数中会循环执行以下过程：</span><br><span class="line">  		调用Poller::poll()，通过此调用获得一个vector&lt;channel*&gt;activeChannels_的就绪事件集合;</span><br><span class="line">  		再遍历该容器，执行每个Channel的Channel::handleEvent()完成相应就绪事件回调;</span><br><span class="line">  		最后执行pendingFunctors_排队的函数。</span><br><span class="line">  	上述一次循环就是一次Reactor模式完成。</span><br><span class="line">  */</span><br><span class="line">void EventLoop::loop()</span><br><span class="line">&#123;</span><br><span class="line">  assert(!looping_);</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  looping_ = true;</span><br><span class="line">  quit_ = false;</span><br><span class="line"></span><br><span class="line">  while (!quit_)</span><br><span class="line">  &#123;</span><br><span class="line">    activeChannels_.clear();</span><br><span class="line">    poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">    for (ChannelList::iterator it = activeChannels_.begin();</span><br><span class="line">        it != activeChannels_.end(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">      (*it)-&gt;handleEvent();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; stop looping&quot;;</span><br><span class="line">  looping_ = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）Channel：事件分发器"><a href="#（2）Channel：事件分发器" class="headerlink" title="（2）Channel：事件分发器"></a>（2）Channel：事件分发器</h3><p>每个<code>Channel</code>对象自始至终只属于一个<code>EventLoop</code>，因此每个<code>Channel</code>对象都只属于一个<code>IO</code>线程。每个<code>Channel</code>对象只负责一个<code>fd</code>的事件分发，但不拥有这个<code>fd</code>，也不会在析构的时候关闭这个<code>fd</code>。</p>
<p><code>Channel</code>不是基类，用户无须继承，一般使用更上层的封装，如<code>TcpConnection</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Channel : boost::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef boost::function&lt;void()&gt; EventCallback;</span><br><span class="line"></span><br><span class="line">  Channel(EventLoop* loop, int fd);</span><br><span class="line"></span><br><span class="line">  // Channel作为是事件分发器其核心结构是Channel::handleEvent()</span><br><span class="line">  // 该函数调用Channel::handleEventWithGuard()</span><br><span class="line">  // 在其内根据Channel::revents的值分发调用相应的事件回调。</span><br><span class="line">  void handleEvent();</span><br><span class="line">  </span><br><span class="line">  // set Callback()系列函数，接受`Channel`所属的类注册相应的事件回调函数。</span><br><span class="line">  void setReadCallback(const EventCallback&amp; cb)</span><br><span class="line">  &#123; readCallback_ = cb; &#125;</span><br><span class="line">  void setWriteCallback(const EventCallback&amp; cb)</span><br><span class="line">  &#123; writeCallback_ = cb; &#125;</span><br><span class="line">  void setErrorCallback(const EventCallback&amp; cb)</span><br><span class="line">  &#123; errorCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  int fd() const &#123; return fd_; &#125;</span><br><span class="line">  int events() const &#123; return events_; &#125;</span><br><span class="line">  void set_revents(int revt) &#123; revents_ = revt; &#125;</span><br><span class="line">  bool isNoneEvent() const &#123; return events_ == kNoneEvent; &#125;</span><br><span class="line"></span><br><span class="line">  void enableReading() &#123; events_ |= kReadEvent; update(); &#125;</span><br><span class="line">  // void enableWriting() &#123; events_ |= kWriteEvent; update(); &#125;</span><br><span class="line">  // void disableWriting() &#123; events_ &amp;= ~kWriteEvent; update(); &#125;</span><br><span class="line">  // void disableAll() &#123; events_ = kNoneEvent; update(); &#125;</span><br><span class="line"></span><br><span class="line">  // for Poller</span><br><span class="line">  int index() &#123; return index_; &#125;</span><br><span class="line">  void set_index(int idx) &#123; index_ = idx; &#125;</span><br><span class="line"></span><br><span class="line">  EventLoop* ownerLoop() &#123; return loop_; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（3）Polloer：IO-multiplexing的封装"><a href="#（3）Polloer：IO-multiplexing的封装" class="headerlink" title="（3）Polloer：IO multiplexing的封装"></a>（3）Polloer：IO multiplexing的封装</h3><p><code>Poller Class</code>是<code>IO multiplexing</code>的封装，它现在是个具体类，而在<code>muduo</code>中是个抽象基类，因为<code>muduo</code>同时支持<code>poll(2)</code>和<code>epoll(4)</code>两种<code>IO multiplexing</code>机制。<br><code>Poller</code>是<code>EventLoop</code>的间接成员，只供其<code>owner</code> <code>EventLoop</code>在<code>IO</code>线程调用，因此无需加锁。其生命与<code>EventLoop</code>相等。<code>Poller</code>并不拥有<code>Channel</code>，<code>Channel</code>在析构之前必须自己<code>unregister(EventLoop::removeChannel())</code>，避免空悬指针。</p>
<p><code>Poller</code>类的作⽤就是<strong>负责监听⽂件描述符事件是否触发</strong>以及<strong>返回发⽣事件的⽂件描述符以及具体事件</strong>。所以⼀个<code>Poller</code>对象对应⼀个<code>IO</code>多路复⽤模块。在<code>muduo</code>中，⼀个<code>EventLoop</code>对应⼀个<code>Poller</code>。</p>
<p><code>Poller</code>的主要成员变量就三个：</p>
<ol>
<li><code>epollFd_</code>：就是⽤<code>epoll_create</code>⽅法返回的<code>epoll</code>句柄，这个是常识。</li>
<li><code>events_</code>：存放<code>epoll_wait()</code>返回的活动事件（是⼀个结构体）</li>
<li><code>channelMap_ </code>：这个变量是<code>std::unordered_map&lt;int, std::shared_ptr&lt;Channel&gt;&gt;</code>类型，负责记录<br>⽂件描述符<code>fd -&gt; Channel</code>的映射，也帮忙保管所有注册在这个<code>Poller</code>上的<code>Channel</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Epoll::poll(std::vector&lt;sp_Channel&gt;&amp; req) &#123;</span><br><span class="line"> int event_count =</span><br><span class="line"> Epoll_wait(epollFd_, &amp;*events_.begin(), events_.size(), EPOLLWAIT_TIME);</span><br><span class="line"> for(int i = 0; i &lt; event_count; ++i) &#123;</span><br><span class="line"> int fd = events_[i].data.fd;</span><br><span class="line"> sp_Channel temp = channelMap_[fd];</span><br><span class="line"> temp-&gt;setRevents(events_[i].events);</span><br><span class="line"> req.emplace_back(std::move(temp));</span><br><span class="line"> &#125;</span><br><span class="line"> // LOG &lt;&lt; &quot;Epoll finished&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当外部调⽤<code>poll</code>⽅法的时候，该⽅法底层其实是通过<code>epoll_wait</code>获取这个事件监听器上发⽣事件的<code>fd</code>及其对应发⽣的事件，我们知道每个<code>fd</code>都是由⼀个<code>Channel</code>封装的，通过哈希表<code>channelMap_</code>可以根据<code>fd</code>找到封装这个<code>fd</code>的<code>Channel</code>。将<code>IO</code>多路复⽤模块监听到该<code>fd</code>发⽣的事件写进这个<code>Channel</code>中的<code>revents</code>成员变量中。然后把这个<code>Channel</code>装进<code>req</code>中。这样，当外界调⽤完<code>poll</code>之后就能拿到<code>IO</code>多路复⽤模块的<strong>监听结果</strong><code>(std::vector&lt;sp_Channel&gt;&amp; req)</code>。</p>
<h3 id="（4）Reactor模式的核心架构"><a href="#（4）Reactor模式的核心架构" class="headerlink" title="（4）Reactor模式的核心架构"></a>（4）Reactor模式的核心架构</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308051524737.png" alt="Reactor模式的核心架构"></p>
<h2 id="2、日志系统"><a href="#2、日志系统" class="headerlink" title="2、日志系统"></a>2、日志系统</h2><p>服务器的⽇志系统是⼀个<strong>多⽣产者，单消费者</strong>的任务场景：多⽣产者负责把⽇志写⼊缓冲区，单消费者负责把缓冲区中数据写⼊⽂件。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308061016505.png" alt="日志系统框图"></p>
<p><code>LOG</code>的实现参照了<code>muduo</code>，但是⽐<code>muduo</code>要简化⼀点，⼤致的实现如上图所示。</p>
<ul>
<li>⾸先是<code>Logger</code>类，<code>Logger</code>类⾥⾯有<code>Impl</code>类，其实具体实现是<code>Impl</code>类，我也不懂<code>muduo</code>为何要再封装⼀层，那么我们来说说<code>Impl</code>⼲了什么，在初始化的时候<code>Impl</code>会把时间信息存到<code>LogStream</code>的缓冲区⾥，在我们实际⽤<code>Log</code>的时候，实际写⼊的缓冲区也是<code>LogStream</code>，在析构的时候<code>Impl</code>会把当前⽂件和⾏数等信息写⼊到<code>LogStream</code>，再把<code>LogStream</code>⾥的内容写到<code>AsyncLogging</code>的缓冲区中，当然这时候我们要先开启⼀个后端线程⽤于把缓冲区的信息写到⽂件⾥。</li>
<li><code>LogStream</code>类，⾥⾯其实就⼀个<code>Buffer</code>缓冲区，是⽤来暂时存放我们写⼊的信息的。还有就是重载运算符，因为我们采⽤的是<code>C++</code>的流式⻛格。</li>
<li><code>AsyncLogging</code>类，最核⼼的部分，在多线程程序中写<code>Log</code>⽆⾮就是前端往后端写，后端往硬盘写，⾸先将<code>LogStream</code>的内容写到了<code>AsyncLogging</code>缓冲区⾥，也就是前端往后端写，这个过程通过<code>append</code>函数实现，后端实现通过<code>threadfunc</code>函数，两个线程的同步和等待通过互斥锁和条件变量来实现，具体实现使⽤了双缓冲技术。</li>
<li>双缓冲技术的基本思路：准备两块<code>buffer</code>，<code>A</code>和<code>B</code>,前端往<code>A</code>写数据，后端从<code>B</code>⾥⾯往硬盘写数据，当<code>A</code>写满后，交换<code>A</code>和<code>B</code>，如此反复。使⽤两个<code>buffer</code>的好处是在新建⽇志消息的时候不必等待磁盘⽂件操作，也避免每条新⽇志消息都触发后端⽇志线程。换句话说，前端不是将⼀条条⽇志消息分别送给后端，⽽是将多条⽇志消息拼接成⼀个⼤的<code>buffer</code>传送给后端，相当于批处理，减少了线程唤醒的开销。不过实际的实现的话和这个还是有点区别，具体看代码吧。</li>
</ul>
<h3 id="（1）LogSream类"><a href="#（1）LogSream类" class="headerlink" title="（1）LogSream类"></a>（1）LogSream类</h3><p><strong>主要作用：将前端日志写入<code>BufferA</code>。</strong></p>
<p>详细来说，是将各个类型的数据转换为<code>char</code>的形式放入字符数组中，方便后端线程写入硬盘。</p>
<blockquote>
<p><strong>问题思考：<code>int</code>型、浮点型及指针都要如何转换为<code>char</code>的形式？</strong></p>
</blockquote>
<h3 id="（2）AsynLogging类"><a href="#（2）AsynLogging类" class="headerlink" title="（2）AsynLogging类"></a>（2）AsynLogging类</h3><p><strong>主要作用：经前端获得的<code>BufferA</code>放入后端的<code>BufferB</code>中，并且将<code>BufferB</code>的内容最终写入到磁盘中。</strong></p>
<h1 id="二、WebServer"><a href="#二、WebServer" class="headerlink" title="二、WebServer"></a>二、WebServer</h1><h2 id="1、项目框架"><a href="#1、项目框架" class="headerlink" title="1、项目框架"></a>1、项目框架</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-webserver.cpp</span><br><span class="line">-webserver.h</span><br><span class="line">-log</span><br><span class="line">  -log.cpp</span><br><span class="line">  -log.h</span><br><span class="line">  -block_queue.h</span><br></pre></td></tr></table></figure>

<h2 id="2、-webserver-webserver-cpp"><a href="#2、-webserver-webserver-cpp" class="headerlink" title="2、&#x2F;webserver&#x2F;webserver.cpp"></a>2、&#x2F;webserver&#x2F;webserver.cpp</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WebServer();</span><br><span class="line">~WebServer();</span><br><span class="line"></span><br><span class="line">bool dealclientdata();</span><br><span class="line">bool dealwithsignal(bool&amp; timeout, bool&amp; stop_server);</span><br><span class="line">void dealwithread(int sockfd);</span><br><span class="line">void dealwithwrite(int sockfd);</span><br><span class="line">void eventLoop();</span><br></pre></td></tr></table></figure>

<h2 id="3、-webserver-log"><a href="#3、-webserver-log" class="headerlink" title="3、&#x2F;webserver&#x2F;log&#x2F;"></a>3、&#x2F;webserver&#x2F;log&#x2F;</h2><h3 id="（1）block-queue-h"><a href="#（1）block-queue-h" class="headerlink" title="（1）block_queue.h"></a>（1）block_queue.h</h3><p>采用循环数组实现阻塞队列，作为二者的共享缓冲区。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 判断队列是否满了</span><br><span class="line">bool full() </span><br><span class="line"></span><br><span class="line">// 判断队列是否为空</span><br><span class="line">bool empty() </span><br><span class="line"></span><br><span class="line">// 返回队首元素</span><br><span class="line">bool front(T &amp;value)</span><br><span class="line"></span><br><span class="line">// 返回队尾元素</span><br><span class="line">bool back(T &amp;value) </span><br><span class="line"></span><br><span class="line">int size() </span><br><span class="line"></span><br><span class="line">int max_size()</span><br><span class="line"></span><br><span class="line">// 往队列添加元素，需要将所有使用队列的线程先唤醒</span><br><span class="line">// 当有元素push进队列，相当于生产者生产了一个元素</span><br><span class="line">// 若当前没有线程等待条件变量，则唤醒无意义</span><br><span class="line">bool push(const T &amp;item)</span><br><span class="line"></span><br><span class="line">// pop时，如果当前队列没有元素,将会等待条件变量</span><br><span class="line">bool pop(T &amp;item)</span><br><span class="line"></span><br><span class="line">// 增加了超时处理</span><br><span class="line">bool pop(T &amp;item, int ms_timeout)</span><br></pre></td></tr></table></figure>

<h3 id="（2）log-cpp"><a href="#（2）log-cpp" class="headerlink" title="（2）log.cpp"></a>（2）log.cpp</h3><p><strong>完成日志文件的初始化和内容的写入。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time_t t = time(NULL);</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>time_t t</code>: 声明了一个名为 <code>t</code> 的变量，其数据类型是 <code>time_t</code>，这是 C 语言标准库中用来表示时间的数据类型。</p>
</li>
<li><p><code>time(NULL)</code>: 这是调用 <code>time()</code> 函数的语法，它接受一个参数（通常是一个指向 <code>time_t</code> 对象的指针），用于存储获取到的时间值。在这里，传递了 <code>NULL</code>，表示我们只是想要获取当前系统时间，不需要保存时间值到任何变量中。</p>
<p><code>time(NULL)</code> 的返回值是当前系统时间（以秒为单位）距离某个固定时间点（通常是 <code>1970 年 1 月 1 日 00:00:00 UTC</code>，也称为 <code>Unix</code> 时间戳）的秒数。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct tm *sys_tm = localtime(&amp;t);</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>struct tm *sys_tm</code>: 声明了一个指针变量 <code>sys_tm</code>，该指针指向 <code>struct tm</code> 结构体，用于存储本地时间的各个组成部分，如年、月、日、时、分、秒等。</p>
</li>
<li><p><code>localtime(&amp;t)</code>: 这是调用 <code>localtime()</code> 函数的语法，它接受一个 <code>time_t</code> 类型的指针作为参数，并返回一个指向 <code>struct tm</code> 结构体的指针。函数的作用是将传入的时间值（由 <code>time_t</code> 类型的变量 <code>t</code> 表示）转换为本地时间，并存储在 <code>struct tm</code> 结构体中。</p>
<p>注意，<code>localtime()</code> 函数将时间从 UTC 时间转换为本地时间，考虑了时区和夏令时等因素。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>项目</category>
        <category>webserver</category>
      </categories>
  </entry>
  <entry>
    <title>C++扩展知识</title>
    <url>/2023/10/08/code%E7%9B%B8%E5%85%B3/C++/c++%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="1、int-p-a、p-a、-p-a的正确理解"><a href="#1、int-p-a、p-a、-p-a的正确理解" class="headerlink" title="1、int *p &#x3D; &amp;a、p &#x3D; &amp;a、*p &#x3D; a的正确理解"></a>1、int *p &#x3D; &amp;a、p &#x3D; &amp;a、*p &#x3D; a的正确理解</h2><p>1、指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;a; <span class="comment">// 初始化一个int *类型指针，同时将变量a的地址存入p指针</span></span><br></pre></td></tr></table></figure>

<p>这里是一个<strong>特殊用法，仅在初始化变量的时候可以使用</strong>，应分为两个部分去进行理解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p;	<span class="comment">// 初始化一个int * 类型指针p</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p = &amp;a; <span class="comment">// 将变量a的地址存入p指针，此时p表示变量a的地址</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*p = a; <span class="comment">// 表示指针p指向变量a，这时*p表示变量a的数值</span></span><br></pre></td></tr></table></figure>

<p><em>注：区别在于在指针中p表示一个地址，存储的是变量的位置。</em></p>
<p>  <code>*p</code>表示一个变量，存储的是一个值。在初始化变量之外使用<code>*p = &amp;a;</code>是错误的，提示不能将<code>int *</code>类型的值分配到<code>int</code>类型的实体。<br>2、引用</p>
<p>  同时在<code>C++</code>中存在引用方法，引用和指针的差异在引用绑定后不可更改绑定对象，指针可以更改指向对象。<br>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> m = <span class="number">3</span>;  <span class="comment">// 定义一个int类型变量m</span></span><br><span class="line"><span class="type">int</span> &amp;r = m; <span class="comment">// 定义引用r表示变量m，后续所有的r都可以作为m来使用，改变r的值会同步修改m</span></span><br></pre></td></tr></table></figure>

<p>相当于把<code>m</code>的地址赋给<code>r</code>，此时两个变量地址是相同的内容。<br>注：引用使用的时候需要进行初始化，指针可以不用初始化。</p>
<p>未初始化的指针可以编译通过，但可能造成野指针问题。</p>
<p>3、野指针</p>
<p>  野指针常出现在空间分配当中，例如在调用的函数中声明了返回地址类型的变量，但是由于声明的位置是在小的空间域当中，因此在调用下一个函数的时候会造成声明处于栈内存中的局部变量被析构掉，最终<strong>只有第一次使用的是正确的数值，第二个函数调用后就默认指向随机位置，获取到的值也是随机获取数值</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int *testa()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	int a = 3;</span></span><br><span class="line"><span class="comment">// 	return &amp;a;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 上述代码产生报错：warning: address of local variable ‘a’ returned [-Wreturn-local-addr]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">testa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *temp = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">	*temp = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *num = <span class="built_in">testa</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;第一次函数调用的数值是：&quot;</span> &lt;&lt; *num &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;第二次函数调用的数值是：&quot;</span> &lt;&lt; *num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2、ifndef"><a href="#2、ifndef" class="headerlink" title="2、ifndef"></a>2、ifndef</h2><p>​		<code>#ifndef</code> 是<code>&quot;if not defined&quot;</code>的简写，是预处理功能（宏定义、文件包含、条件编译）当中的条件编译，在实际开发中可以用于做<code>test</code>或者不同版本的不同适配。<br> 在<code>vscode</code>中可以通过<code>json</code>脚本的<code>define</code>来定义<code>ifndef</code>的值，或者在通过<code>gcc</code>编译的时候添加上宏来进行条件编译。</p>
<p>​		<code>ifndef</code>可以根据是否已经定义了一个变量来进行分支选择，其作用是：</p>
<pre><code>1. 防止头文件的重复包含和编译；
2. 便于程序的调试和移植；
</code></pre>
<p>一般格式是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> <span class="string">&lt;标识&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> <span class="string">&lt;标识&gt;</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>**&lt;标识&gt;**在理论上来说是可以自由命名的，但每个头文件的这个“标识”都应该是唯一的。标识的明明规则一般是头文件名全大写，前面加下划线，并把文件名中的<code>.</code>也变成下划线，如：<code>stdio.h</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _STDIO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _STDIO_H</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>注意：<code>#ifndef</code>起到的效果是防止一个源文件多次包含同一个头文件，而不是防止两个源文件包含同一个头文件。事实上，防止同一头文件被两个不同的源文件包含这种要求本身就是不合理的，头文件存在的价值就是被不同的源文件包含。</p>
<h2 id="3、判断字符、数字以及大小写转换函数"><a href="#3、判断字符、数字以及大小写转换函数" class="headerlink" title="3、判断字符、数字以及大小写转换函数"></a>3、判断字符、数字以及大小写转换函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">islower</span>(<span class="type">char</span> c) <span class="comment">// 是否为小写字母</span></span><br><span class="line"><span class="built_in">isupper</span>(<span class="type">char</span> c) <span class="comment">// 是否为大写字母</span></span><br><span class="line"><span class="built_in">isdigit</span>(<span class="type">char</span> c) <span class="comment">// 是否为数字</span></span><br><span class="line"><span class="built_in">isalpha</span>(<span class="type">char</span> c) <span class="comment">// 是否为字母</span></span><br><span class="line"><span class="built_in">isalnum</span>(<span class="type">char</span> c) <span class="comment">// 是否为字母或者数字</span></span><br><span class="line"><span class="built_in">toupper</span>(<span class="type">char</span> c) <span class="comment">// 字母小转大</span></span><br><span class="line"><span class="built_in">tolower</span>(<span class="type">char</span> c) <span class="comment">// 字母大转小</span></span><br></pre></td></tr></table></figure>

<h2 id="4、顶层const和底层const"><a href="#4、顶层const和底层const" class="headerlink" title="4、顶层const和底层const"></a>4、顶层const和底层const</h2><p>指针本身是一个对象，它又可以指向另一个对象，因此，指针是不是常量以及指针所指的对象是不是一个常量是两个独立的问题。</p>
<p><code>顶层const</code>表示指针本身是一个常量，不能改变，不能指向其他对象。<code>底层const</code>表示指针所指的对象是一个常量，该对象的值不能改变。</p>
<p>更一般的，<code>顶层const</code>可以表示任意的对象是常量，对任何的数据类型都适用。<code>底层const</code>则与指针和引用等复合类型的基本类型有关。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i;    		<span class="comment">// 不能改变p1的值，是一个顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>;     		<span class="comment">// 不能改变ci的值，是一个顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci;   		<span class="comment">// 允许改变p2的值，是一个底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2;	<span class="comment">// 靠右的const是顶层const，靠左的是底层const</span></span><br></pre></td></tr></table></figure>

<h2 id="5、string的size类型为什么是string-size-t而不是int"><a href="#5、string的size类型为什么是string-size-t而不是int" class="headerlink" title="5、string的size类型为什么是string::size_t而不是int"></a>5、string的size类型为什么是string::size_t而不是int</h2><p><code>std::string</code> 的 <code>size</code> 类型被定义为 <code>string::size_t</code> 而不是 <code>int</code>，是为了提高通用性和可移植性。这是因为字符串的大小（长度）可能非常大，而 <code>int</code> 类型的范围是有限的，因此可能无法表示所有可能的字符串大小。</p>
<p><code>string::size_t</code> 是一个无符号整数类型，通常被定义为一个足够大的整数，以便可以容纳字符串的任何合法大小。它的大小通常与系统架构和编译器有关，但通常足够大以容纳大多数字符串的长度。</p>
<p>使用 <code>string::size_t</code> 而不是 <code>int</code> 有以下几个好处：</p>
<ol>
<li><strong>能够表示更大的字符串：</strong> 无符号整数类型 <code>size_t</code> 可以容纳比 <code>int</code> 更大的值，这对于处理非常大的字符串是必要的。</li>
<li><strong>提高可移植性：</strong> 使用 <code>string::size_t</code> 可以确保代码在不同的平台上具有相同的行为，因为 <code>size_t</code> 的大小会根据平台而变化，而不是固定的。</li>
<li><strong>避免符号问题：</strong> <code>size_t</code> 是无符号类型，避免了符号整数的问题，如溢出等。</li>
</ol>
<p>综上所述，使用 <code>string::size_t</code> 作为字符串大小的类型是一种良好的设计选择，可以确保代码能够处理各种大小的字符串，并提高了代码的可移植性。如果你需要与其他整数类型进行比较，你可以将 <code>size_t</code> 强制类型转换为 <code>int</code> 或其他整数类型。</p>
<h2 id="6、typedef函数"><a href="#6、typedef函数" class="headerlink" title="6、typedef函数"></a>6、typedef函数</h2><p>四种常见用法：</p>
<p>1）给已定义的变量类型起个别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">① </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;       </span><br><span class="line"><span class="comment">// uint8_t就是unsigned char的别名，这是最基础的用法</span></span><br><span class="line"></span><br><span class="line">②</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>    name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">uint8_t</span> age;</span><br><span class="line">    <span class="type">uint8_t</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> __person <span class="type">person_t</span>;</span><br><span class="line"><span class="comment">// 以上两段代码也可合并为一段，如下：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>    name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">uint8_t</span> age;</span><br><span class="line">    <span class="type">uint8_t</span> height;</span><br><span class="line">&#125;<span class="type">person_t</span>;</span><br><span class="line"><span class="comment">// 给struct  __person起了个别名person_t</span></span><br></pre></td></tr></table></figure>

<p>2）定义函数指针类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义函数指针变量</span></span><br><span class="line"><span class="built_in">int</span> (*pFunc)(<span class="type">char</span> *frame, <span class="type">int</span> len);</span><br><span class="line"><span class="comment">// 定义了一个函数指针变量pFunc，它可以指向这样的函数：返回值为int，形参为char*、int</span></span><br><span class="line"><span class="type">int</span> *(*pFunc[<span class="number">5</span>])(<span class="type">int</span> len);</span><br><span class="line"><span class="comment">// 定义了5个函数指针变量：pFunc[0]、pFunc[1]···，它们都可以指向这样的函数：返回值为int*，形参为int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.定义函数指针类型</span></span><br><span class="line"><span class="comment">// 定义函数指针类型，必须使用typedef，方法就是，在“定义函数指针变量”加上typedef</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*pFunc_t)</span><span class="params">(<span class="type">char</span> *frame, <span class="type">int</span> len)</span></span>;  <span class="comment">// 定义了一个类型函数指针pFunc_t</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span>  <span class="title">int</span> <span class="params">(*pFunc_t)</span><span class="params">(<span class="type">char</span> *frame, <span class="type">int</span> len)</span></span>;  <span class="comment">// 定义了一个类型pFunc_t</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read_voltage</span><span class="params">(<span class="type">char</span> *data, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> voltage = <span class="number">0</span>;</span><br><span class="line">    ···<span class="comment">// 其他功能代码</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> voltage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pFunc_t pHandler = read_voltage;  <span class="comment">// 使用类型pFunc_t来定义函数指针变量</span></span><br><span class="line">    ···<span class="comment">// 其他功能代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）定义数组指针类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、定义数组指针变量</span></span><br><span class="line"><span class="built_in">int</span>(*pArr)[<span class="number">5</span>];  <span class="comment">// 定义了一个数组指针变量pArr，pArr可以指向一个int [5]的一维数组</span></span><br><span class="line"><span class="built_in">char</span>(*pArr)[<span class="number">4</span>][<span class="number">5</span>];  <span class="comment">// 定义了一个数组指针变量pArr，pArr可以指向一个char[4][5]的二维数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>(*pArr)[<span class="number">5</span>];  <span class="comment">// pArr是一个指向含5个int元素的一维数组的指针变量</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">pArr = &amp;a;				<span class="comment">// 完全合法，无警告</span></span><br><span class="line">pArr = a;				<span class="comment">// 发生编译警告，赋值时类型不匹配：a的类型为int(*)，而pArr的类型为int(*)[5]</span></span><br><span class="line">pArr = &amp;a[<span class="number">0</span>];			<span class="comment">// 发生编译警告，赋值时类型不匹配：a的类型为int(*)，而pArr的类型为int(*)[5]</span></span><br><span class="line">pArr = &amp;b;				<span class="comment">// 发生编译警告，赋值时类型不匹配：&amp;b的类型为int(*)[6]，而pArr的类型为int(*)[5]</span></span><br><span class="line">pArr = (<span class="built_in">int</span>(*)[<span class="number">5</span>])&amp;b;	<span class="comment">// 类型强制转换为int(*)[5]，完全合法，无警告</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、定义数组指针类型</span></span><br><span class="line"><span class="comment">// 如同上面定义函数指针类型的方法，直接在前面加typedef即可，例如</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*pArr_t)</span>[5]</span>; <span class="comment">// 定义了一个指针类型pArr_t，该类型的指针可以指向含5个int元素的数组</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*pArr_t)</span>[5]</span>;  <span class="comment">// 定义一个指针类型，该类型的指针可以指向含5个int元素的一维数组</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    pArr_t pA;<span class="comment">//定义数组指针变量pA</span></span><br><span class="line">    pA= &amp;a;<span class="comment">//完全合法，无警告    </span></span><br><span class="line">    pA= (pArr_t)&amp;b;<span class="comment">//类型强制转换为pArr_t，完全合法，无警告</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）定义数组类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果我们想声明一个含5个int元素的一维数组，一般会这么写：int a[5];</span></span><br><span class="line"><span class="comment">// 如果我们想声明多个含5个int元素的一维数组，一般会这么写：int a1[5], a2[5], a3[5]···，或者 a[N][5]</span></span><br><span class="line"><span class="comment">// 可见，对于定义多个一维数组，写起来略显复杂，这时，我们就应该把数组定义为一个类型，例如：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">arr_t</span>[<span class="number">5</span>]; <span class="comment">// 定义了一个数组类型arr_t，该类型的变量是个数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">arr_t</span> d;        	<span class="comment">// d是个数组，这一行等价于:  int d[5];</span></span><br><span class="line">    <span class="type">arr_t</span> b1, b2, b3;	<span class="comment">// b1, b2, b3都是数组</span></span><br><span class="line"></span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    d[<span class="number">4</span>] = <span class="number">134</span>;</span><br><span class="line">    d[<span class="number">5</span>] = <span class="number">253</span>;  <span class="comment">// 编译警告：下标越界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、mutable关键字"><a href="#7、mutable关键字" class="headerlink" title="7、mutable关键字"></a>7、mutable关键字</h2><p>首先，<code>c++</code>在类中引入<code>const</code>关键字 在成员函数尾部，使函数成为 常成员函数。这么做的目的是，在常成员函数内部，不允许修改调用它的对象的内部状态（即对象的成员变量）。此时，如果想在常成员函数内部修改对象的某个成员变量时，就需要引入<code>mutable</code>，将该对象的成员变量定义为<code>mutable</code>变量。但是，我们会把定义为<code>mutable</code>的这个变量，看做不属于对象的状态。这样，即使在常成员函数内部，<code>mutable</code>变量也可以被修改，与此同时，常成员函数内部，对于对象的其他成员变量（即对象的内部状态）还是不能修改的。</p>
<p>总结下： </p>
<ul>
<li><code>const</code>关键字，用于常成员函数，即“不允许在常成员函数内部修改对象状态的值。 </li>
<li><code>mutable</code>关键字，用于常成员函数，即“允许修改常成员函数内部不是对象状态的值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">A</span>(<span class="type">int</span> a): <span class="built_in">m_na</span>(a), <span class="built_in">m_nCount</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">      ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> m_na;</span><br><span class="line">      <span class="keyword">mutable</span> <span class="type">int</span> m_nCount;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.cpp   </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::display</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ++m_nCount;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;call func display()&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::getCount</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> m_nCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="function">QApplication <span class="title">aaa</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">      <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">      a.<span class="built_in">display</span>();</span><br><span class="line">      a.<span class="built_in">display</span>();</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;call func &quot;</span> &lt;&lt; a.<span class="built_in">getCount</span>() &lt;&lt; <span class="string">&quot; times.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> aaa.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="string">&quot;call func display()&quot;</span></span><br><span class="line"># <span class="string">&quot;call func display()&quot;</span></span><br><span class="line"># <span class="string">&quot;call func 2 times.&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="8、不完全类型"><a href="#8、不完全类型" class="headerlink" title="8、不完全类型"></a>8、不完全类型</h2><p>在一个给定的源文件中，一个类只能被定义一次，如果在多个文件中定义一个类，那么每个文件中的定义必须是完全相同的。一旦遇到花括号，类的定义就结束了。并且一旦定义了类，我们就知道所有类的成员，以及存储该类的对象所需的存储空间。</p>
<p>将类定义放在头文件中，可以保证在每个使用类的文件中以同样的方式定义类。使用头文件保护符，来保证即使头文件在同一个文件中被包含多次，类定义也只出现一次。</p>
<p>只声明却没有定义的类称为<strong>不完全类型</strong>，不完全类型不能定义该类型的对象，只能用于定义指向该类型的指针及引用，或者用于声明（不是定义）使用该类型作为形参类型或返回类型的函数。</p>
<p><strong>在创建类的对象之前，必须完整地定义该类。必须定义，而不是声明类，这样，编译器就会给类的对象预定相应的存储空间。同样的，在使用引用或指针访问类的成员之前，必须已经定义类。</strong>只有当类定义已经在前面出现过，数据成员才能被制定为该类类型。<strong>如果该类型是不完全类型，那么数据成员只能是指向该类类型的指针或引用。</strong></p>
<p>可以声明一个类而不定义它：这个声明称为<strong>前向声明</strong>。类的前向声明一般用来编写相互依赖的类。在声明之后，定义之前，类称为<strong>不完全类型</strong>，即已知Screen类是一个类型，但不知道包含哪些成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>；</span><br></pre></td></tr></table></figure>

<p>因为只有当类定义体完成后才能定义类，因此<strong>类不能具有自身类型的数据成员</strong>，然而，只要类名一出现就可以认为该类已经声明，因此，<strong>类的数据成员可以是指向自身类型的指针或引用</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkScreen</span>&#123;</span><br><span class="line">    Screen window;</span><br><span class="line">    LinkScreen *next;</span><br><span class="line">    LinkScreen *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>static</code>数据成员也可以是该成员所属的类类型。<code>非static</code>成员被限定声明为其自身类对象的指针或引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">static</span> Bar mem1;<span class="comment">//ok</span></span><br><span class="line">   Bar *mem2;<span class="comment">//ok</span></span><br><span class="line">   Bar mem3;<span class="comment">//no!!!!因为Bar是一个不完全类型，所以只能定义它的非static的指针或引用。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code相关</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>《C++ Primer习题集》</title>
    <url>/2023/08/06/code%E7%9B%B8%E5%85%B3/C++/%E3%80%8AC++%20Primer%E4%B9%A0%E9%A2%98%E9%9B%86%E3%80%8B/</url>
    <content><![CDATA[<h1 id="第一章-开始"><a href="#第一章-开始" class="headerlink" title="第一章 开始"></a>第一章 开始</h1><h2 id="练习1-2"><a href="#练习1-2" class="headerlink" title="练习1.2"></a>练习1.2</h2><p>在<code>linux</code>系统中，通过<code>echo $?</code>可以获取该命令的返回值。返回值是一个整数，用于表示命令执行的结果。</p>
<p>一些常见的返回值含义如下：</p>
<pre><code>0 : 命令成功执行，没有错误。
1 : 一般错误，没有具体的错误代码。
2 : 语法错误或命令执行失败。
126 : 命令无法执行，可能缺少执行权限。
127 : 命令不存在或无法找到。
128 : 无效的退出参数。
130 : 命令被中断，通常由用户按下Ctrl+C导致。
255 : 命令执行失败，通常由于出现无效的返回值。
</code></pre>
<span id="more"></span>

<h2 id="练习-1-6"><a href="#练习-1-6" class="headerlink" title="练习 1.6"></a>练习 1.6</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; v1;</span><br><span class="line">	      &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2;</span><br><span class="line">		  &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; v1 + v2 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>这是很容易出现的错误。前两行的末尾有分号，表示语句结束，因此第2、3行为两条新的语句，缺少了<code>std::cout</code>。</p>
<h2 id="练习1-14"><a href="#练习1-14" class="headerlink" title="练习1.14"></a>练习1.14</h2><p>对比<code>for</code>循环和<code>while</code>循环：</p>
<p>在循环次数已知的情况下，<code>for</code>循环的形式显然更为简洁。</p>
<p>而循环次数无法预知时，用<code>while</code>循环实现更适合。用特定条件控制循环是否执行，循环体中执行的语句可能导致循环判定条件发生变化。</p>
<h2 id="练习1-16"><a href="#练习1-16" class="headerlink" title="练习1.16"></a>练习1.16</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, value = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一组数，按ctrl+d表示结束：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(; cin &gt;&gt; value; )</span><br><span class="line">        sum += value;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;读入的数的和为：&quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题重要的是<code>for(; cin &gt;&gt; value ;)</code>，以及后面的题中出现的<code>while(cin &gt;&gt; book)</code>，这种对输入流的结束判断。</p>
<p>注意，当从键盘向程序输入数据时，对于如何指出文件结束，不同操作系统有不同的约定。在Window系统中，输入<strong>文件结束符</strong>的方法是<code>Ctrl+Z</code>，然后按<code>Enter/Return</code>。在<code>Unix</code>系统中，包括<code>MacOSX</code>系统中，文件结束符输入是用<code>Ctrl+D</code>。</p>
<h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 2.26</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> buf;  <span class="comment">// const对象必须初始化</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> sz = cnt;</span><br><span class="line">    ++cnt;</span><br><span class="line">    ++sz;  <span class="comment">// 非法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.27</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">-1</span>, &amp;r = <span class="number">0</span>;         <span class="comment">// &amp;r = 0非法，非常量引用不能引用字面值常量0</span></span><br><span class="line">    <span class="type">int</span> *<span class="type">const</span> p2 = &amp;i2;        <span class="comment">// 合法，p2为常量指针，因此p2永远指向变量i2</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> i = <span class="number">-1</span>, &amp;r = <span class="number">0</span>;   <span class="comment">// 合法，常量i和常量引用r</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = &amp;i2;  <span class="comment">// 合法，常量指针p3指向变量i2，且由于p3指向const，不能通过p3修改i2</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p1 = &amp;i2;        <span class="comment">// 合法，p1指向const，不能通过p1修改i2</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;<span class="type">const</span> r2;        <span class="comment">// 非法，引用非对象，不能让引用恒定不变</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> i2 = i, &amp;r = i;   <span class="comment">// 合法，常量i2和常量引用r</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.28</span></span><br><span class="line">    <span class="comment">// (a) 以下四条均非法，记住涉及到某类型为常量时必须初始化，如这里的常量指针 </span></span><br><span class="line">    <span class="type">int</span> i, *<span class="type">const</span> cp;           </span><br><span class="line">    <span class="type">int</span> *p1, *<span class="type">const</span> p2;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ic, &amp;r = ic;  </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3;</span><br><span class="line">    <span class="comment">// (b) 合法，指针常量，但p没有指向任何实际的对象</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.30</span></span><br><span class="line">    <span class="comment">// 顶层const：表示任意的对象是常量； </span></span><br><span class="line">    <span class="comment">// 底层const：所指的对象是常量，与指针和引用等复合类型的基本数据类型部分有关</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.32</span></span><br><span class="line">    <span class="comment">// int null = 0, *p = null; 非法</span></span><br><span class="line">    <span class="type">int</span> null = <span class="number">0</span>, *p = <span class="literal">nullptr</span>;  <span class="comment">// nullptr是表示空指针的字面值常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.36</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(a) c = a;</span><br><span class="line">    <span class="keyword">decltype</span>((b)) d = a;  <span class="comment">// int &amp;d = a;</span></span><br><span class="line">    ++c;</span><br><span class="line">    ++d;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>    <span class="comment">// 4</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span>    <span class="comment">// 5</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>    <span class="comment">// 4</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;d=&quot;</span> &lt;&lt; d &lt;&lt; endl;  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-字符串、向量和数组"><a href="#第三章-字符串、向量和数组" class="headerlink" title="第三章 字符串、向量和数组"></a>第三章 字符串、向量和数组</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.2</span></span><br><span class="line"><span class="comment">// 一次读入一行</span></span><br><span class="line">string line;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin, line))</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一次读入一个词</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; word)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.3</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        1、标准库string的输入运算符自动忽略字符串开头的空白(包括空格符、换行符、制表符等),从第一个真正的字符开始读起，直到遇见下一处空白为止。</span></span><br><span class="line"><span class="comment">        2、如果希望在最终的字符串中保留输入时的空白符，应该使用getline函数代替原来的&gt;&gt;运算符，</span></span><br><span class="line"><span class="comment">            getline从给定的输入流中读取数据，直到遇到换行符为止，此时换行符也被读取进来，但是并不存储在最后的字符串中。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.4</span></span><br><span class="line">string str1, str2;</span><br><span class="line">cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1=&quot;</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;str2=&quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输出较大的字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span>(str1 != str2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(str1 &gt; str2)</span><br><span class="line">        cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输出较长的字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span>(str1.<span class="built_in">size</span>() != str2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(str1.<span class="built_in">size</span>() &gt; str2.<span class="built_in">size</span>())</span><br><span class="line">        cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.5 </span></span><br><span class="line">string str, str_sum;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; str)</span><br><span class="line">&#123;</span><br><span class="line">    str_sum += str;</span><br><span class="line">    str_sum += <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; str_sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.6</span></span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;at begin str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : str)</span><br><span class="line">    c = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.7</span></span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;at begin str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span> &amp;c : str)</span><br><span class="line">    c = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.8</span></span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;at begin str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"><span class="comment">// while</span></span><br><span class="line">string::size_type i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; str.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    str[i] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"><span class="comment">// for（传统）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">decltype</span>(str.<span class="built_in">size</span>()) i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    str[i] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.9</span></span><br><span class="line">string s;</span><br><span class="line">cout &lt;&lt; s[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.10</span></span><br><span class="line">string line, new_line;</span><br><span class="line"><span class="built_in">getline</span>(cin, line);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;at begin line=&quot;</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">decltype</span>(line.<span class="built_in">size</span>()) i = <span class="number">0</span>; i &lt; line.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">ispunct</span>(line[i]))</span><br><span class="line">        new_line += line[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now str=&quot;</span> &lt;&lt; new_line &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.11</span></span><br><span class="line"><span class="type">const</span> string s = <span class="string">&quot;Keep out!&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.14</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; i)</span><br><span class="line">&#123;</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.15</span></span><br><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.17</span></span><br><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">string str;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; str)</span><br><span class="line">&#123;</span><br><span class="line">    svec.<span class="built_in">push_back</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s : svec)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="built_in">toupper</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.18</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="comment">// ivec[0] = 42;</span></span><br><span class="line">ivec.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.19</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec1</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec2&#123;<span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec3;</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::size_type i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    ivec3.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.20</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; i)</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::size_type i = <span class="number">0</span>; i &lt; ivec.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;和第&quot;</span> &lt;&lt; i+<span class="number">2</span> &lt;&lt; <span class="string">&quot;的和是&quot;</span> &lt;&lt; ivec[i] + ivec[i+<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::size_type i = <span class="number">0</span>; i &lt; ivec.<span class="built_in">size</span>()/<span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;和第&quot;</span> &lt;&lt; ivec.<span class="built_in">size</span>()-i &lt;&lt; <span class="string">&quot;的和是&quot;</span> &lt;&lt; ivec[i] + ivec[ivec.<span class="built_in">size</span>()-i<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.22</span></span><br><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin, s))</span><br><span class="line">    svec.<span class="built_in">push_back</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> s = svec.<span class="built_in">begin</span>(); s != svec.<span class="built_in">end</span>() &amp;&amp; !s-&gt;<span class="built_in">empty</span>(); s++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = s-&gt;<span class="built_in">begin</span>(); it != s-&gt;<span class="built_in">end</span>(); it++)</span><br><span class="line">        *it = <span class="built_in">toupper</span>(*it);</span><br><span class="line">    cout &lt;&lt; *s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.23</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : ivec)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; i;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = ivec.<span class="built_in">begin</span>(); it != ivec.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    *it = (*it) * <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.24</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; i)</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = ivec.<span class="built_in">begin</span>(); it != ivec.<span class="built_in">end</span>() - <span class="number">1</span>; it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it + *(it+<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-------------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">auto</span> beg = ivec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> end = ivec.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = beg; it != beg + (end - beg) / <span class="number">2</span>; it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it + *(beg + (end - it) - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ivec.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">    cout &lt;&lt; *(beg + (end - beg) / <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.25</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">unsigned</span>&gt; <span class="title">scores</span><span class="params">(<span class="number">11</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">unsigned</span> grade;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; grade)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(grade &lt;= <span class="number">100</span>)</span><br><span class="line">        ++*(scores.<span class="built_in">begin</span>() + grade / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : scores)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.26</span></span><br><span class="line"><span class="comment">// 二分搜索程序中，为什么用的是 mid = beg + (end - beg) / 2，而非 mid = (beg + end) / 2</span></span><br><span class="line"><span class="comment">// C++并没有定义两个迭代器的加法运算，实际上直接把两个迭代器加起来是没有意义的。</span></span><br><span class="line"><span class="comment">// 与之相反，C++定义了迭代器的减法运算，两个迭代器相减的结果是它们之间的距离;</span></span><br><span class="line"><span class="comment">// 也就是说，将运算符右侧的迭代器向前移动多少个元素后可以得到左侧的迭代器，参与运算的两个迭代器必须指向同一个容器中的元素或尾后元素。</span></span><br><span class="line"><span class="comment">// 另外，C++还定义了迭代器与整数的加减法运算，用以控制迭代器在容器中左右移动。</span></span><br><span class="line"><span class="comment">// 在本题中，因为迭代器的加法不存在，所以mid=(beg+end)/2;不合法。mid = beg+(end - beg)/ 2;的含义是，先计算end-beg的值得到容器中的元素个数，然后控制迭代器从开始处向右移动二分之一容器的长度，从而定位到容器正中间的元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.29</span></span><br><span class="line"><span class="comment">// 相对于 vector 来说，数组有哪些缺点？</span></span><br><span class="line"><span class="comment">// 1、数组的大小固定不变，不能随意向数组中增加额外的元素。如果想改变数组的长度，必须创建一个更大的数组，然后将原数组的元素复制过去；</span></span><br><span class="line"><span class="comment">// 2、无法使用 size 函数直接获取数组的维度：</span></span><br><span class="line"><span class="comment">//     如果是字符数组，可以用 strlen 获取；</span></span><br><span class="line"><span class="comment">//     如果是其他数组，只能通过 sizeof(array)/sizeof(array[0]) 获取。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.31</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.32</span></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    a[i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    b[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : b)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a1;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    a1.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b1</span><span class="params">(a1)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> j : b1)</span><br><span class="line">    cout &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.33</span></span><br><span class="line"><span class="comment">// 如果不初始化scores，则该数组会含有未定义的数值，这是因为scores是定义在函数内部的整型数组，不会执行默认初始化。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.35</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> *b = <span class="built_in">begin</span>(a);</span><br><span class="line"><span class="keyword">auto</span> *e = <span class="built_in">end</span>(a);</span><br><span class="line"><span class="keyword">while</span>(b != e)</span><br><span class="line">&#123;   </span><br><span class="line">    *b = <span class="number">0</span>;</span><br><span class="line">    ++b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// int *p = a;</span></span><br><span class="line"><span class="comment">// for(int i = 0; i &lt; 4; i++)</span></span><br><span class="line"><span class="comment">//     *(p+i) = 0;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : a)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.36</span></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> *ita = <span class="built_in">begin</span>(a);</span><br><span class="line"><span class="keyword">auto</span> *itb = <span class="built_in">begin</span>(b);</span><br><span class="line"><span class="keyword">while</span>(ita != <span class="built_in">end</span>(a) &amp;&amp; itb != <span class="built_in">end</span>(b))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*ita != *itb)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;两个数组不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ita++;</span><br><span class="line">    itb++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;两个数组相等&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// vector</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec1</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it1 = ivec1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> it2 = ivec2.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it1 != ivec1.<span class="built_in">end</span>() &amp;&amp; it2 != ivec2.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*it1 != *it2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;两个数组不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    it1++;</span><br><span class="line">    it2++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;两个数组相等&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.37</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> ca[] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cp = ca;</span><br><span class="line"><span class="keyword">while</span>(*cp)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *cp &lt;&lt; endl;</span><br><span class="line">    ++cp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个程序原意是想依次输出“hello”这5个字符，</span></span><br><span class="line"><span class="comment">// 但是由于数组ca的末尾不包含空字符&#x27;\0&#x27;，因此可能输出&#x27;o&#x27;后会继续输出，直至遇到空字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.38</span></span><br><span class="line"><span class="comment">// 两个指针的相加是无意义的。</span></span><br><span class="line"><span class="comment">// 指针本身的值是一个内存地址值，表示指针所指对象在内存中的存储地址。</span></span><br><span class="line"><span class="comment">// 如果把两个指针相加，意味着把两个对象的存储地址加在一起，这是没有意义的；</span></span><br><span class="line"><span class="comment">// 如果两个指针指向同一个数组中的不同元素，则它们相减的结果表征了它们所指的元素在数组中的距离。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.39</span></span><br><span class="line">string s1, s2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入两个字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line"><span class="keyword">if</span>(s1 &gt; s2)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 &gt; s2&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 &lt; s2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ca1[<span class="number">80</span>], ca2[<span class="number">80</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入两个字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; ca1 &gt;&gt; ca2;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(ca1, ca2))</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ca1 &gt; ca2&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ca1 &lt; ca2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.40</span></span><br><span class="line"><span class="type">char</span> ca1[<span class="number">80</span>] = <span class="string">&quot;i love u&quot;</span>;</span><br><span class="line"><span class="type">char</span> ca2[<span class="number">80</span>] = <span class="string">&quot;but i love myself more.&quot;</span>;</span><br><span class="line"><span class="type">char</span> ca3[<span class="number">80</span>] = &#123;&#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(ca3, ca1);</span><br><span class="line"><span class="built_in">strcat</span>(ca3, <span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(ca3, ca2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : ca3)</span><br><span class="line">    cout &lt;&lt; i;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.41</span></span><br><span class="line"><span class="type">int</span> int_arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr), end(int_arr))</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : ivec)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.42</span></span><br><span class="line"><span class="comment">// C++允许使用数组直接初始化vector对象，但是不允许使用vector对象初始化数组。</span></span><br><span class="line"><span class="comment">// 如果想用vector对象初始化数组，则必须把vector对象的每个元素逐一赋值给数组。</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> int_arr[ivec.<span class="built_in">size</span>()] = &#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = ivec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;val : int_arr) <span class="comment">//  &amp;val-引用</span></span><br><span class="line">&#123;</span><br><span class="line">    val = *it;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    it++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-表达式"><a href="#第四章-表达式" class="headerlink" title="第四章 表达式"></a>第四章 表达式</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.21</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec; </span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一组整数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; num)</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(num);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : ivec)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;    </span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now the vec:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : ivec)</span><br><span class="line">    cout &lt;&lt; ((i % <span class="number">2</span> == <span class="number">0</span>) ? i : i * <span class="number">2</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;    </span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.22</span></span><br><span class="line"><span class="type">int</span> grade;</span><br><span class="line"><span class="comment">// 条件运算符</span></span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; grade)</span><br><span class="line">&#123;</span><br><span class="line">    string final_grade = (grade &gt; <span class="number">90</span>) ? <span class="string">&quot;high pass&quot;</span> </span><br><span class="line">        : (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> </span><br><span class="line">            : (grade &gt; <span class="number">60</span> &amp;&amp; grade &lt; <span class="number">75</span>) ? <span class="string">&quot;low pass&quot;</span></span><br><span class="line">                : <span class="string">&quot;pass&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;final grade is: &quot;</span> &lt;&lt; final_grade &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// // if语句</span></span><br><span class="line"><span class="comment">// while(cin &gt;&gt; grade)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     if(grade &gt; 90)</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;high pass&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     else if(grade &gt; 60 &amp;&amp; grade &lt; 75)</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;low pass&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     else if(grade &lt; 60)</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;fail&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     else</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;pass&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.28</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;类型名称\t&quot;</span> &lt;&lt;<span class="string">&quot;所占空间&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bool\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">bool</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;char\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;wchar_t\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;char16_t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char16_t</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;char32_t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char32_t</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;short\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long long\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;float\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;double\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long double\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">double</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.29</span></span><br><span class="line"><span class="type">int</span> x[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p = x;</span><br><span class="line">cout &lt;&lt; (<span class="built_in">sizeof</span>(x) / <span class="built_in">sizeof</span>(*x)) &lt;&lt; endl; <span class="comment">// 10(40/4)</span></span><br><span class="line">cout &lt;&lt; (<span class="built_in">sizeof</span>(p) / <span class="built_in">sizeof</span>(*p)) &lt;&lt; endl; <span class="comment">// 2(8/2) 指针所占的空间大小为8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.37</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="type">const</span> string *ps;</span><br><span class="line"><span class="type">char</span> *pc;</span><br><span class="line"><span class="type">void</span> *pv;</span><br><span class="line">pv = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt; (<span class="built_in">const_cast</span>&lt;string*&gt; (ps));     <span class="comment">// pv = (void*)ps;</span></span><br><span class="line">i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt; (*pc);                             <span class="comment">// i = int(*pc);</span></span><br><span class="line">pv = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt; (&amp;d);                           <span class="comment">// pv = &amp;d;</span></span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt; (pv);                           <span class="comment">// pc = (char*)pv;</span></span><br></pre></td></tr></table></figure>

<h1 id="第五章-语句"><a href="#第五章-语句" class="headerlink" title="第五章 语句"></a>第五章 语句</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.5 </span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; grade;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">string grade_[] = &#123;<span class="string">&quot;D&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span> || num &gt; <span class="number">100</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误成绩！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    grade.<span class="built_in">push_back</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : grade)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; grade.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(grade[i] &gt;= <span class="number">60</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;the grade &quot;</span> &lt;&lt; grade[i] &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; grade_[grade[i] / <span class="number">10</span> - <span class="number">6</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;the grade &quot;</span> &lt;&lt; grade[i] &lt;&lt; <span class="string">&quot; is F&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.6</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; grade;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">string grade_[] = &#123;<span class="string">&quot;D&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span> || num &gt; <span class="number">100</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误成绩！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    grade.<span class="built_in">push_back</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : grade)</span><br><span class="line">&#123;</span><br><span class="line">    string final_grade = (i &lt; <span class="number">60</span>) ? <span class="string">&quot;F&quot;</span> </span><br><span class="line">        : (i &gt;=<span class="number">60</span> &amp;&amp; i &lt; <span class="number">70</span>) ? <span class="string">&quot;D&quot;</span></span><br><span class="line">            : (i &gt;=<span class="number">70</span> &amp;&amp; i &lt; <span class="number">80</span>) ? <span class="string">&quot;B&quot;</span></span><br><span class="line">                : (i &gt;=<span class="number">80</span> &amp;&amp; i &lt; <span class="number">90</span>) ? <span class="string">&quot;C&quot;</span></span><br><span class="line">                    : <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the grade &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; final_grade &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.8</span></span><br><span class="line"><span class="comment">// 悬垂else是指当程序中的if分支多于else分支时，如何为else寻找与之匹配的if分支的问题。</span></span><br><span class="line"><span class="comment">// C++规定，else与离它最近的尚未匹配的if匹配，从而消除了二义性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.9</span></span><br><span class="line"><span class="type">unsigned</span> vowelCnt = <span class="number">0</span>, blankspaceCnt = <span class="number">0</span>, tabCnt = <span class="number">0</span>, lineCnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一段文本：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// while(cin &gt;&gt; ch)</span></span><br><span class="line"><span class="keyword">while</span>(cin.<span class="built_in">get</span>(ch))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>: </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line">            ++vowelCnt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            ++blankspaceCnt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">            ++tabCnt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">            ++lineCnt;</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您输入的文本中共有&quot;</span> &lt;&lt; vowelCnt &lt;&lt; <span class="string">&quot;个元音字母&quot;</span> &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; blankspaceCnt &lt;&lt; <span class="string">&quot;个空格&quot;</span> &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; tabCnt &lt;&lt; <span class="string">&quot;个制表符&quot;</span> &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; lineCnt &lt;&lt; <span class="string">&quot;个换行符&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.10</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ffCnt = <span class="number">0</span>, flCnt = <span class="number">0</span>, fiCnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch, prech = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一段文本：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> bl = <span class="literal">true</span>;  <span class="comment">// 避免重复统计ff</span></span><br><span class="line">    <span class="keyword">if</span>(prech == <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">                ++ffCnt;</span><br><span class="line">                bl = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">                ++flCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                ++fiCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!bl)</span><br><span class="line">        prech = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prech = ch;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ff的数量是：&quot;</span> &lt;&lt; ffCnt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;fl的数量是：&quot;</span> &lt;&lt; flCnt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;fi的数量是：&quot;</span> &lt;&lt; fiCnt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.14</span></span><br><span class="line">string cur_str, pre_str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一句话：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; cur_str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur_str == pre_str)</span><br><span class="line">        ++cnt;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre_str != <span class="string">&quot;&quot;</span>)</span><br><span class="line">            cout &lt;&lt; pre_str &lt;&lt; <span class="string">&quot;连续出现了&quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot;次&quot;</span> &lt;&lt; endl;</span><br><span class="line">        pre_str = cur_str;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pre_str != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    cout &lt;&lt; pre_str &lt;&lt; <span class="string">&quot;连续出现了&quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot;次&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.17</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it1 = ivec1.<span class="built_in">begin</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it2 = ivec2.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it1 != ivec1.<span class="built_in">end</span>() &amp;&amp; it2 != ivec2.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*it1 != *it2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1和v2之间不存在前缀关系&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    it1++;</span><br><span class="line">    it2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(it1 == ivec1.<span class="built_in">end</span>())</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1是v2的前缀&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span>(it2 == ivec2.<span class="built_in">end</span>())</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1是v2的前缀&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.19</span></span><br><span class="line">string str1, str2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入两个字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(str1.<span class="built_in">length</span>() != str2.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str1.<span class="built_in">length</span>() &lt; str2.<span class="built_in">length</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;较短的字符串为：&quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;较短的字符串为：&quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(cin &gt;&gt; str1 &gt;&gt; str2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.20</span></span><br><span class="line">string cur_str, pre_str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">bool</span> bl = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; cur_str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur_str == pre_str)</span><br><span class="line">    &#123;</span><br><span class="line">        bl = <span class="literal">false</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;重复出现的词：&quot;</span> &lt;&lt; pre_str &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre_str = cur_str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(bl)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有重复出现的词！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.21</span></span><br><span class="line">string cur_str, pre_str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">bool</span> bl = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; cur_str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isupper</span>(cur_str[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(cur_str == pre_str)</span><br><span class="line">    &#123;</span><br><span class="line">        bl = <span class="literal">false</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;重复出现的词（必须以大写开头）：&quot;</span> &lt;&lt; pre_str &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre_str = cur_str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(bl)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有重复出现的词（必须以大写开头）！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.23</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请依次输入被除数和除数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> i1, i2;</span><br><span class="line">cin &gt;&gt; i1 &gt;&gt; i2;</span><br><span class="line"><span class="keyword">if</span>(i2 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;除数不能为0！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i1/i2=&quot;</span> &lt;&lt; i1 / i2 &lt;&lt; endl;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.24</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请依次输入被除数和除数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> i1, i2;</span><br><span class="line">cin &gt;&gt; i1 &gt;&gt; i2;</span><br><span class="line"><span class="keyword">if</span>(i2 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;除数不能为0！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i1/i2=&quot;</span> &lt;&lt; i1 / i2 &lt;&lt; endl;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.25</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请依次输入被除数和除数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> i1, i2;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; i1 &gt;&gt; i2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i2 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;除数不能为0！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i1/i2=&quot;</span> &lt;&lt; i1 / i2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(runtime_error err)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;需要继续吗？（y or n）&quot;</span>;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line">        <span class="keyword">if</span>(ch != <span class="string">&#x27;y&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h1><p>分离式编译：</p>
<p><code>fact.cc &amp; factMain.cc &amp; main6.3-h</code></p>
<p><code>fact.cc</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main6.3-.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.3</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(val &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum *= val--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>factMain.cc </code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main6.3-.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">fact</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5!=&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main6.3-h</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MAIN6_3_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MAIN6_3_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.3</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line"><span class="comment">// 6.4</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact_usr</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 6.5</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">absd</span><span class="params">(<span class="type">double</span> a)</span></span>;</span><br><span class="line"><span class="comment">// 6.7</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_calls</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 6.18</span></span><br><span class="line"><span class="comment">// bool compare(const matrix&amp; m1, const matrix&amp; m2);</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">change_val</span><span class="params">(<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;::iterator)</span></span>;</span><br><span class="line"><span class="comment">// 6.36 &amp;&amp; 6.37</span></span><br><span class="line"><span class="comment">// 直接声明</span></span><br><span class="line"><span class="built_in">string</span> (*<span class="built_in">func1</span>())[<span class="number">10</span>]; </span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> string arr[<span class="number">10</span>];</span><br><span class="line"><span class="function">arr&amp; <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 尾置返回类型</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func3</span><span class="params">()</span> -&gt; <span class="title">string</span><span class="params">(*)</span> [10]</span>;</span><br><span class="line"><span class="comment">// decltype关键字</span></span><br><span class="line">string str[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">decltype</span>(str) &amp;<span class="built_in">func4</span>();</span><br><span class="line"><span class="comment">// 6.54</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func5</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="keyword">decltype</span>(func5)*&gt; vF;<span class="comment">// 该vector对象的元素是指向函数func5的指针</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>习题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main6.3-.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.3</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(val &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum *= val--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.4</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact_usr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val_usr;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个数字以计算其阶乘：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; val_usr;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(val_usr &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum *= val_usr--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.5</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">absd</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.7</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_calls</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ctr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ctr++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.10</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_pointer</span><span class="params">(<span class="type">int</span> *p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.11</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.12</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_refer</span><span class="params">(<span class="type">int</span> &amp;r1, <span class="type">int</span> &amp;r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    temp = r1;</span><br><span class="line">    r1 = r2;</span><br><span class="line">    r2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.17</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_Upper</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(string::size_type i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isupper</span>(s[i]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">s_to_lower</span><span class="params">(string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(string::size_type i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.21</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare_int</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>* ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; *ip)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> *ip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.22</span></span><br><span class="line"><span class="comment">// 既不交换指针，也不交换指针所指的内容（局限于函数内部）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapPointer1</span><span class="params">(<span class="type">int</span>* p1, <span class="type">int</span>* p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = p1;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换指针所指的内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapPointer2</span><span class="params">(<span class="type">int</span>* p1, <span class="type">int</span>* p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换指针本身</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapPointer3</span><span class="params">(<span class="type">int</span>* &amp;p1, <span class="type">int</span>* &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = p1;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.23</span></span><br><span class="line"><span class="comment">// 参数是常量整型指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数有两个，分别是常量整型指针和数组的容量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p, <span class="type">const</span> <span class="type">int</span> sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != sz)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *p++ &lt;&lt; endl;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数有两个，分别是数组的首尾边界</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print3</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *b,<span class="type">const</span> <span class="type">int</span> *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q=b; q!=e; ++q)</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.24</span></span><br><span class="line"><span class="comment">// void print(const int ia[10])</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     for(size_t i = 0; i != 10; ++i)</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; ia[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 上述print函数的定义存在一个潜在风险</span></span><br><span class="line"><span class="comment">// 即虽然我们期望传入的数组维度是10，但实际上任意维度的数组都可以传入。</span></span><br><span class="line"><span class="comment">// 如果传入的数组维度较大，print函数输出数组的前10个元素，不至于引发错误；</span></span><br><span class="line"><span class="comment">// 相反如果传入的数组维度不足10，则print函数将强行输出一些未定义的值。</span></span><br><span class="line"><span class="comment">// 修改后的程序是：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ia[], <span class="type">const</span> <span class="type">int</span> sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i != sz; ++i)</span><br><span class="line">        cout &lt;&lt; ia[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.33</span></span><br><span class="line"><span class="comment">// 递归输出vector对象的内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vInt, <span class="type">unsigned</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> sz = vInt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(!vInt.<span class="built_in">empty</span>() &amp;&amp; index &lt; sz)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; vInt[index] &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">printVector</span>(vInt, index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.55</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func11</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func12</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func13</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func14</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.56</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Compute</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>(*p)(<span class="type">int</span>, <span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">p</span>(a, b) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 6.3</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">fact</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5!=&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.4</span></span><br><span class="line">    <span class="type">int</span> n_usr = <span class="built_in">fact_usr</span>();</span><br><span class="line">    cout &lt;&lt; n_usr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.5</span></span><br><span class="line">    <span class="type">double</span> m1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入任意一个数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; m1;</span><br><span class="line">    cout &lt;&lt; m1 &lt;&lt; <span class="string">&quot;的绝对值是&quot;</span> &lt;&lt; <span class="built_in">absd</span>(m1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.7</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">count_calls</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.10</span></span><br><span class="line">    <span class="type">int</span> i1 = <span class="number">10</span>, i2 = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> *p1 = &amp;i1, *p2 = &amp;i2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i1=&quot;</span> &lt;&lt; *p1 &lt;&lt; <span class="string">&quot;, i2=&quot;</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">swap_pointer</span>(p1, p2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after swap: i1=&quot;</span> &lt;&lt; *p1 &lt;&lt; <span class="string">&quot;, i2=&quot;</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.11</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m=&quot;</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after reset, m=&quot;</span> &lt;&lt; <span class="built_in">reset</span>(m) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.12</span></span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">10</span>, n2 = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> &amp;r1 = n1, &amp;r2 = n2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;n1=&quot;</span> &lt;&lt; r1 &lt;&lt; <span class="string">&quot;, n2=&quot;</span> &lt;&lt; r2 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">swap_refer</span>(r1, r2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after swap: n1=&quot;</span> &lt;&lt; r1 &lt;&lt; <span class="string">&quot;, n2=&quot;</span> &lt;&lt; r2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.14</span></span><br><span class="line">    <span class="comment">// 练习6.14:举一个形参应该是引用类型的例子，再举一个形参不能是引用类型的例子。</span></span><br><span class="line">    <span class="comment">// 【出题思路】</span></span><br><span class="line">    <span class="comment">// 与值传递相比，引用传递的优势主要体现在三个方面：一是可以直接操作引用形参所引的对象；二是使用引用形参可以避免拷贝大的类类型对象或容器类型对象；三是使用引用形参可以帮助我们从函数中返回多个值。</span></span><br><span class="line">    <span class="comment">// 【解答】</span></span><br><span class="line">    <span class="comment">// 基于对引用传递优势的分析，我们可以举出几个适合使用引用类型形参的例子：</span></span><br><span class="line">    <span class="comment">// 第一，当函数的目的是交换两个参数的内容时应该使用引用类型的形参；第二，当参数是string对象时，为了避免拷贝很长的字符串，应该使用引用类型。</span></span><br><span class="line">    <span class="comment">// 在其他情况下可以使用值传递的方式，而无须使用引用传递，例如求整数的绝对值或者阶乘的程序。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.17</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="built_in">is_Upper</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">    string str = <span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">s_to_lower</span>(str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.21</span></span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; count &lt;&lt; &quot;: &quot; &lt;&lt; compare_int(2, a) &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// a++; // 数组名是一个常量指针，指向数组的首元素，它的值是固定的，不能通过 ++ 操作来修改</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;数组a中第&quot;</span> &lt;&lt; count + <span class="number">1</span> &lt;&lt; <span class="string">&quot;个数和2比较，较大的数是: &quot;</span> &lt;&lt; <span class="built_in">compare_int</span>(<span class="number">2</span>, &amp;a[count]) &lt;&lt; endl;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.22</span></span><br><span class="line">    <span class="type">int</span> h = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;h, *q = &amp;b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(address)h=&quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;\tb=&quot;</span> &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(context)h=&quot;</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;\tb=&quot;</span> &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// swapPointer1(p, q);</span></span><br><span class="line">    <span class="comment">// swapPointer2(p, q);</span></span><br><span class="line">    <span class="built_in">swapPointer3</span>(p, q);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after swap(address): h=&quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;\tb=&quot;</span> &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after swap(context): h=&quot;</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;\tb=&quot;</span> &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.23</span></span><br><span class="line">    <span class="type">int</span> i23 = <span class="number">0</span>, j23[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">print1</span>(&amp;i23); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">print1</span>(j23);  <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">print2</span>(&amp;i23, <span class="number">1</span>); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">print2</span>(j23, <span class="built_in">sizeof</span>(j23) / <span class="built_in">sizeof</span>(*j23)); <span class="comment">// 0, 1</span></span><br><span class="line">    <span class="keyword">auto</span> b23 = <span class="built_in">begin</span>(j23);</span><br><span class="line">    <span class="keyword">auto</span> e23 = <span class="built_in">end</span>(j23);</span><br><span class="line">    <span class="built_in">print3</span>(b23, e23); <span class="comment">// 0, 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.25</span></span><br><span class="line">    string str1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != argc; ++i)</span><br><span class="line">        str1 += argv[i];</span><br><span class="line">    cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.31</span></span><br><span class="line">    <span class="comment">// 练习6.31:什么情况下返回的引用有效?什么情况下返回常量的引用有效?</span></span><br><span class="line">    <span class="comment">// 【出题思路】</span></span><br><span class="line">    <span class="comment">// 函数返回其结果的过程与它接受参数的过程类似。如果返回的是值，则创建一个未命名的临时对象，并把要返回的值拷贝给这个临时对象；如果返回的是引用，则该引用是它所引对象的别名，,不会真正拷贝对象。</span></span><br><span class="line">    <span class="comment">// 【解答】</span></span><br><span class="line">    <span class="comment">// 如果引用所引的是函数开始之前就已经存在的对象，则返回该引用是有效的；如果引用所引的是函数的局部变量，则随着函数结束局部变量也失效了，此时返回的引用无效。</span></span><br><span class="line">    <span class="comment">// 当不希望返回的对象被修改时，返回对常量的引用。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.33</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vInt = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printVector</span>(vInt, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.55</span></span><br><span class="line">    <span class="comment">// 练习6.55：编写4个函数，分别对两个int值执行加、减、乘、除运算；在上一题创建的vector对象中保存指向这些值的指针。</span></span><br><span class="line">    <span class="keyword">decltype</span>(func11) *p11 = func11, *p21 = func12, *p31 = func13, *p41 = func14;</span><br><span class="line">    vector&lt;<span class="keyword">decltype</span>(func11)*&gt; vF = &#123;p11, p21, p31, p41&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.56</span></span><br><span class="line">    <span class="type">int</span> i11= <span class="number">5</span>, j11 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : vF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Compute</span>(i11, j11, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code相关</category>
        <category>C++</category>
      </categories>
  </entry>
</search>
