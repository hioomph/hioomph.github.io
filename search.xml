<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>小程序</title>
    <url>/2023/08/03/Python%20jpg%E5%92%8Cbmp%E8%BD%AC%E5%8C%96%E4%B8%BARGB%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1、PIL库"><a href="#1、PIL库" class="headerlink" title="1、PIL库"></a>1、PIL库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">img0 = Image.open((&#x27;pic0.jpg&#x27;))  # pic0.bmp</span><br><span class="line">img1 = img0.convert(&quot;RGB&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="2、cv2库"><a href="#2、cv2库" class="headerlink" title="2、cv2库"></a>2、cv2库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 读取BMP图像</span><br><span class="line">img0 = cv2.imread(&#x27;pic0.bmp)&#x27;</span><br><span class="line">img1 = cv2.cvtColor(img0, cv2.COLOR_BGR2RGB)  # BGR转RGB格式</span><br></pre></td></tr></table></figure>

<p><strong>cv2.cvtColor(p1, p2) 是颜色空间转换函数，p1是需要转换的图片，p2是转换成何种格式。</strong></p>
<ul>
<li>cv2.COLOR_BGR2RGB 将BGR格式转换成RGB格式</li>
<li>cv2.COLOR_BGR2GRAY 将BGR格式转换成灰度图片</li>
</ul>
<h2 id="3、txt文件转excel文件"><a href="#3、txt文件转excel文件" class="headerlink" title="3、txt文件转excel文件"></a>3、txt文件转excel文件</h2><p>txt文件：</p>
<p><img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20231113194751011.png" alt="image-20231113194751011"></p>
<p>其中数据间以逗号和空格分割。</p>
<p>程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文本文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/root/autodl-tmp/STGA/data/SHT/tpr.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data_lines = file.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据解析成二维列表</span></span><br><span class="line">data = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, line.strip().split(<span class="string">&#x27;, &#x27;</span>))) <span class="keyword">for</span> line <span class="keyword">in</span> data_lines]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Pandas DataFrame</span></span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line">df = df.transpose()  <span class="comment"># 将数据按行存储，不加这一句会把所有数据存储在一行中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 DataFrame 写入 Excel 文件</span></span><br><span class="line">df.to_excel(<span class="string">&#x27;/root/autodl-tmp/STGA/data/SHT/output.xlsx&#x27;</span>, index=<span class="literal">False</span>, header=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>解析<code>data = [list(map(float, line.strip().split(&#39;, &#39;))) for line in data_lines]</code>：</p>
<ul>
<li><code>for line in data_lines</code>: 这是一个循环语句，遍历了从文本文件中读取的每一行。</li>
<li><code>line.strip()</code>: <code>strip()</code> 方法用于去除字符串两端的空白字符（包括换行符 <code>\n</code>），确保数据不包含额外的空格或换行。</li>
<li><code>line.strip().split(&#39;, &#39;)</code>: <code>split(&#39;, &#39;)</code> 方法将字符串按照逗号和空格进行分割，返回一个由分割后的字符串组成的列表。</li>
<li><code>list(map(float, ...))</code>: <code>map(float, ...)</code> 将分割后的字符串列表中的每个元素转换为浮点数，<code>list(...)</code> 将其转换为列表。</li>
</ul>
]]></content>
      <categories>
        <category>code相关</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>c++扩展知识</title>
    <url>/2023/10/08/c++%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="1、int-p-a、p-a、-p-a的正确理解"><a href="#1、int-p-a、p-a、-p-a的正确理解" class="headerlink" title="1、int *p &#x3D; &amp;a、p &#x3D; &amp;a、*p &#x3D; a的正确理解"></a>1、int *p &#x3D; &amp;a、p &#x3D; &amp;a、*p &#x3D; a的正确理解</h2><p>1、指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;a; <span class="comment">// 初始化一个int *类型指针，同时将变量a的地址存入p指针</span></span><br></pre></td></tr></table></figure>

<p>这里是一个<strong>特殊用法，仅在初始化变量的时候可以使用</strong>，应分为两个部分去进行理解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p;	<span class="comment">// 初始化一个int * 类型指针p</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p = &amp;a; <span class="comment">// 将变量a的地址存入p指针，此时p表示变量a的地址</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*p = a; <span class="comment">// 表示指针p指向变量a，这时*p表示变量a的数值</span></span><br></pre></td></tr></table></figure>

<p><em>注：区别在于在指针中p表示一个地址，存储的是变量的位置。</em></p>
<p>  <code>*p</code>表示一个变量，存储的是一个值。在初始化变量之外使用<code>*p = &amp;a;</code>是错误的，提示不能将<code>int *</code>类型的值分配到<code>int</code>类型的实体。<br>2、引用</p>
<p>  同时在<code>C++</code>中存在引用方法，引用和指针的差异在引用绑定后不可更改绑定对象，指针可以更改指向对象。<br>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> m = <span class="number">3</span>;  <span class="comment">// 定义一个int类型变量m</span></span><br><span class="line"><span class="type">int</span> &amp;r = m; <span class="comment">// 定义引用r表示变量m，后续所有的r都可以作为m来使用，改变r的值会同步修改m</span></span><br></pre></td></tr></table></figure>

<p>相当于把<code>m</code>的地址赋给<code>r</code>，此时两个变量地址是相同的内容。<br>注：引用使用的时候需要进行初始化，指针可以不用初始化。</p>
<p>未初始化的指针可以编译通过，但可能造成野指针问题。</p>
<p>3、野指针</p>
<p>  野指针常出现在空间分配当中，例如在调用的函数中声明了返回地址类型的变量，但是由于声明的位置是在小的空间域当中，因此在调用下一个函数的时候会造成声明处于栈内存中的局部变量被析构掉，最终<strong>只有第一次使用的是正确的数值，第二个函数调用后就默认指向随机位置，获取到的值也是随机获取数值</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int *testa()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	int a = 3;</span></span><br><span class="line"><span class="comment">// 	return &amp;a;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 上述代码产生报错：warning: address of local variable ‘a’ returned [-Wreturn-local-addr]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">testa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *temp = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">	*temp = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *num = <span class="built_in">testa</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;第一次函数调用的数值是：&quot;</span> &lt;&lt; *num &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;第二次函数调用的数值是：&quot;</span> &lt;&lt; *num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、ifndef"><a href="#2、ifndef" class="headerlink" title="2、ifndef"></a>2、ifndef</h2><p>​		<code>#ifndef</code> 是<code>&quot;if not defined&quot;</code>的简写，是预处理功能（宏定义、文件包含、条件编译）当中的条件编译，在实际开发中可以用于做<code>test</code>或者不同版本的不同适配。<br> 在<code>vscode</code>中可以通过<code>json</code>脚本的<code>define</code>来定义<code>ifndef</code>的值，或者在通过<code>gcc</code>编译的时候添加上宏来进行条件编译。</p>
<p>​		<code>ifndef</code>可以根据是否已经定义了一个变量来进行分支选择，其作用是：</p>
<pre><code>1. 防止头文件的重复包含和编译；
2. 便于程序的调试和移植；
</code></pre>
<p>一般格式是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> <span class="string">&lt;标识&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> <span class="string">&lt;标识&gt;</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>**&lt;标识&gt;**在理论上来说是可以自由命名的，但每个头文件的这个“标识”都应该是唯一的。标识的明明规则一般是头文件名全大写，前面加下划线，并把文件名中的<code>.</code>也变成下划线，如：<code>stdio.h</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _STDIO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _STDIO_H</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>注意：<code>#ifndef</code>起到的效果是防止一个源文件多次包含同一个头文件，而不是防止两个源文件包含同一个头文件。事实上，防止同一头文件被两个不同的源文件包含这种要求本身就是不合理的，头文件存在的价值就是被不同的源文件包含。</p>
<h2 id="3、判断字符、数字以及大小写转换函数"><a href="#3、判断字符、数字以及大小写转换函数" class="headerlink" title="3、判断字符、数字以及大小写转换函数"></a>3、判断字符、数字以及大小写转换函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">islower</span>(<span class="type">char</span> c) <span class="comment">// 是否为小写字母</span></span><br><span class="line"><span class="built_in">isupper</span>(<span class="type">char</span> c) <span class="comment">// 是否为大写字母</span></span><br><span class="line"><span class="built_in">isdigit</span>(<span class="type">char</span> c) <span class="comment">// 是否为数字</span></span><br><span class="line"><span class="built_in">isalpha</span>(<span class="type">char</span> c) <span class="comment">// 是否为字母</span></span><br><span class="line"><span class="built_in">isalnum</span>(<span class="type">char</span> c) <span class="comment">// 是否为字母或者数字</span></span><br><span class="line"><span class="built_in">toupper</span>(<span class="type">char</span> c) <span class="comment">// 字母小转大</span></span><br><span class="line"><span class="built_in">tolower</span>(<span class="type">char</span> c) <span class="comment">// 字母大转小</span></span><br></pre></td></tr></table></figure>

<h2 id="4、顶层const和底层const"><a href="#4、顶层const和底层const" class="headerlink" title="4、顶层const和底层const"></a>4、顶层const和底层const</h2><p>指针本身是一个对象，它又可以指向另一个对象，因此，指针是不是常量以及指针所指的对象是不是一个常量是两个独立的问题。</p>
<p><code>顶层const</code>表示指针本身是一个常量，不能改变，不能指向其他对象。<code>底层const</code>表示指针所指的对象是一个常量，该对象的值不能改变。</p>
<p>更一般的，<code>顶层const</code>可以表示任意的对象是常量，对任何的数据类型都适用。<code>底层const</code>则与指针和引用等复合类型的基本类型有关。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i;    		<span class="comment">// 不能改变p1的值，是一个顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>;     		<span class="comment">// 不能改变ci的值，是一个顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci;   		<span class="comment">// 允许改变p2的值，是一个底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2;	<span class="comment">// 靠右的const是顶层const，靠左的是底层const</span></span><br></pre></td></tr></table></figure>

<h2 id="5、string的size类型为什么是string-size-t而不是int"><a href="#5、string的size类型为什么是string-size-t而不是int" class="headerlink" title="5、string的size类型为什么是string::size_t而不是int"></a>5、string的size类型为什么是string::size_t而不是int</h2><p><code>std::string</code> 的 <code>size</code> 类型被定义为 <code>string::size_t</code> 而不是 <code>int</code>，是为了提高通用性和可移植性。这是因为字符串的大小（长度）可能非常大，而 <code>int</code> 类型的范围是有限的，因此可能无法表示所有可能的字符串大小。</p>
<p><code>string::size_t</code> 是一个无符号整数类型，通常被定义为一个足够大的整数，以便可以容纳字符串的任何合法大小。它的大小通常与系统架构和编译器有关，但通常足够大以容纳大多数字符串的长度。</p>
<p>使用 <code>string::size_t</code> 而不是 <code>int</code> 有以下几个好处：</p>
<ol>
<li><strong>能够表示更大的字符串：</strong> 无符号整数类型 <code>size_t</code> 可以容纳比 <code>int</code> 更大的值，这对于处理非常大的字符串是必要的。</li>
<li><strong>提高可移植性：</strong> 使用 <code>string::size_t</code> 可以确保代码在不同的平台上具有相同的行为，因为 <code>size_t</code> 的大小会根据平台而变化，而不是固定的。</li>
<li><strong>避免符号问题：</strong> <code>size_t</code> 是无符号类型，避免了符号整数的问题，如溢出等。</li>
</ol>
<p>综上所述，使用 <code>string::size_t</code> 作为字符串大小的类型是一种良好的设计选择，可以确保代码能够处理各种大小的字符串，并提高了代码的可移植性。如果你需要与其他整数类型进行比较，你可以将 <code>size_t</code> 强制类型转换为 <code>int</code> 或其他整数类型。</p>
<h2 id="6、typedef函数"><a href="#6、typedef函数" class="headerlink" title="6、typedef函数"></a>6、typedef函数</h2><p>四种常见用法：</p>
<p>1）给已定义的变量类型起个别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">① </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;       </span><br><span class="line"><span class="comment">// uint8_t就是unsigned char的别名，这是最基础的用法</span></span><br><span class="line"></span><br><span class="line">②</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>    name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">uint8_t</span> age;</span><br><span class="line">    <span class="type">uint8_t</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> __person <span class="type">person_t</span>;</span><br><span class="line"><span class="comment">// 以上两段代码也可合并为一段，如下：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>    name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">uint8_t</span> age;</span><br><span class="line">    <span class="type">uint8_t</span> height;</span><br><span class="line">&#125;<span class="type">person_t</span>;</span><br><span class="line"><span class="comment">// 给struct  __person起了个别名person_t</span></span><br></pre></td></tr></table></figure>

<p>2）定义函数指针类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义函数指针变量</span></span><br><span class="line"><span class="built_in">int</span> (*pFunc)(<span class="type">char</span> *frame, <span class="type">int</span> len);</span><br><span class="line"><span class="comment">// 定义了一个函数指针变量pFunc，它可以指向这样的函数：返回值为int，形参为char*、int</span></span><br><span class="line"><span class="type">int</span> *(*pFunc[<span class="number">5</span>])(<span class="type">int</span> len);</span><br><span class="line"><span class="comment">// 定义了5个函数指针变量：pFunc[0]、pFunc[1]···，它们都可以指向这样的函数：返回值为int*，形参为int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.定义函数指针类型</span></span><br><span class="line"><span class="comment">// 定义函数指针类型，必须使用typedef，方法就是，在“定义函数指针变量”加上typedef</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*pFunc_t)</span><span class="params">(<span class="type">char</span> *frame, <span class="type">int</span> len)</span></span>;  <span class="comment">// 定义了一个类型函数指针pFunc_t</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span>  <span class="title">int</span> <span class="params">(*pFunc_t)</span><span class="params">(<span class="type">char</span> *frame, <span class="type">int</span> len)</span></span>;  <span class="comment">// 定义了一个类型pFunc_t</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read_voltage</span><span class="params">(<span class="type">char</span> *data, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> voltage = <span class="number">0</span>;</span><br><span class="line">    ···<span class="comment">// 其他功能代码</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> voltage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pFunc_t pHandler = read_voltage;  <span class="comment">// 使用类型pFunc_t来定义函数指针变量</span></span><br><span class="line">    ···<span class="comment">// 其他功能代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）定义数组指针类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、定义数组指针变量</span></span><br><span class="line"><span class="built_in">int</span>(*pArr)[<span class="number">5</span>];  <span class="comment">// 定义了一个数组指针变量pArr，pArr可以指向一个int [5]的一维数组</span></span><br><span class="line"><span class="built_in">char</span>(*pArr)[<span class="number">4</span>][<span class="number">5</span>];  <span class="comment">// 定义了一个数组指针变量pArr，pArr可以指向一个char[4][5]的二维数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>(*pArr)[<span class="number">5</span>];  <span class="comment">// pArr是一个指向含5个int元素的一维数组的指针变量</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">pArr = &amp;a;				<span class="comment">// 完全合法，无警告</span></span><br><span class="line">pArr = a;				<span class="comment">// 发生编译警告，赋值时类型不匹配：a的类型为int(*)，而pArr的类型为int(*)[5]</span></span><br><span class="line">pArr = &amp;a[<span class="number">0</span>];			<span class="comment">// 发生编译警告，赋值时类型不匹配：a的类型为int(*)，而pArr的类型为int(*)[5]</span></span><br><span class="line">pArr = &amp;b;				<span class="comment">// 发生编译警告，赋值时类型不匹配：&amp;b的类型为int(*)[6]，而pArr的类型为int(*)[5]</span></span><br><span class="line">pArr = (<span class="built_in">int</span>(*)[<span class="number">5</span>])&amp;b;	<span class="comment">// 类型强制转换为int(*)[5]，完全合法，无警告</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、定义数组指针类型</span></span><br><span class="line"><span class="comment">// 如同上面定义函数指针类型的方法，直接在前面加typedef即可，例如</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*pArr_t)</span>[5]</span>; <span class="comment">// 定义了一个指针类型pArr_t，该类型的指针可以指向含5个int元素的数组</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*pArr_t)</span>[5]</span>;  <span class="comment">// 定义一个指针类型，该类型的指针可以指向含5个int元素的一维数组</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    pArr_t pA;<span class="comment">//定义数组指针变量pA</span></span><br><span class="line">    pA= &amp;a;<span class="comment">//完全合法，无警告    </span></span><br><span class="line">    pA= (pArr_t)&amp;b;<span class="comment">//类型强制转换为pArr_t，完全合法，无警告</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）定义数组类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果我们想声明一个含5个int元素的一维数组，一般会这么写：int a[5];</span></span><br><span class="line"><span class="comment">// 如果我们想声明多个含5个int元素的一维数组，一般会这么写：int a1[5], a2[5], a3[5]···，或者 a[N][5]</span></span><br><span class="line"><span class="comment">// 可见，对于定义多个一维数组，写起来略显复杂，这时，我们就应该把数组定义为一个类型，例如：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">arr_t</span>[<span class="number">5</span>]; <span class="comment">// 定义了一个数组类型arr_t，该类型的变量是个数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">arr_t</span> d;        	<span class="comment">// d是个数组，这一行等价于:  int d[5];</span></span><br><span class="line">    <span class="type">arr_t</span> b1, b2, b3;	<span class="comment">// b1, b2, b3都是数组</span></span><br><span class="line"></span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    d[<span class="number">4</span>] = <span class="number">134</span>;</span><br><span class="line">    d[<span class="number">5</span>] = <span class="number">253</span>;  <span class="comment">// 编译警告：下标越界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、mutable关键字"><a href="#7、mutable关键字" class="headerlink" title="7、mutable关键字"></a>7、mutable关键字</h2><p>首先，<code>c++</code>在类中引入<code>const</code>关键字 在成员函数尾部，使函数成为 常成员函数。这么做的目的是，在常成员函数内部，不允许修改调用它的对象的内部状态（即对象的成员变量）。此时，如果想在常成员函数内部修改对象的某个成员变量时，就需要引入<code>mutable</code>，将该对象的成员变量定义为<code>mutable</code>变量。但是，我们会把定义为<code>mutable</code>的这个变量，看做不属于对象的状态。这样，即使在常成员函数内部，<code>mutable</code>变量也可以被修改，与此同时，常成员函数内部，对于对象的其他成员变量（即对象的内部状态）还是不能修改的。</p>
<p>总结下： </p>
<ul>
<li><code>const</code>关键字，用于常成员函数，即“不允许在常成员函数内部修改对象状态的值。 </li>
<li><code>mutable</code>关键字，用于常成员函数，即“允许修改常成员函数内部不是对象状态的值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">A</span>(<span class="type">int</span> a): <span class="built_in">m_na</span>(a), <span class="built_in">m_nCount</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">      ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> m_na;</span><br><span class="line">      <span class="keyword">mutable</span> <span class="type">int</span> m_nCount;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.cpp   </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::display</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ++m_nCount;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;call func display()&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::getCount</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> m_nCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="function">QApplication <span class="title">aaa</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">      <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">      a.<span class="built_in">display</span>();</span><br><span class="line">      a.<span class="built_in">display</span>();</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;call func &quot;</span> &lt;&lt; a.<span class="built_in">getCount</span>() &lt;&lt; <span class="string">&quot; times.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> aaa.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="string">&quot;call func display()&quot;</span></span><br><span class="line"># <span class="string">&quot;call func display()&quot;</span></span><br><span class="line"># <span class="string">&quot;call func 2 times.&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="8、不完全类型"><a href="#8、不完全类型" class="headerlink" title="8、不完全类型"></a>8、不完全类型</h2><p>在一个给定的源文件中，一个类只能被定义一次，如果在多个文件中定义一个类，那么每个文件中的定义必须是完全相同的。一旦遇到花括号，类的定义就结束了。并且一旦定义了类，我们就知道所有类的成员，以及存储该类的对象所需的存储空间。</p>
<p>将类定义放在头文件中，可以保证在每个使用类的文件中以同样的方式定义类。使用头文件保护符，来保证即使头文件在同一个文件中被包含多次，类定义也只出现一次。</p>
<p>只声明却没有定义的类称为<strong>不完全类型</strong>，不完全类型不能定义该类型的对象，只能用于定义指向该类型的指针及引用，或者用于声明（不是定义）使用该类型作为形参类型或返回类型的函数。</p>
<p><strong>在创建类的对象之前，必须完整地定义该类。必须定义，而不是声明类，这样，编译器就会给类的对象预定相应的存储空间。同样的，在使用引用或指针访问类的成员之前，必须已经定义类。</strong>只有当类定义已经在前面出现过，数据成员才能被制定为该类类型。<strong>如果该类型是不完全类型，那么数据成员只能是指向该类类型的指针或引用。</strong></p>
<p>可以声明一个类而不定义它：这个声明称为<strong>前向声明</strong>。类的前向声明一般用来编写相互依赖的类。在声明之后，定义之前，类称为<strong>不完全类型</strong>，即已知Screen类是一个类型，但不知道包含哪些成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>；</span><br></pre></td></tr></table></figure>

<p>因为只有当类定义体完成后才能定义类，因此<strong>类不能具有自身类型的数据成员</strong>，然而，只要类名一出现就可以认为该类已经声明，因此，<strong>类的数据成员可以是指向自身类型的指针或引用</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkScreen</span>&#123;</span><br><span class="line">    Screen window;</span><br><span class="line">    LinkScreen *next;</span><br><span class="line">    LinkScreen *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>static</code>数据成员也可以是该成员所属的类类型。<code>非static</code>成员被限定声明为其自身类对象的指针或引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">static</span> Bar mem1;<span class="comment">//ok</span></span><br><span class="line">   Bar *mem2;<span class="comment">//ok</span></span><br><span class="line">   Bar mem3;<span class="comment">//no!!!!因为Bar是一个不完全类型，所以只能定义它的非static的指针或引用。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code相关</category>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>c++ primer 习题集</title>
    <url>/2023/08/06/c++%20primer%20%E4%B9%A0%E9%A2%98%E9%9B%86/</url>
    <content><![CDATA[<h1 id="第一章-开始"><a href="#第一章-开始" class="headerlink" title="第一章 开始"></a>第一章 开始</h1><h2 id="练习1-2"><a href="#练习1-2" class="headerlink" title="练习1.2"></a>练习1.2</h2><p>在<code>linux</code>系统中，通过<code>echo $?</code>可以获取该命令的返回值。返回值是一个整数，用于表示命令执行的结果。</p>
<p>一些常见的返回值含义如下：</p>
<pre><code>0 : 命令成功执行，没有错误。
1 : 一般错误，没有具体的错误代码。
2 : 语法错误或命令执行失败。
126 : 命令无法执行，可能缺少执行权限。
127 : 命令不存在或无法找到。
128 : 无效的退出参数。
130 : 命令被中断，通常由用户按下Ctrl+C导致。
255 : 命令执行失败，通常由于出现无效的返回值。
</code></pre>
<h2 id="练习-1-6"><a href="#练习-1-6" class="headerlink" title="练习 1.6"></a>练习 1.6</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; v1;</span><br><span class="line">	      &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2;</span><br><span class="line">		  &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; v1 + v2 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>这是很容易出现的错误。前两行的末尾有分号，表示语句结束，因此第2、3行为两条新的语句，缺少了<code>std::cout</code>。</p>
<h2 id="练习1-14"><a href="#练习1-14" class="headerlink" title="练习1.14"></a>练习1.14</h2><p>对比<code>for</code>循环和<code>while</code>循环：</p>
<p>在循环次数已知的情况下，<code>for</code>循环的形式显然更为简洁。</p>
<p>而循环次数无法预知时，用<code>while</code>循环实现更适合。用特定条件控制循环是否执行，循环体中执行的语句可能导致循环判定条件发生变化。</p>
<h2 id="练习1-16"><a href="#练习1-16" class="headerlink" title="练习1.16"></a>练习1.16</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, value = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一组数，按ctrl+d表示结束：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(; cin &gt;&gt; value; )</span><br><span class="line">        sum += value;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;读入的数的和为：&quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题重要的是<code>for(; cin &gt;&gt; value ;)</code>，以及后面的题中出现的<code>while(cin &gt;&gt; book)</code>，这种对输入流的结束判断。</p>
<p>注意，当从键盘向程序输入数据时，对于如何指出文件结束，不同操作系统有不同的约定。在Window系统中，输入<strong>文件结束符</strong>的方法是<code>Ctrl+Z</code>，然后按<code>Enter/Return</code>。在<code>Unix</code>系统中，包括<code>MacOSX</code>系统中，文件结束符输入是用<code>Ctrl+D</code>。</p>
<h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 2.26</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> buf;  <span class="comment">// const对象必须初始化</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> sz = cnt;</span><br><span class="line">    ++cnt;</span><br><span class="line">    ++sz;  <span class="comment">// 非法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.27</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">-1</span>, &amp;r = <span class="number">0</span>;         <span class="comment">// &amp;r = 0非法，非常量引用不能引用字面值常量0</span></span><br><span class="line">    <span class="type">int</span> *<span class="type">const</span> p2 = &amp;i2;        <span class="comment">// 合法，p2为常量指针，因此p2永远指向变量i2</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> i = <span class="number">-1</span>, &amp;r = <span class="number">0</span>;   <span class="comment">// 合法，常量i和常量引用r</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = &amp;i2;  <span class="comment">// 合法，常量指针p3指向变量i2，且由于p3指向const，不能通过p3修改i2</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p1 = &amp;i2;        <span class="comment">// 合法，p1指向const，不能通过p1修改i2</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;<span class="type">const</span> r2;        <span class="comment">// 非法，引用非对象，不能让引用恒定不变</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> i2 = i, &amp;r = i;   <span class="comment">// 合法，常量i2和常量引用r</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.28</span></span><br><span class="line">    <span class="comment">// (a) 以下四条均非法，记住涉及到某类型为常量时必须初始化，如这里的常量指针 </span></span><br><span class="line">    <span class="type">int</span> i, *<span class="type">const</span> cp;           </span><br><span class="line">    <span class="type">int</span> *p1, *<span class="type">const</span> p2;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ic, &amp;r = ic;  </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3;</span><br><span class="line">    <span class="comment">// (b) 合法，指针常量，但p没有指向任何实际的对象</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.30</span></span><br><span class="line">    <span class="comment">// 顶层const：表示任意的对象是常量； </span></span><br><span class="line">    <span class="comment">// 底层const：所指的对象是常量，与指针和引用等复合类型的基本数据类型部分有关</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.32</span></span><br><span class="line">    <span class="comment">// int null = 0, *p = null; 非法</span></span><br><span class="line">    <span class="type">int</span> null = <span class="number">0</span>, *p = <span class="literal">nullptr</span>;  <span class="comment">// nullptr是表示空指针的字面值常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.36</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(a) c = a;</span><br><span class="line">    <span class="keyword">decltype</span>((b)) d = a;  <span class="comment">// int &amp;d = a;</span></span><br><span class="line">    ++c;</span><br><span class="line">    ++d;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>    <span class="comment">// 4</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span>    <span class="comment">// 5</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>    <span class="comment">// 4</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;d=&quot;</span> &lt;&lt; d &lt;&lt; endl;  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-字符串、向量和数组"><a href="#第三章-字符串、向量和数组" class="headerlink" title="第三章 字符串、向量和数组"></a>第三章 字符串、向量和数组</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.2</span></span><br><span class="line"><span class="comment">// 一次读入一行</span></span><br><span class="line">string line;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin, line))</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一次读入一个词</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; word)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.3</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        1、标准库string的输入运算符自动忽略字符串开头的空白(包括空格符、换行符、制表符等),从第一个真正的字符开始读起，直到遇见下一处空白为止。</span></span><br><span class="line"><span class="comment">        2、如果希望在最终的字符串中保留输入时的空白符，应该使用getline函数代替原来的&gt;&gt;运算符，</span></span><br><span class="line"><span class="comment">            getline从给定的输入流中读取数据，直到遇到换行符为止，此时换行符也被读取进来，但是并不存储在最后的字符串中。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.4</span></span><br><span class="line">string str1, str2;</span><br><span class="line">cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1=&quot;</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;str2=&quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输出较大的字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span>(str1 != str2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(str1 &gt; str2)</span><br><span class="line">        cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输出较长的字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span>(str1.<span class="built_in">size</span>() != str2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(str1.<span class="built_in">size</span>() &gt; str2.<span class="built_in">size</span>())</span><br><span class="line">        cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.5 </span></span><br><span class="line">string str, str_sum;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; str)</span><br><span class="line">&#123;</span><br><span class="line">    str_sum += str;</span><br><span class="line">    str_sum += <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; str_sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.6</span></span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;at begin str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : str)</span><br><span class="line">    c = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.7</span></span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;at begin str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span> &amp;c : str)</span><br><span class="line">    c = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.8</span></span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;at begin str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"><span class="comment">// while</span></span><br><span class="line">string::size_type i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; str.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    str[i] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"><span class="comment">// for（传统）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">decltype</span>(str.<span class="built_in">size</span>()) i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    str[i] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.9</span></span><br><span class="line">string s;</span><br><span class="line">cout &lt;&lt; s[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.10</span></span><br><span class="line">string line, new_line;</span><br><span class="line"><span class="built_in">getline</span>(cin, line);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;at begin line=&quot;</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">decltype</span>(line.<span class="built_in">size</span>()) i = <span class="number">0</span>; i &lt; line.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">ispunct</span>(line[i]))</span><br><span class="line">        new_line += line[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now str=&quot;</span> &lt;&lt; new_line &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.11</span></span><br><span class="line"><span class="type">const</span> string s = <span class="string">&quot;Keep out!&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.14</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; i)</span><br><span class="line">&#123;</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.15</span></span><br><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.17</span></span><br><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">string str;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; str)</span><br><span class="line">&#123;</span><br><span class="line">    svec.<span class="built_in">push_back</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s : svec)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="built_in">toupper</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.18</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="comment">// ivec[0] = 42;</span></span><br><span class="line">ivec.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.19</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec1</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec2&#123;<span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec3;</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::size_type i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    ivec3.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.20</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; i)</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::size_type i = <span class="number">0</span>; i &lt; ivec.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;和第&quot;</span> &lt;&lt; i+<span class="number">2</span> &lt;&lt; <span class="string">&quot;的和是&quot;</span> &lt;&lt; ivec[i] + ivec[i+<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::size_type i = <span class="number">0</span>; i &lt; ivec.<span class="built_in">size</span>()/<span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;和第&quot;</span> &lt;&lt; ivec.<span class="built_in">size</span>()-i &lt;&lt; <span class="string">&quot;的和是&quot;</span> &lt;&lt; ivec[i] + ivec[ivec.<span class="built_in">size</span>()-i<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.22</span></span><br><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin, s))</span><br><span class="line">    svec.<span class="built_in">push_back</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> s = svec.<span class="built_in">begin</span>(); s != svec.<span class="built_in">end</span>() &amp;&amp; !s-&gt;<span class="built_in">empty</span>(); s++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = s-&gt;<span class="built_in">begin</span>(); it != s-&gt;<span class="built_in">end</span>(); it++)</span><br><span class="line">        *it = <span class="built_in">toupper</span>(*it);</span><br><span class="line">    cout &lt;&lt; *s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.23</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : ivec)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; i;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = ivec.<span class="built_in">begin</span>(); it != ivec.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    *it = (*it) * <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.24</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; i)</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = ivec.<span class="built_in">begin</span>(); it != ivec.<span class="built_in">end</span>() - <span class="number">1</span>; it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it + *(it+<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-------------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">auto</span> beg = ivec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> end = ivec.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = beg; it != beg + (end - beg) / <span class="number">2</span>; it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it + *(beg + (end - it) - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ivec.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">    cout &lt;&lt; *(beg + (end - beg) / <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.25</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">unsigned</span>&gt; <span class="title">scores</span><span class="params">(<span class="number">11</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">unsigned</span> grade;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; grade)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(grade &lt;= <span class="number">100</span>)</span><br><span class="line">        ++*(scores.<span class="built_in">begin</span>() + grade / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : scores)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.26</span></span><br><span class="line"><span class="comment">// 二分搜索程序中，为什么用的是 mid = beg + (end - beg) / 2，而非 mid = (beg + end) / 2</span></span><br><span class="line"><span class="comment">// C++并没有定义两个迭代器的加法运算，实际上直接把两个迭代器加起来是没有意义的。</span></span><br><span class="line"><span class="comment">// 与之相反，C++定义了迭代器的减法运算，两个迭代器相减的结果是它们之间的距离;</span></span><br><span class="line"><span class="comment">// 也就是说，将运算符右侧的迭代器向前移动多少个元素后可以得到左侧的迭代器，参与运算的两个迭代器必须指向同一个容器中的元素或尾后元素。</span></span><br><span class="line"><span class="comment">// 另外，C++还定义了迭代器与整数的加减法运算，用以控制迭代器在容器中左右移动。</span></span><br><span class="line"><span class="comment">// 在本题中，因为迭代器的加法不存在，所以mid=(beg+end)/2;不合法。mid = beg+(end - beg)/ 2;的含义是，先计算end-beg的值得到容器中的元素个数，然后控制迭代器从开始处向右移动二分之一容器的长度，从而定位到容器正中间的元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.29</span></span><br><span class="line"><span class="comment">// 相对于 vector 来说，数组有哪些缺点？</span></span><br><span class="line"><span class="comment">// 1、数组的大小固定不变，不能随意向数组中增加额外的元素。如果想改变数组的长度，必须创建一个更大的数组，然后将原数组的元素复制过去；</span></span><br><span class="line"><span class="comment">// 2、无法使用 size 函数直接获取数组的维度：</span></span><br><span class="line"><span class="comment">//     如果是字符数组，可以用 strlen 获取；</span></span><br><span class="line"><span class="comment">//     如果是其他数组，只能通过 sizeof(array)/sizeof(array[0]) 获取。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.31</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.32</span></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    a[i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    b[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : b)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a1;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    a1.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b1</span><span class="params">(a1)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> j : b1)</span><br><span class="line">    cout &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.33</span></span><br><span class="line"><span class="comment">// 如果不初始化scores，则该数组会含有未定义的数值，这是因为scores是定义在函数内部的整型数组，不会执行默认初始化。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.35</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> *b = <span class="built_in">begin</span>(a);</span><br><span class="line"><span class="keyword">auto</span> *e = <span class="built_in">end</span>(a);</span><br><span class="line"><span class="keyword">while</span>(b != e)</span><br><span class="line">&#123;   </span><br><span class="line">    *b = <span class="number">0</span>;</span><br><span class="line">    ++b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// int *p = a;</span></span><br><span class="line"><span class="comment">// for(int i = 0; i &lt; 4; i++)</span></span><br><span class="line"><span class="comment">//     *(p+i) = 0;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : a)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.36</span></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> *ita = <span class="built_in">begin</span>(a);</span><br><span class="line"><span class="keyword">auto</span> *itb = <span class="built_in">begin</span>(b);</span><br><span class="line"><span class="keyword">while</span>(ita != <span class="built_in">end</span>(a) &amp;&amp; itb != <span class="built_in">end</span>(b))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*ita != *itb)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;两个数组不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ita++;</span><br><span class="line">    itb++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;两个数组相等&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// vector</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec1</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it1 = ivec1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> it2 = ivec2.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it1 != ivec1.<span class="built_in">end</span>() &amp;&amp; it2 != ivec2.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*it1 != *it2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;两个数组不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    it1++;</span><br><span class="line">    it2++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;两个数组相等&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.37</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> ca[] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cp = ca;</span><br><span class="line"><span class="keyword">while</span>(*cp)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *cp &lt;&lt; endl;</span><br><span class="line">    ++cp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个程序原意是想依次输出“hello”这5个字符，</span></span><br><span class="line"><span class="comment">// 但是由于数组ca的末尾不包含空字符&#x27;\0&#x27;，因此可能输出&#x27;o&#x27;后会继续输出，直至遇到空字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.38</span></span><br><span class="line"><span class="comment">// 两个指针的相加是无意义的。</span></span><br><span class="line"><span class="comment">// 指针本身的值是一个内存地址值，表示指针所指对象在内存中的存储地址。</span></span><br><span class="line"><span class="comment">// 如果把两个指针相加，意味着把两个对象的存储地址加在一起，这是没有意义的；</span></span><br><span class="line"><span class="comment">// 如果两个指针指向同一个数组中的不同元素，则它们相减的结果表征了它们所指的元素在数组中的距离。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.39</span></span><br><span class="line">string s1, s2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入两个字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line"><span class="keyword">if</span>(s1 &gt; s2)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 &gt; s2&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 &lt; s2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ca1[<span class="number">80</span>], ca2[<span class="number">80</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入两个字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; ca1 &gt;&gt; ca2;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(ca1, ca2))</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ca1 &gt; ca2&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ca1 &lt; ca2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.40</span></span><br><span class="line"><span class="type">char</span> ca1[<span class="number">80</span>] = <span class="string">&quot;i love u&quot;</span>;</span><br><span class="line"><span class="type">char</span> ca2[<span class="number">80</span>] = <span class="string">&quot;but i love myself more.&quot;</span>;</span><br><span class="line"><span class="type">char</span> ca3[<span class="number">80</span>] = &#123;&#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(ca3, ca1);</span><br><span class="line"><span class="built_in">strcat</span>(ca3, <span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(ca3, ca2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : ca3)</span><br><span class="line">    cout &lt;&lt; i;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.41</span></span><br><span class="line"><span class="type">int</span> int_arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr), end(int_arr))</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : ivec)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.42</span></span><br><span class="line"><span class="comment">// C++允许使用数组直接初始化vector对象，但是不允许使用vector对象初始化数组。</span></span><br><span class="line"><span class="comment">// 如果想用vector对象初始化数组，则必须把vector对象的每个元素逐一赋值给数组。</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> int_arr[ivec.<span class="built_in">size</span>()] = &#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = ivec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;val : int_arr) <span class="comment">//  &amp;val-引用</span></span><br><span class="line">&#123;</span><br><span class="line">    val = *it;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    it++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-表达式"><a href="#第四章-表达式" class="headerlink" title="第四章 表达式"></a>第四章 表达式</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.21</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec; </span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一组整数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; num)</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(num);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : ivec)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;    </span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now the vec:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : ivec)</span><br><span class="line">    cout &lt;&lt; ((i % <span class="number">2</span> == <span class="number">0</span>) ? i : i * <span class="number">2</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;    </span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.22</span></span><br><span class="line"><span class="type">int</span> grade;</span><br><span class="line"><span class="comment">// 条件运算符</span></span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; grade)</span><br><span class="line">&#123;</span><br><span class="line">    string final_grade = (grade &gt; <span class="number">90</span>) ? <span class="string">&quot;high pass&quot;</span> </span><br><span class="line">        : (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> </span><br><span class="line">            : (grade &gt; <span class="number">60</span> &amp;&amp; grade &lt; <span class="number">75</span>) ? <span class="string">&quot;low pass&quot;</span></span><br><span class="line">                : <span class="string">&quot;pass&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;final grade is: &quot;</span> &lt;&lt; final_grade &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// // if语句</span></span><br><span class="line"><span class="comment">// while(cin &gt;&gt; grade)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     if(grade &gt; 90)</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;high pass&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     else if(grade &gt; 60 &amp;&amp; grade &lt; 75)</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;low pass&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     else if(grade &lt; 60)</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;fail&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     else</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;pass&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.28</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;类型名称\t&quot;</span> &lt;&lt;<span class="string">&quot;所占空间&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bool\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">bool</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;char\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;wchar_t\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;char16_t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char16_t</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;char32_t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char32_t</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;short\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long long\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;float\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;double\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long double\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">double</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.29</span></span><br><span class="line"><span class="type">int</span> x[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p = x;</span><br><span class="line">cout &lt;&lt; (<span class="built_in">sizeof</span>(x) / <span class="built_in">sizeof</span>(*x)) &lt;&lt; endl; <span class="comment">// 10(40/4)</span></span><br><span class="line">cout &lt;&lt; (<span class="built_in">sizeof</span>(p) / <span class="built_in">sizeof</span>(*p)) &lt;&lt; endl; <span class="comment">// 2(8/2) 指针所占的空间大小为8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.37</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="type">const</span> string *ps;</span><br><span class="line"><span class="type">char</span> *pc;</span><br><span class="line"><span class="type">void</span> *pv;</span><br><span class="line">pv = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt; (<span class="built_in">const_cast</span>&lt;string*&gt; (ps));     <span class="comment">// pv = (void*)ps;</span></span><br><span class="line">i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt; (*pc);                             <span class="comment">// i = int(*pc);</span></span><br><span class="line">pv = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt; (&amp;d);                           <span class="comment">// pv = &amp;d;</span></span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt; (pv);                           <span class="comment">// pc = (char*)pv;</span></span><br></pre></td></tr></table></figure>

<h1 id="第五章-语句"><a href="#第五章-语句" class="headerlink" title="第五章 语句"></a>第五章 语句</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.5 </span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; grade;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">string grade_[] = &#123;<span class="string">&quot;D&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span> || num &gt; <span class="number">100</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误成绩！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    grade.<span class="built_in">push_back</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : grade)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; grade.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(grade[i] &gt;= <span class="number">60</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;the grade &quot;</span> &lt;&lt; grade[i] &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; grade_[grade[i] / <span class="number">10</span> - <span class="number">6</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;the grade &quot;</span> &lt;&lt; grade[i] &lt;&lt; <span class="string">&quot; is F&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.6</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; grade;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">string grade_[] = &#123;<span class="string">&quot;D&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span> || num &gt; <span class="number">100</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误成绩！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    grade.<span class="built_in">push_back</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : grade)</span><br><span class="line">&#123;</span><br><span class="line">    string final_grade = (i &lt; <span class="number">60</span>) ? <span class="string">&quot;F&quot;</span> </span><br><span class="line">        : (i &gt;=<span class="number">60</span> &amp;&amp; i &lt; <span class="number">70</span>) ? <span class="string">&quot;D&quot;</span></span><br><span class="line">            : (i &gt;=<span class="number">70</span> &amp;&amp; i &lt; <span class="number">80</span>) ? <span class="string">&quot;B&quot;</span></span><br><span class="line">                : (i &gt;=<span class="number">80</span> &amp;&amp; i &lt; <span class="number">90</span>) ? <span class="string">&quot;C&quot;</span></span><br><span class="line">                    : <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the grade &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; final_grade &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.8</span></span><br><span class="line"><span class="comment">// 悬垂else是指当程序中的if分支多于else分支时，如何为else寻找与之匹配的if分支的问题。</span></span><br><span class="line"><span class="comment">// C++规定，else与离它最近的尚未匹配的if匹配，从而消除了二义性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.9</span></span><br><span class="line"><span class="type">unsigned</span> vowelCnt = <span class="number">0</span>, blankspaceCnt = <span class="number">0</span>, tabCnt = <span class="number">0</span>, lineCnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一段文本：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// while(cin &gt;&gt; ch)</span></span><br><span class="line"><span class="keyword">while</span>(cin.<span class="built_in">get</span>(ch))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>: </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line">            ++vowelCnt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            ++blankspaceCnt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">            ++tabCnt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">            ++lineCnt;</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您输入的文本中共有&quot;</span> &lt;&lt; vowelCnt &lt;&lt; <span class="string">&quot;个元音字母&quot;</span> &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; blankspaceCnt &lt;&lt; <span class="string">&quot;个空格&quot;</span> &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; tabCnt &lt;&lt; <span class="string">&quot;个制表符&quot;</span> &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; lineCnt &lt;&lt; <span class="string">&quot;个换行符&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.10</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ffCnt = <span class="number">0</span>, flCnt = <span class="number">0</span>, fiCnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch, prech = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一段文本：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> bl = <span class="literal">true</span>;  <span class="comment">// 避免重复统计ff</span></span><br><span class="line">    <span class="keyword">if</span>(prech == <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">                ++ffCnt;</span><br><span class="line">                bl = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">                ++flCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                ++fiCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!bl)</span><br><span class="line">        prech = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prech = ch;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ff的数量是：&quot;</span> &lt;&lt; ffCnt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;fl的数量是：&quot;</span> &lt;&lt; flCnt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;fi的数量是：&quot;</span> &lt;&lt; fiCnt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.14</span></span><br><span class="line">string cur_str, pre_str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一句话：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; cur_str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur_str == pre_str)</span><br><span class="line">        ++cnt;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre_str != <span class="string">&quot;&quot;</span>)</span><br><span class="line">            cout &lt;&lt; pre_str &lt;&lt; <span class="string">&quot;连续出现了&quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot;次&quot;</span> &lt;&lt; endl;</span><br><span class="line">        pre_str = cur_str;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pre_str != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    cout &lt;&lt; pre_str &lt;&lt; <span class="string">&quot;连续出现了&quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot;次&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.17</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it1 = ivec1.<span class="built_in">begin</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it2 = ivec2.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it1 != ivec1.<span class="built_in">end</span>() &amp;&amp; it2 != ivec2.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*it1 != *it2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1和v2之间不存在前缀关系&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    it1++;</span><br><span class="line">    it2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(it1 == ivec1.<span class="built_in">end</span>())</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1是v2的前缀&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span>(it2 == ivec2.<span class="built_in">end</span>())</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1是v2的前缀&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.19</span></span><br><span class="line">string str1, str2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入两个字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(str1.<span class="built_in">length</span>() != str2.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str1.<span class="built_in">length</span>() &lt; str2.<span class="built_in">length</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;较短的字符串为：&quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;较短的字符串为：&quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(cin &gt;&gt; str1 &gt;&gt; str2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.20</span></span><br><span class="line">string cur_str, pre_str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">bool</span> bl = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; cur_str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur_str == pre_str)</span><br><span class="line">    &#123;</span><br><span class="line">        bl = <span class="literal">false</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;重复出现的词：&quot;</span> &lt;&lt; pre_str &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre_str = cur_str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(bl)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有重复出现的词！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.21</span></span><br><span class="line">string cur_str, pre_str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">bool</span> bl = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; cur_str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isupper</span>(cur_str[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(cur_str == pre_str)</span><br><span class="line">    &#123;</span><br><span class="line">        bl = <span class="literal">false</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;重复出现的词（必须以大写开头）：&quot;</span> &lt;&lt; pre_str &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre_str = cur_str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(bl)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有重复出现的词（必须以大写开头）！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.23</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请依次输入被除数和除数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> i1, i2;</span><br><span class="line">cin &gt;&gt; i1 &gt;&gt; i2;</span><br><span class="line"><span class="keyword">if</span>(i2 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;除数不能为0！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i1/i2=&quot;</span> &lt;&lt; i1 / i2 &lt;&lt; endl;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.24</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请依次输入被除数和除数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> i1, i2;</span><br><span class="line">cin &gt;&gt; i1 &gt;&gt; i2;</span><br><span class="line"><span class="keyword">if</span>(i2 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;除数不能为0！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i1/i2=&quot;</span> &lt;&lt; i1 / i2 &lt;&lt; endl;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.25</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请依次输入被除数和除数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> i1, i2;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; i1 &gt;&gt; i2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i2 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;除数不能为0！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i1/i2=&quot;</span> &lt;&lt; i1 / i2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(runtime_error err)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;需要继续吗？（y or n）&quot;</span>;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line">        <span class="keyword">if</span>(ch != <span class="string">&#x27;y&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h1><p>分离式编译：</p>
<p><code>fact.cc &amp; factMain.cc &amp; main6.3-h</code></p>
<p><code>fact.cc</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main6.3-.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.3</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(val &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum *= val--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>factMain.cc </code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main6.3-.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">fact</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5!=&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main6.3-h</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MAIN6_3_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MAIN6_3_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.3</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line"><span class="comment">// 6.4</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact_usr</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 6.5</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">absd</span><span class="params">(<span class="type">double</span> a)</span></span>;</span><br><span class="line"><span class="comment">// 6.7</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_calls</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 6.18</span></span><br><span class="line"><span class="comment">// bool compare(const matrix&amp; m1, const matrix&amp; m2);</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">change_val</span><span class="params">(<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;::iterator)</span></span>;</span><br><span class="line"><span class="comment">// 6.36 &amp;&amp; 6.37</span></span><br><span class="line"><span class="comment">// 直接声明</span></span><br><span class="line"><span class="built_in">string</span> (*<span class="built_in">func1</span>())[<span class="number">10</span>]; </span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> string arr[<span class="number">10</span>];</span><br><span class="line"><span class="function">arr&amp; <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 尾置返回类型</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func3</span><span class="params">()</span> -&gt; <span class="title">string</span><span class="params">(*)</span> [10]</span>;</span><br><span class="line"><span class="comment">// decltype关键字</span></span><br><span class="line">string str[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">decltype</span>(str) &amp;<span class="built_in">func4</span>();</span><br><span class="line"><span class="comment">// 6.54</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func5</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="keyword">decltype</span>(func5)*&gt; vF;<span class="comment">// 该vector对象的元素是指向函数func5的指针</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>习题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main6.3-.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.3</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(val &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum *= val--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.4</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact_usr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val_usr;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个数字以计算其阶乘：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; val_usr;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(val_usr &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum *= val_usr--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.5</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">absd</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.7</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_calls</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ctr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ctr++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.10</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_pointer</span><span class="params">(<span class="type">int</span> *p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.11</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.12</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_refer</span><span class="params">(<span class="type">int</span> &amp;r1, <span class="type">int</span> &amp;r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    temp = r1;</span><br><span class="line">    r1 = r2;</span><br><span class="line">    r2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.17</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_Upper</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(string::size_type i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isupper</span>(s[i]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">s_to_lower</span><span class="params">(string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(string::size_type i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.21</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare_int</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>* ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; *ip)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> *ip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.22</span></span><br><span class="line"><span class="comment">// 既不交换指针，也不交换指针所指的内容（局限于函数内部）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapPointer1</span><span class="params">(<span class="type">int</span>* p1, <span class="type">int</span>* p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = p1;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换指针所指的内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapPointer2</span><span class="params">(<span class="type">int</span>* p1, <span class="type">int</span>* p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换指针本身</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapPointer3</span><span class="params">(<span class="type">int</span>* &amp;p1, <span class="type">int</span>* &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = p1;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.23</span></span><br><span class="line"><span class="comment">// 参数是常量整型指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数有两个，分别是常量整型指针和数组的容量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p, <span class="type">const</span> <span class="type">int</span> sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != sz)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *p++ &lt;&lt; endl;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数有两个，分别是数组的首尾边界</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print3</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *b,<span class="type">const</span> <span class="type">int</span> *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q=b; q!=e; ++q)</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.24</span></span><br><span class="line"><span class="comment">// void print(const int ia[10])</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     for(size_t i = 0; i != 10; ++i)</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; ia[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 上述print函数的定义存在一个潜在风险</span></span><br><span class="line"><span class="comment">// 即虽然我们期望传入的数组维度是10，但实际上任意维度的数组都可以传入。</span></span><br><span class="line"><span class="comment">// 如果传入的数组维度较大，print函数输出数组的前10个元素，不至于引发错误；</span></span><br><span class="line"><span class="comment">// 相反如果传入的数组维度不足10，则print函数将强行输出一些未定义的值。</span></span><br><span class="line"><span class="comment">// 修改后的程序是：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ia[], <span class="type">const</span> <span class="type">int</span> sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i != sz; ++i)</span><br><span class="line">        cout &lt;&lt; ia[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.33</span></span><br><span class="line"><span class="comment">// 递归输出vector对象的内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vInt, <span class="type">unsigned</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> sz = vInt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(!vInt.<span class="built_in">empty</span>() &amp;&amp; index &lt; sz)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; vInt[index] &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">printVector</span>(vInt, index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.55</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func11</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func12</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func13</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func14</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.56</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Compute</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>(*p)(<span class="type">int</span>, <span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">p</span>(a, b) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 6.3</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">fact</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5!=&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.4</span></span><br><span class="line">    <span class="type">int</span> n_usr = <span class="built_in">fact_usr</span>();</span><br><span class="line">    cout &lt;&lt; n_usr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.5</span></span><br><span class="line">    <span class="type">double</span> m1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入任意一个数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; m1;</span><br><span class="line">    cout &lt;&lt; m1 &lt;&lt; <span class="string">&quot;的绝对值是&quot;</span> &lt;&lt; <span class="built_in">absd</span>(m1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.7</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">count_calls</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.10</span></span><br><span class="line">    <span class="type">int</span> i1 = <span class="number">10</span>, i2 = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> *p1 = &amp;i1, *p2 = &amp;i2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i1=&quot;</span> &lt;&lt; *p1 &lt;&lt; <span class="string">&quot;, i2=&quot;</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">swap_pointer</span>(p1, p2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after swap: i1=&quot;</span> &lt;&lt; *p1 &lt;&lt; <span class="string">&quot;, i2=&quot;</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.11</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m=&quot;</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after reset, m=&quot;</span> &lt;&lt; <span class="built_in">reset</span>(m) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.12</span></span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">10</span>, n2 = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> &amp;r1 = n1, &amp;r2 = n2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;n1=&quot;</span> &lt;&lt; r1 &lt;&lt; <span class="string">&quot;, n2=&quot;</span> &lt;&lt; r2 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">swap_refer</span>(r1, r2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after swap: n1=&quot;</span> &lt;&lt; r1 &lt;&lt; <span class="string">&quot;, n2=&quot;</span> &lt;&lt; r2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.14</span></span><br><span class="line">    <span class="comment">// 练习6.14:举一个形参应该是引用类型的例子，再举一个形参不能是引用类型的例子。</span></span><br><span class="line">    <span class="comment">// 【出题思路】</span></span><br><span class="line">    <span class="comment">// 与值传递相比，引用传递的优势主要体现在三个方面：一是可以直接操作引用形参所引的对象；二是使用引用形参可以避免拷贝大的类类型对象或容器类型对象；三是使用引用形参可以帮助我们从函数中返回多个值。</span></span><br><span class="line">    <span class="comment">// 【解答】</span></span><br><span class="line">    <span class="comment">// 基于对引用传递优势的分析，我们可以举出几个适合使用引用类型形参的例子：</span></span><br><span class="line">    <span class="comment">// 第一，当函数的目的是交换两个参数的内容时应该使用引用类型的形参；第二，当参数是string对象时，为了避免拷贝很长的字符串，应该使用引用类型。</span></span><br><span class="line">    <span class="comment">// 在其他情况下可以使用值传递的方式，而无须使用引用传递，例如求整数的绝对值或者阶乘的程序。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.17</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="built_in">is_Upper</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">    string str = <span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">s_to_lower</span>(str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.21</span></span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; count &lt;&lt; &quot;: &quot; &lt;&lt; compare_int(2, a) &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// a++; // 数组名是一个常量指针，指向数组的首元素，它的值是固定的，不能通过 ++ 操作来修改</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;数组a中第&quot;</span> &lt;&lt; count + <span class="number">1</span> &lt;&lt; <span class="string">&quot;个数和2比较，较大的数是: &quot;</span> &lt;&lt; <span class="built_in">compare_int</span>(<span class="number">2</span>, &amp;a[count]) &lt;&lt; endl;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.22</span></span><br><span class="line">    <span class="type">int</span> h = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;h, *q = &amp;b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(address)h=&quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;\tb=&quot;</span> &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(context)h=&quot;</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;\tb=&quot;</span> &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// swapPointer1(p, q);</span></span><br><span class="line">    <span class="comment">// swapPointer2(p, q);</span></span><br><span class="line">    <span class="built_in">swapPointer3</span>(p, q);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after swap(address): h=&quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;\tb=&quot;</span> &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after swap(context): h=&quot;</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;\tb=&quot;</span> &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.23</span></span><br><span class="line">    <span class="type">int</span> i23 = <span class="number">0</span>, j23[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">print1</span>(&amp;i23); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">print1</span>(j23);  <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">print2</span>(&amp;i23, <span class="number">1</span>); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">print2</span>(j23, <span class="built_in">sizeof</span>(j23) / <span class="built_in">sizeof</span>(*j23)); <span class="comment">// 0, 1</span></span><br><span class="line">    <span class="keyword">auto</span> b23 = <span class="built_in">begin</span>(j23);</span><br><span class="line">    <span class="keyword">auto</span> e23 = <span class="built_in">end</span>(j23);</span><br><span class="line">    <span class="built_in">print3</span>(b23, e23); <span class="comment">// 0, 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.25</span></span><br><span class="line">    string str1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != argc; ++i)</span><br><span class="line">        str1 += argv[i];</span><br><span class="line">    cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.31</span></span><br><span class="line">    <span class="comment">// 练习6.31:什么情况下返回的引用有效?什么情况下返回常量的引用有效?</span></span><br><span class="line">    <span class="comment">// 【出题思路】</span></span><br><span class="line">    <span class="comment">// 函数返回其结果的过程与它接受参数的过程类似。如果返回的是值，则创建一个未命名的临时对象，并把要返回的值拷贝给这个临时对象；如果返回的是引用，则该引用是它所引对象的别名，,不会真正拷贝对象。</span></span><br><span class="line">    <span class="comment">// 【解答】</span></span><br><span class="line">    <span class="comment">// 如果引用所引的是函数开始之前就已经存在的对象，则返回该引用是有效的；如果引用所引的是函数的局部变量，则随着函数结束局部变量也失效了，此时返回的引用无效。</span></span><br><span class="line">    <span class="comment">// 当不希望返回的对象被修改时，返回对常量的引用。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.33</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vInt = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printVector</span>(vInt, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.55</span></span><br><span class="line">    <span class="comment">// 练习6.55：编写4个函数，分别对两个int值执行加、减、乘、除运算；在上一题创建的vector对象中保存指向这些值的指针。</span></span><br><span class="line">    <span class="keyword">decltype</span>(func11) *p11 = func11, *p21 = func12, *p31 = func13, *p41 = func14;</span><br><span class="line">    vector&lt;<span class="keyword">decltype</span>(func11)*&gt; vF = &#123;p11, p21, p31, p41&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.56</span></span><br><span class="line">    <span class="type">int</span> i11= <span class="number">5</span>, j11 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : vF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Compute</span>(i11, j11, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code相关</category>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>hexo相关报错</title>
    <url>/2023/07/30/hexo%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="1、OpnSSL-SSL-read-Connection-was-reset-errno-10054"><a href="#1、OpnSSL-SSL-read-Connection-was-reset-errno-10054" class="headerlink" title="1、OpnSSL SSL_read: Connection was reset, errno 10054"></a>1、OpnSSL SSL_read: Connection was reset, errno 10054</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/hioomph/hioomph.github.io.git/&#x27;: OpnSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure>

<h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>一般是这是因为服务器的SSL证书没有经过第三方机构的签署，所以才报错</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>解除ssl验证后，再上传就OK了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure>

<h2 id="2、Error-Spawn-failed"><a href="#2、Error-Spawn-failed" class="headerlink" title="2、Error: Spawn failed"></a>2、Error: Spawn failed</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error: Spawn failed</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (D:\blog\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">    at ChildProcess.emit (node:events:514:28)</span><br><span class="line">    at cp.emit (D:\blog\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">    at ChildProcess._handle.onexit (node:internal/child_process:291:12)</span><br></pre></td></tr></table></figure>

<h3 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h3><p>hexo的_config.yml配置里git仓库地址填写错误，应将https方式改成ssh方式</p>
<h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  # repository: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git  # https方式</span><br><span class="line">  repository: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git		  # ssh方式</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>各种报错信息</category>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>graph_based model调试相关</title>
    <url>/2023/08/03/graph_based%20model%E8%B0%83%E8%AF%95%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="1、Could-not-run-‘aten-slow-conv3d-forward’-with-arguments-from-the-‘CUDA’-backend"><a href="#1、Could-not-run-‘aten-slow-conv3d-forward’-with-arguments-from-the-‘CUDA’-backend" class="headerlink" title="1、Could not run ‘aten::slow_conv3d_forward’ with arguments from the ‘CUDA’ backend."></a>1、Could not run ‘aten::slow_conv3d_forward’ with arguments from the ‘CUDA’ backend.</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/tmp/pycharm_project_917/utils/UCSD/make_mask.py&quot;, line 77, in &lt;module&gt;</span><br><span class="line">    temp_feature = net(temp_frames)  # (4, 4096)</span><br><span class="line">  File &quot;/root/miniconda3/lib/python3.8/site-packages/torch/nn/modules/module.py&quot;, line 1102, in _call_impl</span><br><span class="line">    return forward_call(*input, **kwargs)</span><br><span class="line">  File &quot;/tmp/pycharm_project_917/nets/feature_extract/C3D_Nonlocal.py&quot;, line 43, in forward</span><br><span class="line">    x = self.relu(self.conv1a(x))   # (1, 64, 16, 224, 224)</span><br><span class="line">  File &quot;/root/miniconda3/lib/python3.8/site-packages/torch/nn/modules/module.py&quot;, line 1102, in _call_impl</span><br><span class="line">    return forward_call(*input, **kwargs)</span><br><span class="line">  File &quot;/root/miniconda3/lib/python3.8/site-packages/torch/nn/modules/conv.py&quot;, line 590, in forward</span><br><span class="line">    return self._conv_forward(input, self.weight, self.bias)</span><br><span class="line">  File &quot;/root/miniconda3/lib/python3.8/site-packages/torch/nn/modules/conv.py&quot;, line 585, in _conv_forward</span><br><span class="line">    return F.conv3d(</span><br><span class="line">NotImplementedError: Could not run &#x27;aten::slow_conv3d_forward&#x27; with arguments from the &#x27;CUDA&#x27; backend. This could be because the operator doesn&#x27;t exist for this backend, or was omitted during the selective/custom build process (if using custom build). If you are a Facebook employee using PyTorch on mobile, please visit https://fburl.com/ptmfixes for possible resolutions. &#x27;aten::slow_conv3d_forward&#x27; is only available for these backends: [CPU, BackendSelect, Python, Named, Conjugate, Negative, ADInplaceOrView, AutogradOther, AutogradCPU, AutogradCUDA, AutogradXLA, AutogradLazy, AutogradXPU, AutogradMLC, AutogradHPU, AutogradNestedTensor, AutogradPrivateUse1, AutogradPrivateUse2, AutogradPrivateUse3, Tracer, UNKNOWN_TENSOR_TYPE_ID, Autocast, Batched, VmapMode].</span><br></pre></td></tr></table></figure>

<p>分析代码，发现是因为对于要进行运算的数据<code>temp_frames</code>没有转到<code>cuda</code>设备上，因此：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># temp_frames = temp_frames.reshape(1, 3, 16, 224, 224)</span><br><span class="line">temp_frames = temp_frames.reshape(1, 3, 16, 224, 224).cuda()</span><br></pre></td></tr></table></figure>

<h2 id="2、test-annos部分为空"><a href="#2、test-annos部分为空" class="headerlink" title="2、test_annos部分为空"></a>2、test_annos部分为空</h2><p><code>debug</code>发现<code>test_annos</code>中正常帧对应的<code>anno</code>为空。</p>
<p>在<code>dataset.py</code>中，正常帧的<code>anno</code>主要是通过这两行实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else:  # line_split[1] == &#x27;0&#x27;</span><br><span class="line">    anno = np.zeros(int(line_split[-1]))</span><br><span class="line">    labels.append(&#x27;Normal&#x27;)</span><br></pre></td></tr></table></figure>

<p>参照<code>UCSD</code>的训练过程，<code>ped2_Test.txt</code>中每一行包含：名字，label，帧数</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308081515123.png" alt="image-20230808151522984"></p>
<p>而最开始使用的<code>SH_Test_label.txt</code>不包含帧数。所以异常帧可以直接通过<code>test_frame_mask/</code>中的<code>.npy</code>文件获取对应的<code>anno</code>，而正常帧的<code>anno</code>则为空。</p>
<p>解决方法：在<code>video_to_c3d.py</code>中新增加一个类函数，返回正常帧（<code>.avi</code>视频）对应的名称和帧数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def save_frames(self):</span><br><span class="line">    vr = decord.VideoReader(self.path, ctx=cpu(0))</span><br><span class="line">    num_frame = vr._num_frame  # 单个视频（如01_001.avi）的总帧数</span><br><span class="line">    base_name = os.path.basename(self.path)  # 01_001.avi</span><br><span class="line">    return base_name, num_frame  # 名称，帧数</span><br></pre></td></tr></table></figure>

<p>接下来就可以根据函数返回的结果在<code>SH_Test_label.txt</code>中，正常帧的后面加上对应的帧数，结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308081520957.png" alt="image-20230808152013907"></p>
<h2 id="3、ValueError-Input-contains-NaN"><a href="#3、ValueError-Input-contains-NaN" class="headerlink" title="3、ValueError: Input contains NaN."></a>3、ValueError: Input contains NaN.</h2><p><code>total_scores</code>中出现<code>NaN</code>。</p>
<p>みどり:<br>SHT：dataloader &#x3D;&gt; BatchSampler &#x3D;15</p>
<p>みどり:<br>ucsd：dataloader &#x3D;&gt; BatchSampler &#x3D;1</p>
<p>みどり:<br>尝试重新提取训练集的特征</p>
<p>みどり:<br>每16帧提取一次，而不是将0-15帧的数据拼接在一起形成一组数据 &#x3D;&#x3D;&#x3D;&gt; 目前推测是这个原因</p>
<p>みどり:<br>ucsd：每16帧暂存为一个temp_frames合集，从这个合集中提取新的特征</p>
<p>みどり:<br>SHT：每16帧为一个集合，分别提取16次特征，再拼接起来</p>
]]></content>
      <categories>
        <category>各种报错信息</category>
        <category>Graph_Based</category>
      </categories>
  </entry>
  <entry>
    <title>vscode相关</title>
    <url>/2023/08/01/vscode%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="1、-vscode连接阿里云如何免密？"><a href="#1、-vscode连接阿里云如何免密？" class="headerlink" title="1、 vscode连接阿里云如何免密？"></a>1、 vscode连接阿里云如何免密？</h1><h2 id="windows端："><a href="#windows端：" class="headerlink" title="windows端："></a><code>windows</code>端：</h2><p>1）在<code>cmd</code>中输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>

<p>在<code>c:\Users\用户名\\.ssh</code>下会生成私钥和公钥。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308021257775.png" alt="image-20230802125702563"></p>
<p>2）复制<code>id_rsa.pub</code>中的内容</p>
<h2 id="linux端："><a href="#linux端：" class="headerlink" title="linux端："></a><code>linux</code>端：</h2><p>1）输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>生成<code>linux</code>端的密钥，进入<code>/root/.ssh/id_rsa</code>路径下。</p>
<p>2）创建一个文件，名字叫<code>authorized_keys</code></p>
<p>3）把复制的<code>windows</code>公钥粘贴到<code>authorized_keys</code>中，保存退出</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308012055885.png" alt="Snipaste_2023-08-01_20-46-53"></p>
<h1 id="2、Linux环境使用VSCode调试简单C-代码"><a href="#2、Linux环境使用VSCode调试简单C-代码" class="headerlink" title="2、Linux环境使用VSCode调试简单C++代码"></a>2、Linux环境使用VSCode调试简单C++代码</h1><p>参考教程：<a href="https://blog.csdn.net/hypc9709/article/details/129413482?ops_request_misc=&request_id=&biz_id=102&utm_term=vscode%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-129413482.142%5Ev96%5Epc_search_result_base7&spm=1018.2226.3001.4187">Linux环境使用VSCode调试简单C++代码</a></p>
<h2 id="1）终端命令行进行编译、调试"><a href="#1）终端命令行进行编译、调试" class="headerlink" title="1）终端命令行进行编译、调试"></a>1）终端命令行进行编译、调试</h2><h2 id="2）通过VSCode进行编译、调试"><a href="#2）通过VSCode进行编译、调试" class="headerlink" title="2）通过VSCode进行编译、调试"></a>2）通过VSCode进行编译、调试</h2><h3 id="（1）前置条件"><a href="#（1）前置条件" class="headerlink" title="（1）前置条件"></a>（1）前置条件</h3><p>插件<code>C/C++</code>已安装；<code>g++编译器</code>和<code>gdb调试器</code>已安装。</p>
<h3 id="（2）配置tasks-json"><a href="#（2）配置tasks-json" class="headerlink" title="（2）配置tasks.json"></a>（2）配置<code>tasks.json</code></h3><ul>
<li><p>在<code>VSCode</code>的主菜单中，选择<code>Terminal&gt;Configure Default Build Task</code></p>
</li>
<li><p>出现一个下拉菜单，显示<code>C++</code>编译器的各种预定义编译任务。选择<code>C/C++: g++ build active file</code>（如果配置了中文，会显示<code>C/C++: g++ 生成活动文件</code>）</p>
</li>
<li><p>选择后，<code>VSCode</code>会自动生成一个<code>.vscode</code>文件夹和<code>tasks.json</code>文件，如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312071610116.png" alt="image-20231207144919415"></p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++ 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/g++&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>tasks.json</code>的作用是告诉<code>VSCode</code>如何编译程序，因此从其中的<code>Command</code>和<code>args</code>可以看出，实际上是执行了以下命令：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/usr/bin/g++ -g $&#123;file&#125; -o $&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li><code>$&#123;file&#125;</code>：当前活动文件是<code>VSCode</code>当前查看的文件，如<code>Main.cpp</code>；</li>
<li><code>$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;</code>：用于获取当前文件的目录和不包含扩展名的文件名，如<code>Main</code>。</li>
</ul>
<h3 id="（3）执行编译"><a href="#（3）执行编译" class="headerlink" title="（3）执行编译"></a>（3）执行编译</h3><ul>
<li><p><strong>回到需要执行编译的文件</strong>（这一步很重要，否则<code>\$&#123;file&#125;</code>和<code>$&#123;fileDirname&#125;</code>这些变量都会错）；</p>
</li>
<li><p>快捷键<code>ctrl+shift+B</code>或从菜单中选择运行：<strong>Terminal -&gt; Run Build Task</strong>，即可执行<code>tasks.json</code>中指定的编译过程；</p>
<p>编译任务完成后，会出现终端提示，对于成功的g++编译，输出如下：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312071609602.png" alt="image-20231207150223290"></p>
<p>（这里我将<code>tasks.json</code>中的<code>&quot;$&#123;file&#125;&quot;</code>项更改为<code>&quot;$&#123;fileDirname&#125;/*.cpp&quot;</code></p>
<h3 id="（4）调试文件"><a href="#（4）调试文件" class="headerlink" title="（4）调试文件"></a>（4）调试文件</h3><p>对需要调试的文件设置断点，选择<code>Debug C/C++ file</code>进行调试。</p>
<h3 id="（5）个性化配置launch-json"><a href="#（5）个性化配置launch-json" class="headerlink" title="（5）个性化配置launch.json"></a>（5）个性化配置<code>launch.json</code></h3><blockquote>
<p>这里<code>launch.json</code>的作用就是告诉<code>VSCode</code>如何调用<code>gdb调试器</code>。</p>
</blockquote>
<p>如果想要在调试&#x2F;运行程序时添加参数，只需要把参数添加在<code>&quot;args&quot;</code>选项中即可。</p>
<h4 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h4><p>在<code>VSCode</code>中编译、调试一个简单的<code>.cpp</code>文件，所需要做的就是：</p>
<ol>
<li>在<code>tasks.json</code>中调用<code>g++</code>生成一个可执行二进制文件；</li>
<li>在<code>launch.json</code>中调用<code>gdb</code>对生成的可执行文件进行调试。</li>
</ol>
<h3 id="（7）复用C-配置"><a href="#（7）复用C-配置" class="headerlink" title="（7）复用C++配置"></a>（7）复用C++配置</h3><p>上面的过程已经完成了在<code>VSCode</code>中调试<code>Linux</code>环境下的<code>C++</code>代码的配置，但只适用于当前工作空间。</p>
<p>如果想要在其他的工程文件夹下复用这种配置，只需要把<code>tasks.json</code>和<code>launch.json</code>文件复制到新文件夹下的<code>.vscode</code>目录下，然后根据需要改变对应的源文件和可执行文件的名称即可。</p>
<h1 id="3、VSCode自动生成头文件的-ifndef-define-endif"><a href="#3、VSCode自动生成头文件的-ifndef-define-endif" class="headerlink" title="3、VSCode自动生成头文件的 #ifndef #define #endif"></a>3、VSCode自动生成头文件的 #ifndef #define #endif</h1><p>参考这篇博客：<a href="https://blog.csdn.net/p1279030826/article/details/123851420">VSCode自动生成头文件的 #ifndef #define #endif</a></p>
]]></content>
      <categories>
        <category>各种报错信息</category>
        <category>vscode</category>
      </categories>
  </entry>
  <entry>
    <title>webserver</title>
    <url>/2023/08/04/webserver/</url>
    <content><![CDATA[<h1 id="一、项目基础"><a href="#一、项目基础" class="headerlink" title="一、项目基础"></a>一、项目基础</h1><h2 id="1、Reactor的关键结构"><a href="#1、Reactor的关键结构" class="headerlink" title="1、Reactor的关键结构"></a>1、Reactor的关键结构</h2><p><code>Reactor</code>核心的事件分发机制，即将<code>IO multiplexing</code>拿到的<code>IO</code>事件分发给各个文件描述符<code>fd</code>的事件处理函数。</p>
<p><code>Reactor</code>是一种事件驱动机制，和普通函数调用的不同之处在于：</p>
<ul>
<li>应用程序不是主动地调用某个<code>API</code>来完成处理；其逆置了事件处理流程，<strong>应用程序需要提供相应的接口并注册到<code>Reactor</code>上</strong>，如果相应的事件发生，<code>Reactor</code>将主动调用应用程序注册的接口，这些接口又称为<strong>回调函数</strong>。</li>
</ul>
<h3 id="（1）EventLoop：-事件循环"><a href="#（1）EventLoop：-事件循环" class="headerlink" title="（1）EventLoop： 事件循环"></a>（1）EventLoop： 事件循环</h3><p>从<code>EventLoop</code>的类定义中可以看出，除了⼀些状态量以外，每个<code>EventLoop</code>持有⼀个<code>Poller</code>的智能指针（对<code>epoll / poll</code>的封装），⼀个⽤于<code>EventLoop</code>之间通信的<code>Channel</code>，⾃⼰的线程<code>id</code>，互斥锁以及装有等待处理函数的<code>vector</code>。很明显，<code>EventLoop</code>并不直接管理各个连接的<code>Channel</code>（⽂件描述符的封装），⽽是通过<code>Poller</code>来进⾏的。<code>EventLoop</code>中最核⼼的函数就是<code>EventLoop::Loop()</code>。</p>
<p><code>EventLoop</code>不可拷贝，且每个线程只能有一个<code>EventLoop</code>对象。<code>EventLoop</code>对象的生命周期通常和其所属的线程一样长。</p>
<p><code>EventLoop</code>的头文件定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class EventLoop : boost::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line"></span><br><span class="line">  EventLoop();</span><br><span class="line">  ~EventLoop();</span><br><span class="line"></span><br><span class="line">  void loop();</span><br><span class="line"></span><br><span class="line">  void assertInLoopThread()</span><br><span class="line">  &#123;</span><br><span class="line">    if (!isInLoopThread())</span><br><span class="line">    &#123;</span><br><span class="line">      abortNotInLoopThread();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool isInLoopThread() const &#123; return threadId_ == CurrentThread::tid(); &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  void abortNotInLoopThread();</span><br><span class="line"></span><br><span class="line">  bool looping_; /* atomic */</span><br><span class="line">  const pid_t threadId_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>loop()</code>的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /*</span><br><span class="line">  	在该函数中会循环执行以下过程：</span><br><span class="line">  		调用Poller::poll()，通过此调用获得一个vector&lt;channel*&gt;activeChannels_的就绪事件集合;</span><br><span class="line">  		再遍历该容器，执行每个Channel的Channel::handleEvent()完成相应就绪事件回调;</span><br><span class="line">  		最后执行pendingFunctors_排队的函数。</span><br><span class="line">  	上述一次循环就是一次Reactor模式完成。</span><br><span class="line">  */</span><br><span class="line">void EventLoop::loop()</span><br><span class="line">&#123;</span><br><span class="line">  assert(!looping_);</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  looping_ = true;</span><br><span class="line">  quit_ = false;</span><br><span class="line"></span><br><span class="line">  while (!quit_)</span><br><span class="line">  &#123;</span><br><span class="line">    activeChannels_.clear();</span><br><span class="line">    poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">    for (ChannelList::iterator it = activeChannels_.begin();</span><br><span class="line">        it != activeChannels_.end(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">      (*it)-&gt;handleEvent();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; stop looping&quot;;</span><br><span class="line">  looping_ = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）Channel：事件分发器"><a href="#（2）Channel：事件分发器" class="headerlink" title="（2）Channel：事件分发器"></a>（2）Channel：事件分发器</h3><p>每个<code>Channel</code>对象自始至终只属于一个<code>EventLoop</code>，因此每个<code>Channel</code>对象都只属于一个<code>IO</code>线程。每个<code>Channel</code>对象只负责一个<code>fd</code>的事件分发，但不拥有这个<code>fd</code>，也不会在析构的时候关闭这个<code>fd</code>。</p>
<p><code>Channel</code>不是基类，用户无须继承，一般使用更上层的封装，如<code>TcpConnection</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Channel : boost::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef boost::function&lt;void()&gt; EventCallback;</span><br><span class="line"></span><br><span class="line">  Channel(EventLoop* loop, int fd);</span><br><span class="line"></span><br><span class="line">  // Channel作为是事件分发器其核心结构是Channel::handleEvent()</span><br><span class="line">  // 该函数调用Channel::handleEventWithGuard()</span><br><span class="line">  // 在其内根据Channel::revents的值分发调用相应的事件回调。</span><br><span class="line">  void handleEvent();</span><br><span class="line">  </span><br><span class="line">  // set Callback()系列函数，接受`Channel`所属的类注册相应的事件回调函数。</span><br><span class="line">  void setReadCallback(const EventCallback&amp; cb)</span><br><span class="line">  &#123; readCallback_ = cb; &#125;</span><br><span class="line">  void setWriteCallback(const EventCallback&amp; cb)</span><br><span class="line">  &#123; writeCallback_ = cb; &#125;</span><br><span class="line">  void setErrorCallback(const EventCallback&amp; cb)</span><br><span class="line">  &#123; errorCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  int fd() const &#123; return fd_; &#125;</span><br><span class="line">  int events() const &#123; return events_; &#125;</span><br><span class="line">  void set_revents(int revt) &#123; revents_ = revt; &#125;</span><br><span class="line">  bool isNoneEvent() const &#123; return events_ == kNoneEvent; &#125;</span><br><span class="line"></span><br><span class="line">  void enableReading() &#123; events_ |= kReadEvent; update(); &#125;</span><br><span class="line">  // void enableWriting() &#123; events_ |= kWriteEvent; update(); &#125;</span><br><span class="line">  // void disableWriting() &#123; events_ &amp;= ~kWriteEvent; update(); &#125;</span><br><span class="line">  // void disableAll() &#123; events_ = kNoneEvent; update(); &#125;</span><br><span class="line"></span><br><span class="line">  // for Poller</span><br><span class="line">  int index() &#123; return index_; &#125;</span><br><span class="line">  void set_index(int idx) &#123; index_ = idx; &#125;</span><br><span class="line"></span><br><span class="line">  EventLoop* ownerLoop() &#123; return loop_; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（3）Polloer：IO-multiplexing的封装"><a href="#（3）Polloer：IO-multiplexing的封装" class="headerlink" title="（3）Polloer：IO multiplexing的封装"></a>（3）Polloer：IO multiplexing的封装</h3><p><code>Poller Class</code>是<code>IO multiplexing</code>的封装，它现在是个具体类，而在<code>muduo</code>中是个抽象基类，因为<code>muduo</code>同时支持<code>poll(2)</code>和<code>epoll(4)</code>两种<code>IO multiplexing</code>机制。<br><code>Poller</code>是<code>EventLoop</code>的间接成员，只供其<code>owner</code> <code>EventLoop</code>在<code>IO</code>线程调用，因此无需加锁。其生命与<code>EventLoop</code>相等。<code>Poller</code>并不拥有<code>Channel</code>，<code>Channel</code>在析构之前必须自己<code>unregister(EventLoop::removeChannel())</code>，避免空悬指针。</p>
<p><code>Poller</code>类的作⽤就是<strong>负责监听⽂件描述符事件是否触发</strong>以及<strong>返回发⽣事件的⽂件描述符以及具体事件</strong>。所以⼀个<code>Poller</code>对象对应⼀个<code>IO</code>多路复⽤模块。在<code>muduo</code>中，⼀个<code>EventLoop</code>对应⼀个<code>Poller</code>。</p>
<p><code>Poller</code>的主要成员变量就三个：</p>
<ol>
<li><code>epollFd_</code>：就是⽤<code>epoll_create</code>⽅法返回的<code>epoll</code>句柄，这个是常识。</li>
<li><code>events_</code>：存放<code>epoll_wait()</code>返回的活动事件（是⼀个结构体）</li>
<li><code>channelMap_ </code>：这个变量是<code>std::unordered_map&lt;int, std::shared_ptr&lt;Channel&gt;&gt;</code>类型，负责记录<br>⽂件描述符<code>fd -&gt; Channel</code>的映射，也帮忙保管所有注册在这个<code>Poller</code>上的<code>Channel</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Epoll::poll(std::vector&lt;sp_Channel&gt;&amp; req) &#123;</span><br><span class="line"> int event_count =</span><br><span class="line"> Epoll_wait(epollFd_, &amp;*events_.begin(), events_.size(), EPOLLWAIT_TIME);</span><br><span class="line"> for(int i = 0; i &lt; event_count; ++i) &#123;</span><br><span class="line"> int fd = events_[i].data.fd;</span><br><span class="line"> sp_Channel temp = channelMap_[fd];</span><br><span class="line"> temp-&gt;setRevents(events_[i].events);</span><br><span class="line"> req.emplace_back(std::move(temp));</span><br><span class="line"> &#125;</span><br><span class="line"> // LOG &lt;&lt; &quot;Epoll finished&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当外部调⽤<code>poll</code>⽅法的时候，该⽅法底层其实是通过<code>epoll_wait</code>获取这个事件监听器上发⽣事件的<code>fd</code>及其对应发⽣的事件，我们知道每个<code>fd</code>都是由⼀个<code>Channel</code>封装的，通过哈希表<code>channelMap_</code>可以根据<code>fd</code>找到封装这个<code>fd</code>的<code>Channel</code>。将<code>IO</code>多路复⽤模块监听到该<code>fd</code>发⽣的事件写进这个<code>Channel</code>中的<code>revents</code>成员变量中。然后把这个<code>Channel</code>装进<code>req</code>中。这样，当外界调⽤完<code>poll</code>之后就能拿到<code>IO</code>多路复⽤模块的<strong>监听结果</strong><code>(std::vector&lt;sp_Channel&gt;&amp; req)</code>。</p>
<h3 id="（4）Reactor模式的核心架构"><a href="#（4）Reactor模式的核心架构" class="headerlink" title="（4）Reactor模式的核心架构"></a>（4）Reactor模式的核心架构</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308051524737.png" alt="Reactor模式的核心架构"></p>
<h2 id="2、日志系统"><a href="#2、日志系统" class="headerlink" title="2、日志系统"></a>2、日志系统</h2><p>服务器的⽇志系统是⼀个<strong>多⽣产者，单消费者</strong>的任务场景：多⽣产者负责把⽇志写⼊缓冲区，单消费者负责把缓冲区中数据写⼊⽂件。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308061016505.png" alt="日志系统框图"></p>
<p><code>LOG</code>的实现参照了<code>muduo</code>，但是⽐<code>muduo</code>要简化⼀点，⼤致的实现如上图所示。</p>
<ul>
<li>⾸先是<code>Logger</code>类，<code>Logger</code>类⾥⾯有<code>Impl</code>类，其实具体实现是<code>Impl</code>类，我也不懂<code>muduo</code>为何要再封装⼀层，那么我们来说说<code>Impl</code>⼲了什么，在初始化的时候<code>Impl</code>会把时间信息存到<code>LogStream</code>的缓冲区⾥，在我们实际⽤<code>Log</code>的时候，实际写⼊的缓冲区也是<code>LogStream</code>，在析构的时候<code>Impl</code>会把当前⽂件和⾏数等信息写⼊到<code>LogStream</code>，再把<code>LogStream</code>⾥的内容写到<code>AsyncLogging</code>的缓冲区中，当然这时候我们要先开启⼀个后端线程⽤于把缓冲区的信息写到⽂件⾥。</li>
<li><code>LogStream</code>类，⾥⾯其实就⼀个<code>Buffer</code>缓冲区，是⽤来暂时存放我们写⼊的信息的。还有就是重载运算符，因为我们采⽤的是<code>C++</code>的流式⻛格。</li>
<li><code>AsyncLogging</code>类，最核⼼的部分，在多线程程序中写<code>Log</code>⽆⾮就是前端往后端写，后端往硬盘写，⾸先将<code>LogStream</code>的内容写到了<code>AsyncLogging</code>缓冲区⾥，也就是前端往后端写，这个过程通过<code>append</code>函数实现，后端实现通过<code>threadfunc</code>函数，两个线程的同步和等待通过互斥锁和条件变量来实现，具体实现使⽤了双缓冲技术。</li>
<li>双缓冲技术的基本思路：准备两块<code>buffer</code>，<code>A</code>和<code>B</code>,前端往<code>A</code>写数据，后端从<code>B</code>⾥⾯往硬盘写数据，当<code>A</code>写满后，交换<code>A</code>和<code>B</code>，如此反复。使⽤两个<code>buffer</code>的好处是在新建⽇志消息的时候不必等待磁盘⽂件操作，也避免每条新⽇志消息都触发后端⽇志线程。换句话说，前端不是将⼀条条⽇志消息分别送给后端，⽽是将多条⽇志消息拼接成⼀个⼤的<code>buffer</code>传送给后端，相当于批处理，减少了线程唤醒的开销。不过实际的实现的话和这个还是有点区别，具体看代码吧。</li>
</ul>
<h3 id="（1）LogSream类"><a href="#（1）LogSream类" class="headerlink" title="（1）LogSream类"></a>（1）LogSream类</h3><p><strong>主要作用：将前端日志写入<code>BufferA</code>。</strong></p>
<p>详细来说，是将各个类型的数据转换为<code>char</code>的形式放入字符数组中，方便后端线程写入硬盘。</p>
<blockquote>
<p><strong>问题思考：<code>int</code>型、浮点型及指针都要如何转换为<code>char</code>的形式？</strong></p>
</blockquote>
<h3 id="（2）AsynLogging类"><a href="#（2）AsynLogging类" class="headerlink" title="（2）AsynLogging类"></a>（2）AsynLogging类</h3><p><strong>主要作用：经前端获得的<code>BufferA</code>放入后端的<code>BufferB</code>中，并且将<code>BufferB</code>的内容最终写入到磁盘中。</strong></p>
<h1 id="二、WebServer"><a href="#二、WebServer" class="headerlink" title="二、WebServer"></a>二、WebServer</h1><h2 id="1、项目框架"><a href="#1、项目框架" class="headerlink" title="1、项目框架"></a>1、项目框架</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-webserver.cpp</span><br><span class="line">-webserver.h</span><br><span class="line">-log</span><br><span class="line">  -log.cpp</span><br><span class="line">  -log.h</span><br><span class="line">  -block_queue.h</span><br></pre></td></tr></table></figure>

<h2 id="2、-webserver-webserver-cpp"><a href="#2、-webserver-webserver-cpp" class="headerlink" title="2、&#x2F;webserver&#x2F;webserver.cpp"></a>2、&#x2F;webserver&#x2F;webserver.cpp</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WebServer();</span><br><span class="line">~WebServer();</span><br><span class="line"></span><br><span class="line">bool dealclientdata();</span><br><span class="line">bool dealwithsignal(bool&amp; timeout, bool&amp; stop_server);</span><br><span class="line">void dealwithread(int sockfd);</span><br><span class="line">void dealwithwrite(int sockfd);</span><br><span class="line">void eventLoop();</span><br></pre></td></tr></table></figure>

<h2 id="3、-webserver-log"><a href="#3、-webserver-log" class="headerlink" title="3、&#x2F;webserver&#x2F;log&#x2F;"></a>3、&#x2F;webserver&#x2F;log&#x2F;</h2><h3 id="（1）block-queue-h"><a href="#（1）block-queue-h" class="headerlink" title="（1）block_queue.h"></a>（1）block_queue.h</h3><p>采用循环数组实现阻塞队列，作为二者的共享缓冲区。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 判断队列是否满了</span><br><span class="line">bool full() </span><br><span class="line"></span><br><span class="line">// 判断队列是否为空</span><br><span class="line">bool empty() </span><br><span class="line"></span><br><span class="line">// 返回队首元素</span><br><span class="line">bool front(T &amp;value)</span><br><span class="line"></span><br><span class="line">// 返回队尾元素</span><br><span class="line">bool back(T &amp;value) </span><br><span class="line"></span><br><span class="line">int size() </span><br><span class="line"></span><br><span class="line">int max_size()</span><br><span class="line"></span><br><span class="line">// 往队列添加元素，需要将所有使用队列的线程先唤醒</span><br><span class="line">// 当有元素push进队列，相当于生产者生产了一个元素</span><br><span class="line">// 若当前没有线程等待条件变量，则唤醒无意义</span><br><span class="line">bool push(const T &amp;item)</span><br><span class="line"></span><br><span class="line">// pop时，如果当前队列没有元素,将会等待条件变量</span><br><span class="line">bool pop(T &amp;item)</span><br><span class="line"></span><br><span class="line">// 增加了超时处理</span><br><span class="line">bool pop(T &amp;item, int ms_timeout)</span><br></pre></td></tr></table></figure>

<h3 id="（2）log-cpp"><a href="#（2）log-cpp" class="headerlink" title="（2）log.cpp"></a>（2）log.cpp</h3><p><strong>完成日志文件的初始化和内容的写入。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time_t t = time(NULL);</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>time_t t</code>: 声明了一个名为 <code>t</code> 的变量，其数据类型是 <code>time_t</code>，这是 C 语言标准库中用来表示时间的数据类型。</p>
</li>
<li><p><code>time(NULL)</code>: 这是调用 <code>time()</code> 函数的语法，它接受一个参数（通常是一个指向 <code>time_t</code> 对象的指针），用于存储获取到的时间值。在这里，传递了 <code>NULL</code>，表示我们只是想要获取当前系统时间，不需要保存时间值到任何变量中。</p>
<p><code>time(NULL)</code> 的返回值是当前系统时间（以秒为单位）距离某个固定时间点（通常是 <code>1970 年 1 月 1 日 00:00:00 UTC</code>，也称为 <code>Unix</code> 时间戳）的秒数。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct tm *sys_tm = localtime(&amp;t);</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>struct tm *sys_tm</code>: 声明了一个指针变量 <code>sys_tm</code>，该指针指向 <code>struct tm</code> 结构体，用于存储本地时间的各个组成部分，如年、月、日、时、分、秒等。</p>
</li>
<li><p><code>localtime(&amp;t)</code>: 这是调用 <code>localtime()</code> 函数的语法，它接受一个 <code>time_t</code> 类型的指针作为参数，并返回一个指向 <code>struct tm</code> 结构体的指针。函数的作用是将传入的时间值（由 <code>time_t</code> 类型的变量 <code>t</code> 表示）转换为本地时间，并存储在 <code>struct tm</code> 结构体中。</p>
<p>注意，<code>localtime()</code> 函数将时间从 UTC 时间转换为本地时间，考虑了时区和夏令时等因素。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>项目</category>
        <category>webserver</category>
      </categories>
  </entry>
  <entry>
    <title>《数据结构（C语言实现）》_b站鲍松山</title>
    <url>/2023/12/05/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%EF%BC%89%E3%80%8B_b%E7%AB%99%E9%B2%8D%E6%9D%BE%E5%B1%B1/</url>
    <content><![CDATA[<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><p>数据结构（Data Struct）：数据之间的组织架构&#x2F;结构。</p>
<p>DS：</p>
<ul>
<li>线性结构<ul>
<li>SeqList&#x2F;List&#x2F;Stack&#x2F;Queue&#x2F;String&#x2F;Array</li>
</ul>
</li>
<li>非线性结构<ul>
<li>Tree&#x2F;Graph</li>
</ul>
</li>
<li>排序&#x2F;搜索</li>
<li>算法</li>
</ul>
<h1 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2 线性表"></a>2 线性表</h1><h2 id="2-1-顺序表（SeqList）"><a href="#2-1-顺序表（SeqList）" class="headerlink" title="2.1 顺序表（SeqList）"></a>2.1 顺序表（SeqList）</h2><p>顺序表通过一组地址连续的空间对数据进行存储。</p>
<h2 id="2-2-单链表"><a href="#2-2-单链表" class="headerlink" title="2.2 单链表"></a>2.2 单链表</h2><p>不要求逻辑上相邻的元素在物理位置上也相邻，因此无法实现随机存取。</p>
<p>分清“谁的谁是谁”。 </p>
<p>操作时要时刻注意<code>last</code>这一项。</p>
<p><strong>头部插入时易错：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(List *<span class="built_in">list</span>, ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *s = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    assert(s != <span class="literal">NULL</span>);</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="built_in">list</span>-&gt;first-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;first-&gt;next = s;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下图所示，当使用头插法向<code>空list</code>中插入<code>1</code>后，<code>list-&gt;last</code>仍然指向头结点。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312091056865.png" alt="image-20231209105649826"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312091054319.png" alt="image-20231209105418153"></p>
<p> 对<code>pop_front</code>进行修改，加入对<code>size</code>的判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">list</span>-&gt;last = s; <span class="comment">// 当list为空时，对last进行移动</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312091058534.png" alt="image-20231209105844499"></p>
<p><strong>头部删除时同理</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_front</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Node *p = <span class="built_in">list</span>-&gt;first-&gt;next;</span><br><span class="line">    <span class="built_in">list</span>-&gt;first-&gt;next = <span class="built_in">list</span>-&gt;first-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">list</span>-&gt;last = <span class="built_in">list</span>-&gt;first;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2023/08/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="1、终端与进程组"><a href="#1、终端与进程组" class="headerlink" title="1、终端与进程组"></a>1、终端与进程组</h2><h3 id="（1）终端"><a href="#（1）终端" class="headerlink" title="（1）终端"></a>（1）终端</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031335344.png" alt="image-20230803133540713"></p>
<h4 id="1）运行前台进程-sleep-3000"><a href="#1）运行前台进程-sleep-3000" class="headerlink" title="1）运行前台进程 sleep 3000"></a>1）运行前台进程 <code>sleep 3000</code></h4><h4 id="2）运行后台进程-sleep-3000"><a href="#2）运行后台进程-sleep-3000" class="headerlink" title="2）运行后台进程 sleep 3000 &amp;"></a>2）运行后台进程 <code>sleep 3000 &amp;</code></h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031337505.png" alt="image-20230803133741336"></p>
<h4 id="3）查看后台进程-jobs"><a href="#3）查看后台进程-jobs" class="headerlink" title="3）查看后台进程 jobs"></a>3）查看后台进程 <code>jobs</code></h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031340236.png" alt="image-20230803134010984"></p>
<h4 id="4）将后台进程变为前台进程-fg"><a href="#4）将后台进程变为前台进程-fg" class="headerlink" title="4）将后台进程变为前台进程 fg +%&lt;进程编号&gt;"></a>4）将后台进程变为前台进程 <code>fg +%&lt;进程编号&gt;</code></h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031340037.png" alt="image-20230803134030968"></p>
<h4 id="5）查看当前终端名字-tty"><a href="#5）查看当前终端名字-tty" class="headerlink" title="5）查看当前终端名字 tty"></a>5）查看当前终端名字 <code>tty</code></h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031341611.png" alt="image-20230803134150192"></p>
<h3 id="（2）进程组"><a href="#（2）进程组" class="headerlink" title="（2）进程组"></a>（2）进程组</h3><p>其中，<code>PGID</code>即为进程组<code>ID</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031346173.png" alt="image-20230803134636774"></p>
<h2 id="2、会话"><a href="#2、会话" class="headerlink" title="2、会话"></a>2、会话</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 测试setsid和geysid</span><br><span class="line">int main() &#123;</span><br><span class="line">    pid_t pid = -1;</span><br><span class="line"></span><br><span class="line">    // 获取当前进程组会话ID</span><br><span class="line">    pid = getsid(0);</span><br><span class="line">    if(-1 == pid)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;getsid&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;sid:%d\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sid:620400</span><br></pre></td></tr></table></figure>

<p>此时，若以当前进程创建会话，会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 测试setsid和geysid</span><br><span class="line">int main() &#123;</span><br><span class="line">    pid_t pid = -1;</span><br><span class="line"></span><br><span class="line">    // 获取当前进程组会话ID</span><br><span class="line">    pid = getsid(0);</span><br><span class="line">    if(-1 == pid)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;getsid&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;sid:%d\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    // 新建一个会话</span><br><span class="line">    pid = setsid();</span><br><span class="line">    if(-1 == pid)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;setsid&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;sid:%d\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>报错为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sid:620400</span><br><span class="line">setsid: Operation not permitted</span><br></pre></td></tr></table></figure>

<p>查看当前进程的<code>PID</code>和<code>PGID</code>可以发现</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031401546.png" alt="image-20230803140116366"></p>
<p>当前<code>test</code>本身就是一个组长（<code>PID</code>和<code>PGID</code>一致），所以新建一个会话时报错，因为<strong>创建会话时，调用进程不能是进程组的组长，因为这个进程会变成新会话的首进程（组长）</strong>。</p>
<h2 id="3、daemon进程"><a href="#3、daemon进程" class="headerlink" title="3、daemon进程"></a>3、daemon进程</h2><p>又称守护进程、精灵进程。</p>
<p><code>daemon进程</code>的特点：</p>
<p>1）独立于控制终端；</p>
<p>2）名字一般以<code>d</code>结尾；</p>
<p>3）所有的服务存在于<code>etc/init.d</code></p>
<p>4）是一个特殊的孤儿进程；</p>
<p>5）输入被关闭，输出存在于日志中：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031134687.png" alt="image-20230803113433643"></p>
<h2 id="4、nohup和-命令使进程忽略hangup（挂起）信号"><a href="#4、nohup和-命令使进程忽略hangup（挂起）信号" class="headerlink" title="4、nohup和&amp;命令使进程忽略hangup（挂起）信号"></a>4、nohup和&amp;命令使进程忽略hangup（挂起）信号</h2><p>1）创建一个一般进程</p>
<p>使用<code>tail</code>命令跟踪<code>/var/log/syslog</code>文件</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031135972.png" alt="image-20230803113507931"></p>
<p>2）查看当前<code>tail</code>进程是否存在</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031136769.png" alt="image-20230803113609741"></p>
<p>3）此时若关闭掉<code>tail</code>进程所在的终端，则该进程自动结束。为了使得关闭终端进程依旧可以运行，使用<code>nohup+&amp;</code>指令（此时处于关闭掉tail进程所在终端的状态）</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031148740.png" alt="image-20230803114850706"></p>
<p>输出被追加到<code>nohup.out</code>中</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031149569.png" alt="image-20230803114920537"></p>
<p>此时用<code>ps -ef</code>过滤，仍然有<code>tail</code>进程</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031149918.png" alt="image-20230803114957901"></p>
<p>此时，关闭终端（执行<code>nohup</code>的那个终端），再调用<code>ps -ef</code>，<code>tail</code>进程仍存在，但此时它变为孤儿进程，其父进程分配为<code>1</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031258186.png" alt="image-20230803125857148"></p>
<p>查看当前进程的标准输入和标准输出，可以看到，输入<code>（0）</code>被关闭，输出<code>（1、2）</code>被定向到<code>nohup.out</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031301970.png" alt="image-20230803130115916"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
</search>
