<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《操作系统》</title>
    <url>/2023/08/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="1、终端与进程组"><a href="#1、终端与进程组" class="headerlink" title="1、终端与进程组"></a>1、终端与进程组</h2><h3 id="（1）终端"><a href="#（1）终端" class="headerlink" title="（1）终端"></a>（1）终端</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031335344.png" alt="image-20230803133540713"></p>
<h4 id="1）运行前台进程-sleep-3000"><a href="#1）运行前台进程-sleep-3000" class="headerlink" title="1）运行前台进程 sleep 3000"></a>1）运行前台进程 <code>sleep 3000</code></h4><h4 id="2）运行后台进程-sleep-3000"><a href="#2）运行后台进程-sleep-3000" class="headerlink" title="2）运行后台进程 sleep 3000 &amp;"></a>2）运行后台进程 <code>sleep 3000 &amp;</code></h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031337505.png" alt="image-20230803133741336"></p>
<h4 id="3）查看后台进程-jobs"><a href="#3）查看后台进程-jobs" class="headerlink" title="3）查看后台进程 jobs"></a>3）查看后台进程 <code>jobs</code></h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031340236.png" alt="image-20230803134010984"></p>
<h4 id="4）将后台进程变为前台进程-fg"><a href="#4）将后台进程变为前台进程-fg" class="headerlink" title="4）将后台进程变为前台进程 fg +%&lt;进程编号&gt;"></a>4）将后台进程变为前台进程 <code>fg +%&lt;进程编号&gt;</code></h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031340037.png" alt="image-20230803134030968"></p>
<h4 id="5）查看当前终端名字-tty"><a href="#5）查看当前终端名字-tty" class="headerlink" title="5）查看当前终端名字 tty"></a>5）查看当前终端名字 <code>tty</code></h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031341611.png" alt="image-20230803134150192"></p>
<h3 id="（2）进程组"><a href="#（2）进程组" class="headerlink" title="（2）进程组"></a>（2）进程组</h3><p>其中，<code>PGID</code>即为进程组<code>ID</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031346173.png" alt="image-20230803134636774"></p>
<span id="more"></span>

<h2 id="2、会话"><a href="#2、会话" class="headerlink" title="2、会话"></a>2、会话</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 测试setsid和geysid</span><br><span class="line">int main() &#123;</span><br><span class="line">    pid_t pid = -1;</span><br><span class="line"></span><br><span class="line">    // 获取当前进程组会话ID</span><br><span class="line">    pid = getsid(0);</span><br><span class="line">    if(-1 == pid)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;getsid&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;sid:%d\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sid:620400</span><br></pre></td></tr></table></figure>

<p>此时，若以当前进程创建会话，会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 测试setsid和geysid</span><br><span class="line">int main() &#123;</span><br><span class="line">    pid_t pid = -1;</span><br><span class="line"></span><br><span class="line">    // 获取当前进程组会话ID</span><br><span class="line">    pid = getsid(0);</span><br><span class="line">    if(-1 == pid)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;getsid&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;sid:%d\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    // 新建一个会话</span><br><span class="line">    pid = setsid();</span><br><span class="line">    if(-1 == pid)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;setsid&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;sid:%d\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>报错为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sid:620400</span><br><span class="line">setsid: Operation not permitted</span><br></pre></td></tr></table></figure>

<p>查看当前进程的<code>PID</code>和<code>PGID</code>可以发现</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031401546.png" alt="image-20230803140116366"></p>
<p>当前<code>test</code>本身就是一个组长（<code>PID</code>和<code>PGID</code>一致），所以新建一个会话时报错，因为<strong>创建会话时，调用进程不能是进程组的组长，因为这个进程会变成新会话的首进程（组长）</strong>。</p>
<h2 id="3、daemon进程"><a href="#3、daemon进程" class="headerlink" title="3、daemon进程"></a>3、daemon进程</h2><p>又称守护进程、精灵进程。</p>
<p><code>daemon进程</code>的特点：</p>
<p>1）独立于控制终端；</p>
<p>2）名字一般以<code>d</code>结尾；</p>
<p>3）所有的服务存在于<code>etc/init.d</code></p>
<p>4）是一个特殊的孤儿进程；</p>
<p>5）输入被关闭，输出存在于日志中：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031134687.png" alt="image-20230803113433643"></p>
<h2 id="4、nohup和-命令使进程忽略hangup（挂起）信号"><a href="#4、nohup和-命令使进程忽略hangup（挂起）信号" class="headerlink" title="4、nohup和&amp;命令使进程忽略hangup（挂起）信号"></a>4、nohup和&amp;命令使进程忽略hangup（挂起）信号</h2><p>1）创建一个一般进程</p>
<p>使用<code>tail</code>命令跟踪<code>/var/log/syslog</code>文件</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031135972.png" alt="image-20230803113507931"></p>
<p>2）查看当前<code>tail</code>进程是否存在</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031136769.png" alt="image-20230803113609741"></p>
<p>3）此时若关闭掉<code>tail</code>进程所在的终端，则该进程自动结束。为了使得关闭终端进程依旧可以运行，使用<code>nohup+&amp;</code>指令（此时处于关闭掉tail进程所在终端的状态）</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031148740.png" alt="image-20230803114850706"></p>
<p>输出被追加到<code>nohup.out</code>中</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031149569.png" alt="image-20230803114920537"></p>
<p>此时用<code>ps -ef</code>过滤，仍然有<code>tail</code>进程</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031149918.png" alt="image-20230803114957901"></p>
<p>此时，关闭终端（执行<code>nohup</code>的那个终端），再调用<code>ps -ef</code>，<code>tail</code>进程仍存在，但此时它变为孤儿进程，其父进程分配为<code>1</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031258186.png" alt="image-20230803125857148"></p>
<p>查看当前进程的标准输入和标准输出，可以看到，输入<code>（0）</code>被关闭，输出<code>（1、2）</code>被定向到<code>nohup.out</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308031301970.png" alt="image-20230803130115916"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>《数据结构（严蔚敏）》_b站鲍松山</title>
    <url>/2023/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%A5%E8%94%9A%E6%95%8F%EF%BC%89%E3%80%8B_b%E7%AB%99%E9%B2%8D%E6%9D%BE%E5%B1%B1/</url>
    <content><![CDATA[<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><p>数据结构（Data Struct）：数据之间的组织架构&#x2F;结构。</p>
<blockquote>
<p><strong>DS：</strong></p>
<ul>
<li><strong>线性结构</strong><ul>
<li><strong>SeqList&#x2F;List&#x2F;Stack&#x2F;Queue&#x2F;String&#x2F;Array</strong></li>
</ul>
</li>
<li><strong>非线性结构</strong><ul>
<li><strong>Tree&#x2F;Graph</strong></li>
</ul>
</li>
<li><strong>排序</strong></li>
<li><strong>查找</strong></li>
<li><strong>算法</strong></li>
</ul>
</blockquote>
<span id="more"></span>

<h1 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2 线性表"></a>2 线性表</h1><h2 id="2-1-顺序表（SeqList）"><a href="#2-1-顺序表（SeqList）" class="headerlink" title="2.1 顺序表（SeqList）"></a>2.1 顺序表（SeqList）</h2><p>顺序表通过一组地址连续的空间对数据进行存储。</p>
<h2 id="2-2-单链表（List）"><a href="#2-2-单链表（List）" class="headerlink" title="2.2 单链表（List）"></a>2.2 单链表（List）</h2><p>不要求逻辑上相邻的元素在物理位置上也相邻，因此无法实现随机存取。</p>
<p>分清“谁的谁是谁”。 </p>
<p>操作时要时刻注意<code>last</code>这一项。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120918067.png" alt="image-20231212091813193" style="zoom: 33%;" />

<p><strong>头部插入时易错：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(List *<span class="built_in">list</span>, ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *s = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    assert(s != <span class="literal">NULL</span>);</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="built_in">list</span>-&gt;first-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;first-&gt;next = s;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下图所示，当使用头插法向<code>空list</code>中插入<code>1</code>后，<code>list-&gt;last</code>仍然指向头结点。‘</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915222.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915816.png" alt="2"></p>
<p> 对<code>pop_front</code>进行修改，加入对<code>size</code>的判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">list</span>-&gt;last = s; <span class="comment">// 当list为空时，对last进行移动</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915584.png" alt="3"></p>
<p><strong>头部删除时同理</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_front</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Node *p = <span class="built_in">list</span>-&gt;first-&gt;next;</span><br><span class="line">    <span class="built_in">list</span>-&gt;first-&gt;next = <span class="built_in">list</span>-&gt;first-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">list</span>-&gt;last = <span class="built_in">list</span>-&gt;first;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-静态链表（StaticList）"><a href="#2-3-静态链表（StaticList）" class="headerlink" title="2.3 静态链表（StaticList）"></a>2.3 静态链表（StaticList）</h2><p>使用<strong>静态链表</strong>可以便于在不设<em>指针</em>类型的高级程序设计语言中使用链表结构。</p>
<p>静态链表实际上就是用数组去模拟链表。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915948.png" alt="4" style="zoom: 67%;" />

<p>这里的<code>pool</code>指明下一个备用空间的地址。</p>
<h2 id="2-4-单循环链表（SCList）"><a href="#2-4-单循环链表（SCList）" class="headerlink" title="2.4 单循环链表（SCList）"></a>2.4 单循环链表（SCList）</h2><p>特点：尾节点指向头节点，整个链表形成一个环。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312121129584.png" alt="image-20231212112956184" style="zoom:33%;" />

<p>循环链表的操作和线性链表基本一致,差别仪在于算法中的循环条件不是<code>p</code>或<code>p-&gt;next</code>是否为空，而是它们是否等于头指针。但有的时候，若在循环链表中设立尾指针而不设头指针，可使某些操作简化。例如将两个线性表合并成一个表时，仅需将一个表的表尾和另一个表的表头相接。</p>
<p>初始化时，注意：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>-&gt;first = <span class="built_in">list</span>-&gt;last = s;</span><br><span class="line"><span class="built_in">list</span>-&gt;last-&gt;next = <span class="built_in">list</span>-&gt;first;</span><br><span class="line"><span class="built_in">list</span>-&gt;size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120928507.png" alt="image-20231212092812466"></p>
<p>尾插时的各节点地址：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120954889.png" alt="image-20231212095457800"  />

<p><strong>掌握按值删除这里的的思想：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按值删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_val</span><span class="params">(List *<span class="built_in">list</span>, ElemType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Node *p = find(<span class="built_in">list</span>, key);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;要删除的数据不存在！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p == <span class="built_in">list</span>-&gt;last)</span><br><span class="line">        pop_back(<span class="built_in">list</span>);</span><br><span class="line">    <span class="comment">////////////////////////////////***</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 即不是删除当前节点，而是将下一个节点的值赋值给当前节点，然后删除下一个节点</span></span><br><span class="line">        <span class="comment">// 这样做避免从头遍历链表</span></span><br><span class="line">        Node *q = p-&gt;next;</span><br><span class="line">        p-&gt;data = q-&gt;data;</span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        <span class="built_in">list</span>-&gt;size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">////////////////////////////////***</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>申请节点：Node *s<br>遍历节点：Node *p<br>删除节点：Node *q</p>
</blockquote>
<h2 id="2-5-双向链表（DList）"><a href="#2-5-双向链表（DList）" class="headerlink" title="2.5 双向链表（DList）"></a>2.5 双向链表（DList）</h2><p>每次操作时涉及4个指针：</p>
<ul>
<li>当前节点的前驱；</li>
<li>当前节点的后继；</li>
<li>前一个节点的后继；</li>
<li>后一个节点的前驱。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312131154818.png" alt="image-20231213115430268" style="zoom:33%;" />

<h2 id="2-6-双向循环链表（DCList）"><a href="#2-6-双向循环链表（DCList）" class="headerlink" title="2.6 双向循环链表（DCList）"></a>2.6 双向循环链表（DCList）</h2><p>存在两个环。</p>
<p><strong>环1是<code>list-&gt;last-&gt;next</code></strong></p>
<p><strong>环2是<code>list-&gt;first-&gt;prev</code></strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312140920009.png" alt="image-20231214092024742" style="zoom: 25%;" />

<h1 id="3-栈和队列"><a href="#3-栈和队列" class="headerlink" title="3 栈和队列"></a>3 栈和队列</h1><h2 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h2><p><strong>栈和队列的基本操作是线性表操作的子集，是操作受限的线性表。</strong></p>
<p>栈：限定仅在表尾插入或删除操作的线性表。表尾称为<strong>栈顶</strong>，表头称为<strong>栈底</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312141056107.png" alt="image-20231214105656926" style="zoom: 25%;" />

<h3 id="3-1-1-顺序栈（SeqStack）"><a href="#3-1-1-顺序栈（SeqStack）" class="headerlink" title="3.1.1 顺序栈（SeqStack）"></a>3.1.1 顺序栈（SeqStack）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312141103006.png" alt="image-20231214110346157" style="zoom:25%;" />

<h3 id="3-1-2-链栈（LinkStack）"><a href="#3-1-2-链栈（LinkStack）" class="headerlink" title="3.1.2 链栈（LinkStack）"></a>3.1.2 链栈（LinkStack）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312151207109.png" alt="image-20231215120659701" style="zoom:25%;" />

<h3 id="3-1-3-栈的应用"><a href="#3-1-3-栈的应用" class="headerlink" title="3.1.3 栈的应用"></a>3.1.3 栈的应用</h3><h4 id="1、数制转换"><a href="#1、数制转换" class="headerlink" title="1、数制转换"></a>1、数制转换</h4><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312151258969.png" alt="image-20231215125804838" style="zoom:67%;" />

<p>由于结果要从下往上读取，因此用一个栈来依次存放余数。最终依次取栈顶元素，就可以得到转换后的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;SeqStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数制转换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Convert_8</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqStack st;</span><br><span class="line">    InitStack(&amp;st);</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;st, value%<span class="number">8</span>);</span><br><span class="line">        value /= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Show(&amp;st);</span></span><br><span class="line">    <span class="keyword">while</span> (!(IsEmpty(&amp;st)))</span><br><span class="line">    &#123;</span><br><span class="line">        GetTop(&amp;st, &amp;v);</span><br><span class="line">        Pop(&amp;st);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.数制转换 ElemType int</span></span><br><span class="line">    <span class="type">int</span> value = <span class="number">47183</span>;</span><br><span class="line">    Convert_8(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、括号匹配"><a href="#2、括号匹配" class="headerlink" title="2、括号匹配"></a>2、括号匹配</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 括号匹配</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Check</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqStack st;</span><br><span class="line">    InitStack(&amp;st);</span><br><span class="line">    <span class="type">char</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">&#x27;[&#x27;</span> || *str == <span class="string">&#x27;&#123;&#x27;</span> || *str == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            Push(&amp;st, *str);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetTop(&amp;st, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Pop(&amp;st);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetTop(&amp;st, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Pop(&amp;st);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetTop(&amp;st, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Pop(&amp;st);</span><br><span class="line">        &#125; </span><br><span class="line">        *str++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IsEmpty(&amp;st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2.括号匹配 ElemType char</span></span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;[([][])]&quot;</span>; <span class="comment">// char *str    str是一个指向字符数组的指针</span></span><br><span class="line">    <span class="type">bool</span> flag = Check(str);</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Ok!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、行编辑程序"><a href="#3、行编辑程序" class="headerlink" title="3、行编辑程序"></a>3、行编辑程序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 3.行编辑程序</span></span><br><span class="line">    SeqStack st;</span><br><span class="line">    InitStack(&amp;st);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch != <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(ch !=<span class="string">&#x27;$&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(ch)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    Pop(&amp;st);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">                    Clear(&amp;st);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    Push(&amp;st, ch);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        Print(&amp;st);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    Destroy(&amp;st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-队列（LinkQueue）"><a href="#3-2-队列（LinkQueue）" class="headerlink" title="3.2 队列（LinkQueue）"></a>3.2 队列（LinkQueue）</h2><p>先进先出的结构。</p>
<p>最典型的队列例子是<strong>操作系统中的作业排队</strong>。</p>
<p>队列可分为单端队列和双端队列，但双端队列实际上远不及栈和单端队列有用。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161259625.png" alt="image-20231216125953859" style="zoom: 25%;" />

<h3 id="3-2-1-链队列（LinkQueue）"><a href="#3-2-1-链队列（LinkQueue）" class="headerlink" title="3.2.1 链队列（LinkQueue）"></a>3.2.1 链队列（LinkQueue）</h3><p>由两个分别指向队头和队尾的指针唯一确定一个队列。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161300828.png" alt="image-20231216130008621" style="zoom:20%;" />

<h3 id="3-2-2-顺序队列（SeqQueue）实现循环队列"><a href="#3-2-2-顺序队列（SeqQueue）实现循环队列" class="headerlink" title="3.2.2 顺序队列（SeqQueue）实现循环队列"></a>3.2.2 顺序队列（SeqQueue）实现循环队列</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161300215.png" alt="image-20231216130020025" style="zoom:25%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161300091.png" alt="image-20231216130034444" style="zoom: 33%;" />

<h1 id="4-串"><a href="#4-串" class="headerlink" title="4 串"></a>4 串</h1><p><code>C</code>语言实际上不存在字符串的概念。它是通过相应的字符指针指向一串字符。</p>
<p>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>而在<code>C++</code>中则出现了<code>string</code>类型，它实际上是一个用类实现的数据结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>串的定义：串（<code>string</code>）（或字符串）是由零个或多个字符组成的有限序列。</p>
<p>一般对串的整体进行操作，而不是对其中的单个元素进行操作。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312182049251.png" alt="image-20231218204922589" style="zoom: 25%;" />

<h2 id="4-1-定长顺序存储方式（StackString）"><a href="#4-1-定长顺序存储方式（StackString）" class="headerlink" title="4.1 定长顺序存储方式（StackString）"></a>4.1 定长顺序存储方式（StackString）</h2><p>定长的方式：<strong>先开辟的定长数组</strong>描述字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRLEN 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> u_char unsigned char</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> u_char SString[MAXSTRLEN+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<h2 id="4-2-堆分配存储方式（HeapString）"><a href="#4-2-堆分配存储方式（HeapString）" class="headerlink" title="4.2 堆分配存储方式（HeapString）"></a>4.2 堆分配存储方式（HeapString）</h2><p>仍以一组地址连续的存储单元存放串值字符序列，但其存储空间在程序执行过程中动态分配而得。用<code>malloc()</code>来为新产生的串分配存储空间，并约定串长也作为存储结构的一部分。</p>
<p>函数内部四步：</p>
<ul>
<li>条件判断（不满足条件直接返回）</li>
<li>空间判断（涉及操作的串的空间是否需要赋空，<code>free</code>）</li>
<li>空间分配（给串分配空间，<code>malloc</code>)</li>
<li>赋值操作</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312182049570.png" alt="image-20231218204932225" style="zoom: 33%;" />

<h1 id="5-数组和广义表"><a href="#5-数组和广义表" class="headerlink" title="5 数组和广义表"></a>5 数组和广义表</h1><h2 id="5-1-矩阵的压缩存储（SparseMatrix）"><a href="#5-1-矩阵的压缩存储（SparseMatrix）" class="headerlink" title="5.1 矩阵的压缩存储（SparseMatrix）"></a>5.1 矩阵的压缩存储（SparseMatrix）</h2><p>感兴趣的不是矩阵本身，而是如何存储矩阵的元，使得矩阵进行各项运算。</p>
<p>压缩存储：为多个值相同的元只分配一个存储空间；对零元不分配存储空间。假若值相同的元素或者零元素在矩阵中的分布有一定规律，称为<strong>特殊矩阵</strong>；反之，称为<strong>稀疏矩阵</strong>。</p>
<p><strong>压缩存储时，需要用一个三元组<code>(i,j,aij)</code>唯一确定矩阵A的一个非零元，即除了存储非零元的值<code>aij</code>外，还需要存储其所在行和列的位置<code>(i,j)</code>。</strong></p>
<p>稀疏矩阵的压缩存储示例：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312191547788.png" alt="image-20231219154712437" style="zoom:80%;" />

<h2 id="5-2-矩阵的快速转置算法实现"><a href="#5-2-矩阵的快速转置算法实现" class="headerlink" title="5.2 矩阵的快速转置算法实现"></a>5.2 矩阵的快速转置算法实现</h2><ul>
<li><p>（1）交换矩阵的行列值；</p>
</li>
<li><p>（2）交换三元组中的<code>i</code>和<code>j</code>；</p>
</li>
<li><p><strong>（3）重排三元组之间的次序。—-重点！</strong></p>
<ul>
<li>实现方法1：较为笨拙的重复遍历</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312192015890.png" alt="image-20231219201524473" style="zoom: 33%;" />

<ul>
<li><p>实现方法2：快速转置算法</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312192039855.png" alt="image-20231219203949650" style="zoom: 50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矩阵快速转置（实现方法2）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FastTransposeMatrix</span><span class="params">(SparseMatrix *M, SparseMatrix *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    T-&gt;mu = M-&gt;nu;</span><br><span class="line">    T-&gt;nu = M-&gt;mu;</span><br><span class="line">    T-&gt;tu = M-&gt;tu;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *num = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * M-&gt;nu);  <span class="comment">// M中每一列非零元的个数</span></span><br><span class="line">    assert(num != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">int</span> *cpot = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * M-&gt;nu);  <span class="comment">// M中每一列的第一个非零元对应三元组空间所在位置</span></span><br><span class="line">    assert(cpot != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;tu != <span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 初始化num数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>; col&lt;M-&gt;nu; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            num[col] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>; t&lt;M-&gt;tu; ++t)</span><br><span class="line">        &#123;</span><br><span class="line">            num[M-&gt;data[t].j]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化cpot数组</span></span><br><span class="line">        cpot[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">1</span>; col&lt;M-&gt;nu; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            cpot[col] = cpot[col<span class="number">-1</span>] + num[col<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行转置映射</span></span><br><span class="line">        <span class="type">int</span> col = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> kt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> km=<span class="number">0</span>; km&lt;M-&gt;tu; ++km)</span><br><span class="line">        &#123;</span><br><span class="line">            col = M-&gt;data[km].j;</span><br><span class="line">            kt = cpot[col];</span><br><span class="line">            T-&gt;data[kt].i = M-&gt;data[km].j;</span><br><span class="line">            T-&gt;data[kt].j = M-&gt;data[km].i;</span><br><span class="line">            T-&gt;data[kt].e = M-&gt;data[km].e;</span><br><span class="line">            cpot[col]++; <span class="comment">// 重要步骤</span></span><br><span class="line">            kt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在C中，如果使用了动态内存分配函数如malloc、calloc或realloc来分配内存</span></span><br><span class="line">    <span class="comment">// 那么最终应该使用 free 函数来释放已分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(num);</span><br><span class="line">    <span class="built_in">free</span>(cpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="5-3-广义表（GenList"><a href="#5-3-广义表（GenList" class="headerlink" title="5.3 广义表（GenList)"></a>5.3 广义表（GenList)</h2><blockquote>
<p><strong>所谓的广义表实际上就是一个递归概念。</strong></p>
<p><strong>1、处理tag&#x3D;&#x3D;ATOM的节点；</strong></p>
<p><strong>2、对子表进行递归操作；</strong></p>
<ul>
<li><strong>找到子表中的tag&#x3D;&#x3D;ATOM的节点并处理；</strong></li>
<li><strong>对剩下的节点组成的新的子表重复步骤2，直至子表中不存在节点。</strong></li>
</ul>
</blockquote>
<h3 id="1、含义"><a href="#1、含义" class="headerlink" title="1、含义"></a>1、含义</h3><p>线性表的推广。简单来说就是<strong>表中有表</strong>。</p>
<p>因此，有一个概念要尤其注意，<strong>即广义表是由无数个广义表组成的自身。</strong></p>
<h3 id="2、定义"><a href="#2、定义" class="headerlink" title="2、定义"></a>2、定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LS=(a1,a2,...an)</span><br></pre></td></tr></table></figure>

<p>其中，<code>ai(1&lt;=i&lt;=n)</code>可以是单个元素，也可以是广义表，分别称为<strong>原子</strong>和<strong>子集</strong>。当广义表非空时，<code>a1</code>称为表头（<code>Head</code>），其余元素组成的表<code>(a2,a3,...,an)</code>称为表尾（<code>Tail</code>）。</p>
<p><strong>举例：</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312200930160.png" alt="image-20231220093015065"></p>
<p><strong>注意：</strong>           </p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312200931491.png" alt="image-20231220093159352"></p>
<h3 id="3、存储结构"><a href="#3、存储结构" class="headerlink" title="3、存储结构"></a>3、存储结构</h3><p>由于表中的数据元素可以具有不同结构，因此一般采用<strong>链式存储方式</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312201010034.png" alt="image-20231220101006602" style="zoom: 33%;" />

<h2 id="5-4-表头分割算法"><a href="#5-4-表头分割算法" class="headerlink" title="5.4 表头分割算法"></a>5.4 表头分割算法</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312201628127.png" alt="image-20231220162815397" style="zoom: 33%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建广义表：通过字符串str来创建广义表gl</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateGenList</span><span class="params">(GenList &amp;gl, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(str);  <span class="comment">// 求解字符串长度</span></span><br><span class="line">	<span class="comment">// 存储表内元素</span></span><br><span class="line">	<span class="type">char</span> *sub = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (n<span class="number">-2</span>));</span><br><span class="line">	<span class="comment">// 存储表头</span></span><br><span class="line">	<span class="type">char</span> *hsub = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (n<span class="number">-2</span>));</span><br><span class="line">	assert(sub!=<span class="literal">NULL</span> &amp;&amp; hsub!=<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &quot;1,2,3&quot;</span></span><br><span class="line">	<span class="comment">// 去掉sub左右两边的括号</span></span><br><span class="line">	<span class="built_in">strncpy</span>(sub,str+<span class="number">1</span>,n<span class="number">-2</span>); </span><br><span class="line">	sub[n<span class="number">-2</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//加上结束符</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断广义表是否为空</span></span><br><span class="line">	<span class="keyword">if</span>(gl == <span class="literal">NULL</span>)  <span class="comment">// 为空</span></span><br><span class="line">	&#123;   </span><br><span class="line">		<span class="comment">//  创建头结点(广义表的第一个结点为头结点，其余都为尾结点)</span></span><br><span class="line">		gl = (GLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GLNode));</span><br><span class="line">		assert(gl != <span class="literal">NULL</span>);</span><br><span class="line">		gl-&gt;tag = HEAD;  <span class="comment">// 结点标记为头结点</span></span><br><span class="line">		gl-&gt;hp = gl-&gt;tp = <span class="literal">NULL</span>;  <span class="comment">// 把子表指针和尾指针都指向空</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	GLNode *p = gl;  <span class="comment">// 为了不丢失gl的指向，定义一个指针来操作</span></span><br><span class="line">	<span class="comment">// 求子串长度，当sub长度不为零时，说明广义表还未创建完成</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">strlen</span>(sub) != <span class="number">0</span>)</span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="comment">//  采用尾插法,在后面插入结点</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			1、创建一个结点</span></span><br><span class="line"><span class="comment">			2、让p所指结点的尾指针指向新建的结点</span></span><br><span class="line"><span class="comment">			3、让p指向新建结点</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		p = p-&gt;tp = (GLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GLNode));</span><br><span class="line">		assert(p != <span class="literal">NULL</span>);</span><br><span class="line">		p-&gt;hp = p-&gt;tp = <span class="literal">NULL</span>;  <span class="comment">// 将新建结点的子表指针和尾指针都赋空</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//  &quot;1,2,3&quot;     ==&gt;  &quot;1&quot;      hsub=&quot;1&quot;  sub=&quot;2,3&quot;;</span></span><br><span class="line">		<span class="comment">//  &quot;(1,2),3,4&quot; ==&gt;  &quot;(1,2)&quot;  hsub=&quot;(1,2)&quot; sub=&quot;3,4&quot;</span></span><br><span class="line">		<span class="keyword">if</span>(sever(sub,hsub))  <span class="comment">// sever函数分离表头，并将表头存入hsub中</span></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 对分离出来的表头进行判断，是否包含括号</span></span><br><span class="line">			<span class="keyword">if</span>(hsub[<span class="number">0</span>] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 说明要创建的结点是子表类型</span></span><br><span class="line">				p-&gt;tag = CHILDLIST;  <span class="comment">// 设置子表标记</span></span><br><span class="line">				CreateGenList(p-&gt;hp,hsub);  <span class="comment">// 在p的表头结点处，创建hsub子表</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 说明要创建的结点是原子类型</span></span><br><span class="line">				p-&gt;tag = ATOM;  <span class="comment">// 设置原子标记</span></span><br><span class="line">				p-&gt;atom = atoi(hsub);  <span class="comment">// 将表头字符串转换成整型数据，赋值给原子数据</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广义表表头分割函数，将sub中的表头分割到hsub中</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sever</span><span class="params">(<span class="type">char</span> *sub, <span class="type">char</span> *hsub)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//  判断sub是否为空</span></span><br><span class="line">	<span class="keyword">if</span>(*sub==<span class="string">&#x27;\0&#x27;</span> || <span class="built_in">strcmp</span>(sub,<span class="string">&quot;()&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 是 情况：&quot;&quot;  或  &quot;()&quot;</span></span><br><span class="line">		hsub[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 将hsub赋空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(sub);  <span class="comment">// 求sub的长度</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch = sub[<span class="number">0</span>];  <span class="comment">// 获取第一个字符</span></span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;  <span class="comment">// 表示括号的信息</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        当sub还没遍历完成且还未检测到括号外的逗号，继续遍历</span></span><br><span class="line"><span class="comment">	    注：当检测到括号外的逗号时，说明找到表头分割点，如：&quot;(1,2),3,4&quot; 表头即为(1,2)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;n &amp;&amp; (ch!=<span class="string">&#x27;,&#x27;</span>|| k!=<span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 判断是否运到左括号</span></span><br><span class="line">		<span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">			k++;  <span class="comment">// k++表示进入一层括号</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;)&#x27;</span>)  <span class="comment">// 判断是否遇到右括号</span></span><br><span class="line">			k--;   <span class="comment">// k--表示退出一层括号</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取下一个元素</span></span><br><span class="line">		i++;</span><br><span class="line">		ch = sub[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断是否是因为检测到括号外的逗号而结束的</span></span><br><span class="line">	<span class="keyword">if</span>(i &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 是</span></span><br><span class="line">		<span class="comment">// 在i位置截断，前面部分就是表头</span></span><br><span class="line">		sub[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="comment">// 将取得的表头放入hsub中</span></span><br><span class="line">		<span class="built_in">strcpy</span>(hsub,sub);</span><br><span class="line">		<span class="comment">// 更新sub的值：此时的sub应该去掉表头hsub</span></span><br><span class="line">		<span class="built_in">strcpy</span>(sub,sub+i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(k != <span class="number">0</span>)  <span class="comment">// 判断是否是因为内部括号不匹配</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 是，分割失败</span></span><br><span class="line">	<span class="keyword">else</span>  <span class="comment">// 判断是否是因为i&gt;=n而结束</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 是，情况 &quot;(1,2)&quot;  ==&gt; hsub =&quot;(1,2)&quot;  sub = &quot;&quot;</span></span><br><span class="line">		<span class="comment">// 说明sub整个就是表头</span></span><br><span class="line">		<span class="built_in">strcpy</span>(hsub,sub);  <span class="comment">// 把sub整个赋值给hsub</span></span><br><span class="line">		sub[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// sub赋给hsub后，此时sub为空</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-树和二叉树"><a href="#6-树和二叉树" class="headerlink" title="6 树和二叉树"></a>6 树和二叉树</h1><h2 id="6-1-树及二叉树的概念与性质"><a href="#6-1-树及二叉树的概念与性质" class="headerlink" title="6.1 树及二叉树的概念与性质"></a>6.1 树及二叉树的概念与性质</h2><p><strong>树</strong>：</p>
<ul>
<li><p>结点拥有的子树数称为结点的<strong>度</strong>；</p>
</li>
<li><p>树种结点的最大层次（横向）称为树的<strong>深度****或</strong>高度**；</p>
</li>
<li><p><strong>森林</strong>是<code>m(m&gt;=0)</code>棵互不相交的树的集合。</p>
</li>
</ul>
<p><strong>二叉树</strong></p>
<ul>
<li><p>每个结点至多只有两颗子树，且有左右之分；</p>
<ul>
<li><strong>性质1：</strong>第<code>i</code>层（层次）至多有<code>2^(i-1)</code>个结点；</li>
<li><strong>性质2：</strong>深度为<code>k</code>的二叉树至多有<code>2^k-1</code>个结点；</li>
<li><strong>性质3：</strong>对任何一棵二叉树<code>T</code>，其终端结点数为<code>n0</code>，度为<code>2</code>的结点数为<code>n2</code>，则<code>n0=n2+1</code>；</li>
</ul>
</li>
<li><p>满二叉树：所有结点（除叶子结点外）均有左右分支；</p>
</li>
<li><p>完全二叉树：基于满二叉树实现，<em><strong>性质4&#x2F;5代表从<code>1</code>开始编号的情况。</strong></em></p>
<ul>
<li><strong>性质4：</strong>具有<code>n</code>个结点的<strong>完全二叉树</strong>的深度为<code>[log2n]+1</code>(<code>&quot;[]&quot;</code>表示向下取整)；</li>
<li><strong>性质5：</strong>对一棵有<code>n</code>个结点的<strong>完全二叉树</strong>的结点按层序编号，对任一结点<code>i(1&lt;=i&lt;=n)</code>：<ul>
<li><strong>（1）</strong>若<code>i=1</code>，则结点i是二叉树的根，无双亲；若<code>i&gt;1</code>，则其双亲<code>PARENT(i)</code>是结点<code>[i/2]</code>；</li>
<li><strong>（2）</strong>若<code>2i&gt;n</code>，则结点<code>i</code>无左孩子；否则左孩子是<code>2i</code>；</li>
<li><strong>（3）</strong>若<code>2i+1&gt;n</code>，则结点<code>i</code>无右孩子；否则右孩子是<code>2i+1</code>；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-2-二叉树的链式存储方式（二叉链表，BinTree）"><a href="#6-2-二叉树的链式存储方式（二叉链表，BinTree）" class="headerlink" title="6.2 二叉树的链式存储方式（二叉链表，BinTree）"></a>6.2 二叉树的链式存储方式（二叉链表，BinTree）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType BinTreeNode*</span></span><br></pre></td></tr></table></figure>

<h2 id="6-3-二叉树的非递归遍历"><a href="#6-3-二叉树的非递归遍历" class="headerlink" title="6.3 二叉树的非递归遍历"></a>6.3 二叉树的非递归遍历</h2><p>用<strong>栈</strong>实现。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221544737.png" alt="image-20231222154427982"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221544992.png" alt="image-20231222154440257"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221544658.png" alt="image-20231222154447677"></p>
<h2 id="6-4-二叉树的恢复实现"><a href="#6-4-二叉树的恢复实现" class="headerlink" title="6.4 二叉树的恢复实现"></a>6.4 二叉树的恢复实现</h2><p>两个概念：二叉树的<strong>相似</strong>和<strong>等价</strong>。</p>
<ul>
<li>相似：形状相同，内容不同</li>
<li>等价：形状和内容均相同。</li>
</ul>
<p>二叉树的计数问题：讨论具有<code>n</code>个结点、互不相似的二叉树的数目<code>b</code>。</p>
<p>含有<code>n</code>个结点的不相似的二叉树有：<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221413095.png" alt="image-20231222141353060" style="zoom: 50%;" />棵。</p>
<blockquote>
<p>1、前序+中序唯一恢复一棵二叉树。</p>
<p>2、中序+后序唯一恢复一棵二叉树。</p>
<p>注意：<strong>恢复二叉树时一定要有中序存在</strong>，因为通过中序遍历可以得知这棵二叉树的左右分布。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序+中序恢复二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_5</span><span class="params">(BinTree *bt, <span class="type">char</span> *VLR, <span class="type">char</span>*LVR, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    CreateBinTree_5(bt-&gt;root, VLR, LVR, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_5</span><span class="params">(BinTreeNode *&amp;t, <span class="type">char</span> *VLR, <span class="type">char</span>*LVR, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(VLR[<span class="number">0</span>] != LVR[k])</span><br><span class="line">            k++;</span><br><span class="line"></span><br><span class="line">        t = (BinTreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTreeNode));</span><br><span class="line">        assert(t != <span class="literal">NULL</span>);</span><br><span class="line">        t-&gt;data = LVR[k];</span><br><span class="line"></span><br><span class="line">        CreateBinTree_5(t-&gt;leftChild, VLR+<span class="number">1</span>, LVR, k);</span><br><span class="line">        CreateBinTree_5(t-&gt;rightChild, VLR+k+<span class="number">1</span>, LVR+k+<span class="number">1</span>, n-k<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序+后序恢复二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_6</span><span class="params">(BinTree *bt, <span class="type">char</span> *LVR, <span class="type">char</span>*LRV, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    CreateBinTree_6(bt-&gt;root, LVR, LRV, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_6</span><span class="params">(BinTreeNode *&amp;t, <span class="type">char</span> *LVR, <span class="type">char</span>*LRV, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(LRV[n<span class="number">-1</span>] != LVR[k])</span><br><span class="line">            k++;</span><br><span class="line">        </span><br><span class="line">        t = (BinTreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTreeNode));</span><br><span class="line">        assert(t != <span class="literal">NULL</span>);</span><br><span class="line">        t-&gt;data = LVR[k];</span><br><span class="line"></span><br><span class="line">        CreateBinTree_6(t-&gt;rightChild, LVR+k+<span class="number">1</span>, LRV+k, n-k<span class="number">-1</span>);</span><br><span class="line">        CreateBinTree_6(t-&gt;leftChild, LVR, LRV, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-5-线索二叉树"><a href="#6-5-线索二叉树" class="headerlink" title="6.5 线索二叉树"></a>6.5 线索二叉树</h2><blockquote>
<p>同时保存节点的<strong>前驱和后继</strong>信息。由于<code>n</code>个结点必然存在<code>n+1</code>个空链，实际上并未完全保存所有的前驱后继信息，而只是利用了这<code>n+1</code>个空链。</p>
</blockquote>
<p>举例：对下面这棵二叉树按照中序遍历线索化</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312232026443.png" alt="image-20231223202641174"></p>
<h2 id="6-6-树和森林"><a href="#6-6-树和森林" class="headerlink" title="6.6 树和森林"></a>6.6 树和森林</h2><p>讨论树的表示及其遍历操作，并建立森林与二叉树的对应关系。</p>
<p>注意这里的树<em>不局限于二叉树</em>。</p>
<h3 id="1、双亲表示法（仅了解即可）"><a href="#1、双亲表示法（仅了解即可）" class="headerlink" title="1、双亲表示法（仅了解即可）"></a>1、双亲表示法（仅了解即可）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241441068.png" alt="image-20231224144144837" style="zoom: 80%;" />

<p><strong>缺点</strong>：求父结点很方便，但求孩子结点时需要遍历整个结构。</p>
<h3 id="2、孩子表示法（仅了解即可）"><a href="#2、孩子表示法（仅了解即可）" class="headerlink" title="2、孩子表示法（仅了解即可）"></a>2、孩子表示法（仅了解即可）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241517749.png" alt="image-20231224151751633"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241518866.png" alt="image-20231224151800720"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241517901.png" alt="image-20231224151730578"></p>
<h3 id="3、孩子兄弟表示法（重要）"><a href="#3、孩子兄弟表示法（重要）" class="headerlink" title="3、孩子兄弟表示法（重要）"></a>3、孩子兄弟表示法（重要）</h3><p>又称二叉树表示法或二叉链表表示法。即以二叉链表作为树的存储结构。</p>
<p>链表中结点的两个链域分别指向该结点的第一个<strong>孩子结点</strong>和下一个<strong>兄弟结点</strong>。<em>（即左孩子，右兄弟）</em></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241541154.png" alt="image-20231224154137327" style="zoom: 33%;" />

<p>对其进行遍历可得：</p>
<p>（1）先序遍历<strong>（先访问根，再依次访问根的每棵子树）</strong>：<code>A B C D E</code></p>
<p>（2）后序遍历<strong>（先依次访问根的每棵子树，再访问根）</strong>：<code>B D C E A</code></p>
<p><strong>树不包含中序遍历！</strong></p>
<h3 id="4、森林和二叉树的转换"><a href="#4、森林和二叉树的转换" class="headerlink" title="4、森林和二叉树的转换"></a>4、森林和二叉树的转换</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241530772.png" alt="image-20231224153024529" style="zoom: 67%;" />

<p>上图依然遵循“左孩子右兄弟”的概念。当三棵树的树根相连时，树根结点之间的关系即为“兄弟”的关系。</p>
<p>对其进行遍历可得：</p>
<p>（1）先序遍历：<code>A B C D E F G H I J</code></p>
<ul>
<li>访问第一棵树的根结点；</li>
<li>先序遍历第一棵树的根结点的子树森林；</li>
<li>先序遍历除去第一棵树之后剩余的树构成的森林。</li>
</ul>
<p>（2）中序遍历：<code>B C D A F E H J I G</code></p>
<ul>
<li>中序遍历森林中第一棵树的根结点的子树森林；</li>
<li>访问第一棵树的根结点；</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林。</li>
</ul>
<blockquote>
<p>对比图6.15和图6.17可以发现，若以二叉链表的形式表示时：</p>
<ul>
<li>如果仅包含左孩子，则为一棵树的二叉链表表示；</li>
<li>否则，则是森林的二叉链表表示。</li>
</ul>
</blockquote>
<h3 id="5、在树中查找父结点和在二叉树中查找父结点"><a href="#5、在树中查找父结点和在二叉树中查找父结点" class="headerlink" title="5、在树中查找父结点和在二叉树中查找父结点"></a>5、在树中查找父结点和在二叉树中查找父结点</h3><h4 id="（1）在树中查找父结点"><a href="#（1）在树中查找父结点" class="headerlink" title="（1）在树中查找父结点"></a>（1）在树中查找父结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找父结点</span></span><br><span class="line">TreeNode* <span class="title function_">Parent</span><span class="params">(Tree *tree, TreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Parent(tree-&gt;root, p);</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* <span class="title function_">Parent</span><span class="params">(TreeNode *t, TreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span> || p == <span class="literal">NULL</span> || p == t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode *q = t-&gt;firstChild;</span><br><span class="line">    TreeNode *parent;</span><br><span class="line">    <span class="keyword">while</span>(q != <span class="literal">NULL</span> &amp;&amp; q != p)</span><br><span class="line">    &#123;</span><br><span class="line">        parent = Parent(q, p);  <span class="comment">// 在第一个孩子结点中查找parent结点</span></span><br><span class="line">        <span class="keyword">if</span>(parent != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        q = q-&gt;nextSilbing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(q != <span class="literal">NULL</span> &amp;&amp; q == p)  <span class="comment">// q(t-&gt;firstChild)==p说明要查找的结点p的父结点即为t</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241742171.png" alt="image-20231224174224376" style="zoom: 33%;" />

<h4 id="（2）在二叉树中查找父结点"><a href="#（2）在二叉树中查找父结点" class="headerlink" title="（2）在二叉树中查找父结点"></a>（2）在二叉树中查找父结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找父节点</span></span><br><span class="line">BinTreeNode* <span class="title function_">Parent</span><span class="params">(BinTree *bt, BinTreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Parent(bt-&gt;root, p);</span><br><span class="line">&#125;</span><br><span class="line">BinTreeNode* <span class="title function_">Parent</span><span class="params">(BinTreeNode *t, BinTreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span> || p == <span class="literal">NULL</span>)  <span class="comment">// 树为空或查找的节点为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">if</span>(t-&gt;leftChild == p || t-&gt;leftChild == p)</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    </span><br><span class="line">    BinTreeNode *q = Parent(t-&gt;leftChild, p);</span><br><span class="line">    <span class="keyword">if</span>(q != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    <span class="keyword">return</span> Parent(t-&gt;rightChild, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-图"><a href="#7-图" class="headerlink" title="7 图"></a>7 图</h1><h2 id="7-1-图的定义与概念"><a href="#7-1-图的定义与概念" class="headerlink" title="7.1 图的定义与概念"></a>7.1 图的定义与概念</h2><p>图中的数据元素称为<strong>顶点</strong>(<code>Vertex</code>)，<code>V</code>是顶点的有穷非空集合。<code>E</code>是两个顶点之间的集合。</p>
<ul>
<li><p><code>&lt;v, w&gt;</code>：从顶点<code>v</code>到顶点<code>w</code>的有向边；</p>
</li>
<li><p><code>(v, w)</code>：从顶点<code>v</code>到顶点<code>w</code>的无向边。</p>
</li>
</ul>
<p>图中共<code>n</code>个顶点，此时：</p>
<ul>
<li>对无向图来说边的个数范围为<code>0~1/2(n(n-1))</code>，当有<code>1/2(n(n-1)</code>条边时为<strong>无向完全图</strong>。</li>
<li>对有向图来说边的个数范围为<code>0~n(n-1)</code>，当有<code>n(n-1)</code>条边时为<strong>有向完全图</strong>。</li>
</ul>
<p>图（<code>Graph</code>）与子图（<code>Subgraph</code>）</p>
<p>权（<code>Weight</code>）</p>
<p>邻接点</p>
<p>顶点<code>v</code>的度（<code>Degree</code>）是和<code>v</code>相关联的边的数目。在有向图中还要分<strong>入度</strong>和<strong>出度</strong>。</p>
<p>从顶点<code>v</code>到顶点<code>v&#39;</code>的路径（<code>Path</code>）是一个顶点序列。路径的长度是路径上的边或弧的数目。第一个顶点和最后一个顶点相同的路径称为回路或环（<code>Cycle</code>）。在无向图<code>G</code>中，若从顶点<code>v</code>到顶点<code>v&#39;</code>有路径，则称<code>v</code>和<code>v&#39;</code>是连通的。若图中任意两个顶点都是连通的，则称<code>G</code>为<strong>连通图</strong>。而<strong>连通分量</strong>（<code>Connected Component</code>）是指无向图中的<strong>极大连通子图</strong>。</p>
<p>一个连通图的<strong>生成树</strong>是一个极小连通子图。如果在一棵生成树上添加一条边，必定形成一个环。</p>
<h2 id="7-2-图的存储方式"><a href="#7-2-图的存储方式" class="headerlink" title="7.2 图的存储方式"></a>7.2 图的存储方式</h2><h3 id="1、邻接矩阵表示方式（数组形式，重要）"><a href="#1、邻接矩阵表示方式（数组形式，重要）" class="headerlink" title="1、邻接矩阵表示方式（数组形式，重要）"></a>1、邻接矩阵表示方式（数组形式，重要）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251216684.png" alt="image-20231225121641478" style="zoom: 25%;" />

<p>两个数组分别存储数据元素（顶点）的信息和数据元素之间的关系（边或弧）的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Default_Vertex_Size 10  <span class="comment">// 默认顶点数大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T char</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphMtx</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span>   MaxVertices;    <span class="comment">// 最大顶点数，即容量</span></span><br><span class="line">    <span class="type">int</span>   NumVertices;    <span class="comment">// 当前顶点数，即真实大小</span></span><br><span class="line">    <span class="type">int</span>   NumEdges;       <span class="comment">// 当前边数</span></span><br><span class="line"></span><br><span class="line">    T    *VerticesList;   <span class="comment">// 顶点列表</span></span><br><span class="line">    <span class="type">int</span> **Edge;           <span class="comment">// 指向邻接矩阵，二维数组</span></span><br><span class="line">    <span class="comment">// 一维数组：指向每一行，即每个顶点和其他顶点的边的连接</span></span><br><span class="line">    <span class="comment">// 二维数组：指向每一列，即当前图包含的所有顶点</span></span><br><span class="line"></span><br><span class="line">&#125;GraphMtx;</span><br></pre></td></tr></table></figure>

<h3 id="2、邻接表表示方式（链表形式，重要）"><a href="#2、邻接表表示方式（链表形式，重要）" class="headerlink" title="2、邻接表表示方式（链表形式，重要）"></a>2、邻接表表示方式（链表形式，重要）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Dafault_Vertex_Size 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 边结构。1）保存顶点的位置信息；2）指向下一个顶点的位置信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> dest;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点结构。包含1）顶点的信息；2）指向的边的信息。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T data;</span><br><span class="line">    Edge *adj;</span><br><span class="line">&#125;Vertex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphLink</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> MaxVertices;</span><br><span class="line">    <span class="type">int</span> NumVertices;</span><br><span class="line">    <span class="type">int</span> NumEdges;</span><br><span class="line"></span><br><span class="line">    Vertex *NodeTable;  <span class="comment">// 存放顶点的“List”</span></span><br><span class="line">&#125;GraphLink;</span><br></pre></td></tr></table></figure>

<p>最重要也是最复杂的函数：删除顶点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除顶点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RemoveVertex</span><span class="params">(GraphLink *g, T vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v = GetVertexPos(g, vertex);</span><br><span class="line">    <span class="comment">// 顶点v不存在，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(v == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除顶点：用最后一个顶点的值覆盖要删除的顶点</span></span><br><span class="line">    <span class="comment">// 删除边：直接调用函数RemoveEdge</span></span><br><span class="line"></span><br><span class="line">    Edge *p = g-&gt;NodeTable[v].adj;  <span class="comment">// p指向要删除结点v的边链表</span></span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    Edge *t = <span class="literal">NULL</span>;  <span class="comment">// s的前驱t，注意一定要先赋值为NULL</span></span><br><span class="line">    Edge *s;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        k = p-&gt;dest;  <span class="comment">// 在释放边之前要先获取和这个顶点有关的顶点的位置信息</span></span><br><span class="line">        s = g-&gt;NodeTable[k].adj;  <span class="comment">// s指向和v相连的第一个顶点的边链表</span></span><br><span class="line">        <span class="keyword">while</span>(s != <span class="literal">NULL</span> &amp;&amp; s-&gt;dest != v)</span><br><span class="line">        &#123;</span><br><span class="line">            t = s;</span><br><span class="line">            s = s-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="literal">NULL</span>) </span><br><span class="line">                g-&gt;NodeTable[k].adj = s-&gt;link;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t-&gt;link = s-&gt;link;</span><br><span class="line">            <span class="built_in">free</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放当前结点</span></span><br><span class="line">        g-&gt;NodeTable[v].adj = p-&gt;link;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="comment">// p指向下一个结点，执行下一次删除</span></span><br><span class="line">        p = g-&gt;NodeTable[v].adj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g-&gt;NumVertices--;</span><br><span class="line">    <span class="comment">// 用最后一个结点vl覆盖要删除的结点v</span></span><br><span class="line">    g-&gt;NodeTable[v].data = g-&gt;NodeTable[g-&gt;NumVertices].data;</span><br><span class="line">    g-&gt;NodeTable[v].adj = g-&gt;NodeTable[g-&gt;NumVertices].adj;</span><br><span class="line">    <span class="comment">// 由于此时vl的下标改变，因此遍历vl的边，对应修改和vl相连的顶点，其指向vl的边的下标位置</span></span><br><span class="line">    s = g-&gt;NodeTable[v].adj;</span><br><span class="line">    <span class="keyword">while</span>(s != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        k = s-&gt;dest;</span><br><span class="line">        p = g-&gt;NodeTable[k].adj;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;dest == g-&gt;NumVertices)  <span class="comment">// 找到了指向vl的边</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;dest = v;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、十字链表（仅了解即可）"><a href="#3、十字链表（仅了解即可）" class="headerlink" title="3、十字链表（仅了解即可）"></a>3、十字链表（仅了解即可）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312261148808.png" alt="image-20231226114811489" style="zoom:50%;" />

<h3 id="4、多重邻接表（仅了解即可）"><a href="#4、多重邻接表（仅了解即可）" class="headerlink" title="4、多重邻接表（仅了解即可）"></a>4、多重邻接表（仅了解即可）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312261256940.png" alt="image-20231226125619799" style="zoom: 50%;" />

<h3 id="5、四种存储结构的对比"><a href="#5、四种存储结构的对比" class="headerlink" title="5、四种存储结构的对比"></a>5、四种存储结构的对比</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312261300229.png" alt="image-20231226130055141" style="zoom: 25%;" />

<h2 id="7-3-图的两种遍历方式"><a href="#7-3-图的两种遍历方式" class="headerlink" title="7.3 图的两种遍历方式"></a>7.3 图的两种遍历方式</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312281111625.png" alt="image-20231228111115955" style="zoom:25%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphLink *g, T vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    <span class="type">bool</span> *visited = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * n);  <span class="comment">// visited数组指明当前顶点是否被访问过</span></span><br><span class="line">    assert(visited != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v = GetVertexPos(g, vertex);</span><br><span class="line">    <span class="keyword">if</span>(v == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    DFS(g, v, visited);</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphLink *g, <span class="type">int</span> v, <span class="type">bool</span> visited[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 顶点A对应的位置为A</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;&quot;</span>, GetVertexValue(g, v));</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问顶点A的邻接点</span></span><br><span class="line">    <span class="type">int</span> w = GetFirstNeighbor(g, GetVertexValue(g, v));</span><br><span class="line">    <span class="keyword">while</span>(w != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 深度遍历</span></span><br><span class="line">        <span class="comment">// 递归访问和当前邻接点相连的邻接点</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[w])</span><br><span class="line">            DFS(g, w, visited);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归访问A的其他邻接点</span></span><br><span class="line">        <span class="comment">// 类似于链表中的 w = w-&gt;next;</span></span><br><span class="line">        w = GetNextNeighbor(g, GetVertexValue(g, v), GetVertexValue(g, w));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 广度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(GraphLink *g, T vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    <span class="type">bool</span> *visited = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * n);  <span class="comment">// visited数组指明当前顶点是否被访问过</span></span><br><span class="line">    assert(visited != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> v = GetVertexPos(g, vertex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;&quot;</span>, GetVertexValue(g, v));</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line"></span><br><span class="line">    EnQueue(&amp;Q, v);</span><br><span class="line">    <span class="keyword">while</span>(!EmptyQueue(&amp;Q))</span><br><span class="line">    &#123;</span><br><span class="line">        GetHead(&amp;Q, &amp;v);</span><br><span class="line">        DeQueue(&amp;Q);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> w = GetFirstNeighbor(g, GetVertexValue(g, v));</span><br><span class="line">        <span class="keyword">while</span>(w != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;&quot;</span>, GetVertexValue(g, w));</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                EnQueue(&amp;Q, w);</span><br><span class="line">            &#125;</span><br><span class="line">            w = GetNextNeighbor(g, GetVertexValue(g, v), GetVertexValue(g, w));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-4-图的连通性问题"><a href="#7-4-图的连通性问题" class="headerlink" title="7.4 图的连通性问题"></a>7.4 图的连通性问题</h2><p><strong>连通图：任意顶点间都有路径可以相互到达。</strong></p>
<p>对于无向图来说，若图连通，则采用<code>DFS/BFS</code>即可遍历整张图。</p>
<h3 id="1、非连通图遍历"><a href="#1、非连通图遍历" class="headerlink" title="1、非连通图遍历"></a>1、非连通图遍历</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312281110107.png" alt="image-20231228111031643" style="zoom: 25%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非连通图遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Components</span><span class="params">(GraphLink *g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    <span class="type">bool</span> *visited = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * n);  <span class="comment">// visited数组指明当前顶点是否被访问过</span></span><br><span class="line">    assert(visited != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            DFS(g, i, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、最小生成树（Minimum-Spanning-Tree-MST）"><a href="#2、最小生成树（Minimum-Spanning-Tree-MST）" class="headerlink" title="2、最小生成树（Minimum Spanning Tree, MST）"></a>2、最小生成树（Minimum Spanning Tree, MST）</h3><p>对于<code>n</code>个顶点，通过<code>n-1</code>条边进行连接，找到加权和最小的图。</p>
<h4 id="（1）Prim算法"><a href="#（1）Prim算法" class="headerlink" title="（1）Prim算法"></a>（1）<code>Prim</code>算法</h4><p>先找一条权值最小的边，然后从这两个顶点出发，依次找和这两个顶点连接的边中权值较小的，逐步扩散。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312281115869.png" alt="image-20231228111509756" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401030936983.png" alt="image-20240103093658857" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401030937827.png" alt="image-20240103093711759" style="zoom:67%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最小生成树_Prim算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MinSpanTree_Prim</span><span class="params">(GraphMtx *g, T vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;  <span class="comment">// 计算顶点个数</span></span><br><span class="line">    E *lowcost = (E*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E)*n);  <span class="comment">// lowcost[n]，最小花费的数组</span></span><br><span class="line">    <span class="type">int</span> *mst = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*n);  <span class="comment">// mst[n]，最小花费的起始顶点的数组</span></span><br><span class="line">    assert(lowcost != <span class="literal">NULL</span> &amp;&amp; mst != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、初始化lowcost</span></span><br><span class="line">    <span class="type">int</span> k = GetVertexPos(g, vertex);  <span class="comment">// 获取vertex的位置，作为初始的起始顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != k)</span><br><span class="line">        &#123;</span><br><span class="line">            lowcost[i] = GetWeight(g, k, i);  <span class="comment">// 获取从k到i的边的权重，lowcost[i]中i为终点顶点</span></span><br><span class="line">            mst[i] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            lowcost[i] = <span class="number">0</span>;  <span class="comment">// lowcost[i]=0 ==&gt; 顶点i属于MST的顶点集合</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、从初始起始顶点出发，寻找最小代价的边值</span></span><br><span class="line">    <span class="type">int</span> min, min_index;</span><br><span class="line">    <span class="type">int</span> begin, end;</span><br><span class="line">    E cost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历找到需要的n-1条边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)  <span class="comment">// n-1 ==&gt; n个顶点最多n-1条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        min = MAX_COST;</span><br><span class="line">        min_index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// （1）经过n次遍历，找到从vertex出发的一条权值最小的路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j]&lt;min)  </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// lowcost[j] != 0 ==&gt; 说明顶点j还未加入MST的顶点集合</span></span><br><span class="line">                min = lowcost[j];</span><br><span class="line">                min_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        begin = mst[min_index];</span><br><span class="line">        end = min_index;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;%c : %d\n&quot;</span>, g-&gt;VerticesList[begin], g-&gt;VerticesList[end], min);</span><br><span class="line">        </span><br><span class="line">        lowcost[min_index] = <span class="number">0</span>;  <span class="comment">// 将minx_index所代表的顶点加入MST顶点集合中，后续不再进行考虑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// （2）加入新顶点后，更新此时的lowcost和mst数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cost = GetWeight(g, min_index, j);</span><br><span class="line">            <span class="keyword">if</span>(cost &lt; lowcost[j])</span><br><span class="line">            &#123;</span><br><span class="line">                lowcost[j] = cost;  <span class="comment">// 顶点j到min_index对应顶点的权值比到之前保存的权值更小，因此更新权值</span></span><br><span class="line">                mst[j] = min_index;  <span class="comment">// 更新此时顶点j所对应的起始顶点为min_index对应顶点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（2）Kruskal算法"><a href="#（2）Kruskal算法" class="headerlink" title="（2）Kruskal算法"></a>（2）<code>Kruskal</code>算法</h4><p>每次找权值最小的边，但不关心此时顶点是否已与其他顶点相连。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312281115942.png" alt="image-20231228111533837" style="zoom:80%;" />

<p><strong>关键点：判断新加入的边是否可已有的边属于同一个连通子图。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断i和j是否处于同一连通子图</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_Same</span><span class="params">(<span class="type">int</span> *father, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从当前节点i开始层层追踪，直到找到其最后的父节点</span></span><br><span class="line">    <span class="comment">// father[i]==i说明i自己是一个单独的存在，没有和它连通的顶点</span></span><br><span class="line">    <span class="keyword">while</span>(father[i] != i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 否则，找到和它连通的顶点，并且层层寻找，直到找到最后一个不和其他顶点相连的顶点</span></span><br><span class="line">        <span class="comment">// 这样就追溯到了他的根节点</span></span><br><span class="line">        i = father[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(father[j] != j)</span><br><span class="line">    &#123;</span><br><span class="line">        j = father[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i==j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将i和j标记为相同集合</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mark_Same</span><span class="params">(<span class="type">int</span> *father, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(father[i] != i)</span><br><span class="line">    &#123;</span><br><span class="line">        i = father[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(father[j] != j)</span><br><span class="line">    &#123;</span><br><span class="line">        j = father[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    father[j] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MinSpanTree_Kruskal</span><span class="params">(GraphMtx *g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    Edge *edge = (Edge*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Edge) * (n*(n<span class="number">-1</span>)/<span class="number">2</span>));</span><br><span class="line">    assert(edge != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化edge结构</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查找邻接矩阵的上三角矩阵，避免重复查找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 顶点间的边存在时，初始化edge结构体</span></span><br><span class="line">            <span class="keyword">if</span>(g-&gt;Edge[i][j] != <span class="number">0</span> &amp;&amp; g-&gt;Edge[i][j] != MAX_COST)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[k].x = i;</span><br><span class="line">                edge[k].y = j;</span><br><span class="line">                edge[k].cost = g-&gt;Edge[i][j];</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;k; ++i)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     v1 = edge[i].x;</span></span><br><span class="line">    <span class="comment">//     v2 = edge[i].y;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%c--&gt;%c : %d\n&quot;, g-&gt;VerticesList[v1], g-&gt;VerticesList[v2], edge[i].cost);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将边按照权值升序排序</span></span><br><span class="line">    qsort(edge, k, <span class="keyword">sizeof</span>(Edge), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法核心，判断新加入的边是否可已有的边属于同一个连通子图</span></span><br><span class="line">    <span class="type">int</span> *father = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) *n);</span><br><span class="line">    assert(father != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i] = i;  <span class="comment">// 初始化i的父节点为i自己</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当x与y的父节点不为同一个父节点时，进行连接</span></span><br><span class="line">        <span class="keyword">if</span>(!Is_Same(father, edge[i].x, edge[i].y))</span><br><span class="line">        &#123;</span><br><span class="line">            v1 = edge[i].x;</span><br><span class="line">            v2 = edge[i].y;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;%c : %d\n&quot;</span>, g-&gt;VerticesList[v1], g-&gt;VerticesList[v2], edge[i].cost);</span><br><span class="line">            Mark_Same(father, edge[i].x, edge[i].y);  <span class="comment">// 连接x和y后，将其标记为Same，合并为一个整体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一般来说，两个算法得到的最小生成树唯一。权值相同时可能形状存在差异，但加权和一定一致。</strong></p>
<h2 id="7-5-有向无环图（Directed-Acyclic-Graph-DAG）"><a href="#7-5-有向无环图（Directed-Acyclic-Graph-DAG）" class="headerlink" title="7.5 有向无环图（Directed Acyclic Graph, DAG）"></a>7.5 有向无环图（Directed Acyclic Graph, DAG）</h2><p><code>DAG</code>图是描述含有公共子式的表达式的有效工具。</p>
<ul>
<li><p><code>AOV（Activity On Vertex）</code>：以顶点为活动的网络图</p>
</li>
<li><p><code>AOE（Activity On Edge）</code>：以边为活动的网络图</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401071525659.png" alt="image-20240107152528272"></p>
<h3 id="1、拓扑排序（Topological-Sort）"><a href="#1、拓扑排序（Topological-Sort）" class="headerlink" title="1、拓扑排序（Topological Sort）"></a>1、拓扑排序（<code>Topological Sort</code>）</h3><p><strong>定义</strong>：由某个集合上的一个偏序得到该集合上的一个全序，这个操作称为拓扑排序。（<code>AOV</code>）</p>
<blockquote>
<p><strong>步骤：</strong></p>
<p><strong>s1、先找到一个没有入度的顶点，放入排序中；</strong></p>
<p><strong>s2、删除该顶点和与其相关的边，此时各顶点的入度改变；</strong></p>
<p><strong>s3、重复s1和s2，直至不存在顶点未被排序。</strong></p>
</blockquote>
<p><strong>关键实现</strong>：</p>
<ul>
<li>建立一个栈结构，保存顶点及其入度相关的信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TopologicalSort</span><span class="params">(GraphLink *g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;  <span class="comment">// 顶点个数</span></span><br><span class="line">    <span class="type">int</span> *count = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*n);  <span class="comment">// 初始化count数组，存储顶点及其入度信息</span></span><br><span class="line">    assert(count != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        count[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计入度信息</span></span><br><span class="line">    Edge *p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = g-&gt;NodeTable[i].adj;  <span class="comment">// p指向存放当前顶点边信息的邻接表</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count[p-&gt;dest]++;  <span class="comment">// 在count数组中，对应有入度的顶点位置++</span></span><br><span class="line">            p = p-&gt;link;  <span class="comment">// p指向下一个顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;n; ++i)</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\n&quot;, count[i]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历count，找到所有入度为0的顶点，并存入栈中</span></span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;  <span class="comment">// 所谓的“栈顶指针”</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若该顶点入度为0</span></span><br><span class="line">        <span class="keyword">if</span>(count[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 模拟入栈</span></span><br><span class="line">            count[i] = top;  <span class="comment">// count[i]保存了上一个入度为0的顶点的下标   </span></span><br><span class="line">            top = i;  <span class="comment">// top指向顶点i（即入度为0的栈顶元素）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v, w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(top == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;网络中有回路，无法进行拓扑排序！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 模拟出栈</span></span><br><span class="line">            v = top;  <span class="comment">// v指向栈顶元素（即此时度为0的顶点）</span></span><br><span class="line">            top = count[top];  <span class="comment">// 相当于出栈顶点v的操作</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;&quot;</span>, g-&gt;NodeTable[v]);</span><br><span class="line">            <span class="comment">// 求解v的邻接顶点</span></span><br><span class="line">            w = GetFirstNeighbor(g, g-&gt;NodeTable[v].data);</span><br><span class="line">            <span class="keyword">while</span>(w != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 删去对应的边后若入度为0，则对顶点w进行入栈操作</span></span><br><span class="line">                <span class="keyword">if</span>(--count[w] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 入栈</span></span><br><span class="line">                    count[w] = top;</span><br><span class="line">                    top = w;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则不进行入栈操作，寻找下一个邻接顶点</span></span><br><span class="line">                w = GetNextNeighbor(g, g-&gt;NodeTable[v].data, g-&gt;NodeTable[w].data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Nul.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、关键路径求解（Critical-Path）"><a href="#2、关键路径求解（Critical-Path）" class="headerlink" title="2、关键路径求解（Critical Path）"></a>2、关键路径求解（Critical Path）</h3><p><strong>定义</strong>：由于在<code>AOE</code>网中有些活动可以并行地进行，所以完成工程的最短时间是从开始点到完成点的最长路径的长度，路径长度最长的路径叫做关键路径。（这里的路径长度指路径上各活动的持续时间之和）</p>
<blockquote>
<p><strong>步骤：</strong></p>
<p><strong>s1、先正向求解每个顶点的最早开始时间；</strong></p>
<p><strong>s2、再反向求解每个顶点的最晚开始时间。</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求解关键路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CriticalPath</span><span class="params">(GraphMtx *g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    <span class="type">int</span> *ve = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    <span class="type">int</span> *vl = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    assert(ve != <span class="literal">NULL</span> &amp;&amp; vl != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ve[i] = <span class="number">0</span>;</span><br><span class="line">        vl[i] = MAX_COST;  <span class="comment">// 此处不能初始化为0，否则求解vl时会出现负数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正向求解每个顶点的最早开始时间，ve</span></span><br><span class="line">    <span class="comment">// 实际上这个步骤相当于在初始化最早开始时间</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        对最早开始时间的理解：</span></span><br><span class="line"><span class="comment">            假设此时有一条边从v指向w，</span></span><br><span class="line"><span class="comment">            v的最早开始时间为t1，w的最早开始时间为t2，边v-&gt;w的权值为cost，</span></span><br><span class="line"><span class="comment">            若t1+cost&gt;t2，则更新t2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> j, w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        j = GetFirstNeighbor(g, g-&gt;VerticesList[i]);  <span class="comment">// 指向i的第一个邻接顶点</span></span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            w = GetWeight(g, i, j);  <span class="comment">// 获取边i-&gt;j的权值</span></span><br><span class="line">            <span class="keyword">if</span>((ve[i] + w) &gt; ve[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ve[j] = ve[i] + w;</span><br><span class="line">            &#125;</span><br><span class="line">            j = GetNextNeighbor(g, g-&gt;VerticesList[i], g-&gt;VerticesList[j]);  <span class="comment">// 获取下一个邻接顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;n; ++i)</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\t&quot;, ve[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向求解每个顶点的最晚开始时间，vl</span></span><br><span class="line">    <span class="comment">// 实际上这个步骤相当于在初始化最晚开始时间</span></span><br><span class="line">    <span class="comment">// 最晚开始时间：如果从顶点i到顶点j存在多条路径，则最长时间的那条路径A为关键路径，而小于最长时间的其他路径可以在A开始后一段时间再进行</span></span><br><span class="line">    vl[n<span class="number">-1</span>] = ve[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>; i&gt;<span class="number">0</span>; --i)  <span class="comment">// 从倒数第二个顶点开始往前遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        j = GetFirstNeighbor(g, g-&gt;VerticesList[i]);  <span class="comment">// 指向i的第一个邻接顶点</span></span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            w = GetWeight(g, i, j);</span><br><span class="line">            <span class="comment">// 若步骤j的最晚开始时间（vl[j]）减去活动(i, j)的时间（w）小于步骤i的最晚开始时间（vl[i]），更新vl[i]</span></span><br><span class="line">            <span class="comment">// 因为说明此时活动(i, j)的持续时间要长于原先走的那条路径，所以要进行更新</span></span><br><span class="line">            <span class="comment">// 也就是说，应该选择更小的时间</span></span><br><span class="line">            <span class="keyword">if</span>((vl[j] - w) &lt; vl[i])  </span><br><span class="line">            &#123;</span><br><span class="line">                vl[i] = vl[j] - w;</span><br><span class="line">            &#125;</span><br><span class="line">            j = GetNextNeighbor(g, g-&gt;VerticesList[i], g-&gt;VerticesList[j]);  <span class="comment">// 获取下一个邻接顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;n; ++i)</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\t&quot;, vl[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> Ae, Al;  <span class="comment">// 活动的最早开始时间和最晚开始时间，这里的A代表边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        j = GetFirstNeighbor(g, g-&gt;VerticesList[i]);  <span class="comment">// 指向i的第一个邻接顶点</span></span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Ae = ve[i];  <span class="comment">// 活动的最早开始时间</span></span><br><span class="line">            Al = vl[j] - GetWeight(g, i, j);  <span class="comment">// 有点没太理解这一行</span></span><br><span class="line">            <span class="comment">// vl[j]是顶点j代表该步骤的最晚开始时间，边ij的权重是从完成步骤i所需的时间</span></span><br><span class="line">            <span class="comment">// vl[j] - GetWeight(g, i, j)即代表活动j的最晚开始时间</span></span><br><span class="line">            <span class="keyword">if</span>(Ae == Al)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 说明i和j是关键路径上的两个顶点</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;%c, %c&gt;是关键路径.\n&quot;</span>, g-&gt;VerticesList[i], g-&gt;VerticesList[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            j = GetNextNeighbor(g, g-&gt;VerticesList[i], g-&gt;VerticesList[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ve);</span><br><span class="line">    <span class="built_in">free</span>(vl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-6-最短路径"><a href="#7-6-最短路径" class="headerlink" title="7.6 最短路径"></a>7.6 最短路径</h2><p><strong>从某个源点到其余各个顶点的最短路径</strong></p>
<p><strong><code>Dijkstra</code>算法</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401081053558.png" alt="image-20240108105354193" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401081055708.png" alt="image-20240108105532557" style="zoom: 50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// diskstra算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath</span><span class="params">(GraphMtx *g, T vertex, E dist[], <span class="type">int</span> path[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;  <span class="comment">// 记录顶点个数</span></span><br><span class="line">    <span class="type">bool</span> *S = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>)*n);  <span class="comment">// 已找到从vertex出发的最短路径的终点的集合</span></span><br><span class="line">    assert(S != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v = GetVertexPos(g, vertex);  <span class="comment">// 得到vertex的下标位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dist[i] = GetWeight(g, v, i);  <span class="comment">// 获取顶点vertex到其余各顶点对应的权值，初始化dist</span></span><br><span class="line">        S[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(i != v &amp;&amp; dist[i] &lt; MAX_COST)</span><br><span class="line">        &#123;</span><br><span class="line">            path[i] = v;  <span class="comment">// 若vertex和顶点i有边（方向为vertex-&gt;i），则初始化其起始点为vertex</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            path[i] = <span class="number">-1</span>;  <span class="comment">// 否则初始化其起始点为-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    S[v] = <span class="literal">true</span>;  <span class="comment">// 代表顶点vertex已经加入集合</span></span><br><span class="line">    <span class="type">int</span> min, w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)  <span class="comment">// n-1是因为起始点已经定为vertex了</span></span><br><span class="line">    &#123;</span><br><span class="line">        min = MAX_COST;  <span class="comment">// 初始化最小花费为最大代价</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在本次循环中找到花费最小的路径&lt;i, j&gt;，并用顶点u记录这个顶点j方便后续处理</span></span><br><span class="line">        <span class="type">int</span> u = v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!S[j] &amp;&amp; dist[j] &lt; min)  <span class="comment">// !S[j] --&gt; 未加入集合</span></span><br><span class="line">            &#123;</span><br><span class="line">                u = j;  <span class="comment">// 记录当前顶点</span></span><br><span class="line">                min = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        S[u] = <span class="literal">true</span>;  <span class="comment">// 加入顶点u</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从顶点u出发，更新从u出发到达其他顶点的dist对应的权重</span></span><br><span class="line">        <span class="comment">// 相当于更新dist数组，以便进入下一次循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            w = GetWeight(g, u, k);  <span class="comment">// 顶点u到其余顶点的权值</span></span><br><span class="line">            <span class="keyword">if</span>(!S[k] &amp;&amp; w &lt; MAX_COST &amp;&amp; (dist[u]+w)&lt;dist[k])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[k] = dist[u] + w;</span><br><span class="line">                path[k] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d--&gt;&quot;</span>, path[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Nul.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d--&gt;&quot;</span>, dist[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Nul.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-查找"><a href="#8-查找" class="headerlink" title="8 查找"></a>8 查找</h1><p><strong>查找表</strong>（<code>Search Table</code>）：由同一类型的数据元素（或记录）构成的集合。</p>
<h2 id="8-1-静态查找表"><a href="#8-1-静态查找表" class="headerlink" title="8.1 静态查找表"></a>8.1 静态查找表</h2><h2 id="8-2-动态查找表"><a href="#8-2-动态查找表" class="headerlink" title="8.2 动态查找表"></a>8.2 动态查找表</h2><p><strong>定义</strong>：表结构本身是在查找过程中动态生成的。即对于给定key值，若表中存在关键字等于key值的记录，则查找成功返回；否则插入关键字等于key的记录。</p>
<h3 id="1、二叉排序树（Binary-Sort-Tree）"><a href="#1、二叉排序树（Binary-Sort-Tree）" class="headerlink" title="1、二叉排序树（Binary Sort Tree）"></a>1、二叉排序树（Binary Sort Tree）</h3><p>二叉排序树又称二叉搜索树。</p>
<p><strong>定义</strong>：</p>
<ul>
<li>（1）若左子树非空，则左子树上的所有结点的值小于根节点的值；</li>
<li>（2）若右子树非空，则右子树上的所有结点的值大于根节点的值；</li>
<li>（3）左、右子树分别也为二叉排序树。</li>
</ul>
<h3 id="2、平衡二叉树（Balanced-Binary-Tree-Height-Balanced-Tree）"><a href="#2、平衡二叉树（Balanced-Binary-Tree-Height-Balanced-Tree）" class="headerlink" title="2、平衡二叉树（Balanced Binary Tree&#x2F;Height-Balanced Tree）"></a>2、平衡二叉树（Balanced Binary Tree&#x2F;Height-Balanced Tree）</h3><p>平衡二叉树的前提是这棵树为二叉搜索树。</p>
<p><strong>平衡</strong>：左右子树的深度之差绝对值不大于1。</p>
<p><strong>平衡因子</strong><code>BF(Balanced Factor)</code>：该结点的右子树的深度减去其左子树的深度。</p>
<blockquote>
<p>深度：从根节点数到它的叶节点；</p>
<p>⾼度：从叶节点数到它的根节点</p>
</blockquote>
<p><strong>处理方法</strong>：旋转时结点的处理顺序是从<strong>第一个不平衡的结点</strong>开始。</p>
<ul>
<li>单旋转：不平衡的结点处于同一直线<ul>
<li>左旋转</li>
<li>右旋转</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401191222815.png" alt="image-20240119122225757" style="zoom: 25%;" />

<ul>
<li>双旋转：不平衡的结点处于折线状态<ul>
<li>先左后右（针对向左突出，＜）</li>
<li>先右后左（针对向右突出，＞）</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401191600972.png" alt="image-20240119160055303" style="zoom:25%;" />

<p>删除结点：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401211202772.png" alt="image-20240121120204211"></p>
<h3 id="3、哈希表"><a href="#3、哈希表" class="headerlink" title="3、哈希表"></a>3、哈希表</h3><p><strong>定义：</strong></p>
<p>根据设定的哈希函数<code>H(key)</code>和处理冲突的方法将一组关键字映像到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置。这一映像过程称为<strong>哈希表</strong>或<strong>散列</strong>，所得存储位置称哈希地址或散列地址。</p>
<p><strong>关键问题：</strong></p>
<p>1、创建哈希函数；</p>
<ul>
<li><strong>除留余数法</strong>；（使用最广泛）</li>
</ul>
<p>2、解决哈希冲突。</p>
<ul>
<li><strong>链地址法</strong>；（使用最广泛，相当于顺序表+链表）</li>
</ul>
<p><strong>溢出表算法（公司面试题）</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401231117485.png" alt="image-20240123111749039"></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401231307889.png" alt="image-20240123130752821" style="zoom: 25%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init_bucket_node</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;P; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;BUCKET_NODE_SIZE; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            hash_table[i].data[j] = NULL_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">        hash_table[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Insert_new_element</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="built_in">Hash</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;BUCKET_NODE_SIZE; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hash_table[index].data[i] == NULL_DATA)</span><br><span class="line">        &#123;</span><br><span class="line">            hash_table[index].data[i] = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 溢出桶有空余，直接插入</span></span><br><span class="line">    bucket_node *p = &amp;hash_table[index];</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;BUCKET_NODE_SIZE; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data[i] == NULL_DATA)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;data[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不存在有空余的溢出桶，则新建一个</span></span><br><span class="line">    bucket_node *s = (bucket_node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(bucket_node));</span><br><span class="line">    <span class="built_in">assert</span>(s != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;BUCKET_NODE_SIZE; ++i)</span><br><span class="line">        s-&gt;data[i] = NULL_DATA;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    s-&gt;data[<span class="number">0</span>] = x;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-排序"><a href="#9-排序" class="headerlink" title="9 排序"></a>9 排序</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><p>线性&#x2F;非线性数据结构和排序都是为了最终的查找服务的。</p>
<p><strong>排序方法的稳定与否是针对相同的关键字而言的。若相同的关键字在排序后次序无变化，则其是稳定的。</strong></p>
<p><strong>分类：</strong></p>
<ul>
<li>内部排序：数据量较小，所有的数据一次性全部放入<strong>内存</strong>进行。<ul>
<li><strong>插入排序（稳定排序）</strong></li>
<li><strong>交换排序</strong></li>
<li><strong>选择排序</strong></li>
<li><strong>归并排序</strong></li>
<li><strong>基数排序</strong></li>
</ul>
</li>
<li>外部排序：数据量过大，一部分数据在<strong>内存</strong>中先进行排序，其余的数据暂存在磁盘中。</li>
</ul>
<p><strong>基本方法：</strong></p>
<ul>
<li>比较两个关键字的大小；</li>
<li>将记录从一个位置移动至另一个位置。</li>
</ul>
<h2 id="9-2-插入排序"><a href="#9-2-插入排序" class="headerlink" title="9.2 插入排序"></a>9.2 插入排序</h2><p>插入排序（稳定排序）</p>
<h3 id="1、直接插入排序"><a href="#1、直接插入排序" class="headerlink" title="1、直接插入排序"></a>1、直接插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接插入排序 O(n^2)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T *a, T*b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void InsertSort(SqList &amp;L, int n)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    for(int i=1; i&lt;n; ++i)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(L[i] &lt; L[i-1])</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            Swap(&amp;L[i], &amp;L[i-1]);</span></span><br><span class="line"><span class="comment">            for(int j=i-1; j&gt;0 &amp;&amp; L[j]&lt;L[j-1]; --j)  // important</span></span><br><span class="line"><span class="comment">                Swap(&amp;L[j], &amp;L[j-1]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 改进</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] &lt; L[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            L[<span class="number">0</span>] = L[i];</span><br><span class="line">            L[i] = L[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> j = i<span class="number">-2</span>;            </span><br><span class="line">            <span class="keyword">while</span>(L[<span class="number">0</span>]&lt;L[j])</span><br><span class="line">            &#123;</span><br><span class="line">                L[j+<span class="number">1</span>] = L[j];</span><br><span class="line">                --j;</span><br><span class="line">            &#125;            </span><br><span class="line">            L[j+<span class="number">1</span>] = L[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、折半插入排序"><a href="#2、折半插入排序" class="headerlink" title="2、折半插入排序"></a>2、折半插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 折半插入排序 O(n^2)  -- 减少直接插入排序的关键字比较次数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BInsertSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        L[<span class="number">0</span>] = L[i];</span><br><span class="line">        <span class="type">int</span> low = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> high = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)  <span class="comment">// 折半插入，通过移动low/high找到该插入的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(L[<span class="number">0</span>] &gt;= L[mid])</span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&gt;high+<span class="number">1</span>; --j)  <span class="comment">// high+1是要插入L[0]的数值的位置，因此把high+1到i的值全部往后挪动一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            L[j] = L[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        L[high+<span class="number">1</span>] = L[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、2路插入排序"><a href="#3、2路插入排序" class="headerlink" title="3、2路插入排序"></a>3、2路插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2路插入排序  -- 减少折半插入排序的数据移动次数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TWayInsertSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList tmp;</span><br><span class="line">    tmp[<span class="number">0</span>] = L[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> head, tail;</span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; ++i)  <span class="comment">// L[i]是当前要插入tmp的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] &lt; tmp[head])  <span class="comment">// 若当前遍历到的L[i]小于head所指元素，则将L[i]插入到head的前一个位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = (head<span class="number">-1</span>+n) % n;  <span class="comment">// 取模操作实现循环操作</span></span><br><span class="line">            tmp[head] = L[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L[i] &gt; tmp[tail])  <span class="comment">// 同理，若当前遍历到的L[i]大于head所指元素，则将L[i]插入到head的后一个位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            tail++;</span><br><span class="line">            tmp[tail] = L[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 若tmp[head]&lt;L[i]&lt;tmp[tail]，则需要移动数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            tail++;</span><br><span class="line">            tmp[tail] = tmp[tail<span class="number">-1</span>];  <span class="comment">// 将tmp[tail]向后移动一个，并将tail本身的值加1</span></span><br><span class="line">            <span class="type">int</span> j = tail<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(L[i] &lt; tmp[(j<span class="number">-1</span>+n)%n])  <span class="comment">// L[i]&lt;tmp[(j-1+n)%n]，找到L[i]应该插入的地方，即tmp[j]</span></span><br><span class="line">                                          <span class="comment">// 由于这里的j的指向是循环的，所以(j-1+n)%n相当于j-1</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp[j] = tmp[(j<span class="number">-1</span>+n)%n];</span><br><span class="line">                j = (j<span class="number">-1</span>+n)%n;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp[j] = L[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        L[i] = tmp[head];</span><br><span class="line">        head = (head+<span class="number">1</span>)%n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、表插入排序"><a href="#4、表插入排序" class="headerlink" title="4、表插入排序"></a>4、表插入排序</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401241536655.png" alt="image-20240124153639775" style="zoom: 25%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表插入排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVALUE 0x7fffffff</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SLNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">    <span class="type">int</span> link;</span><br><span class="line">&#125;SLNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> SLNode Table[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableInsertSort</span><span class="params">(Table t, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[<span class="number">0</span>].link = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p, q;  <span class="comment">// q是p的前驱</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = t[<span class="number">0</span>].link;  <span class="comment">// p指向当前检索的值的下标，每一次都要从t[0].link指向的头开始排序</span></span><br><span class="line">        q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">0</span> &amp;&amp; t[p].data&lt;=t[i].data)  <span class="comment">// p!=0说明未检索完；t[p].data&lt;=t[i].data说明当前检索到的值小于等于要排序进来的值，所以要接着往下找更大的值</span></span><br><span class="line">        &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = t[p].link;  <span class="comment">// p指向下一个更大的值对应的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当退出循环时，t[p].data&gt;t[i].data，则i在p的前驱位置插入</span></span><br><span class="line">        t[i].link = t[q].link;</span><br><span class="line">        t[q].link = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、希尔排序"><a href="#5、希尔排序" class="headerlink" title="5、希尔排序"></a>5、希尔排序</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401251321618.png" alt="image-20240125132057065"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> n, <span class="type">int</span> dk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=dk+<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] &lt; L[i-dk])  <span class="comment">// 间隔两端的两个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            L[<span class="number">0</span>] = L[i];</span><br><span class="line">            <span class="type">int</span> j = i - dk;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; L[<span class="number">0</span>] &lt; L[j])</span><br><span class="line">            &#123;</span><br><span class="line">                L[j+dk] = L[j];  <span class="comment">// 在间隔上取的几个数之间进行直接插入排序，需要注意这里数之间的间隔是dk</span></span><br><span class="line">                j -= dk;</span><br><span class="line">            &#125;</span><br><span class="line">            L[j+dk] = L[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n, <span class="type">int</span> dlta[], <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;t; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShellInsert</span>(L, n, dlta[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-3-交换排序"><a href="#9-3-交换排序" class="headerlink" title="9.3 交换排序"></a>9.3 交换排序</h2><h3 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n<span class="number">-1</span>-i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L[j] &gt; L[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Swap</span>(&amp;L[j], &amp;L[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、快速排序"><a href="#2、快速排序" class="headerlink" title="2、快速排序"></a>2、快速排序</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401251320399.png" alt="image-20240125132023301" style="zoom: 25%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T pk = L[low];  <span class="comment">// 先指定L[low]为关键字</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; L[high]&gt;=pk)  <span class="comment">// 循环使得high指向小于枢轴的值</span></span><br><span class="line">            high--;</span><br><span class="line">        L[low] = L[high];  <span class="comment">// 将这个较小的L[high]值赋值给low所处的位置</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; L[low]&lt;pk)  <span class="comment">// 循环使得low指向大于枢轴的值</span></span><br><span class="line">            low++;</span><br><span class="line">        L[high] = L[low];  <span class="comment">// 将这个较大的L[low]值赋值给high所处的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    L[low] = pk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)  <span class="comment">// 未排序完成</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pkloc = <span class="built_in">Partition</span>(L, low, high);  <span class="comment">// 求枢轴关键字的位置</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(L, low, pkloc<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(L, pkloc+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-4-选择排序"><a href="#9-4-选择排序" class="headerlink" title="9.4 选择排序"></a>9.4 选择排序</h2><h3 id="1、简单选择排序"><a href="#1、简单选择排序" class="headerlink" title="1、简单选择排序"></a>1、简单选择排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SelectMinKey</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T minval = L[i];</span><br><span class="line">    <span class="type">int</span> pos = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m=i+<span class="number">1</span>; m&lt;n; ++m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[m] &lt; minval)</span><br><span class="line">        &#123;</span><br><span class="line">            minval = L[m];</span><br><span class="line">            pos = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="built_in">SelectMinKey</span>(L, i, n);  <span class="comment">// 找到最小值对应的下标位置</span></span><br><span class="line">        <span class="keyword">if</span>(j != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Swap</span>(&amp;L[j], &amp;L[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、树形选择排序"><a href="#2、树形选择排序" class="headerlink" title="2、树形选择排序"></a>2、树形选择排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 树形选择排序，相较于简单选择排序减少了比较次数（锦标赛排序）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVALUE 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">GetValue</span><span class="params">(T e[], <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p &gt;= n)</span><br><span class="line">        <span class="keyword">return</span> MAXVALUE;</span><br><span class="line">    </span><br><span class="line">    T value;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; n/<span class="number">2</span>)  <span class="comment">// 得到的是下标位置</span></span><br><span class="line">        value = e[e[p]];</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 否则为叶子节点，直接返回e[p]</span></span><br><span class="line">        value = e[p];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Play</span><span class="params">(T e[], <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> left, right;  <span class="comment">// 左右下标</span></span><br><span class="line">    T lval, rval;  <span class="comment">// 左右值</span></span><br><span class="line">    <span class="keyword">while</span>(p &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        left = <span class="number">2</span>*p+<span class="number">1</span>;</span><br><span class="line">        right = <span class="number">2</span>*p+<span class="number">2</span>;</span><br><span class="line">        lval = <span class="built_in">GetValue</span>(e, n, left);</span><br><span class="line">        rval = <span class="built_in">GetValue</span>(e, n, right);</span><br><span class="line">        <span class="keyword">if</span>(lval &lt;= rval)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &lt; n/<span class="number">2</span>)</span><br><span class="line">                e[p] = e[left];  <span class="comment">// important</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[p] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(right &lt; n/<span class="number">2</span>)</span><br><span class="line">                e[p] = e[right];  <span class="comment">// important</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[p] = right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        --p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select</span><span class="params">(T e[], <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = p;  <span class="comment">// 父节点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">2</span>*p+<span class="number">1</span>;  <span class="comment">// 左子树</span></span><br><span class="line">    T lval, rval;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; flag)</span><br><span class="line">    &#123;</span><br><span class="line">        lval = <span class="built_in">GetValue</span>(e, n, j);</span><br><span class="line">        rval = <span class="built_in">GetValue</span>(e, n, j+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(lval &lt;= rval)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; n/<span class="number">2</span>)</span><br><span class="line">                e[i] = e[j];  <span class="comment">// j&lt;n/2说明j的位置在非叶子节点的位置，所以对于j的父节点，需要的是位置j上存储的内容即e[j]</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[i] = j;  <span class="comment">// j&gt;=n/2说明j的位置在叶子节点的位置，所以对于j的父节点，需要的是就是位置j本身</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((j+<span class="number">1</span>) &lt; n/<span class="number">2</span>)</span><br><span class="line">                e[i] = e[j+<span class="number">1</span>];  <span class="comment">// 同上</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[i] = j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            flag--;</span><br><span class="line">        <span class="comment">// 向上递归，找到新的父节点和对应的左孩子</span></span><br><span class="line">        i = (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        j = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TreeSelectSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">    T *e = (T*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T) * size);</span><br><span class="line">    <span class="built_in">assert</span>(e != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = size / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        e[k++] = L[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> curpos = size/<span class="number">2</span><span class="number">-1</span>;  <span class="comment">// 树最后一个叶子分支的父节点，相当于要打的第一场比赛</span></span><br><span class="line">    <span class="built_in">Play</span>(e, size, curpos);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    L[i] = e[e[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将已经选出来的最小值的节点A，将其赋值为最大值，使其不参与后续的比较</span></span><br><span class="line">    e[e[<span class="number">0</span>]] = MAXVALUE;  </span><br><span class="line">    <span class="comment">// 从A的父节点开始一路向上比较，直到到达根节点，比较完毕</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        curpos = (e[<span class="number">0</span>]<span class="number">-1</span>)/<span class="number">2</span>;  <span class="comment">// A的父节点</span></span><br><span class="line">        <span class="built_in">Select</span>(e, size, curpos);</span><br><span class="line">        L[i] = e[e[<span class="number">0</span>]];</span><br><span class="line">        e[e[<span class="number">0</span>]] = MAXVALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(e);</span><br><span class="line">    e = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、堆排序"><a href="#3、堆排序" class="headerlink" title="3、堆排序"></a>3、堆排序</h3><p><strong>大堆</strong>：父节点大于左右孩子；</p>
<p><strong>小堆</strong>：父节点小于左右孩子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆排序，相较于树形选择排序辅助空间大幅减少，只需要1个辅助空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(T heap[], <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = p;  <span class="comment">// 父节点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">2</span>*i+<span class="number">1</span>;  <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; n)  <span class="comment">// 说明p有左孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;n<span class="number">-1</span> &amp;&amp; heap[j]&gt;heap[j+<span class="number">1</span>])  <span class="comment">// j&lt;n-1说明有右孩子，heap[j]&gt;heap[j+1]说明左孩子大于右孩子</span></span><br><span class="line">            j++;  <span class="comment">// j指向右孩子，也即是保证j指向左右孩子中较小的那个值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(heap[i] &lt;= heap[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Swap</span>(&amp;heap[i], &amp;heap[j]);</span><br><span class="line">            <span class="comment">// 继续递归，使得该函数从位置p一直遍历到叶子结点</span></span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T <span class="title">RemoveMinKey</span><span class="params">(T heap[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T key = heap[<span class="number">0</span>];</span><br><span class="line">    heap[<span class="number">0</span>] = heap[n];</span><br><span class="line">    <span class="built_in">siftDown</span>(heap, n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T *heap = (T*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T) * n);</span><br><span class="line">    <span class="built_in">assert</span>(heap != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        heap[i] = L[i];  <span class="comment">// 将原始数据拷贝到heap空间中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将heap调整为小堆</span></span><br><span class="line">    <span class="comment">// 1、找到最后一个分支节点，调用函数SiftDown后，目前的堆顶元素即为当前序列的最小值</span></span><br><span class="line">    <span class="type">int</span> curpos = n/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(curpos &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">siftDown</span>(heap, n, curpos);</span><br><span class="line">        curpos--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、取走堆顶元素后，依次用最后一个节点补上根节点（最小值），重新进行小堆排序并取堆顶元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        L[i] = <span class="built_in">RemoveMinKey</span>(heap, n-i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-5-归并排序"><a href="#9-5-归并排序" class="headerlink" title="9.5 归并排序"></a>9.5 归并排序</h2><p><strong>2-路归并排序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(SqList &amp;L, SqList &amp;TP, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left; i&lt;=right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        TP[i] = L[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s1 = left;</span><br><span class="line">    <span class="type">int</span> s2 = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = left;</span><br><span class="line">    <span class="keyword">while</span>(s1&lt;=mid &amp;&amp; s2&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(TP[s1] &lt;= TP[s2])</span><br><span class="line">            L[k++] = TP[s1++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L[k++] = TP[s2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s1 &lt;= mid)</span><br><span class="line">        L[k++] = TP[s1++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(s2&lt;=right)</span><br><span class="line">        L[k++] = TP[s2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(SqList &amp;L, SqList &amp;TP, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(L, TP, left, mid);</span><br><span class="line">    <span class="built_in">MergeSort</span>(L, TP, mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="built_in">Merge</span>(L, TP, left, mid, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-6-基数排序"><a href="#9-6-基数排序" class="headerlink" title="9.6 基数排序"></a>9.6 基数排序</h2><p>对数据的<strong>分配和收集</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401262157878.png" alt="image-20240126215723896"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基数排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getkey</span><span class="params">(T value, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">while</span>(k &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        key = value % <span class="number">10</span>;</span><br><span class="line">        value /= <span class="number">10</span>;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Distribute</span><span class="params">(SqList &amp;L, <span class="type">int</span> n, List (&amp;lt)[<span class="number">10</span>], <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>(&amp;lt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        key = <span class="built_in">getkey</span>(L[i], k);  <span class="comment">// 取得需要比对的位置上的值</span></span><br><span class="line">        <span class="built_in">push_back</span>(&amp;lt[key], L[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Collect</span><span class="params">(SqList &amp;L, List (&amp;lt)[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Node *p = lt[i].first-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L[k++] = p-&gt;data;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List list[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InitList</span>(&amp;list[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Distribute</span>(L, n, list, i);</span><br><span class="line">        <span class="built_in">Collect</span>(L, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>hexo相关报错</title>
    <url>/2023/07/30/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF/hexo%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="1、OpnSSL-SSL-read-Connection-was-reset-errno-10054"><a href="#1、OpnSSL-SSL-read-Connection-was-reset-errno-10054" class="headerlink" title="1、OpnSSL SSL_read: Connection was reset, errno 10054"></a>1、OpnSSL SSL_read: Connection was reset, errno 10054</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/hioomph/hioomph.github.io.git/&#x27;: OpnSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure>

<h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>一般是这是因为服务器的SSL证书没有经过第三方机构的签署，所以才报错</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>解除ssl验证后，再上传就OK了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2、Error-Spawn-failed"><a href="#2、Error-Spawn-failed" class="headerlink" title="2、Error: Spawn failed"></a>2、Error: Spawn failed</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error: Spawn failed</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (D:\blog\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">    at ChildProcess.emit (node:events:514:28)</span><br><span class="line">    at cp.emit (D:\blog\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">    at ChildProcess._handle.onexit (node:internal/child_process:291:12)</span><br></pre></td></tr></table></figure>

<h3 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h3><p>hexo的_config.yml配置里git仓库地址填写错误，应将https方式改成ssh方式</p>
<h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  # repository: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git  # https方式</span><br><span class="line">  repository: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git		  # ssh方式</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>报错信息</category>
      </categories>
  </entry>
  <entry>
    <title>vscode相关</title>
    <url>/2023/08/01/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF/vscode%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="1、-vscode连接阿里云如何免密？"><a href="#1、-vscode连接阿里云如何免密？" class="headerlink" title="1、 vscode连接阿里云如何免密？"></a>1、 vscode连接阿里云如何免密？</h1><h2 id="windows端："><a href="#windows端：" class="headerlink" title="windows端："></a><code>windows</code>端：</h2><p>1）在<code>cmd</code>中输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>

<p>在<code>c:\Users\用户名\\.ssh</code>下会生成私钥和公钥。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308021257775.png" alt="image-20230802125702563"></p>
<p>2）复制<code>id_rsa.pub</code>中的内容</p>
<span id="more"></span>

<h2 id="linux端："><a href="#linux端：" class="headerlink" title="linux端："></a><code>linux</code>端：</h2><p>1）输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>生成<code>linux</code>端的密钥，进入<code>/root/.ssh/id_rsa</code>路径下。</p>
<p>2）创建一个文件，名字叫<code>authorized_keys</code></p>
<p>3）把复制的<code>windows</code>公钥粘贴到<code>authorized_keys</code>中，保存退出</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308012055885.png" alt="Snipaste_2023-08-01_20-46-53"></p>
<h1 id="2、Linux环境使用VSCode调试简单C-代码"><a href="#2、Linux环境使用VSCode调试简单C-代码" class="headerlink" title="2、Linux环境使用VSCode调试简单C++代码"></a>2、Linux环境使用VSCode调试简单C++代码</h1><p>参考教程：<a href="https://blog.csdn.net/hypc9709/article/details/129413482?ops_request_misc=&request_id=&biz_id=102&utm_term=vscode%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-129413482.142%5Ev96%5Epc_search_result_base7&spm=1018.2226.3001.4187">Linux环境使用VSCode调试简单C++代码</a></p>
<h2 id="1）终端命令行进行编译、调试"><a href="#1）终端命令行进行编译、调试" class="headerlink" title="1）终端命令行进行编译、调试"></a>1）终端命令行进行编译、调试</h2><h2 id="2）通过VSCode进行编译、调试"><a href="#2）通过VSCode进行编译、调试" class="headerlink" title="2）通过VSCode进行编译、调试"></a>2）通过VSCode进行编译、调试</h2><h3 id="（1）前置条件"><a href="#（1）前置条件" class="headerlink" title="（1）前置条件"></a>（1）前置条件</h3><p>插件<code>C/C++</code>已安装；<code>g++编译器</code>和<code>gdb调试器</code>已安装。</p>
<h3 id="（2）配置tasks-json"><a href="#（2）配置tasks-json" class="headerlink" title="（2）配置tasks.json"></a>（2）配置<code>tasks.json</code></h3><ul>
<li><p>在<code>VSCode</code>的主菜单中，选择<code>Terminal&gt;Configure Default Build Task</code></p>
</li>
<li><p>出现一个下拉菜单，显示<code>C++</code>编译器的各种预定义编译任务。选择<code>C/C++: g++ build active file</code>（如果配置了中文，会显示<code>C/C++: g++ 生成活动文件</code>）</p>
</li>
<li><p>选择后，<code>VSCode</code>会自动生成一个<code>.vscode</code>文件夹和<code>tasks.json</code>文件，如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312071610116.png" alt="image-20231207144919415"></p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++ 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/g++&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>tasks.json</code>的作用是告诉<code>VSCode</code>如何编译程序，因此从其中的<code>Command</code>和<code>args</code>可以看出，实际上是执行了以下命令：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/usr/bin/g++ -g $&#123;file&#125; -o $&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li><code>$&#123;file&#125;</code>：当前活动文件是<code>VSCode</code>当前查看的文件，如<code>Main.cpp</code>；</li>
<li><code>$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;</code>：用于获取当前文件的目录和不包含扩展名的文件名，如<code>Main</code>。</li>
</ul>
<h3 id="（3）执行编译"><a href="#（3）执行编译" class="headerlink" title="（3）执行编译"></a>（3）执行编译</h3><ul>
<li><p><strong>回到需要执行编译的文件</strong>（这一步很重要，否则<code>\$&#123;file&#125;</code>和<code>$&#123;fileDirname&#125;</code>这些变量都会错）；</p>
</li>
<li><p>快捷键<code>ctrl+shift+B</code>或从菜单中选择运行：<strong>Terminal -&gt; Run Build Task</strong>，即可执行<code>tasks.json</code>中指定的编译过程；</p>
<p>编译任务完成后，会出现终端提示，对于成功的g++编译，输出如下：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312071609602.png" alt="image-20231207150223290"></p>
<p>（这里我将<code>tasks.json</code>中的<code>&quot;$&#123;file&#125;&quot;</code>项更改为<code>&quot;$&#123;fileDirname&#125;/*.cpp&quot;</code></p>
<h3 id="（4）调试文件"><a href="#（4）调试文件" class="headerlink" title="（4）调试文件"></a>（4）调试文件</h3><p>对需要调试的文件设置断点，选择<code>Debug C/C++ file</code>进行调试。</p>
<h3 id="（5）个性化配置launch-json"><a href="#（5）个性化配置launch-json" class="headerlink" title="（5）个性化配置launch.json"></a>（5）个性化配置<code>launch.json</code></h3><blockquote>
<p>这里<code>launch.json</code>的作用就是告诉<code>VSCode</code>如何调用<code>gdb调试器</code>。</p>
</blockquote>
<p>如果想要在调试&#x2F;运行程序时添加参数，只需要把参数添加在<code>&quot;args&quot;</code>选项中即可。</p>
<h4 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h4><p>在<code>VSCode</code>中编译、调试一个简单的<code>.cpp</code>文件，所需要做的就是：</p>
<ol>
<li>在<code>tasks.json</code>中调用<code>g++</code>生成一个可执行二进制文件；</li>
<li>在<code>launch.json</code>中调用<code>gdb</code>对生成的可执行文件进行调试。</li>
</ol>
<h3 id="（7）复用C-配置"><a href="#（7）复用C-配置" class="headerlink" title="（7）复用C++配置"></a>（7）复用C++配置</h3><p>上面的过程已经完成了在<code>VSCode</code>中调试<code>Linux</code>环境下的<code>C++</code>代码的配置，但只适用于当前工作空间。</p>
<p>如果想要在其他的工程文件夹下复用这种配置，只需要把<code>tasks.json</code>和<code>launch.json</code>文件复制到新文件夹下的<code>.vscode</code>目录下，然后根据需要改变对应的源文件和可执行文件的名称即可。</p>
<h1 id="3、VSCode自动生成头文件的-ifndef-define-endif"><a href="#3、VSCode自动生成头文件的-ifndef-define-endif" class="headerlink" title="3、VSCode自动生成头文件的 #ifndef #define #endif"></a>3、VSCode自动生成头文件的 #ifndef #define #endif</h1><p>参考这篇博客：<a href="https://blog.csdn.net/p1279030826/article/details/123851420">VSCode自动生成头文件的 #ifndef #define #endif</a></p>
]]></content>
      <categories>
        <category>报错信息</category>
      </categories>
  </entry>
  <entry>
    <title>C++扩展知识</title>
    <url>/2023/10/08/code%E7%9B%B8%E5%85%B3/C++/c++%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="1、int-p-a、p-a、-p-a的正确理解"><a href="#1、int-p-a、p-a、-p-a的正确理解" class="headerlink" title="1、int *p &#x3D; &amp;a、p &#x3D; &amp;a、*p &#x3D; a的正确理解"></a>1、int *p &#x3D; &amp;a、p &#x3D; &amp;a、*p &#x3D; a的正确理解</h2><p>1、指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;a; <span class="comment">// 初始化一个int *类型指针，同时将变量a的地址存入p指针</span></span><br></pre></td></tr></table></figure>

<p>这里是一个<strong>特殊用法，仅在初始化变量的时候可以使用</strong>，应分为两个部分去进行理解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p;	<span class="comment">// 初始化一个int * 类型指针p</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p = &amp;a; <span class="comment">// 将变量a的地址存入p指针，此时p表示变量a的地址</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*p = a; <span class="comment">// 表示指针p指向变量a，这时*p表示变量a的数值</span></span><br></pre></td></tr></table></figure>

<p><em>注：区别在于在指针中p表示一个地址，存储的是变量的位置。</em></p>
<p>  <code>*p</code>表示一个变量，存储的是一个值。在初始化变量之外使用<code>*p = &amp;a;</code>是错误的，提示不能将<code>int *</code>类型的值分配到<code>int</code>类型的实体。<br>2、引用</p>
<p>  同时在<code>C++</code>中存在引用方法，引用和指针的差异在引用绑定后不可更改绑定对象，指针可以更改指向对象。<br>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> m = <span class="number">3</span>;  <span class="comment">// 定义一个int类型变量m</span></span><br><span class="line"><span class="type">int</span> &amp;r = m; <span class="comment">// 定义引用r表示变量m，后续所有的r都可以作为m来使用，改变r的值会同步修改m</span></span><br></pre></td></tr></table></figure>

<p>相当于把<code>m</code>的地址赋给<code>r</code>，此时两个变量地址是相同的内容。<br>注：引用使用的时候需要进行初始化，指针可以不用初始化。</p>
<p>未初始化的指针可以编译通过，但可能造成野指针问题。</p>
<p>3、野指针</p>
<p>  野指针常出现在空间分配当中，例如在调用的函数中声明了返回地址类型的变量，但是由于声明的位置是在小的空间域当中，因此在调用下一个函数的时候会造成声明处于栈内存中的局部变量被析构掉，最终<strong>只有第一次使用的是正确的数值，第二个函数调用后就默认指向随机位置，获取到的值也是随机获取数值</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int *testa()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	int a = 3;</span></span><br><span class="line"><span class="comment">// 	return &amp;a;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 上述代码产生报错：warning: address of local variable ‘a’ returned [-Wreturn-local-addr]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">testa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *temp = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">	*temp = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *num = <span class="built_in">testa</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;第一次函数调用的数值是：&quot;</span> &lt;&lt; *num &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;第二次函数调用的数值是：&quot;</span> &lt;&lt; *num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2、ifndef"><a href="#2、ifndef" class="headerlink" title="2、ifndef"></a>2、ifndef</h2><p>​		<code>#ifndef</code> 是<code>&quot;if not defined&quot;</code>的简写，是预处理功能（宏定义、文件包含、条件编译）当中的条件编译，在实际开发中可以用于做<code>test</code>或者不同版本的不同适配。<br> 在<code>vscode</code>中可以通过<code>json</code>脚本的<code>define</code>来定义<code>ifndef</code>的值，或者在通过<code>gcc</code>编译的时候添加上宏来进行条件编译。</p>
<p>​		<code>ifndef</code>可以根据是否已经定义了一个变量来进行分支选择，其作用是：</p>
<pre><code>1. 防止头文件的重复包含和编译；
2. 便于程序的调试和移植；
</code></pre>
<p>一般格式是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> <span class="string">&lt;标识&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> <span class="string">&lt;标识&gt;</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>**&lt;标识&gt;**在理论上来说是可以自由命名的，但每个头文件的这个“标识”都应该是唯一的。标识的明明规则一般是头文件名全大写，前面加下划线，并把文件名中的<code>.</code>也变成下划线，如：<code>stdio.h</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _STDIO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _STDIO_H</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>注意：<code>#ifndef</code>起到的效果是防止一个源文件多次包含同一个头文件，而不是防止两个源文件包含同一个头文件。事实上，防止同一头文件被两个不同的源文件包含这种要求本身就是不合理的，头文件存在的价值就是被不同的源文件包含。</p>
<h2 id="3、判断字符、数字以及大小写转换函数"><a href="#3、判断字符、数字以及大小写转换函数" class="headerlink" title="3、判断字符、数字以及大小写转换函数"></a>3、判断字符、数字以及大小写转换函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">islower</span>(<span class="type">char</span> c) <span class="comment">// 是否为小写字母</span></span><br><span class="line"><span class="built_in">isupper</span>(<span class="type">char</span> c) <span class="comment">// 是否为大写字母</span></span><br><span class="line"><span class="built_in">isdigit</span>(<span class="type">char</span> c) <span class="comment">// 是否为数字</span></span><br><span class="line"><span class="built_in">isalpha</span>(<span class="type">char</span> c) <span class="comment">// 是否为字母</span></span><br><span class="line"><span class="built_in">isalnum</span>(<span class="type">char</span> c) <span class="comment">// 是否为字母或者数字</span></span><br><span class="line"><span class="built_in">toupper</span>(<span class="type">char</span> c) <span class="comment">// 字母小转大</span></span><br><span class="line"><span class="built_in">tolower</span>(<span class="type">char</span> c) <span class="comment">// 字母大转小</span></span><br></pre></td></tr></table></figure>

<h2 id="4、顶层const和底层const"><a href="#4、顶层const和底层const" class="headerlink" title="4、顶层const和底层const"></a>4、顶层const和底层const</h2><p>指针本身是一个对象，它又可以指向另一个对象，因此，指针是不是常量以及指针所指的对象是不是一个常量是两个独立的问题。</p>
<p><code>顶层const</code>表示指针本身是一个常量，不能改变，不能指向其他对象。<code>底层const</code>表示指针所指的对象是一个常量，该对象的值不能改变。</p>
<p>更一般的，<code>顶层const</code>可以表示任意的对象是常量，对任何的数据类型都适用。<code>底层const</code>则与指针和引用等复合类型的基本类型有关。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i;    		<span class="comment">// 不能改变p1的值，是一个顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>;     		<span class="comment">// 不能改变ci的值，是一个顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci;   		<span class="comment">// 允许改变p2的值，是一个底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2;	<span class="comment">// 靠右的const是顶层const，靠左的是底层const</span></span><br></pre></td></tr></table></figure>

<h2 id="5、string的size类型为什么是string-size-t而不是int"><a href="#5、string的size类型为什么是string-size-t而不是int" class="headerlink" title="5、string的size类型为什么是string::size_t而不是int"></a>5、string的size类型为什么是string::size_t而不是int</h2><p><code>std::string</code> 的 <code>size</code> 类型被定义为 <code>string::size_t</code> 而不是 <code>int</code>，是为了提高通用性和可移植性。这是因为字符串的大小（长度）可能非常大，而 <code>int</code> 类型的范围是有限的，因此可能无法表示所有可能的字符串大小。</p>
<p><code>string::size_t</code> 是一个无符号整数类型，通常被定义为一个足够大的整数，以便可以容纳字符串的任何合法大小。它的大小通常与系统架构和编译器有关，但通常足够大以容纳大多数字符串的长度。</p>
<p>使用 <code>string::size_t</code> 而不是 <code>int</code> 有以下几个好处：</p>
<ol>
<li><strong>能够表示更大的字符串：</strong> 无符号整数类型 <code>size_t</code> 可以容纳比 <code>int</code> 更大的值，这对于处理非常大的字符串是必要的。</li>
<li><strong>提高可移植性：</strong> 使用 <code>string::size_t</code> 可以确保代码在不同的平台上具有相同的行为，因为 <code>size_t</code> 的大小会根据平台而变化，而不是固定的。</li>
<li><strong>避免符号问题：</strong> <code>size_t</code> 是无符号类型，避免了符号整数的问题，如溢出等。</li>
</ol>
<p>综上所述，使用 <code>string::size_t</code> 作为字符串大小的类型是一种良好的设计选择，可以确保代码能够处理各种大小的字符串，并提高了代码的可移植性。如果你需要与其他整数类型进行比较，你可以将 <code>size_t</code> 强制类型转换为 <code>int</code> 或其他整数类型。</p>
<h2 id="6、typedef函数"><a href="#6、typedef函数" class="headerlink" title="6、typedef函数"></a>6、typedef函数</h2><p>四种常见用法：</p>
<p>1）给已定义的变量类型起个别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">① </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;       </span><br><span class="line"><span class="comment">// uint8_t就是unsigned char的别名，这是最基础的用法</span></span><br><span class="line"></span><br><span class="line">②</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>    name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">uint8_t</span> age;</span><br><span class="line">    <span class="type">uint8_t</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> __person <span class="type">person_t</span>;</span><br><span class="line"><span class="comment">// 以上两段代码也可合并为一段，如下：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>    name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">uint8_t</span> age;</span><br><span class="line">    <span class="type">uint8_t</span> height;</span><br><span class="line">&#125;<span class="type">person_t</span>;</span><br><span class="line"><span class="comment">// 给struct  __person起了个别名person_t</span></span><br></pre></td></tr></table></figure>

<p>2）定义函数指针类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义函数指针变量</span></span><br><span class="line"><span class="built_in">int</span> (*pFunc)(<span class="type">char</span> *frame, <span class="type">int</span> len);</span><br><span class="line"><span class="comment">// 定义了一个函数指针变量pFunc，它可以指向这样的函数：返回值为int，形参为char*、int</span></span><br><span class="line"><span class="type">int</span> *(*pFunc[<span class="number">5</span>])(<span class="type">int</span> len);</span><br><span class="line"><span class="comment">// 定义了5个函数指针变量：pFunc[0]、pFunc[1]···，它们都可以指向这样的函数：返回值为int*，形参为int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.定义函数指针类型</span></span><br><span class="line"><span class="comment">// 定义函数指针类型，必须使用typedef，方法就是，在“定义函数指针变量”加上typedef</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*pFunc_t)</span><span class="params">(<span class="type">char</span> *frame, <span class="type">int</span> len)</span></span>;  <span class="comment">// 定义了一个类型函数指针pFunc_t</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span>  <span class="title">int</span> <span class="params">(*pFunc_t)</span><span class="params">(<span class="type">char</span> *frame, <span class="type">int</span> len)</span></span>;  <span class="comment">// 定义了一个类型pFunc_t</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read_voltage</span><span class="params">(<span class="type">char</span> *data, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> voltage = <span class="number">0</span>;</span><br><span class="line">    ···<span class="comment">// 其他功能代码</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> voltage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pFunc_t pHandler = read_voltage;  <span class="comment">// 使用类型pFunc_t来定义函数指针变量</span></span><br><span class="line">    ···<span class="comment">// 其他功能代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）定义数组指针类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、定义数组指针变量</span></span><br><span class="line"><span class="built_in">int</span>(*pArr)[<span class="number">5</span>];  <span class="comment">// 定义了一个数组指针变量pArr，pArr可以指向一个int [5]的一维数组</span></span><br><span class="line"><span class="built_in">char</span>(*pArr)[<span class="number">4</span>][<span class="number">5</span>];  <span class="comment">// 定义了一个数组指针变量pArr，pArr可以指向一个char[4][5]的二维数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>(*pArr)[<span class="number">5</span>];  <span class="comment">// pArr是一个指向含5个int元素的一维数组的指针变量</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">pArr = &amp;a;				<span class="comment">// 完全合法，无警告</span></span><br><span class="line">pArr = a;				<span class="comment">// 发生编译警告，赋值时类型不匹配：a的类型为int(*)，而pArr的类型为int(*)[5]</span></span><br><span class="line">pArr = &amp;a[<span class="number">0</span>];			<span class="comment">// 发生编译警告，赋值时类型不匹配：a的类型为int(*)，而pArr的类型为int(*)[5]</span></span><br><span class="line">pArr = &amp;b;				<span class="comment">// 发生编译警告，赋值时类型不匹配：&amp;b的类型为int(*)[6]，而pArr的类型为int(*)[5]</span></span><br><span class="line">pArr = (<span class="built_in">int</span>(*)[<span class="number">5</span>])&amp;b;	<span class="comment">// 类型强制转换为int(*)[5]，完全合法，无警告</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、定义数组指针类型</span></span><br><span class="line"><span class="comment">// 如同上面定义函数指针类型的方法，直接在前面加typedef即可，例如</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*pArr_t)</span>[5]</span>; <span class="comment">// 定义了一个指针类型pArr_t，该类型的指针可以指向含5个int元素的数组</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*pArr_t)</span>[5]</span>;  <span class="comment">// 定义一个指针类型，该类型的指针可以指向含5个int元素的一维数组</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    pArr_t pA;<span class="comment">//定义数组指针变量pA</span></span><br><span class="line">    pA= &amp;a;<span class="comment">//完全合法，无警告    </span></span><br><span class="line">    pA= (pArr_t)&amp;b;<span class="comment">//类型强制转换为pArr_t，完全合法，无警告</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）定义数组类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果我们想声明一个含5个int元素的一维数组，一般会这么写：int a[5];</span></span><br><span class="line"><span class="comment">// 如果我们想声明多个含5个int元素的一维数组，一般会这么写：int a1[5], a2[5], a3[5]···，或者 a[N][5]</span></span><br><span class="line"><span class="comment">// 可见，对于定义多个一维数组，写起来略显复杂，这时，我们就应该把数组定义为一个类型，例如：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">arr_t</span>[<span class="number">5</span>]; <span class="comment">// 定义了一个数组类型arr_t，该类型的变量是个数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">arr_t</span> d;        	<span class="comment">// d是个数组，这一行等价于:  int d[5];</span></span><br><span class="line">    <span class="type">arr_t</span> b1, b2, b3;	<span class="comment">// b1, b2, b3都是数组</span></span><br><span class="line"></span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    d[<span class="number">4</span>] = <span class="number">134</span>;</span><br><span class="line">    d[<span class="number">5</span>] = <span class="number">253</span>;  <span class="comment">// 编译警告：下标越界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、mutable关键字"><a href="#7、mutable关键字" class="headerlink" title="7、mutable关键字"></a>7、mutable关键字</h2><p>首先，<code>c++</code>在类中引入<code>const</code>关键字 在成员函数尾部，使函数成为 常成员函数。这么做的目的是，在常成员函数内部，不允许修改调用它的对象的内部状态（即对象的成员变量）。此时，如果想在常成员函数内部修改对象的某个成员变量时，就需要引入<code>mutable</code>，将该对象的成员变量定义为<code>mutable</code>变量。但是，我们会把定义为<code>mutable</code>的这个变量，看做不属于对象的状态。这样，即使在常成员函数内部，<code>mutable</code>变量也可以被修改，与此同时，常成员函数内部，对于对象的其他成员变量（即对象的内部状态）还是不能修改的。</p>
<p>总结下： </p>
<ul>
<li><code>const</code>关键字，用于常成员函数，即“不允许在常成员函数内部修改对象状态的值。 </li>
<li><code>mutable</code>关键字，用于常成员函数，即“允许修改常成员函数内部不是对象状态的值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">A</span>(<span class="type">int</span> a): <span class="built_in">m_na</span>(a), <span class="built_in">m_nCount</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">      ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> m_na;</span><br><span class="line">      <span class="keyword">mutable</span> <span class="type">int</span> m_nCount;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.cpp   </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::display</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ++m_nCount;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;call func display()&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::getCount</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> m_nCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="function">QApplication <span class="title">aaa</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">      <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">      a.<span class="built_in">display</span>();</span><br><span class="line">      a.<span class="built_in">display</span>();</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;call func &quot;</span> &lt;&lt; a.<span class="built_in">getCount</span>() &lt;&lt; <span class="string">&quot; times.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> aaa.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="string">&quot;call func display()&quot;</span></span><br><span class="line"># <span class="string">&quot;call func display()&quot;</span></span><br><span class="line"># <span class="string">&quot;call func 2 times.&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="8、不完全类型"><a href="#8、不完全类型" class="headerlink" title="8、不完全类型"></a>8、不完全类型</h2><p>在一个给定的源文件中，一个类只能被定义一次，如果在多个文件中定义一个类，那么每个文件中的定义必须是完全相同的。一旦遇到花括号，类的定义就结束了。并且一旦定义了类，我们就知道所有类的成员，以及存储该类的对象所需的存储空间。</p>
<p>将类定义放在头文件中，可以保证在每个使用类的文件中以同样的方式定义类。使用头文件保护符，来保证即使头文件在同一个文件中被包含多次，类定义也只出现一次。</p>
<p>只声明却没有定义的类称为<strong>不完全类型</strong>，不完全类型不能定义该类型的对象，只能用于定义指向该类型的指针及引用，或者用于声明（不是定义）使用该类型作为形参类型或返回类型的函数。</p>
<p><strong>在创建类的对象之前，必须完整地定义该类。必须定义，而不是声明类，这样，编译器就会给类的对象预定相应的存储空间。同样的，在使用引用或指针访问类的成员之前，必须已经定义类。</strong>只有当类定义已经在前面出现过，数据成员才能被制定为该类类型。<strong>如果该类型是不完全类型，那么数据成员只能是指向该类类型的指针或引用。</strong></p>
<p>可以声明一个类而不定义它：这个声明称为<strong>前向声明</strong>。类的前向声明一般用来编写相互依赖的类。在声明之后，定义之前，类称为<strong>不完全类型</strong>，即已知Screen类是一个类型，但不知道包含哪些成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>；</span><br></pre></td></tr></table></figure>

<p>因为只有当类定义体完成后才能定义类，因此<strong>类不能具有自身类型的数据成员</strong>，然而，只要类名一出现就可以认为该类已经声明，因此，<strong>类的数据成员可以是指向自身类型的指针或引用</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkScreen</span>&#123;</span><br><span class="line">    Screen window;</span><br><span class="line">    LinkScreen *next;</span><br><span class="line">    LinkScreen *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>static</code>数据成员也可以是该成员所属的类类型。<code>非static</code>成员被限定声明为其自身类对象的指针或引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">static</span> Bar mem1;<span class="comment">//ok</span></span><br><span class="line">   Bar *mem2;<span class="comment">//ok</span></span><br><span class="line">   Bar mem3;<span class="comment">//no!!!!因为Bar是一个不完全类型，所以只能定义它的非static的指针或引用。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9-、string：cin和getline"><a href="#9-、string：cin和getline" class="headerlink" title="9 、string：cin和getline"></a>9 、string：cin和getline</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1, s2;</span><br><span class="line">cin &gt;&gt; s1;  <span class="comment">// &quot;   hello world!  &quot;</span></span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;  <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">getline</span>(cin, s2);  <span class="comment">// &quot;   hello world!  &quot;</span></span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl;  <span class="comment">// &quot;   hello world!  &quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="10、vector"><a href="#10、vector" class="headerlink" title="10、vector"></a>10、vector</h2><p>1、要想列表初始化<code>vector</code>对象，花括号里的值必须与元素类型相同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;         <span class="comment">// 10 × 0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">10</span>&#125;;         <span class="comment">// 1  × 10（列表初始化）</span></span><br><span class="line">vector&lt;string&gt; v3&#123;<span class="string">&quot;hi&quot;</span>&#125;;    <span class="comment">// 1 × “hi”（列表初始化）</span></span><br><span class="line">vector&lt;string&gt; v4&#123;<span class="number">10</span>&#125;;      <span class="comment">// 10 × 默认初始化</span></span><br></pre></td></tr></table></figure>

<h2 id="11、逻辑与-、逻辑或-、条件-与逗号-运算符的求值顺序"><a href="#11、逻辑与-、逻辑或-、条件-与逗号-运算符的求值顺序" class="headerlink" title="11、逻辑与(&amp;&amp;)、逻辑或(||)、条件(?:)与逗号(,)运算符的求值顺序"></a>11、逻辑与(&amp;&amp;)、逻辑或(||)、条件(?:)与逗号(,)运算符的求值顺序</h2><ul>
<li>逻辑与(<code>&amp;&amp;</code>)：先求左侧运算对象，为真时才继续求右侧运算对象。</li>
<li>逻辑或(<code>||</code>)：先求左侧运算对象，为假时才继续求右侧运算对象。</li>
<li>逗号运算符：首先对左侧求值，然后丢弃，真正的结果是右侧的值。</li>
</ul>
<h2 id="12、sizeof运算符"><a href="#12、sizeof运算符" class="headerlink" title="12、sizeof运算符"></a>12、sizeof运算符</h2><p>因为<code>sizeof</code>运算符不会实际求运算对象的值，所以<code>sizeof *p;</code>是安全的行为，因为指针实际数据昂并没有被真正使用。</p>
<h2 id="13、switch-case语句"><a href="#13、switch-case语句" class="headerlink" title="13、switch-case语句"></a>13、switch-case语句</h2><p><code>switch-case</code>语句可以两条<code>case</code>语句执行一个操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Sales_item.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string text;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> aCount, eCount, iCount, oCount, uCount, _tCount, _nCount, __Count;</span><br><span class="line">    aCount = eCount = iCount = oCount = uCount = _tCount = _nCount = __Count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// while(getline(cin, text))</span></span><br><span class="line">    <span class="keyword">while</span>(cin.<span class="built_in">get</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: </span><br><span class="line">                aCount++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>: </span><br><span class="line">                eCount++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: </span><br><span class="line">                iCount++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>: </span><br><span class="line">                oCount++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>: </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>: </span><br><span class="line">                eCount++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">                _tCount++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">                _nCount++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                __Count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The num of &#x27;a&#x27; is &quot;</span> &lt;&lt; aCount &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The num of &#x27;e&#x27; is &quot;</span> &lt;&lt; eCount &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The num of &#x27;i&#x27; is &quot;</span> &lt;&lt; iCount &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The num of &#x27;o&#x27; is &quot;</span> &lt;&lt; oCount &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The num of &#x27;u&#x27; is &quot;</span> &lt;&lt; uCount &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The num of &#x27;\\t&#x27; is &quot;</span> &lt;&lt; _tCount &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The num of &#x27;\\n&#x27; is &quot;</span> &lt;&lt; _nCount &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The num of &#x27; &#x27; is &quot;</span> &lt;&lt; __Count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code相关</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>《C++ Primer习题集》</title>
    <url>/2023/08/06/code%E7%9B%B8%E5%85%B3/C++/%E3%80%8AC++%20Primer%E4%B9%A0%E9%A2%98%E9%9B%86%E3%80%8B/</url>
    <content><![CDATA[<h1 id="第一章-开始"><a href="#第一章-开始" class="headerlink" title="第一章 开始"></a>第一章 开始</h1><h2 id="练习1-2"><a href="#练习1-2" class="headerlink" title="练习1.2"></a>练习1.2</h2><p>在<code>linux</code>系统中，通过<code>echo $?</code>可以获取该命令的返回值。返回值是一个整数，用于表示命令执行的结果。</p>
<p>一些常见的返回值含义如下：</p>
<pre><code>0 : 命令成功执行，没有错误。
1 : 一般错误，没有具体的错误代码。
2 : 语法错误或命令执行失败。
126 : 命令无法执行，可能缺少执行权限。
127 : 命令不存在或无法找到。
128 : 无效的退出参数。
130 : 命令被中断，通常由用户按下Ctrl+C导致。
255 : 命令执行失败，通常由于出现无效的返回值。
</code></pre>
<span id="more"></span>

<h2 id="练习-1-6"><a href="#练习-1-6" class="headerlink" title="练习 1.6"></a>练习 1.6</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; v1;</span><br><span class="line">	      &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2;</span><br><span class="line">		  &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; v1 + v2 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>这是很容易出现的错误。前两行的末尾有分号，表示语句结束，因此第2、3行为两条新的语句，缺少了<code>std::cout</code>。</p>
<h2 id="练习1-14"><a href="#练习1-14" class="headerlink" title="练习1.14"></a>练习1.14</h2><p>对比<code>for</code>循环和<code>while</code>循环：</p>
<p>在循环次数已知的情况下，<code>for</code>循环的形式显然更为简洁。</p>
<p>而循环次数无法预知时，用<code>while</code>循环实现更适合。用特定条件控制循环是否执行，循环体中执行的语句可能导致循环判定条件发生变化。</p>
<h2 id="练习1-16"><a href="#练习1-16" class="headerlink" title="练习1.16"></a>练习1.16</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, value = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一组数，按ctrl+d表示结束：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(; cin &gt;&gt; value; )</span><br><span class="line">        sum += value;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;读入的数的和为：&quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题重要的是<code>for(; cin &gt;&gt; value ;)</code>，以及后面的题中出现的<code>while(cin &gt;&gt; book)</code>，这种对输入流的结束判断。</p>
<p>注意，当从键盘向程序输入数据时，对于如何指出文件结束，不同操作系统有不同的约定。在Window系统中，输入<strong>文件结束符</strong>的方法是<code>Ctrl+Z</code>，然后按<code>Enter/Return</code>。在<code>Unix</code>系统中，包括<code>MacOSX</code>系统中，文件结束符输入是用<code>Ctrl+D</code>。</p>
<h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 2.26</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> buf;  <span class="comment">// const对象必须初始化</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> sz = cnt;</span><br><span class="line">    ++cnt;</span><br><span class="line">    ++sz;  <span class="comment">// 非法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.27</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">-1</span>, &amp;r = <span class="number">0</span>;         <span class="comment">// &amp;r = 0非法，非常量引用不能引用字面值常量0</span></span><br><span class="line">    <span class="type">int</span> *<span class="type">const</span> p2 = &amp;i2;        <span class="comment">// 合法，p2为常量指针，因此p2永远指向变量i2</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> i = <span class="number">-1</span>, &amp;r = <span class="number">0</span>;   <span class="comment">// 合法，常量i和常量引用r</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = &amp;i2;  <span class="comment">// 合法，常量指针p3指向变量i2，且由于p3指向const，不能通过p3修改i2</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p1 = &amp;i2;        <span class="comment">// 合法，p1指向const，不能通过p1修改i2</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;<span class="type">const</span> r2;        <span class="comment">// 非法，引用非对象，不能让引用恒定不变</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> i2 = i, &amp;r = i;   <span class="comment">// 合法，常量i2和常量引用r</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.28</span></span><br><span class="line">    <span class="comment">// (a) 以下四条均非法，记住涉及到某类型为常量时必须初始化，如这里的常量指针 </span></span><br><span class="line">    <span class="type">int</span> i, *<span class="type">const</span> cp;           </span><br><span class="line">    <span class="type">int</span> *p1, *<span class="type">const</span> p2;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ic, &amp;r = ic;  </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3;</span><br><span class="line">    <span class="comment">// (b) 合法，指针常量，但p没有指向任何实际的对象</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.30</span></span><br><span class="line">    <span class="comment">// 顶层const：表示任意的对象是常量； </span></span><br><span class="line">    <span class="comment">// 底层const：所指的对象是常量，与指针和引用等复合类型的基本数据类型部分有关</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.32</span></span><br><span class="line">    <span class="comment">// int null = 0, *p = null; 非法</span></span><br><span class="line">    <span class="type">int</span> null = <span class="number">0</span>, *p = <span class="literal">nullptr</span>;  <span class="comment">// nullptr是表示空指针的字面值常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.36</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(a) c = a;</span><br><span class="line">    <span class="keyword">decltype</span>((b)) d = a;  <span class="comment">// int &amp;d = a;</span></span><br><span class="line">    ++c;</span><br><span class="line">    ++d;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>    <span class="comment">// 4</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span>    <span class="comment">// 5</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>    <span class="comment">// 4</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;d=&quot;</span> &lt;&lt; d &lt;&lt; endl;  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-字符串、向量和数组"><a href="#第三章-字符串、向量和数组" class="headerlink" title="第三章 字符串、向量和数组"></a>第三章 字符串、向量和数组</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.2</span></span><br><span class="line"><span class="comment">// 一次读入一行</span></span><br><span class="line">string line;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin, line))</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一次读入一个词</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; word)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.3</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        1、标准库string的输入运算符自动忽略字符串开头的空白(包括空格符、换行符、制表符等),从第一个真正的字符开始读起，直到遇见下一处空白为止。</span></span><br><span class="line"><span class="comment">        2、如果希望在最终的字符串中保留输入时的空白符，应该使用getline函数代替原来的&gt;&gt;运算符，</span></span><br><span class="line"><span class="comment">            getline从给定的输入流中读取数据，直到遇到换行符为止，此时换行符也被读取进来，但是并不存储在最后的字符串中。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.4</span></span><br><span class="line">string str1, str2;</span><br><span class="line">cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1=&quot;</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;str2=&quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输出较大的字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span>(str1 != str2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(str1 &gt; str2)</span><br><span class="line">        cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输出较长的字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span>(str1.<span class="built_in">size</span>() != str2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(str1.<span class="built_in">size</span>() &gt; str2.<span class="built_in">size</span>())</span><br><span class="line">        cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.5 </span></span><br><span class="line">string str, str_sum;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; str)</span><br><span class="line">&#123;</span><br><span class="line">    str_sum += str;</span><br><span class="line">    str_sum += <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; str_sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.6</span></span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;at begin str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : str)</span><br><span class="line">    c = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.7</span></span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;at begin str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span> &amp;c : str)</span><br><span class="line">    c = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.8</span></span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;at begin str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"><span class="comment">// while</span></span><br><span class="line">string::size_type i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; str.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    str[i] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"><span class="comment">// for（传统）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">decltype</span>(str.<span class="built_in">size</span>()) i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    str[i] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.9</span></span><br><span class="line">string s;</span><br><span class="line">cout &lt;&lt; s[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.10</span></span><br><span class="line">string line, new_line;</span><br><span class="line"><span class="built_in">getline</span>(cin, line);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;at begin line=&quot;</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">decltype</span>(line.<span class="built_in">size</span>()) i = <span class="number">0</span>; i &lt; line.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">ispunct</span>(line[i]))</span><br><span class="line">        new_line += line[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now str=&quot;</span> &lt;&lt; new_line &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.11</span></span><br><span class="line"><span class="type">const</span> string s = <span class="string">&quot;Keep out!&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.14</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; i)</span><br><span class="line">&#123;</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.15</span></span><br><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.17</span></span><br><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">string str;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; str)</span><br><span class="line">&#123;</span><br><span class="line">    svec.<span class="built_in">push_back</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s : svec)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="built_in">toupper</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.18</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="comment">// ivec[0] = 42;</span></span><br><span class="line">ivec.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.19</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec1</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec2&#123;<span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec3;</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::size_type i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    ivec3.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.20</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; i)</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::size_type i = <span class="number">0</span>; i &lt; ivec.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;和第&quot;</span> &lt;&lt; i+<span class="number">2</span> &lt;&lt; <span class="string">&quot;的和是&quot;</span> &lt;&lt; ivec[i] + ivec[i+<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::size_type i = <span class="number">0</span>; i &lt; ivec.<span class="built_in">size</span>()/<span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;和第&quot;</span> &lt;&lt; ivec.<span class="built_in">size</span>()-i &lt;&lt; <span class="string">&quot;的和是&quot;</span> &lt;&lt; ivec[i] + ivec[ivec.<span class="built_in">size</span>()-i<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.22</span></span><br><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin, s))</span><br><span class="line">    svec.<span class="built_in">push_back</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> s = svec.<span class="built_in">begin</span>(); s != svec.<span class="built_in">end</span>() &amp;&amp; !s-&gt;<span class="built_in">empty</span>(); s++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = s-&gt;<span class="built_in">begin</span>(); it != s-&gt;<span class="built_in">end</span>(); it++)</span><br><span class="line">        *it = <span class="built_in">toupper</span>(*it);</span><br><span class="line">    cout &lt;&lt; *s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.23</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : ivec)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; i;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = ivec.<span class="built_in">begin</span>(); it != ivec.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    *it = (*it) * <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.24</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; i)</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = ivec.<span class="built_in">begin</span>(); it != ivec.<span class="built_in">end</span>() - <span class="number">1</span>; it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it + *(it+<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-------------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">auto</span> beg = ivec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> end = ivec.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = beg; it != beg + (end - beg) / <span class="number">2</span>; it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it + *(beg + (end - it) - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ivec.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">    cout &lt;&lt; *(beg + (end - beg) / <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.25</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">unsigned</span>&gt; <span class="title">scores</span><span class="params">(<span class="number">11</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">unsigned</span> grade;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; grade)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(grade &lt;= <span class="number">100</span>)</span><br><span class="line">        ++*(scores.<span class="built_in">begin</span>() + grade / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : scores)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.26</span></span><br><span class="line"><span class="comment">// 二分搜索程序中，为什么用的是 mid = beg + (end - beg) / 2，而非 mid = (beg + end) / 2</span></span><br><span class="line"><span class="comment">// C++并没有定义两个迭代器的加法运算，实际上直接把两个迭代器加起来是没有意义的。</span></span><br><span class="line"><span class="comment">// 与之相反，C++定义了迭代器的减法运算，两个迭代器相减的结果是它们之间的距离;</span></span><br><span class="line"><span class="comment">// 也就是说，将运算符右侧的迭代器向前移动多少个元素后可以得到左侧的迭代器，参与运算的两个迭代器必须指向同一个容器中的元素或尾后元素。</span></span><br><span class="line"><span class="comment">// 另外，C++还定义了迭代器与整数的加减法运算，用以控制迭代器在容器中左右移动。</span></span><br><span class="line"><span class="comment">// 在本题中，因为迭代器的加法不存在，所以mid=(beg+end)/2;不合法。mid = beg+(end - beg)/ 2;的含义是，先计算end-beg的值得到容器中的元素个数，然后控制迭代器从开始处向右移动二分之一容器的长度，从而定位到容器正中间的元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.29</span></span><br><span class="line"><span class="comment">// 相对于 vector 来说，数组有哪些缺点？</span></span><br><span class="line"><span class="comment">// 1、数组的大小固定不变，不能随意向数组中增加额外的元素。如果想改变数组的长度，必须创建一个更大的数组，然后将原数组的元素复制过去；</span></span><br><span class="line"><span class="comment">// 2、无法使用 size 函数直接获取数组的维度：</span></span><br><span class="line"><span class="comment">//     如果是字符数组，可以用 strlen 获取；</span></span><br><span class="line"><span class="comment">//     如果是其他数组，只能通过 sizeof(array)/sizeof(array[0]) 获取。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.31</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.32</span></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    a[i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    b[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : b)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a1;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    a1.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b1</span><span class="params">(a1)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> j : b1)</span><br><span class="line">    cout &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.33</span></span><br><span class="line"><span class="comment">// 如果不初始化scores，则该数组会含有未定义的数值，这是因为scores是定义在函数内部的整型数组，不会执行默认初始化。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.35</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> *b = <span class="built_in">begin</span>(a);</span><br><span class="line"><span class="keyword">auto</span> *e = <span class="built_in">end</span>(a);</span><br><span class="line"><span class="keyword">while</span>(b != e)</span><br><span class="line">&#123;   </span><br><span class="line">    *b = <span class="number">0</span>;</span><br><span class="line">    ++b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// int *p = a;</span></span><br><span class="line"><span class="comment">// for(int i = 0; i &lt; 4; i++)</span></span><br><span class="line"><span class="comment">//     *(p+i) = 0;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : a)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.36</span></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> *ita = <span class="built_in">begin</span>(a);</span><br><span class="line"><span class="keyword">auto</span> *itb = <span class="built_in">begin</span>(b);</span><br><span class="line"><span class="keyword">while</span>(ita != <span class="built_in">end</span>(a) &amp;&amp; itb != <span class="built_in">end</span>(b))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*ita != *itb)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;两个数组不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ita++;</span><br><span class="line">    itb++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;两个数组相等&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// vector</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec1</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it1 = ivec1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> it2 = ivec2.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it1 != ivec1.<span class="built_in">end</span>() &amp;&amp; it2 != ivec2.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*it1 != *it2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;两个数组不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    it1++;</span><br><span class="line">    it2++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;两个数组相等&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.37</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> ca[] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cp = ca;</span><br><span class="line"><span class="keyword">while</span>(*cp)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *cp &lt;&lt; endl;</span><br><span class="line">    ++cp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个程序原意是想依次输出“hello”这5个字符，</span></span><br><span class="line"><span class="comment">// 但是由于数组ca的末尾不包含空字符&#x27;\0&#x27;，因此可能输出&#x27;o&#x27;后会继续输出，直至遇到空字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.38</span></span><br><span class="line"><span class="comment">// 两个指针的相加是无意义的。</span></span><br><span class="line"><span class="comment">// 指针本身的值是一个内存地址值，表示指针所指对象在内存中的存储地址。</span></span><br><span class="line"><span class="comment">// 如果把两个指针相加，意味着把两个对象的存储地址加在一起，这是没有意义的；</span></span><br><span class="line"><span class="comment">// 如果两个指针指向同一个数组中的不同元素，则它们相减的结果表征了它们所指的元素在数组中的距离。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.39</span></span><br><span class="line">string s1, s2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入两个字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line"><span class="keyword">if</span>(s1 &gt; s2)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 &gt; s2&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 &lt; s2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ca1[<span class="number">80</span>], ca2[<span class="number">80</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入两个字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; ca1 &gt;&gt; ca2;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(ca1, ca2))</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ca1 &gt; ca2&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ca1 &lt; ca2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.40</span></span><br><span class="line"><span class="type">char</span> ca1[<span class="number">80</span>] = <span class="string">&quot;i love u&quot;</span>;</span><br><span class="line"><span class="type">char</span> ca2[<span class="number">80</span>] = <span class="string">&quot;but i love myself more.&quot;</span>;</span><br><span class="line"><span class="type">char</span> ca3[<span class="number">80</span>] = &#123;&#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(ca3, ca1);</span><br><span class="line"><span class="built_in">strcat</span>(ca3, <span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(ca3, ca2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : ca3)</span><br><span class="line">    cout &lt;&lt; i;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.41</span></span><br><span class="line"><span class="type">int</span> int_arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr), end(int_arr))</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : ivec)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.42</span></span><br><span class="line"><span class="comment">// C++允许使用数组直接初始化vector对象，但是不允许使用vector对象初始化数组。</span></span><br><span class="line"><span class="comment">// 如果想用vector对象初始化数组，则必须把vector对象的每个元素逐一赋值给数组。</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> int_arr[ivec.<span class="built_in">size</span>()] = &#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = ivec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;val : int_arr) <span class="comment">//  &amp;val-引用</span></span><br><span class="line">&#123;</span><br><span class="line">    val = *it;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    it++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-表达式"><a href="#第四章-表达式" class="headerlink" title="第四章 表达式"></a>第四章 表达式</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.21</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec; </span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一组整数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; num)</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(num);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : ivec)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;    </span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now the vec:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : ivec)</span><br><span class="line">    cout &lt;&lt; ((i % <span class="number">2</span> == <span class="number">0</span>) ? i : i * <span class="number">2</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;    </span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.22</span></span><br><span class="line"><span class="type">int</span> grade;</span><br><span class="line"><span class="comment">// 条件运算符</span></span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; grade)</span><br><span class="line">&#123;</span><br><span class="line">    string final_grade = (grade &gt; <span class="number">90</span>) ? <span class="string">&quot;high pass&quot;</span> </span><br><span class="line">        : (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> </span><br><span class="line">            : (grade &gt; <span class="number">60</span> &amp;&amp; grade &lt; <span class="number">75</span>) ? <span class="string">&quot;low pass&quot;</span></span><br><span class="line">                : <span class="string">&quot;pass&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;final grade is: &quot;</span> &lt;&lt; final_grade &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// // if语句</span></span><br><span class="line"><span class="comment">// while(cin &gt;&gt; grade)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     if(grade &gt; 90)</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;high pass&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     else if(grade &gt; 60 &amp;&amp; grade &lt; 75)</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;low pass&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     else if(grade &lt; 60)</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;fail&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     else</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;pass&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.28</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;类型名称\t&quot;</span> &lt;&lt;<span class="string">&quot;所占空间&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bool\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">bool</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;char\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;wchar_t\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;char16_t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char16_t</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;char32_t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char32_t</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;short\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long long\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;float\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;double\t\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long double\t&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">double</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.29</span></span><br><span class="line"><span class="type">int</span> x[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p = x;</span><br><span class="line">cout &lt;&lt; (<span class="built_in">sizeof</span>(x) / <span class="built_in">sizeof</span>(*x)) &lt;&lt; endl; <span class="comment">// 10(40/4)</span></span><br><span class="line">cout &lt;&lt; (<span class="built_in">sizeof</span>(p) / <span class="built_in">sizeof</span>(*p)) &lt;&lt; endl; <span class="comment">// 2(8/2) 指针所占的空间大小为8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.37</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="type">const</span> string *ps;</span><br><span class="line"><span class="type">char</span> *pc;</span><br><span class="line"><span class="type">void</span> *pv;</span><br><span class="line">pv = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt; (<span class="built_in">const_cast</span>&lt;string*&gt; (ps));     <span class="comment">// pv = (void*)ps;</span></span><br><span class="line">i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt; (*pc);                             <span class="comment">// i = int(*pc);</span></span><br><span class="line">pv = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt; (&amp;d);                           <span class="comment">// pv = &amp;d;</span></span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt; (pv);                           <span class="comment">// pc = (char*)pv;</span></span><br></pre></td></tr></table></figure>

<h1 id="第五章-语句"><a href="#第五章-语句" class="headerlink" title="第五章 语句"></a>第五章 语句</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.5 </span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; grade;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">string grade_[] = &#123;<span class="string">&quot;D&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span> || num &gt; <span class="number">100</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误成绩！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    grade.<span class="built_in">push_back</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : grade)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; grade.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(grade[i] &gt;= <span class="number">60</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;the grade &quot;</span> &lt;&lt; grade[i] &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; grade_[grade[i] / <span class="number">10</span> - <span class="number">6</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;the grade &quot;</span> &lt;&lt; grade[i] &lt;&lt; <span class="string">&quot; is F&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.6</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; grade;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">string grade_[] = &#123;<span class="string">&quot;D&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span> || num &gt; <span class="number">100</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误成绩！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    grade.<span class="built_in">push_back</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : grade)</span><br><span class="line">&#123;</span><br><span class="line">    string final_grade = (i &lt; <span class="number">60</span>) ? <span class="string">&quot;F&quot;</span> </span><br><span class="line">        : (i &gt;=<span class="number">60</span> &amp;&amp; i &lt; <span class="number">70</span>) ? <span class="string">&quot;D&quot;</span></span><br><span class="line">            : (i &gt;=<span class="number">70</span> &amp;&amp; i &lt; <span class="number">80</span>) ? <span class="string">&quot;B&quot;</span></span><br><span class="line">                : (i &gt;=<span class="number">80</span> &amp;&amp; i &lt; <span class="number">90</span>) ? <span class="string">&quot;C&quot;</span></span><br><span class="line">                    : <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the grade &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; final_grade &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.8</span></span><br><span class="line"><span class="comment">// 悬垂else是指当程序中的if分支多于else分支时，如何为else寻找与之匹配的if分支的问题。</span></span><br><span class="line"><span class="comment">// C++规定，else与离它最近的尚未匹配的if匹配，从而消除了二义性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.9</span></span><br><span class="line"><span class="type">unsigned</span> vowelCnt = <span class="number">0</span>, blankspaceCnt = <span class="number">0</span>, tabCnt = <span class="number">0</span>, lineCnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一段文本：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// while(cin &gt;&gt; ch)</span></span><br><span class="line"><span class="keyword">while</span>(cin.<span class="built_in">get</span>(ch))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>: </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line">            ++vowelCnt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            ++blankspaceCnt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">            ++tabCnt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">            ++lineCnt;</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您输入的文本中共有&quot;</span> &lt;&lt; vowelCnt &lt;&lt; <span class="string">&quot;个元音字母&quot;</span> &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; blankspaceCnt &lt;&lt; <span class="string">&quot;个空格&quot;</span> &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; tabCnt &lt;&lt; <span class="string">&quot;个制表符&quot;</span> &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; lineCnt &lt;&lt; <span class="string">&quot;个换行符&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.10</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ffCnt = <span class="number">0</span>, flCnt = <span class="number">0</span>, fiCnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch, prech = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一段文本：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> bl = <span class="literal">true</span>;  <span class="comment">// 避免重复统计ff</span></span><br><span class="line">    <span class="keyword">if</span>(prech == <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">                ++ffCnt;</span><br><span class="line">                bl = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">                ++flCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                ++fiCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!bl)</span><br><span class="line">        prech = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prech = ch;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ff的数量是：&quot;</span> &lt;&lt; ffCnt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;fl的数量是：&quot;</span> &lt;&lt; flCnt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;fi的数量是：&quot;</span> &lt;&lt; fiCnt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.14</span></span><br><span class="line">string cur_str, pre_str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一句话：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; cur_str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur_str == pre_str)</span><br><span class="line">        ++cnt;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre_str != <span class="string">&quot;&quot;</span>)</span><br><span class="line">            cout &lt;&lt; pre_str &lt;&lt; <span class="string">&quot;连续出现了&quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot;次&quot;</span> &lt;&lt; endl;</span><br><span class="line">        pre_str = cur_str;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pre_str != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    cout &lt;&lt; pre_str &lt;&lt; <span class="string">&quot;连续出现了&quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot;次&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.17</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it1 = ivec1.<span class="built_in">begin</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it2 = ivec2.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it1 != ivec1.<span class="built_in">end</span>() &amp;&amp; it2 != ivec2.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*it1 != *it2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1和v2之间不存在前缀关系&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    it1++;</span><br><span class="line">    it2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(it1 == ivec1.<span class="built_in">end</span>())</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1是v2的前缀&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span>(it2 == ivec2.<span class="built_in">end</span>())</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1是v2的前缀&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.19</span></span><br><span class="line">string str1, str2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入两个字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(str1.<span class="built_in">length</span>() != str2.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str1.<span class="built_in">length</span>() &lt; str2.<span class="built_in">length</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;较短的字符串为：&quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;较短的字符串为：&quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(cin &gt;&gt; str1 &gt;&gt; str2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.20</span></span><br><span class="line">string cur_str, pre_str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">bool</span> bl = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; cur_str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur_str == pre_str)</span><br><span class="line">    &#123;</span><br><span class="line">        bl = <span class="literal">false</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;重复出现的词：&quot;</span> &lt;&lt; pre_str &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre_str = cur_str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(bl)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有重复出现的词！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.21</span></span><br><span class="line">string cur_str, pre_str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">bool</span> bl = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; cur_str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isupper</span>(cur_str[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(cur_str == pre_str)</span><br><span class="line">    &#123;</span><br><span class="line">        bl = <span class="literal">false</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;重复出现的词（必须以大写开头）：&quot;</span> &lt;&lt; pre_str &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre_str = cur_str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(bl)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有重复出现的词（必须以大写开头）！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.23</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请依次输入被除数和除数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> i1, i2;</span><br><span class="line">cin &gt;&gt; i1 &gt;&gt; i2;</span><br><span class="line"><span class="keyword">if</span>(i2 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;除数不能为0！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i1/i2=&quot;</span> &lt;&lt; i1 / i2 &lt;&lt; endl;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.24</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请依次输入被除数和除数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> i1, i2;</span><br><span class="line">cin &gt;&gt; i1 &gt;&gt; i2;</span><br><span class="line"><span class="keyword">if</span>(i2 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;除数不能为0！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i1/i2=&quot;</span> &lt;&lt; i1 / i2 &lt;&lt; endl;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.25</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请依次输入被除数和除数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> i1, i2;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; i1 &gt;&gt; i2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i2 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;除数不能为0！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i1/i2=&quot;</span> &lt;&lt; i1 / i2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(runtime_error err)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;需要继续吗？（y or n）&quot;</span>;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line">        <span class="keyword">if</span>(ch != <span class="string">&#x27;y&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h1><p>分离式编译：</p>
<p><code>fact.cc &amp; factMain.cc &amp; main6.3-h</code></p>
<p><code>fact.cc</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main6.3-.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.3</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(val &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum *= val--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>factMain.cc </code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main6.3-.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">fact</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5!=&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main6.3-h</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MAIN6_3_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MAIN6_3_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.3</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line"><span class="comment">// 6.4</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact_usr</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 6.5</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">absd</span><span class="params">(<span class="type">double</span> a)</span></span>;</span><br><span class="line"><span class="comment">// 6.7</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_calls</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 6.18</span></span><br><span class="line"><span class="comment">// bool compare(const matrix&amp; m1, const matrix&amp; m2);</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">change_val</span><span class="params">(<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;::iterator)</span></span>;</span><br><span class="line"><span class="comment">// 6.36 &amp;&amp; 6.37</span></span><br><span class="line"><span class="comment">// 直接声明</span></span><br><span class="line"><span class="built_in">string</span> (*<span class="built_in">func1</span>())[<span class="number">10</span>]; </span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> string arr[<span class="number">10</span>];</span><br><span class="line"><span class="function">arr&amp; <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 尾置返回类型</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func3</span><span class="params">()</span> -&gt; <span class="title">string</span><span class="params">(*)</span> [10]</span>;</span><br><span class="line"><span class="comment">// decltype关键字</span></span><br><span class="line">string str[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">decltype</span>(str) &amp;<span class="built_in">func4</span>();</span><br><span class="line"><span class="comment">// 6.54</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func5</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="keyword">decltype</span>(func5)*&gt; vF;<span class="comment">// 该vector对象的元素是指向函数func5的指针</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>习题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main6.3-.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.3</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(val &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum *= val--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.4</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact_usr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val_usr;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个数字以计算其阶乘：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; val_usr;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(val_usr &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum *= val_usr--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.5</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">absd</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.7</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_calls</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ctr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ctr++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.10</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_pointer</span><span class="params">(<span class="type">int</span> *p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.11</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.12</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_refer</span><span class="params">(<span class="type">int</span> &amp;r1, <span class="type">int</span> &amp;r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    temp = r1;</span><br><span class="line">    r1 = r2;</span><br><span class="line">    r2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.17</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_Upper</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(string::size_type i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isupper</span>(s[i]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">s_to_lower</span><span class="params">(string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(string::size_type i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.21</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare_int</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>* ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; *ip)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> *ip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.22</span></span><br><span class="line"><span class="comment">// 既不交换指针，也不交换指针所指的内容（局限于函数内部）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapPointer1</span><span class="params">(<span class="type">int</span>* p1, <span class="type">int</span>* p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = p1;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换指针所指的内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapPointer2</span><span class="params">(<span class="type">int</span>* p1, <span class="type">int</span>* p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换指针本身</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapPointer3</span><span class="params">(<span class="type">int</span>* &amp;p1, <span class="type">int</span>* &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = p1;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.23</span></span><br><span class="line"><span class="comment">// 参数是常量整型指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数有两个，分别是常量整型指针和数组的容量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p, <span class="type">const</span> <span class="type">int</span> sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != sz)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *p++ &lt;&lt; endl;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数有两个，分别是数组的首尾边界</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print3</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *b,<span class="type">const</span> <span class="type">int</span> *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q=b; q!=e; ++q)</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.24</span></span><br><span class="line"><span class="comment">// void print(const int ia[10])</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     for(size_t i = 0; i != 10; ++i)</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; ia[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 上述print函数的定义存在一个潜在风险</span></span><br><span class="line"><span class="comment">// 即虽然我们期望传入的数组维度是10，但实际上任意维度的数组都可以传入。</span></span><br><span class="line"><span class="comment">// 如果传入的数组维度较大，print函数输出数组的前10个元素，不至于引发错误；</span></span><br><span class="line"><span class="comment">// 相反如果传入的数组维度不足10，则print函数将强行输出一些未定义的值。</span></span><br><span class="line"><span class="comment">// 修改后的程序是：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ia[], <span class="type">const</span> <span class="type">int</span> sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i != sz; ++i)</span><br><span class="line">        cout &lt;&lt; ia[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.33</span></span><br><span class="line"><span class="comment">// 递归输出vector对象的内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vInt, <span class="type">unsigned</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> sz = vInt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(!vInt.<span class="built_in">empty</span>() &amp;&amp; index &lt; sz)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; vInt[index] &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">printVector</span>(vInt, index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.55</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func11</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func12</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func13</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func14</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.56</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Compute</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>(*p)(<span class="type">int</span>, <span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">p</span>(a, b) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 6.3</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">fact</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5!=&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.4</span></span><br><span class="line">    <span class="type">int</span> n_usr = <span class="built_in">fact_usr</span>();</span><br><span class="line">    cout &lt;&lt; n_usr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.5</span></span><br><span class="line">    <span class="type">double</span> m1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入任意一个数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; m1;</span><br><span class="line">    cout &lt;&lt; m1 &lt;&lt; <span class="string">&quot;的绝对值是&quot;</span> &lt;&lt; <span class="built_in">absd</span>(m1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.7</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">count_calls</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.10</span></span><br><span class="line">    <span class="type">int</span> i1 = <span class="number">10</span>, i2 = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> *p1 = &amp;i1, *p2 = &amp;i2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i1=&quot;</span> &lt;&lt; *p1 &lt;&lt; <span class="string">&quot;, i2=&quot;</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">swap_pointer</span>(p1, p2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after swap: i1=&quot;</span> &lt;&lt; *p1 &lt;&lt; <span class="string">&quot;, i2=&quot;</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.11</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m=&quot;</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after reset, m=&quot;</span> &lt;&lt; <span class="built_in">reset</span>(m) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.12</span></span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">10</span>, n2 = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> &amp;r1 = n1, &amp;r2 = n2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;n1=&quot;</span> &lt;&lt; r1 &lt;&lt; <span class="string">&quot;, n2=&quot;</span> &lt;&lt; r2 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">swap_refer</span>(r1, r2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after swap: n1=&quot;</span> &lt;&lt; r1 &lt;&lt; <span class="string">&quot;, n2=&quot;</span> &lt;&lt; r2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.14</span></span><br><span class="line">    <span class="comment">// 练习6.14:举一个形参应该是引用类型的例子，再举一个形参不能是引用类型的例子。</span></span><br><span class="line">    <span class="comment">// 【出题思路】</span></span><br><span class="line">    <span class="comment">// 与值传递相比，引用传递的优势主要体现在三个方面：一是可以直接操作引用形参所引的对象；二是使用引用形参可以避免拷贝大的类类型对象或容器类型对象；三是使用引用形参可以帮助我们从函数中返回多个值。</span></span><br><span class="line">    <span class="comment">// 【解答】</span></span><br><span class="line">    <span class="comment">// 基于对引用传递优势的分析，我们可以举出几个适合使用引用类型形参的例子：</span></span><br><span class="line">    <span class="comment">// 第一，当函数的目的是交换两个参数的内容时应该使用引用类型的形参；第二，当参数是string对象时，为了避免拷贝很长的字符串，应该使用引用类型。</span></span><br><span class="line">    <span class="comment">// 在其他情况下可以使用值传递的方式，而无须使用引用传递，例如求整数的绝对值或者阶乘的程序。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.17</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="built_in">is_Upper</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">    string str = <span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">s_to_lower</span>(str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.21</span></span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; count &lt;&lt; &quot;: &quot; &lt;&lt; compare_int(2, a) &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// a++; // 数组名是一个常量指针，指向数组的首元素，它的值是固定的，不能通过 ++ 操作来修改</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;数组a中第&quot;</span> &lt;&lt; count + <span class="number">1</span> &lt;&lt; <span class="string">&quot;个数和2比较，较大的数是: &quot;</span> &lt;&lt; <span class="built_in">compare_int</span>(<span class="number">2</span>, &amp;a[count]) &lt;&lt; endl;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.22</span></span><br><span class="line">    <span class="type">int</span> h = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;h, *q = &amp;b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(address)h=&quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;\tb=&quot;</span> &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(context)h=&quot;</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;\tb=&quot;</span> &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// swapPointer1(p, q);</span></span><br><span class="line">    <span class="comment">// swapPointer2(p, q);</span></span><br><span class="line">    <span class="built_in">swapPointer3</span>(p, q);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after swap(address): h=&quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;\tb=&quot;</span> &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after swap(context): h=&quot;</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;\tb=&quot;</span> &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.23</span></span><br><span class="line">    <span class="type">int</span> i23 = <span class="number">0</span>, j23[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">print1</span>(&amp;i23); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">print1</span>(j23);  <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">print2</span>(&amp;i23, <span class="number">1</span>); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">print2</span>(j23, <span class="built_in">sizeof</span>(j23) / <span class="built_in">sizeof</span>(*j23)); <span class="comment">// 0, 1</span></span><br><span class="line">    <span class="keyword">auto</span> b23 = <span class="built_in">begin</span>(j23);</span><br><span class="line">    <span class="keyword">auto</span> e23 = <span class="built_in">end</span>(j23);</span><br><span class="line">    <span class="built_in">print3</span>(b23, e23); <span class="comment">// 0, 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.25</span></span><br><span class="line">    string str1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != argc; ++i)</span><br><span class="line">        str1 += argv[i];</span><br><span class="line">    cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.31</span></span><br><span class="line">    <span class="comment">// 练习6.31:什么情况下返回的引用有效?什么情况下返回常量的引用有效?</span></span><br><span class="line">    <span class="comment">// 【出题思路】</span></span><br><span class="line">    <span class="comment">// 函数返回其结果的过程与它接受参数的过程类似。如果返回的是值，则创建一个未命名的临时对象，并把要返回的值拷贝给这个临时对象；如果返回的是引用，则该引用是它所引对象的别名，,不会真正拷贝对象。</span></span><br><span class="line">    <span class="comment">// 【解答】</span></span><br><span class="line">    <span class="comment">// 如果引用所引的是函数开始之前就已经存在的对象，则返回该引用是有效的；如果引用所引的是函数的局部变量，则随着函数结束局部变量也失效了，此时返回的引用无效。</span></span><br><span class="line">    <span class="comment">// 当不希望返回的对象被修改时，返回对常量的引用。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.33</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vInt = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printVector</span>(vInt, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.55</span></span><br><span class="line">    <span class="comment">// 练习6.55：编写4个函数，分别对两个int值执行加、减、乘、除运算；在上一题创建的vector对象中保存指向这些值的指针。</span></span><br><span class="line">    <span class="keyword">decltype</span>(func11) *p11 = func11, *p21 = func12, *p31 = func13, *p41 = func14;</span><br><span class="line">    vector&lt;<span class="keyword">decltype</span>(func11)*&gt; vF = &#123;p11, p21, p31, p41&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.56</span></span><br><span class="line">    <span class="type">int</span> i11= <span class="number">5</span>, j11 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : vF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Compute</span>(i11, j11, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code相关</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>零散程序</title>
    <url>/2023/08/03/code%E7%9B%B8%E5%85%B3/Python/%E9%9B%B6%E6%95%A3%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="1、读取图片"><a href="#1、读取图片" class="headerlink" title="1、读取图片"></a>1、读取图片</h2><h3 id="（1）PIL库读取"><a href="#（1）PIL库读取" class="headerlink" title="（1）PIL库读取"></a>（1）PIL库读取</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img0 = Image.<span class="built_in">open</span>((<span class="string">&#x27;pic0.jpg&#x27;</span>))  <span class="comment"># pic0.bmp</span></span><br><span class="line">img1 = img0.convert(<span class="string">&quot;RGB&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="（2）cv2库读取"><a href="#（2）cv2库读取" class="headerlink" title="（2）cv2库读取"></a>（2）cv2库读取</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取BMP图像</span></span><br><span class="line">img0 = cv2.imread(<span class="string">&#x27;pic0.bmp)&#x27;</span></span><br><span class="line">img1 = cv2.cvtColor(img0, cv2.COLOR_BGR2RGB)  <span class="comment"># BGR转RGB格式</span></span><br></pre></td></tr></table></figure>

<p><strong>cv2.cvtColor(p1, p2) 是颜色空间转换函数，p1是需要转换的图片，p2是转换成何种格式。</strong></p>
<ul>
<li>cv2.COLOR_BGR2RGB 将BGR格式转换成RGB格式</li>
<li>cv2.COLOR_BGR2GRAY 将BGR格式转换成灰度图片</li>
</ul>
<span id="more"></span>

<h2 id="2、txt文件转excel文件"><a href="#2、txt文件转excel文件" class="headerlink" title="2、txt文件转excel文件"></a>2、txt文件转excel文件</h2><p>txt文件：</p>
<img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20231113194751011.png" alt="image-20231113194751011"  />

<p>其中数据间以逗号和空格分割。</p>
<p>程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文本文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/root/autodl-tmp/STGA/data/SHT/tpr.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data_lines = file.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据解析成二维列表</span></span><br><span class="line">data = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, line.strip().split(<span class="string">&#x27;, &#x27;</span>))) <span class="keyword">for</span> line <span class="keyword">in</span> data_lines]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Pandas DataFrame</span></span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line">df = df.transpose()  <span class="comment"># 将数据按行存储，不加这一句会把所有数据存储在一行中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 DataFrame 写入 Excel 文件</span></span><br><span class="line">df.to_excel(<span class="string">&#x27;/root/autodl-tmp/STGA/data/SHT/output.xlsx&#x27;</span>, index=<span class="literal">False</span>, header=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>解析<code>data = [list(map(float, line.strip().split(&#39;, &#39;))) for line in data_lines]</code>：</p>
<ul>
<li><code>for line in data_lines</code>: 这是一个循环语句，遍历了从文本文件中读取的每一行。</li>
<li><code>line.strip()</code>: <code>strip()</code> 方法用于去除字符串两端的空白字符（包括换行符 <code>\n</code>），确保数据不包含额外的空格或换行。</li>
<li><code>line.strip().split(&#39;, &#39;)</code>: <code>split(&#39;, &#39;)</code> 方法将字符串按照逗号和空格进行分割，返回一个由分割后的字符串组成的列表。</li>
<li><code>list(map(float, ...))</code>: <code>map(float, ...)</code> 将分割后的字符串列表中的每个元素转换为浮点数，<code>list(...)</code> 将其转换为列表。</li>
</ul>
]]></content>
      <categories>
        <category>code相关</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>webserver</title>
    <url>/2023/08/04/%E9%A1%B9%E7%9B%AE/webserver/webserver/</url>
    <content><![CDATA[<h1 id="一、项目基础"><a href="#一、项目基础" class="headerlink" title="一、项目基础"></a>一、项目基础</h1><h2 id="1、Reactor的关键结构"><a href="#1、Reactor的关键结构" class="headerlink" title="1、Reactor的关键结构"></a>1、Reactor的关键结构</h2><p><code>Reactor</code>核心的事件分发机制，即将<code>IO multiplexing</code>拿到的<code>IO</code>事件分发给各个文件描述符<code>fd</code>的事件处理函数。</p>
<p><code>Reactor</code>是一种事件驱动机制，和普通函数调用的不同之处在于：</p>
<ul>
<li>应用程序不是主动地调用某个<code>API</code>来完成处理；其逆置了事件处理流程，<strong>应用程序需要提供相应的接口并注册到<code>Reactor</code>上</strong>，如果相应的事件发生，<code>Reactor</code>将主动调用应用程序注册的接口，这些接口又称为<strong>回调函数</strong>。</li>
</ul>
<span id="more"></span>

<h3 id="（1）EventLoop：-事件循环"><a href="#（1）EventLoop：-事件循环" class="headerlink" title="（1）EventLoop： 事件循环"></a>（1）EventLoop： 事件循环</h3><p>从<code>EventLoop</code>的类定义中可以看出，除了⼀些状态量以外，每个<code>EventLoop</code>持有⼀个<code>Poller</code>的智能指针（对<code>epoll / poll</code>的封装），⼀个⽤于<code>EventLoop</code>之间通信的<code>Channel</code>，⾃⼰的线程<code>id</code>，互斥锁以及装有等待处理函数的<code>vector</code>。很明显，<code>EventLoop</code>并不直接管理各个连接的<code>Channel</code>（⽂件描述符的封装），⽽是通过<code>Poller</code>来进⾏的。<code>EventLoop</code>中最核⼼的函数就是<code>EventLoop::Loop()</code>。</p>
<p><code>EventLoop</code>不可拷贝，且每个线程只能有一个<code>EventLoop</code>对象。<code>EventLoop</code>对象的生命周期通常和其所属的线程一样长。</p>
<p><code>EventLoop</code>的头文件定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class EventLoop : boost::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line"></span><br><span class="line">  EventLoop();</span><br><span class="line">  ~EventLoop();</span><br><span class="line"></span><br><span class="line">  void loop();</span><br><span class="line"></span><br><span class="line">  void assertInLoopThread()</span><br><span class="line">  &#123;</span><br><span class="line">    if (!isInLoopThread())</span><br><span class="line">    &#123;</span><br><span class="line">      abortNotInLoopThread();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool isInLoopThread() const &#123; return threadId_ == CurrentThread::tid(); &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  void abortNotInLoopThread();</span><br><span class="line"></span><br><span class="line">  bool looping_; /* atomic */</span><br><span class="line">  const pid_t threadId_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>loop()</code>的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /*</span><br><span class="line">  	在该函数中会循环执行以下过程：</span><br><span class="line">  		调用Poller::poll()，通过此调用获得一个vector&lt;channel*&gt;activeChannels_的就绪事件集合;</span><br><span class="line">  		再遍历该容器，执行每个Channel的Channel::handleEvent()完成相应就绪事件回调;</span><br><span class="line">  		最后执行pendingFunctors_排队的函数。</span><br><span class="line">  	上述一次循环就是一次Reactor模式完成。</span><br><span class="line">  */</span><br><span class="line">void EventLoop::loop()</span><br><span class="line">&#123;</span><br><span class="line">  assert(!looping_);</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  looping_ = true;</span><br><span class="line">  quit_ = false;</span><br><span class="line"></span><br><span class="line">  while (!quit_)</span><br><span class="line">  &#123;</span><br><span class="line">    activeChannels_.clear();</span><br><span class="line">    poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">    for (ChannelList::iterator it = activeChannels_.begin();</span><br><span class="line">        it != activeChannels_.end(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">      (*it)-&gt;handleEvent();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; stop looping&quot;;</span><br><span class="line">  looping_ = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）Channel：事件分发器"><a href="#（2）Channel：事件分发器" class="headerlink" title="（2）Channel：事件分发器"></a>（2）Channel：事件分发器</h3><p>每个<code>Channel</code>对象自始至终只属于一个<code>EventLoop</code>，因此每个<code>Channel</code>对象都只属于一个<code>IO</code>线程。每个<code>Channel</code>对象只负责一个<code>fd</code>的事件分发，但不拥有这个<code>fd</code>，也不会在析构的时候关闭这个<code>fd</code>。</p>
<p><code>Channel</code>不是基类，用户无须继承，一般使用更上层的封装，如<code>TcpConnection</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Channel : boost::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef boost::function&lt;void()&gt; EventCallback;</span><br><span class="line"></span><br><span class="line">  Channel(EventLoop* loop, int fd);</span><br><span class="line"></span><br><span class="line">  // Channel作为是事件分发器其核心结构是Channel::handleEvent()</span><br><span class="line">  // 该函数调用Channel::handleEventWithGuard()</span><br><span class="line">  // 在其内根据Channel::revents的值分发调用相应的事件回调。</span><br><span class="line">  void handleEvent();</span><br><span class="line">  </span><br><span class="line">  // set Callback()系列函数，接受`Channel`所属的类注册相应的事件回调函数。</span><br><span class="line">  void setReadCallback(const EventCallback&amp; cb)</span><br><span class="line">  &#123; readCallback_ = cb; &#125;</span><br><span class="line">  void setWriteCallback(const EventCallback&amp; cb)</span><br><span class="line">  &#123; writeCallback_ = cb; &#125;</span><br><span class="line">  void setErrorCallback(const EventCallback&amp; cb)</span><br><span class="line">  &#123; errorCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  int fd() const &#123; return fd_; &#125;</span><br><span class="line">  int events() const &#123; return events_; &#125;</span><br><span class="line">  void set_revents(int revt) &#123; revents_ = revt; &#125;</span><br><span class="line">  bool isNoneEvent() const &#123; return events_ == kNoneEvent; &#125;</span><br><span class="line"></span><br><span class="line">  void enableReading() &#123; events_ |= kReadEvent; update(); &#125;</span><br><span class="line">  // void enableWriting() &#123; events_ |= kWriteEvent; update(); &#125;</span><br><span class="line">  // void disableWriting() &#123; events_ &amp;= ~kWriteEvent; update(); &#125;</span><br><span class="line">  // void disableAll() &#123; events_ = kNoneEvent; update(); &#125;</span><br><span class="line"></span><br><span class="line">  // for Poller</span><br><span class="line">  int index() &#123; return index_; &#125;</span><br><span class="line">  void set_index(int idx) &#123; index_ = idx; &#125;</span><br><span class="line"></span><br><span class="line">  EventLoop* ownerLoop() &#123; return loop_; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（3）Polloer：IO-multiplexing的封装"><a href="#（3）Polloer：IO-multiplexing的封装" class="headerlink" title="（3）Polloer：IO multiplexing的封装"></a>（3）Polloer：IO multiplexing的封装</h3><p><code>Poller Class</code>是<code>IO multiplexing</code>的封装，它现在是个具体类，而在<code>muduo</code>中是个抽象基类，因为<code>muduo</code>同时支持<code>poll(2)</code>和<code>epoll(4)</code>两种<code>IO multiplexing</code>机制。<br><code>Poller</code>是<code>EventLoop</code>的间接成员，只供其<code>owner</code> <code>EventLoop</code>在<code>IO</code>线程调用，因此无需加锁。其生命与<code>EventLoop</code>相等。<code>Poller</code>并不拥有<code>Channel</code>，<code>Channel</code>在析构之前必须自己<code>unregister(EventLoop::removeChannel())</code>，避免空悬指针。</p>
<p><code>Poller</code>类的作⽤就是<strong>负责监听⽂件描述符事件是否触发</strong>以及<strong>返回发⽣事件的⽂件描述符以及具体事件</strong>。所以⼀个<code>Poller</code>对象对应⼀个<code>IO</code>多路复⽤模块。在<code>muduo</code>中，⼀个<code>EventLoop</code>对应⼀个<code>Poller</code>。</p>
<p><code>Poller</code>的主要成员变量就三个：</p>
<ol>
<li><code>epollFd_</code>：就是⽤<code>epoll_create</code>⽅法返回的<code>epoll</code>句柄，这个是常识。</li>
<li><code>events_</code>：存放<code>epoll_wait()</code>返回的活动事件（是⼀个结构体）</li>
<li><code>channelMap_ </code>：这个变量是<code>std::unordered_map&lt;int, std::shared_ptr&lt;Channel&gt;&gt;</code>类型，负责记录<br>⽂件描述符<code>fd -&gt; Channel</code>的映射，也帮忙保管所有注册在这个<code>Poller</code>上的<code>Channel</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Epoll::poll(std::vector&lt;sp_Channel&gt;&amp; req) &#123;</span><br><span class="line"> int event_count =</span><br><span class="line"> Epoll_wait(epollFd_, &amp;*events_.begin(), events_.size(), EPOLLWAIT_TIME);</span><br><span class="line"> for(int i = 0; i &lt; event_count; ++i) &#123;</span><br><span class="line"> int fd = events_[i].data.fd;</span><br><span class="line"> sp_Channel temp = channelMap_[fd];</span><br><span class="line"> temp-&gt;setRevents(events_[i].events);</span><br><span class="line"> req.emplace_back(std::move(temp));</span><br><span class="line"> &#125;</span><br><span class="line"> // LOG &lt;&lt; &quot;Epoll finished&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当外部调⽤<code>poll</code>⽅法的时候，该⽅法底层其实是通过<code>epoll_wait</code>获取这个事件监听器上发⽣事件的<code>fd</code>及其对应发⽣的事件，我们知道每个<code>fd</code>都是由⼀个<code>Channel</code>封装的，通过哈希表<code>channelMap_</code>可以根据<code>fd</code>找到封装这个<code>fd</code>的<code>Channel</code>。将<code>IO</code>多路复⽤模块监听到该<code>fd</code>发⽣的事件写进这个<code>Channel</code>中的<code>revents</code>成员变量中。然后把这个<code>Channel</code>装进<code>req</code>中。这样，当外界调⽤完<code>poll</code>之后就能拿到<code>IO</code>多路复⽤模块的<strong>监听结果</strong><code>(std::vector&lt;sp_Channel&gt;&amp; req)</code>。</p>
<h3 id="（4）Reactor模式的核心架构"><a href="#（4）Reactor模式的核心架构" class="headerlink" title="（4）Reactor模式的核心架构"></a>（4）Reactor模式的核心架构</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308051524737.png" alt="Reactor模式的核心架构"></p>
<h2 id="2、日志系统"><a href="#2、日志系统" class="headerlink" title="2、日志系统"></a>2、日志系统</h2><p>服务器的⽇志系统是⼀个<strong>多⽣产者，单消费者</strong>的任务场景：多⽣产者负责把⽇志写⼊缓冲区，单消费者负责把缓冲区中数据写⼊⽂件。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308061016505.png" alt="日志系统框图"></p>
<p><code>LOG</code>的实现参照了<code>muduo</code>，但是⽐<code>muduo</code>要简化⼀点，⼤致的实现如上图所示。</p>
<ul>
<li>⾸先是<code>Logger</code>类，<code>Logger</code>类⾥⾯有<code>Impl</code>类，其实具体实现是<code>Impl</code>类，我也不懂<code>muduo</code>为何要再封装⼀层，那么我们来说说<code>Impl</code>⼲了什么，在初始化的时候<code>Impl</code>会把时间信息存到<code>LogStream</code>的缓冲区⾥，在我们实际⽤<code>Log</code>的时候，实际写⼊的缓冲区也是<code>LogStream</code>，在析构的时候<code>Impl</code>会把当前⽂件和⾏数等信息写⼊到<code>LogStream</code>，再把<code>LogStream</code>⾥的内容写到<code>AsyncLogging</code>的缓冲区中，当然这时候我们要先开启⼀个后端线程⽤于把缓冲区的信息写到⽂件⾥。</li>
<li><code>LogStream</code>类，⾥⾯其实就⼀个<code>Buffer</code>缓冲区，是⽤来暂时存放我们写⼊的信息的。还有就是重载运算符，因为我们采⽤的是<code>C++</code>的流式⻛格。</li>
<li><code>AsyncLogging</code>类，最核⼼的部分，在多线程程序中写<code>Log</code>⽆⾮就是前端往后端写，后端往硬盘写，⾸先将<code>LogStream</code>的内容写到了<code>AsyncLogging</code>缓冲区⾥，也就是前端往后端写，这个过程通过<code>append</code>函数实现，后端实现通过<code>threadfunc</code>函数，两个线程的同步和等待通过互斥锁和条件变量来实现，具体实现使⽤了双缓冲技术。</li>
<li>双缓冲技术的基本思路：准备两块<code>buffer</code>，<code>A</code>和<code>B</code>,前端往<code>A</code>写数据，后端从<code>B</code>⾥⾯往硬盘写数据，当<code>A</code>写满后，交换<code>A</code>和<code>B</code>，如此反复。使⽤两个<code>buffer</code>的好处是在新建⽇志消息的时候不必等待磁盘⽂件操作，也避免每条新⽇志消息都触发后端⽇志线程。换句话说，前端不是将⼀条条⽇志消息分别送给后端，⽽是将多条⽇志消息拼接成⼀个⼤的<code>buffer</code>传送给后端，相当于批处理，减少了线程唤醒的开销。不过实际的实现的话和这个还是有点区别，具体看代码吧。</li>
</ul>
<h3 id="（1）LogSream类"><a href="#（1）LogSream类" class="headerlink" title="（1）LogSream类"></a>（1）LogSream类</h3><p><strong>主要作用：将前端日志写入<code>BufferA</code>。</strong></p>
<p>详细来说，是将各个类型的数据转换为<code>char</code>的形式放入字符数组中，方便后端线程写入硬盘。</p>
<blockquote>
<p><strong>问题思考：<code>int</code>型、浮点型及指针都要如何转换为<code>char</code>的形式？</strong></p>
</blockquote>
<h3 id="（2）AsynLogging类"><a href="#（2）AsynLogging类" class="headerlink" title="（2）AsynLogging类"></a>（2）AsynLogging类</h3><p><strong>主要作用：经前端获得的<code>BufferA</code>放入后端的<code>BufferB</code>中，并且将<code>BufferB</code>的内容最终写入到磁盘中。</strong></p>
<h1 id="二、WebServer"><a href="#二、WebServer" class="headerlink" title="二、WebServer"></a>二、WebServer</h1><h2 id="1、项目框架"><a href="#1、项目框架" class="headerlink" title="1、项目框架"></a>1、项目框架</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-webserver.cpp</span><br><span class="line">-webserver.h</span><br><span class="line">-log</span><br><span class="line">  -log.cpp</span><br><span class="line">  -log.h</span><br><span class="line">  -block_queue.h</span><br></pre></td></tr></table></figure>

<h2 id="2、-webserver-webserver-cpp"><a href="#2、-webserver-webserver-cpp" class="headerlink" title="2、&#x2F;webserver&#x2F;webserver.cpp"></a>2、&#x2F;webserver&#x2F;webserver.cpp</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WebServer();</span><br><span class="line">~WebServer();</span><br><span class="line"></span><br><span class="line">bool dealclientdata();</span><br><span class="line">bool dealwithsignal(bool&amp; timeout, bool&amp; stop_server);</span><br><span class="line">void dealwithread(int sockfd);</span><br><span class="line">void dealwithwrite(int sockfd);</span><br><span class="line">void eventLoop();</span><br></pre></td></tr></table></figure>

<h2 id="3、-webserver-log"><a href="#3、-webserver-log" class="headerlink" title="3、&#x2F;webserver&#x2F;log&#x2F;"></a>3、&#x2F;webserver&#x2F;log&#x2F;</h2><h3 id="（1）block-queue-h"><a href="#（1）block-queue-h" class="headerlink" title="（1）block_queue.h"></a>（1）block_queue.h</h3><p>采用循环数组实现阻塞队列，作为二者的共享缓冲区。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 判断队列是否满了</span><br><span class="line">bool full() </span><br><span class="line"></span><br><span class="line">// 判断队列是否为空</span><br><span class="line">bool empty() </span><br><span class="line"></span><br><span class="line">// 返回队首元素</span><br><span class="line">bool front(T &amp;value)</span><br><span class="line"></span><br><span class="line">// 返回队尾元素</span><br><span class="line">bool back(T &amp;value) </span><br><span class="line"></span><br><span class="line">int size() </span><br><span class="line"></span><br><span class="line">int max_size()</span><br><span class="line"></span><br><span class="line">// 往队列添加元素，需要将所有使用队列的线程先唤醒</span><br><span class="line">// 当有元素push进队列，相当于生产者生产了一个元素</span><br><span class="line">// 若当前没有线程等待条件变量，则唤醒无意义</span><br><span class="line">bool push(const T &amp;item)</span><br><span class="line"></span><br><span class="line">// pop时，如果当前队列没有元素,将会等待条件变量</span><br><span class="line">bool pop(T &amp;item)</span><br><span class="line"></span><br><span class="line">// 增加了超时处理</span><br><span class="line">bool pop(T &amp;item, int ms_timeout)</span><br></pre></td></tr></table></figure>

<h3 id="（2）log-cpp"><a href="#（2）log-cpp" class="headerlink" title="（2）log.cpp"></a>（2）log.cpp</h3><p><strong>完成日志文件的初始化和内容的写入。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time_t t = time(NULL);</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>time_t t</code>: 声明了一个名为 <code>t</code> 的变量，其数据类型是 <code>time_t</code>，这是 C 语言标准库中用来表示时间的数据类型。</p>
</li>
<li><p><code>time(NULL)</code>: 这是调用 <code>time()</code> 函数的语法，它接受一个参数（通常是一个指向 <code>time_t</code> 对象的指针），用于存储获取到的时间值。在这里，传递了 <code>NULL</code>，表示我们只是想要获取当前系统时间，不需要保存时间值到任何变量中。</p>
<p><code>time(NULL)</code> 的返回值是当前系统时间（以秒为单位）距离某个固定时间点（通常是 <code>1970 年 1 月 1 日 00:00:00 UTC</code>，也称为 <code>Unix</code> 时间戳）的秒数。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct tm *sys_tm = localtime(&amp;t);</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>struct tm *sys_tm</code>: 声明了一个指针变量 <code>sys_tm</code>，该指针指向 <code>struct tm</code> 结构体，用于存储本地时间的各个组成部分，如年、月、日、时、分、秒等。</p>
</li>
<li><p><code>localtime(&amp;t)</code>: 这是调用 <code>localtime()</code> 函数的语法，它接受一个 <code>time_t</code> 类型的指针作为参数，并返回一个指向 <code>struct tm</code> 结构体的指针。函数的作用是将传入的时间值（由 <code>time_t</code> 类型的变量 <code>t</code> 表示）转换为本地时间，并存储在 <code>struct tm</code> 结构体中。</p>
<p>注意，<code>localtime()</code> 函数将时间从 UTC 时间转换为本地时间，考虑了时区和夏令时等因素。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>项目</category>
        <category>webserver</category>
      </categories>
  </entry>
</search>
