<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MoCoDAD</title>
    <url>/2024/04/08/%E7%A7%91%E7%A0%94/MoCoDAD/</url>
    <content><![CDATA[<h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">├── config  <span class="comment">// 保存了三个数据集相关的配置文件</span></span><br><span class="line">│   ├── Avenue</span><br><span class="line">│   │   ├── mocodad_test.yaml</span><br><span class="line">│   │   └── mocodad_train.yaml</span><br><span class="line">│   ├── STC</span><br><span class="line">│   │   ├── mocodad_test.yaml</span><br><span class="line">│   │   └── mocodad_train.yaml</span><br><span class="line">│   └── UBnormal</span><br><span class="line">│      ├── mocodad-latent_train.yaml</span><br><span class="line">│       ├── mocodad-latent_train.yaml</span><br><span class="line">│       ├── mocodad_test.yaml</span><br><span class="line">│       └── mocodad_train.yaml</span><br><span class="line">├── environment.yaml  <span class="comment">// 该模型需要的库依赖</span></span><br><span class="line">├── eval_MoCoDAD.py</span><br><span class="line">├── predict_MoCoDAD.py</span><br><span class="line">├── train_MoCoDAD.py</span><br><span class="line">├── models</span><br><span class="line">│   ├── common</span><br><span class="line">│   │   └── components.py</span><br><span class="line">│   ├── gcae</span><br><span class="line">│   │   └── stsgcn.py</span><br><span class="line">│   ├── mocodad_latent.py</span><br><span class="line">│   ├── mocodad.py</span><br><span class="line">│   └── stsae</span><br><span class="line">│       ├── stsae.py</span><br><span class="line">│       └── stsae_unet.py</span><br><span class="line">└── utils</span><br><span class="line">    ├── argparser.py</span><br><span class="line">    ├── data.py</span><br><span class="line">    ├── dataset.py</span><br><span class="line">    ├── dataset_utils.py</span><br><span class="line">    ├── diffusion_utils.py</span><br><span class="line">    ├── ema.py</span><br><span class="line">    ├── eval_utils.py</span><br><span class="line">    ├── get_robust_data.py</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── model_utils.py</span><br><span class="line">    ├── preprocessing.py</span><br><span class="line">    └── tools.py</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>MoCoDAD &amp; MoCoDADlatent</p>
<h2 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> utils.dataset <span class="keyword">import</span> get_dataset_and_loader</span><br></pre></td></tr></table></figure>

<h2 id="EMA"><a href="#EMA" class="headerlink" title="EMA"></a>EMA</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> utils.ema <span class="keyword">import</span> EMACallback</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>科研</category>
      </categories>
  </entry>
  <entry>
    <title>OpenPose原理及编译</title>
    <url>/2023/12/25/%E7%A7%91%E7%A0%94/OpenPose%E5%8E%9F%E7%90%86%E5%8F%8A%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="1-前提思考"><a href="#1-前提思考" class="headerlink" title="1 前提思考"></a>1 前提思考</h2><p>1、姿态估计中的关键任务是什么？</p>
<p>识别人体骨干躯干的关键点，并进行定位与拼接。</p>
<span id="more"></span>

<p>2、姿态估计中的难点是什么？</p>
<p><strong>（1）遮挡；（2）匹配。</strong></p>
<p>3、COCO数据集的关键点有几个，分别是？</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251524168.png" alt="COCO数据集关键点" style="zoom: 50%;" />

<p>数据集中是<code>17</code>个点，实际上训练时候还要加上<code>1</code>个脖子的点，共<code>18</code>个点。</p>
<p>4、姿态估计方法分为几个大类？</p>
<p>（1）<code>Top-down</code>（自顶向下）：先检测所有的人，再对每个框的人进行姿态估计输出结果</p>
<p>优点：准确率高，点的回归率高；</p>
<p>缺点：算法性能依赖检测效果，复杂度较高，实时性比较差。</p>
<p>主要用于一些离线的项目，对实时性没要求。</p>
<p>（2）<code>bottom-up</code>（自底向上）：先检测所有关键点，再进行匹配连接</p>
<p>优点：计算量较小，可以达到实时性的效果；</p>
<p>缺点：精度较差，匹配策略比较复杂。</p>
<h2 id="2-论文解读"><a href="#2-论文解读" class="headerlink" title="2 论文解读"></a>2 论文解读</h2><p>论文地址：<a href="https://arxiv.org/pdf/1611.08050.pdf">https://arxiv.org/pdf/1611.08050.pdf</a></p>
<h3 id="1、网络框架"><a href="#1、网络框架" class="headerlink" title="1、网络框架"></a>1、网络框架</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251524273.png" alt="网络整体流程图">	<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251532476.jpg" alt="网络框架1"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251534898.png" alt="网络框架2"></p>
<p>其中的重点：</p>
<p>（1）关键点的<code>heatmap</code>标注生成，采用高斯热度图的方式；</p>
<p>（2）<code>PAF</code>：部分亲和域。这也是论文中的重点和难点；</p>
<p>（3）匹配策略：匈牙利匹配。</p>
<h3 id="2、数据制作"><a href="#2、数据制作" class="headerlink" title="2、数据制作"></a>2、数据制作</h3><p>采用的数据集为<code>COCO</code>数据集，其中人体骨骼点的标注信息为<code>[x, y, label]</code>。</p>
<p><code>label</code>取值为<code>0</code>、<code>1</code>、<code>2</code>，分别表示不存在、遮挡、正常，其中不存在的关键点是需要去除的。</p>
<p>（1）关键点高斯热力图实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">putGaussianMaps</span>(<span class="params">center, accumulate_confid_map, sigma, grid_y, grid_x, stride</span>):</span><br><span class="line"></span><br><span class="line">    start = stride / <span class="number">2.0</span> - <span class="number">0.5</span></span><br><span class="line">    y_range = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(grid_y))]</span><br><span class="line">    x_range = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(grid_x))]</span><br><span class="line">    xx, yy = np.meshgrid(x_range, y_range)      <span class="comment"># 构建棋盘</span></span><br><span class="line">    xx = xx * stride + start                    <span class="comment"># 每个点在原始图像上的位置</span></span><br><span class="line">    yy = yy * stride + start</span><br><span class="line">    d2 = (xx - center[<span class="number">0</span>]) ** <span class="number">2</span> + (yy - center[<span class="number">1</span>]) ** <span class="number">2</span>  <span class="comment"># 计算每个点和GT点的距离</span></span><br><span class="line">    exponent = d2 / <span class="number">2.0</span> / sigma / sigma                 <span class="comment"># 这里在做一个高斯计算</span></span><br><span class="line">    mask = exponent &lt;= <span class="number">4.6052</span>                           <span class="comment"># 将在这个阈值范围内的点用True记录</span></span><br><span class="line">    cofid_map = np.exp(-exponent)                       <span class="comment"># 这里做一个标准化</span></span><br><span class="line">    cofid_map = np.multiply(mask, cofid_map)            <span class="comment"># 取出对应关系为True的点</span></span><br><span class="line">    accumulate_confid_map += cofid_map                  <span class="comment"># 将每个点计算的结果都累加到上一次的特征中</span></span><br><span class="line">    accumulate_confid_map[accumulate_confid_map &gt; <span class="number">1.0</span>] = <span class="number">1.0</span>      <span class="comment"># 对结果大于1的值，只取1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> accumulate_confid_map    <span class="comment"># 返回热力图（heatmap）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）PAF数据计算的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">putVecMaps</span>(<span class="params">centerA, centerB, accumulate_vec_map, count, grid_y, grid_x, stride</span>):</span><br><span class="line">    centerA = centerA.astype(<span class="built_in">float</span>)</span><br><span class="line">    centerB = centerB.astype(<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line">    thre = <span class="number">1</span>  <span class="comment"># 表示宽度，也就是一个设定好的参数</span></span><br><span class="line">    centerB = centerB / stride  <span class="comment"># 缩放比例特定到特征图中</span></span><br><span class="line">    centerA = centerA / stride</span><br><span class="line"></span><br><span class="line">    limb_vec = centerB - centerA  <span class="comment"># 求出两个点的向量</span></span><br><span class="line">    norm = np.linalg.norm(limb_vec)  <span class="comment"># 是需要求单位向量，所以先计算范数，也就是向量模长</span></span><br><span class="line">    <span class="keyword">if</span> (norm == <span class="number">0.0</span>):  <span class="comment"># 这里表示两个点基本重合了</span></span><br><span class="line">        <span class="comment"># print &#x27;limb is too short, ignore it...&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> accumulate_vec_map, count</span><br><span class="line">    limb_vec_unit = limb_vec / norm  <span class="comment"># 向量除以模长，得到单位向量</span></span><br><span class="line">    <span class="comment"># print &#x27;limb unit vector: &#123;&#125;&#x27;.format(limb_vec_unit)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># To make sure not beyond the border of this two points</span></span><br><span class="line">    <span class="comment"># 得到所有可能存在方向的区域(这里就用到了之前的超参数阈值)</span></span><br><span class="line">    min_x = <span class="built_in">max</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="built_in">min</span>(centerA[<span class="number">0</span>], centerB[<span class="number">0</span>]) - thre)), <span class="number">0</span>)</span><br><span class="line">    max_x = <span class="built_in">min</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="built_in">max</span>(centerA[<span class="number">0</span>], centerB[<span class="number">0</span>]) + thre)), grid_x)</span><br><span class="line">    min_y = <span class="built_in">max</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="built_in">min</span>(centerA[<span class="number">1</span>], centerB[<span class="number">1</span>]) - thre)), <span class="number">0</span>)</span><br><span class="line">    max_y = <span class="built_in">min</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="built_in">max</span>(centerA[<span class="number">1</span>], centerB[<span class="number">1</span>]) + thre)), grid_y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 得到一个可能存在向量的矩形框</span></span><br><span class="line">    range_x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">int</span>(min_x), <span class="built_in">int</span>(max_x), <span class="number">1</span>))</span><br><span class="line">    range_y = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">int</span>(min_y), <span class="built_in">int</span>(max_y), <span class="number">1</span>))</span><br><span class="line">    xx, yy = np.meshgrid(range_x, range_y)  <span class="comment"># 制作一个网格</span></span><br><span class="line">    ba_x = xx - centerA[<span class="number">0</span>]  <span class="comment"># the vector from (x,y) to centerA 根据位置判断是否在该区域上（分别得到X和Y方向的）</span></span><br><span class="line">    ba_y = yy - centerA[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 向量叉乘根据阈值选择赋值区域，任何向量与单位向量的叉乘即为四边形的面积</span></span><br><span class="line">    <span class="comment"># 这里是重点步骤，也就是论文中的公式，表示计算出两个向量组成四边形的面积</span></span><br><span class="line">    limb_width = np.<span class="built_in">abs</span>(ba_x * limb_vec_unit[<span class="number">1</span>] - ba_y * limb_vec_unit[<span class="number">0</span>])</span><br><span class="line">    mask = limb_width &lt; thre  <span class="comment"># mask is 2D （小于阈值的表示在该区域上）</span></span><br><span class="line"></span><br><span class="line">    vec_map = np.copy(accumulate_vec_map) * <span class="number">0.0</span>  <span class="comment"># 构建一个全为0的矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这行代码主要作用是将mask扩展一个维度并且赋值给vec_map数组</span></span><br><span class="line">    vec_map[yy, xx] = np.repeat(mask[:, :, np.newaxis], <span class="number">2</span>, axis=<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 在该区域上的都用对应的方向向量表示（根据mask结果表示是否在，通过乘法的方式）</span></span><br><span class="line">    vec_map[yy, xx] *= limb_vec_unit[np.newaxis, np.newaxis, :]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># #在特征图中（46*46）中 哪些区域是该躯干所在区域，判断x或者y向量都不为0</span></span><br><span class="line">    mask = np.logical_or.reduce(</span><br><span class="line">        (np.<span class="built_in">abs</span>(vec_map[:, :, <span class="number">0</span>]) &gt; <span class="number">0</span>, np.<span class="built_in">abs</span>(vec_map[:, :, <span class="number">1</span>]) &gt; <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每次返回的accumulate_vec_map都是平均值，现在还原成实际值</span></span><br><span class="line">    accumulate_vec_map = np.multiply(</span><br><span class="line">        accumulate_vec_map, count[:, :, np.newaxis])</span><br><span class="line">    accumulate_vec_map += vec_map  <span class="comment"># 加上当前关键点位置形成的向量</span></span><br><span class="line">    count[mask == <span class="literal">True</span>] += <span class="number">1</span>  <span class="comment"># 该区域计算次数都+1</span></span><br><span class="line"></span><br><span class="line">    mask = count == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    count[mask == <span class="literal">True</span>] = <span class="number">1</span>  <span class="comment"># 没有被计算过的地方就等于自身（因为一会要除法）</span></span><br><span class="line"></span><br><span class="line">    accumulate_vec_map = np.divide(accumulate_vec_map, count[:, :, np.newaxis])  <span class="comment"># 算平均向量</span></span><br><span class="line">    count[mask == <span class="literal">True</span>] = <span class="number">0</span>  <span class="comment"># 还原回去</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> accumulate_vec_map, count</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两个函数是最重要的两个部分，也就是对训练数据的处理，生成出需要的训练数据。</p>
<h3 id="3、预测推理"><a href="#3、预测推理" class="headerlink" title="3、预测推理"></a>3、预测推理</h3><p>预测模型这里，在官方源码中是将<code>paf</code>的处理封装在一个<code>cpp</code>库中，<strong>通过编译得到静态库，代码中可以调用</strong>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">swig -python -c++ pafprocess.i</span><br><span class="line">python3 setup.py build_ext --inplace</span><br></pre></td></tr></table></figure>

<p>这里PAF的处理主要是采用积分计算的方式，也就是对于连线的点的方向选择，采用积分的方式计算最佳连线策略。</p>
<h2 id="3-OpenPose-Windows-cpu-only-编译"><a href="#3-OpenPose-Windows-cpu-only-编译" class="headerlink" title="3 OpenPose_Windows_cpu_only 编译"></a>3 OpenPose_Windows_cpu_only 编译</h2><p>主要步骤参考：</p>
<p><a href="https://blog.csdn.net/qq_51209492/article/details/124185106?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%AE%89%E8%A3%85openpose%E5%B9%B6%E4%BD%BF%E7%94%A8python%E8%B0%83%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-124185106.142%5Ev96%5Epc_search_result_base7&spm=1018.2226.3001.4187">CSDN——win10环境下下载安装openpose(only cpu)并在pycharm中运行代码（超详细）</a></p>
<p>基本按照这上面来走就可以正确编译，但其中要注意以下几点：</p>
<p><strong>1、<code>bat</code>批处理命令运行时给的网站我根本无法访问，一直<code>retry</code></strong></p>
<p>最后选择用迅雷下载，然后放进<code>\openpose\3rdparty\windows</code>文件夹下。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312272200864.png" alt="image-20231227220003816"></p>
<p>同时这里面的<code>caffe_cpu</code>不是用这4个<code>bat</code>文件下载的，但是由于网址同样进不去，也选择先用迅雷下载好后放进去。</p>
<p>我这里的4个<code>zip</code>文件大小显示为<code>0kb</code>似乎是<code>cmake</code>编译后自己更改的，不用去管。</p>
<p><strong>2、用迅雷提前下载好<code>\openpose\models</code>后，<code>cmake</code>编译依然会重新下载模型。</strong></p>
<p>这里我参考了<a href="https://zhuanlan.zhihu.com/p/446981890">OpenPose-CPU版本安装</a>的方法：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312272207425.png" alt="image-20231227220706339"></p>
<p>修改<code>CmakeLists.txt</code>文件后就不会再重新下载模型了。</p>
<p><strong>3、用<code>CMAKE</code>编译<code>openpose</code>项目时，一定要在第一次<code>configure</code>之前，点击<code>Add Entry</code>选择<code>Python</code>版本。</strong></p>
<p>如下所示：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312272202637.png" alt="在这里插入图片描述"></p>
<p>实际上这一步就是要确保在<code>cmake</code>编译时访问的<code>python</code>解释器和最后在<code>pycharm</code>中运行时选择的python解释器一致，否则可能会在<code>pycharm</code>中报错<code>No module named pyopenpose</code>。</p>
<p>我第一次在这里就是因为没有关注这个细节，导致<code>cmake</code>选择的是<code>python 3.6.5</code>的编译器，而<code>pycharm</code>选择的是<code>3.7.6</code>的编译器，出现错误。</p>
<p><strong>4、最好采用本地<code>python</code>解释器，不要用<code>anaconda</code>虚拟环境。</strong></p>
<p>我也不知道为什么虚拟环境会报错，可能还是路径的问题吧。</p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
  </entry>
  <entry>
    <title>vscode相关</title>
    <url>/2023/08/01/%E6%97%A0%E4%BB%8E%E5%B1%9E%E7%B1%BB%E5%88%AB/vscode%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="1、-vscode连接阿里云如何免密？"><a href="#1、-vscode连接阿里云如何免密？" class="headerlink" title="1、 vscode连接阿里云如何免密？"></a>1、 vscode连接阿里云如何免密？</h1><h2 id="windows端："><a href="#windows端：" class="headerlink" title="windows端："></a><code>windows</code>端：</h2><p>1）在<code>cmd</code>中输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>

<p>在<code>c:\Users\用户名\\.ssh</code>下会生成私钥和公钥。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308021257775.png" alt="image-20230802125702563"></p>
<p>2）复制<code>id_rsa.pub</code>中的内容</p>
<span id="more"></span>

<h2 id="linux端："><a href="#linux端：" class="headerlink" title="linux端："></a><code>linux</code>端：</h2><p>1）输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>生成<code>linux</code>端的密钥，进入<code>/root/.ssh/id_rsa</code>路径下。</p>
<p>2）创建一个文件，名字叫<code>authorized_keys</code></p>
<p>3）把复制的<code>windows</code>公钥粘贴到<code>authorized_keys</code>中，保存退出</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202308012055885.png" alt="Snipaste_2023-08-01_20-46-53"></p>
<h1 id="2、Linux环境使用VSCode调试简单C-代码"><a href="#2、Linux环境使用VSCode调试简单C-代码" class="headerlink" title="2、Linux环境使用VSCode调试简单C++代码"></a>2、Linux环境使用VSCode调试简单C++代码</h1><p>参考教程：<a href="https://blog.csdn.net/hypc9709/article/details/129413482?ops_request_misc=&request_id=&biz_id=102&utm_term=vscode%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-129413482.142%5Ev96%5Epc_search_result_base7&spm=1018.2226.3001.4187">Linux环境使用VSCode调试简单C++代码</a></p>
<h2 id="1）终端命令行进行编译、调试"><a href="#1）终端命令行进行编译、调试" class="headerlink" title="1）终端命令行进行编译、调试"></a>1）终端命令行进行编译、调试</h2><h2 id="2）通过VSCode进行编译、调试"><a href="#2）通过VSCode进行编译、调试" class="headerlink" title="2）通过VSCode进行编译、调试"></a>2）通过VSCode进行编译、调试</h2><h3 id="（1）前置条件"><a href="#（1）前置条件" class="headerlink" title="（1）前置条件"></a>（1）前置条件</h3><p>插件<code>C/C++</code>已安装；<code>g++编译器</code>和<code>gdb调试器</code>已安装。</p>
<h3 id="（2）配置tasks-json"><a href="#（2）配置tasks-json" class="headerlink" title="（2）配置tasks.json"></a>（2）配置<code>tasks.json</code></h3><ul>
<li><p>在<code>VSCode</code>的主菜单中，选择<code>Terminal&gt;Configure Default Build Task</code></p>
</li>
<li><p>出现一个下拉菜单，显示<code>C++</code>编译器的各种预定义编译任务。选择<code>C/C++: g++ build active file</code>（如果配置了中文，会显示<code>C/C++: g++ 生成活动文件</code>）</p>
</li>
<li><p>选择后，<code>VSCode</code>会自动生成一个<code>.vscode</code>文件夹和<code>tasks.json</code>文件，如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312071610116.png" alt="image-20231207144919415"></p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++ 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/g++&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>tasks.json</code>的作用是告诉<code>VSCode</code>如何编译程序，因此从其中的<code>Command</code>和<code>args</code>可以看出，实际上是执行了以下命令：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/usr/bin/g++ -g $&#123;file&#125; -o $&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li><code>$&#123;file&#125;</code>：当前活动文件是<code>VSCode</code>当前查看的文件，如<code>Main.cpp</code>；</li>
<li><code>$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;</code>：用于获取当前文件的目录和不包含扩展名的文件名，如<code>Main</code>。</li>
</ul>
<h3 id="（3）执行编译"><a href="#（3）执行编译" class="headerlink" title="（3）执行编译"></a>（3）执行编译</h3><ul>
<li><p><strong>回到需要执行编译的文件</strong>（这一步很重要，否则<code>\$&#123;file&#125;</code>和<code>$&#123;fileDirname&#125;</code>这些变量都会错）；</p>
</li>
<li><p>快捷键<code>ctrl+shift+B</code>或从菜单中选择运行：<strong>Terminal -&gt; Run Build Task</strong>，即可执行<code>tasks.json</code>中指定的编译过程；</p>
<p>编译任务完成后，会出现终端提示，对于成功的g++编译，输出如下：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312071609602.png" alt="image-20231207150223290"></p>
<p>（这里我将<code>tasks.json</code>中的<code>&quot;$&#123;file&#125;&quot;</code>项更改为<code>&quot;$&#123;fileDirname&#125;/*.cpp&quot;</code></p>
<h3 id="（4）调试文件"><a href="#（4）调试文件" class="headerlink" title="（4）调试文件"></a>（4）调试文件</h3><p>对需要调试的文件设置断点，选择<code>Debug C/C++ file</code>进行调试。</p>
<h3 id="（5）个性化配置launch-json"><a href="#（5）个性化配置launch-json" class="headerlink" title="（5）个性化配置launch.json"></a>（5）个性化配置<code>launch.json</code></h3><blockquote>
<p>这里<code>launch.json</code>的作用就是告诉<code>VSCode</code>如何调用<code>gdb调试器</code>。</p>
</blockquote>
<p>如果想要在调试&#x2F;运行程序时添加参数，只需要把参数添加在<code>&quot;args&quot;</code>选项中即可。</p>
<h4 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h4><p>在<code>VSCode</code>中编译、调试一个简单的<code>.cpp</code>文件，所需要做的就是：</p>
<ol>
<li>在<code>tasks.json</code>中调用<code>g++</code>生成一个可执行二进制文件；</li>
<li>在<code>launch.json</code>中调用<code>gdb</code>对生成的可执行文件进行调试。</li>
</ol>
<h3 id="（7）复用C-配置"><a href="#（7）复用C-配置" class="headerlink" title="（7）复用C++配置"></a>（7）复用C++配置</h3><p>上面的过程已经完成了在<code>VSCode</code>中调试<code>Linux</code>环境下的<code>C++</code>代码的配置，但只适用于当前工作空间。</p>
<p>如果想要在其他的工程文件夹下复用这种配置，只需要把<code>tasks.json</code>和<code>launch.json</code>文件复制到新文件夹下的<code>.vscode</code>目录下，然后根据需要改变对应的源文件和可执行文件的名称即可。</p>
<h1 id="3、VSCode自动生成头文件的-ifndef-define-endif"><a href="#3、VSCode自动生成头文件的-ifndef-define-endif" class="headerlink" title="3、VSCode自动生成头文件的 #ifndef #define #endif"></a>3、VSCode自动生成头文件的 #ifndef #define #endif</h1><p>参考这篇博客：<a href="https://blog.csdn.net/p1279030826/article/details/123851420">VSCode自动生成头文件的 #ifndef #define #endif</a></p>
]]></content>
      <categories>
        <category>无从属类别</category>
      </categories>
  </entry>
  <entry>
    <title>代码随想录</title>
    <url>/2024/04/09/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/</url>
    <content><![CDATA[<h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><h2 id="1、二分法"><a href="#1、二分法" class="headerlink" title="1、二分法"></a>1、二分法</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h3><p><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></p>
<ol>
<li><p>本题我采用左闭右开的取法，因此：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// &amp;&amp;</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br></pre></td></tr></table></figure>

<p>当<code>nums[mid]</code>和<code>target</code>不相等需要更新<code>left/right</code>时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">left = mid + <span class="number">1</span>;  <span class="comment">// left是取得到的</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">right = mid;	 <span class="comment">// right是取不到的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新<code>mid</code>时采用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h3><p><a href="https://leetcode.cn/problems/search-insert-position/submissions/521863494/">35. 搜索插入位置</a></p>
<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h3><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<p>这道题做的时候卡了很久，最开始采用前闭后开的区间，但结果是错的，改成前闭后闭的区间就正确了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">searchLeftRange</span>(nums, target);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">searchRightRange</span>(nums, target);</span><br><span class="line">        <span class="comment">// 情况一</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">-2</span> || r == <span class="number">-2</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="comment">// 情况三</span></span><br><span class="line">        <span class="keyword">if</span> (r - l &gt; <span class="number">1</span>) <span class="keyword">return</span> &#123;l + <span class="number">1</span>, r - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 情况二</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchLeftRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">-2</span>;</span><br><span class="line">        <span class="comment">// 寻找左边界</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                l = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchRightRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">-2</span>;</span><br><span class="line">        <span class="comment">// 寻找右边界</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                r = left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69. x的平方根"></a>69. x的平方根</h3><p><a href="https://leetcode.cn/problems/sqrtx/">69. x的平方根</a></p>
<p>1、由于y&#x3D;√x的图像是单调递增的，符合二分查找的条件，因此本题可采用二分查找的方式解决。</p>
<p>2、题目所述x为非负整数，因此left应该初始化为1而非0。</p>
<p>3、<strong>最后结束循环，返回右边界，主要是因为平方根是向下取整，例如 8 的平方跟是 2，而循环结束的条件又是 l &gt; r，因此最后返回右边界 r</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int left = 0;</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = x;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// int tmp = mid * mid;</span></span><br><span class="line">            <span class="comment">// if (mid == x / mid) &#123;</span></span><br><span class="line">            <span class="comment">//     return mid;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">if</span> (mid &lt; x / mid) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; x / mid)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return -1;</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、双指针法"><a href="#2、双指针法" class="headerlink" title="2、双指针法"></a>2、双指针法</h2><p>双指针法：通过一个快指针和一个慢指针在一个for循环下完成两个for循环的工作</p>
<ol>
<li><p><strong>快慢指针</strong>：<strong>快慢指针通常都从下标为0的地方开始走</strong>，当快指针达到末尾时，慢指针通常还在中间位置。</p>
</li>
<li><p><strong>左右指针</strong>：<strong>左右指针分别从数组的两端出发</strong>，根据问题的要求移动指针，并通过调整指针位置来实现问题的解决。</p>
</li>
<li><p><strong>滑动窗口</strong>：常用于解决数组或字符串中的子数组或子串问题，如最小覆盖子串、最长无重复字符的子串等。滑动窗口由左右指针定义，<strong>左指针指向窗口的起始位置，右指针指向窗口的结束位置，通过移动两个指针来扩大或缩小窗口</strong>，从而找到满足特定条件的子数组或子串。</p>
<p>在采用滑动窗口解决问题时，主要确定以下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
</li>
</ol>
<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></p>
<ul>
<li><p>解题思路</p>
<p>本题要求：<em>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组</em>，看到这样的要求时，就要很快地联想到<strong>双指针法（快慢指针法）</strong>。</p>
<ol>
<li><code>fast</code>和<code>slow</code>同时指向数组开始；</li>
<li>判断是否<code>nums[fast]==val</code>，若相等，<code>fast</code>前移一位，继续判断，直到<code>nums[fast]!=val</code>；</li>
<li>此时，将<code>nums[fast]</code>赋值给<code>nums[slow]</code>，<code>slow</code>前移一位；</li>
<li>循环执行步骤<strong>2&amp;3</strong>，直到<code>fast</code>遍历到数组末尾。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[fast] == val) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">                <span class="keyword">if</span> (fast == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> slow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></p>
<ul>
<li><p>解题思路</p>
<p>由于题目中已经说了“整数数组<code>nums</code>是非递减的”，那么在包含负数的情况下，平方后最大值就只能位于数组的两端。因此可以采用<strong>双指针法</strong>，用两个指针分别指向最左边和最右边，依次向中间移动。</p>
<ol>
<li>用两个指针<code>l</code>和<code>r</code>分别指向最左边和最右边，同时定义一个新的数组作为结果数组返回；</li>
<li>判断左右两边谁平方后的值更大，将大的那个放入结果数组的最右边；</li>
<li>更新指针；</li>
<li>重复步骤2&amp;3，直到原数组遍历完毕。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> index = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> tmpl = nums[l] * nums[l];</span><br><span class="line">            <span class="type">int</span> tmpr = nums[r] * nums[r];</span><br><span class="line">            <span class="keyword">if</span> (tmpl &lt; tmpr) &#123;</span><br><span class="line">                res[index] = tmpr;</span><br><span class="line">                index--;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[index] = tmpl;</span><br><span class="line">                index--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></p>
<ul>
<li><p>解题思路</p>
<p><strong>当看到题目中出现“子数组”、“子序列”等时，一般就要想到采用滑动窗口来解决。</strong>但这里我最开始想的是下面这种解法，这样实际上就是一种暴力的思想，而非双指针的思想。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样写会超时</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="type">int</span> sum = nums[i];</span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        sum += nums[j];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = j-i+<span class="number">1</span>;</span><br><span class="line">            len = tmp &lt; len ? tmp : len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，在本题中窗口就是满足其<code>和&gt;=target</code>的长度最小的连续子数组。移动窗口的起始位置是为了在满足条件的情况下缩小窗口，移动窗口的结束位置是为了遍历数组的所有元素。</p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                <span class="type">int</span> sublen = j-i+<span class="number">1</span>;</span><br><span class="line">                len = sublen &lt; len ? sublen : len;</span><br><span class="line">                sum -= nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == INT32_MAX) len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、循环不变原则"><a href="#3、循环不变原则" class="headerlink" title="3、循环不变原则"></a>3、循环不变原则</h2><h3 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59. 螺旋矩阵II"></a>59. 螺旋矩阵II</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵II</a></p>
<ul>
<li><p>解题思路</p>
<p>本题实际上就是考察了<strong>循环不变量原则</strong>，要注意选择好了遍历<strong>区间的开闭</strong>后就一定要贯彻其开闭原则。</p>
<p>将整个过程分为从外到内“画”每一圈的过程。在此基础上，每一圈又包含4步：</p>
<ol>
<li>从左至右</li>
<li>从上至下</li>
<li>从右至左</li>
<li>从下至上</li>
</ol>
<p>这样经过一圈之后，就会回到这一圈的起点，接下来遍历下一圈，直到结束为止。</p>
<p>要注意几个地方：</p>
<ol>
<li><p>每一圈的起始坐标依次为<code>(1, 1)</code>，<code>(2, 2)</code>，….，因此每一圈结束后，<code>x</code>和<code>y</code>的起始位置都要分别加1才能进入下一圈；</p>
</li>
<li><p>循环的结束条件就是遍历到了最后一圈，其中要循环的圈数是<code>n/2</code>，这个可以举几个例子推导；另外一个要注意的就是当<code>n</code>为奇数时，最内圈是一个单独的值<code>n^2</code>，需要单独填充；</p>
</li>
<li><p>在遍历每一圈的4条边时，坚持左闭右开的原则：也就是说，每一条边的最后<code>n</code>个值属于下一条边。如下图所示，这是第一圈的情况。一定要记得设置一个<code>offset</code>，<strong>因为每遍历一圈，每条边的右边界就要收缩一位。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404102110076.png" alt="image-20240410211008731" style="zoom:33%;" /></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>;     <span class="comment">// 定义每一圈的起始坐标位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>;               <span class="comment">// 定义循环几圈</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>;                 <span class="comment">// 定义每一条边遍历的长度 </span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;                  <span class="comment">// 用来给矩阵赋值</span></span><br><span class="line">        <span class="keyword">while</span> (loop--) &#123;</span><br><span class="line">            <span class="type">int</span> i = startx;</span><br><span class="line">            <span class="type">int</span> j = starty;</span><br><span class="line">            <span class="comment">// 从左至右</span></span><br><span class="line">            <span class="keyword">for</span> (j; j&lt;n-offset; ++j) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="comment">// 从上至下</span></span><br><span class="line">            <span class="keyword">for</span> (i; i&lt;n-offset; ++i) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从右至左</span></span><br><span class="line">            <span class="keyword">for</span> (j; j&gt;starty; --j) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从下至上</span></span><br><span class="line">            <span class="keyword">for</span> (i; i&gt;startx; --i) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset++;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            res[n/<span class="number">2</span>][n/<span class="number">2</span>] = n*n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h1><p>实际上感觉链表的题都可以用快慢指针来解决。</p>
<h2 id="1、链表的定义"><a href="#1、链表的定义" class="headerlink" title="1、链表的定义"></a>1、链表的定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	ListNode *next;</span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、删除链表元素"><a href="#2、删除链表元素" class="headerlink" title="2、删除链表元素"></a>2、删除链表元素</h2><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><p>举例来说，从<code>2-&gt;6-&gt;3</code>中删除节点6，需要完成以下几步：</p>
<p>（1）保存节点6，便于后续释放；</p>
<p>（2）将2的next改完3；</p>
<p>（3）释放原节点6。</p>
</li>
<li><p>注意要引入一个虚拟头结点，这样就可以避免在操作时还要区分头节点和非头节点两种情况。并且注意在最后返回真正的头节点时，返回的是<code>dummyhead-&gt;next</code>。</p>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *dummynode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummynode-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode *cur = dummynode;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode *tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummynode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummynode;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a>707. 设计链表</h3><p><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></p>
<ul>
<li><p>解题思路</p>
<p>这里有一个要注意的点，那就是对于这个<code>index</code>，在访问操作和增删操作时，遍历停止的位置是不同的：</p>
<ol>
<li>对于访问操作，需要<code>cur</code>正好停在<strong>下标为<code>index</code>的节点</strong>上，这样才能正确取到值；</li>
<li>对于增删操作，需要<code>cur</code>停在<strong>下标为<code>index</code>的前一个节点</strong>上，这样才方便进行增删操作。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (index-- &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        tmp-&gt;next = _dummyhead-&gt;next;</span><br><span class="line">        _dummyhead-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListNode *_dummyhead;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="19-删除链表的倒数第N个结点"><a href="#19-删除链表的倒数第N个结点" class="headerlink" title="19. 删除链表的倒数第N个结点"></a>19. 删除链表的倒数第N个结点</h3><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第N个结点</a></p>
<ul>
<li><p>解题思路</p>
<p>本题我采用了两趟扫描的方式进行解答。第一趟扫描确定了链表的长度，第二趟扫描则定位到了<strong>要删除结点的前一个结点</strong>。</p>
<ol>
<li><p>由于涉及到对头节点<code>head</code>的操作，因此定义一个<code>dummyhead</code>，避免需要对头结点单独操作；</p>
</li>
<li><p>如何定位到要删除结点的前一个结点，实际上需要分析<code>n</code>和<code>sz</code>之间的关系，如下图所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404120946983.png" alt="image-20240412094658218" style="zoom: 33%;" /></li>
</ol>
<blockquote>
<p>然而这道题我看了代码随想录提供的题解，实际上也是快慢指针法的一种变体，并且使用快慢指针法就可以无需先遍历一遍链表来求出链表的总长度。</p>
<p>只需要定义<code>fast</code>和<code>slow</code>两个指针</p>
<ul>
<li><code>fast</code>先走<code>n+1</code>步。之后<code>fast</code>和<code>slow</code>同时向前走；</li>
<li>当<code>fast</code>指向<code>nullptr</code>时，<code>slow</code>就正好指向要删除结点的前一个结点。</li>
</ul>
</blockquote>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *cur1 = head;</span><br><span class="line">        <span class="type">int</span> sz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            sz++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line">        ListNode *cur = dummyhead;</span><br><span class="line">        <span class="type">int</span> m = sz-n;</span><br><span class="line">        <span class="keyword">while</span> (m &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        head = dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyhead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、反转链表"><a href="#3、反转链表" class="headerlink" title="3、反转链表"></a>3、反转链表</h2><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><p>这道题实际上也相当于是双指针法中的快慢指针，通过定义两个指针<code>pre</code>和<code>cur</code>来依次遍历链表中的所有元素，并在遍历的过程中修改指针的指向。</p>
</li>
<li><p>有一个要注意的点在于：<code>while</code>循环的终止条件是<code>cur != nullptr</code>，若采用<code>cur-&gt;next != nullptr</code>，则最后一个节点不会被遍历到。</p>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p>
<ul>
<li><p>解题思路</p>
<p>实际上这道题只要能够画图模拟出交换的过程，就没有问题了。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404111457295.png" alt="image-20240411145728810"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode *cur = dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode *tmp1 = cur-&gt;next;</span><br><span class="line">            ListNode *tmp2 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next = tmp1;</span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = tmp2;</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next;  <span class="comment">// cur要往后跳两步</span></span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyhead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、链表相交"><a href="#4、链表相交" class="headerlink" title="4、链表相交"></a>4、链表相交</h2><h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></p>
<ul>
<li><p>解题思路</p>
<p>主要有以下几个点要注意：</p>
<ol>
<li><p>最开始我额外定义了<code>a</code>和<code>b</code>用于去遍历两个链表来长度，实际上可以直接定义<code>curA</code>和<code>curB</code>，在遍历结束上让其重新指向头结点即可；</p>
</li>
<li><p>该题交点不是数值相等，而是指针相等！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (curA-&gt;val == curB-&gt;val)  <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">if</span> (curA == curB)			 <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size_a = <span class="number">0</span>, size_b = <span class="number">0</span>;</span><br><span class="line">        ListNode *curA = headA;</span><br><span class="line">        ListNode *curB = headB;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            size_a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">            size_b++;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">abs</span>(size_a - size_b);</span><br><span class="line">        <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// if (curA-&gt;val == curB-&gt;val) &#123;</span></span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></p>
<ul>
<li><p>解题思路</p>
<p>定义快慢指针<code>fast</code>和<code>slow</code>，其中<code>fast</code>每次走两个结点，<code>slow</code>每次走一个结点。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121316807.png" alt="image-20240412131623148"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *index1 = fast;</span><br><span class="line">                ListNode *index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三、哈希表"><a href="#三、哈希表" class="headerlink" title="三、哈希表"></a>三、哈希表</h1><h2 id="1、理论基础"><a href="#1、理论基础" class="headerlink" title="1、理论基础"></a>1、理论基础</h2><p>哈希表即为散列表，一般用于判断一个元素是否出现在集合里。</p>
<p>常见的三种哈希函数：</p>
<ul>
<li><p>数组</p>
</li>
<li><p>集合（<code>set</code>）</p>
<p>首选<code>unordered_set</code>；若需要有序，则选择<code>set</code>；若不仅要求有序还要求有重复数据，选择<code>multiset</code>。</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<ul>
<li><p><code>std::unordered_set</code>底层实现为哈希表；</p>
</li>
<li><p><code>std::set</code>和<code>std::multiset</code>的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以<code>key</code>值是有序的，但<code>key</code>不可以修改，改动<code>key</code>值会导致整棵树的错乱，所以只能删除和增加。</p>
</li>
</ul>
</li>
<li><p>映射（<code>map</code>）</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<ul>
<li><code>std::unordered_map</code>底层实现为哈希表；</li>
<li><code>std::map</code>和<code>std::multimap</code>的底层实现是红黑树。同理，<code>std::map</code>和<code>std::multimap</code>的<code>key</code>也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</li>
</ul>
</li>
</ul>
<h2 id="2、采用数组作为哈希函数"><a href="#2、采用数组作为哈希函数" class="headerlink" title="2、采用数组作为哈希函数"></a>2、采用数组作为哈希函数</h2><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h3><p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></p>
<ul>
<li><p>解题思路</p>
<p>由于“字母异位词”的定义是：两个词中每个字符出现的数组相同，而本题假设词中仅包含小写字母。因此直观的想法就是定义一个数组，先遍历<code>s</code>，将每个字符在数组中对应的位置加1，再遍历<code>t</code>，将每个字符在数组中对应的位置减1，这样若最终数组为全0，则这两个词是字母异位词。</p>
<p>但我陷入的思维瓶颈在于，我想的是按照<code>s</code>中每个字符出现的顺序定义数组<code>a</code>，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s = &quot;anagram&quot;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">// 其中下标1代表字符a</span></span><br></pre></td></tr></table></figure>

<p>但这样实际上就相当于是一个<code>map</code>了，操作变得格外复杂。</p>
<p>实际上，由于小写字母是有顺序的26个，因此只需要定义一个<code>int a[26]</code>，对于<code>s</code>中遍历到的每个字符，通过<code>s[i] - &#39;a&#39;</code>就可以定位到对应的下标。</p>
</li>
<li><p>易混知识点：</p>
<ol>
<li><p><code>a - &#39;a&#39;</code>:</p>
<ul>
<li><strong>用于将字母字符转换成一个从0开始的索引</strong>（例如，’a’变成0, ‘b’变成1, 等等）。</li>
</ul>
<ul>
<li>这里 <code>&#39;a&#39;</code> 是一个字符，其ASCII值是 97。</li>
<li>所以 <code>a - &#39;a&#39;</code> 实际上是计算 <code>97 - 97</code>，结果是 0。</li>
</ul>
</li>
<li><p><code>&#39;1&#39; - &#39;0&#39;</code> </p>
<ul>
<li><strong>计算两个字符的ASCII值之差，用于将字符表示的数字转换成其对应的整数值。</strong></li>
</ul>
<ul>
<li><code>&#39;1&#39;</code> 的 ASCII 值是 49，<code>&#39;0&#39;</code>是 48。所以，<code>&#39;1&#39;-&#39;0&#39;</code> 的计算过程是 <code>49-48</code>，结果是 1。</li>
</ul>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;t.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            record[t[j] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m=<span class="number">0</span>; m&lt;<span class="number">26</span>; ++m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[m] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>洛谷刷题</title>
    <url>/2024/03/15/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1-基础算法"><a href="#1-基础算法" class="headerlink" title="1 基础算法"></a>1 基础算法</h1><h2 id="1-1-枚举"><a href="#1-1-枚举" class="headerlink" title="1.1 枚举"></a>1.1 枚举</h2><h3 id="1-1-1-循环枚举"><a href="#1-1-1-循环枚举" class="headerlink" title="1.1.1 循环枚举"></a>1.1.1 循环枚举</h3><h4 id="P2241-统计方形"><a href="#P2241-统计方形" class="headerlink" title="P2241 统计方形"></a>P2241 统计方形</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> sq_cnt = <span class="number">0</span>, rec_cnt = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">      <span class="type">int</span> temp = std::<span class="built_in">min</span>(n-i, m-j);  <span class="comment">// important</span></span><br><span class="line">      sq_cnt += temp;</span><br><span class="line">      rec_cnt += (n-i)*(m-j) - temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  std::cout &lt;&lt; sq_cnt &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; rec_cnt &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="P2089-烤鸡"><a href="#P2089-烤鸡" class="headerlink" title="P2089 烤鸡"></a>P2089 烤鸡</h4><h4 id="P1618-三连击"><a href="#P1618-三连击" class="headerlink" title="P1618 三连击"></a>P1618 三连击</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> standard[] = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量数组法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> a, b, c, flag=<span class="number">1</span>;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">329</span>; i++) &#123;\</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d%d%d&quot;</span>, a*i, b*i, c*i);</span><br><span class="line">    <span class="built_in">sort</span>(buf, buf+<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(standard, buf) == <span class="number">0</span>) &#123;</span><br><span class="line">      flag = <span class="number">0</span>;</span><br><span class="line">      cout &lt;&lt; a*i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b*i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c*i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题的解题用到了常量数组法。一开始我想着正推，但是没有头绪。看了题解之后我才发现可以反着从比例开始推。先遍历所有满足<code>A:B:C</code>的三位数的情况，然后将这三个三位数，共9个数看成一个整体的<code>buf</code>数组，和<code>123456789</code>对比是否一致。</p>
<h4 id="P3392-涂国旗"><a href="#P3392-涂国旗" class="headerlink" title="P3392 涂国旗"></a>P3392 涂国旗</h4><p>思想实际很简单，注意两个调试中发现的错误点：</p>
<p>1、输入格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">WRWRW</span><br><span class="line">BWRWB</span><br><span class="line">WRWRW</span><br><span class="line">RWBWR</span><br></pre></td></tr></table></figure>

<p>因此对应的代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    string row;</span><br><span class="line">    cin &gt;&gt; row; <span class="comment">// 读取一行数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字符串转换为字符数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        a[i][j] = row[j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误！</span></span><br><span class="line"><span class="comment">// 这种方法会尝试直接读取整个输入流，也就是说一次读取n*m个数据，而不是逐行逐个读取</span></span><br><span class="line"><span class="comment">// for (int i=0; i&lt;n; i++) &#123;</span></span><br><span class="line"><span class="comment">//     for (int j=0; j&lt;m; ++j) &#123;</span></span><br><span class="line"><span class="comment">//         cin &gt;&gt; a[i][j];</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>2、在统计每一行转换为<code>w\b\r</code>需要的个数时，因为<code>wc\bc\rc</code>定义为全局变量，因此要记得及时清零；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">int</span> wc = <span class="number">0</span>, bc = <span class="number">0</span>, rc = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 预处理：每一行转换成w\b\r的需转换的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; ++j) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (a[i][j]) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">            wc++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            bc++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">            rc++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      cnt[i][<span class="number">0</span>] = m-wc;</span><br><span class="line">      cnt[i][<span class="number">1</span>] = m-bc;</span><br><span class="line">      cnt[i][<span class="number">2</span>] = m-rc;</span><br><span class="line"></span><br><span class="line">      wc = bc = rc= <span class="number">0</span>;  <span class="comment">// important!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    ...       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="P3654-First-Step"><a href="#P3654-First-Step" class="headerlink" title="P3654 First Step"></a>P3654 First Step</h4><p>由于这个题算的是<code>1×K</code>的排列方式，因此遗漏掉的一点是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.###.</span><br><span class="line">##.#.</span><br><span class="line">..#..</span><br><span class="line">#..#.</span><br><span class="line">#.###</span><br></pre></td></tr></table></figure>

<p>针对上述的情况，<code>K=1</code>是横着排和竖着排是一样的，因此属于特例，结果要除<code>2</code>。</p>
<h3 id="1-1-2-子集枚举"><a href="#1-1-2-子集枚举" class="headerlink" title="1.1.2 子集枚举"></a>1.1.2 子集枚举</h3><h4 id="P1036-选数"><a href="#P1036-选数" class="headerlink" title="P1036 选数"></a>P1036 选数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> x[<span class="number">25</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为素数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i*i&lt;=num; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归遍历查询</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> sum, <span class="type">int</span> startx)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// m      当前选择了多少个数</span></span><br><span class="line">  <span class="comment">// sum    当前和</span></span><br><span class="line">  <span class="comment">// startx 升序排列</span></span><br><span class="line">  <span class="keyword">if</span> (m == k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_prime</span>(sum)) &#123;</span><br><span class="line">      ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=startx; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(m+<span class="number">1</span>, sum+x[i], i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; x[i];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="P1157-组合的输出※"><a href="#P1157-组合的输出※" class="headerlink" title="P1157 组合的输出※"></a>P1157 组合的输出※</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, r;</span><br><span class="line"><span class="type">int</span> a[<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// m ==&gt; 为当前选择的数</span></span><br><span class="line">  <span class="comment">// 已经选了足够的数</span></span><br><span class="line">  <span class="keyword">if</span> (m &gt; r) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=r; i++) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 未选够，继续遍历</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=a[m<span class="number">-1</span>]+<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="comment">// i=a[m-1]+1指i从上一个选取的整数a[m-1]的下一个数开始</span></span><br><span class="line">    a[m] = i; <span class="comment">// 把上一行提到的那个数赋给当前a[k]</span></span><br><span class="line">    <span class="built_in">dfs</span>(m+<span class="number">1</span>); <span class="comment">// 递归调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; r;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-1-3-排列枚举"><a href="#1-1-3-排列枚举" class="headerlink" title="1.1.3 排列枚举"></a>1.1.3 排列枚举</h3><h4 id="P1706-全排列"><a href="#P1706-全排列" class="headerlink" title="P1706 全排列"></a>P1706 全排列</h4><p>1、直接用<code>c++</code>的<code>next_permutation</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    a[i] = i+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">sort</span>(a, a+n);</span><br><span class="line">  <span class="comment">// sort(a, a+n, greater&lt;&gt;());  -- prev_permutation(a, a+n)</span></span><br><span class="line">  <span class="comment">// greater&lt;int&gt;() 是一个函数对象，用于比较两个同类型的值</span></span><br><span class="line">  <span class="comment">// 第一个参数比第二个参数大时返回true</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(a, a+n));</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、深度搜索：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, pos=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>], b[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深搜函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;  <span class="comment">// 用i遍历所有可能的n种可能（因为这道题遍历的对象即为自然数，因此也就是i本身）</span></span><br><span class="line">    <span class="keyword">if</span> (!b[i]) &#123;  <span class="comment">// 当前b[i]为未使用状态</span></span><br><span class="line">      b[i] = <span class="number">1</span>;  <span class="comment">// 则首先将b[i]设置为使用状态</span></span><br><span class="line">      a[pos] = i;  <span class="comment">// 存储当前i值，</span></span><br><span class="line">      pos++;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (k == n) &#123;</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">search</span>(k+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      pos--;  <span class="comment">// 执行到这一步说明已经打印完了一组数据，因此进行回溯</span></span><br><span class="line">      b[i] = <span class="number">0</span>;  <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">search</span>(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="P1088-火星人"><a href="#P1088-火星人" class="headerlink" title="P1088 火星人"></a>P1088 火星人</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;  <span class="comment">// 火星人手指数</span></span><br><span class="line"><span class="type">int</span> m;  <span class="comment">// 要加上的数B</span></span><br><span class="line"><span class="type">int</span> k[<span class="number">10005</span>];  <span class="comment">// 加数A</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">    cout &lt;&lt; k[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  cin &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; k[i];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; ++i) &#123;</span><br><span class="line">    <span class="built_in">next_permutation</span>(k, k+n);</span><br><span class="line">    <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">      <span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-贪心"><a href="#1-2-贪心" class="headerlink" title="1.2 贪心"></a>1.2 贪心</h2><p>贪心算法中常见的定义<code>结构体</code>并排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Oj</span>&#123;</span><br><span class="line">    <span class="type">int</span> begin;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">&#125;a[<span class="number">1001000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Oj o1, Oj o2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> o1.end &lt;= o2.end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">sort</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>, cmp);  <span class="comment">// 按结束时间对所有oj排序</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-1-线段覆盖"><a href="#1-2-1-线段覆盖" class="headerlink" title="1.2.1 线段覆盖"></a>1.2.1 线段覆盖</h3><blockquote>
<p>通用问题表述：</p>
<p>在一个数轴上有<code>n</code>条线段，现要选取其中<code>k</code>条选段使得这<code>k</code>条线段两两没有重合部分，问最大的<code>k</code>为多少？</p>
</blockquote>
<p>1、最左边的线段放<code>右端点最靠左的线段</code>；</p>
<p>2、剩下的其他线段<code>按右端点排序</code>，贪心放置线段，即能放就放。</p>
<h2 id="1-3-二分法"><a href="#1-3-二分法" class="headerlink" title="1.3 二分法"></a>1.3 二分法</h2><p><strong>二分题的几个特征：</strong></p>
<p>1、求最大&#x2F;最小值；</p>
<p>2、答案离散（答案有多种可能）；</p>
<p>3、容易判断答案是否正确。</p>
<p><strong>做法：</strong></p>
<p>1、确定答案区间；</p>
<p>2、在保证答案在区间内的前提下,逐步缩小区间；</p>
<p>3、当区间缩小到仅包含一个可能解时，该可能解即为答案。</p>
<p><strong>易错点：</strong></p>
<p>1、取边界条件时是选择<code>while(left&lt;right)</code>还是<code>while(left&lt;=right)</code>？</p>
<p>2、当中间值大于（或小于）所需查找的目标时，下一步要迭代更新的<code>right</code>（或<code>left</code>）应该取<code>middle</code>还是<code>middle-1</code>？</p>
<p><strong>解答：</strong></p>
<p>对上述边界条件的选取要参考解法选择“<strong>左闭右闭</strong>”的区间还是“<strong>左闭右开</strong>”的区间。</p>
<ul>
<li><p><strong>左闭右闭</strong>：（在做题时首选这种方法！）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">left = <span class="number">0</span>;</span><br><span class="line">right = nums.size<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">right = middle<span class="number">-1</span>; &amp;&amp; left = middle+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>左闭右开：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">left = <span class="number">0</span>;</span><br><span class="line">right = nums.size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">right = middle; &amp;&amp; left = midlle+<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="P2249-查找"><a href="#P2249-查找" class="headerlink" title="P2249 查找"></a>P2249 查找</h3><p>这道题有一个要掌握的知识点：</p>
<p>在<code>1 3 3 3 5 7 9 11 13 15 15</code>中如何找到第一个<code>3</code>出现的位置：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> right = n;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] == target) &#123;</span><br><span class="line">      res = mid;</span><br><span class="line">      right = mid - <span class="number">1</span>;  <span class="comment">// 这两步是为了找到第一个出现a[mid]的位置</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P1102-A-B数对"><a href="#P1102-A-B数对" class="headerlink" title="P1102 A-B数对"></a>P1102 A-B数对</h3><p>本题需要求解满足<code>A-B=C</code>的数对的个数。由于题中告知了<strong>不同位置但数字一样的数对算不同的数对</strong>，因此求解思路如下：</p>
<p>1、<code>A-B=C</code>即<code>A-C=B</code>；首先建立<code>map</code>映射，统计<code>A</code>取不同值的个数；</p>
<p>2、将所有的<code>A</code>减去<code>C</code>，这个时候得到<code>B</code>，再统计此时<code>map</code>中以<code>B</code>的值为键的个数，即为所求答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, c;</span><br><span class="line"><span class="comment">// int res;</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res;</span><br><span class="line"><span class="type">int</span> a[<span class="number">200001</span>];  <span class="comment">// n个正整数</span></span><br><span class="line">map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; boo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">    boo[a[i]]++;</span><br><span class="line">    a[i]-=c;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">    res += boo[a[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个易错点在第<code>6</code>行，由于</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403211101376.png" alt="image-20240321110105721" style="zoom: 67%;" />

<p>因此<code>res</code>应该定义为<code>long long</code>，而非<code>int</code>。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>long long</td>
<td>-2^63 ~ 2^63-1</td>
</tr>
<tr>
<td>int</td>
<td>-2^31 ~ 2^31-1</td>
</tr>
</tbody></table>
<h3 id="P1873-砍树"><a href="#P1873-砍树" class="headerlink" title="P1873 砍树"></a>P1873 砍树</h3><p>这道题的“二分”思想体现如下：</p>
<p>对于给出的N棵树的高度：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 7</span><br><span class="line">20 15 10 17</span><br></pre></td></tr></table></figure>

<p>假设锯片高度为14:，此时可得到的木材长度（总和<code>s</code>）为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 1 0 3  ==&gt;  s=10</span><br></pre></td></tr></table></figure>

<p>得到的木材多于需要的木材，因此说明<strong>得到的“答案区间大了”，需要对其进行缩小</strong>。（这就可以类比到二分的思想上）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, m, a[<span class="number">1000001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">get</span><span class="params">(<span class="type">long</span> <span class="type">long</span> h)</span> </span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">    s += ((a[i]-h) &gt;= <span class="number">0</span> ? (a[i]-h) : <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>;  <span class="comment">// left、right和mid用来衡量锯片长度</span></span><br><span class="line">  <span class="comment">// long long right = 400001;  // 错误，若m恰好为0或所有木块长度都小于m，则不对</span></span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> right = *<span class="built_in">max_element</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// long long s = 0;</span></span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> s = <span class="number">-1</span>;  <span class="comment">// 初始化为一个无效的值</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// ------------------- 错误 ------------------------- //</span></span><br><span class="line">    <span class="comment">// if (get(mid) == m) &#123;</span></span><br><span class="line">    <span class="comment">//   // 如果恰好找到一个mid使得get(mid)==m，并不一定就是正确的解</span></span><br><span class="line">    <span class="comment">//   // 因为题目要求的是最大的s，而不是等于m的s</span></span><br><span class="line">    <span class="comment">//   s = mid;</span></span><br><span class="line">    <span class="comment">//   break;</span></span><br><span class="line">    <span class="comment">// &#125; else if (get(mid) &gt; m) &#123;</span></span><br><span class="line">    <span class="comment">//   // 当前获得的木材长度太大，需要增大锯片长度</span></span><br><span class="line">    <span class="comment">//   left = mid + 1;</span></span><br><span class="line">    <span class="comment">// &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//   // 当前获得的木材长度太大，需要减小锯片长度</span></span><br><span class="line">    <span class="comment">//   right = mid - 1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//   // 同时，没有处理找不到合适的解的情况</span></span><br><span class="line">    <span class="comment">// ------------------- 错误 ------------------------- //</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get</span>(mid) &gt;= m) &#123;  <span class="comment">// 修正条件，使得可以找到最大的s</span></span><br><span class="line">      s = mid;</span><br><span class="line">      left = mid + <span class="number">1</span>;  <span class="comment">// 向右搜索，寻找更大的锯片高度，使得得到的木材总长度减小</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>;  <span class="comment">// 向左搜索，寻找更小的锯片高度，使得得到的木材总长度增大</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P1024-一元三次方程求解"><a href="#P1024-一元三次方程求解" class="headerlink" title="P1024 一元三次方程求解"></a>P1024 一元三次方程求解</h3><p>首先分析这道题：由于这道题的答案区间很大，因此可以考虑采用二分法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l/r/m	x取值</span><br><span class="line">a[m]	f(x)的值</span><br><span class="line">target	方程的根</span><br></pre></td></tr></table></figure>

<p>但本题的特殊之处在于，不能把<code>l</code>和<code>r</code>想当然地认为是<code>-100</code>和<code>100</code>。这是因为本题需要求解出<code>3个实根</code>。根据题中给出的提示：<strong>根与根之差的绝对值 ≥1</strong>，可以得知<strong>每个长度为<code>1</code>的区间内部至多有<code>1</code>个实根</strong>。明确这一点之后，就可以依次遍历每个长度为<code>1</code>的区间，进行二分查找了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> a, b, c, d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a*x*x*x+b*x*x+c*x+d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">  <span class="type">double</span> l, r, m;</span><br><span class="line">  <span class="type">int</span> s = <span class="number">0</span>;  <span class="comment">// 记录找到的根个数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">-100</span>; i&lt;<span class="number">100</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 由于题目说根与根之差的绝对值大于等于1，也即长度为1的区间内至多只存在1个根</span></span><br><span class="line">    <span class="comment">// 因此，所要做的就是在每个长度为1的区间内进行二分查找</span></span><br><span class="line">    l = i;</span><br><span class="line">    r = i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(l) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 说明此时左端点为根，输出</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%.2lf &quot;</span>, l);</span><br><span class="line">      s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(l) * <span class="built_in">f</span>(r) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// f(x1)*f(x2)&lt;0，说明该区间内存在根</span></span><br><span class="line">      <span class="keyword">while</span> (r-l&gt;=<span class="number">0.001</span>) &#123;  <span class="comment">// 二分控制精度</span></span><br><span class="line">        m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">f</span>(m) * <span class="built_in">f</span>(r) &lt;=<span class="number">0</span>) &#123;</span><br><span class="line">          l = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r = m;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%.2lf &quot;</span>, r);</span><br><span class="line">      s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<code>26</code>行不用<code>while(l &lt;= r)</code>是因为：</p>
<p><code>while(r-l&gt;=0.001)</code> 这个条件是用来控制二分法的精度，它的含义是在区间的长度小于等于0.001时停止循环。这里的0.001是一个预先设定的精度值，表示当根的范围缩小到小于等于0.001时，认为已经找到了一个满足要求的根。</p>
<p>使用 <code>while(r-l&gt;=0.001)</code> 的原因是为了控制二分法的迭代次数，从而提高程序的效率和准确性。当根的范围缩小到足够小的时候，再继续迭代寻找根就没有必要了，因为已经达到了所需的精度要求。</p>
<p>而如果使用 <code>while(l&lt;=r)</code> 作为条件，则无法直接控制迭代的精度。在这种情况下，循环会一直进行，直到区间的长度小于等于0时才停止，这可能会导致不必要的迭代次数，影响程序的效率。因此，使用 <code>while(r-l&gt;=0.001)</code> 能够更好地控制迭代的精度，从而提高程序的性能。</p>
<h1 id="2-搜索算法"><a href="#2-搜索算法" class="headerlink" title="2 搜索算法"></a>2 搜索算法</h1><h2 id="2-1-深度搜索DFS"><a href="#2-1-深度搜索DFS" class="headerlink" title="2.1 深度搜索DFS"></a>2.1 深度搜索DFS</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否满足终止搜索条件</span></span><br><span class="line">  <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 进行相应操作</span></span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// 回溯</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历所有可能的情况</span></span><br><span class="line">  <span class="keyword">for</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 标记当前状态，或执行当前操作</span></span><br><span class="line">    <span class="built_in">dfs</span>(...);  <span class="comment">// dfs搜索</span></span><br><span class="line">    <span class="comment">// 回溯状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P1605-迷宫"><a href="#P1605-迷宫" class="headerlink" title="P1605 迷宫"></a>P1605 迷宫</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251029500.png" alt="image-20240325102955228"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2023/12/05/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>《数据结构（严蔚敏）》_b站鲍松山</p>
<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><p>数据结构（Data Struct）：数据之间的组织架构&#x2F;结构。</p>
<blockquote>
<p><strong>DS：</strong></p>
<ul>
<li><strong>线性结构</strong><ul>
<li><strong>SeqList&#x2F;List&#x2F;Stack&#x2F;Queue&#x2F;String&#x2F;Array</strong></li>
</ul>
</li>
<li><strong>非线性结构</strong><ul>
<li><strong>Tree&#x2F;Graph</strong></li>
</ul>
</li>
<li><strong>排序</strong></li>
<li><strong>查找</strong></li>
<li><strong>算法</strong></li>
</ul>
</blockquote>
<span id="more"></span>

<h1 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2 线性表"></a>2 线性表</h1><h2 id="2-1-顺序表（SeqList）"><a href="#2-1-顺序表（SeqList）" class="headerlink" title="2.1 顺序表（SeqList）"></a>2.1 顺序表（SeqList）</h2><p>顺序表通过一组地址连续的空间对数据进行存储。</p>
<h2 id="2-2-单链表（List）"><a href="#2-2-单链表（List）" class="headerlink" title="2.2 单链表（List）"></a>2.2 单链表（List）</h2><p>不要求逻辑上相邻的元素在物理位置上也相邻，因此无法实现随机存取。</p>
<p>分清“谁的谁是谁”。 </p>
<p>操作时要时刻注意<code>last</code>这一项。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120918067.png" alt="image-20231212091813193" style="zoom: 33%;" />

<p><strong>头部插入时易错：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(List *<span class="built_in">list</span>, ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *s = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    assert(s != <span class="literal">NULL</span>);</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="built_in">list</span>-&gt;first-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;first-&gt;next = s;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下图所示，当使用头插法向<code>空list</code>中插入<code>1</code>后，<code>list-&gt;last</code>仍然指向头结点。‘</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915222.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915816.png" alt="2"></p>
<p> 对<code>pop_front</code>进行修改，加入对<code>size</code>的判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">list</span>-&gt;last = s; <span class="comment">// 当list为空时，对last进行移动</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915584.png" alt="3"></p>
<p><strong>头部删除时同理</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_front</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Node *p = <span class="built_in">list</span>-&gt;first-&gt;next;</span><br><span class="line">    <span class="built_in">list</span>-&gt;first-&gt;next = <span class="built_in">list</span>-&gt;first-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">list</span>-&gt;last = <span class="built_in">list</span>-&gt;first;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-静态链表（StaticList）"><a href="#2-3-静态链表（StaticList）" class="headerlink" title="2.3 静态链表（StaticList）"></a>2.3 静态链表（StaticList）</h2><p>使用<strong>静态链表</strong>可以便于在不设<em>指针</em>类型的高级程序设计语言中使用链表结构。</p>
<p>静态链表实际上就是用数组去模拟链表。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120915948.png" alt="4" style="zoom: 67%;" />

<p>这里的<code>pool</code>指明下一个备用空间的地址。</p>
<h2 id="2-4-单循环链表（SCList）"><a href="#2-4-单循环链表（SCList）" class="headerlink" title="2.4 单循环链表（SCList）"></a>2.4 单循环链表（SCList）</h2><p>特点：尾节点指向头节点，整个链表形成一个环。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312121129584.png" alt="image-20231212112956184" style="zoom:33%;" />

<p>循环链表的操作和线性链表基本一致,差别仪在于算法中的循环条件不是<code>p</code>或<code>p-&gt;next</code>是否为空，而是它们是否等于头指针。但有的时候，若在循环链表中设立尾指针而不设头指针，可使某些操作简化。例如将两个线性表合并成一个表时，仅需将一个表的表尾和另一个表的表头相接。</p>
<p>初始化时，注意：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>-&gt;first = <span class="built_in">list</span>-&gt;last = s;</span><br><span class="line"><span class="built_in">list</span>-&gt;last-&gt;next = <span class="built_in">list</span>-&gt;first;</span><br><span class="line"><span class="built_in">list</span>-&gt;size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120928507.png" alt="image-20231212092812466"></p>
<p>尾插时的各节点地址：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312120954889.png" alt="image-20231212095457800"  />

<p><strong>掌握按值删除这里的的思想：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按值删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_val</span><span class="params">(List *<span class="built_in">list</span>, ElemType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Node *p = find(<span class="built_in">list</span>, key);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;要删除的数据不存在！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p == <span class="built_in">list</span>-&gt;last)</span><br><span class="line">        pop_back(<span class="built_in">list</span>);</span><br><span class="line">    <span class="comment">////////////////////////////////***</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 即不是删除当前节点，而是将下一个节点的值赋值给当前节点，然后删除下一个节点</span></span><br><span class="line">        <span class="comment">// 这样做避免从头遍历链表</span></span><br><span class="line">        Node *q = p-&gt;next;</span><br><span class="line">        p-&gt;data = q-&gt;data;</span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        <span class="built_in">list</span>-&gt;size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">////////////////////////////////***</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>申请节点：Node *s<br>遍历节点：Node *p<br>删除节点：Node *q</p>
</blockquote>
<h2 id="2-5-双向链表（DList）"><a href="#2-5-双向链表（DList）" class="headerlink" title="2.5 双向链表（DList）"></a>2.5 双向链表（DList）</h2><p>每次操作时涉及4个指针：</p>
<ul>
<li>当前节点的前驱；</li>
<li>当前节点的后继；</li>
<li>前一个节点的后继；</li>
<li>后一个节点的前驱。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312131154818.png" alt="image-20231213115430268" style="zoom:33%;" />

<h2 id="2-6-双向循环链表（DCList）"><a href="#2-6-双向循环链表（DCList）" class="headerlink" title="2.6 双向循环链表（DCList）"></a>2.6 双向循环链表（DCList）</h2><p>存在两个环。</p>
<p><strong>环1是<code>list-&gt;last-&gt;next</code></strong></p>
<p><strong>环2是<code>list-&gt;first-&gt;prev</code></strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312140920009.png" alt="image-20231214092024742" style="zoom: 25%;" />

<h1 id="3-栈和队列"><a href="#3-栈和队列" class="headerlink" title="3 栈和队列"></a>3 栈和队列</h1><h2 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h2><p><strong>栈和队列的基本操作是线性表操作的子集，是操作受限的线性表。</strong></p>
<p>栈：限定仅在表尾插入或删除操作的线性表。表尾称为<strong>栈顶</strong>，表头称为<strong>栈底</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312141056107.png" alt="image-20231214105656926" style="zoom: 25%;" />

<h3 id="3-1-1-顺序栈（SeqStack）"><a href="#3-1-1-顺序栈（SeqStack）" class="headerlink" title="3.1.1 顺序栈（SeqStack）"></a>3.1.1 顺序栈（SeqStack）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312141103006.png" alt="image-20231214110346157" style="zoom:25%;" />

<h3 id="3-1-2-链栈（LinkStack）"><a href="#3-1-2-链栈（LinkStack）" class="headerlink" title="3.1.2 链栈（LinkStack）"></a>3.1.2 链栈（LinkStack）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312151207109.png" alt="image-20231215120659701" style="zoom:25%;" />

<h3 id="3-1-3-栈的应用"><a href="#3-1-3-栈的应用" class="headerlink" title="3.1.3 栈的应用"></a>3.1.3 栈的应用</h3><h4 id="1、数制转换"><a href="#1、数制转换" class="headerlink" title="1、数制转换"></a>1、数制转换</h4><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312151258969.png" alt="image-20231215125804838" style="zoom:67%;" />

<p>由于结果要从下往上读取，因此用一个栈来依次存放余数。最终依次取栈顶元素，就可以得到转换后的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;SeqStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数制转换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Convert_8</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqStack st;</span><br><span class="line">    InitStack(&amp;st);</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;st, value%<span class="number">8</span>);</span><br><span class="line">        value /= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Show(&amp;st);</span></span><br><span class="line">    <span class="keyword">while</span> (!(IsEmpty(&amp;st)))</span><br><span class="line">    &#123;</span><br><span class="line">        GetTop(&amp;st, &amp;v);</span><br><span class="line">        Pop(&amp;st);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.数制转换 ElemType int</span></span><br><span class="line">    <span class="type">int</span> value = <span class="number">47183</span>;</span><br><span class="line">    Convert_8(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、括号匹配"><a href="#2、括号匹配" class="headerlink" title="2、括号匹配"></a>2、括号匹配</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 括号匹配</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Check</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqStack st;</span><br><span class="line">    InitStack(&amp;st);</span><br><span class="line">    <span class="type">char</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">&#x27;[&#x27;</span> || *str == <span class="string">&#x27;&#123;&#x27;</span> || *str == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            Push(&amp;st, *str);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetTop(&amp;st, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Pop(&amp;st);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetTop(&amp;st, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Pop(&amp;st);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetTop(&amp;st, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Pop(&amp;st);</span><br><span class="line">        &#125; </span><br><span class="line">        *str++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IsEmpty(&amp;st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2.括号匹配 ElemType char</span></span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;[([][])]&quot;</span>; <span class="comment">// char *str    str是一个指向字符数组的指针</span></span><br><span class="line">    <span class="type">bool</span> flag = Check(str);</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Ok!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、行编辑程序"><a href="#3、行编辑程序" class="headerlink" title="3、行编辑程序"></a>3、行编辑程序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 3.行编辑程序</span></span><br><span class="line">    SeqStack st;</span><br><span class="line">    InitStack(&amp;st);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch != <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(ch !=<span class="string">&#x27;$&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(ch)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    Pop(&amp;st);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">                    Clear(&amp;st);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    Push(&amp;st, ch);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        Print(&amp;st);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    Destroy(&amp;st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-队列（LinkQueue）"><a href="#3-2-队列（LinkQueue）" class="headerlink" title="3.2 队列（LinkQueue）"></a>3.2 队列（LinkQueue）</h2><p>先进先出的结构。</p>
<p>最典型的队列例子是<strong>操作系统中的作业排队</strong>。</p>
<p>队列可分为单端队列和双端队列，但双端队列实际上远不及栈和单端队列有用。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161259625.png" alt="image-20231216125953859" style="zoom: 25%;" />

<h3 id="3-2-1-链队列（LinkQueue）"><a href="#3-2-1-链队列（LinkQueue）" class="headerlink" title="3.2.1 链队列（LinkQueue）"></a>3.2.1 链队列（LinkQueue）</h3><p>由两个分别指向队头和队尾的指针唯一确定一个队列。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161300828.png" alt="image-20231216130008621" style="zoom:20%;" />

<h3 id="3-2-2-顺序队列（SeqQueue）实现循环队列"><a href="#3-2-2-顺序队列（SeqQueue）实现循环队列" class="headerlink" title="3.2.2 顺序队列（SeqQueue）实现循环队列"></a>3.2.2 顺序队列（SeqQueue）实现循环队列</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161300215.png" alt="image-20231216130020025" style="zoom:25%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312161300091.png" alt="image-20231216130034444" style="zoom: 33%;" />

<h1 id="4-串"><a href="#4-串" class="headerlink" title="4 串"></a>4 串</h1><p><code>C</code>语言实际上不存在字符串的概念。它是通过相应的字符指针指向一串字符。</p>
<p>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>而在<code>C++</code>中则出现了<code>string</code>类型，它实际上是一个用类实现的数据结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>串的定义：串（<code>string</code>）（或字符串）是由零个或多个字符组成的有限序列。</p>
<p>一般对串的整体进行操作，而不是对其中的单个元素进行操作。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312182049251.png" alt="image-20231218204922589" style="zoom: 25%;" />

<h2 id="4-1-定长顺序存储方式（StackString）"><a href="#4-1-定长顺序存储方式（StackString）" class="headerlink" title="4.1 定长顺序存储方式（StackString）"></a>4.1 定长顺序存储方式（StackString）</h2><p>定长的方式：<strong>先开辟的定长数组</strong>描述字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRLEN 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> u_char unsigned char</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> u_char SString[MAXSTRLEN+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<h2 id="4-2-堆分配存储方式（HeapString）"><a href="#4-2-堆分配存储方式（HeapString）" class="headerlink" title="4.2 堆分配存储方式（HeapString）"></a>4.2 堆分配存储方式（HeapString）</h2><p>仍以一组地址连续的存储单元存放串值字符序列，但其存储空间在程序执行过程中动态分配而得。用<code>malloc()</code>来为新产生的串分配存储空间，并约定串长也作为存储结构的一部分。</p>
<p>函数内部四步：</p>
<ul>
<li>条件判断（不满足条件直接返回）</li>
<li>空间判断（涉及操作的串的空间是否需要赋空，<code>free</code>）</li>
<li>空间分配（给串分配空间，<code>malloc</code>)</li>
<li>赋值操作</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312182049570.png" alt="image-20231218204932225" style="zoom: 33%;" />

<h1 id="5-数组和广义表"><a href="#5-数组和广义表" class="headerlink" title="5 数组和广义表"></a>5 数组和广义表</h1><h2 id="5-1-矩阵的压缩存储（SparseMatrix）"><a href="#5-1-矩阵的压缩存储（SparseMatrix）" class="headerlink" title="5.1 矩阵的压缩存储（SparseMatrix）"></a>5.1 矩阵的压缩存储（SparseMatrix）</h2><p>感兴趣的不是矩阵本身，而是如何存储矩阵的元，使得矩阵进行各项运算。</p>
<p>压缩存储：为多个值相同的元只分配一个存储空间；对零元不分配存储空间。假若值相同的元素或者零元素在矩阵中的分布有一定规律，称为<strong>特殊矩阵</strong>；反之，称为<strong>稀疏矩阵</strong>。</p>
<p><strong>压缩存储时，需要用一个三元组<code>(i,j,aij)</code>唯一确定矩阵A的一个非零元，即除了存储非零元的值<code>aij</code>外，还需要存储其所在行和列的位置<code>(i,j)</code>。</strong></p>
<p>稀疏矩阵的压缩存储示例：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312191547788.png" alt="image-20231219154712437" style="zoom:80%;" />

<h2 id="5-2-矩阵的快速转置算法实现"><a href="#5-2-矩阵的快速转置算法实现" class="headerlink" title="5.2 矩阵的快速转置算法实现"></a>5.2 矩阵的快速转置算法实现</h2><ul>
<li><p>（1）交换矩阵的行列值；</p>
</li>
<li><p>（2）交换三元组中的<code>i</code>和<code>j</code>；</p>
</li>
<li><p><strong>（3）重排三元组之间的次序。—-重点！</strong></p>
<ul>
<li>实现方法1：较为笨拙的重复遍历</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312192015890.png" alt="image-20231219201524473" style="zoom: 33%;" />

<ul>
<li><p>实现方法2：快速转置算法</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312192039855.png" alt="image-20231219203949650" style="zoom: 50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矩阵快速转置（实现方法2）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FastTransposeMatrix</span><span class="params">(SparseMatrix *M, SparseMatrix *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    T-&gt;mu = M-&gt;nu;</span><br><span class="line">    T-&gt;nu = M-&gt;mu;</span><br><span class="line">    T-&gt;tu = M-&gt;tu;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *num = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * M-&gt;nu);  <span class="comment">// M中每一列非零元的个数</span></span><br><span class="line">    assert(num != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">int</span> *cpot = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * M-&gt;nu);  <span class="comment">// M中每一列的第一个非零元对应三元组空间所在位置</span></span><br><span class="line">    assert(cpot != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;tu != <span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 初始化num数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>; col&lt;M-&gt;nu; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            num[col] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>; t&lt;M-&gt;tu; ++t)</span><br><span class="line">        &#123;</span><br><span class="line">            num[M-&gt;data[t].j]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化cpot数组</span></span><br><span class="line">        cpot[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">1</span>; col&lt;M-&gt;nu; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            cpot[col] = cpot[col<span class="number">-1</span>] + num[col<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行转置映射</span></span><br><span class="line">        <span class="type">int</span> col = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> kt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> km=<span class="number">0</span>; km&lt;M-&gt;tu; ++km)</span><br><span class="line">        &#123;</span><br><span class="line">            col = M-&gt;data[km].j;</span><br><span class="line">            kt = cpot[col];</span><br><span class="line">            T-&gt;data[kt].i = M-&gt;data[km].j;</span><br><span class="line">            T-&gt;data[kt].j = M-&gt;data[km].i;</span><br><span class="line">            T-&gt;data[kt].e = M-&gt;data[km].e;</span><br><span class="line">            cpot[col]++; <span class="comment">// 重要步骤</span></span><br><span class="line">            kt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在C中，如果使用了动态内存分配函数如malloc、calloc或realloc来分配内存</span></span><br><span class="line">    <span class="comment">// 那么最终应该使用 free 函数来释放已分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(num);</span><br><span class="line">    <span class="built_in">free</span>(cpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="5-3-广义表（GenList"><a href="#5-3-广义表（GenList" class="headerlink" title="5.3 广义表（GenList)"></a>5.3 广义表（GenList)</h2><blockquote>
<p><strong>所谓的广义表实际上就是一个递归概念。</strong></p>
<p><strong>1、处理tag&#x3D;&#x3D;ATOM的节点；</strong></p>
<p><strong>2、对子表进行递归操作；</strong></p>
<ul>
<li><strong>找到子表中的tag&#x3D;&#x3D;ATOM的节点并处理；</strong></li>
<li><strong>对剩下的节点组成的新的子表重复步骤2，直至子表中不存在节点。</strong></li>
</ul>
</blockquote>
<h3 id="1、含义"><a href="#1、含义" class="headerlink" title="1、含义"></a>1、含义</h3><p>线性表的推广。简单来说就是<strong>表中有表</strong>。</p>
<p>因此，有一个概念要尤其注意，<strong>即广义表是由无数个广义表组成的自身。</strong></p>
<h3 id="2、定义"><a href="#2、定义" class="headerlink" title="2、定义"></a>2、定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LS=(a1,a2,...an)</span><br></pre></td></tr></table></figure>

<p>其中，<code>ai(1&lt;=i&lt;=n)</code>可以是单个元素，也可以是广义表，分别称为<strong>原子</strong>和<strong>子集</strong>。当广义表非空时，<code>a1</code>称为表头（<code>Head</code>），其余元素组成的表<code>(a2,a3,...,an)</code>称为表尾（<code>Tail</code>）。</p>
<p><strong>举例：</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312200930160.png" alt="image-20231220093015065"></p>
<p><strong>注意：</strong>           </p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312200931491.png" alt="image-20231220093159352"></p>
<h3 id="3、存储结构"><a href="#3、存储结构" class="headerlink" title="3、存储结构"></a>3、存储结构</h3><p>由于表中的数据元素可以具有不同结构，因此一般采用<strong>链式存储方式</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312201010034.png" alt="image-20231220101006602" style="zoom: 33%;" />

<h2 id="5-4-表头分割算法"><a href="#5-4-表头分割算法" class="headerlink" title="5.4 表头分割算法"></a>5.4 表头分割算法</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312201628127.png" alt="image-20231220162815397" style="zoom: 33%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建广义表：通过字符串str来创建广义表gl</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateGenList</span><span class="params">(GenList &amp;gl, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(str);  <span class="comment">// 求解字符串长度</span></span><br><span class="line">	<span class="comment">// 存储表内元素</span></span><br><span class="line">	<span class="type">char</span> *sub = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (n<span class="number">-2</span>));</span><br><span class="line">	<span class="comment">// 存储表头</span></span><br><span class="line">	<span class="type">char</span> *hsub = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (n<span class="number">-2</span>));</span><br><span class="line">	assert(sub!=<span class="literal">NULL</span> &amp;&amp; hsub!=<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &quot;1,2,3&quot;</span></span><br><span class="line">	<span class="comment">// 去掉sub左右两边的括号</span></span><br><span class="line">	<span class="built_in">strncpy</span>(sub,str+<span class="number">1</span>,n<span class="number">-2</span>); </span><br><span class="line">	sub[n<span class="number">-2</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//加上结束符</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断广义表是否为空</span></span><br><span class="line">	<span class="keyword">if</span>(gl == <span class="literal">NULL</span>)  <span class="comment">// 为空</span></span><br><span class="line">	&#123;   </span><br><span class="line">		<span class="comment">//  创建头结点(广义表的第一个结点为头结点，其余都为尾结点)</span></span><br><span class="line">		gl = (GLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GLNode));</span><br><span class="line">		assert(gl != <span class="literal">NULL</span>);</span><br><span class="line">		gl-&gt;tag = HEAD;  <span class="comment">// 结点标记为头结点</span></span><br><span class="line">		gl-&gt;hp = gl-&gt;tp = <span class="literal">NULL</span>;  <span class="comment">// 把子表指针和尾指针都指向空</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	GLNode *p = gl;  <span class="comment">// 为了不丢失gl的指向，定义一个指针来操作</span></span><br><span class="line">	<span class="comment">// 求子串长度，当sub长度不为零时，说明广义表还未创建完成</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">strlen</span>(sub) != <span class="number">0</span>)</span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="comment">//  采用尾插法,在后面插入结点</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			1、创建一个结点</span></span><br><span class="line"><span class="comment">			2、让p所指结点的尾指针指向新建的结点</span></span><br><span class="line"><span class="comment">			3、让p指向新建结点</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		p = p-&gt;tp = (GLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GLNode));</span><br><span class="line">		assert(p != <span class="literal">NULL</span>);</span><br><span class="line">		p-&gt;hp = p-&gt;tp = <span class="literal">NULL</span>;  <span class="comment">// 将新建结点的子表指针和尾指针都赋空</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//  &quot;1,2,3&quot;     ==&gt;  &quot;1&quot;      hsub=&quot;1&quot;  sub=&quot;2,3&quot;;</span></span><br><span class="line">		<span class="comment">//  &quot;(1,2),3,4&quot; ==&gt;  &quot;(1,2)&quot;  hsub=&quot;(1,2)&quot; sub=&quot;3,4&quot;</span></span><br><span class="line">		<span class="keyword">if</span>(sever(sub,hsub))  <span class="comment">// sever函数分离表头，并将表头存入hsub中</span></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 对分离出来的表头进行判断，是否包含括号</span></span><br><span class="line">			<span class="keyword">if</span>(hsub[<span class="number">0</span>] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 说明要创建的结点是子表类型</span></span><br><span class="line">				p-&gt;tag = CHILDLIST;  <span class="comment">// 设置子表标记</span></span><br><span class="line">				CreateGenList(p-&gt;hp,hsub);  <span class="comment">// 在p的表头结点处，创建hsub子表</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 说明要创建的结点是原子类型</span></span><br><span class="line">				p-&gt;tag = ATOM;  <span class="comment">// 设置原子标记</span></span><br><span class="line">				p-&gt;atom = atoi(hsub);  <span class="comment">// 将表头字符串转换成整型数据，赋值给原子数据</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广义表表头分割函数，将sub中的表头分割到hsub中</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sever</span><span class="params">(<span class="type">char</span> *sub, <span class="type">char</span> *hsub)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//  判断sub是否为空</span></span><br><span class="line">	<span class="keyword">if</span>(*sub==<span class="string">&#x27;\0&#x27;</span> || <span class="built_in">strcmp</span>(sub,<span class="string">&quot;()&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 是 情况：&quot;&quot;  或  &quot;()&quot;</span></span><br><span class="line">		hsub[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 将hsub赋空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(sub);  <span class="comment">// 求sub的长度</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch = sub[<span class="number">0</span>];  <span class="comment">// 获取第一个字符</span></span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;  <span class="comment">// 表示括号的信息</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        当sub还没遍历完成且还未检测到括号外的逗号，继续遍历</span></span><br><span class="line"><span class="comment">	    注：当检测到括号外的逗号时，说明找到表头分割点，如：&quot;(1,2),3,4&quot; 表头即为(1,2)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;n &amp;&amp; (ch!=<span class="string">&#x27;,&#x27;</span>|| k!=<span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 判断是否运到左括号</span></span><br><span class="line">		<span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">			k++;  <span class="comment">// k++表示进入一层括号</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;)&#x27;</span>)  <span class="comment">// 判断是否遇到右括号</span></span><br><span class="line">			k--;   <span class="comment">// k--表示退出一层括号</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取下一个元素</span></span><br><span class="line">		i++;</span><br><span class="line">		ch = sub[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断是否是因为检测到括号外的逗号而结束的</span></span><br><span class="line">	<span class="keyword">if</span>(i &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 是</span></span><br><span class="line">		<span class="comment">// 在i位置截断，前面部分就是表头</span></span><br><span class="line">		sub[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="comment">// 将取得的表头放入hsub中</span></span><br><span class="line">		<span class="built_in">strcpy</span>(hsub,sub);</span><br><span class="line">		<span class="comment">// 更新sub的值：此时的sub应该去掉表头hsub</span></span><br><span class="line">		<span class="built_in">strcpy</span>(sub,sub+i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(k != <span class="number">0</span>)  <span class="comment">// 判断是否是因为内部括号不匹配</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 是，分割失败</span></span><br><span class="line">	<span class="keyword">else</span>  <span class="comment">// 判断是否是因为i&gt;=n而结束</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 是，情况 &quot;(1,2)&quot;  ==&gt; hsub =&quot;(1,2)&quot;  sub = &quot;&quot;</span></span><br><span class="line">		<span class="comment">// 说明sub整个就是表头</span></span><br><span class="line">		<span class="built_in">strcpy</span>(hsub,sub);  <span class="comment">// 把sub整个赋值给hsub</span></span><br><span class="line">		sub[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// sub赋给hsub后，此时sub为空</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-树和二叉树"><a href="#6-树和二叉树" class="headerlink" title="6 树和二叉树"></a>6 树和二叉树</h1><h2 id="6-1-树及二叉树的概念与性质"><a href="#6-1-树及二叉树的概念与性质" class="headerlink" title="6.1 树及二叉树的概念与性质"></a>6.1 树及二叉树的概念与性质</h2><p><strong>树</strong>：</p>
<ul>
<li><p>结点拥有的子树数称为结点的<strong>度</strong>；</p>
</li>
<li><p>树种结点的最大层次（横向）称为树的<strong>深度****或</strong>高度**；</p>
</li>
<li><p><strong>森林</strong>是<code>m(m&gt;=0)</code>棵互不相交的树的集合。</p>
</li>
</ul>
<p><strong>二叉树</strong></p>
<ul>
<li><p>每个结点至多只有两颗子树，且有左右之分；</p>
<ul>
<li><strong>性质1：</strong>第<code>i</code>层（层次）至多有<code>2^(i-1)</code>个结点；</li>
<li><strong>性质2：</strong>深度为<code>k</code>的二叉树至多有<code>2^k-1</code>个结点；</li>
<li><strong>性质3：</strong>对任何一棵二叉树<code>T</code>，其终端结点数为<code>n0</code>，度为<code>2</code>的结点数为<code>n2</code>，则<code>n0=n2+1</code>；</li>
</ul>
</li>
<li><p>满二叉树：所有结点（除叶子结点外）均有左右分支；</p>
</li>
<li><p>完全二叉树：基于满二叉树实现，<em><strong>性质4&#x2F;5代表从<code>1</code>开始编号的情况。</strong></em></p>
<ul>
<li><strong>性质4：</strong>具有<code>n</code>个结点的<strong>完全二叉树</strong>的深度为<code>[log2n]+1</code>(<code>&quot;[]&quot;</code>表示向下取整)；</li>
<li><strong>性质5：</strong>对一棵有<code>n</code>个结点的<strong>完全二叉树</strong>的结点按层序编号，对任一结点<code>i(1&lt;=i&lt;=n)</code>：<ul>
<li><strong>（1）</strong>若<code>i=1</code>，则结点i是二叉树的根，无双亲；若<code>i&gt;1</code>，则其双亲<code>PARENT(i)</code>是结点<code>[i/2]</code>；</li>
<li><strong>（2）</strong>若<code>2i&gt;n</code>，则结点<code>i</code>无左孩子；否则左孩子是<code>2i</code>；</li>
<li><strong>（3）</strong>若<code>2i+1&gt;n</code>，则结点<code>i</code>无右孩子；否则右孩子是<code>2i+1</code>；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-2-二叉树的链式存储方式（二叉链表，BinTree）"><a href="#6-2-二叉树的链式存储方式（二叉链表，BinTree）" class="headerlink" title="6.2 二叉树的链式存储方式（二叉链表，BinTree）"></a>6.2 二叉树的链式存储方式（二叉链表，BinTree）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType BinTreeNode*</span></span><br></pre></td></tr></table></figure>

<h2 id="6-3-二叉树的非递归遍历"><a href="#6-3-二叉树的非递归遍历" class="headerlink" title="6.3 二叉树的非递归遍历"></a>6.3 二叉树的非递归遍历</h2><p>用<strong>栈</strong>实现。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221544737.png" alt="image-20231222154427982"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221544992.png" alt="image-20231222154440257"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221544658.png" alt="image-20231222154447677"></p>
<h2 id="6-4-二叉树的恢复实现"><a href="#6-4-二叉树的恢复实现" class="headerlink" title="6.4 二叉树的恢复实现"></a>6.4 二叉树的恢复实现</h2><p>两个概念：二叉树的<strong>相似</strong>和<strong>等价</strong>。</p>
<ul>
<li>相似：形状相同，内容不同</li>
<li>等价：形状和内容均相同。</li>
</ul>
<p>二叉树的计数问题：讨论具有<code>n</code>个结点、互不相似的二叉树的数目<code>b</code>。</p>
<p>含有<code>n</code>个结点的不相似的二叉树有：<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312221413095.png" alt="image-20231222141353060" style="zoom: 50%;" />棵。</p>
<blockquote>
<p>1、前序+中序唯一恢复一棵二叉树。</p>
<p>2、中序+后序唯一恢复一棵二叉树。</p>
<p>注意：<strong>恢复二叉树时一定要有中序存在</strong>，因为通过中序遍历可以得知这棵二叉树的左右分布。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序+中序恢复二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_5</span><span class="params">(BinTree *bt, <span class="type">char</span> *VLR, <span class="type">char</span>*LVR, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    CreateBinTree_5(bt-&gt;root, VLR, LVR, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_5</span><span class="params">(BinTreeNode *&amp;t, <span class="type">char</span> *VLR, <span class="type">char</span>*LVR, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(VLR[<span class="number">0</span>] != LVR[k])</span><br><span class="line">            k++;</span><br><span class="line"></span><br><span class="line">        t = (BinTreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTreeNode));</span><br><span class="line">        assert(t != <span class="literal">NULL</span>);</span><br><span class="line">        t-&gt;data = LVR[k];</span><br><span class="line"></span><br><span class="line">        CreateBinTree_5(t-&gt;leftChild, VLR+<span class="number">1</span>, LVR, k);</span><br><span class="line">        CreateBinTree_5(t-&gt;rightChild, VLR+k+<span class="number">1</span>, LVR+k+<span class="number">1</span>, n-k<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序+后序恢复二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_6</span><span class="params">(BinTree *bt, <span class="type">char</span> *LVR, <span class="type">char</span>*LRV, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    CreateBinTree_6(bt-&gt;root, LVR, LRV, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBinTree_6</span><span class="params">(BinTreeNode *&amp;t, <span class="type">char</span> *LVR, <span class="type">char</span>*LRV, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(LRV[n<span class="number">-1</span>] != LVR[k])</span><br><span class="line">            k++;</span><br><span class="line">        </span><br><span class="line">        t = (BinTreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTreeNode));</span><br><span class="line">        assert(t != <span class="literal">NULL</span>);</span><br><span class="line">        t-&gt;data = LVR[k];</span><br><span class="line"></span><br><span class="line">        CreateBinTree_6(t-&gt;rightChild, LVR+k+<span class="number">1</span>, LRV+k, n-k<span class="number">-1</span>);</span><br><span class="line">        CreateBinTree_6(t-&gt;leftChild, LVR, LRV, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-5-线索二叉树"><a href="#6-5-线索二叉树" class="headerlink" title="6.5 线索二叉树"></a>6.5 线索二叉树</h2><blockquote>
<p>同时保存节点的<strong>前驱和后继</strong>信息。由于<code>n</code>个结点必然存在<code>n+1</code>个空链，实际上并未完全保存所有的前驱后继信息，而只是利用了这<code>n+1</code>个空链。</p>
</blockquote>
<p>举例：对下面这棵二叉树按照中序遍历线索化</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312232026443.png" alt="image-20231223202641174"></p>
<h2 id="6-6-树和森林"><a href="#6-6-树和森林" class="headerlink" title="6.6 树和森林"></a>6.6 树和森林</h2><p>讨论树的表示及其遍历操作，并建立森林与二叉树的对应关系。</p>
<p>注意这里的树<em>不局限于二叉树</em>。</p>
<h3 id="1、双亲表示法（仅了解即可）"><a href="#1、双亲表示法（仅了解即可）" class="headerlink" title="1、双亲表示法（仅了解即可）"></a>1、双亲表示法（仅了解即可）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241441068.png" alt="image-20231224144144837" style="zoom: 80%;" />

<p><strong>缺点</strong>：求父结点很方便，但求孩子结点时需要遍历整个结构。</p>
<h3 id="2、孩子表示法（仅了解即可）"><a href="#2、孩子表示法（仅了解即可）" class="headerlink" title="2、孩子表示法（仅了解即可）"></a>2、孩子表示法（仅了解即可）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241517749.png" alt="image-20231224151751633"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241518866.png" alt="image-20231224151800720"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241517901.png" alt="image-20231224151730578"></p>
<h3 id="3、孩子兄弟表示法（重要）"><a href="#3、孩子兄弟表示法（重要）" class="headerlink" title="3、孩子兄弟表示法（重要）"></a>3、孩子兄弟表示法（重要）</h3><p>又称二叉树表示法或二叉链表表示法。即以二叉链表作为树的存储结构。</p>
<p>链表中结点的两个链域分别指向该结点的第一个<strong>孩子结点</strong>和下一个<strong>兄弟结点</strong>。<em>（即左孩子，右兄弟）</em></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241541154.png" alt="image-20231224154137327" style="zoom: 33%;" />

<p>对其进行遍历可得：</p>
<p>（1）先序遍历<strong>（先访问根，再依次访问根的每棵子树）</strong>：<code>A B C D E</code></p>
<p>（2）后序遍历<strong>（先依次访问根的每棵子树，再访问根）</strong>：<code>B D C E A</code></p>
<p><strong>树不包含中序遍历！</strong></p>
<h3 id="4、森林和二叉树的转换"><a href="#4、森林和二叉树的转换" class="headerlink" title="4、森林和二叉树的转换"></a>4、森林和二叉树的转换</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241530772.png" alt="image-20231224153024529" style="zoom: 67%;" />

<p>上图依然遵循“左孩子右兄弟”的概念。当三棵树的树根相连时，树根结点之间的关系即为“兄弟”的关系。</p>
<p>对其进行遍历可得：</p>
<p>（1）先序遍历：<code>A B C D E F G H I J</code></p>
<ul>
<li>访问第一棵树的根结点；</li>
<li>先序遍历第一棵树的根结点的子树森林；</li>
<li>先序遍历除去第一棵树之后剩余的树构成的森林。</li>
</ul>
<p>（2）中序遍历：<code>B C D A F E H J I G</code></p>
<ul>
<li>中序遍历森林中第一棵树的根结点的子树森林；</li>
<li>访问第一棵树的根结点；</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林。</li>
</ul>
<blockquote>
<p>对比图6.15和图6.17可以发现，若以二叉链表的形式表示时：</p>
<ul>
<li>如果仅包含左孩子，则为一棵树的二叉链表表示；</li>
<li>否则，则是森林的二叉链表表示。</li>
</ul>
</blockquote>
<h3 id="5、在树中查找父结点和在二叉树中查找父结点"><a href="#5、在树中查找父结点和在二叉树中查找父结点" class="headerlink" title="5、在树中查找父结点和在二叉树中查找父结点"></a>5、在树中查找父结点和在二叉树中查找父结点</h3><h4 id="（1）在树中查找父结点"><a href="#（1）在树中查找父结点" class="headerlink" title="（1）在树中查找父结点"></a>（1）在树中查找父结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找父结点</span></span><br><span class="line">TreeNode* <span class="title function_">Parent</span><span class="params">(Tree *tree, TreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Parent(tree-&gt;root, p);</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* <span class="title function_">Parent</span><span class="params">(TreeNode *t, TreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span> || p == <span class="literal">NULL</span> || p == t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode *q = t-&gt;firstChild;</span><br><span class="line">    TreeNode *parent;</span><br><span class="line">    <span class="keyword">while</span>(q != <span class="literal">NULL</span> &amp;&amp; q != p)</span><br><span class="line">    &#123;</span><br><span class="line">        parent = Parent(q, p);  <span class="comment">// 在第一个孩子结点中查找parent结点</span></span><br><span class="line">        <span class="keyword">if</span>(parent != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        q = q-&gt;nextSilbing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(q != <span class="literal">NULL</span> &amp;&amp; q == p)  <span class="comment">// q(t-&gt;firstChild)==p说明要查找的结点p的父结点即为t</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312241742171.png" alt="image-20231224174224376" style="zoom: 33%;" />

<h4 id="（2）在二叉树中查找父结点"><a href="#（2）在二叉树中查找父结点" class="headerlink" title="（2）在二叉树中查找父结点"></a>（2）在二叉树中查找父结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找父节点</span></span><br><span class="line">BinTreeNode* <span class="title function_">Parent</span><span class="params">(BinTree *bt, BinTreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Parent(bt-&gt;root, p);</span><br><span class="line">&#125;</span><br><span class="line">BinTreeNode* <span class="title function_">Parent</span><span class="params">(BinTreeNode *t, BinTreeNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span> || p == <span class="literal">NULL</span>)  <span class="comment">// 树为空或查找的节点为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">if</span>(t-&gt;leftChild == p || t-&gt;leftChild == p)</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    </span><br><span class="line">    BinTreeNode *q = Parent(t-&gt;leftChild, p);</span><br><span class="line">    <span class="keyword">if</span>(q != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    <span class="keyword">return</span> Parent(t-&gt;rightChild, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-图"><a href="#7-图" class="headerlink" title="7 图"></a>7 图</h1><h2 id="7-1-图的定义与概念"><a href="#7-1-图的定义与概念" class="headerlink" title="7.1 图的定义与概念"></a>7.1 图的定义与概念</h2><p>图中的数据元素称为<strong>顶点</strong>(<code>Vertex</code>)，<code>V</code>是顶点的有穷非空集合。<code>E</code>是两个顶点之间的集合。</p>
<ul>
<li><p><code>&lt;v, w&gt;</code>：从顶点<code>v</code>到顶点<code>w</code>的有向边；</p>
</li>
<li><p><code>(v, w)</code>：从顶点<code>v</code>到顶点<code>w</code>的无向边。</p>
</li>
</ul>
<p>图中共<code>n</code>个顶点，此时：</p>
<ul>
<li>对无向图来说边的个数范围为<code>0~1/2(n(n-1))</code>，当有<code>1/2(n(n-1)</code>条边时为<strong>无向完全图</strong>。</li>
<li>对有向图来说边的个数范围为<code>0~n(n-1)</code>，当有<code>n(n-1)</code>条边时为<strong>有向完全图</strong>。</li>
</ul>
<p>图（<code>Graph</code>）与子图（<code>Subgraph</code>）</p>
<p>权（<code>Weight</code>）</p>
<p>邻接点</p>
<p>顶点<code>v</code>的度（<code>Degree</code>）是和<code>v</code>相关联的边的数目。在有向图中还要分<strong>入度</strong>和<strong>出度</strong>。</p>
<p>从顶点<code>v</code>到顶点<code>v&#39;</code>的路径（<code>Path</code>）是一个顶点序列。路径的长度是路径上的边或弧的数目。第一个顶点和最后一个顶点相同的路径称为回路或环（<code>Cycle</code>）。在无向图<code>G</code>中，若从顶点<code>v</code>到顶点<code>v&#39;</code>有路径，则称<code>v</code>和<code>v&#39;</code>是连通的。若图中任意两个顶点都是连通的，则称<code>G</code>为<strong>连通图</strong>。而<strong>连通分量</strong>（<code>Connected Component</code>）是指无向图中的<strong>极大连通子图</strong>。</p>
<p>一个连通图的<strong>生成树</strong>是一个极小连通子图。如果在一棵生成树上添加一条边，必定形成一个环。</p>
<h2 id="7-2-图的存储方式"><a href="#7-2-图的存储方式" class="headerlink" title="7.2 图的存储方式"></a>7.2 图的存储方式</h2><h3 id="1、邻接矩阵表示方式（数组形式，重要）"><a href="#1、邻接矩阵表示方式（数组形式，重要）" class="headerlink" title="1、邻接矩阵表示方式（数组形式，重要）"></a>1、邻接矩阵表示方式（数组形式，重要）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312251216684.png" alt="image-20231225121641478" style="zoom: 25%;" />

<p>两个数组分别存储数据元素（顶点）的信息和数据元素之间的关系（边或弧）的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Default_Vertex_Size 10  <span class="comment">// 默认顶点数大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T char</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphMtx</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span>   MaxVertices;    <span class="comment">// 最大顶点数，即容量</span></span><br><span class="line">    <span class="type">int</span>   NumVertices;    <span class="comment">// 当前顶点数，即真实大小</span></span><br><span class="line">    <span class="type">int</span>   NumEdges;       <span class="comment">// 当前边数</span></span><br><span class="line"></span><br><span class="line">    T    *VerticesList;   <span class="comment">// 顶点列表</span></span><br><span class="line">    <span class="type">int</span> **Edge;           <span class="comment">// 指向邻接矩阵，二维数组</span></span><br><span class="line">    <span class="comment">// 一维数组：指向每一行，即每个顶点和其他顶点的边的连接</span></span><br><span class="line">    <span class="comment">// 二维数组：指向每一列，即当前图包含的所有顶点</span></span><br><span class="line"></span><br><span class="line">&#125;GraphMtx;</span><br></pre></td></tr></table></figure>

<h3 id="2、邻接表表示方式（链表形式，重要）"><a href="#2、邻接表表示方式（链表形式，重要）" class="headerlink" title="2、邻接表表示方式（链表形式，重要）"></a>2、邻接表表示方式（链表形式，重要）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Dafault_Vertex_Size 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 边结构。1）保存顶点的位置信息；2）指向下一个顶点的位置信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> dest;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点结构。包含1）顶点的信息；2）指向的边的信息。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T data;</span><br><span class="line">    Edge *adj;</span><br><span class="line">&#125;Vertex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphLink</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> MaxVertices;</span><br><span class="line">    <span class="type">int</span> NumVertices;</span><br><span class="line">    <span class="type">int</span> NumEdges;</span><br><span class="line"></span><br><span class="line">    Vertex *NodeTable;  <span class="comment">// 存放顶点的“List”</span></span><br><span class="line">&#125;GraphLink;</span><br></pre></td></tr></table></figure>

<p>最重要也是最复杂的函数：删除顶点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除顶点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RemoveVertex</span><span class="params">(GraphLink *g, T vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v = GetVertexPos(g, vertex);</span><br><span class="line">    <span class="comment">// 顶点v不存在，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(v == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除顶点：用最后一个顶点的值覆盖要删除的顶点</span></span><br><span class="line">    <span class="comment">// 删除边：直接调用函数RemoveEdge</span></span><br><span class="line"></span><br><span class="line">    Edge *p = g-&gt;NodeTable[v].adj;  <span class="comment">// p指向要删除结点v的边链表</span></span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    Edge *t = <span class="literal">NULL</span>;  <span class="comment">// s的前驱t，注意一定要先赋值为NULL</span></span><br><span class="line">    Edge *s;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        k = p-&gt;dest;  <span class="comment">// 在释放边之前要先获取和这个顶点有关的顶点的位置信息</span></span><br><span class="line">        s = g-&gt;NodeTable[k].adj;  <span class="comment">// s指向和v相连的第一个顶点的边链表</span></span><br><span class="line">        <span class="keyword">while</span>(s != <span class="literal">NULL</span> &amp;&amp; s-&gt;dest != v)</span><br><span class="line">        &#123;</span><br><span class="line">            t = s;</span><br><span class="line">            s = s-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="literal">NULL</span>) </span><br><span class="line">                g-&gt;NodeTable[k].adj = s-&gt;link;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t-&gt;link = s-&gt;link;</span><br><span class="line">            <span class="built_in">free</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放当前结点</span></span><br><span class="line">        g-&gt;NodeTable[v].adj = p-&gt;link;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="comment">// p指向下一个结点，执行下一次删除</span></span><br><span class="line">        p = g-&gt;NodeTable[v].adj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g-&gt;NumVertices--;</span><br><span class="line">    <span class="comment">// 用最后一个结点vl覆盖要删除的结点v</span></span><br><span class="line">    g-&gt;NodeTable[v].data = g-&gt;NodeTable[g-&gt;NumVertices].data;</span><br><span class="line">    g-&gt;NodeTable[v].adj = g-&gt;NodeTable[g-&gt;NumVertices].adj;</span><br><span class="line">    <span class="comment">// 由于此时vl的下标改变，因此遍历vl的边，对应修改和vl相连的顶点，其指向vl的边的下标位置</span></span><br><span class="line">    s = g-&gt;NodeTable[v].adj;</span><br><span class="line">    <span class="keyword">while</span>(s != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        k = s-&gt;dest;</span><br><span class="line">        p = g-&gt;NodeTable[k].adj;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;dest == g-&gt;NumVertices)  <span class="comment">// 找到了指向vl的边</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;dest = v;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、十字链表（仅了解即可）"><a href="#3、十字链表（仅了解即可）" class="headerlink" title="3、十字链表（仅了解即可）"></a>3、十字链表（仅了解即可）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312261148808.png" alt="image-20231226114811489" style="zoom:50%;" />

<h3 id="4、多重邻接表（仅了解即可）"><a href="#4、多重邻接表（仅了解即可）" class="headerlink" title="4、多重邻接表（仅了解即可）"></a>4、多重邻接表（仅了解即可）</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312261256940.png" alt="image-20231226125619799" style="zoom: 50%;" />

<h3 id="5、四种存储结构的对比"><a href="#5、四种存储结构的对比" class="headerlink" title="5、四种存储结构的对比"></a>5、四种存储结构的对比</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312261300229.png" alt="image-20231226130055141" style="zoom: 25%;" />

<h2 id="7-3-图的两种遍历方式"><a href="#7-3-图的两种遍历方式" class="headerlink" title="7.3 图的两种遍历方式"></a>7.3 图的两种遍历方式</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312281111625.png" alt="image-20231228111115955" style="zoom:25%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphLink *g, T vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    <span class="type">bool</span> *visited = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * n);  <span class="comment">// visited数组指明当前顶点是否被访问过</span></span><br><span class="line">    assert(visited != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v = GetVertexPos(g, vertex);</span><br><span class="line">    <span class="keyword">if</span>(v == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    DFS(g, v, visited);</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphLink *g, <span class="type">int</span> v, <span class="type">bool</span> visited[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 顶点A对应的位置为A</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;&quot;</span>, GetVertexValue(g, v));</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问顶点A的邻接点</span></span><br><span class="line">    <span class="type">int</span> w = GetFirstNeighbor(g, GetVertexValue(g, v));</span><br><span class="line">    <span class="keyword">while</span>(w != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 深度遍历</span></span><br><span class="line">        <span class="comment">// 递归访问和当前邻接点相连的邻接点</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[w])</span><br><span class="line">            DFS(g, w, visited);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归访问A的其他邻接点</span></span><br><span class="line">        <span class="comment">// 类似于链表中的 w = w-&gt;next;</span></span><br><span class="line">        w = GetNextNeighbor(g, GetVertexValue(g, v), GetVertexValue(g, w));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 广度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(GraphLink *g, T vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    <span class="type">bool</span> *visited = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * n);  <span class="comment">// visited数组指明当前顶点是否被访问过</span></span><br><span class="line">    assert(visited != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> v = GetVertexPos(g, vertex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;&quot;</span>, GetVertexValue(g, v));</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line"></span><br><span class="line">    EnQueue(&amp;Q, v);</span><br><span class="line">    <span class="keyword">while</span>(!EmptyQueue(&amp;Q))</span><br><span class="line">    &#123;</span><br><span class="line">        GetHead(&amp;Q, &amp;v);</span><br><span class="line">        DeQueue(&amp;Q);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> w = GetFirstNeighbor(g, GetVertexValue(g, v));</span><br><span class="line">        <span class="keyword">while</span>(w != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;&quot;</span>, GetVertexValue(g, w));</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                EnQueue(&amp;Q, w);</span><br><span class="line">            &#125;</span><br><span class="line">            w = GetNextNeighbor(g, GetVertexValue(g, v), GetVertexValue(g, w));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-4-图的连通性问题"><a href="#7-4-图的连通性问题" class="headerlink" title="7.4 图的连通性问题"></a>7.4 图的连通性问题</h2><p><strong>连通图：任意顶点间都有路径可以相互到达。</strong></p>
<p>对于无向图来说，若图连通，则采用<code>DFS/BFS</code>即可遍历整张图。</p>
<h3 id="1、非连通图遍历"><a href="#1、非连通图遍历" class="headerlink" title="1、非连通图遍历"></a>1、非连通图遍历</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312281110107.png" alt="image-20231228111031643" style="zoom: 25%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非连通图遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Components</span><span class="params">(GraphLink *g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    <span class="type">bool</span> *visited = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * n);  <span class="comment">// visited数组指明当前顶点是否被访问过</span></span><br><span class="line">    assert(visited != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            DFS(g, i, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、最小生成树（Minimum-Spanning-Tree-MST）"><a href="#2、最小生成树（Minimum-Spanning-Tree-MST）" class="headerlink" title="2、最小生成树（Minimum Spanning Tree, MST）"></a>2、最小生成树（Minimum Spanning Tree, MST）</h3><p>对于<code>n</code>个顶点，通过<code>n-1</code>条边进行连接，找到加权和最小的图。</p>
<h4 id="（1）Prim算法"><a href="#（1）Prim算法" class="headerlink" title="（1）Prim算法"></a>（1）<code>Prim</code>算法</h4><p>先找一条权值最小的边，然后从这两个顶点出发，依次找和这两个顶点连接的边中权值较小的，逐步扩散。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312281115869.png" alt="image-20231228111509756" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401030936983.png" alt="image-20240103093658857" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401030937827.png" alt="image-20240103093711759" style="zoom:67%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最小生成树_Prim算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MinSpanTree_Prim</span><span class="params">(GraphMtx *g, T vertex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;  <span class="comment">// 计算顶点个数</span></span><br><span class="line">    E *lowcost = (E*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E)*n);  <span class="comment">// lowcost[n]，最小花费的数组</span></span><br><span class="line">    <span class="type">int</span> *mst = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*n);  <span class="comment">// mst[n]，最小花费的起始顶点的数组</span></span><br><span class="line">    assert(lowcost != <span class="literal">NULL</span> &amp;&amp; mst != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、初始化lowcost</span></span><br><span class="line">    <span class="type">int</span> k = GetVertexPos(g, vertex);  <span class="comment">// 获取vertex的位置，作为初始的起始顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != k)</span><br><span class="line">        &#123;</span><br><span class="line">            lowcost[i] = GetWeight(g, k, i);  <span class="comment">// 获取从k到i的边的权重，lowcost[i]中i为终点顶点</span></span><br><span class="line">            mst[i] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            lowcost[i] = <span class="number">0</span>;  <span class="comment">// lowcost[i]=0 ==&gt; 顶点i属于MST的顶点集合</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、从初始起始顶点出发，寻找最小代价的边值</span></span><br><span class="line">    <span class="type">int</span> min, min_index;</span><br><span class="line">    <span class="type">int</span> begin, end;</span><br><span class="line">    E cost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历找到需要的n-1条边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)  <span class="comment">// n-1 ==&gt; n个顶点最多n-1条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        min = MAX_COST;</span><br><span class="line">        min_index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// （1）经过n次遍历，找到从vertex出发的一条权值最小的路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j]&lt;min)  </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// lowcost[j] != 0 ==&gt; 说明顶点j还未加入MST的顶点集合</span></span><br><span class="line">                min = lowcost[j];</span><br><span class="line">                min_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        begin = mst[min_index];</span><br><span class="line">        end = min_index;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;%c : %d\n&quot;</span>, g-&gt;VerticesList[begin], g-&gt;VerticesList[end], min);</span><br><span class="line">        </span><br><span class="line">        lowcost[min_index] = <span class="number">0</span>;  <span class="comment">// 将minx_index所代表的顶点加入MST顶点集合中，后续不再进行考虑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// （2）加入新顶点后，更新此时的lowcost和mst数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cost = GetWeight(g, min_index, j);</span><br><span class="line">            <span class="keyword">if</span>(cost &lt; lowcost[j])</span><br><span class="line">            &#123;</span><br><span class="line">                lowcost[j] = cost;  <span class="comment">// 顶点j到min_index对应顶点的权值比到之前保存的权值更小，因此更新权值</span></span><br><span class="line">                mst[j] = min_index;  <span class="comment">// 更新此时顶点j所对应的起始顶点为min_index对应顶点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（2）Kruskal算法"><a href="#（2）Kruskal算法" class="headerlink" title="（2）Kruskal算法"></a>（2）<code>Kruskal</code>算法</h4><p>每次找权值最小的边，但不关心此时顶点是否已与其他顶点相连。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202312281115942.png" alt="image-20231228111533837" style="zoom:80%;" />

<p><strong>关键点：判断新加入的边是否可已有的边属于同一个连通子图。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断i和j是否处于同一连通子图</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_Same</span><span class="params">(<span class="type">int</span> *father, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从当前节点i开始层层追踪，直到找到其最后的父节点</span></span><br><span class="line">    <span class="comment">// father[i]==i说明i自己是一个单独的存在，没有和它连通的顶点</span></span><br><span class="line">    <span class="keyword">while</span>(father[i] != i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 否则，找到和它连通的顶点，并且层层寻找，直到找到最后一个不和其他顶点相连的顶点</span></span><br><span class="line">        <span class="comment">// 这样就追溯到了他的根节点</span></span><br><span class="line">        i = father[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(father[j] != j)</span><br><span class="line">    &#123;</span><br><span class="line">        j = father[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i==j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将i和j标记为相同集合</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mark_Same</span><span class="params">(<span class="type">int</span> *father, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(father[i] != i)</span><br><span class="line">    &#123;</span><br><span class="line">        i = father[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(father[j] != j)</span><br><span class="line">    &#123;</span><br><span class="line">        j = father[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    father[j] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MinSpanTree_Kruskal</span><span class="params">(GraphMtx *g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    Edge *edge = (Edge*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Edge) * (n*(n<span class="number">-1</span>)/<span class="number">2</span>));</span><br><span class="line">    assert(edge != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化edge结构</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查找邻接矩阵的上三角矩阵，避免重复查找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 顶点间的边存在时，初始化edge结构体</span></span><br><span class="line">            <span class="keyword">if</span>(g-&gt;Edge[i][j] != <span class="number">0</span> &amp;&amp; g-&gt;Edge[i][j] != MAX_COST)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[k].x = i;</span><br><span class="line">                edge[k].y = j;</span><br><span class="line">                edge[k].cost = g-&gt;Edge[i][j];</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;k; ++i)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     v1 = edge[i].x;</span></span><br><span class="line">    <span class="comment">//     v2 = edge[i].y;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%c--&gt;%c : %d\n&quot;, g-&gt;VerticesList[v1], g-&gt;VerticesList[v2], edge[i].cost);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将边按照权值升序排序</span></span><br><span class="line">    qsort(edge, k, <span class="keyword">sizeof</span>(Edge), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法核心，判断新加入的边是否可已有的边属于同一个连通子图</span></span><br><span class="line">    <span class="type">int</span> *father = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) *n);</span><br><span class="line">    assert(father != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i] = i;  <span class="comment">// 初始化i的父节点为i自己</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当x与y的父节点不为同一个父节点时，进行连接</span></span><br><span class="line">        <span class="keyword">if</span>(!Is_Same(father, edge[i].x, edge[i].y))</span><br><span class="line">        &#123;</span><br><span class="line">            v1 = edge[i].x;</span><br><span class="line">            v2 = edge[i].y;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;%c : %d\n&quot;</span>, g-&gt;VerticesList[v1], g-&gt;VerticesList[v2], edge[i].cost);</span><br><span class="line">            Mark_Same(father, edge[i].x, edge[i].y);  <span class="comment">// 连接x和y后，将其标记为Same，合并为一个整体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一般来说，两个算法得到的最小生成树唯一。权值相同时可能形状存在差异，但加权和一定一致。</strong></p>
<h2 id="7-5-有向无环图（Directed-Acyclic-Graph-DAG）"><a href="#7-5-有向无环图（Directed-Acyclic-Graph-DAG）" class="headerlink" title="7.5 有向无环图（Directed Acyclic Graph, DAG）"></a>7.5 有向无环图（Directed Acyclic Graph, DAG）</h2><p><code>DAG</code>图是描述含有公共子式的表达式的有效工具。</p>
<ul>
<li><p><code>AOV（Activity On Vertex）</code>：以顶点为活动的网络图</p>
</li>
<li><p><code>AOE（Activity On Edge）</code>：以边为活动的网络图</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401071525659.png" alt="image-20240107152528272"></p>
<h3 id="1、拓扑排序（Topological-Sort）"><a href="#1、拓扑排序（Topological-Sort）" class="headerlink" title="1、拓扑排序（Topological Sort）"></a>1、拓扑排序（<code>Topological Sort</code>）</h3><p><strong>定义</strong>：由某个集合上的一个偏序得到该集合上的一个全序，这个操作称为拓扑排序。（<code>AOV</code>）</p>
<blockquote>
<p><strong>步骤：</strong></p>
<p><strong>s1、先找到一个没有入度的顶点，放入排序中；</strong></p>
<p><strong>s2、删除该顶点和与其相关的边，此时各顶点的入度改变；</strong></p>
<p><strong>s3、重复s1和s2，直至不存在顶点未被排序。</strong></p>
</blockquote>
<p><strong>关键实现</strong>：</p>
<ul>
<li>建立一个栈结构，保存顶点及其入度相关的信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TopologicalSort</span><span class="params">(GraphLink *g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;  <span class="comment">// 顶点个数</span></span><br><span class="line">    <span class="type">int</span> *count = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*n);  <span class="comment">// 初始化count数组，存储顶点及其入度信息</span></span><br><span class="line">    assert(count != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        count[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计入度信息</span></span><br><span class="line">    Edge *p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = g-&gt;NodeTable[i].adj;  <span class="comment">// p指向存放当前顶点边信息的邻接表</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count[p-&gt;dest]++;  <span class="comment">// 在count数组中，对应有入度的顶点位置++</span></span><br><span class="line">            p = p-&gt;link;  <span class="comment">// p指向下一个顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;n; ++i)</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\n&quot;, count[i]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历count，找到所有入度为0的顶点，并存入栈中</span></span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;  <span class="comment">// 所谓的“栈顶指针”</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若该顶点入度为0</span></span><br><span class="line">        <span class="keyword">if</span>(count[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 模拟入栈</span></span><br><span class="line">            count[i] = top;  <span class="comment">// count[i]保存了上一个入度为0的顶点的下标   </span></span><br><span class="line">            top = i;  <span class="comment">// top指向顶点i（即入度为0的栈顶元素）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v, w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(top == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;网络中有回路，无法进行拓扑排序！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 模拟出栈</span></span><br><span class="line">            v = top;  <span class="comment">// v指向栈顶元素（即此时度为0的顶点）</span></span><br><span class="line">            top = count[top];  <span class="comment">// 相当于出栈顶点v的操作</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c--&gt;&quot;</span>, g-&gt;NodeTable[v]);</span><br><span class="line">            <span class="comment">// 求解v的邻接顶点</span></span><br><span class="line">            w = GetFirstNeighbor(g, g-&gt;NodeTable[v].data);</span><br><span class="line">            <span class="keyword">while</span>(w != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 删去对应的边后若入度为0，则对顶点w进行入栈操作</span></span><br><span class="line">                <span class="keyword">if</span>(--count[w] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 入栈</span></span><br><span class="line">                    count[w] = top;</span><br><span class="line">                    top = w;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则不进行入栈操作，寻找下一个邻接顶点</span></span><br><span class="line">                w = GetNextNeighbor(g, g-&gt;NodeTable[v].data, g-&gt;NodeTable[w].data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Nul.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、关键路径求解（Critical-Path）"><a href="#2、关键路径求解（Critical-Path）" class="headerlink" title="2、关键路径求解（Critical Path）"></a>2、关键路径求解（Critical Path）</h3><p><strong>定义</strong>：由于在<code>AOE</code>网中有些活动可以并行地进行，所以完成工程的最短时间是从开始点到完成点的最长路径的长度，路径长度最长的路径叫做关键路径。（这里的路径长度指路径上各活动的持续时间之和）</p>
<blockquote>
<p><strong>步骤：</strong></p>
<p><strong>s1、先正向求解每个顶点的最早开始时间；</strong></p>
<p><strong>s2、再反向求解每个顶点的最晚开始时间。</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求解关键路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CriticalPath</span><span class="params">(GraphMtx *g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;</span><br><span class="line">    <span class="type">int</span> *ve = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    <span class="type">int</span> *vl = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    assert(ve != <span class="literal">NULL</span> &amp;&amp; vl != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ve[i] = <span class="number">0</span>;</span><br><span class="line">        vl[i] = MAX_COST;  <span class="comment">// 此处不能初始化为0，否则求解vl时会出现负数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正向求解每个顶点的最早开始时间，ve</span></span><br><span class="line">    <span class="comment">// 实际上这个步骤相当于在初始化最早开始时间</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        对最早开始时间的理解：</span></span><br><span class="line"><span class="comment">            假设此时有一条边从v指向w，</span></span><br><span class="line"><span class="comment">            v的最早开始时间为t1，w的最早开始时间为t2，边v-&gt;w的权值为cost，</span></span><br><span class="line"><span class="comment">            若t1+cost&gt;t2，则更新t2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> j, w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        j = GetFirstNeighbor(g, g-&gt;VerticesList[i]);  <span class="comment">// 指向i的第一个邻接顶点</span></span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            w = GetWeight(g, i, j);  <span class="comment">// 获取边i-&gt;j的权值</span></span><br><span class="line">            <span class="keyword">if</span>((ve[i] + w) &gt; ve[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ve[j] = ve[i] + w;</span><br><span class="line">            &#125;</span><br><span class="line">            j = GetNextNeighbor(g, g-&gt;VerticesList[i], g-&gt;VerticesList[j]);  <span class="comment">// 获取下一个邻接顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;n; ++i)</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\t&quot;, ve[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向求解每个顶点的最晚开始时间，vl</span></span><br><span class="line">    <span class="comment">// 实际上这个步骤相当于在初始化最晚开始时间</span></span><br><span class="line">    <span class="comment">// 最晚开始时间：如果从顶点i到顶点j存在多条路径，则最长时间的那条路径A为关键路径，而小于最长时间的其他路径可以在A开始后一段时间再进行</span></span><br><span class="line">    vl[n<span class="number">-1</span>] = ve[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>; i&gt;<span class="number">0</span>; --i)  <span class="comment">// 从倒数第二个顶点开始往前遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        j = GetFirstNeighbor(g, g-&gt;VerticesList[i]);  <span class="comment">// 指向i的第一个邻接顶点</span></span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            w = GetWeight(g, i, j);</span><br><span class="line">            <span class="comment">// 若步骤j的最晚开始时间（vl[j]）减去活动(i, j)的时间（w）小于步骤i的最晚开始时间（vl[i]），更新vl[i]</span></span><br><span class="line">            <span class="comment">// 因为说明此时活动(i, j)的持续时间要长于原先走的那条路径，所以要进行更新</span></span><br><span class="line">            <span class="comment">// 也就是说，应该选择更小的时间</span></span><br><span class="line">            <span class="keyword">if</span>((vl[j] - w) &lt; vl[i])  </span><br><span class="line">            &#123;</span><br><span class="line">                vl[i] = vl[j] - w;</span><br><span class="line">            &#125;</span><br><span class="line">            j = GetNextNeighbor(g, g-&gt;VerticesList[i], g-&gt;VerticesList[j]);  <span class="comment">// 获取下一个邻接顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;n; ++i)</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\t&quot;, vl[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> Ae, Al;  <span class="comment">// 活动的最早开始时间和最晚开始时间，这里的A代表边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        j = GetFirstNeighbor(g, g-&gt;VerticesList[i]);  <span class="comment">// 指向i的第一个邻接顶点</span></span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Ae = ve[i];  <span class="comment">// 活动的最早开始时间</span></span><br><span class="line">            Al = vl[j] - GetWeight(g, i, j);  <span class="comment">// 有点没太理解这一行</span></span><br><span class="line">            <span class="comment">// vl[j]是顶点j代表该步骤的最晚开始时间，边ij的权重是从完成步骤i所需的时间</span></span><br><span class="line">            <span class="comment">// vl[j] - GetWeight(g, i, j)即代表活动j的最晚开始时间</span></span><br><span class="line">            <span class="keyword">if</span>(Ae == Al)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 说明i和j是关键路径上的两个顶点</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;%c, %c&gt;是关键路径.\n&quot;</span>, g-&gt;VerticesList[i], g-&gt;VerticesList[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            j = GetNextNeighbor(g, g-&gt;VerticesList[i], g-&gt;VerticesList[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ve);</span><br><span class="line">    <span class="built_in">free</span>(vl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-6-最短路径"><a href="#7-6-最短路径" class="headerlink" title="7.6 最短路径"></a>7.6 最短路径</h2><p><strong>从某个源点到其余各个顶点的最短路径</strong></p>
<p><strong><code>Dijkstra</code>算法</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401081053558.png" alt="image-20240108105354193" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401081055708.png" alt="image-20240108105532557" style="zoom: 50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// diskstra算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath</span><span class="params">(GraphMtx *g, T vertex, E dist[], <span class="type">int</span> path[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = g-&gt;NumVertices;  <span class="comment">// 记录顶点个数</span></span><br><span class="line">    <span class="type">bool</span> *S = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>)*n);  <span class="comment">// 已找到从vertex出发的最短路径的终点的集合</span></span><br><span class="line">    assert(S != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v = GetVertexPos(g, vertex);  <span class="comment">// 得到vertex的下标位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dist[i] = GetWeight(g, v, i);  <span class="comment">// 获取顶点vertex到其余各顶点对应的权值，初始化dist</span></span><br><span class="line">        S[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(i != v &amp;&amp; dist[i] &lt; MAX_COST)</span><br><span class="line">        &#123;</span><br><span class="line">            path[i] = v;  <span class="comment">// 若vertex和顶点i有边（方向为vertex-&gt;i），则初始化其起始点为vertex</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            path[i] = <span class="number">-1</span>;  <span class="comment">// 否则初始化其起始点为-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    S[v] = <span class="literal">true</span>;  <span class="comment">// 代表顶点vertex已经加入集合</span></span><br><span class="line">    <span class="type">int</span> min, w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)  <span class="comment">// n-1是因为起始点已经定为vertex了</span></span><br><span class="line">    &#123;</span><br><span class="line">        min = MAX_COST;  <span class="comment">// 初始化最小花费为最大代价</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在本次循环中找到花费最小的路径&lt;i, j&gt;，并用顶点u记录这个顶点j方便后续处理</span></span><br><span class="line">        <span class="type">int</span> u = v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!S[j] &amp;&amp; dist[j] &lt; min)  <span class="comment">// !S[j] --&gt; 未加入集合</span></span><br><span class="line">            &#123;</span><br><span class="line">                u = j;  <span class="comment">// 记录当前顶点</span></span><br><span class="line">                min = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        S[u] = <span class="literal">true</span>;  <span class="comment">// 加入顶点u</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从顶点u出发，更新从u出发到达其他顶点的dist对应的权重</span></span><br><span class="line">        <span class="comment">// 相当于更新dist数组，以便进入下一次循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            w = GetWeight(g, u, k);  <span class="comment">// 顶点u到其余顶点的权值</span></span><br><span class="line">            <span class="keyword">if</span>(!S[k] &amp;&amp; w &lt; MAX_COST &amp;&amp; (dist[u]+w)&lt;dist[k])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[k] = dist[u] + w;</span><br><span class="line">                path[k] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d--&gt;&quot;</span>, path[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Nul.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d--&gt;&quot;</span>, dist[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Nul.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-查找"><a href="#8-查找" class="headerlink" title="8 查找"></a>8 查找</h1><p><strong>查找表</strong>（<code>Search Table</code>）：由同一类型的数据元素（或记录）构成的集合。</p>
<h2 id="8-1-静态查找表"><a href="#8-1-静态查找表" class="headerlink" title="8.1 静态查找表"></a>8.1 静态查找表</h2><h2 id="8-2-动态查找表"><a href="#8-2-动态查找表" class="headerlink" title="8.2 动态查找表"></a>8.2 动态查找表</h2><p><strong>定义</strong>：表结构本身是在查找过程中动态生成的。即对于给定key值，若表中存在关键字等于key值的记录，则查找成功返回；否则插入关键字等于key的记录。</p>
<h3 id="1、二叉排序树（Binary-Sort-Tree）"><a href="#1、二叉排序树（Binary-Sort-Tree）" class="headerlink" title="1、二叉排序树（Binary Sort Tree）"></a>1、二叉排序树（Binary Sort Tree）</h3><p>二叉排序树又称二叉搜索树。</p>
<p><strong>定义</strong>：</p>
<ul>
<li>（1）若左子树非空，则左子树上的所有结点的值小于根节点的值；</li>
<li>（2）若右子树非空，则右子树上的所有结点的值大于根节点的值；</li>
<li>（3）左、右子树分别也为二叉排序树。</li>
</ul>
<h3 id="2、平衡二叉树（Balanced-Binary-Tree-Height-Balanced-Tree）"><a href="#2、平衡二叉树（Balanced-Binary-Tree-Height-Balanced-Tree）" class="headerlink" title="2、平衡二叉树（Balanced Binary Tree&#x2F;Height-Balanced Tree）"></a>2、平衡二叉树（Balanced Binary Tree&#x2F;Height-Balanced Tree）</h3><p>平衡二叉树的前提是这棵树为二叉搜索树。</p>
<p><strong>平衡</strong>：左右子树的深度之差绝对值不大于1。</p>
<p><strong>平衡因子</strong><code>BF(Balanced Factor)</code>：该结点的右子树的深度减去其左子树的深度。</p>
<blockquote>
<p>深度：从根节点数到它的叶节点；</p>
<p>⾼度：从叶节点数到它的根节点</p>
</blockquote>
<p><strong>处理方法</strong>：旋转时结点的处理顺序是从<strong>第一个不平衡的结点</strong>开始。</p>
<ul>
<li>单旋转：不平衡的结点处于同一直线<ul>
<li>左旋转</li>
<li>右旋转</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401191222815.png" alt="image-20240119122225757" style="zoom: 25%;" />

<ul>
<li>双旋转：不平衡的结点处于折线状态<ul>
<li>先左后右（针对向左突出，＜）</li>
<li>先右后左（针对向右突出，＞）</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401191600972.png" alt="image-20240119160055303" style="zoom:25%;" />

<p>删除结点：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401211202772.png" alt="image-20240121120204211"></p>
<h3 id="3、哈希表"><a href="#3、哈希表" class="headerlink" title="3、哈希表"></a>3、哈希表</h3><p><strong>定义：</strong></p>
<p>根据设定的哈希函数<code>H(key)</code>和处理冲突的方法将一组关键字映像到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置。这一映像过程称为<strong>哈希表</strong>或<strong>散列</strong>，所得存储位置称哈希地址或散列地址。</p>
<p><strong>关键问题：</strong></p>
<p>1、创建哈希函数；</p>
<ul>
<li><strong>除留余数法</strong>；（使用最广泛）</li>
</ul>
<p>2、解决哈希冲突。</p>
<ul>
<li><strong>链地址法</strong>；（使用最广泛，相当于顺序表+链表）</li>
</ul>
<p><strong>溢出表算法（公司面试题）</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401231117485.png" alt="image-20240123111749039"></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401231307889.png" alt="image-20240123130752821" style="zoom: 25%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init_bucket_node</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;P; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;BUCKET_NODE_SIZE; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            hash_table[i].data[j] = NULL_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">        hash_table[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Insert_new_element</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="built_in">Hash</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;BUCKET_NODE_SIZE; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hash_table[index].data[i] == NULL_DATA)</span><br><span class="line">        &#123;</span><br><span class="line">            hash_table[index].data[i] = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 溢出桶有空余，直接插入</span></span><br><span class="line">    bucket_node *p = &amp;hash_table[index];</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;BUCKET_NODE_SIZE; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data[i] == NULL_DATA)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;data[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不存在有空余的溢出桶，则新建一个</span></span><br><span class="line">    bucket_node *s = (bucket_node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(bucket_node));</span><br><span class="line">    <span class="built_in">assert</span>(s != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;BUCKET_NODE_SIZE; ++i)</span><br><span class="line">        s-&gt;data[i] = NULL_DATA;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    s-&gt;data[<span class="number">0</span>] = x;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-排序"><a href="#9-排序" class="headerlink" title="9 排序"></a>9 排序</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><p>线性&#x2F;非线性数据结构和排序都是为了最终的查找服务的。</p>
<p><strong>排序方法的稳定与否是针对相同的关键字而言的。若相同的关键字在排序后次序无变化，则其是稳定的。</strong></p>
<p><strong>分类：</strong></p>
<ul>
<li>内部排序：数据量较小，所有的数据一次性全部放入<strong>内存</strong>进行。<ul>
<li><strong>插入排序（稳定排序）</strong></li>
<li><strong>交换排序</strong></li>
<li><strong>选择排序</strong></li>
<li><strong>归并排序</strong></li>
<li><strong>基数排序</strong></li>
</ul>
</li>
<li>外部排序：数据量过大，一部分数据在<strong>内存</strong>中先进行排序，其余的数据暂存在磁盘中。</li>
</ul>
<p><strong>基本方法：</strong></p>
<ul>
<li>比较两个关键字的大小；</li>
<li>将记录从一个位置移动至另一个位置。</li>
</ul>
<h2 id="9-2-插入排序"><a href="#9-2-插入排序" class="headerlink" title="9.2 插入排序"></a>9.2 插入排序</h2><p>插入排序（稳定排序）</p>
<h3 id="1、直接插入排序"><a href="#1、直接插入排序" class="headerlink" title="1、直接插入排序"></a>1、直接插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接插入排序 O(n^2)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T *a, T*b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void InsertSort(SqList &amp;L, int n)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    for(int i=1; i&lt;n; ++i)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(L[i] &lt; L[i-1])</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            Swap(&amp;L[i], &amp;L[i-1]);</span></span><br><span class="line"><span class="comment">            for(int j=i-1; j&gt;0 &amp;&amp; L[j]&lt;L[j-1]; --j)  // important</span></span><br><span class="line"><span class="comment">                Swap(&amp;L[j], &amp;L[j-1]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 改进</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] &lt; L[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            L[<span class="number">0</span>] = L[i];</span><br><span class="line">            L[i] = L[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> j = i<span class="number">-2</span>;            </span><br><span class="line">            <span class="keyword">while</span>(L[<span class="number">0</span>]&lt;L[j])</span><br><span class="line">            &#123;</span><br><span class="line">                L[j+<span class="number">1</span>] = L[j];</span><br><span class="line">                --j;</span><br><span class="line">            &#125;            </span><br><span class="line">            L[j+<span class="number">1</span>] = L[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、折半插入排序"><a href="#2、折半插入排序" class="headerlink" title="2、折半插入排序"></a>2、折半插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 折半插入排序 O(n^2)  -- 减少直接插入排序的关键字比较次数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BInsertSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        L[<span class="number">0</span>] = L[i];</span><br><span class="line">        <span class="type">int</span> low = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> high = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)  <span class="comment">// 折半插入，通过移动low/high找到该插入的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(L[<span class="number">0</span>] &gt;= L[mid])</span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&gt;high+<span class="number">1</span>; --j)  <span class="comment">// high+1是要插入L[0]的数值的位置，因此把high+1到i的值全部往后挪动一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            L[j] = L[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        L[high+<span class="number">1</span>] = L[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、2路插入排序"><a href="#3、2路插入排序" class="headerlink" title="3、2路插入排序"></a>3、2路插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2路插入排序  -- 减少折半插入排序的数据移动次数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TWayInsertSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList tmp;</span><br><span class="line">    tmp[<span class="number">0</span>] = L[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> head, tail;</span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; ++i)  <span class="comment">// L[i]是当前要插入tmp的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] &lt; tmp[head])  <span class="comment">// 若当前遍历到的L[i]小于head所指元素，则将L[i]插入到head的前一个位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = (head<span class="number">-1</span>+n) % n;  <span class="comment">// 取模操作实现循环操作</span></span><br><span class="line">            tmp[head] = L[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L[i] &gt; tmp[tail])  <span class="comment">// 同理，若当前遍历到的L[i]大于head所指元素，则将L[i]插入到head的后一个位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            tail++;</span><br><span class="line">            tmp[tail] = L[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 若tmp[head]&lt;L[i]&lt;tmp[tail]，则需要移动数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            tail++;</span><br><span class="line">            tmp[tail] = tmp[tail<span class="number">-1</span>];  <span class="comment">// 将tmp[tail]向后移动一个，并将tail本身的值加1</span></span><br><span class="line">            <span class="type">int</span> j = tail<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(L[i] &lt; tmp[(j<span class="number">-1</span>+n)%n])  <span class="comment">// L[i]&lt;tmp[(j-1+n)%n]，找到L[i]应该插入的地方，即tmp[j]</span></span><br><span class="line">                                          <span class="comment">// 由于这里的j的指向是循环的，所以(j-1+n)%n相当于j-1</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp[j] = tmp[(j<span class="number">-1</span>+n)%n];</span><br><span class="line">                j = (j<span class="number">-1</span>+n)%n;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp[j] = L[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        L[i] = tmp[head];</span><br><span class="line">        head = (head+<span class="number">1</span>)%n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、表插入排序"><a href="#4、表插入排序" class="headerlink" title="4、表插入排序"></a>4、表插入排序</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401241536655.png" alt="image-20240124153639775" style="zoom: 25%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表插入排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVALUE 0x7fffffff</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SLNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">    <span class="type">int</span> link;</span><br><span class="line">&#125;SLNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> SLNode Table[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableInsertSort</span><span class="params">(Table t, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[<span class="number">0</span>].link = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p, q;  <span class="comment">// q是p的前驱</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = t[<span class="number">0</span>].link;  <span class="comment">// p指向当前检索的值的下标，每一次都要从t[0].link指向的头开始排序</span></span><br><span class="line">        q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">0</span> &amp;&amp; t[p].data&lt;=t[i].data)  <span class="comment">// p!=0说明未检索完；t[p].data&lt;=t[i].data说明当前检索到的值小于等于要排序进来的值，所以要接着往下找更大的值</span></span><br><span class="line">        &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = t[p].link;  <span class="comment">// p指向下一个更大的值对应的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当退出循环时，t[p].data&gt;t[i].data，则i在p的前驱位置插入</span></span><br><span class="line">        t[i].link = t[q].link;</span><br><span class="line">        t[q].link = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、希尔排序"><a href="#5、希尔排序" class="headerlink" title="5、希尔排序"></a>5、希尔排序</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401251321618.png" alt="image-20240125132057065"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> n, <span class="type">int</span> dk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=dk+<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] &lt; L[i-dk])  <span class="comment">// 间隔两端的两个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            L[<span class="number">0</span>] = L[i];</span><br><span class="line">            <span class="type">int</span> j = i - dk;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; L[<span class="number">0</span>] &lt; L[j])</span><br><span class="line">            &#123;</span><br><span class="line">                L[j+dk] = L[j];  <span class="comment">// 在间隔上取的几个数之间进行直接插入排序，需要注意这里数之间的间隔是dk</span></span><br><span class="line">                j -= dk;</span><br><span class="line">            &#125;</span><br><span class="line">            L[j+dk] = L[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n, <span class="type">int</span> dlta[], <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;t; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShellInsert</span>(L, n, dlta[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-3-交换排序"><a href="#9-3-交换排序" class="headerlink" title="9.3 交换排序"></a>9.3 交换排序</h2><h3 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n<span class="number">-1</span>-i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L[j] &gt; L[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Swap</span>(&amp;L[j], &amp;L[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、快速排序"><a href="#2、快速排序" class="headerlink" title="2、快速排序"></a>2、快速排序</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401251320399.png" alt="image-20240125132023301" style="zoom: 25%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T pk = L[low];  <span class="comment">// 先指定L[low]为关键字</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; L[high]&gt;=pk)  <span class="comment">// 循环使得high指向小于枢轴的值</span></span><br><span class="line">            high--;</span><br><span class="line">        L[low] = L[high];  <span class="comment">// 将这个较小的L[high]值赋值给low所处的位置</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; L[low]&lt;pk)  <span class="comment">// 循环使得low指向大于枢轴的值</span></span><br><span class="line">            low++;</span><br><span class="line">        L[high] = L[low];  <span class="comment">// 将这个较大的L[low]值赋值给high所处的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    L[low] = pk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)  <span class="comment">// 未排序完成</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pkloc = <span class="built_in">Partition</span>(L, low, high);  <span class="comment">// 求枢轴关键字的位置</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(L, low, pkloc<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(L, pkloc+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-4-选择排序"><a href="#9-4-选择排序" class="headerlink" title="9.4 选择排序"></a>9.4 选择排序</h2><h3 id="1、简单选择排序"><a href="#1、简单选择排序" class="headerlink" title="1、简单选择排序"></a>1、简单选择排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SelectMinKey</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T minval = L[i];</span><br><span class="line">    <span class="type">int</span> pos = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m=i+<span class="number">1</span>; m&lt;n; ++m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[m] &lt; minval)</span><br><span class="line">        &#123;</span><br><span class="line">            minval = L[m];</span><br><span class="line">            pos = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="built_in">SelectMinKey</span>(L, i, n);  <span class="comment">// 找到最小值对应的下标位置</span></span><br><span class="line">        <span class="keyword">if</span>(j != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Swap</span>(&amp;L[j], &amp;L[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、树形选择排序"><a href="#2、树形选择排序" class="headerlink" title="2、树形选择排序"></a>2、树形选择排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 树形选择排序，相较于简单选择排序减少了比较次数（锦标赛排序）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVALUE 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">GetValue</span><span class="params">(T e[], <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p &gt;= n)</span><br><span class="line">        <span class="keyword">return</span> MAXVALUE;</span><br><span class="line">    </span><br><span class="line">    T value;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; n/<span class="number">2</span>)  <span class="comment">// 得到的是下标位置</span></span><br><span class="line">        value = e[e[p]];</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 否则为叶子节点，直接返回e[p]</span></span><br><span class="line">        value = e[p];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Play</span><span class="params">(T e[], <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> left, right;  <span class="comment">// 左右下标</span></span><br><span class="line">    T lval, rval;  <span class="comment">// 左右值</span></span><br><span class="line">    <span class="keyword">while</span>(p &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        left = <span class="number">2</span>*p+<span class="number">1</span>;</span><br><span class="line">        right = <span class="number">2</span>*p+<span class="number">2</span>;</span><br><span class="line">        lval = <span class="built_in">GetValue</span>(e, n, left);</span><br><span class="line">        rval = <span class="built_in">GetValue</span>(e, n, right);</span><br><span class="line">        <span class="keyword">if</span>(lval &lt;= rval)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &lt; n/<span class="number">2</span>)</span><br><span class="line">                e[p] = e[left];  <span class="comment">// important</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[p] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(right &lt; n/<span class="number">2</span>)</span><br><span class="line">                e[p] = e[right];  <span class="comment">// important</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[p] = right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        --p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select</span><span class="params">(T e[], <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = p;  <span class="comment">// 父节点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">2</span>*p+<span class="number">1</span>;  <span class="comment">// 左子树</span></span><br><span class="line">    T lval, rval;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; flag)</span><br><span class="line">    &#123;</span><br><span class="line">        lval = <span class="built_in">GetValue</span>(e, n, j);</span><br><span class="line">        rval = <span class="built_in">GetValue</span>(e, n, j+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(lval &lt;= rval)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; n/<span class="number">2</span>)</span><br><span class="line">                e[i] = e[j];  <span class="comment">// j&lt;n/2说明j的位置在非叶子节点的位置，所以对于j的父节点，需要的是位置j上存储的内容即e[j]</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[i] = j;  <span class="comment">// j&gt;=n/2说明j的位置在叶子节点的位置，所以对于j的父节点，需要的是就是位置j本身</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((j+<span class="number">1</span>) &lt; n/<span class="number">2</span>)</span><br><span class="line">                e[i] = e[j+<span class="number">1</span>];  <span class="comment">// 同上</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[i] = j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            flag--;</span><br><span class="line">        <span class="comment">// 向上递归，找到新的父节点和对应的左孩子</span></span><br><span class="line">        i = (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        j = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TreeSelectSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">    T *e = (T*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T) * size);</span><br><span class="line">    <span class="built_in">assert</span>(e != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = size / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        e[k++] = L[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> curpos = size/<span class="number">2</span><span class="number">-1</span>;  <span class="comment">// 树最后一个叶子分支的父节点，相当于要打的第一场比赛</span></span><br><span class="line">    <span class="built_in">Play</span>(e, size, curpos);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    L[i] = e[e[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将已经选出来的最小值的节点A，将其赋值为最大值，使其不参与后续的比较</span></span><br><span class="line">    e[e[<span class="number">0</span>]] = MAXVALUE;  </span><br><span class="line">    <span class="comment">// 从A的父节点开始一路向上比较，直到到达根节点，比较完毕</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        curpos = (e[<span class="number">0</span>]<span class="number">-1</span>)/<span class="number">2</span>;  <span class="comment">// A的父节点</span></span><br><span class="line">        <span class="built_in">Select</span>(e, size, curpos);</span><br><span class="line">        L[i] = e[e[<span class="number">0</span>]];</span><br><span class="line">        e[e[<span class="number">0</span>]] = MAXVALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(e);</span><br><span class="line">    e = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、堆排序"><a href="#3、堆排序" class="headerlink" title="3、堆排序"></a>3、堆排序</h3><p><strong>大堆</strong>：父节点大于左右孩子；</p>
<p><strong>小堆</strong>：父节点小于左右孩子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆排序，相较于树形选择排序辅助空间大幅减少，只需要1个辅助空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(T heap[], <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = p;  <span class="comment">// 父节点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">2</span>*i+<span class="number">1</span>;  <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; n)  <span class="comment">// 说明p有左孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;n<span class="number">-1</span> &amp;&amp; heap[j]&gt;heap[j+<span class="number">1</span>])  <span class="comment">// j&lt;n-1说明有右孩子，heap[j]&gt;heap[j+1]说明左孩子大于右孩子</span></span><br><span class="line">            j++;  <span class="comment">// j指向右孩子，也即是保证j指向左右孩子中较小的那个值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(heap[i] &lt;= heap[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Swap</span>(&amp;heap[i], &amp;heap[j]);</span><br><span class="line">            <span class="comment">// 继续递归，使得该函数从位置p一直遍历到叶子结点</span></span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T <span class="title">RemoveMinKey</span><span class="params">(T heap[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T key = heap[<span class="number">0</span>];</span><br><span class="line">    heap[<span class="number">0</span>] = heap[n];</span><br><span class="line">    <span class="built_in">siftDown</span>(heap, n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T *heap = (T*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T) * n);</span><br><span class="line">    <span class="built_in">assert</span>(heap != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        heap[i] = L[i];  <span class="comment">// 将原始数据拷贝到heap空间中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将heap调整为小堆</span></span><br><span class="line">    <span class="comment">// 1、找到最后一个分支节点，调用函数SiftDown后，目前的堆顶元素即为当前序列的最小值</span></span><br><span class="line">    <span class="type">int</span> curpos = n/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(curpos &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">siftDown</span>(heap, n, curpos);</span><br><span class="line">        curpos--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、取走堆顶元素后，依次用最后一个节点补上根节点（最小值），重新进行小堆排序并取堆顶元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        L[i] = <span class="built_in">RemoveMinKey</span>(heap, n-i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-5-归并排序"><a href="#9-5-归并排序" class="headerlink" title="9.5 归并排序"></a>9.5 归并排序</h2><p><strong>2-路归并排序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(SqList &amp;L, SqList &amp;TP, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left; i&lt;=right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        TP[i] = L[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s1 = left;</span><br><span class="line">    <span class="type">int</span> s2 = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = left;</span><br><span class="line">    <span class="keyword">while</span>(s1&lt;=mid &amp;&amp; s2&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(TP[s1] &lt;= TP[s2])</span><br><span class="line">            L[k++] = TP[s1++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L[k++] = TP[s2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s1 &lt;= mid)</span><br><span class="line">        L[k++] = TP[s1++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(s2&lt;=right)</span><br><span class="line">        L[k++] = TP[s2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(SqList &amp;L, SqList &amp;TP, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(L, TP, left, mid);</span><br><span class="line">    <span class="built_in">MergeSort</span>(L, TP, mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="built_in">Merge</span>(L, TP, left, mid, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-6-基数排序"><a href="#9-6-基数排序" class="headerlink" title="9.6 基数排序"></a>9.6 基数排序</h2><p>对数据的<strong>分配和收集</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202401262157878.png" alt="image-20240126215723896"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基数排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getkey</span><span class="params">(T value, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">while</span>(k &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        key = value % <span class="number">10</span>;</span><br><span class="line">        value /= <span class="number">10</span>;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Distribute</span><span class="params">(SqList &amp;L, <span class="type">int</span> n, List (&amp;lt)[<span class="number">10</span>], <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>(&amp;lt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        key = <span class="built_in">getkey</span>(L[i], k);  <span class="comment">// 取得需要比对的位置上的值</span></span><br><span class="line">        <span class="built_in">push_back</span>(&amp;lt[key], L[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Collect</span><span class="params">(SqList &amp;L, List (&amp;lt)[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Node *p = lt[i].first-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L[k++] = p-&gt;data;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List list[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InitList</span>(&amp;list[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Distribute</span>(L, n, list, i);</span><br><span class="line">        <span class="built_in">Collect</span>(L, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2024/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、因特网概述"><a href="#1、因特网概述" class="headerlink" title="1、因特网概述"></a>1、因特网概述</h2><p><strong>internet与Internet的区别</strong></p>
<ul>
<li><p><strong>internet(互联网或互连网)<strong>是一个通用名词，它泛指</strong>多个计算机网络互连而成的网络</strong>。在这些网络之间的通信协议可以是任意的。</p>
</li>
<li><p><strong>Internet（因特网）则是一个专用名词</strong>，它指<strong>当前全球最大的、开放的、由众多网络互连而成的特定计算机网络</strong>，它采用TCP&#x2F;IP协议族作为通信的规则，其前身是美国的ARPANET。</p>
</li>
</ul>
<p>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是互联网(Internet)。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121642022.webp" alt="img"></p>
<blockquote>
<p>普通用户是如何接入到因特网的呢？</p>
<p>答：<strong>通过ISP接入因特网</strong></p>
<p>ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从<strong>ISP的得到所需要的IP地址</strong>。</p>
<p><strong>因为因特网上的主机都必须有IP地址才能进行通信，这样就可以通过该ISP接入到因特网</strong></p>
</blockquote>
<h2 id="2、计算机网络体系结构"><a href="#2、计算机网络体系结构" class="headerlink" title="2、计算机网络体系结构"></a>2、计算机网络体系结构</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121644183.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121645050.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121645246.webp" alt="img"></p>
<h1 id="二、网络层"><a href="#二、网络层" class="headerlink" title="二、网络层"></a>二、网络层</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646323.png" alt="image-20240412164600035"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646120.png" alt="image-20240412164607943"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646736.png" alt="image-20240412164616479"></p>
<h1 id="三、运输层"><a href="#三、运输层" class="headerlink" title="三、运输层"></a>三、运输层</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-d9a70806edc95dc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的。</strong></p>
<h2 id="2、运输层端口号、复用与分用的概念"><a href="#2、运输层端口号、复用与分用的概念" class="headerlink" title="2、运输层端口号、复用与分用的概念"></a>2、运输层端口号、复用与分用的概念</h2><h3 id="（1）为什么用端口号"><a href="#（1）为什么用端口号" class="headerlink" title="（1）为什么用端口号"></a>（1）为什么用端口号</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-de597eda77aa6acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（2）发送方的复用和接收方的分用"><a href="#（2）发送方的复用和接收方的分用" class="headerlink" title="（2）发送方的复用和接收方的分用"></a>（2）发送方的复用和接收方的分用</h3><ul>
<li><p><strong>多个进程</strong>利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据——<strong>复用</strong></p>
</li>
<li><p><strong>多个进程</strong>利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>数据—— <strong>分用</strong></p>
</li>
<li><p>这里一个端口表示一个进程</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2a4ec3f5d5c11433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（3）常用端口号"><a href="#（3）常用端口号" class="headerlink" title="（3）常用端口号"></a>（3）常用端口号</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2117fa99a7f2a89c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="3、TCP和UDP的对比"><a href="#3、TCP和UDP的对比" class="headerlink" title="3、TCP和UDP的对比"></a>3、TCP和UDP的对比</h2><h3 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h3><ul>
<li><p>TCP</p>
<ol>
<li>面向连接，需要在两个套接字之间建立连接，提供可靠服务；</li>
<li>传送TCP报文；</li>
<li>支持点对点单播，不支持多播、广播；</li>
<li>应用场景如万维网、电子邮件、文件传送等。</li>
</ol>
</li>
<li><p>UDP</p>
<ol>
<li><p>无连接，不需要套接字，不提供可靠交付；</p>
</li>
<li><p>传送UDP报文或用户数据报；</p>
</li>
<li><p>支持单播、多播和广播；</p>
</li>
<li><p>应用场景如多媒体应用等。</p>
<img src="https:////upload-images.jianshu.io/upload_images/24878825-624005a24bc5bfcd.png?imageMogr2/auto-orient/strip|imageView2/2/w/871/format/webp" alt="img" style="zoom: 50%;" /></li>
</ol>
</li>
</ul>
<h3 id="（2）TCP"><a href="#（2）TCP" class="headerlink" title="（2）TCP"></a>（2）TCP</h3><p>TCP（Transmission Control Protocol）</p>
<p>发送方</p>
<ul>
<li><p>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，但不知道这些待传送的字节流的含义</p>
</li>
<li><p>将他们编号，并存储在自己发送缓存中</p>
</li>
<li><p>根据发送策略，提取一定量的字节构建TCP报文并发送</p>
</li>
</ul>
<p>接收方</p>
<ul>
<li><p>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</p>
</li>
<li><p>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</p>
</li>
<li><p>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</p>
</li>
</ul>
<p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础。在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收。</p>
<img src="https:////upload-images.jianshu.io/upload_images/24878825-db48b70af7fb7884.png?imageMogr2/auto-orient/strip|imageView2/2/w/897/format/webp" alt="img" style="zoom:50%;" />

<h2 id="4、TCP的流量控制"><a href="#4、TCP的流量控制" class="headerlink" title="4、TCP的流量控制"></a>4、TCP的流量控制</h2><p>流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p>
<ul>
<li>当主机A收到主机B对相关字节数据的<strong>累计确认</strong>时，可以将其在发送缓存中删除。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f73e94f75e94ea4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5bd53b8a5a5ac400.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ea9dc3589e6c6bd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面。因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传。</p>
</blockquote>
<h2 id="5、TCP的拥塞控制"><a href="#5、TCP的拥塞控制" class="headerlink" title="5、TCP的拥塞控制"></a>5、TCP的拥塞控制</h2><p>在某段时间中，若对网络中某一资源（如链路容量&#x2F;带宽、缓存和处理机等）的需求超过了该资源所能提供的可用部分，就称发生了<strong>拥塞</strong>。</p>
<p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p>
<ol>
<li>点缓存的容量太小；</li>
<li>链路的容量不足；</li>
<li>处理机处理的速率太慢；</li>
<li>拥塞本身会进一步加剧拥塞；</li>
</ol>
<blockquote>
<p>相关算法</p>
<ul>
<li><strong>慢开始（slow-start）</strong></li>
<li><strong>拥塞避免（congestion avoidance）</strong></li>
<li><strong>快重传（fast transmit）</strong></li>
<li><strong>快恢复（fast recovery）</strong></li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c7682fe29ebcb6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>真正的发送窗口值 &#x3D; Min (接收方窗口值，拥塞窗口值)</p>
</blockquote>
<h3 id="（1）慢开始和拥塞避免"><a href="#（1）慢开始和拥塞避免" class="headerlink" title="（1）慢开始和拥塞避免"></a>（1）慢开始和拥塞避免</h3><h4 id="A-慢开始"><a href="#A-慢开始" class="headerlink" title="A. 慢开始"></a>A. 慢开始</h4><ul>
<li>目的：用来确定网络的负载能力或拥塞程度。</li>
<li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li>
<li>两个变量：<ul>
<li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。<ul>
<li>1 至 2 个最大报文段 （旧标准）</li>
<li>2 至 4 个最大报文段 （RFC 5681）</li>
</ul>
</li>
<li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-47dba7f2068f35df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1bca665e8eaa965a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/713/format/webp" alt="img"></p>
<blockquote>
<p>图中swnd是发送窗口</p>
<p>每经过一个传输轮次，拥塞窗口就加倍</p>
<p>窗口大小按<strong>指数增加</strong>，2的n-1次方</p>
</blockquote>
<h4 id="B-拥塞避免"><a href="#B-拥塞避免" class="headerlink" title="B. 拥塞避免"></a>B. 拥塞避免</h4><ul>
<li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。</li>
<li>每经过一个传输轮次，拥塞窗口 <strong>cwnd &#x3D; cwnd + 1</strong>。</li>
<li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li>
<li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。<img src="https://upload-images.jianshu.io/upload_images/24878825-f5db7ea25d8aca73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></li>
</ul>
<h3 id="（2）快重传和快恢复"><a href="#（2）快重传和快恢复" class="headerlink" title="（2）快重传和快恢复"></a>（2）快重传和快恢复</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-fee86fb3707a175c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="A-快重传"><a href="#A-快重传" class="headerlink" title="A. 快重传"></a>A. 快重传</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a57c7cc819aa4bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="B-快恢复"><a href="#B-快恢复" class="headerlink" title="B. 快恢复"></a>B. 快恢复</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-ab5a63efbd586eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="C-改进后的整体示意图"><a href="#C-改进后的整体示意图" class="headerlink" title="C. 改进后的整体示意图"></a>C. 改进后的整体示意图</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-8f61b8eddb5b2624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="6、TCP超时重传"><a href="#6、TCP超时重传" class="headerlink" title="6、TCP超时重传"></a>6、TCP超时重传</h2><blockquote>
<p>往返时间：<strong>RTT0</strong></p>
<p>超时重传时间：<strong>RTO</strong></p>
</blockquote>
<p>如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大；如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率。因此需要合理选择RTO的值。</p>
<ul>
<li>不能直接使用某次测量得到的RTT样本来计算超时重传时间RTO。应该利用每次测量得到的RTT样本，计算加权平均往返时间<strong>RTTs</strong>（又称为平滑的往返时间）</li>
</ul>
<p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107689.webp" alt="img"></p>
<p><strong>往返时间RTT的测量比较复杂</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107552.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107260.webp" alt="img"></p>
<p><strong>TCP超时重传的计算</strong></p>
<p>举例</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107514.webp" alt="img"></p>
<h2 id="7、TCP可靠传输的实现"><a href="#7、TCP可靠传输的实现" class="headerlink" title="7、TCP可靠传输的实现"></a>7、TCP可靠传输的实现</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-6d10ea76a1ea032b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-92d975bc880db892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-35bff0a8cc5b0d71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="8、三次握手"><a href="#8、三次握手" class="headerlink" title="8、三次握手"></a>8、三次握手</h2><h3 id="（1）三次握手详解"><a href="#（1）三次握手详解" class="headerlink" title="（1）三次握手详解"></a>（1）三次握手详解</h3><ul>
<li>采用<strong>三次握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li>
</ul>
<ul>
<li><p>TCP的连接建立要解决以下三个问题</p>
<ul>
<li>使得双方能够确知对方的存在；</li>
<li>使得双方能够协商一些参数（如最大窗口值、是否使用时间戳选项和服务质量等）；</li>
<li>使得双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li>
</ul>
</li>
<li><p><strong>具体过程</strong></p>
<ol>
<li><p><strong>TCP服务器进程创建传输控制块，用来存储TCP连接中的一些重要信息，并进入监听状态，等待TCP客户端进程的连接请求</strong></p>
</li>
<li><p><strong>TCP客户进程也是首先创建传输控制块</strong></p>
</li>
<li><p><strong>TCP客户进程向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态。</strong></p>
<ol>
<li>其中， TCP连接请求报文段首部中的同步位syn被设置为1，表明这是一个TCP连接请求报文段；</li>
<li>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号；</li>
<li>注意<em>该报文段不能携带数据</em>，但要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态。</strong></p>
<ol>
<li>同步位SYN和确认位ACK都设置为1，表明这是一个TCP连接请求确认报文段；</li>
<li>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号；</li>
<li>确认位ACK的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认；</li>
<li>注意<em>该报文段也不能携带数据</em>，且同样要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态。</strong></p>
<ol>
<li>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1；</li>
<li>确认位ACK被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认；</li>
<li>注意<em>普通的TCP确认报文段可以携带数据</em>，但如果不携带数据，则不消耗序号。</li>
</ol>
</li>
<li><p><strong>TCP服务器进程收到该确认报文段后也进入连接已建立状态。</strong></p>
</li>
</ol>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-987d5c8512392422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（2）为什么不能“两次握手”？"><a href="#（2）为什么不能“两次握手”？" class="headerlink" title="（2）为什么不能“两次握手”？"></a>（2）为什么不能“两次握手”？</h3><blockquote>
<p>不采用两次握手主要是为了<strong>防止已经失效的连接请求报文段突然又传到服务端</strong>，因而产生错误。</p>
<p>这种情况是：<strong>客户端发出的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到下一个连接释放以后的某个时间才到达服务器端。</strong>当服务器端收到此失效报文后，会误认为是客户端发出的一个新连接请求，于是客户端又发出确认报文，表示同意建立连接。</p>
<p>如果不采用“三次握手”，那么只要服务器端发出确认报文就会认为新的连接已经建立了，但此时客户端并没有发出建立连接的请求，因此不会向服务器端发送数据。服务器端没有收到数据就会一直等待，这样就会白白浪费掉很多资源。</p>
<p>所以必须采用“三次握手”而非“两次握手”。</p>
</blockquote>
<p>下图是“两次握手”的示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0a5773a600817c41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="9、四次挥手"><a href="#9、四次挥手" class="headerlink" title="9、四次挥手"></a>9、四次挥手</h2><h3 id="（1）四次挥手详解"><a href="#（1）四次挥手详解" class="headerlink" title="（1）四次挥手详解"></a>（1）四次挥手详解</h3><ul>
<li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong>端，被动等待连接建立的应用进程叫做<strong>TCP服务器</strong>。<strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong>。</li>
</ul>
<ul>
<li><p>具体过程</p>
<ol>
<li><p><strong>当客户端和服务器端都处于连接已建立状态时，若要释放连接，客户进程会发送TCP连接释放报文段，并进入终止等待状态。</strong></p>
<ol>
<li>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；</li>
<li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1；</li>
<li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1；</li>
<li>注意FIN等于1的报文段即使不携带数据，也要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态。</strong></p>
<ol>
<li>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配；</li>
<li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认。</li>
</ol>
</li>
<li><p><strong>此时，从客户进程到服务器进程这个方向的连接就释放了，这时的TCP连接属于半关闭状态，也就是客户进程已经没有数据要发送了。但如果服务器进程还有数据要发送，客户进程仍要接收，也就是说从服务器进程到客户进程这个方向的连接并未关闭。</strong></p>
</li>
<li><p><strong>客户进程收到TCP确认报文段后就进入终止等待状态，等待服务器进程发出的TCP连接释放报文段。若服务器进程已经没有数据要发送了，服务器进程即释放连接。由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接。</strong></p>
</li>
<li><p><strong>服务器进程发送TCP连接释放报文段并进入最后确认状态。</strong></p>
<ol>
<li><p>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；</p>
</li>
<li><p>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送；</p>
</li>
<li><p>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认。</p>
</li>
</ol>
</li>
<li><p><strong>客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态。服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要经过2MSL后才能进入关闭状态。</strong></p>
<ol>
<li>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号；</li>
<li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认。</li>
</ol>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1c5e0c6357d039ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
</li>
</ul>
<h3 id="（2）为什么不能“三次挥手”？"><a href="#（2）为什么不能“三次挥手”？" class="headerlink" title="（2）为什么不能“三次挥手”？"></a>（2）为什么不能“三次挥手”？</h3><p>TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p>
<blockquote>
<p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。</p>
<p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ef85470fe120f146.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="10、TCP保活计时器"><a href="#10、TCP保活计时器" class="headerlink" title="10、TCP保活计时器"></a>10、TCP保活计时器</h2><p>TCP双方已经建立连接时，TCP客户进程所在的主机突然出现了故障。此时服务器进程无法再收到客户进程发来的数据。因此，应当有措施使TCP服务器进程不要再白白等待下去。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2dc97e06fe1d82ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h1 id="四、应用层"><a href="#四、应用层" class="headerlink" title="四、应用层"></a>四、应用层</h1><h2 id="1、CS方式和P2P方式"><a href="#1、CS方式和P2P方式" class="headerlink" title="1、CS方式和P2P方式"></a>1、CS方式和P2P方式</h2><h3 id="（1）CS方式（客户-服务器方式）"><a href="#（1）CS方式（客户-服务器方式）" class="headerlink" title="（1）CS方式（客户&#x2F;服务器方式）"></a>（1）CS方式（客户&#x2F;服务器方式）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121850174.webp" alt="img"></p>
<h3 id="（2）P2P方式（对等方式）"><a href="#（2）P2P方式（对等方式）" class="headerlink" title="（2）P2P方式（对等方式）"></a>（2）P2P方式（对等方式）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121850280.webp" alt="img"></p>
<h2 id="2、动态主机配置协议DHCP"><a href="#2、动态主机配置协议DHCP" class="headerlink" title="2、动态主机配置协议DHCP"></a>2、动态主机配置协议DHCP</h2><ul>
<li><p>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</p>
</li>
<li><p>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</p>
</li>
<li><p>DHCP的工作过程</p>
<ul>
<li><p><strong>DHCP 使用客户 - 服务器方式</strong></p>
<ul>
<li><p>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文  （DHCP DISCOVER），这时该主机就成为 DHCP 客户。</p>
</li>
<li><p>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</p>
</li>
<li><p>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</p>
</li>
</ul>
</li>
<li><p><strong>DHCP 工作方式</strong></p>
<ul>
<li><p>DHCP 使用客户-服务器方式，采用请求&#x2F;应答方式工作。</p>
</li>
<li><p>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121853443.webp" alt="img"></p>
<ul>
<li><p>DHCP中继代理</p>
<h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p>下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-33c64efac75f0ad2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p>
</blockquote>
</li>
<li><p>总结</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121854516.webp" alt="img"></p>
</li>
</ul>
<h2 id="3、域名系统DNS"><a href="#3、域名系统DNS" class="headerlink" title="3、域名系统DNS"></a>3、域名系统DNS</h2><h3 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855489.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855338.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855952.webp" alt="img"></p>
<h3 id="（2）域名解析过程"><a href="#（2）域名解析过程" class="headerlink" title="（2）域名解析过程"></a>（2）域名解析过程</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856499.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856729.webp" alt="img"></p>
<h2 id="4、文件传送协议FTP"><a href="#4、文件传送协议FTP" class="headerlink" title="4、文件传送协议FTP"></a>4、文件传送协议FTP</h2><blockquote>
<p>注意两种模式都是（1）控制连接在整个会话期间保持打开状态；（2）数据连接传输完毕后就关闭。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856907.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121857685.webp" alt="img"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>手撕算法</title>
    <url>/2024/04/13/%E9%9D%A2%E8%AF%95/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>合并K个有序数组</p>
<p>TOPK问题</p>
<p>逆波兰表达式</p>
<p>动态规划</p>
<p>快排最坏情况的比较次数，归并排序呢？</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>数据库1_MySQL数据库.md</title>
    <url>/2024/04/06/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%931_MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="1、MySQL简介"><a href="#1、MySQL简介" class="headerlink" title="1、MySQL简介"></a>1、MySQL简介</h1><p>MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
<p><strong>其数据通常存储在磁盘中，但也会使用缓存将一部分数据存储在内存中，以提高访问速度。</strong></p>
<span id="more"></span>

<h2 id="（1）架构逻辑"><a href="#（1）架构逻辑" class="headerlink" title="（1）架构逻辑"></a>（1）架构逻辑</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404061034387.png" alt="MySQL逻辑架构"></p>
<p>MySQL的逻辑架构大致可以分为三层：客户端、Server层和存储引擎层。</p>
<ul>
<li><p>客户端（服务器层）：主要做连接处理、授权认证和安全保障等。</p>
</li>
<li><p>Server层：涵盖了 MySQL 大多数核心服务功能，包括查询解析、分析、优化、缓存以及所有内置函数（例如：日期，时间，数学和加密函数等）。存储过程，触发器，视图等跨存储引擎的功能也都在这一层实现。</p>
</li>
<li><p>Server 层基本组件：</p>
<ul>
<li><p><strong>连接器</strong>：我们使用数据库，第一步是连接到数据库。而连接器负责跟客户端建立连接、获取权限、维持和管理连接；</p>
</li>
<li><p><strong>查询缓存</strong>：执行查询语句的时候，会先查询缓存，校验 SQL 是否执行过，如果有 SQL 的缓存，直接返回给客户端，如果没有命中，执行后续的操作；（MySQL 8.0 版本删除）</p>
</li>
<li><p><strong>分析器</strong>：没有命中缓存的话，SQL 语句就会经过分析器，主要分为两步，词法分析和语法分析，先看 SQL 语句要做什么，再检查 SQL 语句语法是否正确；</p>
</li>
<li><p><strong>优化器</strong>：优化器对查询进行优化，包括重写查询、决定表的读写顺序以及选择合适的索引等，生成执行计划，优化器主要做的操作包括：</p>
<ul>
<li>表里面有多个索引的时候，决定使用哪个索引；</li>
<li>一个语句有多表关联（join）的时候，决定各个表的连接顺序；</li>
</ul>
</li>
<li><p><strong>执行器</strong>：首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会根据执行计划去调用引擎的接口，返回结果。</p>
</li>
</ul>
</li>
<li><p><strong>存储引擎层</strong>：主要负责数据的存储和提取，Server层通过 API 与存储引擎层进行交互。服务器通过 API 与存储引擎通信，这些接口屏蔽了不同存储引擎的差异，使得差异对上层查询过程透明。除了会解析外键定义的 InnoDB 外，存储引擎不会解析 SQL，不同存储引擎之间也不会相互通信，只是简单响应上层服务器请求。</p>
</li>
</ul>
<h1 id="2、面试提问"><a href="#2、面试提问" class="headerlink" title="2、面试提问"></a>2、面试提问</h1><h2 id="（1）为什么MySQL使用B-树索引？"><a href="#（1）为什么MySQL使用B-树索引？" class="headerlink" title="（1）为什么MySQL使用B+树索引？"></a>（1）为什么MySQL使用B+树索引？</h2><p>B树是一种自平衡的多路搜索树，每个节点可以包含多个关键字和对应的指针，即B树的每个节点都会存储数据，B树的叶子节点之间是无指针相连接的。因此当读取叶子节点的数据时，只能通过父节点进行多次磁盘I&#x2F;O才能实现。</p>
<p>B+树也是一种自平衡的多路搜索树，所有关键字都存储在叶子节点上，非叶子节点只存储索引列和指向子节点的指针。叶子节点通过指针连接起来，形成一个有序的链表，可以支持顺序访问和范围查询。这样就带来了以下好处：</p>
<ul>
<li>范围查询效率高；</li>
<li>顺序访问性能好；</li>
<li>更少的磁盘I&#x2F;O；</li>
<li>内存友好。</li>
</ul>
<h2 id="（2）MySQL的慢查询如何优化"><a href="#（2）MySQL的慢查询如何优化" class="headerlink" title="（2）MySQL的慢查询如何优化"></a>（2）MySQL的慢查询如何优化</h2><p>针对SQL慢查询，可以考虑以下一些优化措施：</p>
<ol>
<li><strong>优化查询语句结构：</strong>检查是否存在冗余的操作、重复的子查询、不必要的排序、大量的JOIN操作等。优化查询语句的结构和逻辑，减少不必要的数据读取和计算。</li>
<li><strong>添加合适的索引：</strong>确保查询中涉及的列都有适当的索引，并且查询条件能够充分利用索引。通过使用适当的索引，提高查询的性能。但是要避免过多的索引，因为过多的索引会增加写入操作的开销。</li>
<li><strong>数据库表优化：</strong>对于频繁查询的表，考虑进行分库或分表操作，将数据分散存储，提高查询效率。</li>
<li><strong>优化数据库配置：</strong>根据服务器的硬件资源和应用需求，调整MySQL的配置参数，如缓冲区大小、并发连接树、查询缓存等。</li>
<li><strong>使用缓存技术：</strong>对于一些相对稳定的查询结果，考虑使用缓存技术，如Redis、Memcached等，减少对数据库的访问。</li>
</ol>
<h2 id="（3）索引的设计原则"><a href="#（3）索引的设计原则" class="headerlink" title="（3）索引的设计原则"></a>（3）索引的设计原则</h2><ol>
<li>选择适当的列进行索引：选择那些经常被用于查询条件、连接操作和排序的列进行索引；</li>
<li><strong>考虑查询类型：</strong>根据常见的查询模式和性能需求，选择合适的索引类型。如范围查询选择B树索引；全文搜索选择全文索引；</li>
<li><strong>避免过多的索引：</strong>过多的索引会增加写操作的开销，占用存储空间；</li>
<li><strong>注意索引的维护成本：</strong></li>
<li><strong>联合索引的使用：</strong>联合索引可以包含多个列，通过多个列的组合来创建索引。在创建联合索引时，需要根据查询的频率和顺序选择合适的列顺序，将最常用的列放在前面可以提高索引的效果。</li>
</ol>
<h2 id="（4）什么是索引？索引有哪些优缺点？"><a href="#（4）什么是索引？索引有哪些优缺点？" class="headerlink" title="（4）什么是索引？索引有哪些优缺点？"></a>（4）什么是索引？索引有哪些优缺点？</h2><p>索引是数据库中用于提高数据检索性能的排好序的数据结构。它类似于书籍的目录，通过建立特定的数据结构将列或多个列的值与它们在数据表中对应的行关联起来，以加快查询速度。</p>
<p>索引的优点包括：</p>
<ol>
<li>提高查询性能：索引可以加快数据库查找数据的速度，通过快速定位到符合查询条件的数据行，减少了数据库进行全表扫描的开销，从而显著提高查询效率。</li>
<li>唯一性约束：通过在索引上设置唯一性约束，可以确保数据的唯一性，防止重复数据的插入。</li>
</ol>
<p>然而，索引也有一些缺点：</p>
<ol>
<li>占用存储空间：索引通常需要占用一定的磁盘空间。过多的索引可能会增加存储成本。</li>
<li>索引维护的开销：当对数据表进行插入、更新或删除操作时，索引也需要进行相应的维护操作，这可能导致数据写入的性能下降，更新缓慢。</li>
</ol>
<h2 id="（5）索引分类"><a href="#（5）索引分类" class="headerlink" title="（5）索引分类"></a>（5）索引分类</h2><p>在MySQL中，索引按照索引列的类型可以分为以下几种：</p>
<ul>
<li><strong>主键索引：</strong>用于唯一标识每一条记录，主键索引的值不允许重复且不能为空，并且一个表只能有一个主键索引。</li>
<li><strong>唯一索引：</strong>用于保证索引列的值唯一，允许为空值，但是一个表可以有多个唯一索引。</li>
<li><strong>普通索引：</strong>没有唯一性限制，允许重复值和空值，是最基本的索引类型。</li>
<li><strong>组合索引：</strong>在多个字段上创建的索引，可以包含多个列。组合索引可以提高多列查询的性能，但查询条件必须符合最左前缀原则，即查询从左到右使用组合索引中的列。</li>
</ul>
<h2 id="（6）什么是最左前缀原则？"><a href="#（6）什么是最左前缀原则？" class="headerlink" title="（6）什么是最左前缀原则？"></a>（6）什么是最左前缀原则？</h2><p><strong>最左前缀原则（Leftmost Prefix Rule）</strong>是索引在数据库查询中的一种使用规则。它指的是在使用复合索引时，索引的最左边的连续几个列会被用于查询过滤条件的匹配。</p>
<p>具体来说，如果在表中创建了一个复合索引，包含多个列 A、B、C，那么最左前缀原则要求查询中的过滤条件必须从索引的最左边开始，并且不能跳过中间的列。只有当查询中的过滤条件与索引的最左前缀完全匹配时，索引才能被充分利用。</p>
<p>例如，考虑以下复合索引 (A, B, C) 和查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> A <span class="operator">=</span> <span class="string">&#x27;value1&#x27;</span> <span class="keyword">AND</span> C <span class="operator">=</span> <span class="string">&#x27;value2&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，最左前缀原则要求查询条件中必须包含列 A，而不能直接使用列 C 进行过滤。因为只有满足最左前缀条件，索引 (A, B, C) 才能被有效地使用。</p>
<p>遵循最左前缀原则的好处包括：</p>
<ol>
<li><p>提高查询性能：通过使用索引的最左前缀，可以最大限度地减少索引扫描的数据量，提高查询的效率和响应时间。</p>
</li>
<li><p>减少索引占用空间：在某些情况下，使用最左前缀原则可以减少创建多个索引的需求，节省磁盘空间和索引维护的开销。</p>
</li>
</ol>
<h2 id="（7）什么是索引覆盖？"><a href="#（7）什么是索引覆盖？" class="headerlink" title="（7）什么是索引覆盖？"></a>（7）什么是索引覆盖？</h2><p>覆盖索引是指一个索引包含了查询所需的所有列，而无需访问表的实际数据页。</p>
<p>当数据库系统执行查询时，通常需要从磁盘中读取数据页到内存中才能进行处理。而如果使用了覆盖索引，由于索引已经包含了查询所需的所有列的值，数据库系统可以直接通过索引来获取这些值，而不需要额外地读取数据页。这样可以减少磁盘 I&#x2F;O 的次数和数据在内存中的占用，提高查询的效率。</p>
<p>覆盖索引通常适用于以下场景：</p>
<ol>
<li><p>查询语句只需要返回索引列中的数据，而不需要访问其他列的值。</p>
</li>
<li><p>查询语句中的条件过滤、排序或分组的列都在同一个索引上。</p>
</li>
</ol>
<h2 id="（8）聚簇索引和非聚簇索引的区别是什么？"><a href="#（8）聚簇索引和非聚簇索引的区别是什么？" class="headerlink" title="（8）聚簇索引和非聚簇索引的区别是什么？"></a>（8）聚簇索引和非聚簇索引的区别是什么？</h2><p><strong>聚簇索引</strong>也被成为主键索引，它是一种特殊类型的索引，用于存储表中的数据记录。</p>
<p><strong>非聚簇索引</strong>用于存储对表中数据记录的引用地址。</p>
<p>区别：</p>
<ol>
<li>存储方式不同：聚簇索引存储数据记录，非聚簇索引存储对数据记录的引用地址；</li>
<li>查询速度不同：聚簇索引的查询速度快于非聚簇索引；</li>
<li>内存占用不同：聚簇索引占用更多的内存；</li>
<li>索引更新速度不同：由于聚簇索引存储的是数据记录，因此当数据记录发生变化时，需要重构整个索引，更新速度相对较慢；而非聚簇索引只需要修改对数据记录的引用地址，因此更苏速度较快。</li>
</ol>
<h2 id="（9）索引失效的场景有哪些？"><a href="#（9）索引失效的场景有哪些？" class="headerlink" title="（9）索引失效的场景有哪些？"></a>（9）索引失效的场景有哪些？</h2><ol>
<li>当查询中涉及的列<strong>没有被索引</strong>时，索引将不会被使用。</li>
</ol>
<ul>
<li><ul>
<li>例如，<code>SELECT * FROM users WHERE age = 25</code>，如果<code>age</code>列没有被索引，索引就不会被使用。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>在索引列上<strong>使用函数或表达式</strong>会导致索引失效。</li>
</ol>
<ul>
<li><ul>
<li>例如，<code>SELECT * FROM users WHERE YEAR(birth_date) = 1990</code>，即使<code>birth_date</code>被索引，使用<code>YEAR()</code>函数也会使索引失效。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>当使用<code>LIKE</code>操作符，并且<strong>模式以通配符开始</strong>时，索引将不被使用。</li>
</ol>
<ul>
<li><ul>
<li>例如，<code>SELECT * FROM users WHERE name LIKE &#39;%Smith&#39;</code>；但<code>LIKE &#39;Smith%&#39;</code>可以使用索引。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>如果查询中有<strong>隐式类型转换</strong>，可能导致索引失效。</li>
</ol>
<ul>
<li><ul>
<li>例如，<code>SELECT * FROM users WHERE string_column = 123</code>，即使<code>string_column</code>被索引，但由于隐式将数字转换为字符串，索引可能失效。</li>
</ul>
</li>
</ul>
<ol start="5">
<li>当查询使用<code>OR</code>条件，并且<strong>条件中的某些字段没有被索引</strong>时，整个索引可能不会被使用。</li>
</ol>
<ul>
<li><ul>
<li>例如，<code>SELECT * FROM users WHERE last_name = &#39;Smith&#39; OR age = 30</code>，如果<code>last_name</code>被索引而<code>age</code>没有，整个索引可能不会被使用。</li>
</ul>
</li>
</ul>
<ol start="6">
<li>如果索引列的值分布非常不均匀，或者索引列大多数值都是相同的，优化器可能认为使用全表扫描更有效。</li>
</ol>
<ul>
<li><ul>
<li>例如，在一个大多数用户都来自同一城市的用户表中，对城市进行索引可能不会提高查询效率。</li>
</ul>
</li>
</ul>
<h2 id="（10）事务的基本特性和隔离级别？"><a href="#（10）事务的基本特性和隔离级别？" class="headerlink" title="（10）事务的基本特性和隔离级别？"></a>（10）事务的基本特性和隔离级别？</h2><p>事务具备4大特性，<strong>即原子性、一致性、隔离性和持久性</strong>。</p>
<ol>
<li><p><strong>原子性：</strong>事务中的所有操作要么全部执行成功，要么全部回滚到事务开始前的状态。如果在事务执行期间发生错误，系统将回滚所有已执行的操作，以保持数据的一致性。</p>
</li>
<li><p><strong>一致性：</strong>事务的执行不会破坏数据库的完整性约束。在事务开始和结束时，数据库必须处于一致的状态。 如小李转账100元给小白，不管操作是否成功，小李和小白的账户总额是不变的。 </p>
</li>
<li><p><strong>隔离性：</strong>事务的执行是相互隔离的，即每个事务对其他事务是透明的。并发执行的多个事务不会相互干扰，每个事务感知不到其他事务的存在。</p>
</li>
<li><p><strong>持久性：</strong>一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。</p>
</li>
</ol>
<p>MySQL支持以下四个事务隔离级别：</p>
<ol>
<li><strong>读未提交</strong>：最低的隔离级别。事务可以读取到其他事务尚未提交的数据，可能会出现脏读、不可重复读和幻读问题。</li>
<li><strong>读已提交</strong>：事务只能读取到已经提交的数据。但在同一事务中，多次读取同一行的数据结果可能会不一致，可能会出现不可重复读和幻读问题。</li>
<li><strong>可重复读</strong>：在同一个事务内，多次读取同一行的数据结果始终保持一致。MySQL的<strong>默认隔离级别就是可重复读</strong>。通过使用MVCC机制来实现，在读操作期间不会看到其他事务的修改，有效地解决了不可重复读问题。</li>
<li><strong>串行化</strong>：最高的隔离级别。事务串行执行，避免了脏读、不可重复读和幻读等问题。但是并发性能较差，可能导致大量的锁竞争和资源争用。</li>
</ol>
<h2 id="（11）什么是脏读、幻读和不可重复读？"><a href="#（11）什么是脏读、幻读和不可重复读？" class="headerlink" title="（11）什么是脏读、幻读和不可重复读？"></a>（11）什么是脏读、幻读和不可重复读？</h2><ol>
<li>脏读（Dirty Reads）：事务A读取到了事务B已经修改但尚未提交的数据。</li>
<li>幻读（Phantom Reads）：事务A读取到了事务B提交的新增数据。</li>
<li>不可重读（Non-Repeatable Reads）：事务A内部的相同查询语句在不同时刻读出的结果不一致。</li>
</ol>
<h2 id="（12）MySQL中in和exist的区别"><a href="#（12）MySQL中in和exist的区别" class="headerlink" title="（12）MySQL中in和exist的区别"></a>（12）MySQL中in和exist的区别</h2><p> MySQL 中的 IN 和 EXISTS都是用于查询和筛选数据的条件语句，区别在于：</p>
<ol>
<li><strong>IN关键字：</strong>使用 IN 条件时，我们提供一个固定的值列表，然后将其与指定列的值进行比较。如果列中的值与列表中的任何一个值匹配，就会返回结果。IN 条件适合用于确定某个字段的值是否在给定的值列表中。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (value1, value2, value3); </span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 如果 column_name 的值与 value1、value2 或 value3 中的任何一个相匹配</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 那么这条记录将会被返回</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>EXISTS关键字：</strong>使用 EXISTS 条件时，我们需要指定一个子查询。查询的结果并不重要，而是判断子查询是否返回了至少一行结果。如果子查询返回了结果，EXISTS 条件就会被认为是满足的。EXISTS 条件适合用于判断某个条件是否至少存在于子查询的结果中。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE EXISTS (SELECT * FROM another_table WHERE condition); </span><br><span class="line"></span><br><span class="line">// 如果子查询(SELECT * FROM another_table WHERE condition)返回了至少一行结果</span><br><span class="line">//那么主查询中的记录将会被返回。</span><br></pre></td></tr></table></figure>

<p><strong>总结来说：</strong></p>
<ul>
<li>使用 IN 条件时，比较的是指定列的值是否在给定的值列表中。</li>
<li>使用 EXISTS 条件时，判断的是子查询是否返回了至少一行结果。</li>
</ul>
<h2 id="（13）DATETIME和TIMESTAMP的异同"><a href="#（13）DATETIME和TIMESTAMP的异同" class="headerlink" title="（13）DATETIME和TIMESTAMP的异同"></a>（13）DATETIME和TIMESTAMP的异同</h2><p>DATETIME 和 TIMESTAMP 是 MySQL 中用于存储日期和时间的数据类型，它们之间有一些异同点：</p>
<ol>
<li><strong>存储范围</strong>：<ul>
<li>DATETIME 类型可以存储的范围是 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’。</li>
<li>TIMESTAMP 类型可以存储的范围是 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC（32 位系统的最大时间戳限制）。</li>
</ul>
</li>
<li><strong>存储空间</strong>：<ul>
<li>DATETIME 类型在存储时需要占用 8 个字节。</li>
<li>TIMESTAMP 类型在存储时通常只需要占用 4 个字节，因为它存储的是从 UNIX 纪元开始以来的秒数，但是在一些情况下可能会占用 5 个字节，取决于时区的支持和配置。</li>
</ul>
</li>
<li><strong>时区处理</strong>：<ul>
<li>DATETIME 类型不涉及时区转换，存储的时间是按照指定的时区直接存储的。</li>
<li>TIMESTAMP 类型存储的时间是自动转换为 UTC 时间并存储的，但在检索时会再次转换为当前会话时区的时间。</li>
</ul>
</li>
<li><strong>自动更新功能</strong>：<ul>
<li>TIMESTAMP 类型可以设置为自动更新当前时间戳，即在插入或更新记录时会自动更新为当前时间。</li>
<li>DATETIME 类型不具备自动更新功能，需要手动在插入或更新时指定时间。</li>
</ul>
</li>
<li><strong>索引性能</strong>：<ul>
<li>在创建索引时，TIMESTAMP 类型的字段因为只占用了 4 个字节，通常会比 DATETIME 类型的字段占用的索引空间更小，因此在一些情况下查询性能可能会更好。</li>
</ul>
</li>
</ol>
<h2 id="（14）数据库的三大范式是什么？"><a href="#（14）数据库的三大范式是什么？" class="headerlink" title="（14）数据库的三大范式是什么？"></a>（14）数据库的三大范式是什么？</h2><ol>
<li><p><strong>第一范式（1NF）</strong>：确保数据库中的每个列都是原子性的，即每个列都不可再分。</p>
</li>
<li><p><strong>第二范式（2NF）</strong>：在满足第一范式的基础上，确保数据库中的每个非主键列完全依赖于主键。</p>
</li>
<li><p><strong>第三范式（3NF）</strong>：在满足第二范式的基础上，确保数据库中的每个非主键列之间不存在传递依赖。</p>
</li>
</ol>
<h2 id="（15）数据库表的连接方式"><a href="#（15）数据库表的连接方式" class="headerlink" title="（15）数据库表的连接方式"></a>（15）数据库表的连接方式</h2><ol>
<li>内连接（INNER JOIN）：返回两个表中匹配的行，只有当左表和右表中都存在匹配的行时才会返回结果。</li>
<li>左连接（LEFT JOIN）：左连接返回左表中的所有行，以及与右边匹配的行。若右表中无匹配行，则返回NULL值。</li>
<li>右连接（RIGHT JOIN）：右连接返回右表中的所有行，以及与左表匹配的行。若左表中无匹配行，则返回NULL值。</li>
<li>全连接（FULL OUTER JOIN）：全连接返回左表和右边中的所有行，如果某个表中没有匹配的行，则返回NULL值。</li>
<li>自连接（SELF JOIN）：自连接是指在同一个表中进行连接操作，可以用于查找表中某些数据的关联信息。</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>毕设项目提问</title>
    <url>/2024/04/08/%E9%9D%A2%E8%AF%95/%E6%AF%95%E8%AE%BE%E9%A1%B9%E7%9B%AE%E6%8F%90%E9%97%AE/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="一、项目介绍"><a href="#一、项目介绍" class="headerlink" title="一、项目介绍"></a>一、项目介绍</h2><p>名称：<strong>多用户智能家居控制系统设计</strong>。</p>
<p>1、 基于Linux多线程编程，结合MQTT协议的订阅-发布模式，完成多用户智能控制；</p>
<p>2、 在用户端设计双模式。共享模式：多个用户同时控制，且共享当前设备的状态；私人模式：被控制端的某一功能同一时间只能由一个用户控制；</p>
<p>3、 采用MQTT协议进行数据传送。通过实验对比HTTP协议和MQTT协议在智能家居领域的应用，结果表明MQTT在降低功耗和推送功能开发上优势明显，其即便是在资源有限的环境中也能易于使用。</p>
<p><strong>本项目的重点与核心在实现客户端的多用户控制。</strong></p>
<p>1、 针对发布者，利用Qt开发平台设计手机App作为客户端，它有两个特点，分别是多用户和双模式。多用户指不同的客户端均可进行控制操作；双模式指针对客户端本身，有共享模式和私人模式两种，在共享模式下可实现多个用户同时控制，且共享当前设备的状态；在私人模式下被控制端的某一功能同一时间只能由一个用户控制；</p>
<p>2、 针对消息代理者，选择在阿里云上部署mosquitto。选用MQTT协议的原因已在前述加以说明，而由于mosquitto是一种流行的mqtt服务器，且易于安装和配置，因此选用mosquitto进行部署；</p>
<p>3、 针对订阅者，主要以iTop4412开发板作为功能实现端。同时基于Linux多线程来配合实现多用户控制。</p>
<p><strong>本项目的数据转发过程如下。</strong></p>
<p>每个用户在该客户端程序中都对应操作两个线程：</p>
<p>（1）发送控制指令时的发布者身份，代表用户从Android客户端向嵌入式控制终端发送照明及警报的控制指令；<br>用户可自主规定订阅主题为“home&#x2F;*”格式。</p>
<p>（2）接收控制指令时的订阅者身份，代表开发板向用户发送温度数据；统一规定“temp”为传送温度数据的主题。</p>
<p><strong>发布者发出的控制指令将以json数据的格式被封装，经mosquitto云服务器转发后送至开发板侧，订阅者读取json包，解析出对应的命令行指令，对相应的硬件进行控制。</strong></p>
<h2 id="二、相关问题"><a href="#二、相关问题" class="headerlink" title="二、相关问题"></a>二、相关问题</h2><ol>
<li><strong>为什么选择Linux作为多用户智能家居控制系统的操作系统？</strong><ul>
<li>Linux是一个开源的操作系统，具有良好的稳定性和安全性，适合于嵌入式系统和服务器端应用，并且支持多线程编程，能够满足项目的需求。</li>
</ul>
</li>
<li><strong>在Linux中，如何使用多线程编程实现并发处理？项目中是如何实现的？</strong><ul>
<li><strong>pthread库：</strong> pthread库是POSIX标准定义的线程库，在Linux系统中得到广泛支持。通过pthread库，可以创建、管理和同步线程，实现并发处理。具体包括以下几个步骤：<ul>
<li>包含头文件 <code>pthread.h</code>。</li>
<li>使用 <code>pthread_create</code> 函数创建线程。</li>
<li>在线程函数中实现具体的处理逻辑。</li>
<li>使用 <code>pthread_join</code> 函数等待线程结束并回收资源。</li>
<li>使用互斥锁（pthread_mutex）进行线程同步和通信。</li>
</ul>
</li>
<li>在项目中，主要通过编写多线程的C程序来实现。其主要功能是创建两个线程，一个用于订阅MQTT消息，即sub_thread，另一个用于发布MQTT消息，即pub_thread。同时在主线程等待这两个线程的结束。<ul>
<li><code>sub_thread</code>函数首先通过<code>pthread_mutex_lock</code>获取互斥锁，接着创建一个mosquitto客户端并连接到指定的MQTT服务器，配置连接回调函数和消息接收回调函数，最后调用<code>mosquitto_loop_forever</code>函数来循环接收消息。当业务结束时，释放互斥锁并退出线程。<ul>
<li>回调函数是在特定事件发生时自动调用的函数，用于处理相应的事件或数据。在sub_thread中调用了mosquitto库提供的mosquitto_connect_callback_set和 mosquitto_message_callback_set。</li>
</ul>
</li>
<li><code>pub_thread</code>函数操作和sub_thread类似，但不需要对其进行加锁操作。在成功建立连接后，进入一个死循环，在循环中创建一个JSON格式的消息并发布到指定的主题。</li>
<li>在<code>main</code>函数中使用了<code>pthread_create</code>函数来创建线程，并使用<code>pthread_join</code>函数来等待线程结束。</li>
</ul>
</li>
</ul>
</li>
<li><strong>MQTT协议与HTTP协议相比，有何优势？为什么选择MQTT协议进行数据传送？</strong><ul>
<li>MQTT协议相比HTTP协议在降低功耗和推送功能开发上具有明显优势，适合于资源有限的环境和实时数据传输的场景。因此选择MQTT协议进行数据传送。</li>
</ul>
</li>
<li><strong>如何使用Qt开发平台设计手机App？</strong><ul>
<li>使用Qt Creator工具进行开发，利用Qt提供的QML语言和Qt Quick控件进行界面设计和开发，同时通过C++语言编写业务逻辑代码。</li>
</ul>
</li>
<li><strong>介绍一下阿里云上部署mosquitto的过程。</strong><ul>
<li>在阿里云上安装mosquitto，配置mosquitto的配置文件，设置端口号和用户名密码等参数，启动mosquitto服务，配置防火墙规则允许外部访问。</li>
<li>MQTT服务器的端口号通常是1883。</li>
</ul>
</li>
<li><strong>如何在iTop4412开发板上实现对控制指令的接收和执行？</strong><ul>
<li>通过Linux多线程编程，在iTop4412开发板上创建一个线程来监听MQTT服务器发送的控制指令，接收到指令后解析并执行对应的命令。</li>
</ul>
</li>
<li><strong>在Android客户端中，如何使用JSON格式封装控制指令？</strong><ul>
<li>使用 <code>cJSON_CreateObject()</code> 函数创建一个空的JSON对象。</li>
<li>使用 <code>cJSON_AddNumberToObject()</code> 函数向JSON对象中添加一个键值对，键为 “temp”，值为一个随机生成的温度值 <code>a</code>。</li>
<li>使用 <code>cJSON_Print()</code> 函数将JSON对象打印成JSON格式的字符串，并将其赋值给 <code>json_buf</code>。</li>
<li>使用 <code>mosquitto_publish()</code> 函数将JSON字符串发布到MQTT服务器上的主题为 “temp” 的通道中。</li>
</ul>
</li>
<li><strong>如何通过mosquitto服务器将客户端的控制指令转发给iTop4412开发板？</strong><ul>
<li>在mosquitto服务器上配置相应的主题和订阅关系，客户端发布控制指令到对应的主题，mosquitto服务器将控制指令转发给iTop4412开发板的订阅者。</li>
</ul>
</li>
<li><strong>在多用户智能家居控制系统中，如何处理并发访问问题？</strong><ul>
<li>订阅者线程（<code>sub_thread</code>）需要访问共享资源，涉及到订阅者之间的状态共享或者资源竞争，因此需要使用互斥锁来保护共享资源的访问，确保线程安全。</li>
<li>而发布者线程（<code>pub_thread</code>）只是简单地发布消息，没有涉及到共享资源的修改或竞争条件，因此不需要使用互斥锁。只是在程序结束时释放资源。</li>
</ul>
</li>
<li><strong>在Android客户端中，如何实现共享模式和私人模式的切换？</strong><ul>
<li>通过界面设计和用户交互实现切换按钮或选项卡，根据用户选择的模式来设置相应的控制权限和功能。</li>
</ul>
</li>
<li><strong>在iTop4412开发板上，如何解析JSON格式的控制指令并执行相应的功能操作？</strong><ul>
<li>使用第三方JSON库cJSON在Linux环境下解析JSON格式的控制指令，提取出对应的命令参数，然后调用相应的系统调用或执行命令行来控制硬件设备。</li>
</ul>
</li>
<li><strong>在多用户智能家居控制系统中，如何实现用户认证和权限管理？</strong><ul>
<li>在安卓客户端上实现用户登录和注册功能。将用户信息存储在MySQL数据库上，在登陆查询当前用户是否属于该数据库，以及用户名与密码是否匹配；若不存在，可进行注册操作。</li>
<li>由于本设计要访问特定公网的阿里云服务器上的数据库，因此在Qt开发平台上需要首先提供所需要的驱动插件之后，再利用QSqlDatabase来处理与数据库的连接，利用QSqlQuery类来执行底层数据库支持的任何SQL语句。</li>
</ul>
</li>
<li><strong>如何保证系统的稳定性和可靠性？</strong><ul>
<li>采用日志记录功能来记录系统运行状态和处理异常情况，同时进行定期的系统监控和维护。</li>
</ul>
</li>
<li><strong>在Android客户端中，如何实现界面的实时更新和数据同步？</strong><ul>
<li>使用信号与槽机制： 在Qt中，通过信号与槽机制实现对象之间的通信。当数据发生变化时，可以通过信号发送变化的消息，然后在界面组件中连接相应的槽函数来更新界面。</li>
</ul>
</li>
<li><strong>在多用户智能家居控制系统中，如何实现系统的扩展性和灵活性？</strong><ul>
<li>采用模块化设计，将系统功能拆分为独立的模块，支持动态加载和卸载，从而实现系统的扩展性和灵活性。</li>
</ul>
</li>
<li><strong>在iTop4412开发板上，如何实现硬件设备的驱动和控制？</strong><ul>
<li>通过 MQTT 实现硬件设备的驱动和控制：<ul>
<li>当用户在 UI 上进行操作时，比如点击 LED 开关按钮，UI 触发对应的槽函数，如 <code>on_ledBt_ON_1_clicked()</code>。</li>
<li>在槽函数中构造一个JSON 数据包，其中包含了需要控制的硬件设备信息，比如 LED 的状态。然后将这个 JSON 数据包发布到 MQTT 主题上，通过 MQTT 协议发送给 MQTT 服务器。</li>
<li>在硬件设备端，通过订阅相应的 MQTT 主题，监听来自 MQTT 服务器的消息。</li>
<li>当硬件设备端接收到相应的消息后，解析 JSON 数据包，获取到控制指令，并执行相应的操作，例如打开或关闭 LED。</li>
</ul>
</li>
</ul>
</li>
<li><strong>该项目还有哪些可以改进的地方？</strong><ul>
<li>可以在mosquitto服务器上配置TLS&#x2F;SSL加密通信，客户端和服务器之间通过证书验证进行安全连接，防止数据被窃取或篡改。确保安卓客户端与mosquitto服务器之间的通信安全性。</li>
<li>此外，对于多线程部分我觉得还可以再考虑细化锁的粒度，以及进行RAII技术管理互斥锁，避免在某些异常情况下未释放锁导致资源泄露问题。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>数据库2_Redis数据库.md</title>
    <url>/2024/04/06/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%932_Redis%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="1、Redis简介"><a href="#1、Redis简介" class="headerlink" title="1、Redis简介"></a>1、Redis简介</h1><p>Redis是一个基于内存的数据存储系统，它<strong>将数据完全存储在内存中</strong>，通过使用<strong>持久化机制</strong>来将数据定期写入磁盘以保证数据的持久性。</p>
<span id="more"></span>

<h2 id="（1）内存淘汰机制-过期策略"><a href="#（1）内存淘汰机制-过期策略" class="headerlink" title="（1）内存淘汰机制&#x2F;过期策略"></a>（1）内存淘汰机制&#x2F;过期策略</h2><p><strong>MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？</strong></p>
<p>redis 提供 6种数据淘汰策略：</p>
<ul>
<li>volatile-lru： 从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl： 从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li>volatile-random： 从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li>allkeys-lru： 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）.</li>
<li>allkeys-random： 从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-eviction： 禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</li>
</ul>
<h2 id="（2）持久化机制"><a href="#（2）持久化机制" class="headerlink" title="（2）持久化机制"></a>（2）持久化机制</h2><p><strong>怎么保证 redis 挂掉之后再重启数据可以进行恢复？</strong></p>
<p><strong>持久化数据</strong>：也就是将内存中的数据写入磁盘。</p>
<ul>
<li><p>目的：</p>
<ul>
<li>为了之后重用数据（比如重启机器、机器故障之后恢复数据），</li>
<li>为了防止系统故障而将数据备份到一个远程位置。</li>
</ul>
</li>
<li><p><strong>快照（snapshotting，RDB）</strong></p>
<ul>
<li>在指定的时间间隔内将内存中的数据集快照写入磁盘，RDB是内存快照（内存数据的二进制序列化形式）的方式持久化，每次都是从Redis中生成一个快照进行数据的全量备份。</li>
<li>Redis持久化<strong>默认开启为RDB持久化</strong>。<ul>
<li>指定的时间间隔：体现在主进程fork子进程的阶段。</li>
<li>触发规则：<ul>
<li><strong>手动触发</strong><ul>
<li><strong>save</strong>：阻塞当前Redis进程，直到RDB持久化完成（尽量不使用）</li>
<li><strong>bgsave</strong>：Redis主进程fork子进程，由子进程完成持久化</li>
</ul>
</li>
<li><strong>自动触发</strong>：<ul>
<li><strong>配置触发</strong>：redis.conf——&#x2F;snapshot即可定位到触发的配置位置<ul>
<li>save 3600 1 300 100 600 60 10000<ul>
<li>save 3600 1：3600秒内有1个key被修改，触发RDB</li>
<li>save 300 100：300秒内有100个key被修改，触发RDB</li>
<li>save 60 10000：60秒内有10000个key被修改，触发RDB</li>
</ul>
</li>
</ul>
</li>
<li><strong>shutdown触发</strong></li>
<li><strong>flushall触发</strong>：清空Redis数据的同时清空dump.rdb文件，等同于删库跑路</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>优点<ul>
<li>性能高：RDB持久化通过生成一个快照文件来保存数据，因此在恢复数据时速度非常快；</li>
<li>文件紧凑：RDB文件是二进制格式的数据库文件，相较于AOF文件来说，文件体积小。</li>
</ul>
</li>
<li>缺点<ul>
<li>可能丢失数据：由于RDB是定期生成的快照文件，如果Redis意外宕机，最近一次的修改可能会丢失。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>只追加文件（append-only file，AOF）</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404061114362.png" alt="image-20240406111403297"></p>
<ul>
<li>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。</li>
<li><strong>同步策略</strong>：<ul>
<li><code>appendfsync always</code>：每次有数据修改发生时都会写入AOF文件，但会严重降低Redis的速度；</li>
<li><code>appendfsync everysec</code>：每秒刷新一次缓冲区中的数据到AOF文件，显式地将多个写命令同步到硬盘；</li>
<li><code>appendfsync no</code>：Redis进程不会主动地去刷新缓冲区的数据到AOF文件，让操作系统决定何时进行同步。</li>
</ul>
</li>
<li><strong>重写策略</strong><ul>
<li><code>auto-aof-rewrite-percentage 100</code>：当AOF文件体积达到上次重写之后的体积的100%时，触发AOF重写；</li>
<li><code>auto-aof-rewrite-min-size 64mb</code>：当AOF文件体积超过该阈值时，触发AOF重写。</li>
</ul>
</li>
<li><strong>优点</strong><ul>
<li>数据更加可靠：AOF持久化记录了每个写命令的操作，因此在出现故障时，可以通过重新执行AOF文件来保证数据的完整性；</li>
<li>可以保留写命令历史：AOF文件是一个追加日志文件，可以用于回放过去的写操作。</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>文件较大：由于记录了每个写命令，AOF文件体积通常比RDB文件要大；</li>
<li>恢复速度较慢：当AOF文件较大时，Redis重启时需要重新执行整个AOF文件，恢复速度相对较慢。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="（3）缓存击穿、缓存雪崩和缓存穿透"><a href="#（3）缓存击穿、缓存雪崩和缓存穿透" class="headerlink" title="（3）缓存击穿、缓存雪崩和缓存穿透"></a>（3）缓存击穿、缓存雪崩和缓存穿透</h2><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>在高并发的访问下，一个热点数据失效时，大量请求会直接绕过缓存，直接查询数据库，导致数据库压力剧增。</p>
<p>解决方案：</p>
<ul>
<li><strong>设置热点数据永不过期</strong>：对于一些热点数据，可以设置不过期，或者设置较长的过期时间，以保证这部分数据在缓存中一直可用，减少因数据过期引起的击穿问题；</li>
<li><strong>设置互斥锁</strong>：在缓存失效时，只允许一个请求访问数据库，其他请求需要等待该请求执行完毕后再从缓存中获取数据，可以减少并发请求对数据库的冲击；</li>
<li><strong>采用布隆过滤器（Bloom Filter）</strong>：使用布隆过滤器判断请求的数据是否存在，如果不存在，可以直接返回避免对数据库的查询，缓解击穿压力。</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>在高并发的访问下，大规模缓存失效同时失效或者缓存宕机，大量请求同时涌入数据库，导致数据库负载过大甚至崩溃的情况。 </p>
<p>解决方案：</p>
<ul>
<li><strong>随机分布过期时间</strong>：在设置缓存数据的过期时间时，可以随机分布过期时间，避免缓存数据同时大规模失效；</li>
<li><strong>使用多级缓存</strong>：引入多级缓存架构，将请求分散到不同的缓存层，即使一个缓存层发生雪崩，也能够有其他缓存层提供服务。</li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指恶意请求或者大量查询不存在于缓存中的数据，导致请求直接绕过缓存层，直接访问后端存储系统（如数据库），从而给后端系统造成巨大压力的现象。</p>
<p>解决方法主要包括：</p>
<ul>
<li><strong>空值缓存</strong>：对于查询数据库返回空结果的情况，也将其缓存起来，但设置一个较短的过期时间，防止缓存穿透的请求直接击穿数据库；</li>
<li><strong>采用布隆过滤器（Bloom Filter）</strong>：使用布隆过滤器判断请求的数据是否存在，如果数据不存在，则直接拒绝访问，从而避免了对后端系统的查询请求，减轻了后端压力；</li>
<li><strong>数据预热</strong>：在系统启动或者定时任务中，预先将热点数据加载到缓存中，避免缓存穿透带来的大量请求直接击穿数据库；</li>
<li><strong>合法性校验</strong>：在接收到请求后，首先进行参数的合法性校验，对非法请求直接拒绝，从而减少无效请求对后端系统的压力。</li>
</ul>
<h2 id="（4）Redis的哨兵机制是怎样的？"><a href="#（4）Redis的哨兵机制是怎样的？" class="headerlink" title="（4）Redis的哨兵机制是怎样的？"></a>（4）Redis的哨兵机制是怎样的？</h2><p>设置多个哨兵监视Master节点。只有当多个哨兵都认为Master节点宕掉时，才进行主从切换；同时，针对由哪一个哨兵来进行主从切换的问题，进行哨兵选举，通过选举选出一个主导的哨兵进行主从切换。</p>
<h2 id="（5）Redis数据类型"><a href="#（5）Redis数据类型" class="headerlink" title="（5）Redis数据类型"></a>（5）Redis数据类型</h2><ul>
<li>String：String是最常用的数据类型，在Redis中以二进制安全的方式存储字符串值。它可以包含任何类型的数据，比如文本、整数或二进制数据。</li>
</ul>
<ol start="2">
<li>Hash：Hash是一个键值对的集合，其中每个键都与一个值相关联。在Redis中，Hash可以用于存储和操作对象，每个键值对相当于对象的字段和值。</li>
<li>List：List是一个按照插入顺序排序的字符串元素集合。集合中的元素可以重复，可以从列表的两端进行插入和删除操作，可用于实现队列、栈等数据结构。</li>
<li>Set：Set是一个无序、唯一的字符串集合，不允许重复的成员。可以对集合执行添加、删除和判断成员是否存在等操作，也支持集合间的交集、并集和差集运算。</li>
<li>Sorted Set：Sorted Set是一个有序的字符串集合，每个成员都关联着一个分数。集合中的成员根据分数的大小进行排序，可以进行范围查询和按分数排名操作。</li>
</ol>
<h2 id="（6）Redis是单线程的，为什么还会这么快呢？"><a href="#（6）Redis是单线程的，为什么还会这么快呢？" class="headerlink" title="（6）Redis是单线程的，为什么还会这么快呢？"></a>（6）Redis是单线程的，为什么还会这么快呢？</h2><ul>
<li>首先Redis是基于内存的nosql数据库，基于内存的读写效率本身就非常高；</li>
<li>Redis内部对应核心命令的执行采用了单线程模型，并且给予内存模型，单条命令的执行速度远小于线程上下文的开销，所以使用单线程能够大大提升我们Redis的吞吐量；</li>
<li>内部提供了高效查询和操作的数据结构；</li>
<li>采用IO多路复用模型，能够同时处理大量连接，并且使用reator模型，能够并发的处理连接以及对连接进行响应，但是内部命令执行还是单线程的；</li>
<li>对Redis常用操作进行旅游化，提供了管道技术和批量操作技术，能够减少单次Redis操作的网络开销</li>
</ul>
<h2 id="（7）使用缓存的好处？"><a href="#（7）使用缓存的好处？" class="headerlink" title="（7）使用缓存的好处？"></a>（7）使用缓存的好处？</h2><ul>
<li>高性能</li>
<li>高并发</li>
</ul>
<h2 id="（8）对Redis的理解"><a href="#（8）对Redis的理解" class="headerlink" title="（8）对Redis的理解"></a>（8）对Redis的理解</h2><p>首先，Redis本质上是一个nosql数据库，内部提供了非常多的数据结构，帮助我们满足各种场景的需求实现。</p>
<p>并且内部使用了IO多路复用的模型，使得Redis能够处理大量的连接，并且内部对于核心命令的执行部分使用了单线程，使得我们的不需要考虑线程安全的问题。</p>
<p>Redis完全是基于内存操作，速度很快，他的并发读写性能非常高，并且Redis6之后，对于协议解析和响应使用率了多线程模型，进一步降低核心单线程处理任务的复杂度，使得我们Redis的性能又提升了一个量级。</p>
<p>Redis本身提供了非常多的高可用机制，帮助我们实现Redis的高可用集群，目前企业中已经大量使用Redis作为我们缓存 等场景</p>
<h2 id="（7）一个Redis实例最多能存放多少Keys？"><a href="#（7）一个Redis实例最多能存放多少Keys？" class="headerlink" title="（7）一个Redis实例最多能存放多少Keys？"></a>（7）一个Redis实例最多能存放多少Keys？</h2><p>Redis 的每个实例最多可以存放约 2^32 - 1 个keys，即大约 42 亿个keys。</p>
<p>这是由 Redis 内部使用的哈希表实现决定的，它使用 32 位有符号整数作为索引。Redis 使用的哈希函数和负载因子等因素也会影响实际可存放键的数量。</p>
<h2 id="（8）说说你对缓存双写不一致的理解？"><a href="#（8）说说你对缓存双写不一致的理解？" class="headerlink" title="（8）说说你对缓存双写不一致的理解？"></a>（8）说说你对缓存双写不一致的理解？</h2><p>缓存不一致主要是指我们的业务系统里面引入了缓存提生我们查询性能，但是当我们数据库数据发生变更的时候，我们如何去保证缓存和数据库中数据的一致性问题，主要有两大种方案首先是异步通知，可以利用canal监听我们mysql的数据变化，然后发送变更缓存消息到mq，让业务系统去对缓存进行更新，由于我们一般监听binlog都是在从mysql上进行，而主从同步有一定的延时，监听完消息发送到mq又存在一定的延时，所以他的实时性不是很好，比较适合用在一致性要求不是很高的缓存场景，并且异步通知最大的优点就是解耦，对于更新缓存的逻辑不需要耦合在代码中</p>
<p>第二种方案也是得物使用规范的中最推荐的同步双写，之所以使用这种方案，就是非常多的业务中都涉及到钱相关，如果缓存长时间不一致容易造成大量的资损，比如：我们商品中心大量商品数据进行了缓存，此时我们管理员修改了价格，这个缓存怎么同步，其实就是缓存一致性的问题，对于这种一致性比较高的业务，我们推荐最佳方案是采用延时双删，先删缓存，然后写数据库，然后过500ms再删一次缓存，这种方案能够尽可能避免出现缓存不一致的问题，但是也是无法完全避免，因为可能出现一些极端情况，比如出现了慢SQL，查了半天还是旧数据，结果我们双删也删完了，他又走了旧数据的逻辑，但是这种都可以通过监控来进行优化，尽最大可能不出现问题，如果想要保证强一致性，其实方案就是使用读写锁来保证了，但是一般C端业务，优先考虑用户体验性，如果不是直接操作钱一般不使用这种方案</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>面试八股</title>
    <url>/2024/04/07/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="一、C-C-八股"><a href="#一、C-C-八股" class="headerlink" title="一、C&#x2F;C++八股"></a>一、C&#x2F;C++八股</h1><h2 id="1、C-C"><a href="#1、C-C" class="headerlink" title="1、C&#x2F;C++"></a>1、C&#x2F;C++</h2><h3 id="如何看待C-和C的关系？"><a href="#如何看待C-和C的关系？" class="headerlink" title="如何看待C++和C的关系？"></a>如何看待C++和C的关系？</h3><p>C++最初只是在C的基础上增加了面向对象的特性，后来随着C++的发展，其灵活性不断增加，现在C++已经成为了一个语言联邦，他包含了C语言，但也有延伸出许多其他特性。<br>（1）面向对象：C++包含封装、继承、多态的特性；<br>（2）C++支持泛型编程；<br>（3）C++包含了STL部分。</p>
<h3 id="对面向对象的理解，面向对象解决了什么问题"><a href="#对面向对象的理解，面向对象解决了什么问题" class="headerlink" title="对面向对象的理解，面向对象解决了什么问题"></a>对面向对象的理解，面向对象解决了什么问题</h3><h3 id="介绍一下C-11的新特性"><a href="#介绍一下C-11的新特性" class="headerlink" title="介绍一下C++11的新特性"></a>介绍一下C++11的新特性</h3><p>一些主要新特性介绍：</p>
<ol>
<li><strong>自动类型推导（auto）</strong>：<ul>
<li>使用<code>auto</code>关键字可以让编译器自动推导变量的类型，简化变量定义。</li>
</ul>
</li>
<li><strong>基于范围的for循环（Range-based for loop）</strong>：<ul>
<li>允许遍历容器或数组时更简洁地写法。</li>
</ul>
</li>
<li><strong>智能指针（Smart Pointers）</strong>：<ul>
<li>引入了<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>，用于更安全方便地管理动态分配的内存。</li>
</ul>
</li>
<li><strong>Lambda表达式</strong>：<ul>
<li>支持匿名函数，方便地定义和使用内联函数对象。</li>
</ul>
</li>
<li><strong>nullptr关键字</strong>：<ul>
<li>引入<code>nullptr</code>作为空指针的标准表示，取代了之前的<code>NULL</code>。</li>
</ul>
</li>
<li><strong>右值引用和移动语义（Rvalue references and Move semantics）</strong>：<ul>
<li>引入右值引用<code>&amp;&amp;</code>，以及基于此的移动语义和<code>std::move</code>，优化资源管理和提高效率。</li>
</ul>
</li>
<li><strong>统一的初始化列表（Uniform initialization）</strong>：<ul>
<li>提供一种统一的语法来初始化任何对象。</li>
</ul>
</li>
<li><strong>常量表达式（constexpr）</strong>：<ul>
<li>允许在编译时计算表达式值的函数和变量。</li>
</ul>
</li>
<li><strong>多线程支持（Multithreading support）</strong>：<ul>
<li>在标准库中加入了线程（thread）、互斥量（mutex）、条件变量（condition variable）等多线程编程的支持。</li>
</ul>
</li>
<li><strong>枚举类（Enum classes）</strong>：<ul>
<li>引入了枚举类（也称作强类型枚举），提高了枚举的类型安全。</li>
</ul>
</li>
<li><strong>删除和默认的函数（Deleted and defaulted functions）</strong>：<ul>
<li>允许显式地禁用（delete）或默认实现（default）特殊成员函数。</li>
</ul>
</li>
</ol>
<h2 id="2、智能指针相关"><a href="#2、智能指针相关" class="headerlink" title="2、智能指针相关"></a>2、智能指针相关</h2><h3 id="讲一下什么是智能指针？"><a href="#讲一下什么是智能指针？" class="headerlink" title="讲一下什么是智能指针？"></a>讲一下什么是智能指针？</h3><p>智能指针是对裸指针的封装，其实质上是一个类，在离开类的作用范围后会自动调用析构函数释放资源，因此避免了程序员手动操作时忘记释放资源导致的内存泄漏问题。<br>智能指针包含4类：<br>（1）auto_ptr：在C++11中已经被废弃使用。它提供独占所有权，但没有复制语义，存在潜在的危险，例如当它被复制后原始指针可能被意外释放。<br>（2）unique_ptr：实现了对资源的独占访问，同一时刻只能有一个指针对资源进行访问。<br>（3）shared_ptr：当有多个对象需要共享资源时，则使用shared_ptr。其内部维护了一个引用计数器，当引用计数减少为0时调用delete释放资源。<br>当存在下列情况时会使得引用计数增加：1）新建一个shared_ptr指向对象；2）拷贝构造函数复制一个shared_ptr；3）复制操作将一个shared_ptr复制给另一个shared_ptr。<br>当存在下列操作时会使得引用计数减少：1）当一个shared_ptr被销毁时，如离开作用域，或调用了析构函数；2）当一个shared_ptr不再指向某个资源，如调用reset方法。<br>（4）weak_ptr：指向一个shared_ptr对象，并不会增加其引用计数，而只是提供一种访问方式。可以解决shared_ptr中存在的循环引用问题。</p>
<h3 id="循环引用是如何发生的？如何解决？"><a href="#循环引用是如何发生的？如何解决？" class="headerlink" title="循环引用是如何发生的？如何解决？"></a>循环引用是如何发生的？如何解决？</h3><p>当多个shared_ptr对象互相引用，或是在某些比较复杂的数据结构中存在多条引用路径时，可能存在循环引用问题，导致资源无法被释放。此时就可以使用weak_ptr来打破循环，因为waek_ptr不会增加引用计数。</p>
<h3 id="shared-ptr是线程安全的吗？多线程使用时需要注意什么问题？"><a href="#shared-ptr是线程安全的吗？多线程使用时需要注意什么问题？" class="headerlink" title="shared_ptr是线程安全的吗？多线程使用时需要注意什么问题？"></a>shared_ptr是线程安全的吗？多线程使用时需要注意什么问题？</h3><p>shared_ptr并不是线程安全的，当多个线程同时访问或修改同一个shared_ptr对象时，可能会导致数据竞争或未定义的行为。但shared_ptr内部的计数器操作是线程安全的。<br>因此，在多线程使用时，需要避免多个线程同时访问一个shared_ptr对象或对其修改。</p>
<h3 id="引用计数的线程安全性怎么实现的？"><a href="#引用计数的线程安全性怎么实现的？" class="headerlink" title="引用计数的线程安全性怎么实现的？"></a>引用计数的线程安全性怎么实现的？</h3><p>引用计数的线程安全性通常通过原子操作实现，确保对引用计数的增减操作是原子的，这样可以避免多线程环境下的竞态条件。</p>
<h3 id="如果有⼀个场景需要用到线程安全的shared-ptr，一般你会怎么做？"><a href="#如果有⼀个场景需要用到线程安全的shared-ptr，一般你会怎么做？" class="headerlink" title="如果有⼀个场景需要用到线程安全的shared_ptr，一般你会怎么做？"></a>如果有⼀个场景需要用到线程安全的shared_ptr，一般你会怎么做？</h3><p>如果需要在多线程环境下使用线程安全的 shared_ptr，通常会使用 std::atomic 或者 std::mutex 来保护对 shared_ptr 的访问。</p>
<h3 id="make-shared和shared-ptr构造函数创建shared-ptr的区别？"><a href="#make-shared和shared-ptr构造函数创建shared-ptr的区别？" class="headerlink" title="make_shared和shared_ptr构造函数创建shared_ptr的区别？"></a>make_shared和shared_ptr构造函数创建shared_ptr的区别？</h3><p>make_shared 创建的对象和 shared_ptr 一起存储在同一块内存中，而使用构造函数创建的 shared_ptr 需要额外的内存用于存储引用计数。</p>
<h3 id="如果构造函数传入同一裸指针构造两个shared-ptr对象，会发生什么现象？"><a href="#如果构造函数传入同一裸指针构造两个shared-ptr对象，会发生什么现象？" class="headerlink" title="如果构造函数传入同一裸指针构造两个shared_ptr对象，会发生什么现象？"></a>如果构造函数传入同一裸指针构造两个shared_ptr对象，会发生什么现象？</h3><p>如果构造函数传入同一个裸指针构造两个 shared_ptr 对象，会导致两个 shared_ptr 对象都管理同一个对象，引用计数会变为 2。</p>
<h3 id="还是上面的问题，你觉得对于所谓的智能指针，为什么会出现这样的现象？"><a href="#还是上面的问题，你觉得对于所谓的智能指针，为什么会出现这样的现象？" class="headerlink" title="还是上面的问题，你觉得对于所谓的智能指针，为什么会出现这样的现象？"></a>还是上面的问题，你觉得对于所谓的智能指针，为什么会出现这样的现象？</h3><p>这种现象是因为 shared_ptr 的设计决定了它的共享性质，即多个 shared_ptr 可以管理同一个对象。</p>
<h3 id="很多人说到weak-ptr就会说是为了解决循环引用，你觉得这是关键的因素吗？"><a href="#很多人说到weak-ptr就会说是为了解决循环引用，你觉得这是关键的因素吗？" class="headerlink" title="很多人说到weak_ptr就会说是为了解决循环引用，你觉得这是关键的因素吗？"></a>很多人说到weak_ptr就会说是为了解决循环引用，你觉得这是关键的因素吗？</h3><p><code>std::weak_ptr</code> 的主要作用是提供一种非拥有性的智能指针，用于解决共享指针的循环引用问题，避免内存泄漏和资源泄露。它不会增加对象的引用计数，也不会影响对象的生命周期，因此适用于表示临时性的对象引用或者避免循环引用的情况。</p>
<p>除了解决循环引用之外，<code>std::weak_ptr</code> 还具有其他用途，例如：</p>
<ol>
<li><strong>观察者模式（Observer Pattern）：</strong> <code>std::weak_ptr</code> 可用于实现观察者模式，其中观察者持有被观察者对象的弱引用，以避免循环引用和对象生命周期管理的问题。</li>
<li><strong>缓存：</strong> 在缓存系统中，可以使用 <code>std::weak_ptr</code> 来保存对象的缓存项，以避免对对象的强引用导致缓存项无法被释放。</li>
<li><strong>延迟初始化：</strong> <code>std::weak_ptr</code> 可用于实现延迟初始化（Lazy Initialization），只有在需要时才创建对象，以提高性能和资源利用率。</li>
</ol>
<h3 id="如果传给shared-ptr一个引用，那么引用计数会不会加1？"><a href="#如果传给shared-ptr一个引用，那么引用计数会不会加1？" class="headerlink" title="如果传给shared_ptr一个引用，那么引用计数会不会加1？"></a>如果传给shared_ptr一个引用，那么引用计数会不会加1？</h3><p>（1）当一个裸指针（raw pointer）被传递给<code>std::shared_ptr</code>的构造函数时，<code>std::shared_ptr</code>会接管该裸指针的所有权，并初始化引用计数为1。</p>
<p>（2）当一个<code>std::shared_ptr</code>的引用被传递给另一个<code>std::shared_ptr</code>对象时（例如通过拷贝构造函数或拷贝赋值操作），新的<code>std::shared_ptr</code>对象会共享原有对象的所有权，并且引用计数会增加1。</p>
<p>（3）<code>std::shared_ptr</code>不能直接从非指针类型的引用构造。如果尝试从一个对象的引用或其他非指针类型的引用创建<code>std::shared_ptr</code>，需要先获取该对象的地址，然后传递给<code>std::shared_ptr</code>。这种情况下，会创建一个新的<code>std::shared_ptr</code>实例，引用计数从1开始。</p>
<h2 id="3、关键字"><a href="#3、关键字" class="headerlink" title="3、关键字"></a>3、关键字</h2><h3 id="介绍一下static和const？"><a href="#介绍一下static和const？" class="headerlink" title="介绍一下static和const？"></a>介绍一下static和const？</h3><p>const允许我们指定一个语义约束，告诉编译器某个变量不应该被修改。const可以用于修饰普通变量、函数、类等。比如在重载解引用操作符时，就可以用const来修饰，因为在解引用操作前后指针所指向的值是不应该被改变的。<br>static则修改存储方式和可见范围。主要包含4类：<br>（1）静态成员变量：静态成员变量不属于类的任何一个对象，而只属于类本身，所有对象共享一个静态成员变量。<br>（2）静态成员函数：静态成员函数同理。<br>（3）静态局部变量：定义在函数内部，和普通局部变量不同，在函数整个运行期间只会初始化一次，即使函数被多次调用也是如此。<br>（4）静态全局变量：静态全局变量在某个源文件中被定义后则只能在该源文件中被使用，而不能在其他文件中使用，有助于封装和避免命名冲突。</p>
<h3 id="explicit关键字用在什么情况下？"><a href="#explicit关键字用在什么情况下？" class="headerlink" title="explicit关键字用在什么情况下？"></a>explicit关键字用在什么情况下？</h3><p>explicit关键用于声明一个单参数的构造函数，阻止该构造函数隐式转换为该类的类型。</p>
<h3 id="inline关键字遇到过吗？作用是什么？和-define有什么区别？"><a href="#inline关键字遇到过吗？作用是什么？和-define有什么区别？" class="headerlink" title="inline关键字遇到过吗？作用是什么？和#define有什么区别？"></a>inline关键字遇到过吗？作用是什么？和#define有什么区别？</h3><p>inline关键字作为函数定义的关键字，说明该函数是内联函数。内联函数会将代码块嵌入到每个调用该函数的地方，减少函数调用的开销，但增加了代码量。同时要注意inline只是对编译器的一个建议，真正能否内联还是要看编译器自己的判断。</p>
<p>和#define的区别在于：</p>
<p>（1）#define是关键字，inline是函数。</p>
<p>（2）宏定义在预处理阶段进行文本替换，inline函数在编译时进行替换。</p>
<p>（3）inline有类型检查，相对于#define较安全。</p>
<h3 id="define、const和constexpr的区別和应用场景？"><a href="#define、const和constexpr的区別和应用场景？" class="headerlink" title="#define、const和constexpr的区別和应用场景？"></a>#define、const和constexpr的区別和应用场景？</h3><p>（1）#define是预处理指令，用于定义常量宏。它在预处理阶段将标识符替换为指定的文本。不包含类型检查。</p>
<p>（2）const用于定义类型安全的常量，在编译时被创建，并且会占用内存，可以在运行时被初始化。之所以说其是类型安全的，是因为声明为const的常量在编译期间会检查程序是否对其进行了修改，避免意外修改；同时会对其进行类型检查，因此是安全的。</p>
<p>（3）constexpr用于声明常量表达式，在编译时被求值。因此适用于在编译时期就能确定初始值，并且在整个程序生命周期内都不会改变的常量。</p>
<h3 id="简单说说lambda表达式？"><a href="#简单说说lambda表达式？" class="headerlink" title="简单说说lambda表达式？"></a>简单说说lambda表达式？</h3><p>Lambda表达式是C++11中引入的一种匿名函数，可以在需要函数的地方直接定义，无需提前命名。</p>
<p>它可以显著减少代码的数量和复杂性，特性是在一些需要简单的函数作为参数传递给算法或函数对象时，可以简化代码的书写。</p>
<p>Lambda表达式可以捕获定义范围内的局部变量，形成闭包。这是Lambda表达式可以在其定义范围之外使用局部变量。</p>
<h3 id="virtual和override的区别和应用场景？"><a href="#virtual和override的区别和应用场景？" class="headerlink" title="virtual和override的区别和应用场景？"></a>virtual和override的区别和应用场景？</h3><p>（1）virtual用于声明虚函数，即在基类中声明一个函数为虚函数，以便在派生类中进行覆盖或重写。</p>
<p>（2）override用于显式地告诉编辑器，当前函数是基类中虚函数的重写版本。</p>
<h3 id="sizeof和strlen之间的区别是什么？"><a href="#sizeof和strlen之间的区别是什么？" class="headerlink" title="sizeof和strlen之间的区别是什么？"></a>sizeof和strlen之间的区别是什么？</h3><p>（1）sizeof是一个运算符而不是函数，用于获取指定类型或变量在内存中占用的字节数，在编译时进行计算；</p>
<p>（2）strlen是一个函数，用于获取以null结尾的C风格字符串的长度，即字符串中有效字符的数量，不包含结尾的null字符。在运行时进行遍历计算。</p>
<h3 id="scanf-和std-cin有什么区别？"><a href="#scanf-和std-cin有什么区别？" class="headerlink" title="scanf()和std::cin有什么区别？"></a>scanf()和std::cin有什么区别？</h3><p>（1）<code>scanf()</code> 是 C 语言标准库中的函数，用于从标准输入流（通常是键盘）读取数据，并按照指定的格式进行解析；<code>std::cin</code> 是 C++ 中的输入流对象，属于标准库 <code>iostream</code> 中的一部分，用于从标准输入流或其他流中读取数据；</p>
<p>（2）<code>scanf()</code> 对输入的类型不进行类型检查，可能会导致类型不匹配或溢出等问题；<code>std::cin</code> 是 C++ 中的类型安全输入方式。</p>
<h3 id="struct和class的区别是什么？"><a href="#struct和class的区别是什么？" class="headerlink" title="struct和class的区别是什么？"></a>struct和class的区别是什么？</h3><p>struct和class是用于定义自定义数据类型的关键字。</p>
<p>其中struct默认的访问类型是public，而class默认的访问类型是private。</p>
<p>此外，struct的继承是public的，而class的继承默认是private的。struct用于较为简单的结构，而class用于更加复杂的结构。</p>
<h2 id="4、内存模型-虚拟内存"><a href="#4、内存模型-虚拟内存" class="headerlink" title="4、内存模型&#x2F;虚拟内存"></a>4、内存模型&#x2F;虚拟内存</h2><h3 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h3><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
<h3 id="一个由C-C-编译的程序的内存分布（内存模型）？"><a href="#一个由C-C-编译的程序的内存分布（内存模型）？" class="headerlink" title="一个由C&#x2F;C++编译的程序的内存分布（内存模型）？"></a>一个由C&#x2F;C++编译的程序的内存分布（内存模型）？</h3><p>其内存分布或内存模型实际上就是虚拟内存。主要分为以下几个部分，分别是：<br>.text段，.rodata段，.data段，.bss段，堆，内存映射区，栈，内核空间。<br>其中，各项主要内容如下：<br>（1）.text段主要存在程序编译后的机器指令<br>（2）.rodata段主要存放程序中的各种只读变量<br>（3）.data段主要存放已经被初始化了的全局静态变量和局部静态变量<br>（4）.bss段主要存放未被初始化的全局静态变量和局部静态变量<br>（5）堆：由程序员进行动态分配，如调用malloc或new<br>（6）栈：由编译器自动分配释放，存放一些局部变量等<br>（7）内核空间：存放操作系统的一些内核数据和代码</p>
<h3 id="不同段上的对象的生命周期是怎样的？"><a href="#不同段上的对象的生命周期是怎样的？" class="headerlink" title="不同段上的对象的生命周期是怎样的？"></a>不同段上的对象的生命周期是怎样的？</h3><p>（1）.data&#x2F;.bss段的生命周期和程序的生命周期一致，在程序加载到内存时被分配，程序结束时被销毁<br>（2）堆上的对象由程序员进行动态分配<br>（3）栈上的对象由编译器进行分配，当离开作用域范围时被编译器销毁</p>
<h3 id="堆和栈的区别是什么？"><a href="#堆和栈的区别是什么？" class="headerlink" title="堆和栈的区别是什么？"></a>堆和栈的区别是什么？</h3><p>（1）内存分配方式<br>（2）生命周期不同<br>（3）内存大小不同</p>
<h3 id="如何让对象只能存在于栈-堆中？"><a href="#如何让对象只能存在于栈-堆中？" class="headerlink" title="如何让对象只能存在于栈&#x2F;堆中？"></a>如何让对象只能存在于栈&#x2F;堆中？</h3><p>如果将operator new设置为私有的，此时尝试在堆上分配内存失败，对象就会存在于栈中。<br>由于编译器在栈上分配内存时会自动调用其构造函数和析构函数，因此如果将析构函数设置为私有的，在栈上分配内存失败，对象就会存在于堆中。</p>
<h3 id="new和malloc的区别？"><a href="#new和malloc的区别？" class="headerlink" title="new和malloc的区别？"></a>new和malloc的区别？</h3><p>主要包含以下区别：<br>（1）new是c++特有的操作符，只能在C++中使用；malloc是C中的函数，但可以同时在c&#x2F;c++中使用。<br>（2）malloc在使用时需要指定分配内存的大小，如malloc(sizeof(int))，但new的使用则比较简洁，如new int。<br>（3）malloc分配的内存是未定义的，而new在分配内存时还会调用构造函数进行初始化。<br>（4）malloc返回的是void *类型的指针，需要进行强制类型转换以得到需要的指针类型，而new会自动转换为响应的指针类型。<br>（5）malloc调用free进行释放， ew调用delete进行释放。</p>
<h3 id="内存模型是什么？是指可执行文件中包含这些东西吗？"><a href="#内存模型是什么？是指可执行文件中包含这些东西吗？" class="headerlink" title="内存模型是什么？是指可执行文件中包含这些东西吗？"></a>内存模型是什么？是指可执行文件中包含这些东西吗？</h3><p>内存模型是指虚拟内存。<br>可执行文件中只包含.text .rodata和.data，不包含.bss、栈和堆。.bss段存放的是未初始化的全局静态变量和局部静态变量，在程序加载到内存中时，这些变量会被初始化为0或空指针，在生成可执行文件时不会占用内存空间。而栈和堆是动态加载的，只有在程序运行时才会分配。</p>
<h3 id="C-对象的大小由哪些因素决定？"><a href="#C-对象的大小由哪些因素决定？" class="headerlink" title="C++对象的大小由哪些因素决定？"></a>C++对象的大小由哪些因素决定？</h3><p>（1）变量的类型和大小；</p>
<p>（2）内存对齐和填充；</p>
<p>（3）虚函数所带来的开销；</p>
<p>（4）空类优化。</p>
<h3 id="说一下你对于内存对齐的理解？"><a href="#说一下你对于内存对齐的理解？" class="headerlink" title="说一下你对于内存对齐的理解？"></a>说一下你对于内存对齐的理解？</h3><p>内存对齐是指对于特定类型的数据规定了其应该位于内存的哪个位置上。比如，对于int类型的数据，在32系统上要求其内存对齐为4个字节，也就是说其起始地址应该为4的倍数。</p>
<p>内存对齐的目的是为了提高内存访问的效率。因为在许多硬件平台上，访问对齐的内存要比访问不对齐的内存更快。</p>
<h3 id="内存对齐可能会带来哪些问题？"><a href="#内存对齐可能会带来哪些问题？" class="headerlink" title="内存对齐可能会带来哪些问题？"></a>内存对齐可能会带来哪些问题？</h3><p>（1）可能会造成内存浪费问题。虽然内存对齐后其内存访问速度会大幅提升，但随之而来的可能会造成一些内存浪费现象。</p>
<p>（2）可能存在平台不兼容的问题。不同类型的数据在不同的平台上可能有不能的内存对齐规则。</p>
<h2 id="5、左值引用和右值引用"><a href="#5、左值引用和右值引用" class="headerlink" title="5、左值引用和右值引用"></a>5、左值引用和右值引用</h2><h3 id="什么是左值，什么是右值？"><a href="#什么是左值，什么是右值？" class="headerlink" title="什么是左值，什么是右值？"></a>什么是左值，什么是右值？</h3><p>左值是指一段指向内存的，具有名称的值，通常有较长的声明周期；右值是指向不稳定内存的匿名值，声明周期较短。可以通过取址符号来进行判断，能取到地址的是左值，取不到的是右值。</p>
<h3 id="前置c-返回的是左值还是右值？后置c-呢？字符串字面量呢？"><a href="#前置c-返回的是左值还是右值？后置c-呢？字符串字面量呢？" class="headerlink" title="前置c++返回的是左值还是右值？后置c++呢？字符串字面量呢？"></a>前置c++返回的是左值还是右值？后置c++呢？字符串字面量呢？</h3><p>前置C++的实现是直接对传入的变量进行自增，然后返回这个对象，即一个具有名称的稳定的值，因此返回的是左值。后置C++是创建一个临时对象，然后对对象自增，再返回这个临时对象自增，因此返回的是右值。<br>字符串字面量也是左值。他会将字符串变量存放在程序的数据段中，程序加载时为其分配一段内存。</p>
<h3 id="什么是左值引用和右值引用？"><a href="#什么是左值引用和右值引用？" class="headerlink" title="什么是左值引用和右值引用？"></a>什么是左值引用和右值引用？</h3><p>左值引用是指向左值的引用，用单个&amp;表示。常量左值引用可以绑定左值，也可以绑定右值。非常量左值引用只能绑定左值。<br>右值引用是指向右值的引用，用两个&amp;&amp;表示。右值引用主要用于移动语义。通过移动语义，可以避免不必要的拷贝操作，从而提升性能。</p>
<h3 id="右值引用是如何提高性能的？"><a href="#右值引用是如何提高性能的？" class="headerlink" title="右值引用是如何提高性能的？"></a>右值引用是如何提高性能的？</h3><p>右值引用主要是通过避免不必要的拷贝操作来提升性能的。<br>举两个例子：<br>（1）当使用右值引用接收函数返回的局部变量时，可以延长该局部变量的声明周期，使得右值引用直接利用该局部变量的内存，而不是创建一个临时对象，从而避免了不必要的开销。<br>（2）当使用一个临时对象来创建一个新对象时，可以使用移动构造函数，直接将资源从一个对象复制到另一个对象上，避免了不必要的复制操作。</p>
<h2 id="6、构造-析构相关"><a href="#6、构造-析构相关" class="headerlink" title="6、构造&#x2F;析构相关"></a>6、构造&#x2F;析构相关</h2><h3 id="深拷贝和浅拷贝指什么？"><a href="#深拷贝和浅拷贝指什么？" class="headerlink" title="深拷贝和浅拷贝指什么？"></a>深拷贝和浅拷贝指什么？</h3><p>（1）深拷贝创建一个新的对象，并且复制对象的所有内容，包括对象的指针成员变量所指向的内存空间。深拷贝后的新对象和原对象之间是彼此独立的。</p>
<p>（2）浅拷贝只复制对象的引用，而不复制对象的内容。也就是说，浅拷贝创建一个新的对象，但是其新对象的指针成员变量指向的是原对象的指针成员变量所指向的内存空间。</p>
<h3 id="移动构造函数可能会有什么问题？"><a href="#移动构造函数可能会有什么问题？" class="headerlink" title="移动构造函数可能会有什么问题？"></a>移动构造函数可能会有什么问题？</h3><p>在使用移动构造函数时，如果当一个对象的资源移动到另一个对象上时发生了异常，此时就会造成有一部分资源转移了，而另一部分没有，从而使得源对象和目标对象上的资源都不完整。因此在使用移动构造函数时应该避免发生异常。如果无法确保移动构造函数不会发生异常，应该用noexcept进行修饰。这样函数如果发生异常时不会继续执行，而是抛出std::terminate并停止。</p>
<h3 id="移动构造函数的使用场景是什么？"><a href="#移动构造函数的使用场景是什么？" class="headerlink" title="移动构造函数的使用场景是什么？"></a>移动构造函数的使用场景是什么？</h3><p>移动构造函数是 C++11 新增的特性，用于实现右值引用语义，可以将临时对象的资源有效地转移给目标对象，避免不必要的资源复制，提高程序的性能和效率。</p>
<p>（1）容器元素的插入和移动</p>
<p>（2）返回临时对象</p>
<h3 id="析构函数为什么设置成虚函数？"><a href="#析构函数为什么设置成虚函数？" class="headerlink" title="析构函数为什么设置成虚函数？"></a>析构函数为什么设置成虚函数？</h3><p>如果这个类是一个多态性质的类，其析构函数应该设置为虚函数，否则就不应该被设置为虚函数。<br>由于基类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。假如析构函数非虚函数，如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，造成内存的局部释放，内存泄漏。因此此时析构函数应该设置为虚函数。<br>但如果这个类不包含多态性，就不应该设置为虚函数，否则会引入虚函数指针和虚函数表，造成内存浪费。</p>
<h3 id="C-在返回⼀个局部对象的时候是如何避免多次调用构造函数的，返回局部对象⼀定会多次构造吗？"><a href="#C-在返回⼀个局部对象的时候是如何避免多次调用构造函数的，返回局部对象⼀定会多次构造吗？" class="headerlink" title="C++在返回⼀个局部对象的时候是如何避免多次调用构造函数的，返回局部对象⼀定会多次构造吗？"></a>C++在返回⼀个局部对象的时候是如何避免多次调用构造函数的，返回局部对象⼀定会多次构造吗？</h3><p>在 C++ 中，返回局部对象时会发生返回值优化（Return Value Optimization，RVO）和命名返回值优化（Named Return Value Optimization，NRVO）。这些优化技术可以避免多次调用构造函数，提高程序的性能和效率。</p>
<p>具体来说，当函数返回一个局部对象时，编译器可以将该对象直接构造在函数调用方的目标对象的位置上，而不是在函数内部创建一个局部对象然后再拷贝到目标对象中。这样就避免了额外的构造和拷贝操作。</p>
<h2 id="7、多态-虚函数相关"><a href="#7、多态-虚函数相关" class="headerlink" title="7、多态&#x2F;虚函数相关"></a>7、多态&#x2F;虚函数相关</h2><h3 id="多态的实现原理是什么？"><a href="#多态的实现原理是什么？" class="headerlink" title="多态的实现原理是什么？"></a>多态的实现原理是什么？</h3><p>c++的多态包括静态多态和动态多态。<br>静态多态是指编译器的多态，主要由函数重载和函数模板实现。函数重载是指在同一作用域内，一组函数具有相同的函数名和不同的参数列表，编译器根据函数调用时传递的参数数量和类型选择调用哪个函数执行。函数模板允许编写通用的代码，编译器根据模板实例化的内容生成代码。<br>动态多态则是在运行时实现，主要由虚函数和继承实现。其核心思想是类的对象会根据其属性来确定究竟调用哪一个类的函数。具体来说，每一个包含虚函数的类中都分配了一个虚函数指针，每一个虚函数指针都指向一个虚函数表。当需要调用函数时，根据虚函数指针找到对应的虚函数表，然后根据函数的下标位置在虚函数表找到对应的函数实现。</p>
<h3 id="c-是如何实现动态多态的？"><a href="#c-是如何实现动态多态的？" class="headerlink" title="c++是如何实现动态多态的？"></a>c++是如何实现动态多态的？</h3><p>c++是通过虚函数实现动态多态的。其核心是通过不同对象的特性来确定调用哪一个类的函数。具体来说，每一个包含虚函数的类都分配了一个虚函数指针，这个虚函数指针指向一个虚函数表。当需要调用对应的函数时，首先根据虚函数指针找到对应的虚函数表，然后根据这个函数在表中的下标位置找到对应的函数。</p>
<h3 id="一个类中有几个虚函数表？一个类的对象有几个虚函数指针？"><a href="#一个类中有几个虚函数表？一个类的对象有几个虚函数指针？" class="headerlink" title="一个类中有几个虚函数表？一个类的对象有几个虚函数指针？"></a>一个类中有几个虚函数表？一个类的对象有几个虚函数指针？</h3><p>一个类继承了多少个父类，就有多少张虚函数表。一个类的对象包含多少张虚函数表，就有多少虚函数指针。</p>
<h3 id="一个类的虚函数指针在类中的内存分布是怎样的？"><a href="#一个类的虚函数指针在类中的内存分布是怎样的？" class="headerlink" title="一个类的虚函数指针在类中的内存分布是怎样的？"></a>一个类的虚函数指针在类中的内存分布是怎样的？</h3><p>根据该类继承父类的顺序，从对象的首地址开始依次排列。</p>
<h3 id="虚函数表在什么时候创建、存在在什么位置？"><a href="#虚函数表在什么时候创建、存在在什么位置？" class="headerlink" title="虚函数表在什么时候创建、存在在什么位置？"></a>虚函数表在什么时候创建、存在在什么位置？</h3><p>（1）虚函数表在<strong>编译时期</strong>创建。编译器在处理类定义时，如果发现类中有虚函数（包括从基类继承的虚函数），它会为这个类生成一个虚函数表。这个表包含了指向类的虚函数的指针。如果类中没有虚函数，则不会生成虚函数表。对于继承的情况，如果派生类覆盖了基类的虚函数，派生类的虚函数表中对应的条目会被更新为指向派生类中的虚函数。如果派生类没有覆盖基类的某个虚函数，那么派生类的虚函数表中会保留一个指向基类虚函数的指针。</p>
<p>（2）虚函数表存储在程序的只读数据段（.rodata section），这是因为虚函数表在编译时就已经确定，运行时不会修改。</p>
<h3 id="虚函数指针在什么时候创建？"><a href="#虚函数指针在什么时候创建？" class="headerlink" title="虚函数指针在什么时候创建？"></a>虚函数指针在什么时候创建？</h3><p>虚函数指针（vptr）的创建和初始化实际上发生在<strong>对象的构造阶段</strong>。当一个对象被创建时，编译器会在对象的内存布局中的特定位置（通常是对象内存布局的开始位置）插入一个指针，这个指针指向该对象所属类的虚函数表。这个过程是自动发生的，确保了对象能够通过虚函数指针访问到正确的虚函数表，从而实现多态性。</p>
<h2 id="8、继承相关"><a href="#8、继承相关" class="headerlink" title="8、继承相关"></a>8、继承相关</h2><h3 id="C-的菱形继承指什么？"><a href="#C-的菱形继承指什么？" class="headerlink" title="C++的菱形继承指什么？"></a>C++的菱形继承指什么？</h3><p>菱形继承指两个及以上的派生类继承自同一个基类，而另外又有一个类继承了这些派生类，导致最终生成的派生类中包含多个基类的子对象副本。</p>
<h2 id="9、STL相关"><a href="#9、STL相关" class="headerlink" title="9、STL相关"></a>9、STL相关</h2><h3 id="vector的扩容原理是怎样的？"><a href="#vector的扩容原理是怎样的？" class="headerlink" title="vector的扩容原理是怎样的？"></a>vector的扩容原理是怎样的？</h3><p>vector可以进行自动扩容，以容纳更多的元素。主要包含以下几步：</p>
<p>（1）确定新容量。根据平台的不同，有不同的扩容倍数。其中linux和gcc下为2倍，windows下为1.5倍。</p>
<p>（2）开辟内存空间。确定了新容量后，在堆上开辟一块新的连续内存空间。</p>
<p>（3）复制元素。通过拷贝构造或移动构造将现有元素从旧内存空间复制到新内存空间。</p>
<p>（4）释放旧内存。</p>
<p>（5）更新内部指针。在元素复制完成后，vector更新其内部数据结构，如指向元素数组的指针、大小和容量。</p>
<h3 id="vector、list和array的区别是什么？"><a href="#vector、list和array的区别是什么？" class="headerlink" title="vector、list和array的区别是什么？"></a>vector、list和array的区别是什么？</h3><p>（1）vector是动态数组，支持随机访问，内部使用连续的内存存储元素，在进行删除和插入操作时可能需要移动其他元素；</p>
<p>（2）list是双向链表，不支持随机访问，插入和删除的操作效率高，内存不连续，每个元素存储在独立的节点中；</p>
<p>（3）array是静态数组，大小固定，在编译时就确定，内存连续存储，且支持随机访问。</p>
<h3 id="C-map的实现（说了红黑树和哈希），如何考虑选择，为什么用红黑树？"><a href="#C-map的实现（说了红黑树和哈希），如何考虑选择，为什么用红黑树？" class="headerlink" title="C++map的实现（说了红黑树和哈希），如何考虑选择，为什么用红黑树？"></a>C++map的实现（说了红黑树和哈希），如何考虑选择，为什么用红黑树？</h3><h3 id="map和set保存的元素有什么区别？"><a href="#map和set保存的元素有什么区别？" class="headerlink" title="map和set保存的元素有什么区别？"></a>map和set保存的元素有什么区别？</h3><p>（1）map保存的是键值对元素，其中key是不能重复的，一旦重复将对value进行覆盖。只能通过key来访问value。</p>
<p>（2）set保存的元素是无序的，且元素也是不能重复的。只能通过迭代器遍历访问set。</p>
<h3 id="map的插入方式和访问方式有哪些？"><a href="#map的插入方式和访问方式有哪些？" class="headerlink" title="map的插入方式和访问方式有哪些？"></a>map的插入方式和访问方式有哪些？</h3><p>插入方式：</p>
<p>（1）operator []；（2）emplace()；（3）insert()</p>
<p>访问方式</p>
<p>（1）operator []；（2）使用at；（3）find()；（4）使用迭代器</p>
<h1 id="二、操作系统八股"><a href="#二、操作系统八股" class="headerlink" title="二、操作系统八股"></a>二、操作系统八股</h1><h2 id="1、线程与进程"><a href="#1、线程与进程" class="headerlink" title="1、线程与进程"></a>1、线程与进程</h2><h3 id="进程和线程以及并发和并行的概念是什么？"><a href="#进程和线程以及并发和并行的概念是什么？" class="headerlink" title="进程和线程以及并发和并行的概念是什么？"></a>进程和线程以及并发和并行的概念是什么？</h3><p>（1）线程是操作系统中的最小执行单元，进程是程序的一次执行过程，是系统资源分配的最小单位。并发是指多个任务交替执行，而并行是指多个任务同时执行。</p>
<p>（2）并发是在单个处理器上实现多个线程同时执行的假象，而并行是在多个处理器上实现多个线程同时执行。</p>
<h3 id="Linux的Fork怎么实现的？"><a href="#Linux的Fork怎么实现的？" class="headerlink" title="Linux的Fork怎么实现的？"></a>Linux的Fork怎么实现的？</h3><h3 id="线程中的锁包含哪些？"><a href="#线程中的锁包含哪些？" class="headerlink" title="线程中的锁包含哪些？"></a>线程中的锁包含哪些？</h3><p>（1）互斥锁：用于对共享资源的互斥访问。当有线程对该资源加了互斥锁后，其他线程尝试加锁时会被阻塞，直至锁被释放。</p>
<p>（2）递归锁：是一种特殊的互斥锁，当有同一个线程尝试对同一个线程不断加锁时，不会被阻塞。</p>
<p>（3）读写锁：允许多个线程同时进行读操作，但仅允许一个线程进行写操作，使用的读多于写的场景。</p>
<p>（4）自旋锁：当有线程对资源加了自旋锁后，其他线程尝试加锁时将忙等待，而非被阻塞。</p>
<h3 id="多线程怎么保证线程安全？"><a href="#多线程怎么保证线程安全？" class="headerlink" title="多线程怎么保证线程安全？"></a>多线程怎么保证线程安全？</h3><p>在语言层面，我一般会使用原子操作和互斥锁来确保多线程环境下的线程安全性。</p>
<h3 id="多线程环境下对变量的读写操作是否是原子的（提示CAS，说了概念），追问内部怎么实现的（不会）？"><a href="#多线程环境下对变量的读写操作是否是原子的（提示CAS，说了概念），追问内部怎么实现的（不会）？" class="headerlink" title="多线程环境下对变量的读写操作是否是原子的（提示CAS，说了概念），追问内部怎么实现的（不会）？"></a>多线程环境下对变量的读写操作是否是原子的（提示CAS，说了概念），追问内部怎么实现的（不会）？</h3><h3 id="如何实现一个线程池？"><a href="#如何实现一个线程池？" class="headerlink" title="如何实现一个线程池？"></a>如何实现一个线程池？</h3><p>线程池是一组预先创建好的线程，用于执行多个任务。它可以提高任务调度的效率和性能。</p>
<p>实现一个线程池可以使用 C++11 提供的 std::thread和 std::mutex 等多线程库，结合队列等数据结构来管理任务的提交和执行。</p>
<h3 id="遇到多线程同步问题有哪些机制？举例来说信号量如何实现？他们一般会调用到什么样的函数？如果想等待线程a执行完任务后再去执行b，这种情况要怎么处理？"><a href="#遇到多线程同步问题有哪些机制？举例来说信号量如何实现？他们一般会调用到什么样的函数？如果想等待线程a执行完任务后再去执行b，这种情况要怎么处理？" class="headerlink" title="遇到多线程同步问题有哪些机制？举例来说信号量如何实现？他们一般会调用到什么样的函数？如果想等待线程a执行完任务后再去执行b，这种情况要怎么处理？"></a>遇到多线程同步问题有哪些机制？举例来说信号量如何实现？他们一般会调用到什么样的函数？如果想等待线程a执行完任务后再去执行b，这种情况要怎么处理？</h3><p>在处理多线程同步问题时，常用的机制包括互斥锁（Mutex）、条件变量（Condition Variable）、信号量（Semaphore）等。下面简要介绍一下信号量的实现和处理方式，并举例说明如何使用。</p>
<p>（1）信号量（Semaphore）</p>
<p>信号量是一种用于多线程同步的机制，它可以用来控制对临界资源的访问。信号量维护了一个计数器，表示可用资源的数量，线程在访问临界资源之前必须先获取信号量，如果信号量计数器大于零，则线程可以获取资源并将计数器减一；如果计数器等于零，则线程将被阻塞，直到有其他线程释放资源并增加计数器。当线程使用完资源后，需要释放信号量，使计数器加一，以便其他线程可以继续访问资源。</p>
<p>（2）等待线程A执行完任务后再执行线程B的处理方式</p>
<p>在示例中，使用了条件变量 <code>std::condition_variable</code> 来等待线程A执行完任务后再执行线程B。线程A在等待条件时会调用 <code>cv.wait(lock, predicate)</code> 函数，其中 <code>predicate</code> 是一个lambda表达式，表示等待的条件。线程B在执行完任务后调用 <code>cv.notify_one()</code> 函数来发送信号给等待中的线程A，从而唤醒线程A并开始执行任务。</p>
<h3 id="多线程切换，cpu和内存会做一些什么处理"><a href="#多线程切换，cpu和内存会做一些什么处理" class="headerlink" title="多线程切换，cpu和内存会做一些什么处理"></a>多线程切换，cpu和内存会做一些什么处理</h3><p>在多线程环境下，当操作系统进行线程切换时，CPU 和内存会做一些处理：</p>
<ol>
<li><strong>保存当前线程的上下文：</strong> 当一个线程被抢占时，CPU 会保存当前线程的上下文信息，包括程序计数器（PC）、寄存器状态、栈指针（SP）等。这样做是为了在之后恢复线程时能够继续执行。</li>
<li><strong>加载下一个线程的上下文：</strong> CPU 根据调度算法选择下一个需要执行的线程，然后加载其上下文信息到寄存器和其他硬件状态中。</li>
<li><strong>切换内存空间：</strong> 在多线程环境下，不同线程可能会访问不同的内存区域。因此，在线程切换时，操作系统需要更新页表（Page Table）等内存映射表，以确保下一个线程能够访问到正确的内存空间。</li>
<li><strong>处理器流水线的清空和填充：</strong> 在 CPU 进行线程切换时，可能存在流水线（Pipeline）中的指令未执行完毕。在切换时，CPU 可能需要将流水线清空，以避免对新线程执行的指令产生影响。</li>
<li><strong>更新调度器信息：</strong> 操作系统需要更新线程的调度信息，包括线程的状态（就绪、运行、阻塞等），以及相关的时间片（Time Slice）等调度参数。</li>
</ol>
<h3 id="线程间的通信包括哪些方式？"><a href="#线程间的通信包括哪些方式？" class="headerlink" title="线程间的通信包括哪些方式？"></a>线程间的通信包括哪些方式？</h3><h3 id="什么是僵尸进程，僵尸进程太多对系统的影响"><a href="#什么是僵尸进程，僵尸进程太多对系统的影响" class="headerlink" title="什么是僵尸进程，僵尸进程太多对系统的影响"></a>什么是僵尸进程，僵尸进程太多对系统的影响</h3><h3 id="如何让进程后台运行？"><a href="#如何让进程后台运行？" class="headerlink" title="如何让进程后台运行？"></a>如何让进程后台运行？</h3><h3 id="进程间的通信包括哪些方式？"><a href="#进程间的通信包括哪些方式？" class="headerlink" title="进程间的通信包括哪些方式？"></a>进程间的通信包括哪些方式？</h3><p>（1）管道，半双工的通信方式，可以在父子进程间进行数据传递。通常用于具有亲缘关系的进程之间的通信。</p>
<p>（2）命名管道，与普通管道类似，但可以在无亲缘关系的进程之间使用。命名管道通过文件系统进行通信。</p>
<p>（3）消息队列，允许一个或多个进程向队列中发送消息，并从队列中接收消息。消息队列通常用于在不同进程之间传递结构化的数据。</p>
<p>（4）信号量，控制进程间访问共享资源的机制，可以用来解决进程同步和互斥的问题，防止竞态条件的发生。</p>
<p>（5）共享内存，允许多个进程共享同一块内存区域，进程可以直接读写共享内存中的数据。</p>
<p>（6）套接字，适用于在不同主机和不同进程之间进行通信，通常用于网络编程。</p>
<h3 id="哪个通信方式效率最高"><a href="#哪个通信方式效率最高" class="headerlink" title="哪个通信方式效率最高"></a>哪个通信方式效率最高</h3><h3 id="有名管道和无名管道的区别是什么？"><a href="#有名管道和无名管道的区别是什么？" class="headerlink" title="有名管道和无名管道的区别是什么？"></a>有名管道和无名管道的区别是什么？</h3><h3 id="信号和信号量是什么，信号量如何使用？"><a href="#信号和信号量是什么，信号量如何使用？" class="headerlink" title="信号和信号量是什么，信号量如何使用？"></a>信号和信号量是什么，信号量如何使用？</h3><h3 id="select、poll、epoll-的区别"><a href="#select、poll、epoll-的区别" class="headerlink" title="select、poll、epoll 的区别"></a>select、poll、epoll 的区别</h3><h3 id="协程了解吗，为什么比线程更轻量，协程堆栈是怎么管理的"><a href="#协程了解吗，为什么比线程更轻量，协程堆栈是怎么管理的" class="headerlink" title="协程了解吗，为什么比线程更轻量，协程堆栈是怎么管理的"></a>协程了解吗，为什么比线程更轻量，协程堆栈是怎么管理的</h3><h3 id="协程怎么实现并发的，怎么做系统I-O的"><a href="#协程怎么实现并发的，怎么做系统I-O的" class="headerlink" title="协程怎么实现并发的，怎么做系统I&#x2F;O的"></a>协程怎么实现并发的，怎么做系统I&#x2F;O的</h3><h2 id="2、虚拟内存-页相关"><a href="#2、虚拟内存-页相关" class="headerlink" title="2、虚拟内存&#x2F;页相关"></a>2、虚拟内存&#x2F;页相关</h2><h3 id="虚拟地址和物理地址怎么管理？"><a href="#虚拟地址和物理地址怎么管理？" class="headerlink" title="虚拟地址和物理地址怎么管理？"></a>虚拟地址和物理地址怎么管理？</h3><h3 id="页表是啥，页多大，为啥4KB？"><a href="#页表是啥，页多大，为啥4KB？" class="headerlink" title="页表是啥，页多大，为啥4KB？"></a>页表是啥，页多大，为啥4KB？</h3><h3 id="缺页中断什么时候发生？"><a href="#缺页中断什么时候发生？" class="headerlink" title="缺页中断什么时候发生？"></a>缺页中断什么时候发生？</h3><p>（1）当程序要访问的页面不在物理内存中时，会触发缺页中断。这通常发生在虚拟内存中，即当前只有部分的页面写入了物理内存。</p>
<p>（2）当程序尝试进行一个违反内存规则的操作时，也会触发缺页中断。比如，当程序试图对一个只读页面进行写操作，或是访问一个不允许被访问的页面。</p>
<h3 id="常见的缺页中断算法有哪些？"><a href="#常见的缺页中断算法有哪些？" class="headerlink" title="常见的缺页中断算法有哪些？"></a>常见的缺页中断算法有哪些？</h3><p>（1）LRU，最近最少使用。</p>
<p>（2）LFU，使用频率最低。</p>
<p>（3）FIFO，先进先出。</p>
<h3 id="malloc函数的底层实现是什么？"><a href="#malloc函数的底层实现是什么？" class="headerlink" title="malloc函数的底层实现是什么？"></a>malloc函数的底层实现是什么？</h3><p>（1）当开辟的空间小于128kb时，调用brk()函数，先遍历空闲内存链表，如果有已释放且空间足够的内存块就拿来用。如果找不到就移动指针_enddata，即堆区的末尾地址。</p>
<p>（2）当开辟的空间大于128kb时，系统调用mmap()函数来在虚拟地址中找一块空间来开辟，即堆和栈中间的文件映射区域。</p>
<p>malloc()在分配用户传入大小的内存时，还分配一个用于管理的额外内存，大小为8字节。而由于堆中的内存是成块分配的，与内存对齐有关，在64为系统中，内存对齐为16字节，因此<strong>实际分配的内存大小还要考虑8字节的管理内存和内存对齐</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mem_control_block</span> &#123;</span><br><span class="line">    <span class="type">int</span> is_available;      <span class="comment">// 1表可用，0表不可用</span></span><br><span class="line">    <span class="type">int</span> size;                 <span class="comment">// 总大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么-malloc-不全部使用-mmap-来实现呢-mmap分配的内存可以会通过-munmap-进行-free-，实现真正释放-？而是仅仅对于大于-128k-的大块内存才使用-mmap-？"><a href="#既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么-malloc-不全部使用-mmap-来实现呢-mmap分配的内存可以会通过-munmap-进行-free-，实现真正释放-？而是仅仅对于大于-128k-的大块内存才使用-mmap-？" class="headerlink" title="既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么 malloc 不全部使用 mmap 来实现呢(mmap分配的内存可以会通过 munmap 进行 free ，实现真正释放)？而是仅仅对于大于 128k 的大块内存才使用 mmap ？"></a>既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么 malloc 不全部使用 mmap 来实现呢(mmap分配的内存可以会通过 munmap 进行 free ，实现真正释放)？而是仅仅对于大于 128k 的大块内存才使用 mmap ？</h3><p>进程向 OS 申请和释放地址空间的接口 sbrk&#x2F;mmap&#x2F;munmap 都是系统调用，<strong>频繁调用系统调用都比较消耗系统资源的</strong>。并且， mmap 申请的内存被 munmap 后，重新申请会产生更多的缺页中断。例如使用 mmap 分配 1M 空间，第一次调用产生了大量缺页中断  (1M&#x2F;4K 次 ) ，当munmap 后再次分配 1M 空间，会再次产生大量缺页中断。<strong>缺页中断是内核行为，会导致内核态CPU消耗较大。  另外，如果使用 mmap 分配小内存，会导致地址空间的分片更多，内核的管理负担更大。</strong></p>
<p>同时堆是一个连续空间，并且堆内碎片由于没有归还 OS ，<strong>如果可重用碎片，再次访问该内存很可能不需产生任何系统调用和缺页中断，这将大大降低  CPU 的消耗。</strong> 因此， glibc 的 malloc 实现中，充分考虑了 sbrk 和 mmap 行为上的差异及优缺点，默认分配大块内存  (128k) 才使用 mmap 获得地址空间。</p>
<h2 id="3、编译程序相关"><a href="#3、编译程序相关" class="headerlink" title="3、编译程序相关"></a>3、编译程序相关</h2><h3 id="什么是内存泄漏，如何防止？"><a href="#什么是内存泄漏，如何防止？" class="headerlink" title="什么是内存泄漏，如何防止？"></a>什么是内存泄漏，如何防止？</h3><p>内存泄漏是发生在程序分配了堆内存但未释放，导致内存无法被再次使用。长时间的内存泄漏可能导致程序运行缓慢或异常终止。</p>
<p>主要有以下策略来防止内存泄漏：</p>
<p>（1）使用智能指针。这些智能指针利用RAII（Resource Acquisition Is Initialization）原则，确保资源（如动态分配的内存）在不再需要时能够被自动释放。</p>
<p>（2）手动管理内存。</p>
<p>（3）使用RAII原则。RAII是C++中的一种编程技术，通过将资源封装在对象中，并在对象的构造函数中分配资源，在析构函数中释放资源，可以确保资源总是被正确管理。</p>
<p>（4）使用内存泄漏检测工具。如Valgrind、AddressSanitizer等，可以帮助识别程序中的内存泄漏。</p>
<h3 id="从C-文件到可执行文件经过了哪几个阶段？"><a href="#从C-文件到可执行文件经过了哪几个阶段？" class="headerlink" title="从C++文件到可执行文件经过了哪几个阶段？"></a>从C++文件到可执行文件经过了哪几个阶段？</h3><p>预编译、编译、汇编、链接，最后生成可执行文件。</p>
<h3 id="为什么需要有链接的过程？"><a href="#为什么需要有链接的过程？" class="headerlink" title="为什么需要有链接的过程？"></a>为什么需要有链接的过程？</h3><p>因为软件开发的规模很大，不可能将它们都放在同一个模块中。因此按照层次化以及模块化的视线方法，将代码分成多个部分，每个部分分别开发。因此就需要在最后将它们组装起来，这就是链接的过程。通过链接，实现符号解析、地址分配和库依赖管理等工作。</p>
<h3 id="链接这个过程做了什么？"><a href="#链接这个过程做了什么？" class="headerlink" title="链接这个过程做了什么？"></a>链接这个过程做了什么？</h3><p>（1）符号解析。在目标文件和库中存在许多符号（如函数名或变量名等），需要在其他的目标文件或库中找到相应的定义，并将它们连接起来，使得程序在运行时可以找到正确的内存地址。</p>
<p>（2）地址分配。给目标文件和库分配内存地址，并确定其在程序中的内存布局。同时需要完成重定位的工作，用实际的内存地址去替换其中的地址引用。</p>
<p>（3）库依赖管理。链接器处理程序和库之间的依赖关系，确保所有库都被正确地包含在目标文件中。同时要处理库与库之间的依赖关系。</p>
<h3 id="假设有一个A-dll和B-dll，A-dll调用了B-dll的方法，A-dll是如何找到B-dll中的方法的？"><a href="#假设有一个A-dll和B-dll，A-dll调用了B-dll的方法，A-dll是如何找到B-dll中的方法的？" class="headerlink" title="假设有一个A.dll和B.dll，A.dll调用了B.dll的方法，A.dll是如何找到B.dll中的方法的？"></a>假设有一个A.dll和B.dll，A.dll调用了B.dll的方法，A.dll是如何找到B.dll中的方法的？</h3><p>在使用动态库时，链接器会将动态库的相关信息，包括动态库的名字、符号表以及可重定位信息存储到相应的可执行文件中。在可执行文件运行时，链接器会根据这些信息找到动态库是否存在、在哪里、符号引用的内存地址是哪里，也就是说找到A.dll引用的B.dll的相关方法，并通过重定位找到其物理内存地址。</p>
<h3 id="函数调用中堆和栈的变化情况是怎样的？"><a href="#函数调用中堆和栈的变化情况是怎样的？" class="headerlink" title="函数调用中堆和栈的变化情况是怎样的？"></a>函数调用中堆和栈的变化情况是怎样的？</h3><p>函数调用时主要影响的是栈（stack）的变化，而不直接影响堆（heap）的变化。</p>
<p>当一个函数被调用时，程序会在栈上为这个函数分配一个新的栈帧（Stack Frame）。栈帧通常包含以下内容：</p>
<ul>
<li><strong>函数的参数</strong>：按照函数定义，传递给函数的参数。</li>
<li><strong>返回地址</strong>：函数执行完毕后，程序计数器（PC）需要跳转回的地址。</li>
<li><strong>局部变量</strong>：函数内部定义的变量，它们的生命周期仅限于函数的执行期间。</li>
</ul>
<p>函数调用完成后，其栈帧会从栈上弹出，返回地址被用来恢复程序执行的下一条指令。</p>
<h2 id="4、Linux相关"><a href="#4、Linux相关" class="headerlink" title="4、Linux相关"></a>4、Linux相关</h2><h3 id="0、1、2的文件描述符是什么含义？指向什么类型的文件？"><a href="#0、1、2的文件描述符是什么含义？指向什么类型的文件？" class="headerlink" title="0、1、2的文件描述符是什么含义？指向什么类型的文件？"></a>0、1、2的文件描述符是什么含义？指向什么类型的文件？</h3><ol>
<li>文件描述符0（标准输入）：指向标准输入设备，通常是终端（键盘）。</li>
<li>文件描述符1（标准输出）：指向标准输出设备，通常是终端（屏幕）。</li>
<li>文件描述符2（标准错误）：指向标准错误设备，通常也是终端（屏幕）。</li>
</ol>
<h3 id="Linux如何切换目录、查看端口绑定情况以及查看CPU利用率命令"><a href="#Linux如何切换目录、查看端口绑定情况以及查看CPU利用率命令" class="headerlink" title="Linux如何切换目录、查看端口绑定情况以及查看CPU利用率命令"></a>Linux如何切换目录、查看端口绑定情况以及查看CPU利用率命令</h3><p>（1）切换目录：<code>cd</code></p>
<p>（2）查看端口绑定情况：<code>lsof -i : [端口号]</code>或<code>netstat -tuln</code>（列出所有监听端口）</p>
<p>（3）查看CPU利用率：<code>top</code>或<code>htop</code></p>
<h2 id="5、应用相关"><a href="#5、应用相关" class="headerlink" title="5、应用相关"></a>5、应用相关</h2><h3 id="什么是qps和tps，如何计算？"><a href="#什么是qps和tps，如何计算？" class="headerlink" title="什么是qps和tps，如何计算？"></a>什么是qps和tps，如何计算？</h3><p>（1）<strong>QPS（Queries Per Second）</strong>：每秒查询率，是衡量每秒能处理多少个查询请求的指标。它通常用于评估搜索引擎、数据库服务器和Web服务器的性能。QPS可以通过将总查询数除以时间（秒）来计算。</p>
<p>（2）<strong>TPS（Transactions Per Second）</strong>：每秒事务数，是衡量系统每秒能处理多少个事务的指标。一个事务是指一个完整的业务操作，可能包含多个查询和更新。TPS是数据库操作和商业应用（如在线支付平台）的常用性能指标。TPS的计算方法与QPS类似，将总事务数除以时间（秒）。</p>
<h3 id="CPU利用率拉满的时候在线程池中增加线程是否能提高qps？"><a href="#CPU利用率拉满的时候在线程池中增加线程是否能提高qps？" class="headerlink" title="CPU利用率拉满的时候在线程池中增加线程是否能提高qps？"></a>CPU利用率拉满的时候在线程池中增加线程是否能提高qps？</h3><p>（1）对于CPU密集型应用，CPU是性能瓶颈。如果CPU利用率已经达到100%，这意味着CPU资源已经被完全使用。在这种情况下，增加更多的线程实际上会导致线程之间的竞争更加激烈，因为更多的线程需要共享有限的CPU资源。这可能导致上下文切换增加，反而降低了程序的效率和QPS。</p>
<p>（2）对于IO密集型应用，主要的瓶颈在于IO操作，如磁盘读写或网络通信等。即使CPU利用率很高，增加线程数仍然可能提高QPS，因为当一部分线程在等待IO操作完成时，其他线程可以继续执行，从而提高整体的吞吐量。在这种情况下，增加线程数可以有效利用CPU在等待IO时的空闲周期，提高QPS。</p>
<p>（3）混合型应用同时包含CPU密集型和IO密集型的操作。在这种情况下，是否增加线程以提高QPS取决于应用中CPU密集型和IO密集型操作的比例。如果IO操作占主导，增加线程可能有助于提高QPS；但如果CPU密集型操作占主导，增加线程可能不会带来预期的效果，甚至可能因为线程竞争导致性能下降。</p>
<h3 id="什么是CPU密集型应用和IO密集型应用？"><a href="#什么是CPU密集型应用和IO密集型应用？" class="headerlink" title="什么是CPU密集型应用和IO密集型应用？"></a>什么是CPU密集型应用和IO密集型应用？</h3><p>（1）CPU密集型应用是指那些需要进行大量计算，消耗大量CPU资源的应用。这类应用的特点是CPU使用率很高，因为它们主要进行数学计算、逻辑判断或者数据处理等操作，这些操作需要大量的CPU周期来完成。CPU密集型应用的性能很大程度上依赖于CPU的处理能力。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>科学计算软件</li>
<li>图像处理和视频编码</li>
<li>大数据处理应用</li>
<li>游戏服务器的游戏逻辑处理</li>
<li>加密和解密操作</li>
</ul>
<p>（2）IO密集型应用是指那些主要时间花费在输入输出操作上，而不是CPU计算上的应用。这类应用的特点是频繁地进行磁盘操作或网络通信，CPU使用率不高，但是需要等待IO操作的完成，因此对IO性能的依赖很高。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>Web服务器</li>
<li>数据库服务器</li>
<li>文件服务器</li>
<li>客户端&#x2F;服务器应用</li>
<li>大规模日志处理系统</li>
</ul>
<h1 id="三、计算机网络八股"><a href="#三、计算机网络八股" class="headerlink" title="三、计算机网络八股"></a>三、计算机网络八股</h1><h2 id="1、网络层"><a href="#1、网络层" class="headerlink" title="1、网络层"></a>1、网络层</h2><h3 id="什么是ICMP？"><a href="#什么是ICMP？" class="headerlink" title="什么是ICMP？"></a>什么是ICMP？</h3><p>ICMP是TCP&#x2F;IP协议族中网络层的协议，通过传输网络层控制消息的协议来实现网络诊断，以及发送错误报告的目的。<br>如ping&#x2F;traceout就是通过icmp来诊断网络质量以及追踪数据包在网络中的传输路径来达到网络诊断的目的。</p>
<h2 id="2、TCP和UD"><a href="#2、TCP和UD" class="headerlink" title="2、TCP和UD"></a>2、TCP和UD</h2><h3 id="什么是TCP粘包？"><a href="#什么是TCP粘包？" class="headerlink" title="什么是TCP粘包？"></a>什么是TCP粘包？</h3><p>TCP粘包是指在使用TCP协议传输数据时，发送方发送的多个数据包被接收方一次性接收。这是由于TCP发送的数据是以字节流为单位的，无法确定消数据边界。</p>
<h3 id="如何解决TCP粘包？"><a href="#如何解决TCP粘包？" class="headerlink" title="如何解决TCP粘包？"></a>如何解决TCP粘包？</h3><p>（1）添加数据边界，在数据中添加一个一个特定边界标识<br>（2）发送定长数据，不满足定长的数据用特定字符填充<br>（3）添加消息头<br>（4）使用应用层协议，如HTTP&#x2F;FTP协议都已经针对粘包问题进行了处理</p>
<h3 id="UDP会发生粘包吗？"><a href="#UDP会发生粘包吗？" class="headerlink" title="UDP会发生粘包吗？"></a>UDP会发生粘包吗？</h3><p>不会，因为UDP数据报格式的协议，发送时的数据报是独立的，因此有明确的边界。</p>
<h3 id="UDP为什么会发生乱序问题？"><a href="#UDP为什么会发生乱序问题？" class="headerlink" title="UDP为什么会发生乱序问题？"></a>UDP为什么会发生乱序问题？</h3><p>UDP不像TCP，存在滑动窗、序列号、确认序列和超时重传机制。因此由于存在网络抖动问题，接收方接收到的UDP数据报可能是乱序的，需要自行处理。</p>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p>TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种常见的传输层协议，它们在网络通信中有以下几点区别：</p>
<ol>
<li><strong>连接性：</strong>TCP 是面向连接的协议；UDP 是无连接的协议</li>
<li><strong>可靠性：</strong><ul>
<li>TCP 提供可靠的数据传输，保证数据的完整性和顺序性，通过确认应答机制和重传机制来确保数据的可靠传输。</li>
<li>UDP 不提供可靠的数据传输，数据包可能会丢失、重复或者乱序，不保证数据的可靠性和顺序性。</li>
</ul>
</li>
<li><strong>传输效率：</strong><ul>
<li>TCP 的数据传输效率相对较低</li>
<li>UDP 的数据传输效率相对较高，适用于实时性要求较高的应用场景。</li>
</ul>
</li>
<li><strong>应用场景：</strong><ul>
<li>TCP 可进行网页浏览、文件传输、电子邮件等。</li>
<li>UDP 适用于实时性要求较高、对数据可靠性要求不高的应用，如音视频传输、在线游戏、DNS 查询等。</li>
</ul>
</li>
<li><strong>头部开销：</strong><ul>
<li>TCP 头部开销较大，包含了序列号、确认号、窗口大小等字段，用于实现可靠传输和流量控制。</li>
<li>UDP 头部开销较小，只包含了源端口、目标端口、长度和校验和字段，不包含额外的控制信息。</li>
</ul>
</li>
</ol>
<h3 id="UDP报文的最大报文限制（说错了，应该是DNS中UDP限制512字节）？"><a href="#UDP报文的最大报文限制（说错了，应该是DNS中UDP限制512字节）？" class="headerlink" title="UDP报文的最大报文限制（说错了，应该是DNS中UDP限制512字节）？"></a>UDP报文的最大报文限制（说错了，应该是DNS中UDP限制512字节）？</h3><h2 id="3、TCP三次握手"><a href="#3、TCP三次握手" class="headerlink" title="3、TCP三次握手"></a>3、TCP三次握手</h2><h3 id="详细说明三次握手"><a href="#详细说明三次握手" class="headerlink" title="详细说明三次握手"></a>详细说明三次握手</h3><ol>
<li><p>TCP服务器进程创建传输控制块，用来存储TCP连接中的一些重要信息，并进入监听状态，等待TCP客户端进程的连接请求</p>
</li>
<li><p>TCP客户进程也是首先创建传输控制块</p>
</li>
<li><p>TCP客户进程向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态。</p>
</li>
<li><p>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态。</p>
</li>
<li><p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态。</p>
</li>
<li><p>TCP服务器进程收到该确认报文段后也进入连接已建立状态。</p>
</li>
</ol>
<h3 id="为什么不能两次握手？"><a href="#为什么不能两次握手？" class="headerlink" title="为什么不能两次握手？"></a>为什么不能两次握手？</h3><p>不采用两次握手主要是为了<strong>防止已经失效的连接请求报文段突然又传到服务端</strong>，因而产生错误。</p>
<p>这种情况是：<strong>客户端发出的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到下一个连接释放以后的某个时间才到达服务器端。</strong>当服务器端收到此失效报文后，会误认为是客户端发出的一个新连接请求，于是客户端又发出确认报文，表示同意建立连接。</p>
<p>如果不采用“三次握手”，那么只要服务器端发出确认报文就会认为新的连接已经建立了，但此时客户端并没有发出建立连接的请求，因此不会向服务器端发送数据。服务器端没有收到数据就会一直等待，这样就会白白浪费掉很多资源。</p>
<p>所以必须采用“三次握手”而非“两次握手”。</p>
<h3 id="TCP三次握手的过程中可以携带数据吗"><a href="#TCP三次握手的过程中可以携带数据吗" class="headerlink" title="TCP三次握手的过程中可以携带数据吗"></a>TCP三次握手的过程中可以携带数据吗</h3><p>第三次握手的时候可以携带数据，第一次和第二次握手不可以。</p>
<h3 id="TCP挥手过程中，为什么存在一个time-wait状态？"><a href="#TCP挥手过程中，为什么存在一个time-wait状态？" class="headerlink" title="TCP挥手过程中，为什么存在一个time_wait状态？"></a>TCP挥手过程中，为什么存在一个time_wait状态？</h3><p>（1）防止错误接收报文。如果立刻断掉连接，那么当客户端复位ip地址和端口号重新建立连接时，可能会收到上一个连接发送过来的历史报文，而当前建立的新连接无法判断这个报文是否为历史报文，因此会出现错误。</p>
<p>（2）确保双方正常关闭。当客户端发送ACK报文给服务器端时，若该报文丢失，需要等待服务器端重新发送一个FIN报文给客户端，这个等待的时间最大为2MSL，因此需要一个time_wait状态来让客户端等到是否再次接受到一个FIN报文。</p>
<h3 id="什么情况下会出现大量time-wait状态？如何优化？"><a href="#什么情况下会出现大量time-wait状态？如何优化？" class="headerlink" title="什么情况下会出现大量time_wait状态？如何优化？"></a>什么情况下会出现大量time_wait状态？如何优化？</h3><p>在以下两种场景会出现大量time_wait状态：</p>
<p>（1）高并发场景下。此时存在大量的客户端和服务器端建立连接，因此在断开连接时就会出现大量的time_wait状态。</p>
<p>（2）短连接场景下。短连接场景下的TCP连接生命周期较短，很快就会断开连接，就导致出现大量的time_wait状态。</p>
<p>可以通过下列方式进行优化：</p>
<p>（1）缩短MSL的时间。</p>
<p>（2）建立连接池。在客户端和服务器端中间建立连接池，这样就可以复用已经建立的的TCP连接。</p>
<p>（3）在服务器端开启SO_REUSEADDR套接字，这样可以使得服务器端在time_wait状态时就可以重新绑定并监听端口号。</p>
<p>（4）在客户端开启SO_LINGER套接字，并将延迟设置为0。这样当断开连接时，客户端会直接发送一个RST信号，不再进行四次挥手，从而避免进入time_wait状态。</p>
<h2 id="4、TCP四次挥手"><a href="#4、TCP四次挥手" class="headerlink" title="4、TCP四次挥手"></a>4、TCP四次挥手</h2><h3 id="详细说明四次挥手"><a href="#详细说明四次挥手" class="headerlink" title="详细说明四次挥手"></a>详细说明四次挥手</h3><ol>
<li>当客户端和服务器端都处于连接已建立状态时，若要释放连接，客户进程会发送TCP连接释放报文段，并进入终止等待状态。</li>
<li>服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态。</li>
<li>此时，从客户进程到服务器进程这个方向的连接就释放了，这时的TCP连接属于半关闭状态，也就是客户进程已经没有数据要发送了。但如果服务器进程还有数据要发送，客户进程仍要接收，也就是说从服务器进程到客户进程这个方向的连接并未关闭。</li>
<li>客户进程收到TCP确认报文段后就进入终止等待状态，等待服务器进程发出的TCP连接释放报文段。若服务器进程已经没有数据要发送了，服务器进程即释放连接。由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接。</li>
<li>服务器进程发送TCP连接释放报文段并进入最后确认状态。</li>
<li>客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态。服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要经过2MSL后才能进入关闭状态。</li>
</ol>
<h3 id="为什么不能三次挥手？"><a href="#为什么不能三次挥手？" class="headerlink" title="为什么不能三次挥手？"></a>为什么不能三次挥手？</h3><p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。</p>
<p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段。</p>
<h2 id="5、TCP可靠传输"><a href="#5、TCP可靠传输" class="headerlink" title="5、TCP可靠传输"></a>5、TCP可靠传输</h2><h3 id="流量控制和拥塞控制"><a href="#流量控制和拥塞控制" class="headerlink" title="流量控制和拥塞控制"></a>流量控制和拥塞控制</h3><p>流量控制和拥塞控制都是网络通信中用于控制数据传输的机制，但它们针对的对象和目的略有不同。</p>
<p>（1）流量控制（Flow Control）</p>
<p>流量控制是指在数据传输过程中，接收方通过一定的方式告诉发送方自己的接收能力，以控制发送方的发送速率，防止发送方发送过多的数据导致接收方无法及时处理。流量控制通常发生在端到端之间，其主要目的是保护接收方不被发送方的数据压倒。</p>
<p>常见的流量控制机制包括<strong>滑动窗口协议（如TCP的滑动窗口机制）和通告窗口大小（advertised window size）</strong>等。接收方通过不断调整通告窗口大小来告诉发送方自己的接收能力，从而控制发送方的发送速率。</p>
<p>（2）拥塞控制（Congestion Control）</p>
<p>拥塞控制是指在网络中避免过多的数据包拥塞在网络节点或链路上，从而影响网络性能和吞吐量的机制。拥塞控制通常发生在网络中，其主要目的是保护网络免受过载和崩溃。</p>
<p>拥塞控制通过监控网络的拥塞程度，并采取一系列措施来降低数据包的发送速率，从而避免网络拥塞。常见的拥塞控制算法包括<strong>拥塞窗口控制、慢启动、拥塞避免、快速重传、快速恢复</strong>等。这些算法通过动态调整数据包的发送速率，以适应网络的负载情况，从而确保网络的稳定性和性能。</p>
<h3 id="TCP可靠传输的⼏种机制"><a href="#TCP可靠传输的⼏种机制" class="headerlink" title="TCP可靠传输的⼏种机制"></a>TCP可靠传输的⼏种机制</h3><p>TCP（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层协议。它采用了多种机制来保证数据的可靠传输，以下是几种常见的机制：</p>
<ol>
<li><strong>序列号和确认应答：</strong> TCP 使用序列号和确认应答机制来确保数据的可靠传输。发送方将每个数据包都标记上序列号，并等待接收方发送确认应答。接收方收到数据后，会发送确认应答，告诉发送方已成功接收到数据，如果发送方在一定时间内没有收到确认应答，则会重新发送数据。</li>
<li><strong>超时重传：</strong> TCP 采用超时重传机制来处理丢失的数据包。如果发送方在一定时间内没有收到确认应答，则会认为数据包丢失，会重新发送该数据包。</li>
<li><strong>滑动窗口：</strong> TCP 使用滑动窗口机制来进行流量控制和拥塞控制。滑动窗口指定了发送方可以发送的数据量，接收方通过发送窗口大小来告知发送方自己的接收能力。发送方根据接收窗口的大小来控制发送速率，以避免发送过多的数据导致接收方无法及时处理。</li>
<li><strong>累积确认：</strong> TCP 使用累积确认机制来确认已成功接收的数据。接收方发送的确认应答中包含了已成功接收的数据的最大序列号，发送方根据该确认号来确认哪些数据已经被成功接收。</li>
<li><strong>拥塞控制算法：</strong> TCP 使用拥塞控制算法来避免网络拥塞和过载。常见的拥塞控制算法包括慢启动、拥塞避免、快速重传和快速恢复等，通过动态调整发送窗口大小和数据包的发送速率来适应网络的负载情况，从而确保网络的稳定性和性能。</li>
</ol>
<h2 id="6、应用层"><a href="#6、应用层" class="headerlink" title="6、应用层"></a>6、应用层</h2><h3 id="打开一个网址，发生了什么，HTTP报文怎么发送Server的（提示路由，不会）"><a href="#打开一个网址，发生了什么，HTTP报文怎么发送Server的（提示路由，不会）" class="headerlink" title="打开一个网址，发生了什么，HTTP报文怎么发送Server的（提示路由，不会）?"></a>打开一个网址，发生了什么，HTTP报文怎么发送Server的（提示路由，不会）?</h3><h3 id="HTTP的状态码有哪些？"><a href="#HTTP的状态码有哪些？" class="headerlink" title="HTTP的状态码有哪些？"></a>HTTP的状态码有哪些？</h3><h3 id="HTTPS和HTTP的区别是什么？"><a href="#HTTPS和HTTP的区别是什么？" class="headerlink" title="HTTPS和HTTP的区别是什么？"></a>HTTPS和HTTP的区别是什么？</h3><h3 id="HTTPS是如何进行加密的？"><a href="#HTTPS是如何进行加密的？" class="headerlink" title="HTTPS是如何进行加密的？"></a>HTTPS是如何进行加密的？</h3><p>HTTPS（HyperText Transfer Protocol Secure）是一种基于HTTP协议和SSL&#x2F;TLS协议的安全传输协议，它通过使用加密技术来保护通信数据的安全性和完整性。下面是HTTPS进行加密的基本流程：</p>
<ol>
<li><strong>建立SSL&#x2F;TLS连接：</strong> 客户端与服务器之间首先建立SSL&#x2F;TLS连接，这个过程通常称为SSL&#x2F;TLS握手。在握手过程中，客户端和服务器协商使用的加密算法、密钥长度和其他参数，同时进行身份验证。</li>
<li><strong>进行证书交换：</strong> 在握手过程中，服务器会向客户端发送数字证书，用于证明服务器的身份。数字证书包含了服务器的公钥以及与证书相关的信息，如证书颁发者、有效期等。</li>
<li><strong>验证证书：</strong> 客户端收到服务器的证书后，会对证书进行验证。这个过程通常包括检查证书的有效性、签发者的可信度、证书是否过期等。如果证书验证通过，则客户端继续握手过程；否则，可能会发出警告或中止连接。</li>
<li><strong>生成会话密钥：</strong> 一旦证书验证通过，客户端会生成一个用于对通信数据进行加密和解密的会话密钥（Session Key）。通常情况下，客户端使用服务器的公钥来加密这个会话密钥，并发送给服务器。</li>
<li><strong>加密通信：</strong> 一旦服务器收到客户端发送的加密的会话密钥，服务器使用自己的私钥解密会话密钥。此后，客户端和服务器之间的通信就使用这个会话密钥来进行对称加密和解密了。这意味着通信数据在传输过程中是加密的，保护了数据的机密性和完整性。</li>
</ol>
<h3 id="对称加密和非对称加密的区别，哈希散列算不算加密算法"><a href="#对称加密和非对称加密的区别，哈希散列算不算加密算法" class="headerlink" title="对称加密和非对称加密的区别，哈希散列算不算加密算法"></a>对称加密和非对称加密的区别，哈希散列算不算加密算法</h3><h3 id="HTTPS的端口？其证书是怎么验证的？"><a href="#HTTPS的端口？其证书是怎么验证的？" class="headerlink" title="HTTPS的端口？其证书是怎么验证的？"></a>HTTPS的端口？其证书是怎么验证的？</h3><h3 id="OKHttp的原理、功能，以及在哪些地方应用，做了哪些优化"><a href="#OKHttp的原理、功能，以及在哪些地方应用，做了哪些优化" class="headerlink" title="OKHttp的原理、功能，以及在哪些地方应用，做了哪些优化"></a>OKHttp的原理、功能，以及在哪些地方应用，做了哪些优化</h3><h3 id="大量网络请求，怎么优化（不会，应该是在客户端做离散化处理）？"><a href="#大量网络请求，怎么优化（不会，应该是在客户端做离散化处理）？" class="headerlink" title="大量网络请求，怎么优化（不会，应该是在客户端做离散化处理）？"></a>大量网络请求，怎么优化（不会，应该是在客户端做离散化处理）？</h3>]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>cmu15-445 Course Related (Spring 2023)</title>
    <url>/2024/03/02/Project/cmu15-445/cmu15-445%20Course%20Related%20(Spring%202023)/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>PPT</th>
<th>Project</th>
<th>Date</th>
</tr>
</thead>
<tbody><tr>
<td>1-5</td>
<td>P0 &amp; P1</td>
<td>2.26-3.24</td>
</tr>
<tr>
<td>6-9</td>
<td>P2</td>
<td>3.24-</td>
</tr>
<tr>
<td>10-14</td>
<td>P3</td>
<td></td>
</tr>
<tr>
<td>15-21</td>
<td>P4</td>
<td></td>
</tr>
</tbody></table>
<p><code>DBMS</code>的磁盘管理模块主要解决两个问题：</p>
<ul>
<li>如何使用磁盘文件来表示数据库的数据（元数据、索引、数据表等）；</li>
<li>（<code>Buffer Pool</code>）如何管理数据在内存与磁盘之间的移动<ul>
<li>空间控制（<code>Spatio Control</code>）：决定将<code>pages</code>写入磁盘的哪个位置，使得尝尝一起使用的<code>pages</code>能离得更近，提高<code>I/O</code>效率；</li>
<li>时间控制（<code>Temporal Control</code>）：决定何时将<code>pages</code>读入内存，写回磁盘，使得读写的次数最小，从而提高<code>I/O</code>效率。</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p>整体图片：</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-LZUa28zEosfmp4uFA77%2F-LZUJRryGLyHUdcOnhD0%2FScreen%20Shot%202019-02-24%20at%207.43.51%20PM.jpg?alt=media&token=5ca91d06-1e09-43be-afd2-5a52918ad9c9" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242055708.png" alt="image-20240324205507545"></p>
<h1 id="1-Buffer-Pool"><a href="#1-Buffer-Pool" class="headerlink" title="1 Buffer Pool"></a>1 Buffer Pool</h1><h2 id="1-1-Buffer-Pool-Manager"><a href="#1-1-Buffer-Pool-Manager" class="headerlink" title="1.1 Buffer Pool Manager"></a>1.1 Buffer Pool Manager</h2><p><code>DBMS</code>启动时，从<code>OS</code>申请一片<strong>内存区域</strong>，即<code>Buffer Pool</code>，并把这块区域划分成大小相同的<code>pages</code>，通常称为 <code>frames</code>，当<code>DBMS</code>请求一个<code>disk page</code>时，它首先需要被复制到<code>Buffer Pool</code>的一个<code>frame</code>中。</p>
<p><code>Page Table</code>中存储的<code>meta-data</code>包括：</p>
<ul>
<li><p><code>page_table</code>：内存中的哈希表，跟踪当前在内存中的页面；</p>
</li>
<li><p><code>dirty flag</code>：当线程修改页面时设置（需要回写）；</p>
</li>
<li><p><code>pin count</code>：在有线程<strong>读页面</strong>时加<code>1</code>。</p>
</li>
</ul>
<p>当有线程需要**写<code>Page Table</code>**时，需要加一个<code>latch</code>。</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-LZUa28zEosfmp4uFA77%2F-LZUP5rlT7qWNo8qYSuD%2FScreen%20Shot%202019-02-24%20at%208.08.44%20PM.jpg?alt=media&token=f492f425-12b9-47bc-af9a-b4e2430e12bf" alt="img"></p>
<h3 id="locks和latches"><a href="#locks和latches" class="headerlink" title="locks和latches"></a>locks和latches</h3><p><code>Locks</code>（逻辑上的）</p>
<ul>
<li>保护<strong>数据库逻辑内容</strong>免受其他事务的影响</li>
<li>持有直到事务结束</li>
<li><strong>需要支持回滚</strong>（回滚即回到之前的版本状态）</li>
<li>保护元组（行），表，索引</li>
</ul>
<p><code>Latches/Mutex</code>（偏底层的）</p>
<ul>
<li>保护**<code>DBMS</code>内部数据结构**的关键部分不受其他线程的影响</li>
<li>持有直到一个操作结束</li>
<li><strong>不需要支持回滚</strong></li>
</ul>
<h3 id="scan-sharing"><a href="#scan-sharing" class="headerlink" title="scan sharing"></a>scan sharing</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403021705443.png" alt="image-20240302170551246" style="zoom:33%;" />

<p>图中的查询语句可能会导致<code>Q2</code>得不到自己真实想要的结果，需要加上<code>ORDER BY</code>限制才行。</p>
<p>假如有<code>Page0-Page199</code>，<code>scan sharing</code>可能导致：</p>
<ul>
<li><code>Q1</code>-&gt;<code>Page0-Page99</code></li>
<li><code>Q2</code>-&gt;<code>Page40-Page139</code></li>
</ul>
<h3 id="buffer-pool-bypass"><a href="#buffer-pool-bypass" class="headerlink" title="buffer pool bypass"></a>buffer pool bypass</h3><p>只需要调用一次的<code>page</code>，用完后直接丢弃，则可以不放入<code>buffer pool</code>。</p>
<h2 id="1-2-Buffer-Replacement-Policies"><a href="#1-2-Buffer-Replacement-Policies" class="headerlink" title="1.2 Buffer Replacement Policies"></a>1.2 Buffer Replacement Policies</h2><p>当<code>Buffer Pool</code>空间不足时，选择移除其中的哪些<code>pages</code>的问题。</p>
<h3 id="Least-Recently-Used-LRU"><a href="#Least-Recently-Used-LRU" class="headerlink" title="Least-Recently Used(LRU)"></a>Least-Recently Used(LRU)</h3><p><code>LRU</code>维护每个<code>page</code>上一次被访问的时间戳，每次移除时间戳最早的<code>page</code>。</p>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p><code>LRU</code>的近似实现。快速的<code>LRU</code>实现。</p>
<blockquote>
<p>但<code>LRU</code>和<code>Clock</code>容易被<code>sequential flooding</code>现象影响，从而导致最近被访问的<code>page</code>实际上却是最不可能需要的<code>page</code>。<strong>比如在全表扫描时，刚被访问的<code>page</code>实际上再访问完成后就不再需要了，因此反而成为了最不需要的<code>page</code>。</strong></p>
<p>为了解决这个问题，提出了<code>LRU-K</code>策略。</p>
</blockquote>
<h3 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h3><p><code>LRU-K</code>保存每个<code>page</code>的最后<code>K</code>次访问时间戳，利用这些时间戳来估计它们下次被访问的时间，通常<code>K</code>取<code>1</code>就能获得很好的效果。</p>
<p><strong>时间局部性原理：程序最近访问的地址在不久的将来很可能再次被访问。</strong></p>
<p><code>K</code>指的是最后第<code>K</code>次访问的距离，也就是倒数第<code>K</code>次访问时和最近一次访问的时间差。<code>LRU-K</code>算法主要是对比最后第<code>K</code>次的访问距离，访问距离越大则代表每次的访问间隔越长，因此更容易被替换出<code>cahce</code>。</p>
<ul>
<li><code>Correlated References Period</code>：指的是块首次访问后的一段时间。在这段时间以内的多次访问不会被记录，只有这段时间过后再次访问才会被记录。</li>
<li><code>Reference Retained Information Period</code>：指的是块被替换出<code>cache</code>后的一段时间。为了避免块被替换出<code>cache</code>后短时间内被反复重新访问、替换，因此对于替换出<code>cache</code>后的块会继续保留访问信息一段时间。</li>
</ul>
<h3 id="Dirty-Page"><a href="#Dirty-Page" class="headerlink" title="Dirty Page"></a>Dirty Page</h3><p><code>Dirty</code>：内存中的<code>page</code>和磁盘中的<code>page</code>有差别。</p>
<ul>
<li><p><code>FAST</code>：如果缓冲池中的页面不脏，那么<code>DBMS</code>可以简单地“删除”它；</p>
</li>
<li><p><code>SLOW</code>：如果页面是脏的，则<code>DBMS</code>必须写回磁盘以确保其更改是持久的。</p>
</li>
</ul>
<p><a href="https://www.jianshu.com/p/f242bc1e95ff">MySQL的WAL（Write-Ahead Logging）机制</a></p>
<h2 id="1-3-Other-Memory-Pools"><a href="#1-3-Other-Memory-Pools" class="headerlink" title="1.3 Other Memory Pools"></a>1.3 Other Memory Pools</h2><p>除了存储<code>tuples</code>和<code>indexes</code>，<code>DBMS</code>还需要<code>Memory Pools</code>来存储其它数据：</p>
<ul>
<li><code>Sorting + Join Buffers</code></li>
<li><code>Query Caches</code></li>
<li><code>Maintenance Buffers</code></li>
<li><code>Log Buffers</code></li>
<li><code>Dictionary Caches</code></li>
</ul>
<h1 id="2-B-Tree-Index"><a href="#2-B-Tree-Index" class="headerlink" title="2 B+Tree Index"></a>2 B+Tree Index</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271651204.png" alt="image-20240327165111130"></p>
<h2 id="2-1-Hash-Tables"><a href="#2-1-Hash-Tables" class="headerlink" title="2.1 Hash Tables"></a>2.1 Hash Tables</h2><h3 id="2-1-1-Hash-Functions"><a href="#2-1-1-Hash-Functions" class="headerlink" title="2.1.1 Hash Functions"></a>2.1.1 Hash Functions</h3><p>由于<code>DBMS</code>内使用的<code>Hash Function</code>并不会暴露在外，因此<strong>没必要使用加密（<code>cryptographic</code>）哈希函数</strong>，我们希望它速度越快，<code>collision rate</code>越低越好。</p>
<p>目前各 DBMS 主要在用的 Hash Functions 包括：</p>
<ul>
<li><a href="https://github.com/aappleby/smhasher">MurmurHash (2008)</a></li>
<li><a href="https://github.com/google/cityhash">Google CityHash (2011)</a></li>
<li><a href="https://github.com/google/farmhash">Google FarmHash (2014)</a></li>
<li><a href="https://github.com/lemire/clhash">CLHash (2016)</a></li>
</ul>
<h4 id="SHA256算法"><a href="#SHA256算法" class="headerlink" title="SHA256算法"></a>SHA256算法</h4><h3 id="2-1-2-Static-Hashing-Scheme"><a href="#2-1-2-Static-Hashing-Scheme" class="headerlink" title="2.1.2 Static Hashing Scheme"></a>2.1.2 Static Hashing Scheme</h3><p>（1）Linear Probe Hashing 开放地址哈希</p>
<p>“开放”的意思就是说：对于所有的key来说地址是开放的。碰撞时则往下一个地址存。</p>
<p>在删除时可能会因为前项被删除导致的空白，造成找不到当前项，这时有两个解决思路：</p>
<ul>
<li>Tombstone；</li>
<li>Movement</li>
</ul>
<p>重复key出现时的解决思路：</p>
<ul>
<li>Separate Linked List，把当前key作为指针指向一个新的区域：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242120365.png" alt="image-20240324212003301"></p>
<ul>
<li>Redundant Keys，把key和value拼在一起作为新的key：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242120828.png" alt="image-20240324212049757"></p>
<p>（2）Robin Hood Hashing，是开放地址哈希的变种，其基本思想是“劫富济贫”。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242123712.png" alt="image-20240324212329536"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242123232.png" alt="image-20240324212342001"></p>
<p>简单来说就是，当E和A碰撞时，正常E偏移3位，但为了不让自己比D“惨”太多，它就把D推到后面去，自己占了D的位置。此时D和E均为2。</p>
<p>（3）Cuckoo Hashing</p>
<blockquote>
<p>静态的哈希结构的问题在于需要DBMS能够预判所存数据的总量，否则每次数量超过范围时都需要重建 Hash Table。这显然是很困难的。</p>
</blockquote>
<h3 id="2-1-3-Dynamic-Hash-Tables"><a href="#2-1-3-Dynamic-Hash-Tables" class="headerlink" title="2.1.3 Dynamic Hash Tables"></a>2.1.3 Dynamic Hash Tables</h3><p>（1）Chained Hashing（※）</p>
<p>每个 key 对应一个链表，每个节点是一个 bucket，装满了就再往后挂一个 bucket。需要写操作时，需要请求 latch。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242129786.png" alt="image-20240324212955629"></p>
<ul>
<li>好处：简单；</li>
<li>坏处：最坏的情况下Hash Table可能降级为链表，操作的时间复杂度降格为 O(n)。</li>
</ul>
<p>（2）Extendible Hashing</p>
<p>Extendible Hashing 的基本思路是一边扩容，一边 rehash。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242134200.png" alt="image-20240324213443953"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242134195.png" alt="image-20240324213451869"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242134845.png" alt="image-20240324213459513"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242135620.png" alt="image-20240324213509210"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242135275.png" alt="image-20240324213516681"></p>
<p>（3）Linear Hashing</p>
<p>基本思想：维护一个指针，指向下一个将被拆分的 bucket，每当任意一个 bucket 溢出（标准自定，如利用率到达阈值等）时，将指针指向的 bucket 拆分。</p>
<h3 id="2-1-4-总结"><a href="#2-1-4-总结" class="headerlink" title="2.1.4 总结"></a>2.1.4 总结</h3><p>Hash Tables 提供 O(1)O(1) 的访问效率，因此它被大量地应用于 DBMS 的内部实现中。即便如此，它并不适合作为 table index 的数据结构，而 table index 的首选就是下节将介绍的 B+ Tree。</p>
<p><strong>哈希表对于范围索引是效率极低的。</strong></p>
<h2 id="2-2-Tree-Indexes（B-索引）"><a href="#2-2-Tree-Indexes（B-索引）" class="headerlink" title="2.2 Tree Indexes（B+索引）"></a>2.2 Tree Indexes（B+索引）</h2><blockquote>
<p>table index 为提供 DBMS 数据查询的快速索引，它本身存储着某表某列排序后的数据，并包含指向相应 tuple 的指针。DBMS 需要保证表信息与索引信息在逻辑上保持同步。用户可以在 DBMS 中为任意表建立多个索引，DBMS 负责选择最优的索引提升查询效率。但索引自身需要占用存储空间，因此在索引数量与索引存储、维护成本之间存在权衡。</p>
</blockquote>
<p>索引本质上就是一种小表，是把大表中的某些列抽取出来。</p>
<h3 id="2-2-1-B-Tree"><a href="#2-2-1-B-Tree" class="headerlink" title="2.2.1 B+ Tree"></a>2.2.1 B+ Tree</h3><p>B+ Tree 是一种自平衡树，它将数据有序地存储，且在 search、sequential access、insertions 以及 deletions 操作的复杂度上都满足 O(logn)，其中 sequential access 的最终复杂度还与所需数据总量有关。</p>
<blockquote>
<p>这里的O(logn)的意义在于，随着数据的增长，操作的复杂度增长是要慢于数据的增长速度的。比如数据增长到原来的2倍，但搜索时间不会变成原来的2倍。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242151303.png" alt="image-20240324215134042"></p>
<h4 id="B-Tree-Nodes"><a href="#B-Tree-Nodes" class="headerlink" title="B+ Tree Nodes"></a>B+ Tree Nodes</h4><p>B+ Tree 中的每个 node 都包含一列按 key 排好序的 key&#x2F;value pairs，key 就是 table index 对应的 column，value 的取值与 node 类型相关，在 inner nodes 和 leaf nodes 中存的内容不同。</p>
<p>values主要有两种存法：</p>
<ul>
<li>Record IDs，存储指向最终 tuple 的指针。</li>
<li>Tuple Data，直接将 tuple data 存在 leaf node 中。key为ID，v为整个行数据。如主键索引，其key为主键，value即为这张表的全部内容。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403242154259.png" alt="image-20240324215455186"></p>
<h4 id="B-Tree-Operations"><a href="#B-Tree-Operations" class="headerlink" title="B+ Tree Operations"></a>B+ Tree Operations</h4><p><em>Insert</em></p>
<ol>
<li>找到对应的 leaf node，L</li>
<li>将 key&#x2F;value pair 按顺序插入到 L 中</li>
<li>如果 L 还有足够的空间，操作结束；如果空间不足，则需要将 L 分裂成两个节点，同时在 parent node 上新增 entry，若 parent node 也空间不足，则递归地分裂，直到 root node 为止。</li>
</ol>
<p><em>Delete</em></p>
<ol>
<li>从 root 开始，找到目标 entry 所处的 leaf node, L</li>
<li>删除该 entry</li>
<li>如果 L 仍然至少处于半满状态，则操作结束；否则先尝试从 siblings 那里拆借 entries，如果失败，则将 L 与相应的 sibling 合并</li>
<li>如果合并发生了，则可能需要递归地删除 parent node 中的 entry</li>
</ol>
<h4 id="Clustered-Indexes-聚簇索引"><a href="#Clustered-Indexes-聚簇索引" class="headerlink" title="Clustered Indexes 聚簇索引"></a>Clustered Indexes 聚簇索引</h4><h3 id="2-2-2-B-Tree-Design-Choices"><a href="#2-2-2-B-Tree-Design-Choices" class="headerlink" title="2.2.2 B+ Tree Design Choices"></a>2.2.2 B+ Tree Design Choices</h3><h4 id="Node-Size"><a href="#Node-Size" class="headerlink" title="Node Size"></a>Node Size</h4><p>通常来说，disk 的数据读取速度越慢，node size 就越大：</p>
<table>
<thead>
<tr>
<th>Disk Type</th>
<th>Node Size</th>
</tr>
</thead>
<tbody><tr>
<td>HDD</td>
<td>~1MB</td>
</tr>
<tr>
<td>SSD</td>
<td>~10KB</td>
</tr>
<tr>
<td>In-Memory</td>
<td>~512B</td>
</tr>
</tbody></table>
<p>具体情境下的最优大小由 workload 决定。</p>
<h4 id="Merge-Threshold"><a href="#Merge-Threshold" class="headerlink" title="Merge Threshold"></a>Merge Threshold</h4><p>由于 merge 操作引起的修改较大，有些 DBMS 选择延迟 merge 操作的发生时间，甚至可以利用其它进程来负责周期性地重建 table index。</p>
<h4 id="Variable-Length-Keys"><a href="#Variable-Length-Keys" class="headerlink" title="Variable Length Keys"></a>Variable Length Keys</h4><p>B+ Tree 中存储的 key 经常是变长的，通常有三种手段来应对：</p>
<ul>
<li>Pointers：存储指向 key 的指针；</li>
<li>Variable Length Nodes：需要精细的内存管理操作，不推荐；</li>
<li>Padding：给每个变长的key都强制转成一致的长度；</li>
<li>key Map：内嵌一个指针数组，指向 node 中的 key&#x2F;val list</li>
</ul>
<h4 id="Non-unique-Indexes-变长字段"><a href="#Non-unique-Indexes-变长字段" class="headerlink" title="Non-unique Indexes 变长字段"></a>Non-unique Indexes 变长字段</h4><p>索引针对的 key 可能是非唯一的，通常有两种手段来应对：</p>
<ul>
<li><p>Duplicate Keys：存储多次相同的 key；</p>
</li>
<li><p>Value Lists：每个 key 只出现一次，但同时维护另一个链表，存储 key 对应的多个 values，类似 chained hashing</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251235897.png" alt="image-20240325123534595"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251235251.png" alt="image-20240325123553069"></p>
<h4 id="Intra-node-Search-结点的内部搜素"><a href="#Intra-node-Search-结点的内部搜素" class="headerlink" title="Intra-node Search 结点的内部搜素"></a>Intra-node Search 结点的内部搜素</h4><p>在节点内部搜索，就是在排好序的序列中检索元素，手段通常有：</p>
<ul>
<li>Linear Scan，这种线性扫描虽然似乎很费时，但相比把page从磁盘读到内存的时间来看几乎已经不算什么了；</li>
<li>Binary Search，用二分来优化线性搜索；</li>
<li>Interpolation：通过 keys 的分布统计信息来估计大概位置进行检索</li>
</ul>
<h3 id="2-2-3-Optimizations"><a href="#2-2-3-Optimizations" class="headerlink" title="2.2.3 Optimizations"></a>2.2.3 Optimizations</h3><h4 id="Prefix-Compression"><a href="#Prefix-Compression" class="headerlink" title="Prefix Compression"></a>Prefix Compression</h4><p>同一个 leaf node 中的 keys 通常有相同的 prefix，如下图所示。为了节省空间，可以只存所有 keys 的不同的 suffix。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251240293.png" alt="image-20240325124020194"></p>
<h4 id="Suffix-Truncation"><a href="#Suffix-Truncation" class="headerlink" title="Suffix Truncation"></a>Suffix Truncation</h4><p>由于 inner nodes 只用于引导搜索，因此没有必要在 inner nodes 中储存完整的 key，我们可以<strong>只存储足够的 prefix 即可</strong>，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251241456.png" alt="image-20240325124132291"></p>
<h4 id="Bulk-Insert"><a href="#Bulk-Insert" class="headerlink" title="Bulk Insert"></a>Bulk Insert</h4><p>建 B+ Tree 的最快方式是先将 keys 排好序后，再从下往上建树，如下图所示。因此如果有<strong>大量插入操作</strong>，可以利用这种方式提高效率。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251241413.png" alt="image-20240325124150282"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251242426.png" alt="image-20240325124207283"></p>
<h4 id="Pointer-Swizzling"><a href="#Pointer-Swizzling" class="headerlink" title="Pointer Swizzling"></a>Pointer Swizzling</h4><p>Nodes 使用 page id 来存储其它 nodes 的引用，DBMS 每次需要首先从 page table 中获取对应的内存地址，然后才能获取相应的 nodes 本身，如果 page 已经在 buffer pool 中，我们可以直接存储其它 page 在 buffer pool 中的内存地址作为引用，从而提高访问效率。</p>
<h2 id="2-3-Index-Concurrency-Control"><a href="#2-3-Index-Concurrency-Control" class="headerlink" title="2.3 Index Concurrency Control"></a>2.3 Index Concurrency Control</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251246471.png" alt="image-20240325124646316"></p>
<h3 id="2-3-1-Latch-Modes"><a href="#2-3-1-Latch-Modes" class="headerlink" title="2.3.1 Latch Modes"></a>2.3.1 Latch Modes</h3><h4 id="Read-Mode"><a href="#Read-Mode" class="headerlink" title="Read Mode"></a>Read Mode</h4><ul>
<li>多个线程可以同时读取相同的数据</li>
<li>针对相同的数据，当别的线程已经获得处于 read mode 的 latch，新的线程也可以继续获取 read mode 的 latch</li>
</ul>
<h4 id="Write-Mode"><a href="#Write-Mode" class="headerlink" title="Write Mode"></a>Write Mode</h4><ul>
<li>同一时间只有单个线程可以访问</li>
<li>针对相同的数据，如果获取前已经有别的线程获得任何 mode 的 latch，新的线程就无法获取 write mode  的 latch</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251249774.png" alt="image-20240325124932586"></p>
<p><strong>锁的实现：</strong></p>
<ul>
<li><p>Blocking OS Mutex：如std::mutex，好处是竞争的线程会陷入sleep，但坏处是需要OS去进行唤醒，极度浪费资源；</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251251222.png" alt="image-20240325125111105"></p>
</li>
<li><p>Test-ans-Set Spin Latch(TAS)：自旋锁，如std::atomic<T>，不需要OS操作，自己在死循环内不断旋转，直到可以获取到该锁；</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251253634.png" alt="image-20240325125323436"></p>
</li>
<li><p>Reader-Writer Latches：自旋锁的基础上实现。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403251255541.png" alt="image-20240325125549330"></p>
<p>这里注意：若有线程需要加写锁，那么此时如果再有线程希望加读锁也会被阻塞。只有等之前的读锁都释放，写锁成功加上后，后续的读锁才能正常上锁。（这样做是为了避免写锁被无止境地锁住）</p>
</li>
</ul>
<h4 id="hash-table-latching"><a href="#hash-table-latching" class="headerlink" title="hash table latching"></a><strong>hash table latching</strong></h4><p>相较于B+ Tree，Hash Table不容易遇到死锁，尤其是开放地址哈希，因为大家都是朝着一个方向去进行的。一般在扩容（resize）操作时，加一个全局的写锁，因为此时哈希表内部的数据需要进行一个整理。</p>
<ul>
<li>page latches：块与块之间的锁独立。线程会给所有块加分段锁。例如下图，块1的写锁和块2的读锁独立。这样的优势是：1）锁的粒度不会太细；2）支持一定的并发操作。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271610143.png" alt="image-20240327161025853"></p>
<ul>
<li><p>slot latches：以槽为单位进行加锁。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271611923.png" alt="image-20240327161157762"></p>
</li>
<li><p>compare-and-swap，CAS，使得hash table实现无锁插入。例如下图：让os先0判断是否为20，若是再加到30，属于原子操作。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271629958.png" alt="image-20240327162902774"></p>
</li>
</ul>
<h3 id="2-3-2-Index-Crabbing-Coupling"><a href="#2-3-2-Index-Crabbing-Coupling" class="headerlink" title="2.3.2 Index Crabbing&#x2F;Coupling"></a>2.3.2 Index Crabbing&#x2F;Coupling</h3><p>B+Tree考虑两方面的并发问题：</p>
<ul>
<li>1）结点内部的数据，即多个线程同时修改一个node；</li>
<li>2）结点间的合并和分裂操作，即一个线程正在遍历 B+ Tree 的同时，另一个线程正在 splits&#x2F;merges nodes。</li>
</ul>
<p><strong>Latch Crabbing 的基本思想如下：</strong></p>
<ul>
<li>获取 parent 的 latch</li>
<li>获取 child 的 latch</li>
<li>如果<strong>安全</strong>，可以释放 parent 的 latch</li>
</ul>
<p><strong>这里的“安全”指的是，当发生更新操作时，该节点不会发生 split 或 merge 的操作，即：</strong></p>
<ul>
<li>在插入元素时，节点未满</li>
<li>在删除元素时，节点超过半满</li>
</ul>
<p>按照上述方法，无论对叶子结点执行何种操作，第一步都是先锁住根节点，这是一种“悲观”的做法。“乐观”的做法是：一路加读锁，最后加写锁。当然也有可能出现到了最后一步，发现会改动前面的parent，因此需要放弃当前的操作，重新从root开始加写锁。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271638410.png" alt="image-20240327163836210"></p>
<h3 id="2-3-3-Leaf-Scans"><a href="#2-3-3-Leaf-Scans" class="headerlink" title="2.3.3 Leaf Scans"></a>2.3.3 Leaf Scans</h3><p>之前的分析中我们仅仅关注了从上到下的访问模式，而没有考虑到左右方向的访问模式，在 range query 中，常常需要横向访问相邻的 nodes。</p>
<p>当遇到横向扫描无法获取下一个节点的 latch 时，该线程将释放 latch 后自杀。这种策略逻辑简单，尽管有理论上的优化空间，但在实践中是常见的避免死锁的方式。</p>
<h3 id="2-3-4-Delayed-Parent-Updates"><a href="#2-3-4-Delayed-Parent-Updates" class="headerlink" title="2.3.4 Delayed Parent Updates"></a>2.3.4 Delayed Parent Updates</h3><p>从上文中，我们可以观察到：每当 leaf node 溢出时，我们都需要更新至少 3 个节点：</p>
<ul>
<li>即将被拆分的 leaf node</li>
<li>新的 leaf node</li>
<li>parent node</li>
</ul>
<p>修改的成本较高，因此 B-link Tree 提出了一种优化策略：<strong>每当 leaf node 溢出时，只是标记一下而暂时不更新 parent node，等下一次有别的线程获取 parnet node 的 write latch 时，一并修改。</strong></p>
<h2 id="2-4-Sorting-and-Aggregations"><a href="#2-4-Sorting-and-Aggregations" class="headerlink" title="2.4 Sorting and Aggregations"></a>2.4 Sorting and Aggregations</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271648356.png" alt="image-20240327164819130"></p>
<p>一个disk-oriented DBMS不能假定query results和内存大小完全适配。有可能筛选出来的query results也需要存到磁盘中，和buffer pool互相配合来实现操作。需要最大化利用sequential I&#x2F;O。</p>
<p><strong>为什么需要排序：关系型数据库是unsorted的。</strong></p>
<h3 id="2-4-1-Sorting-Algorithm"><a href="#2-4-1-Sorting-Algorithm" class="headerlink" title="2.4.1 Sorting Algorithm"></a>2.4.1 Sorting Algorithm</h3><ul>
<li>early materialization：排序时value直接存储当前key那一行的剩余数据；</li>
<li>later materialization：排序时value存储ID值。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271703469.png" alt="image-20240327170300327"></p>
<h4 id="External-Merge-Sort"><a href="#External-Merge-Sort" class="headerlink" title="External Merge Sort"></a>External Merge Sort</h4><p>外部排序通常有两个步骤：</p>
<p>1、Sorting Phase：将数据分成多个 chunks，每个 chunk 可以完全读入到 memory 中，在 memory 中排好序后再写回到 disk 中</p>
<p>2、Merge Phase：将多个子文件合并成一个大文件</p>
<ul>
<li><p>2-Way External Merge Sort：这里的“2-way”即是指每次读入两页。</p>
</li>
<li><p>General External Merge Sort：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271947535.png" alt="image-20240327194734264"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271949041.png" alt="image-20240327194933847"></p>
</li>
</ul>
<h4 id="Using-B-Tree-for-Sorting"><a href="#Using-B-Tree-for-Sorting" class="headerlink" title="Using B+Tree for Sorting"></a>Using B+Tree for Sorting</h4><p>注意包含聚簇和非聚簇两种情况。</p>
<h3 id="2-4-2-Aggregations"><a href="#2-4-2-Aggregations" class="headerlink" title="2.4.2 Aggregations"></a>2.4.2 Aggregations</h3><h4 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403271953093.png" alt="image-20240327195346706"></p>
<p>但很多时候我们并不需要排好序的数据，如：</p>
<ul>
<li>Forming groups in GROUP BY</li>
<li>Removing duplicates in DISTINCT</li>
</ul>
<p>在这样的场景下 hashing 是更好的选择，它能有效减少排序所需的额外工作。</p>
<h4 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h4><p>利用一个临时 (ephemeral) 的 hash table 来记录必要的信息，即检查 hash table 中是否存在已经记录过的元素并作出相应操作：</p>
<ul>
<li>DISTINCT: Discard duplicate</li>
<li>GROUP BY: Perform aggregate computation</li>
</ul>
<p>如果所有信息都能一次性读入内存，那事情就很简单了，但如若不然，我们就得变得更聪明。</p>
<p>hashing aggregation 同样分成两步：</p>
<ul>
<li>Partition Phase: 将 tuples 根据 hash key 放入不同的 buckets<ul>
<li>use a hash function h1 to split tuples into partitions on disk<ul>
<li>all matches live in the same partition</li>
<li>partitions are “spilled” to disk via output buffers</li>
</ul>
</li>
<li>这里有个额外的假设，即每个 partition 能够被放到 memory 中</li>
</ul>
</li>
<li>ReHash Phase: 在内存中针对每个 partition 利用 hash table 计算 aggregation 的结果</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403272000471.png" alt="image-20240327200043163"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403272000726.png" alt="image-20240327200052468"></p>
<p>在 ReHash phase 中，存着 (GroupKey→RunningVal)(GroupKey→RunningVal) 的键值对，当我们需要向 hash table 中插入新的 tuple 时：</p>
<ul>
<li>如果我们发现相应的 GroupKey 已经在内存中，只需要更新 RunningVal 就可以</li>
<li>反之，则插入新的 GroupKey 到 RunningVal 的键值对</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403272001082.png" alt="image-20240327200117774"></p>
]]></content>
      <categories>
        <category>Project</category>
        <category>cmu15-445</category>
      </categories>
  </entry>
  <entry>
    <title>cmu15-445 Homework1_SQL (Spring 2023)</title>
    <url>/2024/02/28/Project/cmu15-445/cmu15-445%20Homework1_SQL/</url>
    <content><![CDATA[<h1 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> CategoryName <span class="keyword">FROM</span> Category <span class="keyword">ORDER</span> <span class="keyword">BY</span> CategoryName;</span><br><span class="line"></span><br><span class="line">Beverages</span><br><span class="line">Condiments</span><br><span class="line">Confections</span><br><span class="line">Dairy Products</span><br><span class="line">Grains<span class="operator">/</span>Cereals</span><br><span class="line">Meat<span class="operator">/</span>Poultry</span><br><span class="line">Produce</span><br><span class="line">Seafood</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> ShipName <span class="keyword">FROM</span> <span class="string">&#x27;Order&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span>  ShipName <span class="keyword">LIKE</span> <span class="string">&#x27;%-%&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> ShipName;</span><br><span class="line"></span><br><span class="line">Bottom<span class="operator">-</span>Dollar Markets</span><br><span class="line">Chop<span class="operator">-</span>suey Chinese</span><br><span class="line">GROSELLA<span class="operator">-</span>Restaurante</span><br><span class="line">HILARION<span class="operator">-</span>Abastos</span><br><span class="line">Hungry Owl <span class="keyword">All</span><span class="operator">-</span>Night Grocers</span><br><span class="line">LILA<span class="operator">-</span>Supermercado</span><br><span class="line">LINO<span class="operator">-</span>Delicateses</span><br><span class="line">QUICK<span class="operator">-</span>Stop</span><br><span class="line">Save<span class="operator">-</span>a<span class="operator">-</span>lot Markets</span><br><span class="line"></span><br><span class="line">DETAILS:</span><br><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> ShipName <span class="operator">||</span> <span class="string">&#x27;|&#x27;</span> <span class="operator">||</span> SUBSTR(ShipName, <span class="number">1</span>, INSTR(ShipName, <span class="string">&#x27;-&#x27;</span>) <span class="operator">-</span> <span class="number">1</span>) <span class="keyword">AS</span> formatted_res</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="string">&#x27;Order&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> ShipName <span class="keyword">like</span> <span class="string">&#x27;%-%&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> ShipName;</span><br><span class="line"></span><br><span class="line">Bottom<span class="operator">-</span>Dollar Markets<span class="operator">|</span>Bottom</span><br><span class="line">Chop<span class="operator">-</span>suey Chinese<span class="operator">|</span>Chop</span><br><span class="line">GROSELLA<span class="operator">-</span>Restaurante<span class="operator">|</span>GROSELLA</span><br><span class="line">HILARION<span class="operator">-</span>Abastos<span class="operator">|</span>HILARION</span><br><span class="line">Hungry Owl <span class="keyword">All</span><span class="operator">-</span>Night Grocers<span class="operator">|</span>Hungry Owl <span class="keyword">All</span></span><br><span class="line">LILA<span class="operator">-</span>Supermercado<span class="operator">|</span>LILA</span><br><span class="line">LINO<span class="operator">-</span>Delicateses<span class="operator">|</span>LINO</span><br><span class="line">QUICK<span class="operator">-</span>Stop<span class="operator">|</span>QUICK</span><br><span class="line">Save<span class="operator">-</span>a<span class="operator">-</span>lot Markets<span class="operator">|</span>Save</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> INSTR(ShipName, <span class="string">&#x27;-&#x27;</span>)：该函数找到在 ShipName 字符串中连字符（<span class="string">&#x27;-&#x27;</span>）的位置</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> SUBSTR(ShipName, <span class="number">1</span>, INSTR(ShipName, <span class="string">&#x27;-&#x27;</span>) <span class="operator">-</span> <span class="number">1</span>)：该 SUBSTR 函数从 ShipName 字符串的开头（位置<span class="number">1</span>）提取子字符串，直到连字符的位置减<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Id <span class="operator">||</span> <span class="string">&#x27;|&#x27;</span> <span class="operator">||</span> ShipCountry <span class="operator">||</span> <span class="string">&#x27;|&#x27;</span> <span class="operator">||</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">CASE</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">WHEN</span> ShipCountry <span class="keyword">IN</span> (<span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Mexico&#x27;</span>, <span class="string">&#x27;Canada&#x27;</span>) <span class="keyword">THEN</span> <span class="string">&#x27;NorthAmerica&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">ELSE</span> <span class="string">&#x27;OtherPlace&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">END</span> <span class="keyword">AS</span> Region</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="string">&#x27;Order&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> Id<span class="operator">&gt;=</span><span class="number">15445</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> Id</span><br><span class="line">   ...<span class="operator">&gt;</span> LIMIT <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">15445</span><span class="operator">|</span>France<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15446</span><span class="operator">|</span>Italy<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15447</span><span class="operator">|</span>Portugal<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15448</span><span class="operator">|</span>Argentina<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15449</span><span class="operator">|</span>Portugal<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15450</span><span class="operator">|</span>Venezuela<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15451</span><span class="operator">|</span>Brazil<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15452</span><span class="operator">|</span>France<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15453</span><span class="operator">|</span>France<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15454</span><span class="operator">|</span>Canada<span class="operator">|</span>NorthAmerica</span><br><span class="line"><span class="number">15455</span><span class="operator">|</span>USA<span class="operator">|</span>NorthAmerica</span><br><span class="line"><span class="number">15456</span><span class="operator">|</span>France<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15457</span><span class="operator">|</span>Mexico<span class="operator">|</span>NorthAmerica</span><br><span class="line"><span class="number">15458</span><span class="operator">|</span>USA<span class="operator">|</span>NorthAmerica</span><br><span class="line"><span class="number">15459</span><span class="operator">|</span>Germany<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15460</span><span class="operator">|</span>Argentina<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15461</span><span class="operator">|</span>Austria<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15462</span><span class="operator">|</span>Austria<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15463</span><span class="operator">|</span>Finland<span class="operator">|</span>OtherPlace</span><br><span class="line"><span class="number">15464</span><span class="operator">|</span>Brazil<span class="operator">|</span>OtherPlace</span><br></pre></td></tr></table></figure>

<h1 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span></span><br><span class="line">   ...<span class="operator">&gt;</span> s.CompanyName <span class="operator">||</span> <span class="string">&#x27;|&#x27;</span> <span class="operator">||</span></span><br><span class="line">   ...<span class="operator">&gt;</span> ROUND(<span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> o.ShippedDate <span class="operator">&gt;</span> o.RequiredDate <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="operator">*</span> <span class="number">100.0</span> <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>), <span class="number">2</span>) <span class="keyword">AS</span> Percentage</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> Shipper <span class="keyword">as</span> s</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">JOIN</span> [<span class="keyword">Order</span>] <span class="keyword">as</span> o <span class="keyword">ON</span> s.Id <span class="operator">=</span> o.ShipVia</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> s.CompanyName</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> Percentage <span class="keyword">DESC</span>; </span><br><span class="line"></span><br><span class="line">United Package<span class="operator">|</span><span class="number">23.44</span></span><br><span class="line">Speedy Express<span class="operator">|</span><span class="number">23.46</span></span><br><span class="line">Federal Shipping<span class="operator">|</span><span class="number">23.61</span></span><br></pre></td></tr></table></figure>

<h1 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span></span><br><span class="line">   ...<span class="operator">&gt;</span> a.CategoryName,</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="built_in">COUNT</span>(a.Id) <span class="keyword">AS</span> TotalCategoryCount,</span><br><span class="line">   ...<span class="operator">&gt;</span> ROUND(((<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(UnitPrice) <span class="keyword">FROM</span> Category b, Product c <span class="keyword">WHERE</span> b.Id <span class="operator">=</span> c.CategoryId <span class="keyword">AND</span> b.CategoryName <span class="operator">=</span> a.CategoryName) <span class="operator">*</span> <span class="number">1.0</span>) <span class="operator">/</span> ((<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> Category d, Product e <span class="keyword">WHERE</span> d.Id <span class="operator">=</span> e.CategoryId <span class="keyword">AND</span> d.CategoryName <span class="operator">=</span> a.CategoryName) <span class="operator">*</span> <span class="number">1.0</span>) , <span class="number">2</span>),</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="built_in">MIN</span>(f.UnitPrice),</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="built_in">MAX</span>(f.UnitPrice),</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="built_in">SUM</span>(f.UnitsOnOrder)</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> Category a, Product f</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> a.Id <span class="operator">=</span> f.CategoryId</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.CategoryName</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">HAVING</span> TotalCategoryCount <span class="operator">&gt;</span> <span class="number">10</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a.Id <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">Beverages<span class="operator">|</span><span class="number">12</span><span class="operator">|</span><span class="number">37.98</span><span class="operator">|</span><span class="number">4.5</span><span class="operator">|</span><span class="number">263.5</span><span class="operator">|</span><span class="number">60</span></span><br><span class="line">Condiments<span class="operator">|</span><span class="number">12</span><span class="operator">|</span><span class="number">23.06</span><span class="operator">|</span><span class="number">10</span><span class="operator">|</span><span class="number">43.9</span><span class="operator">|</span><span class="number">170</span></span><br><span class="line">Confections<span class="operator">|</span><span class="number">13</span><span class="operator">|</span><span class="number">25.16</span><span class="operator">|</span><span class="number">9.2</span><span class="operator">|</span><span class="number">81</span><span class="operator">|</span><span class="number">180</span></span><br><span class="line">Seafood<span class="operator">|</span><span class="number">12</span><span class="operator">|</span><span class="number">20.68</span><span class="operator">|</span><span class="number">6</span><span class="operator">|</span><span class="number">62.5</span><span class="operator">|</span><span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> b.CategoryName <span class="operator">=</span> a.CategoryName 这个条件确保了在计算每个类别的商品价格总和时，只考虑了与当前类别相关的商品</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 这是为了满足 <span class="keyword">HAVING</span> TotalCategoryCount <span class="operator">&gt;</span> <span class="number">10</span> 中的条件</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">*</span><span class="number">1.0</span> 的目的是将整数值转换为浮点数。这是为了确保在计算平均商品价格时，得到的结果是一个浮点数，而不是整数</span><br></pre></td></tr></table></figure>

<h1 id="Q6"><a href="#Q6" class="headerlink" title="Q6*"></a>Q6*</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">SELECT</span> p.ProductName, </span><br><span class="line">(<span class="keyword">SELECT</span> </span><br><span class="line">  c1.CompanyName <span class="operator">||</span> <span class="string">&#x27;|&#x27;</span> <span class="operator">||</span> c1.ContactName </span><br><span class="line">  <span class="keyword">FROM</span> Customer c1 </span><br><span class="line">  <span class="keyword">JOIN</span> [<span class="keyword">Order</span>] o1 <span class="keyword">ON</span> o1.CustomerId <span class="operator">=</span> c1.Id</span><br><span class="line">  <span class="keyword">JOIN</span> OrderDetail od1 <span class="keyword">ON</span> o1.Id <span class="operator">=</span> od1.OrderID</span><br><span class="line">  <span class="keyword">WHERE</span> od1.ProductId <span class="operator">=</span> p.Id</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> o1.OrderDate <span class="keyword">ASC</span> LIMIT <span class="number">1</span>) <span class="keyword">AS</span> CustomerInfo</span><br><span class="line"><span class="keyword">FROM</span> Product p</span><br><span class="line"><span class="keyword">JOIN</span> OrderDetail od <span class="keyword">ON</span> p.Id <span class="operator">=</span> od.ProductId</span><br><span class="line"><span class="keyword">JOIN</span> [<span class="keyword">Order</span>] o <span class="keyword">ON</span> od.OrderId <span class="operator">=</span> o.Id</span><br><span class="line"><span class="keyword">JOIN</span> CUSTOMER c <span class="keyword">ON</span> o.CustomerID <span class="operator">=</span> c.Id</span><br><span class="line"><span class="keyword">WHERE</span> p.Discontinued <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> p.ProductName;</span><br><span class="line"></span><br><span class="line">Alice Mutton<span class="operator">|</span>Consolidated Holdings<span class="operator">|</span>Elizabeth Brown</span><br><span class="line">Chef Anton<span class="string">&#x27;s Gumbo Mix|Piccolo und mehr|Georg Pipps</span></span><br><span class="line"><span class="string">Guaraná Fantástica|Piccolo und mehr|Georg Pipps</span></span><br><span class="line"><span class="string">Mishi Kobe Niku|Old World Delicatessen|Rene Phillips</span></span><br><span class="line"><span class="string">Perth Pasties|Piccolo und mehr|Georg Pipps</span></span><br><span class="line"><span class="string">Rössle Sauerkraut|Piccolo und mehr|Georg Pipps</span></span><br><span class="line"><span class="string">Singaporean Hokkien Fried Mee|Vins et alcools Chevalier|Paul Henriot</span></span><br><span class="line"><span class="string">Thüringer Rostbratwurst|Piccolo und mehr|Georg Pipps</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// c1		==&gt; FROM Customer c1 </span></span><br><span class="line"><span class="string">// c1-&gt;o1	==&gt; JOIN [Order] o1 ON o1.CustomerId = c1.Id</span></span><br><span class="line"><span class="string">// o1-&gt;od1	==&gt; JOIN OrderDetail od1 ON o1.Id = od1.OrderID</span></span><br><span class="line"><span class="string">// od1-&gt;p	==&gt; (将子查询和外部主查询联系起来)WHERE od1.ProductId = p.Id</span></span><br></pre></td></tr></table></figure>

<h2 id="Q7"><a href="#Q7" class="headerlink" title="Q7*"></a>Q7*</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Id, Orderdate, pre_OrderDate, ROUND(julianday(OrderDate)<span class="operator">-</span>julianday(pre_orderdate) , <span class="number">2</span>)</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> Id, OrderDate, <span class="built_in">LAG</span>(Orderdate, <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> CustomerId <span class="keyword">ORDER</span> <span class="keyword">BY</span> OrderDate <span class="keyword">ASC</span>) pre_OrderDate</span><br><span class="line">      <span class="keyword">FROM</span> [<span class="keyword">Order</span>]</span><br><span class="line">      <span class="keyword">WHERE</span> CustomerId <span class="operator">=</span> <span class="string">&#x27;BLONP&#x27;</span></span><br><span class="line">      LIMIT <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">16766</span><span class="operator">|</span><span class="number">2012</span><span class="number">-07</span><span class="number">-22</span> <span class="number">23</span>:<span class="number">11</span>:<span class="number">15</span><span class="operator">|</span><span class="number">0</span><span class="operator">|</span><span class="number">2456131.47</span></span><br><span class="line"><span class="number">10265</span><span class="operator">|</span><span class="number">2012</span><span class="number">-07</span><span class="number">-25</span><span class="operator">|</span><span class="number">2012</span><span class="number">-07</span><span class="number">-22</span> <span class="number">23</span>:<span class="number">11</span>:<span class="number">15</span><span class="operator">|</span><span class="number">2.03</span></span><br><span class="line"><span class="number">12594</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-16</span> <span class="number">12</span>:<span class="number">35</span>:<span class="number">15</span><span class="operator">|</span><span class="number">2012</span><span class="number">-07</span><span class="number">-25</span><span class="operator">|</span><span class="number">22.52</span></span><br><span class="line"><span class="number">20249</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">52</span>:<span class="number">23</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-16</span> <span class="number">12</span>:<span class="number">35</span>:<span class="number">15</span><span class="operator">|</span><span class="number">0.18</span></span><br><span class="line"><span class="number">20882</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-18</span> <span class="number">19</span>:<span class="number">11</span>:<span class="number">48</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">52</span>:<span class="number">23</span><span class="operator">|</span><span class="number">2.1</span></span><br><span class="line"><span class="number">18443</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-28</span> <span class="number">05</span>:<span class="number">34</span>:<span class="number">03</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-18</span> <span class="number">19</span>:<span class="number">11</span>:<span class="number">48</span><span class="operator">|</span><span class="number">9.43</span></span><br><span class="line"><span class="number">10297</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-04</span><span class="operator">|</span><span class="number">2012</span><span class="number">-08</span><span class="number">-28</span> <span class="number">05</span>:<span class="number">34</span>:<span class="number">03</span><span class="operator">|</span><span class="number">6.77</span></span><br><span class="line"><span class="number">11694</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-17</span> <span class="number">00</span>:<span class="number">27</span>:<span class="number">14</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-04</span><span class="operator">|</span><span class="number">13.02</span></span><br><span class="line"><span class="number">25613</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-18</span> <span class="number">22</span>:<span class="number">37</span>:<span class="number">15</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-17</span> <span class="number">00</span>:<span class="number">27</span>:<span class="number">14</span><span class="operator">|</span><span class="number">1.92</span></span><br><span class="line"><span class="number">17361</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">13</span>:<span class="number">21</span><span class="operator">|</span><span class="number">2012</span><span class="number">-09</span><span class="number">-18</span> <span class="number">22</span>:<span class="number">37</span>:<span class="number">15</span><span class="operator">|</span><span class="number">0.57</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> julianday(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">Result</span>: <span class="number">2458220.59892027</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 返回从格林尼治时间的公元前 <span class="number">4714</span> 年 <span class="number">11</span> 月 <span class="number">24</span> 日正午算起的天数</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="built_in">LAG</span>(expr, <span class="keyword">offset</span>, <span class="keyword">default</span>) <span class="keyword">OVER</span> (partition_by_clause order_by_clause)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 计算当前行向前数若干行的值，该函数专门用作窗口函数(<span class="keyword">window</span> functions)，<span class="keyword">partition</span> <span class="keyword">by</span>功能类似<span class="keyword">group</span> <span class="keyword">by</span></span><br></pre></td></tr></table></figure>

<h1 id="Q8"><a href="#Q8" class="headerlink" title="Q8*"></a>Q8*</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">WITH</span> expenditures <span class="keyword">AS</span>(</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">SELECT</span> </span><br><span class="line">   ...<span class="operator">&gt;</span>                        IFNULL(c.CompanyName, <span class="string">&#x27;MISSING_NAME&#x27;</span>) <span class="keyword">AS</span> CompanyName,</span><br><span class="line">   ...<span class="operator">&gt;</span>                        o.CustomerId,</span><br><span class="line">   ...<span class="operator">&gt;</span>                        ROUND((<span class="built_in">SUM</span>(od.Quantity <span class="operator">*</span> od.UnitPrice)) , <span class="number">2</span>) <span class="keyword">AS</span> totalcost</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">FROM</span> [<span class="keyword">Order</span>] o</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">JOIN</span> OrderDetail od <span class="keyword">ON</span> od.OrderId <span class="operator">=</span> o.Id</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Customer c <span class="keyword">ON</span> c.Id <span class="operator">=</span> o.CustomerId</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">GROUP</span> <span class="keyword">BY</span> o.CustomerId),</span><br><span class="line">   ...<span class="operator">&gt;</span>      quartiles <span class="keyword">AS</span>(</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">SELECT</span></span><br><span class="line">   ...<span class="operator">&gt;</span>                        <span class="operator">*</span>,</span><br><span class="line">   ...<span class="operator">&gt;</span>                        <span class="built_in">NTILE</span>(<span class="number">4</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> totalcost <span class="keyword">ASC</span>) <span class="keyword">AS</span> ExpenditureQuartile</span><br><span class="line">   ...<span class="operator">&gt;</span>                      <span class="keyword">FROM</span> expenditures)</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">SELECT</span> CompanyName, CustomerId, totalcost</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> quartiles</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> ExpenditureQuartile <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> totalcost <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">MISSING_NAME<span class="operator">|</span>DUMO<span class="operator">|</span><span class="number">1615.9</span></span><br><span class="line">MISSING_NAME<span class="operator">|</span>OCEA<span class="operator">|</span><span class="number">3460.2</span></span><br><span class="line">MISSING_NAME<span class="operator">|</span>ANTO<span class="operator">|</span><span class="number">7515.35</span></span><br><span class="line">MISSING_NAME<span class="operator">|</span>QUEE<span class="operator">|</span><span class="number">30226.1</span></span><br><span class="line">Trail<span class="string">&#x27;s Head Gourmet Provisioners|TRAIH|3874502.02</span></span><br><span class="line"><span class="string">Blondesddsl père et fils|BLONP|3879728.69</span></span><br><span class="line"><span class="string">Around the Horn|AROUT|4395636.28</span></span><br><span class="line"><span class="string">Hungry Owl All-Night Grocers|HUNGO|4431457.1</span></span><br><span class="line"><span class="string">Bon app|BONAP|4485708.49</span></span><br><span class="line"><span class="string">Bólido Comidas preparadas|BOLID|4520121.88</span></span><br><span class="line"><span class="string">Galería del gastrónomo|GALED|4533089.9</span></span><br><span class="line"><span class="string">FISSA Fabrica Inter. Salchichas S.A.|FISSA|4554591.02</span></span><br><span class="line"><span class="string">Maison Dewey|MAISD|4555931.37</span></span><br><span class="line"><span class="string">Cactus Comidas para llevar|CACTU|4559046.87</span></span><br><span class="line"><span class="string">Spécialités du monde|SPECD|4571764.89</span></span><br><span class="line"><span class="string">Magazzini Alimentari Riuniti|MAGAA|4572382.35</span></span><br><span class="line"><span class="string">Toms Spezialitäten|TOMSP|4628403.36</span></span><br><span class="line"><span class="string">Split Rail Beer &amp; Ale|SPLIR|4641383.53</span></span><br><span class="line"><span class="string">Santé Gourmet|SANTG|4647668.15</span></span><br><span class="line"><span class="string">Morgenstern Gesundkost|MORGK|4676234.2</span></span><br><span class="line"><span class="string">White Clover Markets|WHITC|4681531.74</span></span><br><span class="line"><span class="string">La corne d&#x27;</span>abondance<span class="operator">|</span>LACOR<span class="operator">|</span><span class="number">4724494.22</span></span><br><span class="line">Victuailles en stock<span class="operator">|</span>VICTE<span class="operator">|</span><span class="number">4726476.33</span></span><br><span class="line">Lonesome Pine Restaurant<span class="operator">|</span>LONEP<span class="operator">|</span><span class="number">4735780.66</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> IFNULL(c.CompanyName, <span class="string">&#x27;MISSING_NAME&#x27;</span>) <span class="keyword">AS</span> CompanyName  </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 处理<span class="keyword">NULL</span>值</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Customer c <span class="keyword">ON</span> c.Id <span class="operator">=</span> o.CustomerId</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 这种连接类型包含左表的所有行，以及右表中满足连接条件的行。如果右表中没有匹配的行，那么结果集中将包含 <span class="keyword">NULL</span> 值</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="built_in">NTILE</span>(<span class="number">4</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> totalcost <span class="keyword">ASC</span>) <span class="keyword">AS</span> ExpenditureQuartile</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 它将结果集划分为指定数量的桶（buckets），并为每个桶分配一个标识号（bucket number）</span><br></pre></td></tr></table></figure>
<p>现在，假设有以下支出数据：</p>
<table>
<thead>
<tr>
<th>CompanyName</th>
<th>CustomerId</th>
<th>totalcost</th>
</tr>
</thead>
<tbody><tr>
<td>Company1</td>
<td>1</td>
<td>100</td>
</tr>
<tr>
<td>Company2</td>
<td>2</td>
<td>150</td>
</tr>
<tr>
<td>Company3</td>
<td>3</td>
<td>200</td>
</tr>
<tr>
<td>Company4</td>
<td>4</td>
<td>250</td>
</tr>
<tr>
<td>Company5</td>
<td>5</td>
<td>300</td>
</tr>
</tbody></table>
<p><code>NTILE(4) OVER (ORDER BY totalcost ASC) AS ExpenditureQuartile</code>将分配 ExpenditureQuartile 值，结果如下：</p>
<table>
<thead>
<tr>
<th>CompanyName</th>
<th>CustomerId</th>
<th>totalcost</th>
</tr>
</thead>
<tbody><tr>
<td>Company1</td>
<td>1</td>
<td>100</td>
</tr>
<tr>
<td>Company2</td>
<td>2</td>
<td>150</td>
</tr>
<tr>
<td>Company3</td>
<td>3</td>
<td>200</td>
</tr>
<tr>
<td>Company4</td>
<td>4</td>
<td>250</td>
</tr>
<tr>
<td>Company5</td>
<td>5</td>
<td>300</td>
</tr>
</tbody></table>
<h1 id="Q9"><a href="#Q9" class="headerlink" title="Q9"></a>Q9</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> r.RegionDescription, e.FirstName, e.LastName, <span class="built_in">MAX</span>(e.BirthDate)</span><br><span class="line"><span class="keyword">FROM</span> Region r</span><br><span class="line"><span class="keyword">JOIN</span> Territory t <span class="keyword">ON</span> t.RegionId <span class="operator">=</span> r.Id</span><br><span class="line"><span class="keyword">JOIN</span> EmployeeTerritory et <span class="keyword">ON</span> et.TerritoryId <span class="operator">=</span> t.Id</span><br><span class="line"><span class="keyword">JOIN</span> Employee e <span class="keyword">On</span> e.Id <span class="operator">=</span> et.EmployeeId</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t.RegionId;</span><br><span class="line"></span><br><span class="line">Eastern<span class="operator">|</span>Steven<span class="operator">|</span>Buchanan<span class="operator">|</span><span class="number">1987</span><span class="number">-03</span><span class="number">-04</span></span><br><span class="line">Western<span class="operator">|</span>Michael<span class="operator">|</span>Suyama<span class="operator">|</span><span class="number">1995</span><span class="number">-07</span><span class="number">-02</span></span><br><span class="line">Northern<span class="operator">|</span>Anne<span class="operator">|</span>Dodsworth<span class="operator">|</span><span class="number">1998</span><span class="number">-01</span><span class="number">-27</span></span><br><span class="line">Southern<span class="operator">|</span>Janet<span class="operator">|</span>Leverling<span class="operator">|</span><span class="number">1995</span><span class="number">-08</span><span class="number">-30</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="built_in">MAX</span>(e.BirthDate)</span><br></pre></td></tr></table></figure>

<h1 id="Q10"><a href="#Q10" class="headerlink" title="Q10"></a>Q10</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> temptable <span class="keyword">AS</span>(</span><br><span class="line">                  <span class="keyword">SELECT</span> </span><br><span class="line">                    d.ProductName myproductname,</span><br><span class="line">                    strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>, b.OrderDate) <span class="type">date</span></span><br><span class="line">                  <span class="keyword">FROM</span> Customer a, [<span class="keyword">Order</span>] b, OrderDetail c, Product d</span><br><span class="line">                  <span class="keyword">WHERE</span> a.Id <span class="operator">=</span> b.CustomerId </span><br><span class="line">                    <span class="keyword">AND</span> b.Id <span class="operator">=</span> c.OrderId </span><br><span class="line">                    <span class="keyword">AND</span> c.ProductId <span class="operator">=</span> d.Id </span><br><span class="line">                    <span class="keyword">AND</span> a.CompanyName <span class="operator">=</span> <span class="string">&#x27;Queen Cozinha&#x27;</span> </span><br><span class="line">                    <span class="keyword">AND</span> <span class="type">date</span> <span class="operator">=</span> <span class="string">&#x27;2014-12-25&#x27;</span></span><br><span class="line">                  <span class="keyword">ORDER</span> <span class="keyword">BY</span> d.Id <span class="keyword">ASC</span>)</span><br><span class="line"><span class="keyword">SELECT</span> group_concat(myproductname)</span><br><span class="line"><span class="keyword">FROM</span> temptable;</span><br><span class="line"></span><br><span class="line">Mishi Kobe Niku,NuNuCa Nuß<span class="operator">-</span>Nougat<span class="operator">-</span>Creme,Schoggi Schokolade,Mascarpone Fabioli,Sasquatch Ale,Boston Crab Meat,Manjimup Dried Apples,Longlife Tofu,Lakkalikööri</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>, b.OrderDate) <span class="type">date</span>  </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> 将日期和时间格式化为字符串，将原始日期格式转换为 &quot;年-月-日&quot; 的字符串格式</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Project</category>
        <category>cmu15-445</category>
      </categories>
  </entry>
  <entry>
    <title>cmu15-445 Project 0 (Spring 2023)</title>
    <url>/2024/02/28/Project/cmu15-445/cmu15-445%20Project%200%20(Spring%202023)%20%20/</url>
    <content><![CDATA[<h1 id="Task-1-Copy-On-Write-Trie"><a href="#Task-1-Copy-On-Write-Trie" class="headerlink" title="Task #1 - Copy-On-Write Trie"></a>Task #1 - Copy-On-Write Trie</h1><p>在<code>trie.cpp</code>中实现<code>COW Trie</code>。</p>
<p><code>COW</code>即代表，对<code>Trie</code>的添加&#x2F;删除操作不会在原<code>Trie</code>上进行，而是对原<code>Trie</code>进行拷贝后再进行修改。</p>
<span id="more"></span>

<p><code>trie.h</code>中共有三个类：</p>
<ul>
<li>​	<code>TrieNode</code>：表示Trie树不包含value的普通节点。<ul>
<li>组成：<ul>
<li><code>bool is_value_node_&#123;false&#125;;</code></li>
<li><code>std::map&lt;char, std::shared_ptr&lt;const TrieNode&gt;&gt; children_;</code></li>
</ul>
</li>
</ul>
</li>
<li><code>TrieNodeWithValue</code>：<code>Trie</code>树包含<code>value</code>的节点，由<code>TrieNode</code>派生而来。<ul>
<li>新增组成：<ul>
<li><code>std::shared_ptr&lt;T&gt; value_;</code></li>
</ul>
</li>
</ul>
</li>
<li><code>Trie</code>：<code>Trie</code> 树的本体，<ul>
<li>组成：<ul>
<li><code>std::shared_ptr&lt;const TrieNode&gt; root_&#123;nullptr&#125;;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注意：</p>
<p>1、一个 <code>shared_ptr&lt;const TrieNode&gt;</code> 智能指针（<code>root</code>）指向一个 <code>TrieNode</code> 节点，而 <code>TrieNode</code> 节点中的 <code>map</code> 则含有多个可以指向下一个 <code>TrieNode</code> 节点的智能指针。也就是说，当 <code>TrieNode</code> 调用 <code>Clone()</code> 时，会复制一份<strong>当前节点</strong>并返回。由于返回的是 <code>unique_ptr</code>，因此我们只能用 <code>shared_ptr</code> 的构造函数来接收，然后再对 <code>shared_ptr</code> 进行赋值，类似于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;TrieNode&gt; new_root = std::<span class="built_in">shared_ptr</span>&lt;TrieNode&gt;(<span class="keyword">this</span>-&gt;root_-&gt;<span class="built_in">Clone</span>());</span><br></pre></td></tr></table></figure>

<h2 id="1、Get-key"><a href="#1、Get-key" class="headerlink" title="1、Get(key)"></a>1、<code>Get(key)</code></h2><p>（1）考虑<code>key</code>为空的边界情况，此时看<code>root</code>是否是一个<code>TrieNodeWithVal</code>节点；</p>
<p>（2）考虑<code>root</code>为空的边界情况，此时直接返回一个<code>nullptr</code>；</p>
<p>（3）若非上述两种边界情况，则通过遍历进行<code>Get</code>操作：</p>
<ul>
<li>定义一个<code>cur</code>指向当前根节点，注意<code>root</code>的类型是<code>std::shared_ptr&lt;const bustub::TrieNode&gt;</code></li>
<li>对<code>key</code>的所有字符进行遍历，<code>cur</code>不断更新迭代指向<code>cur-&gt;children-&gt;second</code>，直到找到<code>key</code>的键尾为止；</li>
<li>判断此时的<code>cur</code>是否是一个<code>TrieNodeWithVal</code>节点</li>
</ul>
<p>注意：返回的<code>value</code>——<code>std::shared_ptr&lt;T&gt; value_</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> *twnv = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> bustub::TrieNodeWithValue&lt;T&gt; *&gt;(root_.<span class="built_in">get</span>());</span><br><span class="line"><span class="comment">// const确保twnv是一个指向常量对象的指针，最好保留以明确这种限制</span></span><br><span class="line"><span class="comment">// dynamic_cast的目的是为了检查在运行时root_所指向的对象是否实际上是TrieNodeWithValue&lt;T&gt;或其派生类型</span></span><br></pre></td></tr></table></figure>

<h2 id="2、Put-key-value"><a href="#2、Put-key-value" class="headerlink" title="2、Put(key, value)"></a>2、<code>Put(key, value)</code></h2><p><code>Put</code>操作最需要注意的点在于：在插入时，已有的节点执行<code>Clone()</code>操作，新建的节点执行<code>make_shared</code>操作，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/b8962d07c7484d00bdb71214b75ea157.png#pic_center" alt="在这里插入图片描述"></p>
<p>逻辑如下：</p>
<p>（1）考虑<code>key</code>为空的边界情况，此时在<code>root</code>处插入</p>
<ul>
<li>创建新的<code>shared_ptr</code>指针指向<code>value</code>和为空的<code>new_root</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;T&gt; val_p = std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">std::shared_ptr&lt;bustub::TrieNodeWithValue&lt;T&gt;&gt; new_root = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>判断原<code>root</code>是否有子节点，处理后返回新的<code>Trie</code>的根结点<code>new_root</code></p>
<ul>
<li><p>若无，则直接对<code>new_root</code>进行修改；</p>
</li>
<li><p>若有，则构造一个新节点指向<code>root</code>的<code>children</code>，如图</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403011541108.png" alt="image-20240301154103793"></p>
</li>
</ul>
</li>
</ul>
<p>（2）若<code>key</code>非空</p>
<ul>
<li><p>首先拷贝根节点<code>root</code></p>
<ul>
<li>若<code>root</code>空，直接新建空的<code>Trie</code></li>
<li>若<code>root</code>非空，调用<code>Clone()</code>操作，拷贝<code>root</code>的已有<code>children</code>给<code>new_root</code></li>
</ul>
</li>
<li><p><code>Put1()</code>函数递归插入</p>
<ul>
<li><p>遍历<code>new_root</code>的<code>children</code>，找到是否有哪一个<code>children</code>的<code>key</code>等于传入<code>key</code>的<code>key[0]</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pair : new_root-&gt;children_) &#123;&#125;</span><br><span class="line"><span class="comment">// pari类型：std::map&lt;char, std::shared_ptr&lt;const TrieNode&gt;&gt; children</span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断完<code>key[0]</code>后，对<code>key</code>剩余的值进行判断<ul>
<li>若到达<code>key</code>的键尾，新建一个节点并覆盖掉<code>pair</code>的<code>second</code></li>
<li>若未到达键尾，拷贝已有节点、递归调用<code>Put1</code>写入<code>key</code>、将写入完成后的节点重新拷贝给<code>pair.second</code></li>
</ul>
</li>
</ul>
</li>
<li><p>若未找到匹配的<code>key[0]</code>，则直接新建节点插入。注意判断<code>key</code>的长度以决定是否需要递归操作。</p>
</li>
</ul>
</li>
<li><p>返回新的<code>Trie</code></p>
</li>
</ul>
<p>注意：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;bustub::TrieNode&gt; ptr = pair.second-&gt;<span class="built_in">Clone</span>();</span><br><span class="line"><span class="comment">// Clone()返回的对象是std::unique_ptr&lt;TrieNode&gt;类型，为了确保ptr能够在程序的其他地方被共享所有权，因此</span></span><br><span class="line"><span class="comment">// 用std::shared_ptr&lt;bustub::TrieNode&gt;接收</span></span><br></pre></td></tr></table></figure>

<h2 id="3、Remove-key"><a href="#3、Remove-key" class="headerlink" title="3、Remove(key)"></a>3、<code>Remove(key)</code></h2><p><code>Remove</code>的思想和<code>Put</code>一致，不再赘述。</p>
<h1 id="Task-2-Concurrent-Key-Value-Store"><a href="#Task-2-Concurrent-Key-Value-Store" class="headerlink" title="Task #2 - Concurrent Key-Value Store"></a>Task #2 - Concurrent Key-Value Store</h1><p>注意加锁的时机即可。</p>
<p><code>read</code>操作只需要在获取根节点时加锁。</p>
<p><code>write</code>操作则需要全程添加写锁，从而保证只有一名<code>writer</code>。此外，在获取根节点和更新修改后的根结点时，需要添加读锁。</p>
]]></content>
      <categories>
        <category>Project</category>
        <category>cmu15-445</category>
      </categories>
  </entry>
  <entry>
    <title>cmu15-445 Project 1 (Spring 2023)</title>
    <url>/2024/03/02/Project/cmu15-445/cmu15-445%20Project%201%20(Spring%202023)/</url>
    <content><![CDATA[<h1 id="Task-1-LRU-K-Replacement-Policy"><a href="#Task-1-LRU-K-Replacement-Policy" class="headerlink" title="Task #1 - LRU-K Replacement Policy"></a>Task #1 - LRU-K Replacement Policy</h1><p>跟踪缓冲池中页面的使用情况，用于记录、更新以及删除页<code>(frame)</code>。</p>
<p><code>src/include/buffer/lru_k_replacer.h</code>  &#x3D;&#x3D;&gt; 实现<code>LRUKReplacer</code>的新类，且独立</p>
<p><code>src/buffer/lru_k_replacer.cpp</code> &#x3D;&#x3D;&gt; 对应实现，实现<code>LRU-K</code>替换策略。</p>
<span id="more"></span>

<p><code>LRU-K</code>将替换帧中<code>backward k-distance</code>最大的帧剔除。<code>backward k-distance</code>计算的是当前时间戳与前<code>k</code>次访问的时间戳之差。</p>
<p>历史链表：记录出现的历史时间戳，新的时间戳追加到链表尾部；</p>
<p><code>k-distance</code>：若出现此时小于<code>k</code>，则为无穷大；若大于等于<code>k</code>，则对应为历史链表头部；</p>
<p>驱逐方法：1）优先驱逐<code>k-distance</code>为无穷大的页，且按照<code>FIFO</code>的策略进行驱逐；2）若无无穷大的页，则驱逐<code>k-distance</code>最小的页（说明其倒数第<code>k</code>次出现最遥远，时间局部性更弱）。</p>
<h2 id="Task1踩坑处"><a href="#Task1踩坑处" class="headerlink" title="Task1踩坑处"></a>Task1踩坑处</h2><h3 id="（1）-15634-ERROR-AddressSanitizer-attempting-free-on-address-which-was-not-malloc-ed-0x7ffd62284260-in-thread-T0"><a href="#（1）-15634-ERROR-AddressSanitizer-attempting-free-on-address-which-was-not-malloc-ed-0x7ffd62284260-in-thread-T0" class="headerlink" title="（1）&#x3D;&#x3D;15634&#x3D;&#x3D;ERROR: AddressSanitizer: attempting free on address which was not malloc()-ed: 0x7ffd62284260 in thread T0"></a>（1）&#x3D;&#x3D;15634&#x3D;&#x3D;ERROR: AddressSanitizer: attempting free on address which was not malloc()-ed: 0x7ffd62284260 in thread T0</h3><p>表明在试图释放一个未经 malloc 分配的地址。</p>
<p>错误代码处为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// history 已满，更新 history</span></span><br><span class="line">node.history_.<span class="built_in">pop_front</span>();</span><br><span class="line">node.history_.<span class="built_in">push_back</span>(current_timestamp_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 more</span></span><br><span class="line">node_more_k_.<span class="built_in">erase</span>(node_more_k_.<span class="built_in">find</span>(&amp;node)); </span><br><span class="line">node_more_k_.<span class="built_in">insert</span>(&amp;node);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">node_more_k_.<span class="built_in">erase</span>(node_more_k_.<span class="built_in">find</span>(&amp;node));  <span class="comment">// here</span></span><br></pre></td></tr></table></figure>

<p>在 C++ 的 <code>std::set</code> 中，<code>erase</code> 函数会删除指定的元素，但不会直接释放其内存。相反，它会调用元素类型的析构函数，然后将元素从 <code>std::set</code> 中移除。然而这里尝试擦除的是一个指向局部对象 <code>node</code> 的指针，而不是指向 <code>std::set</code> 中元素的指针。一旦 <code>node</code> 超出作用域，其地址将变为无效地址。因此，这样的写法可能导致悬垂指针问题，当再次访问 <code>node_more_k_</code> 时，可能会引发未定义行为或崩溃。</p>
<p>修正后为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// history 已满，更新 history</span></span><br><span class="line">LRUKNode&amp; tmp = node;</span><br><span class="line">node_more_k_.<span class="built_in">erase</span>(&amp;node);</span><br><span class="line"><span class="comment">// 更新 more</span></span><br><span class="line">tmp.history_.<span class="built_in">pop_front</span>();</span><br><span class="line">tmp.history_.<span class="built_in">push_back</span>(current_timestamp_);</span><br><span class="line">node_more_k_.<span class="built_in">insert</span>(&amp;tmp);</span><br></pre></td></tr></table></figure>

<h3 id="（2）-17474-ERROR-LeakSanitizer-detected-memory-leaks"><a href="#（2）-17474-ERROR-LeakSanitizer-detected-memory-leaks" class="headerlink" title="（2）&#x3D;&#x3D;17474&#x3D;&#x3D;ERROR: LeakSanitizer: detected memory leaks"></a>（2）&#x3D;&#x3D;17474&#x3D;&#x3D;ERROR: LeakSanitizer: detected memory leaks</h3><p>表明存在内存泄漏问题。</p>
<p>错误代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果在node_store_中没有找到对应的元素，创建一个新的LRUKNode</span></span><br><span class="line"><span class="keyword">auto</span> *new_node = <span class="keyword">new</span> <span class="built_in">LRUKNode</span>();</span><br><span class="line">new_node-&gt;fid_ = frame_id;</span><br><span class="line">new_node-&gt;history_.<span class="built_in">push_back</span>(current_timestamp_);</span><br><span class="line">new_node-&gt;k_ = <span class="keyword">this</span>-&gt;k_;</span><br><span class="line"></span><br><span class="line">node_store_[frame_id] = *new_node;</span><br><span class="line">node_less_k_.<span class="built_in">insert</span>(node_less_k_.<span class="built_in">end</span>(), new_node);</span><br><span class="line">node_store_[frame_id].pos_ = std::<span class="built_in">prev</span>(node_less_k_.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>上述代码中，由于<code>node_store_</code> 的声明是 <code>std::unordered_map&lt;frame_id_t, LRUKNode&gt;</code>，这表示它存储的是 <code>LRUKNode</code> 对象的副本而不是指针。因此在使用<code>new</code>运算符分配内存后，将对象的副本赋值给了<code>node_store_[frame_id]</code>，而不是直接将指针存储在<code>node_store_</code>中。</p>
<p>改正的方式是直接存储指向动态分配的对象的指针，而不是对象的副本。同时，应该考虑采用智能指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::unordered_map&lt;<span class="type">frame_id_t</span>, std::shared_ptr&lt;LRUKNode&gt;&gt; node_store_;</span><br><span class="line">std::list&lt;std::shared_ptr&lt;LRUKNode&gt;&gt; node_less_k_;  <span class="comment">// 访问 k 次以下的页面，FIFO 队列</span></span><br><span class="line">std::set&lt;std::shared_ptr&lt;LRUKNode&gt;, MyCompare&gt; node_more_k_;  <span class="comment">// 访问 k 次以上的页面，LRU 队列</span></span><br></pre></td></tr></table></figure>

<p>此时上述代码可修改为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> new_node = std::<span class="built_in">make_shared</span>&lt;LRUKNode&gt;();</span><br><span class="line">new_node-&gt;fid_ = frame_id;</span><br><span class="line">new_node-&gt;history_.<span class="built_in">push_back</span>(current_timestamp_);</span><br><span class="line">new_node-&gt;k_ = <span class="keyword">this</span>-&gt;k_;</span><br><span class="line"></span><br><span class="line">node_store_[frame_id] = new_node;</span><br><span class="line">node_less_k_.<span class="built_in">insert</span>(node_less_k_.<span class="built_in">end</span>(), new_node);</span><br><span class="line">node_store_[frame_id]-&gt;pos_ = std::<span class="built_in">prev</span>(node_less_k_.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h1 id="Task-2-Buffer-Pool-Manager"><a href="#Task-2-Buffer-Pool-Manager" class="headerlink" title="Task #2 - Buffer Pool Manager"></a>Task #2 - Buffer Pool Manager</h1><blockquote>
<p><code>BufferPoolManager</code>负责从<code>DiskManager</code>抓取数据库页面并将其存储到内存中。<code>BufferPoolManager</code>还可以在收到明确指示或需要删除页面以便为新页面腾出空间时，将脏页面写入磁盘。</p>
<p>实际读取和写入磁盘数据的代码已经写好，不需要自己实现（<code>DiskManager</code>）。</p>
<p>系统中的所有内存页面都由<code>Page</code>对象表示。缓冲池管理器无需了解这些页面的内容。但作为系统开发人员，您必须明白，<code>Page</code>对象只是缓冲池中内存的容器，因此并不特定于某个页面。也就是说，每个页面对象都包含一个内存块，<code>DiskManager</code>将把它用作从磁盘读取物理页面内容的复制位置。<strong>缓冲池管理器（<code>BufferPoolManager</code>）会重复使用同一个页面对象来存储数据，因为数据会在磁盘上来回移动。这意味着，在系统的整个生命周期中，同一个页面对象可能包含不同的物理页面。</strong>页面对象的标识符（<code>page_id</code>）可追踪其包含的物理页面；如果页面对象不包含物理页面，则其<code>page_id</code>必须设置为<code>INVALID_PAGE_ID</code>。每个页面对象还维护一个计数器，用于记录 “钉住 “该页面的线程数。缓冲池管理器不允许释放被钉住的页面。每个页面对象也会记录它是否变脏。你的工作就是记录页面在解除固定前是否被修改过。<code>BufferPoolManager</code>必须先将脏页面的内容写回磁盘，然后才能重新使用该对象。</p>
<p>您的<code>BufferPoolManager</code>实现将使用您在本作业前几步中创建的<code>LRUKReplacer</code>类。<code>LRUKReplacer</code>将跟踪页面对象被访问的时间，以便在必须释放帧以腾出空间从磁盘复制新的物理页面时，决定驱逐哪个页面对象。在<code>BufferPoolManager</code>中将<code>page_id</code>映射到<code>frame_id</code>时，请再次注意 STL 容器不是线程安全的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Page *pages_;  <span class="comment">// 数组，索引为frame_id</span></span><br><span class="line">std::unordered_map&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; page_table_;  <span class="comment">// 即内存，存放page_id与frame_id的映射</span></span><br><span class="line">std::unique_ptr&lt;LRUKReplacer&gt; replacer_;</span><br><span class="line">std::list&lt;<span class="type">frame_id_t</span>&gt; free_list_;  <span class="comment">// 记录哪些位置为空</span></span><br><span class="line">std::mutex latch_;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>NewPage</code>：<ul>
<li>先在内存里(<code>free_list_</code>)找到一个空<code>frame</code>;</li>
<li>若没有，则替换出一个可驱逐的<code>replacement frame</code>，并更新访问历史和不可驱逐状态，注意若包含<code>dirty page</code>，则先将脏数据写回<code>disk</code>；</li>
<li>创建新<code>page</code>；</li>
<li>写回内存（<code>page_table_</code>）。</li>
</ul>
</li>
<li><code>FetchPage</code>：<ul>
<li>找<code>page_id</code>对应的页：<ul>
<li>先在<code>page_table_</code>中查找是否有<code>page_id</code>对应的页：<ul>
<li>若找到，<code>pin_count_</code>自增；</li>
<li>更新<code>frame</code>的访问历史，设置不可驱逐状态；</li>
</ul>
</li>
<li>若内存没有，则在<code>disk</code>中找，并在内存中腾出一个空位（<code>replacer_</code>）：<ul>
<li>若<code>replacement frame</code>包含<code>dirty page</code>，则先将脏数据写回<code>disk</code>；</li>
<li>更新<code>frame</code>的访问历史，设置不可驱逐状态；</li>
<li>在<code>disk</code>中读取该<code>page</code>的内容并写入；</li>
<li>写回内存（<code>page_table_</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>UnpinPage</code>：<ul>
<li>若<code>page_id</code>不存在，直接返回；</li>
<li>若存在，但<code>unpin</code>后<code>pin_count_</code>为<code>0</code>，也直接返回，并设置<code>frame</code>可驱逐；</li>
<li>除此之外，注意此处应该为：<code>pages_[frame_id].is_dirty_ |= is_dirty;</code>。</li>
</ul>
</li>
</ul>
<h2 id="Task2踩坑处"><a href="#Task2踩坑处" class="headerlink" title="Task2踩坑处"></a>Task2踩坑处</h2><h3 id="（1）unknown-file-Failure-C-exception-with-description-“The-id-not-found-in-cache”-thrown-in-the-test-body"><a href="#（1）unknown-file-Failure-C-exception-with-description-“The-id-not-found-in-cache”-thrown-in-the-test-body" class="headerlink" title="（1）unknown file: Failure C++ exception with description “The id not found in cache” thrown in the test body."></a>（1）unknown file: Failure C++ exception with description “The id not found in cache” thrown in the test body.</h3><p>一个很粗心的错误，那就是<code>RecordAccess</code>和<code>SetEvictable</code>的顺序搞反了。</p>
<p>正确的顺序应该是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">replacer_-&gt;<span class="built_in">RecordAccess</span>(frame_id);</span><br><span class="line">replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="（2）ERROR-AddressSanitizer-SEGV-on-unknown-address-0x000000000000-pc-0x7fb0fb78fdbe-bp-0x61a0000002d0-sp-0x7ffd1c504cc0-T0-、"><a href="#（2）ERROR-AddressSanitizer-SEGV-on-unknown-address-0x000000000000-pc-0x7fb0fb78fdbe-bp-0x61a0000002d0-sp-0x7ffd1c504cc0-T0-、" class="headerlink" title="（2）ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7fb0fb78fdbe bp 0x61a0000002d0 sp 0x7ffd1c504cc0 T0)、"></a>（2）ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7fb0fb78fdbe bp 0x61a0000002d0 sp 0x7ffd1c504cc0 T0)、</h3><p>这个错误是由于在程序执行期间发生了段错误（<code>Segmentation Fault</code>），导致程序崩溃。</p>
<p>根据错误信息，问题出现在调用 <code>std::basic_streambuf&lt;char, std::char_traits&lt;char&gt;&gt;::xsgetn(char*, long)</code> 函数时，发生了对未知地址的写操作，这可能是由于访问了空指针或者其他非法内存区域引起的。</p>
<p>引起错误的代码行为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">page0 = bpm-&gt;<span class="built_in">FetchPage</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"><span class="type">char</span> *page_data = <span class="literal">nullptr</span>;</span><br><span class="line">disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, page_data);</span><br></pre></td></tr></table></figure>

<p>报错的原因可能是因为 <code>disk_manager_-&gt;ReadPage</code> 函数中的 <code>page_data</code> 参数被传入了空指针。在 C&#x2F;C++ 中，如果要通过函数修改指针指向的内存内容，需要确保传入的指针指向有效的内存空间，而不是空指针。</p>
<p>这里实际上应该直接传入<code>pages_[frame_id].dara_</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, pages_[frame_id].data_);</span><br></pre></td></tr></table></figure>

<h1 id="Task-3-Read-Write-Page-Guards"><a href="#Task-3-Read-Write-Page-Guards" class="headerlink" title="Task #3 - Read&#x2F;Write Page Guards"></a>Task #3 - Read&#x2F;Write Page Guards</h1><blockquote>
<p>您将实现BasicPageGuard，它存储指向BufferPoolManager和Page对象的指针。页面保护确保在相应的page对象超出作用域时立即在其上调用UnpinPage。注意，它仍然应该为程序员提供一个方法来手动解除页面的锁定。</p>
<p>由于BasicPageGuard隐藏了底层的Page指针，它还可以提供只读&#x2F;写数据api，提供编译时检查，以确保针对每种用例正确设置is_dirty标志。</p>
<p>在未来的项目中，多个线程将从同一个页面读取和写入，因此需要读写锁存器来确保数据的正确性。请注意，在Page类中，有用于此目的的相关锁存方法。与页面的解锁类似，程序员在使用页面后可能会忘记解锁页面。为了缓解这个问题，你将实现ReadPageGuard和WritePageGuard，它们会在页面超出范围时自动解锁。</p>
<p>你需要为所有的BasicPageGuard, ReadPageGuard和WritePageGuard实现以下函数。</p>
<ul>
<li><code>PageGuard(PageGuard &amp;&amp;that)</code> : Move constructor.</li>
<li><code>operator=(PageGuard &amp;&amp;that)</code> : Move operator.</li>
<li><code>Drop()</code> : Unpin and&#x2F;or unlatch.</li>
<li><code>~PageGuard()</code> : Destructor.</li>
</ul>
<p>使用新的页面保护，在BufferPoolManager中实现以下wrappers。</p>
<ul>
<li><code>FetchPageBasic(page_id_t page_id)</code></li>
<li><code>FetchPageRead(page_id_t page_id)</code></li>
<li><code>FetchPageWrite(page_id_t page_id)</code></li>
<li><code>NewPageGuarded(page_id_t *page_id)</code></li>
</ul>
</blockquote>
<p>这个<code>task</code>的重点就是实现移动构造、移动幅值、<code>Drop</code>和析构这四个函数。</p>
<h1 id="GradeScope在线测试"><a href="#GradeScope在线测试" class="headerlink" title="GradeScope在线测试"></a>GradeScope在线测试</h1><h2 id="1、LRUKReplacerTest-Evict"><a href="#1、LRUKReplacerTest-Evict" class="headerlink" title="1、LRUKReplacerTest.Evict"></a>1、LRUKReplacerTest.Evict</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19: /autograder/source/bustub/test/buffer/grading_lru_k_replacer_test.cpp:276: Failure</span><br><span class="line">19: Expected equality of these values:</span><br><span class="line">19:   i</span><br><span class="line">19:     Which is: 100</span><br><span class="line">19:   result</span><br><span class="line">19:     Which is: 0</span><br><span class="line">19: Check your return value behavior for LRUKReplacer::Evict</span><br></pre></td></tr></table></figure>

<p>这个问题我真的研究了很久，本地测试和前面的一大部分在线测试都可以过，但是就是卡在这里。后来查了很久，知乎上有一个博主说是发现他的<code>LRUKReplacer::Remove</code>。于是我去检查了我的<code>Remove</code>函数，发现我也没有写完……我只在<code>node_store_</code>中进行了删除，而没有在<code>node_less_k_</code>或者<code>node_more_k_</code>中删除，补上后这个测试就通过了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (it-&gt;second-&gt;is_evictable_) &#123;</span><br><span class="line">      <span class="comment">// 该帧为可驱逐状态，继续操作</span></span><br><span class="line">      it-&gt;second-&gt;history_.<span class="built_in">clear</span>();</span><br><span class="line">      <span class="comment">// -------- add ------------------------------ //</span></span><br><span class="line">      <span class="keyword">if</span> (it-&gt;second-&gt;pos_ != node_less_k_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        node_less_k_.<span class="built_in">erase</span>(it-&gt;second-&gt;pos_);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node_more_k_.<span class="built_in">erase</span>(it-&gt;second);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// -------- add ------------------------------ //</span></span><br><span class="line">      node_store_.<span class="built_in">erase</span>(it);</span><br><span class="line">      curr_size_--;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、BufferPoolManagerTest-UnpinPage"><a href="#2、BufferPoolManagerTest-UnpinPage" class="headerlink" title="2、BufferPoolManagerTest.UnpinPage"></a>2、BufferPoolManagerTest.UnpinPage</h2><h3 id="DeletePage"><a href="#DeletePage" class="headerlink" title="DeletePage"></a>DeletePage</h3><p>[*]Bug:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">------------------------------------------</span><br><span class="line"><span class="number">7</span>: UnpinPage: <span class="number">0</span></span><br><span class="line"><span class="number">7</span>: --- Before UnpinPage: --- </span><br><span class="line"><span class="number">7</span>: ---page_table size: <span class="number">2</span></span><br><span class="line"><span class="number">7</span>: ---page_table content:</span><br><span class="line"><span class="number">7</span>: page_id: <span class="number">1</span>, frame_id: <span class="number">1</span>, pin_count: <span class="number">1</span>, page_data: page1</span><br><span class="line"><span class="number">7</span>: page_id: <span class="number">0</span>, frame_id: <span class="number">0</span>, pin_count: <span class="number">1</span>, page_data: page0</span><br><span class="line"><span class="number">7</span>: ---free_list size: <span class="number">0</span></span><br><span class="line"><span class="number">7</span>: ---free_list Content:</span><br><span class="line"><span class="number">7</span>: </span><br><span class="line"><span class="number">7</span>: --- After UnpinPage: --- </span><br><span class="line"><span class="number">7</span>: ---page_table size: <span class="number">1</span></span><br><span class="line"><span class="number">7</span>: ---page_table content:</span><br><span class="line"><span class="number">7</span>: page_id: <span class="number">1</span>, frame_id: <span class="number">1</span>, pin_count: <span class="number">1</span>, page_data: page1</span><br><span class="line"><span class="number">7</span>: ---free_list size: <span class="number">0</span></span><br><span class="line"><span class="number">7</span>: ---free_list Content:  <span class="comment">// free_list的更新出错</span></span><br></pre></td></tr></table></figure>

<p>要在DeletePage中实现将不再使用的frame从Replacer中删除，并重新放入free_list中</p>
<h3 id="NewPage"><a href="#NewPage" class="headerlink" title="NewPage"></a>NewPage</h3><ul>
<li>通过evict获取frame时，要先删除其上的old page</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">page_table_.<span class="built_in">erase</span>(pages_[frame_id].page_id_);  <span class="comment">// debug</span></span><br></pre></td></tr></table></figure>

<h3 id="FetchPage"><a href="#FetchPage" class="headerlink" title="FetchPage"></a>FetchPage</h3><ul>
<li><p>同NewPage，通过evict获取frame时，要先删除其上的old page；</p>
</li>
<li><p>若在内存中没找到对应的page，而需要从disk中获取时，注意除了要在page_table中绑定page_id和frame_id，还要在pages_对象中更新page_id和frame_id的绑定关系</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pages_[frame_id].page_id_ = page_id;  <span class="comment">// debug</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在fetch一个page后，更新其dirty状态为false，因为此时的page刚从disk写完数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pages_[frame_id].is_dirty_ = <span class="literal">false</span>;  <span class="comment">// debug</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、BufferPoolManagerTest-ConcurrencyTest"><a href="#3、BufferPoolManagerTest-ConcurrencyTest" class="headerlink" title="3、BufferPoolManagerTest.ConcurrencyTest"></a>3、BufferPoolManagerTest.ConcurrencyTest</h2><p>问题出在每个函数的加锁写在了日志打印后面，因此出现并发错误。</p>
<h2 id="4、PageGuardTest-DropTest-PageGuardTest-MoveTest"><a href="#4、PageGuardTest-DropTest-PageGuardTest-MoveTest" class="headerlink" title="4、PageGuardTest.DropTest &amp;&amp; PageGuardTest.MoveTest"></a>4、PageGuardTest.DropTest &amp;&amp; PageGuardTest.MoveTest</h2><blockquote>
<p>PageGuardTest.DropTest (0&#x2F;8)<br>PageGuardTest.MoveTest (0&#x2F;8)<br>PageGuardTest.BPMTest (0&#x2F;9)</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403241940804.png" alt="image-20240324194001569"></p>
<p>经过研究，我重写了PageGuard.cpp中几个函数的逻辑：</p>
<h3 id="BasicPageGuard"><a href="#BasicPageGuard" class="headerlink" title="BasicPageGuard"></a>BasicPageGuard</h3><h4 id="（1）Drop"><a href="#（1）Drop" class="headerlink" title="（1）Drop()"></a>（1）Drop()</h4><p>忘记了对bpm_重置为nullptr;</p>
<h4 id="（2）operator-BasicPageGuard-that"><a href="#（2）operator-BasicPageGuard-that" class="headerlink" title="（2）operator&#x3D;(BasicPageGuard &amp;&amp;that)"></a>（2）operator&#x3D;(BasicPageGuard &amp;&amp;that)</h4><p>注意要先调用<code>Drop()</code>来drop掉当前的old guarded page，然后再进行资源转移。</p>
<h3 id="ReadPageGuard"><a href="#ReadPageGuard" class="headerlink" title="ReadPageGuard"></a>ReadPageGuard</h3><h4 id="（1）ReadPageGuard-ReadPageGuard-that"><a href="#（1）ReadPageGuard-ReadPageGuard-that" class="headerlink" title="（1）ReadPageGuard(ReadPageGuard &amp;&amp;that)"></a>（1）ReadPageGuard(ReadPageGuard &amp;&amp;that)</h4><p>虽然.cpp文件中写的是<code>=default</code>，但.h文件中又要求实现，所以还是实现了一下。</p>
<h4 id="（2）operator-ReadPageGuard-that"><a href="#（2）operator-ReadPageGuard-that" class="headerlink" title="（2）operator&#x3D;(ReadPageGuard &amp;&amp;that)"></a>（2）operator&#x3D;(ReadPageGuard &amp;&amp;that)</h4><p>这里我最开始只调用了<code>std::move(that.guard_)</code>，实际上应该1)先在page_不为空时进行解读锁；2)然后进行资源转移。</p>
<h4 id="（3）Drop"><a href="#（3）Drop" class="headerlink" title="（3）Drop()"></a>（3）Drop()</h4><p>这里和重载移动赋值运算符一样，最开始只调用了<code>Drop()</code>，而实际上也应该先解读锁。</p>
<h3 id="WritePageGuard"><a href="#WritePageGuard" class="headerlink" title="WritePageGuard"></a>WritePageGuard</h3><p>和ReadPageGuard同理。</p>
<p>最后，历时许久，第一个Project终于通过了！</p>
]]></content>
      <categories>
        <category>Project</category>
        <category>cmu15-445</category>
      </categories>
  </entry>
  <entry>
    <title>cmu15-445 Project 2 (Spring 2023)</title>
    <url>/2024/03/27/Project/cmu15-445/cmu15-445%20Project%202%20(Spring%202023)/</url>
    <content><![CDATA[<p>Overview：</p>
<blockquote>
<p>In this programming project you will implement a <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+Tree</a> index in your database system. <strong>A B+Tree is a balanced search tree in which the internal pages direct the search and leaf pages contain the actual data entries.</strong> The index provides fast data retrieval without needing to search every row in a database table, enabling rapid random lookups and efficient scans of ordered records. Your implementation will support thread-safe search, insertion, deletion (including splitting and merging nodes), and an iterator to support in-order leaf scans.</p>
<p>在这个编程项目中，您将在数据库系统中实现B+树索引。B+树是一种平衡搜索树，其中internal pages指导搜索，leaf pages包含实际的数据项。索引提供了快速的数据检索，而不需要搜索数据库表中的每一行，支持快速随机查找和高效的有序记录扫描。你的实现将支持<strong>线程安全</strong>的搜索、插入、删除(包括节点拆分和合并)，以及一个支持按序叶扫描的迭代器。</p>
</blockquote>
<span id="more"></span>

<p>Project2的实现依赖于Project1的buffer pool和page guards。</p>
<h1 id="Checkpoint-1-15-points"><a href="#Checkpoint-1-15-points" class="headerlink" title="Checkpoint #1 (15 points)"></a><strong>Checkpoint #1 (15 points)</strong></h1><h2 id="Task-1-B-Tree-Pages"><a href="#Task-1-B-Tree-Pages" class="headerlink" title="Task #1 - B+Tree Pages"></a>Task #1 - B+Tree Pages</h2><p>实现三个Page Classes去存储B+Tree的数据：</p>
<ul>
<li><p>B+Tree Page</p>
<ul>
<li>Base class，以供下面两个类继承。</li>
</ul>
</li>
<li><p>B+Tree Internal Page</p>
<ul>
<li><strong>存储m个ordered keys和m+1个child pointers</strong>（即page_ids，指向其他的B+Tree Pages），表现为<code>key/page_id</code>pairs；</li>
</ul>
<blockquote>
<p>Because the number of pointers does not equal the number of keys, the first key is set to be invalid, and lookups should always start with the second key.</p>
</blockquote>
<ul>
<li>在任意时刻，internal page必须至少为<code>half full</code>。<ul>
<li>删除时，两个<code>half full pages</code>可以合并，或<code>keys and pointers</code>重新分布来避免合并；</li>
<li>插入时，一个<code>full pages</code>可以拆分成两个，或<code>keys and pointers</code>重新分布来避免拆分。</li>
</ul>
</li>
</ul>
</li>
<li><p>B+Tree Leaf Page</p>
<ul>
<li><strong>存储m个ordered keys和m个相对应的value。</strong>value需要被设置为<strong>64-bit record-id</strong>。</li>
<li>其余设置和internal pages一致。</li>
</ul>
<blockquote>
<p>即使叶子页和内部页包含相同类型的键，它们的值类型也可能不同。因此，max_size 也可能不同。</p>
</blockquote>
</li>
</ul>
<p>注意：</p>
<p>1、每个 B+Tree 的叶子页&#x2F;内部页都与缓冲池获取的内存页的内容（即 data_ 部分）相对应；</p>
<p>2、每次read&#x2F;write一个leaf&#x2F;internal page时：</p>
<p>（1）从buffer pool中fetch该页；（page id）</p>
<p>（2）reinterpret cast to leaf&#x2F;internal page；</p>
<p>（3）读&#x2F;写完后Unpin该page。</p>
<ul>
<li><p>flexible array</p>
<ul>
<li><p>flexible array 必须是类中的最后一个成员，并且仅能有一个。在为对象分配内存时，flexible array 会自动填充，占用未被其他变量使用的内存。这样就可以确定自己的长度了。</p>
</li>
<li><p>举例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如有一个类 C：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">// 4 byte</span></span><br><span class="line">    <span class="type">int</span> array[<span class="number">1</span>]; <span class="comment">// unknown size</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在初始化一个 C 的对象，并为其分配了 24 byte 的内存。a 占了 4 byte 内存</span></span><br><span class="line"><span class="comment">// 那么 array 会尝试填充剩下的内存，大小变为 5。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="B-PLUS-TREE-INTERNAL-PAGE"><a href="#B-PLUS-TREE-INTERNAL-PAGE" class="headerlink" title="B_PLUS_TREE_INTERNAL_PAGE"></a><strong>B_PLUS_TREE_INTERNAL_PAGE</strong></h3><ul>
<li><p>对于 Internal Page 其储存的节点数最大正好是 internal_max_size，可能被存满</p>
<ul>
<li>由于先插入会导致空间溢出，因此考虑单独开辟一块内存空间，在完成插入与分裂后释放。</li>
</ul>
</li>
<li><p>要求第一个key为空的原因：在 internal page 中，n 个 key 可以将数轴划分为 n+1 个区域，也就对应着 n+1 个 value。</p>
</li>
<li><p>internal page 中的 key 并不代表实际上的索引值，仅仅是作为一个向导，引导需要插入&#x2F;删除&#x2F;查询的 key 找到这个 key 真正所在的 leaf page。</p>
</li>
<li><p>Header大小为24Byte：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">IndexPageType page_type_;   <span class="comment">// leaf or internal. 4 Byte</span></span><br><span class="line"><span class="type">lsn_t</span> lsn_  <span class="comment">// temporarily unused. 4 Byte</span></span><br><span class="line"><span class="type">int</span> size_;  <span class="comment">// tree page data size(not in byte, in count). 4 Byte</span></span><br><span class="line"><span class="type">int</span> max_size_;  <span class="comment">// tree page data max size(not in byte, in count). 4 Byte</span></span><br><span class="line"><span class="type">page_id_t</span> parent_page_id_; <span class="comment">// 4 Byte</span></span><br><span class="line"><span class="type">page_id_t</span> page_id_; <span class="comment">// 4 Byte</span></span><br><span class="line"><span class="comment">// 24 Byte in total</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>internal page的KV对</strong>中：</p>
<ul>
<li>K-比较大小的索引；</li>
<li>V-page_id，指向下一层的节点。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202403291930057.png" alt="image-20240329193009583"></p>
<h3 id="B-PLUS-TREE-LEAF-PAGE"><a href="#B-PLUS-TREE-LEAF-PAGE" class="headerlink" title="B_PLUS_TREE_LEAF_PAGE"></a><strong>B_PLUS_TREE_LEAF_PAGE</strong></h3><ul>
<li>对于 Leaf Page 其储存的节点数最大永远是 leaf_max_size - 1，永远存不满、<ul>
<li>对于Leaf Page，直接先插入再分裂；</li>
</ul>
</li>
<li>Header大小为28Byte，多了一个成员变量 <code>next_page_id</code>。</li>
<li><strong>leaf page的KV对</strong>中：<ul>
<li>K-实际的索引；</li>
<li>V-Record ID，用于识别表中的某一条数据。</li>
</ul>
</li>
</ul>
<h2 id="Task-2a-B-Tree-Data-Structure-Insertion-Point-Search"><a href="#Task-2a-B-Tree-Data-Structure-Insertion-Point-Search" class="headerlink" title="Task #2a - B+Tree Data Structure (Insertion, Point Search)"></a>Task #2a - B+Tree Data Structure (Insertion, Point Search)</h2><ul>
<li>目标：实现1）<code>insertion：Insert()</code>；2）<code>Search：Getvalue()</code></li>
</ul>
<blockquote>
<p>index仅支持unique keys。</p>
<p>如果插入会改变树的不变形，需要进行结点的拆分或keys的重组。</p>
<p>若改变了root的page ID，必须更新<code>root_page_id</code>。为此，可以访问构造函数中给出的 <code>header_page_id_</code> 页面。然后，通过使用 <code>reinterpret cast</code>，可以将该页面解释为 <code>BPlusTreeHeaderPage</code>，并从这里更新root的page ID。此外，必须实现 <code>GetRootPageId</code>（目前默认返回 0）。</p>
<p>推荐使用<code>FetchPageBasic</code>来访问页。</p>
</blockquote>
<ul>
<li><p>对于取得的页进行操作：1）根据page_id取得guard；2）将其数据部分<code>data_</code>强制转换成对应的类型（reinterpret_cast&#x2F;As&#x2F;AsMut）。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将内部存储的指针按照指定的类型进行类型转换</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">As</span><span class="params">()</span> -&gt; <span class="type">const</span> T * </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> guard_.<span class="built_in">As</span>&lt;T&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><em><strong>（under analyze）补充</strong></em></p>
<h3 id="src-storage-page-b-plus-tree-internal-page-cpp"><a href="#src-storage-page-b-plus-tree-internal-page-cpp" class="headerlink" title="src&#x2F;storage&#x2F;page&#x2F;b_plus_tree_internal_page.cpp"></a>src&#x2F;storage&#x2F;page&#x2F;b_plus_tree_internal_page.cpp</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ==under analyze 1: FindValue的逻辑</span><br><span class="line">// ==under analyze 2: lambda 表达式 &amp; [comparator]</span><br><span class="line">// ==under analyze 2: std::lower_bound &amp; std::prev</span><br></pre></td></tr></table></figure>

<h3 id="src-storage-page-b-plus-tree-leaf-page-cpp"><a href="#src-storage-page-b-plus-tree-leaf-page-cpp" class="headerlink" title="src&#x2F;storage&#x2F;page&#x2F;b_plus_tree_leaf_page.cpp"></a>src&#x2F;storage&#x2F;page&#x2F;b_plus_tree_leaf_page.cpp</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ==under analyze 1: FindValue的逻辑</span><br></pre></td></tr></table></figure>

<h3 id="src-storage-index-b-plus-tree-cpp"><a href="#src-storage-index-b-plus-tree-cpp" class="headerlink" title="src&#x2F;storage&#x2F;index&#x2F;b_plus_tree.cpp"></a>src&#x2F;storage&#x2F;index&#x2F;b_plus_tree.cpp</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ==under analyze1: emplace_back()</span><br></pre></td></tr></table></figure>

<h1 id="Checkpoint-2-85-points"><a href="#Checkpoint-2-85-points" class="headerlink" title="Checkpoint #2 (85 points)"></a><strong>Checkpoint #2 (85 points)</strong></h1><h2 id="Task-2b-B-Tree-Data-Structure-Deletion"><a href="#Task-2b-B-Tree-Data-Structure-Deletion" class="headerlink" title="Task #2b - B+Tree Data Structure (Deletion)"></a>Task #2b - B+Tree Data Structure (Deletion)</h2><h2 id="Task-3-Index-Iterator"><a href="#Task-3-Index-Iterator" class="headerlink" title="Task #3 - Index Iterator"></a>Task #3 - Index Iterator</h2><h2 id="Task-4-Concurrency-Control"><a href="#Task-4-Concurrency-Control" class="headerlink" title="Task #4 - Concurrency Control"></a>Task #4 - Concurrency Control</h2>]]></content>
      <categories>
        <category>Project</category>
        <category>cmu15-445</category>
      </categories>
  </entry>
  <entry>
    <title>Ch1 计算机系统漫游</title>
    <url>/2024/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CSAPP/CSAPP_Ch1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</url>
    <content><![CDATA[<h1 id="Ch1-计算机系统漫游"><a href="#Ch1-计算机系统漫游" class="headerlink" title="Ch1 计算机系统漫游"></a>Ch1 计算机系统漫游</h1><span id="more"></span>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031123622.png" alt="CSAPP Ch1-Ch3_00"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031124622.png" alt="CSAPP Ch1-Ch3_01"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch10 系统级I/O</title>
    <url>/2024/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CSAPP/CSAPP_Ch10%20%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/</url>
    <content><![CDATA[<h1 id="Ch10-系统级I-O"><a href="#Ch10-系统级I-O" class="headerlink" title="Ch10 系统级I&#x2F;O"></a>Ch10 系统级I&#x2F;O</h1><span id="more"></span>

<p><strong>I-Input&#x2F;O-Output：外设和内存之间进行数据交互的过程</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052201601.png" alt="image-20240405220142526"></p>
<h2 id="1、系统级I-O"><a href="#1、系统级I-O" class="headerlink" title="1、系统级I&#x2F;O"></a>1、系统级I&#x2F;O</h2><h3 id="（1）Unix-I-O"><a href="#（1）Unix-I-O" class="headerlink" title="（1）Unix I&#x2F;O"></a>（1）Unix I&#x2F;O</h3><ul>
<li>Opening files——返回文件描述符（file discripitor，fd）<ul>
<li>standard unput</li>
<li>standard output</li>
<li>standard err</li>
</ul>
</li>
<li>Changing the current file（改变当前文件的位置）</li>
<li>Reading and Writing files</li>
<li>Closing files</li>
</ul>
<h3 id="（2）Files"><a href="#（2）Files" class="headerlink" title="（2）Files"></a>（2）Files</h3><ul>
<li><p><strong>Regular file</strong>（普通文件）</p>
</li>
<li><p><strong>Directory</strong>（目录文件）</p>
<ul>
<li>相当于文件夹，是一个<strong>存储链接信息</strong>的数组，即<strong>文件和文件名的映射</strong></li>
</ul>
</li>
<li><p><strong>Socket</strong>（套接字）</p>
</li>
<li><p><strong>named pipe</strong>（命名管道），<strong>symbolic link</strong>（符号链接），<strong>character and block device</strong>（字符和块设备）</p>
<ul>
<li>如键盘、鼠标等为字符设备；硬盘为块设备</li>
</ul>
</li>
<li><p><strong>usr</strong>——Unix Software Resources的缩写</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052220580.png" alt="image-20240405222033196"></p>
<h3 id="（3）Opening-and-Closing-Files"><a href="#（3）Opening-and-Closing-Files" class="headerlink" title="（3）Opening and Closing Files"></a>（3）Opening and Closing Files</h3><ul>
<li><p>打开文件</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052222286.png" alt="image-20240405222257203"></p>
</li>
<li><p>关闭文件</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052223245.png" alt="image-20240405222318176"></p>
</li>
</ul>
<h3 id="（4）File-Permission"><a href="#（4）File-Permission" class="headerlink" title="（4）File Permission"></a>（4）File Permission</h3><ul>
<li><p>User（文件拥有者）</p>
</li>
<li><p>Group（群组）</p>
</li>
<li><p>Others（其他人）</p>
</li>
<li><p>观察下图，可以看出：</p>
<ul>
<li>普通文件由<code>-</code>开头；目录文件由<code>d</code>开头</li>
<li><code>rwx</code>：<ul>
<li><code>r</code>：read</li>
<li><code>w</code>：write</li>
<li><code>x</code>：execute</li>
</ul>
</li>
<li>一共有三组，如hello.c：<code>-rw-rw-r--</code>，可以看作是：<code>-|rw-|rw-|r--</code>，分别对应User、Group和Others的权限</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052227053.png" alt="image-20240405222704994"></p>
<h3 id="（5）Reading-and-Writing-Files"><a href="#（5）Reading-and-Writing-Files" class="headerlink" title="（5）Reading and Writing Files"></a>（5）Reading and Writing Files</h3><ul>
<li><code>EOF</code>：End of File</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052233018.png" alt="image-20240405223313949"></p>
<h3 id="（6）Reading-File-Metadata"><a href="#（6）Reading-File-Metadata" class="headerlink" title="（6）Reading File Metadata"></a>（6）Reading File Metadata</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052235910.png" alt="image-20240405223528846"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052235669.png" alt="image-20240405223540586"></p>
<h2 id="2、Robust-I-O"><a href="#2、Robust-I-O" class="headerlink" title="2、Robust I&#x2F;O"></a>2、Robust I&#x2F;O</h2><p><strong>Robust I&#x2F;O主要用于网络中。</strong></p>
<blockquote>
<p>Robust I&#x2F;O（健壮的I&#x2F;O）是一种设计模式，旨在提高程序对输入输出（I&#x2F;O）操作的稳健性和可靠性。具体来说，Robust I&#x2F;O 的作用包括以下几个方面：</p>
<ol>
<li><strong>错误处理：</strong> Robust I&#x2F;O 强调对I&#x2F;O操作的错误处理。它会在发生错误时进行适当的处理，例如捕获异常、返回错误码或者记录日志，从而确保程序在出现异常情况时能够做出合适的应对，而不会导致程序崩溃或者数据丢失。</li>
<li><strong>超时处理：</strong> Robust I&#x2F;O 考虑到可能发生的网络超时、设备故障等情况，会设置适当的超时时间，并在超时发生时进行处理，例如重新尝试连接或者报告错误，以保证程序能够及时响应并继续执行。</li>
<li><strong>资源释放：</strong> Robust I&#x2F;O 确保在完成I&#x2F;O操作后及时释放资源，避免资源泄露和内存溢出等问题，提高程序的稳定性和性能。</li>
<li><strong>容错机制：</strong> Robust I&#x2F;O 通过实现容错机制，可以在遇到部分错误或异常情况时，仍然保持程序的正常运行，尽量避免中断整个操作流程。</li>
<li><strong>重试机制：</strong> Robust I&#x2F;O 可能会实现重试机制，以确保在出现一次性错误时，能够尝试多次重复操作，从而提高操作的成功率。</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052239600.png" alt="image-20240405223951531"></p>
<ul>
<li><p>rio_t结构体</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404052240176.png" alt="image-20240405224031108"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch2 信息的表示和处理</title>
    <url>/2024/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CSAPP/CSAPP_Ch2%20%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="Ch2-信息的表示和处理"><a href="#Ch2-信息的表示和处理" class="headerlink" title="Ch2 信息的表示和处理"></a>Ch2 信息的表示和处理</h1><span id="more"></span>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031130352.png" alt="CSAPP Ch1-Ch3_02"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031130692.png" alt="CSAPP Ch1-Ch3_03"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031130543.png" alt="CSAPP Ch1-Ch3_04"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031131731.png" alt="CSAPP Ch1-Ch3_05"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031131498.png" alt="CSAPP Ch1-Ch3_06"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch3 程序的机器级表示</title>
    <url>/2024/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CSAPP/CSAPP_Ch3%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="Ch3-程序的机器级表示"><a href="#Ch3-程序的机器级表示" class="headerlink" title="Ch3 程序的机器级表示"></a>Ch3 程序的机器级表示</h1><span id="more"></span>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031125101.png" alt="CSAPP Ch1-Ch3_07"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031125684.png" alt="CSAPP Ch1-Ch3_08"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031125146.png" alt="CSAPP Ch1-Ch3_09"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031125670.png" alt="CSAPP Ch1-Ch3_10"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031126892.png" alt="CSAPP Ch1-Ch3_11"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031126616.png" alt="CSAPP Ch1-Ch3_12"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031126789.png" alt="CSAPP Ch1-Ch3_13"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch4 处理器体系结构</title>
    <url>/2024/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CSAPP/CSAPP_Ch4%20%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Ch4-处理器体系结构"><a href="#Ch4-处理器体系结构" class="headerlink" title="Ch4 处理器体系结构"></a>Ch4 处理器体系结构</h1><p>CSAPP自定义了一个Y86-64</p>
<span id="more"></span>

<h2 id="1、指令系统结构"><a href="#1、指令系统结构" class="headerlink" title="1、指令系统结构"></a>1、指令系统结构</h2><h3 id="（1）Programmer-Visible-State"><a href="#（1）Programmer-Visible-State" class="headerlink" title="（1）Programmer-Visible State"></a>（1）Programmer-Visible State</h3><p>可见状态：每条指令都会去读取或修改处理器某些部分，如下图所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011539557.png" alt="image-20240401153926464" style="zoom:33%;" />

<h3 id="（2）指令编码"><a href="#（2）指令编码" class="headerlink" title="（2）指令编码"></a>（2）指令编码</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011540371.png" alt="image-20240401154030167" style="zoom:33%;" />

<p>如上图最后一条：</p>
<ul>
<li><p>5 指令代码</p>
</li>
<li><p>0 指令功能</p>
</li>
<li><p>rA&#x2F;rB 寄存器指示符字节</p>
<ul>
<li><p>对寄存器编码，用16进制数<strong>0~0xE</strong>表示</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011531970.png" alt="image-20240401153138807" style="zoom:33%;" /></li>
</ul>
</li>
</ul>
<p>举例：（小端法存储）</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011536946.png" alt="image-20240401153606853" style="zoom:33%;" />

<h3 id="（3）处理异常"><a href="#（3）处理异常" class="headerlink" title="（3）处理异常"></a>（3）处理异常</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011540188.png" alt="image-20240401154055033" style="zoom:33%;" />

<h2 id="2、数字电路与处理器设计"><a href="#2、数字电路与处理器设计" class="headerlink" title="2、数字电路与处理器设计"></a>2、数字电路与处理器设计</h2><p>Register File 寄存器文件（寄存器堆）输出端口与ALU的输入端口串联。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011545861.png" alt="image-20240401154517784" style="zoom:33%;" />

<ul>
<li>读写操作共用地址线；</li>
<li>定义15个寄存器，因此地址线设计成4为即可；</li>
<li>we_（写使能信号）&#x2F;reeset（复位信号）</li>
</ul>
<p>下图为Register File的内部结构：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011547329.png" alt="image-20240401154700867" style="zoom: 50%;" />

<p>逻辑门，这些门结构可通过P管和N管（CMOS管）组合表现。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011548500.png" alt="image-20240401154803404" style="zoom: 33%;" />

<h2 id="3、Y86-64的顺序实现"><a href="#3、Y86-64的顺序实现" class="headerlink" title="3、Y86-64的顺序实现"></a>3、Y86-64的顺序实现</h2><p>举例：sum程序对应的汇编代码和二进制指令：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011554476.png" alt="image-20240401155427243" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011554403.png" alt="image-20240401155410294" style="zoom:50%;" />

<h3 id="（1）处理器六大阶段"><a href="#（1）处理器六大阶段" class="headerlink" title="（1）处理器六大阶段"></a>（1）处理器六大阶段</h3><ul>
<li><p>取指：分析指令；</p>
</li>
<li><p>译码：读寄存器文件；</p>
</li>
<li><p>执行：ALU执行 1)算术逻辑运算； 2)计算内存引用的有效地址； 3)执行push和pop指令；</p>
</li>
<li><p>访存：针对内存的读写操作；</p>
</li>
<li><p>写回：写寄存器文件；</p>
</li>
<li><p>更新PC：将PC的内容设置为下一条指令的地址。</p>
</li>
</ul>
<h3 id="（2）各阶段的硬件结构"><a href="#（2）各阶段的硬件结构" class="headerlink" title="（2）各阶段的硬件结构"></a>（2）各阶段的硬件结构</h3><p>总体结构（<strong>其中从valP到Data的橙色线错误，应该为从valC到Data！</strong>），对于顺序操作，这6个阶段在一个时钟周期内完成。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011906322.png" alt="image-20240401190602950"></p>
<ul>
<li><p>取指</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011619659.png" alt="image-20240401161926457" style="zoom: 33%;" />
</li>
<li><p>译码</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011621480.png" alt="image-20240401162105328" style="zoom: 33%;" />
</li>
<li><p>执行</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011622684.png" alt="image-20240401162222519" style="zoom: 33%;" />
</li>
<li><p>访存</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011622546.png" alt="image-20240401162255349" style="zoom: 33%;" />
</li>
<li><p>写回</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011623806.png" alt="image-20240401162342626" style="zoom: 33%;" />
</li>
<li><p>更新PC</p>
<ol>
<li>call指令常数字段；</li>
<li>在访存阶段从内存（栈）中读出的返回地址；</li>
<li>跳转指令的常数字段；</li>
<li>当前PC+当前指令长度。</li>
</ol>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011624170.png" alt="image-20240401162430019" style="zoom: 33%;" /></li>
</ul>
<h3 id="（3）举例"><a href="#（3）举例" class="headerlink" title="（3）举例"></a>（3）举例</h3><p>举例1：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011600331.png" alt="image-20240401160018132" style="zoom: 33%;" />

<p>举例2：（下图中的<strong>valE&#x3D;0+8</strong>是因为寄存器文件的写入端与ALU的输出端相连）</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011605541.png" alt="image-20240401160504446" style="zoom:33%;" />

<p>举例3：</p>
<p>该指令为<strong>将寄存器 <code>%rsp</code> 中的值存储到以 <code>%rbx</code> 寄存器的值为基地址偏移100个字节的内存单元中</strong>，因此不涉及写寄存器操作。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011608224.png" alt="image-20240401160808121" style="zoom:33%;" />

<p>举例4：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011612305.png" alt="image-20240401161239187" style="zoom:33%;" />

<p>举例5：跳转指令</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011613911.png" alt="image-20240401161359730" style="zoom:33%;" />

<h2 id="4、流水线"><a href="#4、流水线" class="headerlink" title="4、流水线"></a>4、流水线</h2><h3 id="（1）属性及原理"><a href="#（1）属性及原理" class="headerlink" title="（1）属性及原理"></a>（1）属性及原理</h3><p>假设有一个非流水线设计，如下图所示，该系统的吞吐量约为<strong>3.12GIPS</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011659177.png" alt="image-20240401165925089" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011659832.png" alt="image-20240401165943770" style="zoom:33%;" />

<p>若采用流水线设计，将组合逻辑单元阶段分为三个阶段，每个阶段120ps，此时吞吐量为<strong>8.33GIPS</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011701350.png" alt="image-20240401170120155" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011702592.png" alt="image-20240401170206480" style="zoom:33%;" />

<ul>
<li>流水线的局限性：此时各个阶段的延迟可能都是不等的，此时时钟的速率受最慢阶段的限制（木桶效应）：</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011706596.png" alt="image-20240401170631392" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011836974.png" alt="image-20240401183610851" style="zoom:33%;" />

<ul>
<li>此外，过深的流水线会导致系统性能的下降。实际中的指令间存在数据依赖，以及指令控制流造成的控制依赖。</li>
</ul>
<h3 id="（2）硬件结构"><a href="#（2）硬件结构" class="headerlink" title="（2）硬件结构"></a>（2）硬件结构</h3><p>在顺序实现的硬件结构中，取指发生在时钟周期刚开始时，而更新PC发生在时钟快要结束时，如下图所示（<strong>橙色线需勘误</strong>）。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011906322.png" alt="image-20240401190602950"></p>
<p>为了实现流水线的硬件结构，将更新PC的操作从时钟周期快要结束时移动到时钟刚开始执行时（即最左侧新增的寄存器）</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011910589.png" alt="image-20240401191048453"></p>
<p>从宏观上来说，也就是在各个阶段前加入流水线寄存器。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011911529.png" alt="image-20240401191145449"></p>
<p>其展开后的整体逻辑如下：</p>
<ul>
<li>寄存器F保存PC的预测值；</li>
<li>寄存器D保存刚取出的指令信息；</li>
<li>寄存器E保存最新译码指令的状态以及从寄存器文件中读出的数值；</li>
<li>寄存器M保存最新执行指令的结果，包含ALU处理的那三类；</li>
<li>寄存器W保存访存执行的结果，而反馈路径将结果写回寄存器文件。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011924576.png" alt="image-20240401192450295"></p>
<h3 id="（3）数据冒险"><a href="#（3）数据冒险" class="headerlink" title="（3）数据冒险"></a>（3）数据冒险</h3><p>在下图的时钟周期4中，读取到的值并非所期望的10和3，而是默认值0，这是因为此时指令1处于访存阶段，10仍未写回%rdx中；而指令2处于执行阶段，3也未写回%rax。这种情况称为<strong>冒险&#x2F;冲突</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011937082.png" alt="image-20240401193745913" style="zoom:50%;" />

<p>解决方法：</p>
<ul>
<li><p>暂停技术</p>
<ul>
<li><p>在D阶段读取寄存器的ID值，分别于执行阶段、访存阶段及写回阶段所执行指令的目的寄存器ID比较，若相等，则存在数据相关，需要在译码阶段等待；</p>
</li>
<li><p>方式为插入气泡：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011941588.png" alt="image-20240401194157407"></p>
</li>
</ul>
</li>
<li><p>数据转发&#x2F;旁路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404011943090.png" alt="image-20240401194351754"></p>
</li>
</ul>
<h3 id="（4）控制冒险"><a href="#（4）控制冒险" class="headerlink" title="（4）控制冒险"></a>（4）控制冒险</h3><p>控制冒险的情况例举如下：</p>
<ul>
<li>若取出的是ret指令，下一条指令的地址需要等到访存结束后才能从栈中取出；  —— 解决：暂停处理新指令</li>
<li>若取出的是分支条件指令，需要经过执行阶段后才能确定是否跳转。—— 解决：分支预测（预测其总是跳转或总是不跳转）</li>
</ul>
<p>暂停和插入气泡是如何实现的？</p>
<p>流水线寄存器是通过时钟的上升沿来改变输出的值，遇到上升沿时，加载其输入作为新的输出。因此，给每个流水线寄存器引入stall信号和bubble信号，<strong>当需要暂停时</strong>，将halt信号设为1，寄存器保存原状态；<strong>当需要插入气泡时</strong>，将bubble信号设为1，寄存器的状态设置成某个固定的复位配置，等效于nop。</p>
<h2 id="5、Y86-64的流水线实现"><a href="#5、Y86-64的流水线实现" class="headerlink" title="5、Y86-64的流水线实现"></a>5、Y86-64的流水线实现</h2><h3 id="（1）取指阶段"><a href="#（1）取指阶段" class="headerlink" title="（1）取指阶段"></a>（1）取指阶段</h3><ul>
<li><p>顺序执行：valP &#x3D; 当前PC + 指令长度</p>
</li>
<li><p>跳转执行：valP &#x3D; （指令中的常数字段）valC</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404012055519.png" alt="image-20240401205520162" style="zoom:50%;" />
</li>
<li><p>为了应对出错的情况，设置<strong>select PC部件</strong>纠错：</p>
<ul>
<li><p>若取到<strong>ret</strong>，需要等到译码、执行和访存后，才能从内存中读到正确的返回地址，此时的改正方法为：<strong>将流水线寄存器W中的访存结果（W_valM）作为下一条指令的地址；</strong></p>
</li>
<li><p>若取到<strong>条件分支指令</strong>，需要等到译码、执行后才能判断是否跳转，此时的改正方法为：<strong>根据Cnd信号判断是否跳转，若不跳转，则从流水线寄存器M读取（M_valA）下一条指令的地址</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404012104691.png" alt="image-20240401210442459"></p>
</li>
</ul>
</li>
</ul>
<h3 id="（2）译码阶段"><a href="#（2）译码阶段" class="headerlink" title="（2）译码阶段"></a>（2）译码阶段</h3><ul>
<li><p>需要判断是1）<strong>直接使用转发的数据</strong>；还是2）<strong>从寄存器文件中读取数据</strong>。</p>
</li>
<li><p>哪些数据需要转发？</p>
<ul>
<li><strong>ALU的输出结果</strong><ul>
<li>正常需要经访存和写回后，才能完成寄存器的数据更新；</li>
<li>采用转发设计时，ALU的输出结果可以马上作为译码阶段的结果。</li>
</ul>
</li>
<li><strong>内存的输出数据</strong><ul>
<li>和ALU类似</li>
</ul>
</li>
<li><strong>访存阶段时，寄存器写入端口E还没有写入的数据</strong></li>
<li><strong>写回阶段时，寄存器写入端口M还没有写入的数据</strong></li>
<li><strong>写回阶段时，寄存器写入端口E还没有写入的数据</strong></li>
</ul>
</li>
<li><p>每个转发源包括：1）<strong>寄存器的ID值</strong>；2）<strong>转发数据</strong>。</p>
</li>
<li><p>Sel+Fwd A与Fwd B相比，<strong>多了一个valP输入</strong>。这里将valA与valP合并，可以合并的原因是只有函数调用指令和跳转指令在后面的阶段才需要用到valP，而这两类指令并不需要从A端口读取数据（见3(3).举例5.跳转指令）</p>
<ul>
<li>valP是顺序执行时下一条指令的地址，而跳转执行指令在译码阶段不需要valP；</li>
<li>根据icode判断是否为这两类指令，如果是则可以进行合并。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404012117651.png" alt="image-20240401211720521"></p>
</li>
</ul>
<p>其他阶段和顺序设计相差不大，不再赘述。</p>
<h2 id="6、流水线的控制逻辑"><a href="#6、流水线的控制逻辑" class="headerlink" title="6、流水线的控制逻辑"></a>6、流水线的控制逻辑</h2><h3 id="（1）加载-使用冒险"><a href="#（1）加载-使用冒险" class="headerlink" title="（1）加载&#x2F;使用冒险"></a>（1）加载&#x2F;使用冒险</h3><h3 id="（2）分支预测发生错误"><a href="#（2）分支预测发生错误" class="headerlink" title="（2）分支预测发生错误"></a>（2）分支预测发生错误</h3><h3 id="（3）返回阶段的处理"><a href="#（3）返回阶段的处理" class="headerlink" title="（3）返回阶段的处理"></a>（3）返回阶段的处理</h3>]]></content>
      <categories>
        <category>计算机基础</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch5 优化程序性能</title>
    <url>/2024/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CSAPP/CSAPP_Ch5%20%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h1 id="Ch5-优化程序性能"><a href="#Ch5-优化程序性能" class="headerlink" title="Ch5 优化程序性能"></a>Ch5 优化程序性能</h1><span id="more"></span>

<h2 id="1、优化程序性能"><a href="#1、优化程序性能" class="headerlink" title="1、优化程序性能"></a>1、优化程序性能</h2><h3 id="（1）局限性"><a href="#（1）局限性" class="headerlink" title="（1）局限性"></a>（1）局限性</h3><ul>
<li><strong>如果编译器无法确定两个指针是否指向同一个位置，那么编译器会假设所有情况都有可能发生，反而限制了优化策略。</strong></li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404012134539.png" alt="image-20240401213441380" style="zoom:33%;" />

<p>当编译器在优化代码时，会假设xp和yp有可能指向同一个内存位置，如下图所示，此时add1 res&#x3D;4x，add2 res&#x3D;3x，因此不能将add2用于优化add1。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404012134793.png" alt="image-20240401213457648" style="zoom:33%;" />

<ul>
<li><strong>函数调用影响优化策略</strong></li>
</ul>
<p>如下图所示，大多数编译器不会把func1优化为func2（注意func2返回0是因为counter为后++，先返回再++）。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021006812.png" alt="image-20240402100639099" style="zoom:33%;" />

<h3 id="（2）优化方式"><a href="#（2）优化方式" class="headerlink" title="（2）优化方式"></a>（2）优化方式</h3><ul>
<li><p>1）代码移动</p>
<ul>
<li>循环不变式外提，比如在执行for循环前先计算出数组长度；</li>
</ul>
</li>
<li><p>2）优化函数调用</p>
<ul>
<li><p>举例：在循环中将函数get_vec_element变为直接数组访问，这样反而降低了效率，这是因为每次操作数组时需要两次读内存和一次写内存：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021022591.png" alt="image-20240402102218521"></p>
</li>
<li><p>基于此再进行优化，设置临时变量，直到循环结束再写入，此时只需要一次读内存，性能得到了很大的提升：</p>
<ul>
<li><strong>这里的acc是临时变量， 通常情况下，临时变量会被保存在栈帧（栈帧是用来存储函数调用期间的局部变量和其他临时数据的一块内存区域）中， 由于 acc 在循环中频繁使用，并且在每次迭代中都需要更新，将其保存在寄存器中可以提高访问速度，避免了频繁的内存访问操作。寄存器的访问速度比内存更快，因此可以加快循环的执行速度；</strong></li>
<li><strong>由于循环中的代码会被频繁执行，对循环内的变量进行优化以提高性能尤为重要。将累加器保存在寄存器中可以减少内存访问次数，从而提高代码的执行效率。</strong></li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021022289.png" alt="image-20240402102255146" style="zoom:33%;" /></li>
</ul>
</li>
</ul>
<h2 id="2、现代处理器"><a href="#2、现代处理器" class="headerlink" title="2、现代处理器"></a>2、现代处理器</h2><p>在1的基础上，考虑利用处理器的微体系结构进行优化。现代处理器可以实现多指令并行。</p>
<h3 id="（1）功能单元"><a href="#（1）功能单元" class="headerlink" title="（1）功能单元"></a>（1）功能单元</h3><ul>
<li>指令控制单元（Instruction Control Unit，ICU）<ul>
<li>从内存中读取指令序列并译码，之后进行一系列操作</li>
<li>退役单元，控制着寄存器文件<ul>
<li>若指令执行完毕，相应更新寄存器文件；</li>
<li>若不该执行该条指令，则丢弃所有运算结果。</li>
</ul>
</li>
</ul>
</li>
<li>执行单元（Execution Unit，EU）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021039315.png" alt="image-20240402103925031"></p>
<h3 id="（2）功能单元的性能衡量指标"><a href="#（2）功能单元的性能衡量指标" class="headerlink" title="（2）功能单元的性能衡量指标"></a>（2）功能单元的性能衡量指标</h3><ul>
<li>延迟（Latency）：完成运算需要的总时间</li>
<li>发射（Isuue）：两次运算间间隔的最小周期数</li>
<li>容量（Capacity）：执行该运算的功能单元的数量</li>
</ul>
<p>CPE&#x2F;Clocks Per Instruction，每条指令所需的时钟周期数，衡量计算机指令执行效率的一个指标。</p>
<p>延迟界限和吞吐量界限的CPE值</p>
<ul>
<li>延迟界限：在给定的工作负载下，系统性能受到的主要限制是每个任务或指令的执行时间（延迟）的上限<ul>
<li>对于任何必须严格按照顺序执行的合并运算，延迟界限给出了所需要的最小的CPE值</li>
</ul>
</li>
</ul>
<p>吞吐量界限：在给定的工作负载下，系统性能受到的主要限制是系统的总体吞吐量（Throughput）的上限</p>
<ul>
<li>吞吐量是指单位时间内完成的任务数或指令数，它反映了系统的处理能力和效率</li>
<li>吞吐量界限通常与系统资源的利用率相关联，包括处理器的吞吐量、内存带宽、缓存命中率等因素</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch6 存储器层次结构</title>
    <url>/2024/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CSAPP/CSAPP_Ch6%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Ch6-存储器层次结构"><a href="#Ch6-存储器层次结构" class="headerlink" title="Ch6 存储器层次结构"></a>Ch6 存储器层次结构</h1><span id="more"></span>

<h2 id="1、存储技术"><a href="#1、存储技术" class="headerlink" title="1、存储技术"></a>1、存储技术</h2><h3 id="（1）随机访问存储器（RAM）"><a href="#（1）随机访问存储器（RAM）" class="headerlink" title="（1）随机访问存储器（RAM）"></a>（1）随机访问存储器（RAM）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021437441.png" alt="image-20240402143708229"></p>
<ul>
<li><p>静态RAM（SRAM）</p>
<ul>
<li>将每个bit位的信息存储在一个双稳态的存储器单元内，每个存储体单元由6个晶体管实现</li>
</ul>
</li>
<li><p>动态RAM（DRAM）</p>
<ul>
<li><p>电容充电，将每个bit位的存储对应1个电容和1个晶体管</p>
</li>
<li><p>存在缺陷：漏电时在10-100毫秒失去电荷，内存系统需要不断读出数据并重写，通过刷新来保存数据</p>
</li>
<li><p>举例：</p>
<ul>
<li>16：超单元（即supercell，DRAM的单个存储单元）个数</li>
<li>8：每个超单元存储8比特数据</li>
<li>下图分行、列两次发送地址，虽然增加了访问时间，原因<strong>DRAM存储结构为二位阵列而非一维数组，可以减少地址引脚数量</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021444685.png" alt="image-20240402144425635"></p>
</li>
<li><p>DRAM0-DRAM7以此存储低八位字节至最高八位字节，当处理器向内存控制器发起读取数据的请求时，内存控制器将地址转换为超单元地址，内存模块将i和j广播给每个DRAM，从而找到对应的数据，最终返回一个64bit的数据：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021450063.png" alt="image-20240402145000491"></p>
</li>
</ul>
</li>
</ul>
<h3 id="（2）机械磁盘"><a href="#（2）机械磁盘" class="headerlink" title="（2）机械磁盘"></a>（2）机械磁盘</h3><p>依靠盘片存储数据，表面涂有磁性记录材料。如下图共3个盘片，即6个盘面存储数据。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021453039.png" alt="image-20240402145348856" style="zoom: 50%;" />

<p>盘片表面由一圈圈的磁道组成。每一圈磁盘划分为多个扇区（通常存储512字节），扇区间存在间隙用于存储扇区的标识信息。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021457089.png" alt="image-20240402145714941" style="zoom:33%;" />

<p>每个盘片有独立的读&#x2F;写头，所有读&#x2F;写头连接在一个<strong>传动臂</strong>上，只能在半径方向上移动来读写数据，称为<strong>寻道</strong>。所有的读&#x2F;写头必须垂直排列、一致行动。读&#x2F;写头距离表盘的距离约0.1微米。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021458391.png" alt="image-20240402145841146" style="zoom: 33%;" />

<p>磁盘访问数据花费时间：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021513461.png" alt="image-20240402151318110" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021515859.png" alt="image-20240402151514499" style="zoom:50%;" />

<h3 id="（3）固态硬盘"><a href="#（3）固态硬盘" class="headerlink" title="（3）固态硬盘"></a>（3）固态硬盘</h3><p>固态磁盘由一个或多个闪存芯片组成，使用闪存芯片替代传动臂加盘片这种机械工作方式。</p>
<p>Flash translation layer：FTL，闪存转换层，将操作系统对逻辑块的请求翻译成对底层物理设备的访问。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021515854.png" alt="image-20240402151543579"></p>
<ul>
<li><p>闪存芯片（falsh chip）</p>
<ul>
<li><p>基于Nand Flash实现，下图的block与逻辑块无关。</p>
</li>
<li><p>包含读、写和擦除三个操作。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021521937.png" alt="image-20240402152128719"></p>
</li>
</ul>
</li>
</ul>
<h3 id="（4）程序的局部性"><a href="#（4）程序的局部性" class="headerlink" title="（4）程序的局部性"></a>（4）程序的局部性</h3><ul>
<li>时间局部性<ul>
<li>若被引用过的内存位置很可能在不远的将来还会被多次引用，则具有较好的时间局部性；</li>
</ul>
</li>
<li>空间局部性<ul>
<li>若一个内存位置被引用一次后，程序在不远的将来引用其附近的一个内存位置，则具有较好的时间局部性；</li>
</ul>
</li>
</ul>
<h2 id="2、存储器层次结构"><a href="#2、存储器层次结构" class="headerlink" title="2、存储器层次结构"></a>2、存储器层次结构</h2><p>结构如下图所示，基本思想是上层存储设备作为下层存储设备的缓存。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021433966.png" alt="image-20240402143353405"></p>
<h3 id="（1）cache"><a href="#（1）cache" class="headerlink" title="（1）cache"></a>（1）cache</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021603503.png" alt="image-20240402160342276"></p>
<ul>
<li><p>缓存命中（cache Hit）</p>
<ul>
<li>当程序需要第k+1层的某个数据对象d时，它首先从第k层的数据块中检索是否包含目标数据d的副本。若第k层包含目标数据d，称为缓存明中，否则称之为缓存不命中（cache Miss）</li>
<li>当发生不命中时，第k层的缓存要从第k+1层取出包含目标数据的块；若第k层缓存已满，会覆盖已有的块，被替换的块称为牺牲块。</li>
<li>步骤分三步：<ul>
<li>set selection（组选择）</li>
<li>line matching（行匹配）</li>
<li>word extraction（字抽取）</li>
</ul>
</li>
</ul>
</li>
<li><p>内部结构</p>
<ul>
<li><p>划分为S个Set，每个Set包含E行cache Line，地址为m位。</p>
</li>
<li><p>每行cache Line包含valid（数据是否有效）、Tag（目标数据是否存在在当前cache Line中）和大小为B的数据副本</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021607690.png" alt="image-20240402160725448" style="zoom: 50%;" />
</li>
<li><p>cache通过下面的方式知道自己是否包含目标数据的副本</p>
<ul>
<li>假设目标数据的地址A长度为m位，该地址会被S和B分为3个字段，如下图所示。<ul>
<li><strong>Set index确定目标数据存储在哪个set中</strong></li>
<li><strong>Tag确定目标数据在set的哪一行（此时valid必须为1）</strong></li>
<li><strong>Block index指示块偏移量，确定目标数据的确切数据</strong></li>
</ul>
</li>
<li>cache用中间的位作为Set索引，是为了避免使用高位作为索引时造成映射到相同的区域。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021609317.png" alt="image-20240402160935274" style="zoom: 50%;" />
</li>
<li><p>Issues With Writes</p>
<ul>
<li>写命中（Write Hit）<ul>
<li>写穿透（write-through）：写入cache的同时写回内存（更低一级cache），这样cache在替换可以直接丢掉旧的</li>
<li>写回（write-back）：只写入cache，在cache需要替换时才写回内存</li>
</ul>
</li>
<li>写不命中（Write Miss）<ul>
<li>写分配（write-allocate）：先把目标数据所在的块从内存（更低一级cache）加载到cache中，然后再往cache中写</li>
<li>写不分配（no-write-allocate）：绕开cache，直接把要写的内容写到内存里</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（2）直接映射高速缓存"><a href="#（2）直接映射高速缓存" class="headerlink" title="（2）直接映射高速缓存"></a>（2）直接映射高速缓存</h3><ul>
<li><p>直接映射：每个Set只包含1行cache line</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021611962.png" alt="image-20240402161142799" style="zoom:50%;" />
</li>
<li><p>举例说明：假设存在一个cache，大小为(4, 1, 2, 4)，则整个地址空间可以由0-15标记，而标记位Tag和索引位Index连起来可以唯一的标识每一个内存块。</p>
<ul>
<li><p><strong>s1、组选择</strong>：根据Set index进行选择</p>
</li>
<li><p><strong>s2、行匹配</strong>：</p>
<ul>
<li>1、valid是否为1？</li>
<li>2、对比cache Line中的Tag与地址中的Tag是否一致</li>
</ul>
</li>
<li><p><strong>s3、字抽取</strong></p>
<ul>
<li>若一致，根据Block offset找到确切的地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021620864.png" alt="image-20240402162006768" style="zoom: 50%;" />

<ul>
<li><p>举例说明：假设有一个cache如下图所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021640771.png" alt="image-20240402164025528" style="zoom: 50%;" />

<ul>
<li>当地址是4位时，整个地址空间用编号0-15表示</li>
<li>地址中的Tag和Index二者结合标识唯一的内存块（即右侧的Block number）。由于<strong>每个内存块由两个字节组成</strong>，因此整个内存空间被分成8个块</li>
<li>由于cache中仅包含4个Set，因此会出现两个内存块映射到同一个Set的情况</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021636016.png" alt="image-20240402163600762"></p>
</li>
<li><p><strong>冲突不命中</strong>：内存中的不同块映射到cache的同一个Set中，此时不同块之间交替引用，即使cache中还存在空闲的块，也依旧造成不命中。</p>
</li>
</ul>
<h3 id="（3）组相联-全相联高速缓存"><a href="#（3）组相联-全相联高速缓存" class="headerlink" title="（3）组相联&#x2F;全相联高速缓存"></a>（3）组相联&#x2F;全相联高速缓存</h3><ul>
<li><p>组相联cache的每个set包含多个cache line，下图是一个2路组相联，其中C为cache的容量。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021659281.png" alt="image-20240402165930042" style="zoom:50%;" />
</li>
<li><p>全相联cache只有一个set</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021859412.png" alt="image-20240402185940143" style="zoom:50%;" /></li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch7 链接</title>
    <url>/2024/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CSAPP/CSAPP_Ch7%20%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="Ch7-链接"><a href="#Ch7-链接" class="headerlink" title="Ch7 链接"></a>Ch7 链接</h1><span id="more"></span>

<h2 id="1、编译器驱动程序"><a href="#1、编译器驱动程序" class="headerlink" title="1、编译器驱动程序"></a>1、编译器驱动程序</h2><p>链接（Linking）：<strong>将可重定位目标文件以及必要的系统文件组合起来，生成一个可执行文件</strong>，并加载到内存执行。</p>
<ul>
<li>构造大型程序时，容易遇到<strong>缺少库文件或库文件的版权不兼容导致连接错误</strong>的问题，因此需要理解链接器是如何用库文件来解析引用的；</li>
<li>遇到一些危险的编译错误；</li>
<li>理解语言的作用域如何实现；</li>
<li>理解其他重要的系统概念；</li>
<li>更好地利用共享库。</li>
</ul>
<p>编译系统四步：</p>
<ul>
<li><p>预处理</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021919552.png" alt="image-20240402191932454" style="zoom: 33%;" />
</li>
<li><p>编译</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021920420.png" alt="image-20240402192004172" style="zoom:33%;" />
</li>
<li><p>汇编</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021920745.png" alt="image-20240402192028410" style="zoom:33%;" />
</li>
<li><p>链接</p>
<ul>
<li><p>crt  –  c runtime</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021920762.png" alt="image-20240402192057662" style="zoom:33%;" />
</li>
<li><p>ld  –  链接器</p>
</li>
<li><p>-static – 静态链接</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021921378.png" alt="image-20240402192107260" style="zoom:33%;" /></li>
</ul>
</li>
</ul>
<h2 id="2、可重定位目标文件"><a href="#2、可重定位目标文件" class="headerlink" title="2、可重定位目标文件"></a>2、可重定位目标文件</h2><p>可重定位文件的组成：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021927625.png" alt="image-20240402192742394" style="zoom: 50%;" />

<p>本节举例用到的程序：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022023749.png" alt="image-20240402202308661" style="zoom:33%;" />

<h3 id="（1）ELF-header"><a href="#（1）ELF-header" class="headerlink" title="（1）ELF header"></a>（1）ELF header</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021928876.png" alt="image-20240402192847629" style="zoom:50%;" />

<ul>
<li><p>Magic（魔数），用于确定文件类型，操作系统在加载可执行文件时会确认魔数是否正确。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021930868.png" alt="image-20240402193033694" style="zoom:33%;" />
</li>
<li><p>start of section headers：为section header table的起始地址</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404021936802.png" alt="image-20240402193640661" style="zoom:33%;" /></li>
</ul>
<h3 id="（2）Section-header-table"><a href="#（2）Section-header-table" class="headerlink" title="（2）Section header table"></a>（2）Section header table</h3><p>查看表的全部内容：<code>readelf -S main.o</code></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022030317.png" alt="image-20240402203056995" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022020376.png" alt="image-20240402202016269" style="zoom:50%;" />

<ul>
<li><p><strong><code>.text</code> Section：</strong>存放<strong>已经编译好的机器代码</strong>，使用<code>objdump -s -d main.o</code>查看</p>
</li>
<li><p><strong><code>.data</code> Section：</strong>存放<strong>已初始化的全局变量和静态变量</strong>的值</p>
</li>
<li><p><strong><code>.bss</code> Section：</strong>存放<strong>未初始化的全局变量和静态变量</strong>的值</p>
<ul>
<li>实际上bss section并不占据实际的空间，它仅仅只是一个占位符</li>
<li>区分已初始化和未初始化的变量是为了节省空间<ul>
<li><strong>节省空间</strong>的含义：在可执行文件中不存储未初始化的全局变量和静态变量的实际初始值，而是延迟到程序运行时动态分配内存并初始化为零，从而减小可执行文件的体积。</li>
</ul>
</li>
<li><strong>和COMMON的区别</strong><ul>
<li>COMMON：未初始化的全局变量</li>
<li>.bss：未初始化的静态变量，初始化为0的全局或静态变量</li>
</ul>
</li>
</ul>
</li>
<li><p><code>.rodata</code> Section：ro-read only，如printf语句中的格式串和switch语句中的跳转表</p>
</li>
<li><p><strong>其余Section：</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022020768.png" alt="image-20240402202046576" style="zoom: 50%;" />
</li>
<li><p><strong><code>.symtab</code> Section</strong></p>
<ul>
<li><p>使用<code>readelf -s main.o</code>命令查看符号表的内容</p>
<ul>
<li>ndx 字段则用于指示该 section 在 section header table 中的索引</li>
<li>由于printf只是在main.c中被引用，并非定义在main.c中，因此其Ndx为UND(Undefine)类型</li>
<li>OBJECT类型表示符号为数据对象</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022030660.png" alt="image-20240402203002144"></p>
</li>
<li><p><strong>有三种类型的符号</strong></p>
<ul>
<li>全局符号：由<strong>该模块</strong>定义，同时能被其他模块引用</li>
<li>外部符号：由<strong>其他模块</strong>定义，同时能被其他模块引用</li>
<li>局部符号：由<strong>该模块</strong>定义，不能被其他模块引用<ul>
<li>任何带有<code>static</code>属性声明的全局变量或函数都是模块私有的</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>强符号与弱符号</strong></p>
<ul>
<li>强符号：函数和已初始化的全局变量</li>
<li>弱符号：未初始化的全局变量</li>
</ul>
</li>
<li><p><strong>符号解析</strong></p>
<ul>
<li><p><strong>当编译器遇到一个不是在当前模块中定义的符号时，会假设该符号是在其他模块中定义的。此时仅执行编译和汇编，而不执行链接的话是没有问题的</strong></p>
</li>
<li><p>找不到符号定义时的报错：</p>
<p><img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240402204455103.png" alt="image-20240402204455103"></p>
</li>
<li><p>多个可重定位文件中定义了同名的全局符号，有以下三种情况：</p>
<ul>
<li><p><strong>多个同名强符号一起出现——不允许</strong></p>
</li>
<li><p>一个强符号和多个同名弱符号——允许</p>
</li>
<li><p>多个同名弱符号——允许</p>
<ul>
<li><p>但容易发生不易发现的错误，如下图所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022103873.png" alt="image-20240402210359483" style="zoom: 33%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（3）静态库"><a href="#（3）静态库" class="headerlink" title="（3）静态库"></a>（3）静态库</h3><ul>
<li><p>定义：在Linux系统中，静态库以一种称为archive的特殊文件格式存放在磁盘上，如<code>libc.a</code>。<strong>archive文件是一组可重定位目标文件的集合。</strong></p>
</li>
<li><p>举例：如何构造一个静态库文件<code>libvector.a</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022111482.png" alt="image-20240402211100296"></p>
<p>​	之后就可以在链接时使用该静态库文件：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022111559.png" alt="image-20240402211151493" style="zoom:50%;" />
</li>
<li><p><strong>静态库的链接过程</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022113150.png" alt="image-20240402211346051" style="zoom:50%;" />
</li>
<li><p><strong>静态库的解析过程</strong></p>
<ul>
<li><p>链接器<strong>从左到右</strong>按命令行中出现的顺序来扫描可重定位文件和静态库文件（libc.a可以不用显式写出）</p>
<ul>
<li><p>由于是按从左到右的顺序扫描，因此命令行中各文件的输入顺序十分重要，遵循<strong>调用者在前</strong>的顺序</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404022125679.png" alt="image-20240402212530449" style="zoom:50%;" /></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">linux&gt; gcc -<span class="type">static</span> -o prog main.o ./libvector.a [libc.a]</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理三个集合，直至集合U和D不再发生变化，<strong>仅当集合U为空时才会链接正确</strong></p>
<ul>
<li>集合E：扫描中发现的可重定位目标文件</li>
<li>集合U：引用了但尚未定义的符号（也即是在其他模块中定义的符号）<ul>
<li>放入目标文件的符号表中未定义，仅引用的符号</li>
<li><strong>而尝试会用扫描到的静态库文件解析集合U中未定义的符号，找到其相关定义后转移到集合D中</strong></li>
</ul>
</li>
<li>集合D：已经定义了的符号</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>重定位（Relocation）</strong></p>
<ul>
<li><p>链接器合并输入模块，并为每个符号分配运行时地址</p>
</li>
<li><p>步骤</p>
<ul>
<li><p>重定位section和符号定义</p>
<ul>
<li>将所有可重定位目标文件中<strong>相同类型的section合并为一个新的section</strong></li>
</ul>
</li>
<li><p>重定位section中的符号引用，使其指向正确的运行地址</p>
<ul>
<li><p>依赖于可重定位条目的数据结构</p>
</li>
<li><p>由于汇编器在生成可重定位目标文件时，并不知道数据和代码在内存的什么位置，同时也不知道该模块所引用的外部定义的函数以及全局变量的位置。因此，<strong>当遇到最终位置不确定的符号引用时，就产生一个可重定位条目，告诉链接器在合成可执行文件时应该如何修改这个引用</strong></p>
<ul>
<li><p>关于代码的重定位条目放在<code>.rel.text</code>；已初始化数据的重定位条目放在<code>.rel.data</code></p>
</li>
<li><p>重定位条目的结构体定义</p>
<ul>
<li>offset：被修改的引用的section偏移量</li>
<li>type：重定位条目的类型，此处仅关心图中两种类型</li>
<li>symbol：表示被修改的引用时是哪一个符号</li>
<li>addend：常数，用于对某些类型的重定位条目进行偏移调整</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031016083.png" alt="image-20240403101650663" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>举例说明：此处ref_addr为运行时的地址；而*ref_ptr相当于计算的是当前PC要加上多少才能跳转到sum函数的地址处</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031022768.png" alt="image-20240403102210671" style="zoom: 80%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>举例：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031034256.png" alt="image-20240403103405171" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031034682.png" alt="image-20240403103432537" style="zoom:50%;" />

<h3 id="（4）可执行目标文件"><a href="#（4）可执行目标文件" class="headerlink" title="（4）可执行目标文件"></a>（4）可执行目标文件</h3><ul>
<li><strong>总体概述</strong></li>
</ul>
<p>下图左侧为可执行（目标）文件，右图为可重定位目标文件</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031035608.png" alt="image-20240403103531280"></p>
<p>具体来说，<strong>代码段和数据段会在执行时加入内存，而剩余的如符号表、调试信息等不会加入内存。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031036213.png" alt="image-20240403103641109" style="zoom:50%;" />

<ul>
<li><p><strong>段头部表（Segment header table）</strong></p>
<ul>
<li><p>描述代码段、数据段与内存的映射关系</p>
</li>
<li><p>末尾的<code>r-x/rw-</code>表示是否可读、可写以及可执行；</p>
</li>
<li><p><code>off</code>表示这个段在可执行文件中的偏移量</p>
</li>
<li><p><code>vaddr/paddr</code>表示该段在内存中的开始地址</p>
</li>
<li><p><code>filesz</code>表示该段的大小</p>
</li>
<li><p><code>memsz</code>表示运行时该段在内存中的大小，包括ELF header、程序头部表以及.init、.text和.rodata section的内容。<strong>注意：数据段中memsz比filesz多8个字节，是为了存储.bss的数据（仅运行时分配内存）</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031044703.png" alt="image-20240403104441234"></p>
</li>
</ul>
</li>
<li><p><strong>程序的加载过程（大致）</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031049727.png" alt="image-20240403104941601"></p>
</li>
</ul>
<h3 id="（5）动态链接共享库"><a href="#（5）动态链接共享库" class="headerlink" title="（5）动态链接共享库"></a>（5）动态链接共享库</h3><p>Linux中的<code>.so</code>文件和Windows中的<code>.dll</code>文件。</p>
<ul>
<li><p><strong>如何构造共享库</strong></p>
<ul>
<li><p>-shared</p>
</li>
<li><p>-fpic：位置无关选项，这样共享库才能被加载到任意的内存位置</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031113305.png" alt="image-20240403111355228" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031114886.png" alt="image-20240403111421652" style="zoom:50%;" /></li>
</ul>
</li>
<li><p><strong>动态链接过程</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031115921.png" alt="image-20240403111521660" style="zoom: 50%;" /></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032057373.png" alt="image-20240403205722302"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch8 异常控制流</title>
    <url>/2024/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CSAPP/CSAPP_Ch8%20%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    <content><![CDATA[<h1 id="Ch8-异常控制流"><a href="#Ch8-异常控制流" class="headerlink" title="Ch8 异常控制流"></a>Ch8 异常控制流</h1><span id="more"></span>

<h2 id="1、异常控制流"><a href="#1、异常控制流" class="headerlink" title="1、异常控制流"></a>1、异常控制流</h2><h3 id="（1）控制流"><a href="#（1）控制流" class="headerlink" title="（1）控制流"></a>（1）控制流</h3><p>处理器上电运行到断点关机的过程中，如下图，从ak到ak+1的过渡称为控制转移。最简单的控制流是平滑序列，其中平滑指内存中地址相邻，当出现跳转、函数调用和返回这类指令时会造成“不平滑”，会导致突变。</p>
<p><strong>异常控制流（Exception Control Flow）</strong>指的是程序执行过程中由于发生异常而导致的控制流程的变化。在计算机系统中，异常是一种特殊的事件，它表示了一种不寻常的情况，可能需要程序或者操作系统采取相应的措施来处理。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031243585.png" alt="image-20240403124332377" style="zoom: 33%;" />

<h2 id="2、异常"><a href="#2、异常" class="headerlink" title="2、异常"></a>2、异常</h2><ul>
<li>定义：在执行某个指令时，可能发生一个与当前指令有关或无关的<strong>事件</strong>，此时处理器将从执行应用程序切换到<strong>异常处理程序</strong>，待起处理完成后，根据引起异常的事件类型选择是否返回。</li>
<li>对异常的处理类似于一个间接的函数调用，但存在一些细微的差异：<ul>
<li>函数调用时，在跳转到目前函数之前，处理器首先将返回地址压入栈中；而处理器在处理异常时，会<strong>把处理器额外的一些状态压到栈中</strong></li>
<li>此外，若控制是从用户态转向内核态，那么所有的这些内容会被压到<strong>内核栈</strong>中，而不是用户栈中</li>
<li><strong>异常处理程序运行在内核态</strong>，因此对所有的系统资源都有访问权限</li>
</ul>
</li>
</ul>
<p>​	<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031250335.png" alt="image-20240403125006994"  /></p>
<ul>
<li>当异常处理程序处理完事件后，有以下三种情况：<ul>
<li>将控制交还给之前正在执行的指令</li>
<li>将控制返回给如果未发生异常时将会执行的下一条指令</li>
<li>终止程序</li>
</ul>
</li>
</ul>
<h3 id="（1）异常的分类"><a href="#（1）异常的分类" class="headerlink" title="（1）异常的分类"></a>（1）异常的分类</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031334140.png" alt="image-20240403133440480"></p>
<ul>
<li><p>中断（异步，即由处理器，即<strong>CPU外部</strong>的I&#x2F;O设备产生的）	</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031340026.png" alt="image-20240403134055559"></p>
</li>
<li><p>陷阱（同步）</p>
<ul>
<li>故意触发异常，是执行一条指令的结果，为用户程序和操作系统内核之间提供一个类似函数的接口</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031343706.png" alt="image-20240403134303996"></p>
</li>
<li><p>故障（同步）</p>
<ul>
<li>由错误情况引起，故障处理程序会尝试修复</li>
<li>经典示例：缺页异常</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031344402.png" alt="image-20240403134407074"></p>
</li>
<li><p>终止（同步）</p>
<ul>
<li>由不可恢复的致命错误导致</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031345806.png" alt="image-20240403134503470"></p>
</li>
</ul>
<h3 id="（2）x86-64系统中的异常"><a href="#（2）x86-64系统中的异常" class="headerlink" title="（2）x86-64系统中的异常"></a>（2）x86-64系统中的异常</h3><p>共定义256种异常，其中编号0-31所对应的异常由Intel的架构师定义，因此对于任意的x86-64系统都是一样的。编号32-255所对应的异常由操作系统定义。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404031346638.png" alt="image-20240403134638369"></p>
<h2 id="3、进程"><a href="#3、进程" class="headerlink" title="3、进程"></a>3、进程</h2><p>进程即一个正在执行的程序实例。</p>
<h3 id="（1）逻辑控制流"><a href="#（1）逻辑控制流" class="headerlink" title="（1）逻辑控制流"></a>（1）逻辑控制流</h3><p>当使用调试器来控制程序单步执行时，会得到一系列的程序计数器的数值，这些数值与可执行程序中的指令一一对应。把这个<strong>PC值的序列</strong>叫做<strong>逻辑控制流</strong>，简称逻辑流。</p>
<ul>
<li>区分并发和并行：<ul>
<li><strong>并发</strong>：并发指的是，在<strong>同一个处理器核</strong>上，多个任务<strong>同一时间段内交替地执行</strong>，它们共享系统资源</li>
<li><strong>并行</strong>：两个进程<strong>在不同的处理器核上同时运行</strong></li>
</ul>
</li>
</ul>
<h3 id="（2）用户态和内核态"><a href="#（2）用户态和内核态" class="headerlink" title="（2）用户态和内核态"></a>（2）用户态和内核态</h3><p>为了限制应用程序执行某些特殊的指令以及限制可以访问的地址空间范围，通常处理器通过<strong>控制寄存器（Control Register）的模式位</strong>实现这些限制功能。</p>
<ul>
<li><p>控制寄存器：描述进程当前的权限</p>
</li>
<li><p><strong>用户程序可以通过系统调用来间接地访问内核的代码和数据</strong></p>
</li>
<li><p>从User Mode到Kernel Mode：中断&#x2F;故障&#x2F;系统调用</p>
</li>
<li><p>上下文（Context）</p>
<ul>
<li><p><strong>内核为每个进程维持了一个上下文</strong>，是内核重启一个被抢占的进程所需的状态，状态包括如下：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032014836.png" alt="image-20240403201459671" style="zoom: 67%;" />
</li>
<li><p>内核调度进程时使用上下文切换的机制将控制转移到新的进程，分为以下三步：</p>
<ul>
<li>保存当前进程的上下文；</li>
<li>恢复某个先前被抢占进程的上下文；</li>
<li>将控制传递给这个新恢复的进程。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（3）进程的创建"><a href="#（3）进程的创建" class="headerlink" title="（3）进程的创建"></a>（3）进程的创建</h3><ul>
<li><p>进程的状态：运行、暂停、终止</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032028003.png" alt="image-20240403202844940" style="zoom:50%;" /></li>
</ul>
<h2 id="4、进程相关函数"><a href="#4、进程相关函数" class="headerlink" title="4、进程相关函数"></a>4、进程相关函数</h2><h3 id="（1）fork函数"><a href="#（1）fork函数" class="headerlink" title="（1）fork函数"></a>（1）fork函数</h3><p>调用该函数会返回两次：1）返回到父进程；2）返回到创建的子进程。<strong>父子进程各有一份副本，不同的进程有各自的栈（即各自的地址空间）。父子进程并发执行。</strong>以下图为例，父子进程有各自的x。</p>
<ul>
<li><p>父进程中fork的返回值是<strong>子进程的PID</strong>；</p>
</li>
<li><p>子进程中fork的返回值是<strong>0</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032031897.png" alt="image-20240403203131780"></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032050294.png" alt="image-20240403205019101"></p>
<h3 id="（2）execve-waitpid函数"><a href="#（2）execve-waitpid函数" class="headerlink" title="（2）execve&#x2F;waitpid函数"></a>（2）execve&#x2F;waitpid函数</h3><ul>
<li><p>execve函数</p>
<ul>
<li><code>*argv[]</code>：参数列表</li>
<li><code>*envp[]</code>：环境变量列表，包括当前的工作目录PWD、用户名等信息</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032052443.png" alt="image-20240403205217368" style="zoom: 67%;" />

<ul>
<li>作用：调用加载器，在执行可执行程序的main函数之前，启动代码需要设置的用户栈，并将控制传递给新程序的主函数。</li>
</ul>
</li>
<li><p>waitpid函数</p>
<ul>
<li><p>僵尸进程(<code>zombie</code>)：一个终止运行但是还未被父进程回收的进程。</p>
<blockquote>
<p>在大多数情况下，僵尸进程的大部分内存资源都会被回收，因为进程的地址空间、堆栈和数据段等资源都会在进程终止时由操作系统回收。但是，还有一些资源可能没有被完全回收：</p>
<ol>
<li><strong>进程描述符（Process Descriptor）：</strong> 操作系统仍然会保留僵尸进程的进程描述符，其中包含了一些关于进程的信息，比如进程 ID、父进程 ID、状态等。这些信息可以被父进程使用 <code>wait()</code> 或 <code>waitpid()</code> 函数来获取。</li>
<li><strong>进程表项（Process Table Entry）：</strong> 操作系统的进程表中仍然会保留僵尸进程的表项，这是因为操作系统需要跟踪所有进程的状态信息。</li>
</ol>
</blockquote>
</li>
<li><p>但父进程需要获取子进程的某些信息时，通过**waitpid()**等待它的子进程终止或者停止。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032103323.png" alt="image-20240403210325217"></p>
<ul>
<li>（1）pid &gt; 0<ul>
<li>表示等待的进程是一个单独的子进程，那么该子进程的ID即为该pid的值</li>
</ul>
</li>
<li>（2）pid &#x3D; -1<ul>
<li>表示等待的进程是由父进程创建的所有进程组成的集合</li>
</ul>
</li>
<li>status中存放导致返回的子进程的状态信息，用<code>statusp</code>指向</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032110406.png" alt="image-20240403211011042"></p>
</li>
</ul>
<h2 id="5、Linux信号"><a href="#5、Linux信号" class="headerlink" title="5、Linux信号"></a>5、Linux信号</h2><p>信号是软件形式的异常。</p>
<ul>
<li>进程组：默认情况下，父子进程属于一个进程组。可通过<code>setpgrp()</code>修改进程组。</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>Ch9 虚拟内存</title>
    <url>/2024/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CSAPP/CSAPP_Ch9%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="Ch9-虚拟内存"><a href="#Ch9-虚拟内存" class="headerlink" title="Ch9 虚拟内存"></a>Ch9 虚拟内存</h1><span id="more"></span>

<p>计算机系统三大件：CPU&#x2F;内存&#x2F;Disk</p>
<h2 id="1、虚拟内存"><a href="#1、虚拟内存" class="headerlink" title="1、虚拟内存"></a>1、虚拟内存</h2><p>“虚拟”这两个字究竟指的是什么？</p>
<h3 id="（1）两种寻址方法"><a href="#（1）两种寻址方法" class="headerlink" title="（1）两种寻址方法"></a>（1）两种寻址方法</h3><ul>
<li><p>物理地址</p>
<ul>
<li><p>将内存看作一个非常大的数组，将地址看作下标。</p>
</li>
<li><p>CPU访问时通过总线将物理地址发给内存控制器，取出具体的数据并返回给CPU。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032355663.png" alt="image-20240403235534488" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>虚拟寻址</p>
<ul>
<li><p>在CPU和内存中加入MMU（Memory Management Unit），通过MMU将物理地址转换为虚拟地址</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404032355710.png" alt="image-20240403235558629"></p>
</li>
</ul>
</li>
</ul>
<h3 id="（2）虚拟内存"><a href="#（2）虚拟内存" class="headerlink" title="（2）虚拟内存"></a>（2）虚拟内存</h3><ul>
<li><p><strong>地址空间</strong></p>
<ul>
<li><p>虚拟地址空间：用于存放进程运行时所需的代码、数据和堆栈等信息</p>
</li>
<li><p>如下图所示，<strong>8位</strong>的虚拟地址位数可以表示<strong>2^8个</strong>虚拟地址</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040006809.png" alt="image-20240404000647696"></p>
</li>
<li><p>物理地址空间</p>
</li>
</ul>
</li>
<li><p>CPU-Cache-内存-Disk</p>
</li>
<li><p>如下图所示的Virtual Pages，共N个字节，每个字节成为一个页（Page），每个页约为4KB-2MB。<strong>页是内存和磁盘间数据交换的单位。在虚拟内存中，数据通常被分割成称为页面（Page）或者页面帧（Page Frame）的固定大小的块，这些页面可以存储在物理内存中，也可以存储在磁盘上。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040017251.png" alt="image-20240404001727055"></p>
</li>
<li><p>虚拟内存中页的状态：</p>
<ul>
<li><p><code>Unallocated</code>：未分配数据，不占用磁盘空间；当调用<code>malloc()</code>函数时会用到这些未分配的页</p>
<blockquote>
<p><strong>malloc()分配的内存在堆上，为什么会分配一个虚拟页呢？</strong></p>
</blockquote>
</li>
<li><p><code>Cached</code>：该页的数据已经缓存到物理内存中，访问时CPU直接访问内存即可</p>
</li>
<li><p><code>UnCached</code>：已分配数据，但仍未缓存到物理内存中</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040020594.png" alt="image-20240404002021516"></p>
</li>
<li><p><strong>区分SRAM缓存和DRAM缓存</strong></p>
<ul>
<li>其中DRAM执行的是<strong>写回策略</strong>而非写穿透策略</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040022266.png" alt="image-20240404002223222" style="zoom:50%;" /></li>
</ul>
<h3 id="（3）页表"><a href="#（3）页表" class="headerlink" title="（3）页表"></a>（3）页表</h3><ul>
<li><p><strong>页表中的每一项页表项</strong>与<strong>虚拟内存中的每一页</strong>是一一对应的</p>
</li>
<li><p>MMU使用页表做虚拟地址到物理地址的映射</p>
</li>
<li><p><strong>页命中</strong>：要访问的目的数据页已经缓存到物理内存中</p>
<ul>
<li>若未命中，会触发缺页故障&#x2F;缺页异常，异常处理程序将页加载到物理内存中</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040029732.png" alt="image-20240404002955643" style="zoom:67%;" /></li>
</ul>
<h2 id="2、地址翻译"><a href="#2、地址翻译" class="headerlink" title="2、地址翻译"></a>2、地址翻译</h2><p><strong>地址翻译即为：将虚拟地址映射到真实物理地址</strong></p>
<ul>
<li>虚拟地址（VA） &#x3D; 虚拟页号（VPN）+ 虚拟页偏移量（VPO）<ul>
<li>虚拟页号：虚拟地址中用来索引页表的部分，<strong>表示了虚拟页在页表中的索引位置，用于确定对应的物理页框</strong></li>
<li>虚拟页偏移量：虚拟地址中用于表示页内偏移的部分，<strong>表示了虚拟页内的地址偏移量，用于在物理页框中定位具体的数据</strong>；每个页通常为<strong>4KB(&#x3D;4096Byte&#x3D;2^12，即12位)</strong></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040038957.png" alt="image-20240404003849872"></p>
<ul>
<li><p><strong>页命中的情况</strong></p>
<ul>
<li>VA：虚拟地址 &#x2F; PA：物理地址</li>
<li>PTEA：页表项地址 &#x2F; PTE：页表项</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040053564.png" alt="image-20240404005347498"></p>
</li>
<li><p><strong>缺页的情况</strong></p>
<ul>
<li>牺牲页（victim page）需要写回磁盘</li>
<li><strong>注意步骤7</strong>：<ul>
<li>步骤7在此处是因为当发现异常并处理完成后，会返回到原来引发异常的那条指令</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040054592.png" alt="image-20240404005427513"></p>
</li>
<li><p><strong>TLB&#x2F;Translation Lookaside Buffer</strong></p>
<ul>
<li>高速缓存，用于存储虚拟地址到物理地址的转换信息。它位于CPU和内存之间，用于加速虚拟地址到物理地址的转换过程。</li>
<li><strong>虚拟页号(VPN) &#x3D; TLBT(TLB Tag) + TLBI(TLB Index)</strong></li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040102671.png" alt="image-20240404010233622" style="zoom: 67%;" />
</li>
<li><p><strong>TLB Hit</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040106432.png" alt="image-20240404010601364"></p>
</li>
<li><p><strong>TLB Miss</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404040106189.png" alt="image-20240404010620118"></p>
</li>
<li><p>多级页表</p>
<ul>
<li><p>多级页表（Multi-level Page Tables）是一种用于管理大型虚拟内存空间的技术，它将整个虚拟地址空间分割成多个级别的页表，从而降低了页表的大小和访问时间。</p>
</li>
<li><p>下图是一个<strong>2级页表</strong>的示例。其中2级页表才指向真正的虚拟页的地址。 </p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041446551.png" alt="image-20240404144628382"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041508429.png" alt="image-20240404150817364"></p>
</li>
</ul>
</li>
</ul>
<h2 id="3、Inter-Core-i7"><a href="#3、Inter-Core-i7" class="headerlink" title="3、Inter Core i7"></a>3、Inter Core i7</h2><h3 id="（1）Cache-Hierarchy"><a href="#（1）Cache-Hierarchy" class="headerlink" title="（1）Cache Hierarchy"></a>（1）Cache Hierarchy</h3><ul>
<li>共4个Core(核心)，每个Core有自己的L1 d-cache(数据cache)、L1 i-cache(指令cache)和L2 cache</li>
<li>4个Core共享L3 cache</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041509298.png" alt="image-20240404150908225"></p>
<ul>
<li><p>单个Core中的结构（包含TLB）</p>
<ul>
<li><strong>L2 unified TLB直接连到了DDR3 memory controller上，访问内存</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041511470.png" alt="image-20240404151102359"></p>
</li>
</ul>
<h3 id="（2）i7中如何进行地址翻译"><a href="#（2）i7中如何进行地址翻译" class="headerlink" title="（2）i7中如何进行地址翻译"></a>（2）i7中如何进行地址翻译</h3><ul>
<li><p>CPU发出一个虚拟地址去访存（-48位）</p>
<ul>
<li><p><strong>VPN</strong>(&#x3D;TLBT(-32位)+TLBI(-4位))：-36位； <strong>VPO</strong>：-12位(&#x3D;2^12&#x3D;4096B&#x3D;4KB)</p>
</li>
<li><p>根据TLBI查询相应的Set</p>
</li>
<li><p>组成52位的物理地址</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041536104.png" alt="image-20240404153626039"></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041535284.png" alt="image-20240404153537221"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041537071.png" alt="image-20240404153719985"></p>
</li>
</ul>
<h3 id="（3）Page-Memory-Area（段-Segment）"><a href="#（3）Page-Memory-Area（段-Segment）" class="headerlink" title="（3）Page Memory Area（段&#x2F;Segment）"></a>（3）Page Memory Area（段&#x2F;Segment）</h3><blockquote>
<ol>
<li><strong>进程私有部分（Process Private Memory）：</strong> 每个进程拥有自己独立的虚拟内存空间，包括代码、数据、堆、栈等部分。这些内存区域是进程私有的，不同进程之间互不干扰。当进程被创建时，操作系统会为其分配一定的虚拟地址空间，进程可以在这个地址空间中进行内存操作。</li>
<li><strong>内核部分（Kernel Space）：</strong> 所有进程共享一份内核虚拟内存空间，其中包含了操作系统的内核代码和数据。这部分内存空间被所有进程共享，用于执行操作系统提供的系统调用、管理硬件资源等操作。进程无法直接访问内核空间，需要通过系统调用等方式请求操作系统执行相应的操作。</li>
</ol>
<p>总之，每个进程都有自己独立的虚拟内存空间，但所有进程共享一份内核虚拟内存空间。这种设计既保证了进程间的隔离和安全性，又能够高效地共享操作系统提供的资源和功能。</p>
</blockquote>
<ul>
<li>pdg——page global directory</li>
<li>mmap——结构体<ul>
<li>vm_start-vm_end——该段的起始地址到结束地址，如：共享库&#x2F;Data<ul>
<li>若在这个vm_area_struct中找不到合法的起始地址，将报错<code>segment fault</code></li>
</ul>
</li>
<li>vm_prot——protect 段的权限信息<ul>
<li>若找到了对应的地址，但和段的当前权限不匹配，如需要写，但该段仅可读，也会报错</li>
</ul>
</li>
<li>vm_flags——段的某些属性</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404041539849.png" alt="image-20240404153947715"></p>
<h2 id="4、内存映射"><a href="#4、内存映射" class="headerlink" title="4、内存映射"></a>4、内存映射</h2><p>通俗来讲，内存映射（Memory Mapping）是指要把段（Virtual Memory Area）上的内容（比如共享库、数据、代码等）与磁盘中的页关联起来。也即是将磁盘上的页加载到内存中的过程。</p>
<blockquote>
<p>内存映射是一种操作系统的内存管理技术，它允许将文件或其他设备映射到进程的虚拟地址空间，使得进程可以通过内存访问的方式来操作文件或设备。</p>
<p>在内存映射中，操作系统会在进程的虚拟地址空间中创建一个映射区域（Memory-mapped region），将文件的内容或设备的数据映射到这个区域中。进程可以像访问内存一样对这个映射区域进行读写操作，而不需要显式地进行文件的读写或设备的输入输出。</p>
</blockquote>
<p>对于如下图所示的ELF（Executable and Linkable Format）文件，将磁盘中的数据按照4KB的大小抽象成一页一页的虚拟页，映射到相应的虚拟地址空间中。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042220837.png" alt="image-20240404222055630"></p>
<p>这个过程也就是下图所示的<code>Loaded from the executable file</code>，<strong>这个过程只是做了一个映射，而并没有把实际的代码&#x2F;数据等写入真实物理内存。真正执行这一步是依靠缺页处理程序来实现的。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042221907.png" alt="image-20240404222120839"></p>
<p><strong>这里有个问题，那就是针对下图，对于代码段、数据段以及共享库段等，ELF文件（磁盘上）是有对应的数据对其进行映射的，但对于其他的部分，诸如用户栈、堆等，是没有可以与之映射的。</strong></p>
<ul>
<li>解决方法是将栈和堆映射到一个<strong>匿名文件（由内核创建）</strong>，也叫<strong>请求二进制（demand-zero）</strong>，其存储的全是二进制的0。当需要使用堆中的数据时（如malloc()），内核就去物理页中找一个页，用二进制0做覆盖并更新页表。</li>
</ul>
<p>也就是说：<strong>操作系统用匿名文件来映射栈和堆区域。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042226192.png" alt="image-20240404222601119"></p>
<ul>
<li><p>对于进程间的<strong>共享对象</strong>（如libc.so），不需要再复制一份到内存中，<strong>只需多个进程映射到一个相同的物理地址空间即可</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042234474.png" alt="image-20240404223431408"></p>
</li>
<li><p>对于<strong>私有对象</strong>，采用<code>copy-on-write</code>的策略</p>
<ul>
<li>在读数据时，和共享对象的映射策略一致；</li>
<li>一旦某个进程触发了一个写操作，则在写时需要<strong>先将其复制到内存上再进行修改</strong>，如下图2</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042235045.png" alt="image-20240404223543989"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042237697.png" alt="image-20240404223756633"> </p>
</li>
<li><p>用户级的内存映射函数：<code>mmap()</code></p>
<ul>
<li><code>*start</code>：一般为null，是由内核选择的虚拟地址空间的起始位置</li>
<li><code>length</code>：要映射的长度</li>
<li><code>prot</code>：权限问题</li>
<li><code>fd(file discriptor)</code></li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404042303799.png" alt="image-20240404230341734" style="zoom: 50%;" /></li>
</ul>
<h2 id="5、动态内存分配"><a href="#5、动态内存分配" class="headerlink" title="5、动态内存分配"></a>5、动态内存分配</h2><p>示例：<code>array = (int *)malloc(n * sizeof(int));</code>其中malloc()申请到的地址空间位于堆中。</p>
<p><code>brk</code>指针指向堆的最底端，<strong>堆的生长空间是从低地址到高地址</strong>，与之相区别的，<strong>栈的生长空间是从高地址到低地址</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404050001970.png" alt="image-20240405000133888" style="zoom:50%;" />

<ul>
<li><p><strong><code>malloc()</code>的地址返回需要对齐，32位要求为8的倍数，64位要求为16的倍数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> incr)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Allocator动态分配时的要求</p>
<ul>
<li>处理任意请求序列</li>
<li>立即响应请求</li>
<li>只使用堆</li>
<li>对齐块</li>
<li>不修改已分配的块</li>
</ul>
</li>
<li><p>Allocator动态分配时的目标</p>
<ul>
<li>最大化吞吐率</li>
<li>最大化内存利用率<ul>
<li>存在<strong>内部碎片（internal fragmentation）</strong>和<strong>外部碎片（external fragmentation）</strong><ul>
<li><strong>内部碎片：</strong> 当一个分配的内存块的实际大小大于请求的大小时，产生了内部碎片，分配的内存块中存在的一部分空闲的空间</li>
<li><strong>外部碎片：</strong> 外部碎片是指由于连续的空闲内存块分散在内存中，导致无法满足一个新的内存分配请求。即使系统总的空闲内存足够大，但由于空闲内存块分布不连续，导致无法找到一个足够大的连续空间来满足新的内存分配请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用malloc()申请到的一块内存的数据结构：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404050020437.png" alt="image-20240405002017373"></p>
<ul>
<li><p>Header：头部信息，用户成员无法访问该信息</p>
<ul>
<li><p>29个bit表示整个Header的大小</p>
</li>
<li><p>0-2位仅0位上有有效信息，表明该块是否被分配</p>
</li>
<li><p>这里用29位表示大小，而留下了最后3位，是由于内存对齐的要求下，要求大小为8的倍数，因此对于任意8的倍数的二进制表示，其最低三位都为0</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404050026188.png" alt="image-20240405002607101"  /></li>
</ul>
</li>
<li><p>Payload：有效载荷，即实际存放的数据，其大小为请求的内存空间大小</p>
</li>
<li><p>Padding：用于内存对齐，用户成员无法访问该信息</p>
</li>
</ul>
</li>
<li><p>隐式空闲链表（Implicit Free List）</p>
<ul>
<li>隐式空闲链表是动态内存分配中一种常见的内存管理数据结构，用于管理堆中的空闲内存块。在隐式空闲链表中，空闲的内存块不是显式地维护在一个链表中，而是通过在堆中连续的空闲内存块之间插入一个特殊的标记来隐式地表示空闲空间的位置和大小</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404050028163.png" alt="image-20240405002833100"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>CSAPP</category>
      </categories>
  </entry>
</search>
