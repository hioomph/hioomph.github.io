<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch_cat_logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/site_cat-32%C3%9732.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/site_cat-16%C3%9716.png">
  <link rel="mask-icon" href="/images/cat_logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="MIDORII&#39;S JOURNEY">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="MIDORII&#39;S JOURNEY">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="midorii">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>MIDORII'S JOURNEY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MIDORII'S JOURNEY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">a little bit sweet</p>
      <a>
        <img class="custom-logo-image" src="/images/cat.jpeg" alt="MIDORII'S JOURNEY">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/06/Computer/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/06/Computer/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">C++面向对象高级编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-06 20:14:02" itemprop="dateCreated datePublished" datetime="2024-05-06T20:14:02+08:00">2024-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-05 10:42:29" itemprop="dateModified" datetime="2024-07-05T10:42:29+08:00">2024-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/%E4%BE%AF%E6%8D%B7C-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">侯捷C++系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>326</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://lishizheng.blog.csdn.net/article/details/135360282">C++面向对象高级编程（侯捷）笔记1</a></p>
<p>2 头文件和类的声明<br>3 构造函数<br>4 参数传递与返回值<br>5 操作符重载与临时对象<br>    操作符重载1——成员函数<br>    操作符重载2——非成员函数<br>6 复习Complex类的实现过程</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/06/Computer/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/30/Computer/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/30/Computer/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">内存管理机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-30 13:07:46" itemprop="dateCreated datePublished" datetime="2024-04-30T13:07:46+08:00">2024-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-05 10:42:25" itemprop="dateModified" datetime="2024-07-05T10:42:25+08:00">2024-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/%E4%BE%AF%E6%8D%B7C-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">侯捷C++系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:01</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="第一讲-Primitives"><a href="#第一讲-Primitives" class="headerlink" title="第一讲 Primitives"></a>第一讲 Primitives</h1><h2 id="2-内存分配的每一层面"><a href="#2-内存分配的每一层面" class="headerlink" title="2 内存分配的每一层面"></a>2 内存分配的每一层面</h2><blockquote>
<ul>
<li>C++内存分配的深度一般是有五个层面，它们分别是<ul>
<li>C++ application 常见：vector等容器</li>
<li>C++ allocator 常见：vector自带的allocator分配器</li>
<li>C++ primitives 常见：new delete</li>
<li>CRT 常见：malloc free</li>
<li>OS API 常见：heapalloc等等</li>
</ul>
</li>
</ul>
<p>一般情况下，为了保证可移植性质，一般最底层就到了malloc free，如果调用OS API就基本上丧失了可移植性质。每一个层面的对应的基本上都会依次向下调用，然后进行内存的分配。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404301822840.png" alt="4_内存管理_01"></p>
<p>C++ memory primitives</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302008310.png" alt="4_内存管理_02"></p>
<h2 id="3-四个层面的基本用法"><a href="#3-四个层面的基本用法" class="headerlink" title="3 四个层面的基本用法"></a>3 四个层面的基本用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>				 <span class="comment">//std::allocator  </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext\pool_allocator.h&gt;</span>	 <span class="comment">//欲使用 std::allocator 以外的 allocator, 就得自行 #include &lt;ext/...&gt; </span></span></span><br><span class="line"><span class="keyword">namespace</span> jj01</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_primitives</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\ntest_primitives().......... \n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="type">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">512</span>);	<span class="comment">//512 bytes</span></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">    complex&lt;<span class="type">int</span>&gt;* p2 = <span class="keyword">new</span> complex&lt;<span class="type">int</span>&gt;; <span class="comment">//one object</span></span><br><span class="line">    <span class="keyword">delete</span> p2;             </span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p3 = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="number">512</span>); <span class="comment">//512 bytes</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下使用 C++ 標準庫提供的 allocators。</span></span><br><span class="line"><span class="comment">//其接口雖有標準規格，但實現廠商並未完全遵守；下面三者形式略異。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">    <span class="comment">//以下兩函數都是 non-static，定要通過 object 調用。以下分配 3 個 ints.</span></span><br><span class="line">    <span class="type">int</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">3</span>, (<span class="type">int</span>*)<span class="number">0</span>); </span><br><span class="line">    <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p4,<span class="number">3</span>);           </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __BORLANDC__</span></span><br><span class="line">    <span class="comment">//以下兩函數都是 non-static，定要通過 object 調用。以下分配 5 個 ints.</span></span><br><span class="line">    <span class="type">int</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">5</span>);  </span><br><span class="line">    <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p4,<span class="number">5</span>);       </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line">    <span class="comment">//以下兩函數都是 static，可通過全名調用之。以下分配 512 bytes.(GNUC 2.9)</span></span><br><span class="line">    <span class="comment">//void* p4 = alloc::allocate(512); </span></span><br><span class="line">    <span class="comment">//alloc::deallocate(p4,512);   </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下兩函數都是 non-static，定要通過 object 調用。以下分配 7 個 ints.(GNUC 4.9) </span></span><br><span class="line">	<span class="type">void</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">7</span>); </span><br><span class="line">    <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="type">int</span>*)p4,<span class="number">7</span>);     </span><br><span class="line">	</span><br><span class="line">    <span class="comment">//以下兩函數都是 non-static，定要通過 object 調用。以下分配 9 個 ints.(GNUC 4.9) 	</span></span><br><span class="line">	<span class="type">void</span>* p5 = __gnu_cxx::__pool_alloc&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">9</span>); </span><br><span class="line">    __gnu_cxx::__pool_alloc&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="type">int</span>*)p5,<span class="number">9</span>);	</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;	</span><br><span class="line">&#125; <span class="comment">//namespace</span></span><br></pre></td></tr></table></figure>

<h2 id="4-基本构件之一new-delete-expression上"><a href="#4-基本构件之一new-delete-expression上" class="headerlink" title="4 基本构件之一new delete expression上"></a>4 基本构件之一new delete expression上</h2><ul>
<li>new expression（即new operator）（详见<a target="_blank" rel="noopener" href="https://hioomph.github.io/2024/04/24/Computer/C++/new%E4%B8%8Eoperator%20new/">new与operator new</a>）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302012729.png" alt="https://hioomph.github.io/2024/04/24/Computer/C++/new%E4%B8%8Eoperator%20new/"></p>
<ul>
<li><p>右上角的operator new的实现（VC98版）</p>
<ol>
<li>调用malloc函数；</li>
<li>若malloc无法分配内存，就一直在while循环中：调用_callnewh，即一个new handler，用于处理内存分配失败的情况。</li>
</ol>
<blockquote>
<p>_callnewh 不是 C++ 标准中的函数，而是可能是用户定义的一个函数。通常情况下，这类函数的名字以 _new_handler 结尾，用于处理内存分配失败的情况。</p>
<p>在 C++ 中，当 new 表达式无法分配所需的内存时，会调用用户指定的 new_handler 函数。new_handler 是一个函数指针，指向一个用户定义的函数，其原型通常为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数可以尝试释放内存、扩大内存池，或者执行其他操作来尝试解决内存不足的问题。如果 new_handler 能够成功处理内存不足的情况，它返回；如果不能处理，它可以选择抛出异常或者终止程序。</p>
</blockquote>
</li>
</ul>
<h2 id="5-基本构件之一new-delete-expression中"><a href="#5-基本构件之一new-delete-expression中" class="headerlink" title="5 基本构件之一new delete expression中"></a>5 基本构件之一new delete expression中</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302021318.png" alt="4_内存管理_06"></p>
<h2 id="6-基本构件之一new-delete-expression下"><a href="#6-基本构件之一new-delete-expression下" class="headerlink" title="6 基本构件之一new delete expression下"></a>6 基本构件之一new delete expression下</h2><p>下面显示不能直接调用构造函数，而只有编译器会进行隐式调用。调用时在vc6编译通过，在GCC中编译失败。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A* pA = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">1</span>);         	<span class="comment">//ctor. this=000307A8 id=1</span></span><br><span class="line">cout &lt;&lt; pA-&gt;id &lt;&lt; endl;   	<span class="comment">//1</span></span><br><span class="line"><span class="comment">//!	pA-&gt;A::A(3);                //in VC6 : ctor. this=000307A8 id=3</span></span><br><span class="line">  								<span class="comment">//in GCC : [Error] cannot call constructor &#x27;jj02::A::A&#x27; directly</span></span><br><span class="line">  								</span><br><span class="line"><span class="comment">//!	A::A(5);	  				//in VC6 : ctor. this=0013FF60 id=5</span></span><br><span class="line">                      			<span class="comment">//         dtor. this=0013FF60  	</span></span><br><span class="line">  								<span class="comment">//in GCC : [Error] cannot call constructor &#x27;jj02::A::A&#x27; directly</span></span><br><span class="line">  								<span class="comment">//         [Note] for a function-style cast, remove the redundant &#x27;::A&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-Array-new"><a href="#7-Array-new" class="headerlink" title="7 Array new"></a>7 Array new</h2><p>（1）array new和array delete的搭配使用</p>
<p>如果<code>new[]</code>不搭配<code>delete[]</code>的话，实际上是针对<code>class with pointer member</code>的情况造成内存泄漏。<strong>此时若调用<code>delete</code>，带有<code>cookie</code>的动态数组部分实际上仍然会被回收，发生错误的地方是需要调用3次析构函数（如下图右边），但实际上只调用了1次，因此造成内存泄漏</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Complex* pca = <span class="keyword">new</span> Complex[<span class="number">3</span>];  <span class="comment">// 调用三次构造函数</span></span><br><span class="line"><span class="keyword">delete</span>[] pca;  <span class="comment">// 唤起三次析构函数， 这是正确的</span></span><br><span class="line"></span><br><span class="line">string* psa = <span class="keyword">new</span> string[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> psa;  <span class="comment">// 唤起一次析构函数，这是错误的</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302024595.png" alt="4_内存管理_08"></p>
<p>（2）array size in memory size</p>
<ul>
<li>右侧的图是new int[10]的内存布局，其中：<strong>灰色</strong>表示具体数据，<strong>橙色</strong>表示debug模式下添加的内存，最上面和最下面的两个0x61(61H)是cookie，记录整体内存分配的大小；<strong>浅蓝色</strong>的pad表示补齐，填补到16的倍数。<ul>
<li>61H实际上是60H，表示内存分配的大小，后面1H意思是占用最后一位，表示内存分配出去</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302027115.png" alt="4_内存管理_10"></p>
<h2 id="8-placement-new"><a href="#8-placement-new" class="headerlink" title="8 placement new"></a>8 placement new</h2><p>palcement new允许我们将object建构于allocated memory中。<strong>没有所谓的placement new，因为placement new根本没分配memory。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">sizeof</span>(Complex) * <span class="number">3</span>]; <span class="comment">// 已经分配了内存</span></span><br><span class="line">Complex* pc = <span class="built_in">new</span>(buf)<span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 把上面分配的内存位置传进来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br></pre></td></tr></table></figure>

<p>其中<code>Complex* pc = new(buf)Complex(1, 2);</code>这句话会被编译器转换为下图中的1，2，3三行，分别调用operator new（和上文看到的不同，这里需要第二个参数，表示位置，这个函数只是传回这个位置，不再分配内存），指针转型，调用构造函数。</p>
<p>这种用法被称为 “placement new”，它允许程序员在指定的内存位置上创建对象。这通常用于特殊的内存管理场景，例如在预分配的内存池中创建对象。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302031495.png" alt="4_内存管理_12"></p>
<h2 id="9-重载"><a href="#9-重载" class="headerlink" title="9 重载"></a>9 重载</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302031922.png" alt="4_内存管理_13"></p>
<p>（1）C++容器分配内存的途径</p>
<p>容器会走分配器，分配器会调用::operator new和::operator delete，底层也是调用malloc和free。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302033606.png" alt="4_内存管理_14"></p>
<p>在 C++ 中，容器使用分配器（Allocator）来进行内存分配和释放。分配器是负责管理容器内部元素内存的组件。下面是容器分配内存的一般途径：</p>
<ol>
<li><p>容器使用分配器：<br>C++ 容器（如 std::vector、std::list、std::map 等）通常使用分配器来分配和释放内存。分配器是容器的一部分，负责处理元素的内存分配和释放操作。</p>
</li>
<li><p>分配器调用 ::operator new 和 ::operator delete：<br>分配器的实现通常会调用全局作用域下的 ::operator new 来分配内存，并在需要释放内存时调用 ::operator delete。<br>::operator new 和 ::operator delete 是 C++ 中的全局内存分配和释放函数。它们底层可能调用标准库的 malloc 和 free。</p>
</li>
<li><p>底层可能调用 malloc 和 free：<br>malloc 和 free 是 C 标准库中的内存分配和释放函数，用于分配和释放原始的、未构造的内存块。C++ 的 ::operator new 和 ::operator delete 可能在底层调用这些函数。</p>
</li>
</ol>
<p>总体来说，C++ 容器使用分配器来管理内存，而分配器可能在其实现中调用 ::operator new 和 ::operator delete，从而涉及到底层的内存分配函数 malloc 和 free。这种设计允许用户自定义容器的内存管理行为，以适应不同的需求。用户可以通过提供自定义分配器来实现特定的内存分配策略。</p>
<p>（2）重载全局的::operator new 和::operator delete</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302034363.png" alt="4_内存管理_15"></p>
<p>（3）重载operator new和operator delete</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302034714.png" alt="4_内存管理_16"></p>
<p>（3）重载operator new[]和operator delete[]</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302035382.png" alt="4_内存管理_17"></p>
<h2 id="10-重载示例（上）"><a href="#10-重载示例（上）" class="headerlink" title="10 重载示例（上）"></a>10 重载示例（上）</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302036272.png" alt="4_内存管理_18"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302036230.png" alt="4_内存管理_19"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302036668.png" alt="4_内存管理_20"></p>
<h2 id="11-重载示例（下）"><a href="#11-重载示例（下）" class="headerlink" title="11 重载示例（下）"></a>11 重载示例（下）</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302036617.png" alt="4_内存管理_21"></p>
<p>placement new的重载第一参数必须是size_t类型，对于如何区分operator new和placement new，要看调用的时候怎么用。在调用时，编译器会根据传递给new表达式的参数来匹配适当的重载版本。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302038221.png" alt="4_内存管理_22"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302038657.png" alt="4_内存管理_23"></p>
<p>basic_string使用new(extra)扩充申请量</p>
<p>重载了operator new，其实是placement new。因为用法为<code>new(extra) Rep;</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302038299.png" alt="4_内存管理_24"></p>
<h2 id="12-Per-class-allocator"><a href="#12-Per-class-allocator" class="headerlink" title="12 Per class allocator"></a>12 Per class allocator</h2><p>（1）内存池</p>
<p>内存池是一种用于管理和分配内存的机制，它可以提高内存分配的效率，减少内存碎片，并降低动态内存分配的开销。在 C++ 中，内存池通常通过重载 operator new 和 operator delete 来实现。</p>
<p>下面简要描述一下内存池的概念，并提供一个简单的示意图：</p>
<ol>
<li><p>内存池概念：</p>
<ul>
<li>内存池是一块预先分配的内存区域，它被划分为多个小块，每个小块可以被分配给程序使用；</li>
<li>内存池通常由一个或多个链表、堆栈或其他数据结构来管理，以追踪哪些内存块是空闲的，哪些是已分配的；</li>
<li>内存池的目的是减少因频繁的内存分配和释放而引起的性能开销。</li>
</ul>
</li>
<li><p>示意图：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------+</span><br><span class="line">|            Memory Pool             |</span><br><span class="line">+------------------------------------+</span><br><span class="line">|   Free Block <span class="number">1</span>   |   Free Block <span class="number">2</span>  |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">|   Allocated Block <span class="number">1</span>                |</span><br><span class="line">+------------------------------------+</span><br><span class="line">|   Free Block <span class="number">3</span>   |   Free Block <span class="number">4</span>  |</span><br><span class="line">+------------------+-----------------+</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的示意图展示了一个简单的内存池，其中包含多个内存块，有一些是空闲的，有一些是已经分配给程序使用的；</li>
<li>每个内存块的大小可能不同，取决于内存池的设计；</li>
<li>空闲的内存块可以通过链表或其他数据结构连接在一起，以便快速分配。</li>
</ul>
</li>
<li><p>内存池的操作：</p>
<ul>
<li>当程序需要分配内存时，内存池会从空闲块中选择一个合适的块分配给程序；</li>
<li>当程序释放内存时，将相应的内存块标记为空闲，并重新加入空闲块链表，以便下次分配使用。</li>
</ul>
</li>
<li><p>自定义内存池的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> size;</span><br><span class="line">        Block* next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Block* freeList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MemoryPool</span>(<span class="type">size_t</span> poolSize) &#123;</span><br><span class="line">        <span class="comment">// 初始化内存池</span></span><br><span class="line">        <span class="type">void</span>* memory = ::<span class="keyword">operator</span> <span class="built_in">new</span>(poolSize);</span><br><span class="line">        freeList = <span class="built_in">static_cast</span>&lt;Block*&gt;(memory);</span><br><span class="line">        freeList-&gt;size = poolSize;</span><br><span class="line">        freeList-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从内存池中分配内存</span></span><br><span class="line">        <span class="keyword">if</span> (!freeList || freeList-&gt;size &lt; size) &#123;</span><br><span class="line">            <span class="comment">// 内存不足，或者没有空闲块，可以根据实际情况扩展内存池</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Block* allocatedBlock = freeList;</span><br><span class="line">        freeList = freeList-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(allocatedBlock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放内存到内存池</span></span><br><span class="line">        Block* block = <span class="built_in">static_cast</span>&lt;Block*&gt;(ptr);</span><br><span class="line">        block-&gt;next = freeList;</span><br><span class="line">        freeList = block;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述示例为了简洁，省略了一些内存池的管理细节</span></span><br><span class="line"><span class="comment">// 实际的内存池实现可能需要更复杂的数据结构和算法。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>引入内存池的考量：</p>
<p>当需要多次调用new来分配内存时，为了减少malloc分配内存的数量，以及减少cookie的用量，可以选择用malloc分配一大块内存（即内存池），然后将这块内存池分成小块，在实际的分配时直接取用其中的一小块，从而减少malloc的调用次数。</p>
</blockquote>
<p>（2）对类Screen进行内存设置的示例（设计类的内存分配器_版本1）</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302045487.png" alt="4_内存管理_25"></p>
<p>如下图右侧所示：</p>
<ul>
<li>左边间隔8，表示每个Screen对象内存分配的大小为8B，说明每个Screen分配的时候没有cookie；</li>
<li>右边间隔16，表示每个Screen对象内存分配的大小为16B，这是因为对象分配的时候上下加了cookie，最上面和最下面的cookie大小共为8B。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302046008.png" alt="4_内存管理_26"></p>
<h2 id="13-Per-class-allocator-2"><a href="#13-Per-class-allocator-2" class="headerlink" title="13 Per class allocator 2"></a>13 Per class allocator 2</h2><p>（1）设计类的内存分配器_版本2</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302047081.png" alt="4_内存管理_27"></p>
<p>这里和第一版本的最大不同是设计上采用union。</p>
<p>在C++中，union 是一种特殊的数据结构，允许在相同的内存位置存储不同类型的对象。它的每个成员共享相同的内存空间，只能同时使用一个成员。union 提供了一种有效利用内存的方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AirplaneRep</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> miles;  <span class="comment">// 4B</span></span><br><span class="line">	<span class="type">char</span> type;  <span class="comment">// 1B</span></span><br><span class="line">    <span class="comment">// 由于对齐，这5B会变成8B</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">	AirplaneRep rep;</span><br><span class="line">	Airplane* next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302047903.png" alt="4_内存管理_28"></p>
<h2 id="14-Static-allocator"><a href="#14-Static-allocator" class="headerlink" title="14 Static allocator"></a>14 Static allocator</h2><p>（1）设计类的内存分配器_版本3</p>
<p>下面是内存分配的第三版本。</p>
<p>从软件工程的角度看，上面的operator new和operator delete对于不同 类都要重载，明显不是一个好的解法，下面是将allocator抽象成一个类。</p>
<p>allocator类中定义allocate和deallocate函数，用于分配和回收。</p>
<p>下图中右侧是具体的实现。这里每次分配CHUNK个大小的一大块，然后切割成小块，并用链表串起来。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302049167.png" alt="4_内存管理_29"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302049165.png" alt="4_内存管理_30"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302049639.png" alt="4_内存管理_31"></p>
<h2 id="15-Macro-for-static-allocator"><a href="#15-Macro-for-static-allocator" class="headerlink" title="15 Macro for static allocator"></a>15 Macro for static allocator</h2><p>（1）设计类的内存分配器_版本4</p>
<p>把allocator的部分拿出来用宏来定义。</p>
<p>在C++中，宏（macro）是一种预处理指令，用于在编译过程中执行文本替换。宏通常通过 #define 关键字定义，并在代码中通过宏名称来调用。它们是一种简单的文本替换机制，可以用于创建常量、函数替代、条件编译等。</p>
<p>在宏定义的末尾使用反斜杠是为了告诉编译器该宏定义将在下一行继续。如果在宏定义的最后一行没有使用反斜杠，那么编译器会认为宏定义结束了。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302050403.png" alt="4_内存管理_32"></p>
<p>（2）标准库中的allocator</p>
<p>其中一种分配器有16条自由链表，来应对不同大小的块分配，不同的大小的类对象，分配到不同的链表中。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302050613.png" alt="4_内存管理_34"></p>
<h2 id="16-New-Handler"><a href="#16-New-Handler" class="headerlink" title="16 New Handler"></a>16 New Handler</h2><p>new handler</p>
<p>new handler 是一个与 C++ 内存分配和 new 操作符相关的概念。它是一个函数指针，指向一个用户定义的函数，该函数负责处理 new 操作符无法满足内存分配请求时的情况。</p>
<p>当 new 操作符无法分配所需的内存时，它会调用与之关联的 new handler。new handler 可以执行一些操作，例如释放一些已分配的内存、尝试扩展堆的大小、选择性地抛出异常，或者执行其他用户定义的操作。</p>
<p>使用 set_new_handler 函数设置 new handler：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">customNewHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed! Custom new handler called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::<span class="built_in">terminate</span>();  <span class="comment">// 终止程序或者执行其他处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(customNewHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试分配大块内存</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1000000000000</span>];  <span class="comment">// 如果分配失败，会调用 customNewHandler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，通过 set_new_handler 函数设置了一个自定义的 new handler，即 customNewHandler。当 new 操作符在尝试分配非常大的内存块时失败，会调用这个自定义的 new handler。</p>
<p>注意事项：</p>
<ul>
<li>new handler 是全局的，一旦设置，会在程序的生命周期内一直有效，直到被其他<code>set_new_handler</code>覆盖。</li>
<li>如果 new handler 返回，new 操作符会再次尝试分配内存，如果还失败，则再次调用 new handler。这个过程会一直重复，直到 new handler 抛出异常或者不返回（例如调用 <code>std::terminate()</code>）。</li>
<li>在 C++11 及以后的版本中，可以使用 std::get_new_handler 获取当前的 new handler，以便在需要时进行保存和恢复。</li>
</ul>
<p>使用 new handler 可以提供一些灵活性，允许程序员在内存分配失败的情况下采取定制的操作，而不是默认的行为（即抛出 std::bad_alloc 异常）。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302052495.png" alt="4_内存管理_35"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302052411.png" alt="4_内存管理_36"></p>
<h1 id="第二讲-std-allocator"><a href="#第二讲-std-allocator" class="headerlink" title="第二讲 std::allocator"></a>第二讲 std::allocator</h1><h2 id="17-VC6-malloc"><a href="#17-VC6-malloc" class="headerlink" title="17 VC6 malloc"></a>17 VC6 malloc</h2><p>VC6下的malloc内存块布局：从上往下分别是cookie，debug header, 实际数据的block, debug tail, pad, cookie，对应于下图。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062002434.png" alt="在这里插入图片描述"></p>
<p>在VC6（Visual C++ 6.0）下，malloc 函数分配的内存块的布局包含以下部分：</p>
<ul>
<li><p>Cookie（饼干）：<br>Cookie 是一小段额外的标识信息，用于在边界检查中检测缓冲区溢出。它通常是一个特殊的值，放置在分配的内存块的开始位置。记录内存分配出去的大小。</p>
</li>
<li><p>Debug Header（调试头部）：<br>Debug Header 包含一些调试信息，例如分配的文件名、行号等。这些信息用于调试和跟踪内存分配的源。</p>
</li>
<li><p>实际数据的 Block：<br>这是分配的实际数据块，用于存储程序员请求的数据。</p>
</li>
<li><p>Debug Tail（调试尾部）：<br>Debug Tail 包含与调试信息相关的尾部数据。类似于 Debug Header，它包含一些额外的调试信息。</p>
</li>
<li><p>Pad（填充）：<br>填充是为了确保分配的内存块满足特定的对齐要求。它可能包含一些额外的字节，使得整个内存块的大小满足特定的对齐条件。</p>
</li>
<li><p>Cookie（饼干）：<br>与开头的 Cookie 相对应，是分配的内存块的结束位置。</p>
</li>
</ul>
<p>这样的内存布局在 VC6 中用于调试和检测内存溢出等问题。Cookie 和调试信息是为了帮助调试过程，检测潜在的内存错误。在实际的发布版本中，这些额外的调试信息通常会被省略，以减小内存开销。 VC6 是相对较老的版本，现代的 Visual C++ 版本可能采用了更高效和精简的内存分配方案。</p>
<h2 id="18-VC6标准分配器之实现"><a href="#18-VC6标准分配器之实现" class="headerlink" title="18 VC6标准分配器之实现"></a>18 VC6标准分配器之实现</h2><p>VC6标准分配器allocator的实现，里面的allocate和deallocate的实现只是调用<code>::operator new </code>和<code>::operator delete</code>, 没有任何特殊设计。我们知道它们底层是malloc和free，所以具体分配的时候是带有cookie的，存在内存浪费的现象。</p>
<p>这里分配的单位是具体的类型，比如<code>allocator&lt;int&gt;().allocate(512,(int*)0);</code>分配的就是512个int类型的大小。而后面讲到的一个分配器是以字节为单位，不是以具体类型的大小为单位。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062004430.png" alt="在这里插入图片描述"></p>
<h2 id="19-BC5标准分配器之实现"><a href="#19-BC5标准分配器之实现" class="headerlink" title="19 BC5标准分配器之实现"></a>19 BC5标准分配器之实现</h2><p>Borland5 编译器的allocator的实现，里面的allocate和deallocate的实现只是调用<code>::operator new</code> 和<code>::operator delete</code>, 没有任何特殊设计。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062004019.png" alt="在这里插入图片描述"></p>
<h2 id="20-G2-9标准分配器之实现"><a href="#20-G2-9标准分配器之实现" class="headerlink" title="20 G2.9标准分配器之实现"></a>20 G2.9标准分配器之实现</h2><p>GNU C++2.9标准分配器std::allocator的实现，里面的allocate和deallocate的实现只是调用<code>::operator new </code>和<code>::operator delete</code>, 没有任何特殊设计。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062005939.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>GNU C++2.9容器使用的分配器，不是std::allocator,而是std::alloc</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* p = alloc::<span class="built_in">allocate</span>(<span class="number">512</span>); <span class="comment">// 分配512bytes，不是512个int或者512个double类型等等</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062006939.png" alt="在这里插入图片描述"></p>
<h2 id="21-G2-9-std-alloc-VS-G4-9-pull-alloc"><a href="#21-G2-9-std-alloc-VS-G4-9-pull-alloc" class="headerlink" title="21 G2.9 std::alloc VS G4.9 __pull_alloc"></a>21 G2.9 std::alloc VS G4.9 __pull_alloc</h2><blockquote>
<p>G2.9 std::alloc在G4.9中是 __pull_alloc。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062006172.png" alt="在这里插入图片描述"></p>
<p>G4.9版本中标准分配器std::allocator的实现，里面的allocate和deallocate的实现只是调用::operator new 和::operator delete, 没有任何特殊设计。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062006067.png" alt="在这里插入图片描述"></p>
<h2 id="22-G4-9-pull-alloc用例"><a href="#22-G4-9-pull-alloc用例" class="headerlink" title="22 G4.9 __pull_alloc用例"></a>22 G4.9 __pull_alloc用例</h2><p>这里的alloc（G2.9的叫法, G4.9叫做__pull_alloc）用法, 它在__gnu_cxx这个命名空间内。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>, __gnu_cxx::__pool_alloc&lt;<span class="type">int</span>&gt;&gt; vecPool;</span><br></pre></td></tr></table></figure>

<p>这个分配器是去除了cookie（一个元素带有上下两个cookie，共8B），可以省很多的内存空间。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062007981.png" alt="在这里插入图片描述"></p>
<h2 id="23-G2-9-std-alloc"><a href="#23-G2-9-std-alloc" class="headerlink" title="23 G2.9 std::alloc"></a>23 G2.9 std::alloc</h2><p>（1）alloc的运作模式</p>
<p>第一讲中介绍的Per class allocator类，每个类里面重载了 operator new和operator delete，每个类都单独维护一个链表。如下图所示，<code>std::alloc</code>为所有的类维护16个链表，每个链表负责不同大小的区块分配，从小到大分别为：<code>8B, 16B, 24B, 32B, …, 128B</code>，按8的倍数增长。<strong>当大小不为8的倍数的时候，分配器会自动将其对齐到8的倍数。当大小超过128B时，就交给malloc来单独处理。</strong></p>
<blockquote>
<p>这里可以联系到面经中的问答：malloc函数的底层实现是什么？及相关问题。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011019232.png" alt="4_内存管理_51"></p>
<p><strong>举例：</strong>对于<code>#3</code>链表，每次将分配一大块内存给它（负责32B区块的分配，里面有20个小块，每个都是32B，但是实际分配的时候是20块的两倍大小，剩余的部分可能分配给其他的<code>#x</code>链表）。当一个vector里面存储一个32B的stone类型的对象，会在<code>#3</code>链表里指定一小块给该对象。</p>
<p>（2）embedded pointers</p>
<blockquote>
<p>嵌入式指针工作原理：借用A对象所占用的内存空间中的前4个字节，这4个字节用来 链住这些空闲的内存块；<br>但是，一旦某一块被分配出去，那么这个块的 前4个字节 就不再需要，此时这4个字节可以被正常使用；</p>
<p>参考:<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42604176/article/details/113871565">https://blog.csdn.net/qq_42604176/article/details/113871565</a></p>
<p>内存的使用方法是,使用的时候看成对象实例,空闲的时候会看成next指针.</p>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/KinWaiYuen/KinWaiYuen.github.io/blob/master/c%2B%2B/%E4%BE%AF%E6%8D%B7%E5%86%85%E5%AD%98.md">https://github.com/KinWaiYuen/KinWaiYuen.github.io/blob/master/c%2B%2B/%E4%BE%AF%E6%8D%B7%E5%86%85%E5%AD%98.md</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011041526.png" alt="4_内存管理_52"></p>
<h2 id="24-G2-9-std-alloc运行一瞥01-05"><a href="#24-G2-9-std-alloc运行一瞥01-05" class="headerlink" title="24 G2.9 std::alloc运行一瞥01-05"></a>24 G2.9 std::alloc运行一瞥01-05</h2><p>（1）源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;                        <span class="comment">//小區塊的上調邊界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;                  <span class="comment">//小區塊的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;; <span class="comment">//free-lists 個數</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// union obj &#123;                   //G291[o],CB5[x],VC6[x]</span></span><br><span class="line"><span class="comment">//   union obj* free_list_link;  //這麼寫在 VC6 和 CB5 中也可以，</span></span><br><span class="line"><span class="comment">// &#125;;                            //但以後就得使用 &quot;union obj&quot; 而不能只寫 &quot;obj&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__obj</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__obj</span>* free_list_link;</span><br><span class="line">&#125; obj;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*   start_free = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>*   end_free = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span>  heap_size = <span class="number">0</span>;</span><br><span class="line">obj* free_list[__NFREELISTS]</span><br><span class="line">     = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="meta"># enum &#123;__ALIGN = 8&#125;;  </span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ROUND_UP</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个常量<code>__ALIGN</code>，它表示内存分配时的对齐边界，设定为8字节。然后，定义了一个函数 <code>ROUND_UP</code>，该函数接受一个大小（<code>bytes</code>）作为参数，然后将其上调到对齐边界。</p>
<p>具体来说，<code>ROUND_UP</code>函数的作用是将传入的大小（<code>bytes</code>）上调到<code>__ALIGN</code>的倍数。这是通过以下步骤实现的：</p>
<ul>
<li>将<code>bytes</code>加上<code> __ALIGN-1</code>，即<code> bytes + 7</code>；</li>
<li>对结果进行按位与操作，通过<code>&amp; ~(__ALIGN - 1)</code>将最低的3位清零，确保结果是<code>__ALIGN</code>的倍数。</li>
</ul>
<blockquote>
<p>这样做的目的是为了满足内存对齐的要求。在一些硬件体系结构中，访问未对齐的内存可能会导致性能问题或者错误，因此内存分配时通常需要对齐到某个特定的边界。这个函数就提供了一种简单的方法来确保分配的内存大小是对齐的。</p>
</blockquote>
<p>（2）std::alloc运行01-05</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053088.png" alt="4_内存管理_53"></p>
<ol start="2">
<li>当一个容器里面存储的元素大小是<code>32B</code>时，它的运作过程如下：</li>
</ol>
<ul>
<li><p>挂在<code>32 / 8 - 1 = #3</code>号链表；</p>
</li>
<li><p>刚开始的时候pool为空，此时要分配<code>32 * 20 *2 + RoundUp(0 &gt;&gt; 4)= 1280B</code>大小的空间为pool，然后从pool里面切割20个小块（共640B）挂在<code>#3</code>链表上。第1个给容器，剩下的19个挂在<code>#3</code>链表；</p>
</li>
<li><p>此时pool的余量为<code>640B</code>。RoundUp是追加量，里面的大小是把上次的累计申请量右移4位(除以16)，由于这里是刚开始，没有累计申请量，故为0&gt;&gt;4。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053848.png" alt="4_内存管理_54"></p>
</li>
</ul>
<ol start="3">
<li>此时，又创建了新的容器，它里面的元素大小为<code>64B</code></li>
</ol>
<ul>
<li>对应#7链表；</li>
<li>此时链表为空。由于上页的pool里面还剩<code>640B</code>，现在将其切分为<code>640/64 = 10</code>个区块，第1个给容器，剩下的9个挂在<code>#7</code>链表；</li>
<li>此时pool的余量为<code>0B</code>，因为被切分挂到链表上了。<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053984.png" alt="4_内存管理_55"></li>
</ul>
<ol start="4">
<li>在上面的基础上，现在新建容器，它的元素大小为<code>96B</code></li>
</ol>
<ul>
<li>对应<code>96 / 8 - 1 = #11</code>链表；</li>
<li>先检查pool是否有余量，由于pool为空，此时调用malloc分配一大块作为pool，总共大小为<code>96x 20 x 2 + RoundUp(1280 &gt;&gt; 4) = 3840 + 80 = 3920B</code>，切割20个区块拿出来用，第1个给容器，另外19个挂在<code>#11</code>链表上；</li>
<li>此时pool的余量为<code>3920−(96×20)=3920−1920=2000 B</code>。累计申请量是1280 + 3920 &#x3D; 5200B。<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053482.png" alt="4_内存管理_56"></li>
</ul>
<ol start="5">
<li>再次新建容器，里面元素大小是<code>88B</code></li>
</ol>
<ul>
<li><p>挂在<code>88 / 8 - 1 = #10</code>号链表；</p>
</li>
<li><p>现在pool中的余量为<code>2000B</code>，将2000B切分为20个区块（每个区块88B），第1个给容器，剩下的19个挂在<code>#10</code>链表上；</p>
</li>
<li><p>此时pool的余量为<code>2000 - 88 x 20 = 240B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053390.png" alt="4_内存管理_57"></p>
</li>
</ul>
<h2 id="25-G2-9-std-alloc运行一瞥06-10"><a href="#25-G2-9-std-alloc运行一瞥06-10" class="headerlink" title="25 G2.9 std::alloc运行一瞥06-10"></a>25 G2.9 std::alloc运行一瞥06-10</h2><ol start="6">
<li>下面这张图表示容器**连续申请3次<code>88B</code>**大小的空间</li>
</ol>
<ul>
<li><p>由于上面已经在<code>#10</code>链表上挂了19个大小为<code>88B</code>的区块，这时候直接从该链表上拿下来3个区块返回给容器即可；</p>
</li>
<li><p>此时pool的余量为<code>240B</code>没变。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021045105.png" alt="4_内存管理_58"></p>
</li>
</ul>
<ol start="7">
<li>又来新的容器，它的元素大小为8B</li>
</ol>
<ul>
<li><p>挂在<code>8 / 8 - 1 = #0</code>号链表；</p>
</li>
<li><p>根据06，pool容量为<code>240B</code>，从pool里面切分出20个区块，共<code>8B x 20 = 160B</code>大小，第1个返回给容器，其余19个区块挂在<code>#0</code>链表上；</p>
</li>
<li><p>此时pool的余量为<code>240 - 160 = 80B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021045366.png" alt="4_内存管理_59"></p>
</li>
</ul>
<ol start="8">
<li>又来新的容器，它的元素大小为<code>104B</code></li>
</ol>
<ul>
<li><p>挂在<code>104 / 8 - 1 = #12</code>链表；</p>
</li>
<li><p>由于此时pool余量为<code>80B</code>，一个大小为<code>104B</code>的区块都切分不了。此时这个<code>80B</code>大小的空间就是碎片，需要将其挂在<code>80 / 8 - 1 = #9</code>链表上。碎片处理完之后， 再来应付现在的需求：<code>104B</code>的分配；</p>
</li>
<li><p>现在再调用<code>malloc</code>分配一大块，大小为<code>104 x 20 x 2 + RoundUp(5200 &gt;&gt; 4) = 4160 + RoundUp(325) = 4160 + 328 = 4488</code>；把第1个分配给容器，切出的19个挂在<code>#12</code>链表上。累计申请量为<code>5200 + 4488 = 9688B</code>；</p>
</li>
<li><p>此时pool的余量为<code>4488 - 104 x 20 = 2408B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021045618.png" alt="4_内存管理_60"></p>
</li>
</ul>
<ol start="9">
<li>现在申请<code>112B</code></li>
</ol>
<ul>
<li><p>挂在<code>112 / 8 - 1 = #13</code>链表上；</p>
</li>
<li><p>根据08，pool容量为<code>2408B</code>，从里面取出<code>112 * 20 = 2240B</code>，第1个返回给容器，留下19个挂在<code>#13</code>链表上；</p>
</li>
<li><p>此时pool的余量为<code>2408 - 2240 = 168B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021045344.png" alt="4_内存管理_61"></p>
</li>
</ul>
<ol start="10">
<li>现在的新需求是申请<code>48B</code></li>
</ol>
<ul>
<li>挂在<code>48 / 8 - 1 = #5</code>链表上；</li>
<li>根据09，pool余量是<code>168B</code>，可以分配<code>168 / 48 = 3</code>个区块，第1个返回给容器，剩下2个挂在<code>#5</code>链表上；</li>
<li>此时pool的余量为<code>24B</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021046301.png" alt="4_内存管理_62"></p>
<h2 id="26-G2-9-std-alloc运行一瞥11-13"><a href="#26-G2-9-std-alloc运行一瞥11-13" class="headerlink" title="26 G2.9 std::alloc运行一瞥11-13"></a>26 G2.9 std::alloc运行一瞥11-13</h2><p>下面看一下内存分配失败的动作。</p>
<ol start="11">
<li>新的容器请求<code>72B</code>的大小</li>
</ol>
<ul>
<li><p>挂在<code>72 / 8 - 1 = #8</code>链表；</p>
</li>
<li><p>pool容量为<code>24B</code>，不足以分配一个大小为<code>72B</code>的区块，于是这个大小为<code>24B</code>的pool就成为碎片，需要先挂在<code>24 / 8 - 1 = #2</code>链表，所以把这个pool余量挂在#2链表, 然后调用malloc分配<code>72 x 20 x 2 + RoundUP(9688 &gt;&gt; 4) = 3488B</code>。在实验过程中把系统heap大小设置为<code>10000B</code>，前面已经累计分配了<code>9688B</code>，因此无法满足本次内存分配。</p>
</li>
<li><p>此时，alloc从手中资源取最接近<code>72B</code>的大小回填pool，这里最接近的是<code>80B</code>(即在<code>#9</code>链表有1个空的区块可用)，然后从其<code>80B</code>中切<code>72B</code>给容器，此时pool的余量为<code>80 - 72 = 8B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021131569.png" alt="4_内存管理_63"></p>
</li>
</ul>
<ol start="12">
<li>容器再申请<code>72B</code></li>
</ol>
<ul>
<li><p><code>#8</code>链表没有区块可用，而pool余量为<code>8B</code>，不足以供应1个区块。因此先将pool余量挂在<code>#0</code>链表上，然后想要调用malloc分配<code>72 x 20 x 2 + RoundUP(9688 &gt;&gt; 4) = 3488B</code>的空间，此时依然无法满足分配；</p>
</li>
<li><p>于是alloc从手中资源取最接近<code>72B</code>的<code>88B</code>（#10链表）回填pool。因为上面的<code>80B</code>（<code>#9</code>链表）已经用完了，从<code>88B</code>中切出<code>72B</code>返回给容器；</p>
</li>
<li><p>此时pool余量为<code>88 - 72 = 16B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021133827.png" alt="4_内存管理_64"></p>
</li>
</ul>
<ol start="13">
<li>新的容器申请<code>120B</code></li>
</ol>
<ul>
<li><p>挂在<code>120 / 8 - 1 = #14</code>链表；</p>
</li>
<li><p>同样的，pool供应不足，先将上面的<code>16B</code>挂在<code>#1</code>链表上，再想要malloc分配一大块也分配不出，无法满足需求；</p>
</li>
<li><p>于是，alloc从手中资源中取最接近<code>120B</code>的区块回填pool，但是<code>#14</code>链表和<code>#15</code>链表都是空的，于是无法分配。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021135087.png" alt="4_内存管理_65"></p>
</li>
</ul>
<ol start="14">
<li>检讨</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021135931.png" alt="4_内存管理_66"></p>
<h2 id="27-G2-9-std-alloc源码剖析（上）"><a href="#27-G2-9-std-alloc源码剖析（上）" class="headerlink" title="27 G2.9 std::alloc源码剖析（上）"></a>27 G2.9 std::alloc源码剖析（上）</h2><p>GNU C++2.9 分配器的设计：分为两级分配器，分别是第一级分配器和第二级分配器.</p>
<ol>
<li>第一级分配器</li>
</ol>
<p>其中<strong>第一级分配器不重要</strong>，主要模拟new handler的作用，处理一下内存分配的情况。下列图片是第一级分配器的代码。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041115341.png" alt="4_内存管理_67"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041115436.png" alt="4_内存管理_68"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041116564.png" alt="4_内存管理_69"></p>
<ol start="2">
<li>第二级分配器</li>
</ol>
<p>（1）定义</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041140479.png" alt="4_内存管理_70"></p>
<ul>
<li><p>ROUND_UP：将分配的大小变成8的倍数；</p>
</li>
<li><p>FREELIST_INDEX：根据bytes的大小指定分配到哪个链表；</p>
</li>
<li><p>几个变量的作用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>*   start_free = <span class="number">0</span>; <span class="comment">// 指向战备池pool的头</span></span><br><span class="line"><span class="type">char</span>*   end_free = <span class="number">0</span>;   <span class="comment">// 指向战备池pool的尾</span></span><br><span class="line"><span class="type">size_t</span>  heap_size = <span class="number">0</span>;  <span class="comment">// 累计分配大小</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>（2）最重要的两个函数：allocate和deallocate</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041141570.png" alt="4_内存管理_71"></p>
<ul>
<li><p><code>allocate</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span>  <span class="comment">//n must be &gt; 0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  obj* <span class="keyword">volatile</span> *my_free_list;    <span class="comment">//obj** my_free_list;</span></span><br><span class="line">  obj* result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>)__MAX_BYTES) &#123; <span class="comment">// 大于128B，交给第一级分配器来分配</span></span><br><span class="line">      <span class="keyword">return</span>(<span class="built_in">malloc_allocate</span>(n));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);  <span class="comment">// 定位到几号链表</span></span><br><span class="line">  result = *my_free_list;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;  <span class="comment">// 该链表为空</span></span><br><span class="line">      <span class="type">void</span>* r = <span class="built_in">refill</span>(<span class="built_in">ROUND_UP</span>(n));  <span class="comment">// 链表充值，从pool中去拿区块，链表有了可用区块</span></span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 指针指向下一个可用区块</span></span><br><span class="line">  *my_free_list = result-&gt;free_list_link;</span><br><span class="line">  <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041143025.png" alt="4_内存管理_72"></p>
</li>
<li><p><code>deallocate</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> n)</span>  <span class="comment">//p may not be 0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  obj* q = (obj*)p;</span><br><span class="line">  obj* <span class="keyword">volatile</span> *my_free_list;  <span class="comment">//obj** my_free_list;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>) __MAX_BYTES) &#123;  <span class="comment">// 大于128B，改用第一级分配器进行回收</span></span><br><span class="line">      <span class="built_in">malloc_deallocate</span>(p, n);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 回收过来的p指针指向的区块，挂在单向链表的头</span></span><br><span class="line">  my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);  <span class="comment">// 指向16个链表中的一个，比如list #6,如下图所示</span></span><br><span class="line">  q-&gt;free_list_link = *my_free_list;  <span class="comment">// q的next指向单向链表的头，就是list #6指向的具体区块的单向链表（free_list_link即next指针）</span></span><br><span class="line">  *my_free_list = q;  <span class="comment">// my_free_list重新指向新的单向链表q，因为头指针被换成新的了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041143591.png" alt="4_内存管理_73"></p>
</li>
</ul>
<h2 id="28-G2-9-std-alloc源码剖析（中）"><a href="#28-G2-9-std-alloc源码剖析（中）" class="headerlink" title="28 G2.9 std::alloc源码剖析（中）"></a>28 G2.9 std::alloc源码剖析（中）</h2><ul>
<li><code>refill</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041150983.png" alt="4_内存管理_75"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="comment">// Returns an object of size n, and optionally adds</span></span><br><span class="line"><span class="comment">// to size n free list. We assume that n is properly aligned.</span></span><br><span class="line"><span class="comment">// We hold the allocation lock.</span></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">refill</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span>* chunk = <span class="built_in">chunk_alloc</span>(n,&amp;nobjs);</span><br><span class="line">    obj* <span class="keyword">volatile</span> *my_free_list;   <span class="comment">//obj** my_free_list;</span></span><br><span class="line">    obj* result;</span><br><span class="line">    obj* current_obj;</span><br><span class="line">    obj* next_obj;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);</span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Build free list in chunk</span></span><br><span class="line">    result = (obj*)chunk;</span><br><span class="line">    *my_free_list = next_obj = (obj*)(chunk + n);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;  ; ++i) &#123;</span><br><span class="line">      current_obj = next_obj;</span><br><span class="line">      next_obj = (obj*)((<span class="type">char</span>*)next_obj + n);</span><br><span class="line">      <span class="keyword">if</span> (nobjs<span class="number">-1</span> == i) &#123;</span><br><span class="line">          current_obj-&gt;free_list_link = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          current_obj-&gt;free_list_link = next_obj;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，next_obj 的计算是为了在内存块（chunk）上构建一个链表，以形成一个自由链表（free list）。这个链表将被用于分配对象。让我们解释一下这行代码的目的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next_obj = (obj*)((<span class="type">char</span>*)next_obj + n);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>next_obj</code>是一个指向当前空闲块的指针，它一开始指向<code>chunk + n</code>，即第一个可用的内存块；</li>
<li><code>(char*)next_obj</code>将<code>next_obj</code>强制类型转换为<code>char*</code>类型，这是因为我们希望按字节递增，而不是按对象递增；</li>
<li><code>((char*)next_obj + n)</code>表示将指针移动到下一个内存块的起始位置，即当前内存块的末尾加上一个对象的大小<code>n</code>；</li>
<li><code>(obj*)((char*)next_obj + n)</code>将移动后的指针重新转换为<code>obj*</code>类型，以便正确指向下一个空闲块的起始位置。</li>
</ul>
<p>这样，通过不断地按对象大小 n 的步长在内存块上移动，构建了一个包含多个空闲块的链表。这个链表可以有效地用于分配对象。这种处理方式是为了确保链表中相邻的空闲块之间的间隔是 n 字节，从而满足对象的对齐需求。</p>
<p>在上述代码中，for 循环的第二个条件 ; 是一个空语句，表示没有额外的条件来控制循环的执行。这意味着 for 循环会一直执行，直到执行到 break 语句为止。</p>
<p>在这个具体的代码中，循环的目的是为了在内存块上构建一个链表，将多个空闲块连接在一起。循环体中的 if 语句用于判断是否已经遍历了 nobjs-1 个空闲块。如果是，则最后一个空闲块的 free_list_link 设置为 0，表示链表的结束。此时，break 语句被执行，跳出循环。</p>
<p>因此，循环终止的条件是遍历了 nobjs-1 个空闲块，确保链表的正确构建，并在最后一个空闲块处设置了结束标志。循环的终止是由 break 语句触发的，而不是由循环条件控制的。</p>
<ul>
<li><code>chunk_alloc</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041210910.png" alt="4_内存管理_74"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041210501.png" alt="4_内存管理_75"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="comment">// We allocate memory in large chunks in order to</span></span><br><span class="line"><span class="comment">// avoid fragmentingthe malloc heap too much.</span></span><br><span class="line"><span class="comment">// We assume that size is properly aligned.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocates a chunk for nobjs of size &quot;size&quot;.</span></span><br><span class="line"><span class="comment">// nobjs may be reduced if it is inconvenient to</span></span><br><span class="line"><span class="comment">// allocate the requested number.</span></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="comment">//char* chunk_alloc(size_t size, int&amp; nobjs)  //G291[o],VC6[x],CB5[x]</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">chunk_alloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span>* nobjs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span>* result;</span><br><span class="line">  <span class="comment">// 调用chunk_alloc的时候，nobjs为20，所以默认total_bytes为20个区块的大小</span></span><br><span class="line">  <span class="type">size_t</span> total_bytes = size * (*nobjs);   <span class="comment">// 原nobjs改為 (*nobjs)</span></span><br><span class="line">  <span class="type">size_t</span> bytes_left = end_free - start_free; <span class="comment">// pool中剩余的字节个数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. pool空间足以满足20块需求</span></span><br><span class="line">  <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;  </span><br><span class="line">      result = start_free;  <span class="comment">// 将原来的start_free作为结果传回去</span></span><br><span class="line">      start_free += total_bytes;  <span class="comment">// 调整pool水位，下降，战备池pool变小</span></span><br><span class="line">      <span class="keyword">return</span>(result);</span><br><span class="line">  <span class="comment">// 2. pool空间只能满足1个及以上区块的需求，但不足20块</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) &#123; </span><br><span class="line">      *nobjs = bytes_left / size;     <span class="comment">//原nobjs改為 (*nobjs)，改变需求数，看看可以切成几个区块</span></span><br><span class="line">      total_bytes = size * (*nobjs);  <span class="comment">//原nobjs改為 (*nobjs)，改变需求总量</span></span><br><span class="line">      result = start_free;</span><br><span class="line">      start_free += total_bytes;</span><br><span class="line">      <span class="keyword">return</span>(result);</span><br><span class="line">  <span class="comment">// 3. pool空间不足以满足1块需求，pool空间可能是碎片，也可能表示pool大小为0</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">      <span class="type">size_t</span> bytes_to_get =  </span><br><span class="line">                 <span class="number">2</span> * total_bytes + <span class="built_in">ROUND_UP</span>(heap_size &gt;&gt; <span class="number">4</span>);  <span class="comment">// 需要请求的一大块的大小</span></span><br><span class="line">      <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">      <span class="comment">// 先将pool池的碎片挂到对应大小的链表上</span></span><br><span class="line">      <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          obj* <span class="keyword">volatile</span> *my_free_list =  <span class="comment">// 找出应转移到第#号链表</span></span><br><span class="line">                 free_list + <span class="built_in">FREELIST_INDEX</span>(bytes_left);</span><br><span class="line">		  <span class="comment">// 将pool空间编入第#号链表，next指针指向链表的头节点，编入链表的第一个节点</span></span><br><span class="line">          ((obj*)start_free)-&gt;free_list_link = *my_free_list;</span><br><span class="line">          *my_free_list = (obj*)start_free;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 上面处理完pool的碎片，pool为空，开始用malloc为pool分配内存</span></span><br><span class="line">      start_free = (<span class="type">char</span>*)<span class="built_in">malloc</span>(bytes_to_get); <span class="comment">// pool的起点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123;  <span class="comment">// 分配失败，从free list中找区块（向右边更大的区块去找）</span></span><br><span class="line">          <span class="type">int</span> i;</span><br><span class="line">          obj* <span class="keyword">volatile</span> *my_free_list, *p;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//Try to make do with what we have. That can&#x27;t</span></span><br><span class="line">          <span class="comment">//hurt. We do not try smaller requests, since that tends</span></span><br><span class="line">          <span class="comment">//to result in disaster on multi-process machines.</span></span><br><span class="line">          <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123; <span class="comment">// 向右侧的链表去找区块，例如88B，96B，104B， 112B等等</span></span><br><span class="line">              my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(i);</span><br><span class="line">              p = *my_free_list;</span><br><span class="line">              <span class="keyword">if</span> (<span class="number">0</span> != p) &#123; <span class="comment">// 找到右边的list中的可用区块，只释放一块给pool</span></span><br><span class="line">                  *my_free_list = p -&gt; free_list_link;</span><br><span class="line">                  <span class="comment">// start_free 和 end_free是战备池pool的头尾指针，指向这一块空间</span></span><br><span class="line">                  start_free = (<span class="type">char</span>*)p;  </span><br><span class="line">                  end_free = start_free + i;</span><br><span class="line">                  <span class="keyword">return</span>(<span class="built_in">chunk_alloc</span>(size, nobjs)); <span class="comment">// 递归再试一次</span></span><br><span class="line">                  <span class="comment">//Any leftover piece will eventually make it to the</span></span><br><span class="line">                  <span class="comment">//right free list.</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          end_free = <span class="number">0</span>;       <span class="comment">//In case of exception.</span></span><br><span class="line">          start_free = (<span class="type">char</span>*)<span class="built_in">malloc_allocate</span>(bytes_to_get);</span><br><span class="line">          <span class="comment">//This should either throw an exception or</span></span><br><span class="line">          <span class="comment">//remedy the situation. Thus we assume it</span></span><br><span class="line">          <span class="comment">//succeeded.</span></span><br><span class="line">      &#125; <span class="comment">// if结束</span></span><br><span class="line">      </span><br><span class="line">      heap_size += bytes_to_get;  <span class="comment">// 累计总分配量</span></span><br><span class="line">      end_free = start_free + bytes_to_get;  <span class="comment">// 调整pool水位，pool空间变大，pool的终点</span></span><br><span class="line">      <span class="keyword">return</span>(<span class="built_in">chunk_alloc</span>(size, nobjs));  <span class="comment">// 递归再调用一次</span></span><br><span class="line">      <span class="comment">// 不论是58/59行还是72/73行，都是先将空闲放入战备池中，然后再递归调用chunk_aclloc，就可以达到重新分配内存的效果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="29-G2-9-std-alloc源码剖析（下）"><a href="#29-G2-9-std-alloc源码剖析（下）" class="headerlink" title="29 G2.9 std::alloc源码剖析（下）"></a>29 G2.9 std::alloc源码剖析（下）</h2><p>分析chunk_alloc函数在G2.9 std::alloc源码剖析（中）进行。</p>
<p>具体一些数据的初始定义：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041212367.png" alt="在这里插入图片描述"></p>
<h2 id="30-G2-9-std-alloc观念大整理"><a href="#30-G2-9-std-alloc观念大整理" class="headerlink" title="30 G2.9 std::alloc观念大整理"></a>30 G2.9 std::alloc观念大整理</h2><p>（1）观念整理</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041233313.png" alt="4_内存管理_78"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list&lt;Foo&gt; c;</span><br><span class="line">c.<span class="built_in">push_back</span>(<span class="built_in">Foo</span>(<span class="number">1</span>)); <span class="comment">// Foo(1)临时对象，创建在栈stack中</span></span><br><span class="line"><span class="comment">//容器c使用alloc分配空间，看16条链表中哪一条可以提供区块，分配给它。所以它不带cookie</span></span><br><span class="line"></span><br><span class="line">Foo* p = <span class="keyword">new</span> <span class="built_in">Foo</span>(<span class="number">2</span>); <span class="comment">// 采用new，创建在heap中</span></span><br><span class="line"><span class="comment">// new是调用operator new，底层是调用malloc，它带有cookie</span></span><br><span class="line">c.<span class="built_in">push_back</span>(*p); <span class="comment">// 容器c push_back的时候不带cookie</span></span><br><span class="line"><span class="keyword">delete</span> p; </span><br></pre></td></tr></table></figure>

<p>（2）“批斗”大会</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041234181.png" alt="4_内存管理_79"></p>
<ul>
<li><p>需要学习的地方：比较判断的时候把具体的值写在前面，防止出现将&#x3D;&#x3D;写成&#x3D;赋值的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == start_free)</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> != p)</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == nobjs)        </span><br></pre></td></tr></table></figure>
</li>
<li><p>不好的地方</p>
<ul>
<li><p>变量定义的地方不要和使用的地方间隔太远，尤其是指针的使用；</p>
</li>
<li><p>第一级分配器使用的一个函数：炫技，没有人看得懂；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*<span class="built_in">set_malloc_handler</span>(<span class="built_in">void</span> (*f)()))()</span><br><span class="line">&#123; <span class="comment">//類似 C++ 的 set_new_handler().</span></span><br><span class="line">  <span class="built_in">void</span> (*old)() = oom_handler;</span><br><span class="line">  oom_handler = f;</span><br><span class="line">  <span class="keyword">return</span>(old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于 //</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*H)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">H <span class="title">set_malloc_handler</span><span class="params">(H f)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有deallocate的时候并没有free掉，这是由设计的先天缺陷造成的。</p>
</li>
</ul>
</li>
</ul>
<h2 id="31-G4-9-pull-allocator运行观察"><a href="#31-G4-9-pull-allocator运行观察" class="headerlink" title="31 G4.9 pull allocator运行观察"></a>31 G4.9 pull allocator运行观察</h2><p>在GNU C++4.9版本下的测试，由于2.9版本分配内存都是调用malloc，无法重载，即无法接管到我们用户手中，无法记录总分配量和总释放量。而在4.9版本中，它的内存分配动作是调用operator new，这样我们就可以接管operator new，对其进行重载。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041240025.png" alt="4_内存管理_80"></p>
<p>下面测试两个分配器使用情况，分别对list容器进行100万次分配。</p>
<p>由于GNU C++4.9版本标准分配器是allocator，并不是2.9版本alloc，所以容器（客户）分配内存的时候每个元素（100万个）都带cookie（每个cookie占8B）。这个如下图右侧所示。</p>
<p>下图左侧使用4.9版本好的分配器__pool_alloc，这个是2.9版本的alloc，显示分配的次数timesNew为122次（调用malloc的次数），这比右侧标准分配器好上不少。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405041240699.png" alt="4_内存管理_81"></p>
<h1 id="第三讲-malloc-free"><a href="#第三讲-malloc-free" class="headerlink" title="第三讲 malloc&#x2F;free"></a>第三讲 malloc&#x2F;free</h1><h2 id="32-VC6和VC10的malloc比较"><a href="#32-VC6和VC10的malloc比较" class="headerlink" title="32 VC6和VC10的malloc比较"></a>32 VC6和VC10的malloc比较</h2><blockquote>
<p> SBH：Small Block Heap</p>
</blockquote>
<p>（1）VC6内存分配</p>
<p>下图为<code>call stack</code>，即调用栈，需要从下往上看。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061116653.png" alt="4_内存管理_86"></p>
<p><code>mainCRTStartup</code>函数是<code>CRT</code>（C Run Time，C标准库）提供的入口点函数，调用一系列函数，后面才是调用<code>main</code>函数。其中，在<code>_heap_alloc_base</code>函数中：</p>
<ul>
<li>当size小于阈值<code>_sbh_thrshold</code>时调用<code>__sbh_alloc_block</code>函数；</li>
<li>否则调用<code>HeapAlloc</code>函数，即操作系统提供的内存分配函数。</li>
</ul>
<blockquote>
<p>在 VC6（Visual C++ 6.0）的内存分配机制中，SBH（Small Block Heap）是用于管理小块内存的一部分。这是一个专门用于分配和释放相对较小内存块的堆管理机制，通常用于提高小对象的内存分配效率。</p>
<p>在调用栈中，从下往上看，mainCRTStartup 函数是 CRT（C Runtime）提供的入口点函数。CRT 是 C++ 程序运行时环境的一部分，负责初始化和管理程序的运行时状态。mainCRTStartup 函数会执行一系列的初始化操作，包括初始化全局变量、调用构造函数等。在这个过程中，可能会涉及到内存分配操作，其中就包括 SBH 的管理。</p>
<p>在 VC6 中，SBH 通常使用一些数据结构（例如内存池、free list 等）来管理小块内存。这有助于减少内存碎片，并提高小对象的分配和释放效率。</p>
<p>整个调用栈的过程可能是这样的：</p>
<ul>
<li>mainCRTStartup 函数初始化 CRT 环境。</li>
<li>在初始化过程中，可能会涉及到 SBH 的初始化或使用。</li>
<li>然后执行 main 函数，开始程序的主要逻辑。</li>
</ul>
<p>总的来说，VC6 的内存分配机制在运行时可能会使用 SBH 等机制来管理小块内存，以提高性能和效率。这些机制通常是底层的、对开发者透明的，但在整个程序运行的过程中发挥着重要的作用。</p>
</blockquote>
<p>（2）VC10内存分配</p>
<p>下图中黑色覆盖的函数表示VC10不再使用，对于<code>_heap_alloc_base</code>函数，它里面直接调用<code>HeapAlloc</code>函数，不再对小块内存进行管理，统统交给操作系统来做。对于VC10版本，它的SHB等小块内存的管理都被包装到<code>HeapAlloc</code>里面来了。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061120640.png" alt="4_内存管理_87"></p>
<p>（3）SBH之始</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061124139.png" alt="4_内存管理_88"></p>
<p><code>_heap_init</code></p>
<ul>
<li><p>调用<code>HeapCreate</code>来分配一块大小为<code>4096</code>的堆空间，命名为<code>_crtheap</code>，后面<code>CRT</code>的动作都要从这一块内存中来拿；</p>
</li>
<li><p>调用<code>__sbh_heap_init</code>，里面是<code>HeapAlloc</code>，从<code>_crtheap</code>中拿内存，准备好<code>16个header</code>。</p>
<ul>
<li><p>header的结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> BITVEC;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagHeader</span></span><br><span class="line">&#123;</span><br><span class="line">    BITVEC bitvEntryHi; <span class="comment">// 32位</span></span><br><span class="line">    BITVEC bitbEntryLo;  <span class="comment">// 32位</span></span><br><span class="line">    BITVEC bitvCommit;  <span class="comment">// 32位</span></span><br><span class="line">    <span class="type">void</span>* pHeapData;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tagRegion</span>* pRegion;</span><br><span class="line">&#125;</span><br><span class="line">HEADER, *PHEADER;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061123323.png" alt="4_内存管理_89"></p>
</li>
</ul>
</li>
</ul>
<h2 id="33-VC6内存分配（1）"><a href="#33-VC6内存分配（1）" class="headerlink" title="33 VC6内存分配（1）"></a>33 VC6内存分配（1）</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061126561.png" alt="4_内存管理_90"></p>
<h3 id="（1）ioinit"><a href="#（1）ioinit" class="headerlink" title="（1）ioinit()"></a>（1）ioinit()</h3><ul>
<li><p>和<code>I/O</code>相关的初始化，其中调用<code>_malloc_crt</code>进行内存分配，这是<code>CRT</code>进行的第一次内存分配，大小为<code>32×8=256B</code>，所有的程序一进来都是分配<code>256B</code>。256在十六进制下是0x100，或者写成<code>100H</code>。</p>
</li>
<li><p>调用了<code>_malloc_dbg</code>，和<code>malloc</code>稍微有所不同，是与调试相关的内存分配函数，</p>
<ul>
<li><p>是 Microsoft Visual C++ 提供的一种扩展版本，用于在调试模式下进行内存分配，并提供额外的调试信息。与标准的<code>malloc</code>函数相比，<code>_malloc_dbg</code>主要用于在调试期间更容易跟踪内存分配和释放的情况。</p>
</li>
<li><p>示例用法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;crtdbg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* ptr = _malloc_dbg(size, _NORMAL_BLOCK, __FILE__, __LINE__);</span><br><span class="line"></span><br><span class="line"><span class="comment">// _malloc_dbg 用于分配带有调试信息的内存块</span></span><br><span class="line"><span class="comment">// _NORMAL_BLOCK 表示内存块的类型</span></span><br><span class="line"><span class="comment">// __FILE__ 和 __LINE__ 分别表示调用该函数的源文件和行号</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="（2）-heap-alloc-dbg"><a href="#（2）-heap-alloc-dbg" class="headerlink" title="（2）_heap_alloc_dbg()"></a>（2）_heap_alloc_dbg()</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061130993.png" alt="4_内存管理_91"></p>
<ul>
<li><code>_CrtMemBlockHeader</code>是一个结构体，可称为<code>debug header</code>；<code>nSize</code>就是上文提到的<code>256B</code>；<code>nNoManLandSize</code>为4；</li>
<li>右侧的图显示了<strong>debug模式下申请nsize&#x3D;256B大小内存</strong>，额外附加了一些东西，debug header和NoMansLand，这是为调试器设计的；</li>
<li><strong>blockSize计算完毕之后，开始调用_heap_alloc_base分配内存空间</strong></li>
<li><strong>所需内存的nSize部分加上调试所加的部分，这个整体称为block，由灰色、深绿色、浅绿色共同构成</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061132445.png" alt="4_内存管理_92"></p>
<ul>
<li><code>_pFirstBlock</code>和<code>_pLastBlock</code>两根指针指向block链表的头尾，<code>malloc</code>分配的内存块都用链表串起来；</li>
<li>右下角的<code>memset</code>是给特定地方填入特定的值。</li>
</ul>
<h2 id="34-VC6内存分配（2）"><a href="#34-VC6内存分配（2）" class="headerlink" title="34 VC6内存分配（2）"></a>34 VC6内存分配（2）</h2><h3 id="（3）-heap-alloc-base"><a href="#（3）-heap-alloc-base" class="headerlink" title="（3）_heap_alloc_base()"></a>（3）_heap_alloc_base()</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061135466.png" alt="4_内存管理_93"></p>
<ul>
<li>调用<code>_heap_alloc_base</code>分配内存，小于阈值的内存交给sbh服务，大于阈值的内存交给操作系统HeapAlloc来服务；</li>
<li>这里<code>_Sbh_threshold</code>的值是<code>1016B</code>，这是因为还没有加cookie（大小为8），两者加起来是<code>1024B</code>。</li>
</ul>
<h3 id="（4）-sbh-alloc-block"><a href="#（4）-sbh-alloc-block" class="headerlink" title="（4）_sbh_alloc_block()"></a>（4）_sbh_alloc_block()</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061136305.png" alt="4_内存管理_94"></p>
<p>在前面<code>block</code>的基础上，上下添加<code>cookie</code>（体现在2*sizeof(int)，以及下图右侧上下两块红色的地方0x131），后面涉及到的(BYTE_PER_PARA-1) 是进行向上调整ROUND_UP，调整到16的倍数。</p>
<ul>
<li><strong>cookie的计算</strong>：<ul>
<li>首先是<code>_ioinit</code>首次需要的内存<code>256B</code>（0x100，浅绿色的部分）;</li>
<li>然后是调试器加的<code>debug header</code>，大小为<code>9 x 4 = 36B</code>（0x24，灰色部分和深绿色部分(4个0xfd)），再加上下两个cookie大小<code>4 x 2 = 8B</code>（0x8），所有的加起来：0x100 + 0x24 + 0x8 &#x3D; 0x12C，<strong>向上调整到16的倍数</strong>，变成<code>0x130</code>；</li>
<li>最后，末位为<code>1</code>表示这块内存分配出去，如果末位为0则表示这块内存还在<code>sbh</code>手上。这里是分配出去的内存，所以<code>cookie</code>里面填的值是<code>0x131</code>。</li>
</ul>
</li>
</ul>
<h2 id="35-VC6内存分配（3）"><a href="#35-VC6内存分配（3）" class="headerlink" title="35 VC6内存分配（3）"></a>35 VC6内存分配（3）</h2><p>上述函数的作用都是确定该分配内存的大小，接下来真正进行内存分配的任务。</p>
<h3 id="（5）-sbh-alloc-new-region"><a href="#（5）-sbh-alloc-new-region" class="headerlink" title="（5）_sbh_alloc_new_region()"></a>（5）_sbh_alloc_new_region()</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061139061.png" alt="4_内存管理_95"></p>
<p>共<code>16</code>个<code>header</code>，每个<code>header</code>负责<code>1MB</code>的内存。</p>
<p><code>header</code>有两个指针：</p>
<ul>
<li>一个指向<strong>真正的内存</strong>；</li>
<li>另一个指向<strong>管理中心（region）</strong>，上图中橙色框圈出来的就是<code>new region</code>，具体细节如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagRegion</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> indGroupUse;                  <span class="comment">// 一个整数</span></span><br><span class="line">	<span class="type">char</span> cntRegionSize[<span class="number">64</span>];           <span class="comment">// 64个char</span></span><br><span class="line">    <span class="comment">// 下面两者合并，共有32组，每组64bits，用来管理区块在链表中存在与否等细节</span></span><br><span class="line">	BITVEC bitvGroupHi[<span class="number">32</span>];           <span class="comment">// unsigned int</span></span><br><span class="line">	BITVEC bitvGroupLo[<span class="number">32</span>];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tagGroup</span> grpHeadList[<span class="number">32</span>];  <span class="comment">// 32个group</span></span><br><span class="line">&#125;</span><br><span class="line">REGION, *REGION;</span><br></pre></td></tr></table></figure>

<ul>
<li>每一个<code>group</code>是<code>64</code>个<code>ListHead</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagGroup</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> cntEntries;                   <span class="comment">// 记录累计分配出去的区块</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tagListHead</span> listHead[<span class="number">64</span>];  <span class="comment">// 64个ListHead</span></span><br><span class="line">&#125;</span><br><span class="line">GROUP, *PGROUP;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ListHead</code>里面有两个指针，双向链表</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagListHead</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tagEntry</span>* pEntryNext;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tagEntry</span>* pEntryPrev;</span><br><span class="line">&#125;</span><br><span class="line">LISTHEAD, *PLISTHEAD;	</span><br></pre></td></tr></table></figure>

<p>一个<code>region</code>的大小大概有<code>16K</code>左右。管理右侧的虚拟地址空间的成本即为<code>region</code>的大小，<code>16K</code>。</p>
<h2 id="36-VC6内存分配（4）"><a href="#36-VC6内存分配（4）" class="headerlink" title="36 VC6内存分配（4）"></a>36 VC6内存分配（4）</h2><p>接下来就是如何从<code>1MB</code>内存中切出一块。</p>
<h3 id="（6）-sbh-alloc-new-group"><a href="#（6）-sbh-alloc-new-group" class="headerlink" title="（6）_sbh_alloc_new_group()"></a>（6）_sbh_alloc_new_group()</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061241209.png" alt="4_内存管理_96"></p>
<p>将右侧的虚拟内存空间（大小为<code>1MB</code>），分成<code>32</code>块，每个<code>group</code>管理<code>1</code>块，每一块大小为<code>1MB / 32 = 32KB</code>。然后再将每一块细分为<code>8</code>个<code>page</code>，每个<code>page</code>大小为<code>32KB / 8 = 4KB</code>，如上图<code>page1, page2, …, page8</code>所示。</p>
<p>第<code>1</code>块由<code>group0</code>进行管理。<code>group0</code>里面有<code>64</code>条链表。<code>SBH</code>中用链表把第<code>1</code>块的<code>8</code>个<code>page</code>串起来，挂在<code>group0</code>里面<code>64</code>条链表的最后一条上。</p>
<p>当<code>_ioinit</code>第一次来要内存的时候，就从<code>group0</code>的<code>page1</code>挖一块给它。后面又有要内存的时候，就一直往后挖，如果<code>page1</code>到<code>page8</code>都被分配出去了，之后还是要内存，就到<code>group1</code>中去处理。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061241234.png" alt="4_内存管理_97"></p>
<ul>
<li><p><strong>黄色部分</strong>：这<code>32KB</code>（8个page）是一次性从操作系统分配过来的。每一个<code>page</code>的偏移值地方设置为<code>0xffffffff</code>，也就是<code>-1</code>（上图中黄色的部分），设置为<code>-1</code>的作用是合并的时候做分隔符（栅栏），分隔符（栅栏）之内的合并在一起。</p>
</li>
<li><p><strong>红色部分</strong>：有三个小块，下面两个红色的小块是两个指针，将8个page串起来，上面的一个红色小块是记录可用空间的大小，这里是<code>4080</code>（由4KB &#x3D; 4096B，4096减去两个黄色的部分（栅栏，分隔符）8B，剩下4088B，但是要下调到16的倍数，变成4080B，剩余的放到保留区），这上下两块<code>4080</code>是cookie，记录自己这一块的大小。</p>
</li>
</ul>
<p>64条链表负责不同大小的区块，分别是<code>16B， 32B， 64B,…, </code>每次增加16B，一直到最后一条链表，最后一条应该负责<code>64 x 16 = 1024B</code>的区块分配。<strong>另外最后一根链表还有一个任务，就是所有大于1024B的区块都由它负责</strong>。当切分完之后如果剩下的空间小于1024B，就要挂载到对应区块大小的那根链表上。</p>
<p>这64条链表上面还有一个整数<code>cntEntries</code>，表示分配的累积量，分配出去一个区块就<code>+1</code>，回收回来一个区块就<code>-1</code>。</p>
<h2 id="37-VC6内存分配（5）"><a href="#37-VC6内存分配（5）" class="headerlink" title="37 VC6内存分配（5）"></a>37 VC6内存分配（5）</h2><p>下面分析第一个<code>page</code>怎么切分。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061248201.png" alt="4_内存管理_98"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4080 = 0xff0</span><br></pre></td></tr></table></figure>

<p>上面<code>_ioinit</code>第一次要的内存是<code>256B</code>（0x110），然后加上各种<code>debug header</code>和其他，总共是<code>0x130</code>，所以给出去的内存是<code>0x130</code>，<code>cookie</code>记录的值是<code>0x131</code>。</p>
<p>剩下的大小为<code>0xff0 - 0x130 = 0xec0</code>。</p>
<ul>
<li><p>上图左侧<strong>红色的地址0x007d0ed0</strong>是传出去的指针，<strong>指向的是客户要的<code>0x130</code>大小（加上各种debug header等）的内存</strong>。<strong>然后0x130内部还要调整指针，指向实际要的大小0x100大小的位置，就是图中的纯绿色（fill 0xcd）位置。这就是_ioinit获得的空间的位置。</strong></p>
</li>
<li><p>上图右侧的<code>_NORMAL_BLOCK </code>和<code>_CRT_BLOCK</code>指的是不同类型的<code>block</code></p>
<ul>
<li><p><code>_NORMAL_BLOCK</code>是<code>main</code>函数里面具体用的<code>block</code>，它在<code>main</code>函数结束的时候应该全部被归还，否则就是内存泄漏；</p>
</li>
<li><p><code>_CRT_BLOCK</code>在<code>main</code>函数运行结束之后还会存在，它会由<code>CRT</code>进行释放。</p>
</li>
</ul>
</li>
</ul>
<h2 id="38-SBH行为分析-分配-释放之连续动作图解（1）"><a href="#38-SBH行为分析-分配-释放之连续动作图解（1）" class="headerlink" title="38 SBH行为分析 分配+释放之连续动作图解（1）"></a>38 SBH行为分析 分配+释放之连续动作图解（1）</h2><p>（1）首次需求</p>
<p><strong>首次需求</strong>是由<code>ioinit.c</code>第<code>81</code>行代码发出，申请<code>100H</code>的空间，加上各种<code>debug header</code>，它的区块大小变成<code>130H</code>（十进制是304），应该由<code>64</code>条链表中的第<code>304 / 16 - 1 = 18</code>号链表进行供应（不同链表区块大小是16的倍数）。<strong>但是前63条链表都为空，只有最后一条（#63）有空间。下面就是以最后一条链表（#63）来讲解。</strong></p>
<p><code>SBH</code>面对这样的需求，它在初始化的时候已经有<code>16</code>个<code>header</code>，现在<code>0</code>号<code>header</code>来进行处理。</p>
<ol>
<li>它首先分配<code>1MB</code>的地址空间，这个动作是由<code>VirtualAlloc</code>去拿到的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, <span class="number">1</span>MB, MEM_RESERVE, ...)</span><br></pre></td></tr></table></figure>

<p>这段代码使用了<code>VirtualAlloc</code>函数，该函数是 Windows API 提供的用于虚拟内存操作的函数之一。在这里，<code>VirtualAlloc</code>用于分配 1MB 的地址空间，并且使用<code>MEM_RESERVE</code>标志表示要保留这个地址空间，而不分配物理内存。</p>
<ul>
<li>0：表示欲分配或保留的内存区域的起始地址。在这里，设置为 0，表示让系统决定分配的地址。</li>
<li>1MB：表示要分配或保留的内存区域的大小，这里是 1MB。</li>
<li>MEM_RESERVE：表示要保留而不是分配物理内存。这样做可以预留地址空间，但只有在访问这些地址空间时才会分配物理内存。</li>
<li>…：其他参数，这里没有提供具体的细节。</li>
</ul>
<p><strong>所以，这个调用的目的是在虚拟地址空间中保留 1MB 的地址区域，但实际上并没有分配物理内存。这样的操作通常用于预留地址空间，以便在需要时再分配实际的物理内存。</strong></p>
<ol start="2">
<li>其次，<code>header0</code>有另外一根指针分配出<code>region</code>，这个动作是由<code>HeapAlloc</code>进行</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">HeapAlloc</span>(_crtheap, <span class="built_in">sizeof</span>(REGION));</span><br></pre></td></tr></table></figure>

<p>这个<code>region</code>里面就是上文介绍的，里面有一些<code>bit</code>，还有<code>32</code>个<code>group</code>，每个<code>group</code>有<code>64</code>条链表。</p>
<p>上述动作准备好之后，要从虚拟地址空间中分配<code>32KB</code>（被分成8个page，每个page大小为4KB），8个page由指针串起来，这次内存分配是用<code>VirtualAlloc</code>进行的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VirtualAlloc</span>(addr, <span class="number">32</span>KB, MEM_COMMIT, ...)  <span class="comment">// MEM_COMMIT表示真的分配内存</span></span><br></pre></td></tr></table></figure>

<p>万事俱备，开始在page1上分配刚开始的需求：申请的<code>100h</code>，区块大小<code>130h</code>，十进制大小<code>4080</code>。剩下的大小为<code>0xff0 - 0x130 = 0xec0</code>，这部分还在<code>SBH</code>控制之中，<code>130h</code>被分配出去，所以cookie记为<code>131h</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061255241.png" alt="4_内存管理_99"></p>
<p>下面红色方框中是32组64bits，64bits分别对应64根链表的状态，哪一条链表有挂区块，对应的bit就设置为1。32组表示的是32个group</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061255415.png" alt="在这里插入图片描述"></p>
<p>（2）第二次需求</p>
<p><strong>第二次需求，这个需求是<code>CRT</code>里面谁发出来的需求呢？是上面讲的<code>call stack</code>中的<code>__crtGetEnvironmentStringsA()</code>发出的。</strong></p>
<p>这次需求是且分出<code>240H</code>的大小（包含各种debug header，调整16的边界等之后的大小），这个240h的区块应该由哪条链表提供服务呢？240h &#x3D; 576d（d表示十进制）,576 &#x2F; 16 -1 &#x3D; 35, 所以由#35号链表提供服务。然后去检查64bits中35号对应的bit，看看是否挂有区块，这里的情况是#35链表是空的。 然后退而求其次逐渐遍历更大容量的链表，这里只能找到最大的那条链表，这里最后一条是#63（从0开始编号）。</p>
<p>和前面一样，检查#63链表发现它有8个page，page1还有空间可用。从这里切出<code>240h</code>的大小，经过两次切割之后，<code>page1</code>还剩<code>c80h</code>大小，<code>ec0h - 240h = c80h</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061256770.png" alt="4_内存管理_100"></p>
<p>（3）第三次需求</p>
<p><strong>第三次需求分配<code>70h</code>的大小。</strong>首先先检查应该是几号链表服务刚刚好？这里是<code>70h = 112D</code>, <code>112 / 16 - 1 = 6</code>, 应该由6号链表服务，但是它是空的，往上寻找只发现最后一个链表有区块。</p>
<p><code>page1</code>继续分配空间，这次分配之后还剩下<code>c80h - 70h = c10h</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061256560.png" alt="4_内存管理_101"></p>
<h2 id="39-SBH行为分析-分配-释放之连续动作图解（2）"><a href="#39-SBH行为分析-分配-释放之连续动作图解（2）" class="headerlink" title="39 SBH行为分析 分配+释放之连续动作图解（2）"></a>39 SBH行为分析 分配+释放之连续动作图解（2）</h2><p>上面是分析内存分配的情况，下面分析一下内存回收的阶段。</p>
<p>下图是第<code>15</code>次的动作，它前面有<code>14</code>次内存分配，这次是内存释放（回收），右上角可以看到<code>cntEntries</code>由<code>14</code>变成<code>13</code>，内存释放会<code>-1</code>.</p>
<p>这次释放的是大小为<code>240h</code>的区块，这一块应该回收到<code>64</code>条链表中的哪一条呢？<code>240h = 576D， 576 / 16 - 1 = 35</code>，所以应该还到<code>#35</code>号链表。由于分配出去的<code>cookie</code>为<code>241h</code>，现在将其变为<code>240h</code>，就表示回收回来，在<code>SBH</code>的掌控之下。然后<code>64bits</code>中<strong>第35号bit需要由0变成1</strong>。</p>
<blockquote>
<p>切割实际上只是cookie的调整。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061257419.png" alt="4_内存管理_102"></p>
<h2 id="40-SBH行为分析-分配-释放之连续动作图解（3）"><a href="#40-SBH行为分析-分配-释放之连续动作图解（3）" class="headerlink" title="40 SBH行为分析 分配+释放之连续动作图解（3）"></a>40 SBH行为分析 分配+释放之连续动作图解（3）</h2><p>下图是第<code>16</code>次的动作，还是内存分配的动作</p>
<p>这次分配的是<code>b0h</code>，应该由哪条链表来服务呢？<code>b0h = 176D， 176 / 16 - 1 = 10</code>，所以应该由<code>#10</code>号链表服务，但是它是空的。此时需要向右寻求拥有更大区块的链表的帮助，这里从<code>#10</code>号往右逐个查找，发现上次回收了回来第<code>#35</code>号链表，它是可用的，所以这次应该由#35号链表提供服务。</p>
<p>上次刚回收回来<code>240h</code>，分配出去<code>b0h</code>，这块空间还剩多大？<code>240h - b0h = 190h</code>。</p>
<p>这里的<code>190h</code>，应该挂到哪条链表呢？ <code>190h = 400D, 400 / 16 - 1= 24</code>，所以应该挂到<code>#24</code>号链表。此时<code>64bits</code>中的<code>24号bit</code>需要变成<code>1</code>，表示该号链表有区块可分配。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061257265.png" alt="4_内存管理_103"></p>
<p>一直进行下去，不断的进行内存分配和回收。</p>
<p><code>group1</code>共有<code>32KB</code>，下面的第一行表示的就是<code>group1</code>的<code>64</code>条链表的使用情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">02000014</span> <span class="number">00000000</span>H  <span class="comment">// 共64bits，表示的是第几号链表时候有区块</span></span><br></pre></td></tr></table></figure>

<p>展开成二进制，发现有3个链表挂有区块，有可用空间供分配。</p>
<p>现在要分配的大小为<code>230h</code>，上面的<code>group1</code>中的可用链表都不能满足它的需求</p>
<p>现在用的是<code>group2</code>，对于<code>group2</code>中，<code>230h</code>应该由几号链表来服务呢？ <code>230h = 560D， 560 / 16 - 1 = 34</code>，理想的状况是由<code>34</code>号链表服务，它检查下面的表示链表状态的64bits，</p>
<p>这里第二行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000001</span>H  <span class="comment">// 表示只有最后一条链表有可用空间供分配</span></span><br></pre></td></tr></table></figure>

<p>表示只有最后一条链表有可用空间供分配，最后一条链表的编号为<code>#63</code>， 每个大小<code>page</code>还是<code>4080D = ff0H</code>。</p>
<p>现在<code>ff0H</code>分配出去<code>230H</code>，还剩<code>ff0h - 230h = dc0h</code>，<code>dc0h</code>应该挂在哪个链表上呢？<code>dc0h = 3520D</code>，表示空间大小为<code>3520B</code>，比前<code>63</code>条链表的区块（小于<code>1024B</code>）还要大，它只能还挂在<code>#63</code>号链表上。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061258561.png" alt="4_内存管理_104"></p>
<h2 id="41-SBH行为分析-分配-释放之连续动作图解（4）"><a href="#41-SBH行为分析-分配-释放之连续动作图解（4）" class="headerlink" title="41 SBH行为分析 分配+释放之连续动作图解（4）"></a>41 SBH行为分析 分配+释放之连续动作图解（4）</h2><p><strong>VC6内存管理：区块的合并</strong></p>
<p>如果回收的是相邻的空间，则应该合并。这里的上cookie表示的是上面的cookie，下cookie表示的是下面的cookie。下图左侧第一张图中灰色部分表示待收回的区块300h，它的上下两部分为白色，表示已经回收过来的区块，可以合并。</p>
<p>（1）首先往下看，怎么往下看呢？</p>
<p>指针找到自己的cookie大小，这里是300h，指针移动300h，就到了下面一个区块的cookie位置，看最后1bit是否是为0，如果为0，表示可以和下面的区块合并。</p>
<p>现在发现，下方区块为free，也为300h，合并之，合并为600h，如第二张图中间灰色部分所示。</p>
<p>总之，往下合并，用的就是上cookie，根据上cookie的大小，指针移动cookie个大小，就可以找到下一个区块的位置。</p>
<p>（2）其次往上看，怎么往上看呢？</p>
<p>指针还在自己cookie的位置，往上移动4字节，就找到上方区块的下cookie，判断最后1bit是否为0，若为0，就表示可以和上面的区块合并。</p>
<p>现在发现，上方区块也为free，大小也为300h，合并之。</p>
<p>总之，往上合并，用的是上面区块的下cookie，根据这个值，往上跳cookie个大小，找到上面区块的起始位置。如果没有下cookie，就不能往上合并。</p>
<p>（3）三个300h合并大小为900h，然后去找900h应该挂在几号链表上，900h &#x3D; 2304D， 2304大于1024，所以它应该挂在最后一个链表#63上，它用来处理大于1024B的区块。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061258046.png" alt="4_内存管理_105"></p>
<h2 id="42-VC6内存管理free（p）"><a href="#42-VC6内存管理free（p）" class="headerlink" title="42 VC6内存管理free（p）"></a>42 VC6内存管理free（p）</h2><p><code>free</code>回收，<code>SBH</code>要确定落在哪个<code>header</code>（共16个header）指定的<code>1MB</code>空间中，然后确定是这个<code>header</code>中的哪个<code>group</code>，然后确定这个<code>group</code>中的<code>64</code>条链表中的哪个链表。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061258074.png" alt="4_内存管理_106"></p>
<h2 id="43-VC6内存管理总结（上）"><a href="#43-VC6内存管理总结（上）" class="headerlink" title="43 VC6内存管理总结（上）"></a>43 VC6内存管理总结（上）</h2><p>分成<code>16</code>个<code>header</code>，每个<code>header</code>管理<code>1MB</code>的虚拟空间，这个虚拟空间分成<code>32</code>个<code>group</code>（每个<code>group</code>管理大小为32KB的空间），每个<code>group</code>里有<code>64</code>个链表。</p>
<p>这里的管理是分段管理（一段是<code>32KB</code>），分段的时候便于一段全部回收，然后还给操作系统。</p>
<p><strong>如何判断全回收？</strong></p>
<p>因为每个<code>group</code>中都有一个<code>cntEntries</code>，统计分配和回收的区块数量，当它为<code>0</code>的时候，意味着这个<code>group</code>全回收，这一段<code>32KB</code>就可以还给操作系统。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagGroup</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> cntEntries; <span class="comment">// 记录累计分配出去的区块</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tagListHead</span> listHead[<span class="number">64</span>];  <span class="comment">// 64个ListHead</span></span><br><span class="line">&#125;</span><br><span class="line">GROUP, *PGROUP;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061259550.png" alt="4_内存管理_107"></p>
<p><code>cntEntries = 0</code>的时候，这些区块是什么样子呢？它们已经进行了合并，合并到初始状态，即<code>8</code>个<code>page</code>分别挂载<code>4080B</code>那个状态，如下图所示，然后挂在<code>#63</code>号链表上。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061259316.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>不急着还给操作系统，有一个<code>defering</code>，延缓归还的操作。</p>
<p>有一个全回收的<code>group</code>时，先暂存，当有第二个全回收的<code>group</code>时，才释放前面那个<code>group</code>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061300668.png" alt="4_内存管理_108"></p>
<h2 id="44-VC6内存管理总结（下）"><a href="#44-VC6内存管理总结（下）" class="headerlink" title="44 VC6内存管理总结（下）"></a>44 VC6内存管理总结（下）</h2><p>释放所有的内存块，SBH系统的面貌就是初始状态，如前面所述。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061300128.png" alt="4_内存管理_109"></p>
<blockquote>
<p>第二讲讲的是GNU C++的分配器，这里的第三讲涉及的是VC的malloc函数，可以把它们混在一起吗？其实GNU C++的malloc实现差不多。</p>
<p>这里再系统化一遍。</p>
<p>allocator要内存，底部还是向malloc要内存。</p>
<p>allocator设计成16个链表的目的不是提升分配的速度，而是为了去除malloc的cookie开销，减少malloc的次数，每一次malloc要一大块内存，然后切分成相等的区块，这样就可以去除每一小块的cookie。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061301504.png" alt="4_内存管理_111"></p>
<p><strong>从操作系统的API(这里是windows系统，比如HeapAlloc， VirtualAlloc)，到CRT的malloc设计，再到std::allocator的底部实现，都有类似的链表管理结构。</strong><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061301013.png" alt="4_内存管理_112"></p>
<h1 id="第四讲-loki-allocator"><a href="#第四讲-loki-allocator" class="headerlink" title="第四讲 loki::allocator"></a>第四讲 loki::allocator</h1><h2 id="45-上中下三个classes分析"><a href="#45-上中下三个classes分析" class="headerlink" title="45 上中下三个classes分析"></a>45 上中下三个classes分析</h2><p>Loki 是 C++ 中一个开源的库，其中包含一组通用的 C++ 组件。在 Loki 库中，有一个称为 Loki::Allocator 的组件，它是一个用于内存分配的工具。讲这个分配器是为了和GNU C++中的alloc分配器作比较，alloc分配器最后的内存并没有还给操作系统。</p>
<p>Loki allocator的三个类，从低阶到高阶分别为：<code>Chunk, FixedAllocator, SmallObjAllocator</code>。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061930580.png" alt="4_内存管理_117"></p>
<ul>
<li>Chunk</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pData_: <span class="type">unsigned</span> <span class="type">char</span>* <span class="comment">// 指针，指向分配的一个chunk</span></span><br><span class="line">firstAvailableBlock_：<span class="type">unsigned</span> <span class="type">char</span> <span class="comment">// 第一个可用区块</span></span><br><span class="line">blocksAvailable_: <span class="type">unsigned</span> <span class="type">char</span> <span class="comment">// 目前还可以供应几个区块</span></span><br></pre></td></tr></table></figure>

<ul>
<li>FixedAllocator</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chunks_: vector&lt;Chunk&gt; <span class="comment">// vector里面放了很多chunk</span></span><br><span class="line"><span class="comment">// 两个指针，指向某两个Chunk</span></span><br><span class="line">allocChunk_: Chunk* </span><br><span class="line">deallocChunk_: Chunk*</span><br></pre></td></tr></table></figure>

<ul>
<li>SmallObjectAllocator</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pool_: vector&lt;FixedAllocator&gt;  <span class="comment">// 里面放了很多FixedAllocator</span></span><br><span class="line"><span class="comment">// 两个指针，指向某两个FixedAllocator</span></span><br><span class="line">pLastAlloc: FixedAllocator*</span><br><span class="line">pLastDealloc: FixedAllocator*</span><br><span class="line">chunkSize: <span class="type">size_t</span></span><br><span class="line">maxObjectSize: <span class="type">size_t</span></span><br></pre></td></tr></table></figure>

<h2 id="46-Class-Chunk分析"><a href="#46-Class-Chunk分析" class="headerlink" title="46 Class Chunk分析"></a>46 Class Chunk分析</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061935095.png" alt="4_内存管理_125"></p>
<ul>
<li><code>Init()</code><ul>
<li>动态分配一大块Chunk；</li>
<li>调用<code>Reset()</code><ul>
<li>上图中可用的block个数为64，第一个可用的block编号为0；</li>
<li>for循环把每个block的第一个字节当作索引index使用（类似于嵌入式指针）</li>
</ul>
</li>
</ul>
</li>
<li><code>Release()</code><ul>
<li>调用<code>delete[]</code>释放空间，归还操作系统。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061936225.png" alt="4_内存管理_126"></p>
<ul>
<li><code>Allocate()</code><ul>
<li>分配一个可用区块，并赋予其最高优先权；</li>
<li><code>firstAvailableBlock_</code>对应指向下一个可用区块，比如这里可用区块的索引从左边的4变成了右边的3，剩余区块个数也相应调整。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061938608.png" alt="4_内存管理_127"></p>
<ul>
<li><code>Deallocate()</code><ul>
<li>用p指针减去头指针然后除以每个block的大小，得到该释放的block的索引（即该block为第几个block）；</li>
<li>这个释放回收的block赋予最高优先权，成为<code>firstAvailableBlock_</code>;</li>
<li>最后，可利用的block个数<code>+1</code>。</li>
</ul>
</li>
</ul>
<h2 id="47-class-FixedAllocator分析（上）"><a href="#47-class-FixedAllocator分析（上）" class="headerlink" title="47 class FixedAllocator分析（上）"></a>47 class FixedAllocator分析（上）</h2><p>FixedAllocator</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chunks_: vector&lt;Chunk&gt;  <span class="comment">// vector里面放了很多chunk</span></span><br><span class="line">allocChunk_: Chunk* 	<span class="comment">// 指向最近一次满足分配动作的chunk</span></span><br><span class="line">deallocChunk_: Chunk*	<span class="comment">// 指向最近一次回收的chunk</span></span><br><span class="line"><span class="comment">// 这两个chunk的指定符合数据的局部性原理</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Allocate的逻辑如下图所示：如果有最近的allocChunk_，那么直接取区块，</span></span><br><span class="line"><span class="comment">// 否则就要for循环从头开始遍历每个chunk，直到找到有可用空间的chunk。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061940593.png" alt="4_内存管理_128"></p>
<h2 id="48-class-FixedAllocator分析（下）"><a href="#48-class-FixedAllocator分析（下）" class="headerlink" title="48 class FixedAllocator分析（下）"></a>48 class FixedAllocator分析（下）</h2><ul>
<li>第二级FixedAllocator类的Deallocate函数，调用VicinityFind函数查找还回来的指针p落在哪个chunk，找到之后交给第一级Chunk类的Deallocate来处理。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061942795.png" alt="4_内存管理_129"></p>
<ul>
<li>VicinityFind()（临近搜寻）<ul>
<li>chunkLength是chunk的大小；lo是上次还回来的chunk，hi是下一个chunk；loBound和hiBound是vector的头跟尾</li>
<li>整体思路是：兵分两路，一路往上查找，一路往下查找。<ul>
<li>在lo里面找，找不到的话就往上面的chunk去查找，一直往上，一个接一个的chunk去找。</li>
<li>然后在hi里面找，找不到就往下面的chunk去查找，一直往下，一个接一个的chunk去找。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061943323.png" alt="4_内存管理_130"></p>
<ul>
<li>调用Deallocate()进行回收时，进行分情况处理。注意全回收时，需要确认有2个chunk，才会回收其中一个，也就是上文提到的<strong>deferring延缓回收</strong>。</li>
</ul>
<h2 id="49-Loki-allocator总结"><a href="#49-Loki-allocator总结" class="headerlink" title="49 Loki::allocator总结"></a>49 Loki::allocator总结</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061943975.png" alt="4_内存管理_131"></p>
<h1 id="第五讲-other-issues"><a href="#第五讲-other-issues" class="headerlink" title="第五讲 other issues"></a>第五讲 other issues</h1><h2 id="50-GNU-C-对allocators的描述"><a href="#50-GNU-C-对allocators的描述" class="headerlink" title="50 GNU C++对allocators的描述"></a>50 GNU C++对allocators的描述</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061944785.png" alt="4_内存管理_138"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061944147.png" alt="4_内存管理_139"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061944623.png" alt="4_内存管理_140"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061944227.png" alt="4_内存管理_141"></p>
<p><img src="C:/Users/86135/Desktop/内存管理/4_内存管理_142.png" alt="4_内存管理_142"></p>
<h2 id="51-VS2013标准分配器-G4-9标准分配器与new-allocator以及G4-9malloc"><a href="#51-VS2013标准分配器-G4-9标准分配器与new-allocator以及G4-9malloc" class="headerlink" title="51 VS2013标准分配器&amp;G4.9标准分配器与new_allocator以及G4.9malloc"></a>51 VS2013标准分配器&amp;G4.9标准分配器与new_allocator以及G4.9malloc</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061945904.png" alt="4_内存管理_143"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061945669.png" alt="4_内存管理_144"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061946198.png" alt="4_内存管理_145"></p>
<h2 id="52-G4-9-array-allocator"><a href="#52-G4-9-array-allocator" class="headerlink" title="52 G4.9 array_allocator"></a>52 G4.9 array_allocator</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061947049.png" alt="4_内存管理_146"></p>
<ul>
<li>指针<code>_M_array</code>指向一个C++数组，静态数组不需要释放与归还</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061947075.png" alt="4_内存管理_148"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061948852.png" alt="4_内存管理_147"></p>
<h2 id="53-G4-9-debug-allocator"><a href="#53-G4-9-debug-allocator" class="headerlink" title="53 G4.9 debug_allocator"></a>53 G4.9 debug_allocator</h2><p><code>debug_allocator</code>是一个包装器，把另一个分配器包装进来，这里是<code>_Alloc</code>分配器，定义为<code>_M_allocator</code>，实际分配的时候就是调用这个分配器的<code>allocate</code>，分配<code>n + extra</code>个大小的空间。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061948633.png" alt="4_内存管理_149"></p>
<h2 id="54-bitmap-allocator（上）"><a href="#54-bitmap-allocator（上）" class="headerlink" title="54 bitmap_allocator（上）"></a>54 bitmap_allocator（上）</h2><p>（1）介绍bitmap_allocator</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061949227.png" alt="4_内存管理_153"></p>
<ul>
<li><code>_M_allocate_single_object</code>和<code>_M_deallocate_single_object</code>：所有的<code>allocator</code>都是供给容器使用的，容器每次请求的都是一个元素的内存分配，所以这里就是<strong>单独处理一个<code>object</code>的请求</strong>。<strong>当不是一个object的时候，就会退化到operator new和operator delete</strong>，但是这种情况一般遇不到。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061950407.png" alt="4_内存管理_154"></p>
<p>当使用容器时，容器中一个元素的内存空间就是<code>block</code>，如果是<code>std::list</code>的时候，这个<code>block</code>还包括<code>node</code>里面的指针。上图中的<code>64blocks</code>指的是一次性挖<code>64个blocks</code>开始供应，注意这里是两倍成长，下次挖<code>128</code>个，再是<code>256</code>个，…。<strong>挖的这些blocks，加上前面的bitmap，还有前面的数值，一起称为super block。</strong></p>
<ul>
<li><code>bitmap</code>中是<code>64bits</code>（对应于blocks的数量），每个<code>bit</code>表示单个<code>block</code>的状态，<code>bitmap</code>是<code>unsigned int</code>，一个<code>bitmap</code>是<code>32</code>位，只能记录<code>32</code>个blocks的情况。这里是<code>64</code>个<code>blocks</code>，需要<code>2</code>个<code>bitmap</code>来记录。</li>
<li>前面还有一个整数<code>use count</code>，记录有几个block被分配。</li>
<li>最前面还有一个整数，记录<code>super block</code>的大小。</li>
<li>有一个<code>mini vector</code>（模拟标准库中的vector写出来的）来操纵<code>super block</code>，里面的<code>start</code>指针和<code>finish</code>指针分别指向<code>super block</code>的头和尾。</li>
</ul>
<p>（2）示例分析</p>
<ol>
<li>现在客户需要分配内存，此时深灰色这个block被分配出去：<ul>
<li>use count &#x3D; 1；</li>
<li>bitmap[0]最后一位变成0，表示已经分配出去</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061955406.png" alt="4_内存管理_155"></p>
<ol start="2">
<li>然后请求分配第二个block，下面两个灰色的block表示被分配出去：<ul>
<li>use count &#x3D; 2；</li>
<li>bitmap[0]后两位变成0，表示这两个block被分配出去。</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061955242.png" alt="4_内存管理_156"></p>
<ol start="3">
<li>后面一直分配block出去，下图表示已经分配出去63个block：<ul>
<li>对应的use count &#x3D; 63；</li>
<li>bitmap[1]和bitmap[0]变成80000000H和00000000H，只有最后一个block对应的bitmap中的bit才为1,表示未被分配出去。</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061957215.png" alt="4_内存管理_157"></p>
<ol start="4">
<li>下面客户归还其中一个block：<ul>
<li>对应的bitmap要变成1，表示未分配（回收回来）；</li>
<li>use count由63变成62。</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061957438.png" alt="4_内存管理_158"></p>
<ol start="5">
<li>当一个super block(有64个blocks)用完后，开始启用第二号super block，<strong>这时候super block中的block块数由64扩大两倍变成128个</strong>，由4个bitmap整数表示。而且mini vector中由一个单元变成两个单元，每个单元指向一个super block。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061957540.png" alt="4_内存管理_159"></p>
<ol start="6">
<li>第二个super block用完（前面已经用完第一个super block，其含有64个blocks，第二个super block包含128个blocks，也已经用完），<strong>启用第三个super bloc，其包含的blocks为128 x 2 &#x3D; 256个</strong>。mini vector中也有第三个单元来控制这个super block。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061958956.png" alt="4_内存管理_160"></p>
<h2 id="55-bitmap-allocator（下）"><a href="#55-bitmap-allocator（下）" class="headerlink" title="55 bitmap_allocator（下）"></a>55 bitmap_allocator（下）</h2><p>上面谈的是bitmap_allocator的分配，下面谈它的回收（容器归还元素空间）机制。</p>
<ol>
<li><p>第一个super block全回收，用另一个mini vector（称为free list）中的entry指针指向这个super block，表示已经回收。<strong>如果下次新分配一个super block，它其中blocks的数量要减半</strong>。</p>
<p>如下图所示，前三个superblocks大小分别为64个，128个，256个，由于第一个superblock被回收，那么下次分配的superblock大小由已经分配的最大值256变成一半，为128个blocks。原来的mini vector里面的指向回收的这个superblock头和尾的entry被删除。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405061959663.png" alt="4_内存管理_161"></p>
<ol start="2">
<li>第二个super block也全回收，则free list里的entry加一个，指向这个super block。原来的mini vector里面指向这个superblock头尾的entry被删除。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062000036.png" alt="4_内存管理_162"></p>
<ol start="3">
<li>第三个super block被全回收，被free list的指针指向。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405062000522.png" alt="4_内存管理_163"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/29/Computer/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/STL%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/29/Computer/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/STL%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">STL标准库与泛型编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-29 19:16:16" itemprop="dateCreated datePublished" datetime="2024-04-29T19:16:16+08:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-05 10:42:30" itemprop="dateModified" datetime="2024-07-05T10:42:30+08:00">2024-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/%E4%BE%AF%E6%8D%B7C-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">侯捷C++系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>491</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://lishizheng.blog.csdn.net/article/details/135440545">STL标准库与泛型编程（侯捷）笔记1</a></p>
<p>3 容器之分类与各种测试（一）：array<br>4 容器之分类与各种测试（二）：vector<br>5 容器之分类与各种测试（三）list, deque,stack, queue<br>6 容器之分类与各种测试（四）：set和unordered_set等<br>7 分配器之测试</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/29/Computer/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/STL%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/26/Computer/C++/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/26/Computer/C++/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97/" class="post-title-link" itemprop="url">字符串与整数的相互转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-26 10:40:36" itemprop="dateCreated datePublished" datetime="2024-04-26T10:40:36+08:00">2024-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-05 10:41:45" itemprop="dateModified" datetime="2024-07-05T10:41:45+08:00">2024-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>531</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/26/Computer/C++/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/24/Computer/C++/new%E4%B8%8Eoperator%20new/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/24/Computer/C++/new%E4%B8%8Eoperator%20new/" class="post-title-link" itemprop="url">new与operator new</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-24 14:13:55" itemprop="dateCreated datePublished" datetime="2024-04-24T14:13:55+08:00">2024-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-05 10:41:43" itemprop="dateModified" datetime="2024-07-05T10:41:43+08:00">2024-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>区分三个概念：new operator、operator new和placement new</strong></p>
</blockquote>
<p>[TOC]</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/24/Computer/C++/new%E4%B8%8Eoperator%20new/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/17/Computer/Base/Linux%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/17/Computer/Base/Linux%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Linux基础相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-17 10:06:59" itemprop="dateCreated datePublished" datetime="2024-04-17T10:06:59+08:00">2024-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-05 10:39:00" itemprop="dateModified" datetime="2024-07-05T10:39:00+08:00">2024-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/Base/" itemprop="url" rel="index"><span itemprop="name">Base</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>39 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="1、GCC安装"><a href="#1、GCC安装" class="headerlink" title="1、GCC安装"></a>1、GCC安装</h1><h2 id="（1）GCC相关知识点"><a href="#（1）GCC相关知识点" class="headerlink" title="（1）GCC相关知识点"></a>（1）GCC相关知识点</h2><p>GCC（GNU Compiler Collection， GNU编译器套件）是由GNU开发的编程语言译器。</p>
<p>gcc和g++都是GNU（组织）的一个编译器</p>
<ul>
<li>误区一：gcc只能编译C程序，g++只能编译C++代码：<ul>
<li>后缀为.c时，gcc认为其是C程序，g++认为其是C++程序；</li>
<li>后缀为.cpp时，gcc和g++均认为其是C++程序。</li>
</ul>
</li>
<li>误区二：编译只能用gcc，链接只能用g++：<ul>
<li>严格来说不算错误，但混淆了概念，应该说：编译可以用gcc&#x2F;g++，而链接可以用g++或者gcc -lstdc++;</li>
<li>gcc命令不能自动和C++程序使用的库链接，所以通常使用g++来完成链接。但在编译阶段，g++会自动调用gcc，二者等价。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171012036.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171012580.png" alt="2"></p>
<h2 id="（2）GCC工作流程"><a href="#（2）GCC工作流程" class="headerlink" title="（2）GCC工作流程"></a>（2）GCC工作流程</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013866.png" alt="3"></p>
<ul>
<li><p>预处理：对头文件展开\删除代码中的注释\宏替换</p>
</li>
<li><p><strong>程序编译成可执行程序的过程：</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013529.png" alt="4"></p>
</li>
</ul>
<h1 id="2、静态库和动态库"><a href="#2、静态库和动态库" class="headerlink" title="2、静态库和动态库"></a>2、静态库和动态库</h1><h2 id="（1）静态库"><a href="#（1）静态库" class="headerlink" title="（1）静态库"></a>（1）静态库</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013337.png" alt="5"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013840.png" alt="6"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson/library<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">├── add.c</span><br><span class="line">├── div.c</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br><span class="line">root@iisayhi:~/lesson/library<span class="comment"># gcc main.c -o app -I ./include/ -l calc -L ./lib/</span></span><br><span class="line">root@iisayhi:~/lesson/library<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── app</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">		├── add.c</span><br><span class="line">		├── div.c</span><br><span class="line">		├── mult.c</span><br><span class="line">		└── sub.c</span><br></pre></td></tr></table></figure>

<h2 id="（2）动态库"><a href="#（2）动态库" class="headerlink" title="（2）动态库"></a>（2）动态库</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013622.png" alt="7"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013961.png" alt="8"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013076.png" alt="9"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/calc# **gcc -c -fpic add.c mult.c sub.c div.c** </span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# ls</span><br><span class="line">add.c  add.o  div.c  div.o  head.h  main.c  mult.c  mult.o  sub.c  sub.o</span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# **gcc -shared *.o -o libcalc.so**</span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# ll</span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x 2 root root  4096 Apr  6 22:49 ./</span><br><span class="line">drwxr-xr-x 4 root root  4096 Apr  6 22:47 ../</span><br><span class="line">-rw-r--r-- 1 root root    80 Apr  6 22:47 add.c</span><br><span class="line">-rw-r--r-- 1 root root  1376 Apr  6 22:48 add.o</span><br><span class="line">-rw-r--r-- 1 root root    94 Apr  6 22:47 div.c</span><br><span class="line">-rw-r--r-- 1 root root  1384 Apr  6 22:48 div.o</span><br><span class="line">-rw-r--r-- 1 root root   189 Apr  6 22:47 head.h</span><br><span class="line">-rwxr-xr-x 1 root root 15824 Apr  6 22:49 libcalc.so*</span><br><span class="line">-rw-r--r-- 1 root root   306 Apr  6 22:47 main.c</span><br><span class="line">-rw-r--r-- 1 root root    85 Apr  6 22:47 mult.c</span><br><span class="line">-rw-r--r-- 1 root root  1384 Apr  6 22:48 mult.o</span><br><span class="line">-rw-r--r-- 1 root root    85 Apr  6 22:47 sub.c</span><br><span class="line">-rw-r--r-- 1 root root  1376 Apr  6 22:48 sub.o</span><br></pre></td></tr></table></figure>

<ul>
<li>运行main可执行文件报错：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># gcc main.c -o main -I include/ -L lib/ -l calc</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ls</span></span><br><span class="line">include  lib  main  main.c  src</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">**./main: error <span class="keyword">while</span> loading shared libraries: [libcalc.so](&lt;http://libcalc.so/&gt;): cannot open shared object file: No such file or directory**</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffda29fd000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; not found</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbe8fa25000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007fbe8fc31000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>原因即是由于动态库是在程序启动后才被加载到内存中，而我们自己写的动态库libcalc.so并没有给出对应的路径去查找它，所以会报错。</p>
<p>解决方法：</p>
<blockquote>
<p>对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的 <strong>DT_RPATH段</strong> ——&gt; <strong>环境变量LD_LIBRARY_PATH</strong> ——&gt; <strong>&#x2F;etc&#x2F;ld.so.cache</strong>文件列表 ——&gt; <strong>&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib</strong>目录找到库文件后将其载入内存</p>
</blockquote>
<p><strong>1）DT_RPATH段 无法修改，系统本身固定值</strong></p>
<p><strong>2）环境变量LD_LIBRARY_PATH</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># echo $LD_LIBRARY_PATH </span></span><br><span class="line">:/root/lesson/lesson01/library/lib</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffff57e5000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; /root/lesson/lesson01/library/lib/libcalc.so (0x00007f06515af000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f06513aa000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f06515bb000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">a = 20, b = 12</span><br><span class="line">a + b = 32</span><br><span class="line">a - b = 8</span><br><span class="line">a * b = 240</span><br><span class="line">a / b = 1.666667</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>直接在终端中配置，当终端被关闭后该环境变量就会消失了，属于临时性配置。</p>
<p>永久性配置：</p>
<ul>
<li><p>用户级别</p>
<ul>
<li><p>根目录下，<code>vim .bashrc</code></p>
</li>
<li><p>在最后一行加上要添加的路径</p>
<p><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</code></p>
</li>
<li><p><code>source ~/.bashrc</code></p>
</li>
</ul>
</li>
<li><p>系统级别</p>
<ul>
<li><p><code>sudo vim /etc/profile</code></p>
</li>
<li><p>在最后一行加上要添加的路径</p>
<p><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</code></p>
</li>
<li><p><code>source /etc/profile</code></p>
</li>
</ul>
</li>
</ul>
<p><strong>3）&#x2F;etc&#x2F;ld.so.cache文件列表</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson<span class="comment"># ll /etc/ld.so.cache</span></span><br><span class="line">-rw-r--r-- 1 root root 74025 Jan 12 21:15 /etc/ld.so.cache</span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># **sudo vim /etc/ld.so.conf**</span></span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># **sudo ldconfig**</span></span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># cd lesson01/library/</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffd633f6000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; /root/lesson/lesson01/library/lib/libcalc.so (0x00007f7b8a4e1000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7b8a2ef000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f7b8a500000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">a = 20, b = 12</span><br><span class="line">a + b = 32</span><br><span class="line">a - b = 8</span><br><span class="line">a * b = 240</span><br><span class="line">a / b = 1.666667</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p><code>/etc/ld.so.cache</code>是一个二进制文件，无法直接用vim进行修改；</p>
<p>因此要借助<code>/etc/ld.so.conf</code>的帮助：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014770.png" alt="10"></p>
<p><strong>4）&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib目录</strong></p>
<p>不推荐使用，因为在上述目录下已经包含很多系统自带的库文件，因此可能存在重名导致被替换的问题存在。</p>
<h2 id="（3）静态库和动态库的对比"><a href="#（3）静态库和动态库的对比" class="headerlink" title="（3）静态库和动态库的对比"></a>（3）静态库和动态库的对比</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014481.png" alt="11"></p>
<ul>
<li>消耗系统资源、浪费内存：<ul>
<li>每个程序在运行时都会将静态库复制一份到内存中，多个程序同时运行时浪费内存；</li>
</ul>
</li>
<li>更新、部署、发布麻烦：<ul>
<li>每次更新、部署或发布时都需要重新编译</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014264.png" alt="12"></p>
<h1 id="3、Makefile"><a href="#3、Makefile" class="headerlink" title="3、Makefile"></a>3、Makefile</h1><ul>
<li>定义<ul>
<li>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 <code>Makefile 文件就像一个 Shell 脚本一样，也可以执行操作系统的命令</code>。</li>
<li><strong>Makefile 带来的好处就是“自动化编译”</strong> ，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如 Delphi 的 <code>make</code>，Visual C++ 的 <code>nmake</code>，Linux 下 GNU 的 <code>make</code>。</li>
</ul>
</li>
<li>命名规则</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014308.png" alt="13"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014605.png" alt="14"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014917.png" alt="15"></p>
<ul>
<li>工作原理</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015389.png" alt="16"></p>
<ul>
<li>变量</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015553.png" alt="17"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171018439.png" alt="Untitled"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019513.png" alt="Untitled"></p>
<p><strong>对原始写法进行简写：</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015837.png" alt="20"></p>
<p>改进1：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171018316.png" alt="Untitled"></p>
<p>改进2：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015549.png" alt="22"></p>
<p>改进3：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015818.png" alt="23"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY:clean  # 定义clean为伪目标</span><br></pre></td></tr></table></figure>

<p>改进4：<code>Makefile</code>中写了<code>clean</code>之后，在命令行要用<code>make clean</code>来调用</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019153.png" alt="24"></p>
<h1 id="4、GDB调试"><a href="#4、GDB调试" class="headerlink" title="4、GDB调试"></a>4、GDB调试</h1><!--more-->

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man gdb</span><br></pre></td></tr></table></figure>

<p>要进入gdb调试模式需要加上-g参数，<code>gcc -g filename</code></p>
<blockquote>
<p>gdb基本命令</p>
</blockquote>
<p><code>list</code> 查看当前源代码</p>
<p><code>run</code> 运行程序</p>
<p><code>break(b)</code> 打断点，有两种打断点方式：</p>
<ol>
<li><code>break function</code></li>
<li><code>break 可执行文件:行号</code></li>
</ol>
<p><code>info b</code> 查看已经打的断点</p>
<p><code>next(n)</code> 执行下一步</p>
<p><code>step(s)</code> 执行函数内部</p>
<p><code>print(p)</code> 打印当前变量内容</p>
<blockquote>
<p>gdb小技巧</p>
</blockquote>
<ol>
<li>gdb中可以通过<code>shell</code>调取终端命令，如：</li>
</ol>
<ul>
<li>shell ls</li>
<li>shell cat filename</li>
</ul>
<ol>
<li>设置日志功能，<code>set logging on</code></li>
<li>断点的相关设置：</li>
</ol>
<ul>
<li>breakpoints</li>
<li>watchpoints：观察变量是否变化</li>
<li>catchpoints</li>
</ul>
<blockquote>
<p>调试core文件</p>
</blockquote>
<p>系统不会默认生成core文件，需要进行手动设置</p>
<p>man ulimit</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404170953727.png" alt="1"></p>
<p>注意其中一行：<code>open file 65535</code>，能打开的最大文件数是65535</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br></pre></td></tr></table></figure>

<p>这样设置之后，运行可执行文件后出现(core dump)即为生成了对应的core文件。若仍为生成core文件，调用命令：<code>echo &quot;core&quot; &gt; /proc/sys/kernel/core_pattern</code></p>
<p>此时的gdb调试命令为：<code>gdb 可执行文件名（二进制文件） 可执行文件生成的core文件名</code></p>
<blockquote>
<p>调试正在运行的文件</p>
</blockquote>
<p>后台运行一个程序并返回其pid号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./a.out &amp;</span><br><span class="line">[1] 96929</span><br></pre></td></tr></table></figure>

<p>gdb调试该后台程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">gdb -p 96929</span><br><span class="line">root@iisayhi:~/Documents/useless# vim test_for.c </span><br><span class="line">root@iisayhi:~/Documents/useless# **gcc test_for.c -g**</span><br><span class="line">root@iisayhi:~/Documents/useless# **./a.out &amp;**</span><br><span class="line">**[1] 96929**</span><br><span class="line">root@iisayhi:~/Documents/useless# **gdb -p 96929**</span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br><span class="line">Attaching to process 96929</span><br><span class="line">Reading symbols from /root/Documents/useless/a.out...</span><br><span class="line">Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...</span><br><span class="line">Reading symbols from /usr/lib/debug/.build-id/ee/be5d5f4b608b8a53ec446b63981bba373ca0ca.debug...</span><br><span class="line">Reading symbols from /lib64/ld-linux-x86-64.so.2...</span><br><span class="line">Reading symbols from /usr/lib/debug/.build-id/7a/e2aaae1a0e5b262df913ee0885582d2e327982.debug...</span><br><span class="line">test1 () at test_for.c:14</span><br><span class="line">14	&#125;</span><br><span class="line">(gdb) n</span><br><span class="line">main () at test_for.c:18</span><br><span class="line">18			test();</span><br><span class="line">(gdb) n</span><br><span class="line">19			test1();</span><br><span class="line">(gdb) s</span><br><span class="line">test1 () at test_for.c:11</span><br><span class="line">11	void test1() &#123;</span><br><span class="line">(gdb) n</span><br><span class="line">12		int i = 0;</span><br><span class="line">(gdb) n</span><br><span class="line">13		i++;</span><br><span class="line">(gdb) p i</span><br><span class="line">$1 = 0</span><br><span class="line">(gdb) n</span><br><span class="line">14	&#125;</span><br><span class="line">(gdb) p i</span><br><span class="line">$2 = 1</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// test test1</span><br><span class="line">// i i++</span><br><span class="line">// call test test1</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test1() &#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	for(;;) &#123;</span><br><span class="line">		test();</span><br><span class="line">		test1();</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5、文件I-O"><a href="#5、文件I-O" class="headerlink" title="5、文件I&#x2F;O"></a>5、文件I&#x2F;O</h1><h2 id="（1）标准C库IO函数"><a href="#（1）标准C库IO函数" class="headerlink" title="（1）标准C库IO函数"></a>（1）标准C库IO函数</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019600.png" alt="25"></p>
<p>标准C库IO函数可以跨平台（win\linux等）。</p>
<p><strong>在不同平台上调用不同的系统API，从而实现跨平台。</strong></p>
<p>写数据时首先有一个缓冲区，内容首先写到缓冲区（内存，默认<em><strong>8k</strong></em>）中，当<strong>缓冲区内容满后&#x2F;强行刷新缓冲区&#x2F;正常关闭文件后</strong>，再将当前缓冲区的内容传递到磁盘中。</p>
<ul>
<li>标准C库IO和Linux系统IO的关系：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019149.png" alt="26"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020236.png" alt="27"></p>
<h2 id="（2）虚拟地址空间"><a href="#（2）虚拟地址空间" class="headerlink" title="（2）虚拟地址空间"></a>（2）虚拟地址空间</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020344.png" alt="28"></p>
<p>虚拟地址空间会通过MMU映射到真实物理空间上。</p>
<p>NULL\NULL pointer — 受保护的地址</p>
<p>new\malloc              — 堆空间</p>
<p>局部变量                  — 栈空间</p>
<h2 id="（3）文件描述符"><a href="#（3）文件描述符" class="headerlink" title="（3）文件描述符"></a>（3）文件描述符</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020768.png" alt="29"></p>
<ul>
<li><p>程序和进程间的区别</p>
<ul>
<li>程序（test.c)\可执行程序(test) — 不占用内存空间，只占用磁盘空间，是伪文件；</li>
<li>进程 — 运行一个程序时，操作系统创建一个进程为其分配资源，会占用内存空间。</li>
</ul>
</li>
<li><pre><code>PCB进程控制块
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">是一个复杂的结构体，位于Linux kernel的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
内存管理
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  。中封装了各类信息，如文件描述符表</span><br><span class="line"></span><br><span class="line">  - 文件描述符表，是一个数组</span><br><span class="line"></span><br><span class="line">    ，存储多个文件描述符 — 使得一个进程可以打开多个文件（产生多个文件描述符）</span><br><span class="line"></span><br><span class="line">    - 默认的大小是**1024（默认能打开的文件数）；**</span><br><span class="line">    - 数组前3位被默认占用，为**标准输入、标准输出、标准错误，且默认是打开状态**（此三个文件描述符和**当前终端**绑定，联系linux系统一切皆文件的思想来理解）；</span><br><span class="line">    - 占用文件描述符时内核会自动寻找最小的没有被占用的文件描述符来使用。</span><br><span class="line"></span><br><span class="line">## （4）Linux系统IO函数</span><br><span class="line"></span><br><span class="line">![30](https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020793.png)</span><br><span class="line"></span><br><span class="line">1）open函数</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">// 打开一个已经存在的文件</span><br><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">    参数：</span><br><span class="line">        - pathname  要打开的文件路径</span><br><span class="line">        - flags     对文件的操作权限设置还有其他的设置</span><br><span class="line">                    O_RDONLY, O_WRONLY, or O_RDWR 这三个操作互斥</span><br><span class="line">    返回值：</span><br><span class="line">        返回一个新的文件描述符；若失败则返回-1</span><br><span class="line"></span><br><span class="line">errno：属于Linux系统函数库里面的一个全局变量，记录的是最近的错误号</span><br><span class="line">    #include &lt;stdio.h&gt;</span><br><span class="line">    void perror(const char *s);</span><br><span class="line">        作用：打印errno对应的错误描述</span><br><span class="line">        参数：</span><br><span class="line">            - s     用户描述</span><br><span class="line">// 创建一个新的文件</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line">    参数：</span><br><span class="line">        - pathname  要打开的文件路径</span><br><span class="line"></span><br><span class="line">        - flags     对文件的操作权限设置还有其他的设置</span><br><span class="line">                    - 必选项：O_RDONLY, O_WRONLY, O_RDWR 这三个操作互斥</span><br><span class="line">                    - 可选项：O_CREAT 文件不存在，创建新文件</span><br><span class="line">                    flags参数是一个int类型的数据，占4个字节，32位</span><br><span class="line">                    flags32位，每一位就是一个标志位</span><br><span class="line"></span><br><span class="line">        - mode      八进制数，表述用户对创建出的新的文件的操作权限</span><br><span class="line">                    - 0777</span><br><span class="line">                        0：     0开头，八进制数</span><br><span class="line">                        777：   并非就是777，涉及到掩码，最终的权限是 mode &amp; ~umask</span><br><span class="line">                                    umask = 0022  ~umask = 0755</span><br><span class="line">                                        0777 -&gt; 111111111</span><br><span class="line">                                    &amp;   0755 -&gt; 111101101</span><br><span class="line">                                        0755 -&gt; 111101101</span><br><span class="line">                    umask的作用就是抹去某些权限</span><br><span class="line"></span><br><span class="line">                                </span><br><span class="line">    返回值：</span><br><span class="line">    返回一个新的文件描述符；若失败则返回-1</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code>flags
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">和</span><br><span class="line"></span><br></pre></td></tr></table></figure>
mode_t
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  的区别：</span><br><span class="line"></span><br><span class="line">  - `flags`是程序在运行时，能以什么权限对文件进行操作；</span><br><span class="line">  - `mode_t`是指这个文件本身的权限。</span><br><span class="line"></span><br><span class="line">- 关于rwx权限：</span><br><span class="line"></span><br><span class="line">  - r   - 读，对文件而言，具有读取文件内容的权限；对目录来说，具有浏览该目录信息的权限</span><br><span class="line"></span><br><span class="line">  - w  - 写，对文件而言，具有修改文件内容的权限；对目录来说具有删除移动目录内文件的权限</span><br><span class="line"></span><br><span class="line">  - x   - 可执行，对文件而言，具有执行文件的权限；对目录来说，具有进入目录的权限</span><br><span class="line"></span><br><span class="line">    | 第一位  | 用户   | 组用户 | 其他用户 |</span><br><span class="line">    | ------- | ------ | ------ | -------- |</span><br><span class="line">    | -  文件 | d 目录 | rwx    | r-x      |</span><br><span class="line"></span><br><span class="line">2）read &amp; write函数</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">        参数：</span><br><span class="line">            - fd        文件描述符，open得到</span><br><span class="line">            - *buf      缓冲区，读取数据存放的地方，数组的地址</span><br><span class="line">            - count     指定的数组的大小</span><br><span class="line">        返回值</span><br><span class="line">            - 成功：</span><br><span class="line">                &gt;0      返回实际读取到的字节数</span><br><span class="line">                =0      文件已经读取完毕</span><br><span class="line">            - 失败</span><br><span class="line">                -1      并设置errno</span><br><span class="line"></span><br><span class="line">ssize_t  write(int  fd,  const void *buf, size_t count);</span><br><span class="line">        参数：</span><br><span class="line">		        - fd        文件描述符，open得到</span><br><span class="line">		        - *buf      要往磁盘写入的数据，数据</span><br><span class="line">		        - count     实际写入数据大小</span><br><span class="line">        返回值</span><br><span class="line">            - 成功：</span><br><span class="line">                &gt;0      返回实际读取到的字节数</span><br><span class="line">                =0      无任何数据写到文件中</span><br><span class="line">            - 失败</span><br><span class="line">                -1      并设置errno</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>对于write函数来说，如果count的大小（实际写入数据的大小）大于缓冲区实际大小时，那么会把缓冲区后面的内存中的数据写进去，只不过这些数据我们是不确定的，是野内存，操作野内存有可能会产生问题，所以一般不会这么去做。缓冲区中有多少数据，我们就写多少数据即可。</p>
</li>
</ul>
<p>3）lseek函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">标准C库：</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"></span><br><span class="line">Linux系统函数：</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line">    <span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line">        对文件指针进行操作</span><br><span class="line">        参数：</span><br><span class="line">            - fd        文件描述符</span><br><span class="line">            - offset    偏移量  </span><br><span class="line">            - whence    </span><br><span class="line">                SEEK_SET</span><br><span class="line">                    设置文件指针的偏移量</span><br><span class="line"></span><br><span class="line">                SEEK_CUR</span><br><span class="line">                    设置偏移量：当前位置 + 第二个参数offset的值</span><br><span class="line"></span><br><span class="line">                SEEK_END</span><br><span class="line">                    设置偏移量：文件大小 + 第二个参数offset的值</span><br><span class="line">        返回值：返回文件指针的位置</span><br><span class="line">        作用：</span><br><span class="line">            <span class="number">1</span>、移动文件指针到头文件</span><br><span class="line">                lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">            <span class="number">2</span>、获取当前文件指针的位置</span><br><span class="line">                lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line">            <span class="number">3</span>、获取文件长度</span><br><span class="line">                lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">            <span class="number">4</span>、拓展文件长度 ex. <span class="number">10b</span> =&gt; <span class="number">110b</span></span><br><span class="line">                lseek(fd, <span class="number">100</span>, SEEK_END);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>利用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek</span><br></pre></td></tr></table></figure>

<p>函数拓展文件长度时需要写入一次数据才能起作用：</p>
<ul>
<li>拓展时，<code>lseek</code>只是逻辑上移动文件指针的位置，并没有为文件分配存储空间，为了让这些空间实际得到分配，可以使用<code>write</code>在最后补充一个字符，这样拓展的存储空间应该就分配了。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓展文件长度</span></span><br><span class="line">    <span class="type">int</span> ret = lseek(fd, <span class="number">100</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入空数据，被写入到第112b的位置上</span></span><br><span class="line">    <span class="comment">// 不执行这一步之前一般ll是看不到hello.txt的文件大小变化的</span></span><br><span class="line">    <span class="comment">// hello.txt : 11b ==&gt; 112b</span></span><br><span class="line">    write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br></pre></td></tr></table></figure>

<p>4）stat\lstat函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line">    作用：获取一个文件相关的一些信息</span><br><span class="line">    参数:</span><br><span class="line">        - pathname：    操作的文件的路径</span><br><span class="line">        - statbuf：     结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="line">    返回值：</span><br><span class="line">        成功：返回<span class="number">0</span></span><br><span class="line">        失败：返回<span class="number">-1</span> 设置errno</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line">    参数:</span><br><span class="line">        - pathname：    操作的文件的路径</span><br><span class="line">        - statbuf：     结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="line">    返回值：</span><br><span class="line">        成功：返回<span class="number">0</span></span><br><span class="line">        失败：返回<span class="number">-1</span> 设置errno</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020543.png" alt="31"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171020502.png" alt="32"></p>
<p>5）文件属性操作函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>;</span><br><span class="line">    作用：判断某个文件是否有某个权限，或者判断文件是否存在</span><br><span class="line">    参数：</span><br><span class="line">        - pathname: 判断的文件路径</span><br><span class="line">        - mode:</span><br><span class="line">            R_OK: 判断是否有读权限</span><br><span class="line">            W_OK: 判断是否有写权限</span><br><span class="line">            X_OK: 判断是否有执行权限</span><br><span class="line">            F_OK: 判断文件是否存在</span><br><span class="line">    返回值：成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">    修改文件的权限</span><br><span class="line">    参数：</span><br><span class="line">        - pathname: 需要修改的文件的路径</span><br><span class="line">        - mode:需要修改的权限值，八进制的数</span><br><span class="line">    返回值：成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line">    作用：缩减或者扩展文件的尺寸至指定的大小</span><br><span class="line">    参数：</span><br><span class="line">        - path: 需要修改的文件的路径</span><br><span class="line">        - length: 需要最终文件变成的大小</span><br><span class="line">    返回值：</span><br><span class="line">        成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前用户id和组id：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/passwd <span class="comment">// 用户</span></span><br><span class="line">vim /etc/group   <span class="comment">// 组</span></span><br></pre></td></tr></table></figure>

<p>6）目录操作函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">    作用：创建一个目录</span><br><span class="line">    参数：</span><br><span class="line">        pathname: 创建的目录的路径</span><br><span class="line">        mode: 权限，八进制的数</span><br><span class="line">    返回值：</span><br><span class="line">        成功返回<span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"><span class="type">int</span> ret = mkdir(<span class="string">&quot;aaa&quot;</span>, <span class="number">0777</span>);</span><br><span class="line"><span class="comment">// 最终的权限结果是 mode &amp; ~umask &amp; 0777</span></span><br><span class="line"><span class="comment">// 给的是0777 ==&gt; 最终得到 drwxr-xr-x</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line">    作用：修改进程的工作目录</span><br><span class="line">        比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder</span><br><span class="line">    参数：</span><br><span class="line">        path : 需要修改的工作目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br><span class="line">    作用：获取当前工作目录</span><br><span class="line">    参数：</span><br><span class="line">        - buf : 存储的路径，指向的是一个数组（传出参数）</span><br><span class="line">        - size: 数组的大小</span><br><span class="line">    返回值：</span><br><span class="line">        返回的指向的一块内存，这个数据就是第一个参数</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure>

<p>7）目录遍历函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开一个目录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line">    参数：</span><br><span class="line">        - name: 需要打开的目录的名称</span><br><span class="line">    返回值：</span><br><span class="line">        DIR * 类型，理解为目录流</span><br><span class="line">        错误返回<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取目录中的数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line">    - 参数：dirp是opendir返回的结果</span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>，代表读取到的文件的信息</span></span><br><span class="line"><span class="class">        读取到了末尾或者失败了，返回<span class="title">NULL</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 关闭目录</span></span><br><span class="line"><span class="class">#<span class="title">include</span> &lt;</span>sys/types.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171021405.png" alt="33"></p>
<p>8）dup\dup2函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line">	  作用：复制一个新的文件描述符</span><br><span class="line">	  fd=<span class="number">3</span>, <span class="type">int</span> fd1 = dup(fd),</span><br><span class="line">	  fd指向的是a.txt, fd1也是指向a.txt</span><br><span class="line">		从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> dup2(<span class="type">int</span> oldfd, <span class="type">int</span> newfd);</span><br><span class="line">    作用：重定向文件描述符</span><br><span class="line">    oldfd 指向 a.txt, newfd 指向 b.txt</span><br><span class="line">    调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt</span><br><span class="line">    oldfd 必须是一个有效的文件描述符</span><br><span class="line">    oldfd和newfd值相同，相当于什么都没有做</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd1 = open(<span class="string">&quot;2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line"><span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d\\n&quot;</span>, fd, fd1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做了dup2之后 fd1就和2.txt没有关系了  </span></span><br><span class="line"><span class="comment">// 返回值fd2其实没必要再做任何操作了</span></span><br><span class="line"><span class="type">int</span> fd2 = dup2(fd, fd1);</span><br><span class="line"><span class="keyword">if</span>(fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样重定向之后2.txt就没有任何文件描述符了</span></span><br><span class="line"><span class="comment">// 如果还需要访问2.txt，则需要重新open一下，赋值一个新的文件描述符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过fd1去写数据，实际操作的是1.txt，而不是2.txt</span></span><br><span class="line"><span class="type">char</span> * str = <span class="string">&quot;hello, dup2&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9）fcntl函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span>;</span><br><span class="line">参数：</span><br><span class="line">    fd : 表示需要操作的文件描述符</span><br><span class="line">    cmd: 表示对文件描述符进行如何操作</span><br><span class="line">        - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）</span><br><span class="line">            <span class="type">int</span> ret = fcntl(fd, F_DUPFD);</span><br><span class="line"></span><br><span class="line">        - F_GETFL : 获取指定的文件描述符文件状态flag</span><br><span class="line">          获取的flag和我们通过open函数传递的flag是一个东西。</span><br><span class="line"></span><br><span class="line">        - F_SETFL : 设置文件描述符文件状态flag</span><br><span class="line">          必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改</span><br><span class="line">          可选性：O_APPEND, O_NONBLOCK</span><br><span class="line">            O_APPEND 表示追加数据</span><br><span class="line">            O_NONBLOCK 设置成非阻塞</span><br><span class="line">    </span><br><span class="line">    阻塞和非阻塞：描述的是函数调用的行为。</span><br></pre></td></tr></table></figure>

<h1 id="6、进程"><a href="#6、进程" class="headerlink" title="6、进程"></a>6、进程</h1><h2 id="（1）进程概述"><a href="#（1）进程概述" class="headerlink" title="（1）进程概述"></a>（1）进程概述</h2><ul>
<li>进程要占用内存和CPU资源，而程序不占用</li>
<li>从内核角度看：进程 &#x3D; 用户内存空间 + 内核数据结构</li>
<li><code>时间片(timeslice)</code>是操作系统分配给每个正在运行的进程微观上的一段CPU时间。由于timeslice的存在，让进程“看起来像”是同时运行的。<strong>Linux一般为5ms-800ms</strong></li>
<li>并行和并发<ul>
<li><code>并行(parallel)</code>：指在同一时刻，有多条指令在多个处理器上同时执行。</li>
<li><code>并发(concurrency)</code>：指在同一时刻只能有一条指令执行，但多个进程指令被快速的 轮换执行，本质上是把时间分成若干段，使多个进程快速交替的执行。</li>
</ul>
</li>
<li>内核为每个进程分配一个PCB(Processing Control Block)进程控制块</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171022599.png" alt="34"></p>
<h2 id="（2）进程状态转换"><a href="#（2）进程状态转换" class="headerlink" title="（2）进程状态转换"></a>（2）进程状态转换</h2><p>1）进程状态</p>
<ul>
<li><p>三态模型</p>
<ul>
<li>就绪态：进程具备运行条件，已分配到除CPU以外的所有必要资源；处于就绪态的多个进程排成就绪队列</li>
<li>运行态：进程占有处理器正在运行</li>
<li>阻塞态：进程不具备运行条件，又称wait或sleep态，需要与用户进行交互时也将阻塞</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171024144.png" alt="35"></p>
</li>
<li><p>五态模型</p>
<ul>
<li>新建态：进程刚被创建，尚未进入就绪队列</li>
<li>就绪态</li>
<li>运行态</li>
<li>阻塞态</li>
<li>终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统以及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171024552.png" alt="36"></p>
</li>
</ul>
<p>2）进程相关命令</p>
<ul>
<li>查看进程 <code>ps aux / ajx</code> a：显示终端上的所有进程，包括其他用户的进程 u：显示进程的详细信息 x：显示没有控制终端的进程 j：列出与作业控制相关的信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson<span class="meta"># ps aux</span></span><br><span class="line">USER  PID  %CPU  %MEM  VSZ  RSS  TTY  STAT  START  TIME  COMMAND</span><br><span class="line"></span><br><span class="line">root@iisayhi:~/lesson<span class="meta"># ps ajx</span></span><br><span class="line">PPID  PID  PGID  SID  TTY  TPGID  STAT  UID  TIME  COMMAND</span><br><span class="line">PPID - 父进程ID  </span><br><span class="line">PID  - 进程ID  </span><br><span class="line">PGID - 进程组的ID</span><br><span class="line">SID  - 会话的ID</span><br><span class="line">TTY  - 终端  </span><br></pre></td></tr></table></figure>

<ul>
<li>实时显示进程动态 <code>top</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171024495.png" alt="37"></p>
<ul>
<li>杀死进程<ul>
<li><code>kill [-signal] pid</code></li>
<li><code>kill –l</code> 列出所有信号</li>
<li><code>kill –SIGKILL</code> 进程ID</li>
<li><code>kill -9</code> 进程ID</li>
<li><code>killall name</code> 根据进程名杀死进程</li>
</ul>
</li>
</ul>
<p>3）进程相关</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025257.png" alt="38"></p>
<ul>
<li>父子进程虚拟地址空间情况</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid : %d\\n&quot;</span>, pid);</span><br><span class="line">        <span class="comment">// 若大于0，当前为父进程，并返回子进程的进程号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent procress, pid : %d, ppid : %d\\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 若等于0，当前为子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child procress, pid : %d, ppid : %d\\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d, pid : %d\\n&quot;</span>, i, getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。</span></span><br><span class="line"><span class="comment">写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</span></span><br><span class="line"><span class="comment">内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</span></span><br><span class="line"><span class="comment">只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</span></span><br><span class="line"><span class="comment">也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</span></span><br><span class="line"><span class="comment">注意：fork之后父子进程共享文件，</span></span><br><span class="line"><span class="comment">fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">root@iisayhi:~/lesson/lesson07<span class="meta"># gcc fork.c -o fork</span></span><br><span class="line">root@iisayhi:~/lesson/lesson07# ./fork</span><br><span class="line">pid : <span class="number">265418</span></span><br><span class="line">I am parent procress, pid : <span class="number">265417</span>, ppid : <span class="number">264856</span></span><br><span class="line">i : <span class="number">0</span>, pid : <span class="number">265417</span></span><br><span class="line">I am child procress, pid : <span class="number">265418</span>, ppid : <span class="number">265417</span></span><br><span class="line">i : <span class="number">0</span>, pid : <span class="number">265418</span></span><br><span class="line">i : <span class="number">1</span>, pid : <span class="number">265417</span></span><br><span class="line">i : <span class="number">1</span>, pid : <span class="number">265418</span></span><br><span class="line">i : <span class="number">2</span>, pid : <span class="number">265417</span></span><br><span class="line">i : <span class="number">2</span>, pid : <span class="number">265418</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025204.png" alt="39"></p>
<blockquote>
<p>Linux父子进程中变量地址相同——虚拟内存</p>
<p>csdn参考网址：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45636061/article/details/124610215?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124610215-blog-124260634.235%5Ev28%5Epc_relevant_t0_download&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124610215-blog-124260634.235%5Ev28%5Epc_relevant_t0_download&utm_relevant_index=2">虚拟内存</a></p>
<p><strong>物理内存和虚拟内存被分成了页框与页之后，其存储单元原来的地址都被自然地分成了两段，并且这两段各自代表着不同的意义：高位段分别叫做页框码和页码，它们是识别页框和页的编码；低位段分别叫做页框偏移量和页内偏移量，它们是存储单元在页框和页内的地址编码。</strong></p>
<p><strong>处理器遇到的地址都是虚拟地址。虚拟地址和物理地址都分成页码（页框码）和偏移值两部分。在由虚拟地址转化成物理地址的过程中，偏移值不变。而页码和页框码之间的映射就在一个映射记录表——页表中。</strong></p>
<p><strong>当程序执行fork()并创建子进程时，子进程会完全复制父进程的栈空间，包括页表，但没有复制物理页面，所以这时父子进程的变量地址相同，也即虚拟地址和物理地址相同。</strong></p>
<p>但是此时父子共享的页面仅标记为“只读”，在父子进程都没有访问内存时，二者共享一个页面。</p>
<p>当发生内存访问操作时，内核会复制一个物理页面给该进程，并修改其页表。同时把原来的只读页面标记为“可写”，留给另一个进程。以上即为所谓的“<strong>写时复制</strong>”或“<strong>写时拷贝</strong>”。</p>
</blockquote>
<ul>
<li><p>父子进程关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">父子进程之间的关系：</span><br><span class="line">    区别：</span><br><span class="line">        <span class="number">1.f</span>ork()函数的返回值不同</span><br><span class="line">            父进程中: &gt;<span class="number">0</span> 返回的子进程的ID</span><br><span class="line">            子进程中: =<span class="number">0</span></span><br><span class="line">        <span class="number">2.</span>pcb（进程控制块）中的一些数据</span><br><span class="line">            当前的进程的id pid</span><br><span class="line">            当前的进程的父进程的id ppid</span><br><span class="line">            信号集</span><br><span class="line"></span><br><span class="line">    共同点：</span><br><span class="line">        某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</span><br><span class="line">            - 用户区的数据</span><br><span class="line">            - 文件描述符表</span><br><span class="line">    </span><br><span class="line">    父子进程对变量是不是共享的？</span><br><span class="line">        - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。</span><br><span class="line">        - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。</span><br></pre></td></tr></table></figure>
</li>
<li><p>GDB多进程调试</p>
<ul>
<li><p>GDB默认只能跟踪一个进程，<strong>默认跟踪父进程</strong>。所以需要指令设置GDB跟踪的是父进程还是子进程</p>
</li>
<li><p>设置调试父进程或子进程：</p>
<ul>
<li><code>set follow-fork-mode [parent(默认) | child]</code></li>
</ul>
</li>
<li><p>设置调试模式</p>
<ul>
<li><pre><code>set detach-on-fork [on | off]
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      - `on`：调试当前进程时，其它进程继续运行；</span><br><span class="line">      - `off`：调试当前进程时，其它进程被GDB挂起。</span><br><span class="line"></span><br><span class="line">  - 查看调试的进程：</span><br><span class="line"></span><br><span class="line">    - `info inderiors`</span><br><span class="line"></span><br><span class="line">  - 切换当前调试的进程：</span><br><span class="line"></span><br><span class="line">    - `inferior id`</span><br><span class="line"></span><br><span class="line">  - 使进程脱离GDB调试：</span><br><span class="line"></span><br><span class="line">    - `detach inferiors id`</span><br><span class="line"></span><br><span class="line">## （3）exec函数族</span><br><span class="line"></span><br><span class="line">- **exec函数族**的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件</span><br><span class="line"></span><br><span class="line">- **exec函数族**的函数执行成功后不会返回，因为**调用进程的实体，包括代码段，数据段和堆栈等（即即将执行的可执行文件的用户区内容）都已经被新的内容取代**，只留下进程 ID 等一些表面上的信息仍保持原样；**只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行**</span><br><span class="line"></span><br><span class="line">- 函数原型：</span><br><span class="line"></span><br><span class="line">  ![40](https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025390.png)</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  #include &lt;unistd.h&gt;</span><br><span class="line">  int execl(const char *path, const char *arg, ...);</span><br><span class="line">      - 参数：</span><br><span class="line">          - path:需要指定的执行的文件的路径或者名称</span><br><span class="line">              a.out /home/nowcoder/a.out 推荐使用绝对路径</span><br><span class="line">              ./a.out hello world</span><br><span class="line">  </span><br><span class="line">          - arg:是执行可执行文件所需要的参数列表</span><br><span class="line">              第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="line">              从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="line">              参数最后需要以NULL结束（哨兵）</span><br><span class="line">  </span><br><span class="line">      - 返回值：</span><br><span class="line">          只有当调用失败，才会有返回值，返回-1，并且设置errno</span><br><span class="line">          如果调用成功，没有返回值。</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="（4）进程控制"><a href="#（4）进程控制" class="headerlink" title="（4）进程控制"></a>（4）进程控制</h2><p>1）进程退出</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025341.png" alt="41"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">    void exit(int status);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    void _exit(int status);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\\n&quot;</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exit(0); // 可打印hello world</span></span><br><span class="line">    _exit(<span class="number">0</span>);   <span class="comment">// 仅打印hello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分析：</span></span><br><span class="line">    <span class="comment">// 对于标准c库函数printf，首先会把其中的内容放入缓冲区</span></span><br><span class="line">    <span class="comment">// 当有\\n时，会对缓冲区进行刷新，从而就可以获取到hello这一内容</span></span><br><span class="line">    <span class="comment">// 而没有\\n时，world会首先被放到缓冲区，_exit也不会对缓冲区进行刷新，从而无法打印</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）孤儿进程</p>
<ul>
<li>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程<strong>（Orphan Process）</strong></li>
<li>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为<code>init</code>，而<code>init</code>进程会循环地 <code>wait()</code>已经退出的子进程。这样，当一个孤儿进程结束了其生命周期的时候，<code>init</code>进程就会处理它的一切善后工作</li>
<li>孤儿进程实际上无危害</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d, ppid : %d\\n&quot;</span>, getpid(), getppid());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 当前是子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d, ppid : %d\\n&quot;</span>, getpid(),getppid());</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d , pid : %d\\n&quot;</span>, i , getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">root@iisayhi:~/lesson/lesson08# ./orphan</span><br><span class="line">i am parent process, pid : <span class="number">275127</span>, ppid : <span class="number">272697</span></span><br><span class="line">i : <span class="number">0</span> , pid : <span class="number">275127</span></span><br><span class="line">i : <span class="number">1</span> , pid : <span class="number">275127</span></span><br><span class="line">i : <span class="number">2</span> , pid : <span class="number">275127</span></span><br><span class="line">root@iisayhi:~/lesson/lesson08<span class="meta"># i am child process, pid : 275128, **ppid : 1**</span></span><br><span class="line">i : <span class="number">0</span> , pid : <span class="number">275128</span></span><br><span class="line">i : <span class="number">1</span> , pid : <span class="number">275128</span></span><br><span class="line">i : <span class="number">2</span> , pid : <span class="number">275128</span></span><br></pre></td></tr></table></figure>

<p>3）僵尸进程</p>
<ul>
<li>每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。<strong>进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程</strong></li>
<li><strong>僵尸进程不能被</strong><code>kill -9</code><strong>杀死</strong>，因此如果父进程不调用<code>wait()</code>或<code>waitpid()</code>的话，那么保留的那段信息就不会释放，<strong>其进程号就会一直被占用</strong>，但是系统所能使用的进程号是有限的，<strong>如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免</strong></li>
</ul>
<p>4）wait &amp; waitpid</p>
<ul>
<li><p><strong>注意：一次<code>wait</code>或<code>waitpid</code>调用只能清理一个子进程，清理多个子进程应使用循环</strong></p>
</li>
<li><p><code>wait()</code></p>
<ul>
<li><code>wait()</code>函数会阻塞<strong>（阻塞的意思就是说，在子进程结束前，会一直阻塞在<code>wait()</code>函数处，等到子进程结束后才会继续向下执行）</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171025019.png" alt="42"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *wstatus)</span>;</span><br><span class="line">    功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源。</span><br><span class="line">    参数：<span class="type">int</span> *wstatus</span><br><span class="line">        进程退出时的状态信息，传入的是一个<span class="type">int</span>类型的地址，传出参数。</span><br><span class="line">    返回值：</span><br><span class="line">        - 成功：返回被回收的子进程的id</span><br><span class="line">        - 失败：<span class="number">-1</span> (所有的子进程都结束，调用函数失败)</span><br><span class="line"></span><br><span class="line">调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span><br><span class="line">如果没有子进程了，函数立刻返回，返回<span class="number">-1</span>；如果子进程都已经结束了，也会立即返回，返回<span class="number">-1.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>waitpid()</code></p>
<ul>
<li><code>waitpid()</code>可以设置不阻塞<strong>（不阻塞的意思就是说，即使子进程还未结束，<code>waitpid()</code>也会立刻返回，程序可以接着往下执行）</strong>，<code>waitpid()</code>还可以指定等待哪个子进程结束</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line">    功能：回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="line">    参数：</span><br><span class="line">        - pid:</span><br><span class="line">            pid &gt; <span class="number">0</span> : 某个子进程的pid</span><br><span class="line">            pid = <span class="number">0</span> : 回收当前进程组的所有子进程    </span><br><span class="line">            pid = <span class="number">-1</span> : 回收所有的子进程，相当于 wait()  （最常用）</span><br><span class="line">            pid &lt; <span class="number">-1</span> : 某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="line">        - options：设置阻塞或者非阻塞</span><br><span class="line">            <span class="number">0</span> : 阻塞</span><br><span class="line">            WNOHANG : 非阻塞</span><br><span class="line">     返回值：</span><br><span class="line">        &gt; <span class="number">0</span> : 返回子进程的id</span><br><span class="line">        = <span class="number">0</span> : options=WNOHANG, 表示还有子进程或者</span><br><span class="line">        = <span class="number">-1</span> ：错误，或者没有子进程了</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="（5）进程间通信"><a href="#（5）进程间通信" class="headerlink" title="（5）进程间通信"></a>（5）进程间通信</h2><h3 id="1）匿名管道"><a href="#1）匿名管道" class="headerlink" title="1）匿名管道"></a>1）匿名管道</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">管道的读写特点：</span><br><span class="line">使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I/O操作）</span><br><span class="line">	<span class="number">1.</span>所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为<span class="number">0</span>），有进程从管道的读端</span><br><span class="line">	读数据，那么管道中剩余的数据被读取以后，再次read会返回<span class="number">0</span>，就像读到文件末尾一样。</span><br><span class="line">	</span><br><span class="line">	<span class="number">2.</span>如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于<span class="number">0</span>），而持有管道写端的进程</span><br><span class="line">	也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，</span><br><span class="line">	再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。</span><br><span class="line">	</span><br><span class="line">	<span class="number">3.</span>如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为<span class="number">0</span>），这个时候有进程</span><br><span class="line">	向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。</span><br><span class="line">	</span><br><span class="line">	<span class="number">4.</span>如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于<span class="number">0</span>），而持有管道读端的进程</span><br><span class="line">	也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，</span><br><span class="line">	直到管道中有空位置才能再次写入数据并返回。</span><br><span class="line">总结：</span><br><span class="line">	读管道：</span><br><span class="line">		管道中有数据，read返回实际读到的字节数。</span><br><span class="line">		管道中无数据：</span><br><span class="line">			写端被全部关闭，read返回<span class="number">0</span>（相当于读到文件的末尾）</span><br><span class="line">			写端没有完全关闭，read阻塞等待</span><br><span class="line">	</span><br><span class="line">	写管道：</span><br><span class="line">    管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）</span><br><span class="line">    管道读端没有全部关闭：</span><br><span class="line">        管道已满，write阻塞</span><br><span class="line">        管道没有满，write将数据写入，并返回实际写入的字节数</span><br></pre></td></tr></table></figure>

<h3 id="2）有名管道"><a href="#2）有名管道" class="headerlink" title="2）有名管道"></a>2）有名管道</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">有名管道的注意事项：</span><br><span class="line">	<span class="number">1.</span>一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</span><br><span class="line">	<span class="number">2.</span>一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</span><br><span class="line"></span><br><span class="line">读管道：</span><br><span class="line">    管道中有数据，read返回实际读到的字节数</span><br><span class="line">    管道中无数据：</span><br><span class="line">        写端被全部关闭，read返回<span class="number">0</span>（相当于读到文件末尾）</span><br><span class="line">        写端没有完全关闭，read阻塞等待</span><br><span class="line"></span><br><span class="line">写管道：</span><br><span class="line">    管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）</span><br><span class="line">    管道读端没有全部关闭：</span><br><span class="line">        管道已满，write阻塞</span><br><span class="line">        管道没有满，write将数据写入，并返回实际写入的字节数。</span><br></pre></td></tr></table></figure>

<ul>
<li>有名管道实现简单版聊天功能</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171026474.png" alt="43"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读数据</span></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">  ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">  <span class="comment">// ret = read(fdr, buf, strlen(buf)); 错误写法</span></span><br><span class="line">  <span class="keyword">if</span>(ret &lt;= <span class="number">0</span> )&#123;perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>read</code>函数的原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>fd</code>为文件描述符；<code>buf</code>表示读出数据缓冲区地址；<code>count</code>表示读出的字节数。</p>
<p>因此，若写成<code>ret = read(fdr, buf, strlen(buf))</code>，在当时所写程序中，最开始并未写入数据，因此读到的数据为空，则将报错</p>
<h2 id="（6）内存映射"><a href="#（6）内存映射" class="headerlink" title="（6）内存映射"></a>（6）内存映射</h2><p>内存映射（Memory-mapped I&#x2F;O）是将磁盘文件的数据映射到内存，用户通过修改 内存就能修改磁盘文件。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171026332.png" alt="44"></p>
<h1 id="7、阻塞-非阻塞-同步-异步"><a href="#7、阻塞-非阻塞-同步-异步" class="headerlink" title="7、阻塞&#x2F;非阻塞 &amp;&amp; 同步&#x2F;异步"></a>7、阻塞&#x2F;非阻塞 &amp;&amp; 同步&#x2F;异步</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lengxiao1993/article/details/78154467?ops_request_misc=%7B%22request_id%22:%22168319803316800182190279%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168319803316800182190279&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-78154467-null-null.142%5Ev86%5Ekoosearch_v1,239%5Ev2%5Einsert_chatgpt&utm_term=%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E&spm=1018.2226.3001.4187">阻塞与非阻塞_csdn</a></p>
<ul>
<li><p>阻塞（Blocking）与非阻塞（Nonblocking）是在数据就绪阶段进行判断</p>
<ul>
<li><p>阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。</p>
</li>
<li><p>非阻塞指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。当前线程可以去干别的事情。</p>
</li>
<li><p>sockfd对应操作系统中一个tcp缓冲区，阻塞与非阻塞都在该缓冲区中进行考虑。</p>
<blockquote>
<p><strong>阻塞IO和非阻塞IO的区别就在于</strong>： 应用程序的调用是否立即返回</p>
</blockquote>
</li>
</ul>
</li>
<li><p>同步（Synchronous）与非同步（Asynchronous）在数据读写阶段进行判断</p>
<ul>
<li><p>同步即应用程序自己从内核缓冲区中获取数据送入自己定义的buf中，只有数据获取结束之后应用程序才能进行其他的操作。</p>
</li>
<li><p>异步中有一个非常重要的“通知方式”，异步即为操作系统将数据从内核中送入自己定义的buf中，不需要我们自己操作，数据放好后通过“通知方式”告诉我们</p>
<blockquote>
<p><strong>同步IO</strong>：应用程序主动向内核查询是否有可用数据，如果有,当前进程自己负责把数据从内核copy到用户空间，拷贝的过程中进程阻塞。 <strong>异步IO</strong>：应用程序向内核发起读数据请求时需要：（1）告诉内核数据存放位置（2）注册回调函数，当内核完成数据copy后调用回调通知应用程序取数据。因为数据copy由内核完成的，所以拷贝的时候进程不阻塞。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="8、用户空间和内核空间"><a href="#8、用户空间和内核空间" class="headerlink" title="8、用户空间和内核空间"></a>8、用户空间和内核空间</h1><ul>
<li>内存空间的划分<ul>
<li>内核空间</li>
<li>用户空间</li>
</ul>
</li>
<li><strong>操作系统内核需要拥有高于普通进程的权限</strong>， 以此来调度和管理用户的应用程序，不同进程间相对独立。</li>
<li>硬件层面的内存访问权限控制细节：DPL&#x2F;CPL</li>
</ul>
<h1 id="9、进程切换与进程阻塞"><a href="#9、进程切换与进程阻塞" class="headerlink" title="9、进程切换与进程阻塞"></a>9、进程切换与进程阻塞</h1><ul>
<li>进程切换中几个最重要的步骤：</li>
</ul>
<p>1）当一个程序正在执行的过程中， 中断（interrupt） 或 系统调用（system call） 发生可以使得CPU的控制权会从当前进程转移到操作系统内核。</p>
<p>2）操作系统内核负责保存<code>进程i</code>在CPU中的上下文（程序计数器， 寄存器）到<code>PCBi</code>（操作系统分配给进程的一个内存块）中。</p>
<p>3）从<code>PCBj</code>取出<code>进程j</code>的CPU 上下文， 将 CPU 控制权转移给<code>进程j</code> ， 开始执行<code>进程j</code>的指令。</p>
<ul>
<li>中断<ul>
<li>在每个时钟周期末尾查询当前CPU中断位是否有中断信号送入，若有，判断当前正在执行的指令和中断信号的指令的优先级，决定执行哪个指令</li>
</ul>
</li>
<li>时钟中断<ul>
<li>一个硬件时钟会每隔一段（很短）的时间就产生一个中断信号发送给 CPU，CPU 在响应这个中断时， 就会去执行操作系统内核的指令， 继而将 CPU 的控制权转移给了操作系统内核， 可以由操作系统内核决定下一个要被执行的指令</li>
</ul>
</li>
<li>系统调用<ul>
<li>system call 是操作系统提供给应用程序的接口。 用户通过调用 system call 来完成那些需要操作系统内核进行的操作， 例如硬盘， 网络接口设备的读写等</li>
</ul>
</li>
<li><strong>对于一个运行着 UNIX 系统的现代 PC 来说， 进程切换至少需要花费 300 us 的时间</strong></li>
<li>进程阻塞<ul>
<li>我们所说的 “阻塞”是指进程在<strong>发起了一个系统调用</strong>（System Call） 后， 由于该系统调用的操作不能立即完成，需要等待一段时间，于是内核将进程挂起为等待 （waiting）状态， 以确保它不会被调度执行， 占用 CPU 资源。</li>
</ul>
</li>
</ul>
<h1 id="10、Unix-Linux上的五种IO模型"><a href="#10、Unix-Linux上的五种IO模型" class="headerlink" title="10、Unix&#x2F;Linux上的五种IO模型"></a>10、Unix&#x2F;Linux上的五种IO模型</h1><p>（1）<strong>（同步）阻塞 blocking</strong></p>
<p>阻塞即为：调用某函数后，必须等到该函数返回之后才能进行下一步动作。</p>
<p>（2）<strong>（同步）非阻塞 non-blocking</strong></p>
<p>非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。一旦内核中的数据准备好了，并且又再次收到了用户进程的请求，那么<strong>进程就会将内核中的数据拷贝到用户内存</strong>，然后返回。</p>
<p>非阻塞I&#x2F;O执行系统调用总是立即返回，不管事件是否已经发生。</p>
<p>（3）<strong>IO复用 IO multiplexing</strong></p>
<p>Linux 用 <code>select/poll/epoll</code> 函数实现 IO 复用模型。</p>
<p>这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。</p>
<p>（4）<strong>信号驱动 signal-driven</strong></p>
<p>Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到<code>SIGIO</code>信号，然后处理 IO 事件。</p>
<blockquote>
<p>多路复用和信号驱动的区别与联系：</p>
<ul>
<li>多路复用：内核们监听多个文件描述符，阻塞在监听的函数处（如<code>select/poll/epoll</code>），同时也阻塞在数据拷贝阶段。多路复用只是<strong>防止进程在某个io阻塞后，不能及时处理其他io的事件。</strong></li>
<li>信号驱动：先登记信号处理函数，当数据准备完毕后由内核发送信号给进程，让进程处理。信号驱动<strong>不阻塞在数据准备过程，但阻塞在数据拷贝</strong>。</li>
</ul>
</blockquote>
<p>💡 <strong>前四种方式都属于同步IO。</strong></p>
<p>（5）<strong>异步 asynchronous</strong></p>
<p>Linux中，可以调用 <code>aio_read</code> 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及<strong>通知的方式</strong>，然后<strong>立即返回</strong>，当内核将数据拷贝到缓冲区后，再通知应用程序。</p>
<h1 id="11、Web-Server（网页服务器）"><a href="#11、Web-Server（网页服务器）" class="headerlink" title="11、Web Server（网页服务器）"></a>11、<strong>Web Server（网页服务器）</strong></h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171026839.png" alt="45"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/13/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/13/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">手撕算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-13 14:56:15" itemprop="dateCreated datePublished" datetime="2024-04-13T14:56:15+08:00">2024-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-30 10:42:08" itemprop="dateModified" datetime="2024-05-30T10:42:08+08:00">2024-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9A%82%E4%B8%8D%E5%88%86%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">--暂不分类</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>457</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>合并K个有序数组</p>
<p>TOPK问题</p>
<p>逆波兰表达式</p>
<p>动态规划</p>
<p>快排最坏情况的比较次数，归并排序呢？</p>
<p>自定义实现strcpy函数</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/13/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/09/Computer/DataStruct/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/09/Computer/DataStruct/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="post-title-link" itemprop="url">代码随想录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-09 20:29:30" itemprop="dateCreated datePublished" datetime="2024-04-09T20:29:30+08:00">2024-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-05 10:41:03" itemprop="dateModified" datetime="2024-07-05T10:41:03+08:00">2024-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/DataStruct/" itemprop="url" rel="index"><span itemprop="name">DataStruct</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>46 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/09/Computer/DataStruct/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/08/Computer/Base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/08/Computer/Base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-08 23:57:17" itemprop="dateCreated datePublished" datetime="2024-04-08T23:57:17+08:00">2024-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-05 10:38:55" itemprop="dateModified" datetime="2024-07-05T10:38:55+08:00">2024-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/Base/" itemprop="url" rel="index"><span itemprop="name">Base</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、因特网概述"><a href="#1、因特网概述" class="headerlink" title="1、因特网概述"></a>1、因特网概述</h2><p><strong>internet与Internet的区别</strong></p>
<ul>
<li><p><strong>internet(互联网或互连网)<strong>是一个通用名词，它泛指</strong>多个计算机网络互连而成的网络</strong>。在这些网络之间的通信协议可以是任意的。</p>
</li>
<li><p><strong>Internet（因特网）则是一个专用名词</strong>，它指<strong>当前全球最大的、开放的、由众多网络互连而成的特定计算机网络</strong>，它采用TCP&#x2F;IP协议族作为通信的规则，其前身是美国的ARPANET。</p>
</li>
</ul>
<p>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是互联网(Internet)。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121642022.webp" alt="img"></p>
<blockquote>
<p>普通用户是如何接入到因特网的呢？</p>
<p>答：<strong>通过ISP接入因特网</strong></p>
<p>ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从<strong>ISP的得到所需要的IP地址</strong>。</p>
<p><strong>因为因特网上的主机都必须有IP地址才能进行通信，这样就可以通过该ISP接入到因特网</strong></p>
</blockquote>
<h2 id="2、计算机网络体系结构"><a href="#2、计算机网络体系结构" class="headerlink" title="2、计算机网络体系结构"></a>2、计算机网络体系结构</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121644183.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121645050.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121645246.webp" alt="img"></p>
<h1 id="二、网络层"><a href="#二、网络层" class="headerlink" title="二、网络层"></a>二、网络层</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646323.png" alt="image-20240412164600035"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646120.png" alt="image-20240412164607943"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646736.png" alt="image-20240412164616479"></p>
<h1 id="三、运输层"><a href="#三、运输层" class="headerlink" title="三、运输层"></a>三、运输层</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-d9a70806edc95dc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的。</strong></p>
<h2 id="2、运输层端口号、复用与分用的概念"><a href="#2、运输层端口号、复用与分用的概念" class="headerlink" title="2、运输层端口号、复用与分用的概念"></a>2、运输层端口号、复用与分用的概念</h2><h3 id="（1）为什么用端口号"><a href="#（1）为什么用端口号" class="headerlink" title="（1）为什么用端口号"></a>（1）为什么用端口号</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-de597eda77aa6acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（2）发送方的复用和接收方的分用"><a href="#（2）发送方的复用和接收方的分用" class="headerlink" title="（2）发送方的复用和接收方的分用"></a>（2）发送方的复用和接收方的分用</h3><ul>
<li><p><strong>多个进程</strong>利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据——<strong>复用</strong></p>
</li>
<li><p><strong>多个进程</strong>利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>数据—— <strong>分用</strong></p>
</li>
<li><p>这里一个端口表示一个进程</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2a4ec3f5d5c11433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（3）常用端口号"><a href="#（3）常用端口号" class="headerlink" title="（3）常用端口号"></a>（3）常用端口号</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2117fa99a7f2a89c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="3、TCP和UDP的对比"><a href="#3、TCP和UDP的对比" class="headerlink" title="3、TCP和UDP的对比"></a>3、TCP和UDP的对比</h2><h3 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h3><ul>
<li><p>TCP</p>
<ol>
<li>面向连接，需要在两个套接字之间建立连接，提供可靠服务；</li>
<li>传送TCP报文；</li>
<li>支持点对点单播，不支持多播、广播；</li>
<li>应用场景如万维网、电子邮件、文件传送等。</li>
</ol>
</li>
<li><p>UDP</p>
<ol>
<li><p>无连接，不需要套接字，不提供可靠交付；</p>
</li>
<li><p>传送UDP报文或用户数据报；</p>
</li>
<li><p>支持单播、多播和广播；</p>
</li>
<li><p>应用场景如多媒体应用等。</p>
<img src="https:////upload-images.jianshu.io/upload_images/24878825-624005a24bc5bfcd.png?imageMogr2/auto-orient/strip|imageView2/2/w/871/format/webp" alt="img" style="zoom: 50%;" /></li>
</ol>
</li>
</ul>
<h3 id="（2）TCP"><a href="#（2）TCP" class="headerlink" title="（2）TCP"></a>（2）TCP</h3><p>TCP（Transmission Control Protocol）</p>
<p>发送方</p>
<ul>
<li><p>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，但不知道这些待传送的字节流的含义</p>
</li>
<li><p>将他们编号，并存储在自己发送缓存中</p>
</li>
<li><p>根据发送策略，提取一定量的字节构建TCP报文并发送</p>
</li>
</ul>
<p>接收方</p>
<ul>
<li><p>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</p>
</li>
<li><p>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</p>
</li>
<li><p>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</p>
</li>
</ul>
<p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础。在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收。</p>
<img src="https:////upload-images.jianshu.io/upload_images/24878825-db48b70af7fb7884.png?imageMogr2/auto-orient/strip|imageView2/2/w/897/format/webp" alt="img" style="zoom:50%;" />

<h2 id="4、TCP的流量控制"><a href="#4、TCP的流量控制" class="headerlink" title="4、TCP的流量控制"></a>4、TCP的流量控制</h2><p>流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p>
<ul>
<li>当主机A收到主机B对相关字节数据的<strong>累计确认</strong>时，可以将其在发送缓存中删除。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f73e94f75e94ea4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5bd53b8a5a5ac400.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ea9dc3589e6c6bd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面。因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传。</p>
</blockquote>
<h2 id="5、TCP的拥塞控制"><a href="#5、TCP的拥塞控制" class="headerlink" title="5、TCP的拥塞控制"></a>5、TCP的拥塞控制</h2><p>在某段时间中，若对网络中某一资源（如链路容量&#x2F;带宽、缓存和处理机等）的需求超过了该资源所能提供的可用部分，就称发生了<strong>拥塞</strong>。</p>
<p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p>
<ol>
<li>点缓存的容量太小；</li>
<li>链路的容量不足；</li>
<li>处理机处理的速率太慢；</li>
<li>拥塞本身会进一步加剧拥塞；</li>
</ol>
<blockquote>
<p>相关算法</p>
<ul>
<li><strong>慢开始（slow-start）</strong></li>
<li><strong>拥塞避免（congestion avoidance）</strong></li>
<li><strong>快重传（fast transmit）</strong></li>
<li><strong>快恢复（fast recovery）</strong></li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c7682fe29ebcb6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>真正的发送窗口值 &#x3D; Min (接收方窗口值，拥塞窗口值)</p>
</blockquote>
<h3 id="（1）慢开始和拥塞避免"><a href="#（1）慢开始和拥塞避免" class="headerlink" title="（1）慢开始和拥塞避免"></a>（1）慢开始和拥塞避免</h3><h4 id="A-慢开始"><a href="#A-慢开始" class="headerlink" title="A. 慢开始"></a>A. 慢开始</h4><ul>
<li>目的：用来确定网络的负载能力或拥塞程度。</li>
<li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li>
<li>两个变量：<ul>
<li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。<ul>
<li>1 至 2 个最大报文段 （旧标准）</li>
<li>2 至 4 个最大报文段 （RFC 5681）</li>
</ul>
</li>
<li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-47dba7f2068f35df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1bca665e8eaa965a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/713/format/webp" alt="img"></p>
<blockquote>
<p>图中swnd是发送窗口</p>
<p>每经过一个传输轮次，拥塞窗口就加倍</p>
<p>窗口大小按<strong>指数增加</strong>，2的n-1次方</p>
</blockquote>
<h4 id="B-拥塞避免"><a href="#B-拥塞避免" class="headerlink" title="B. 拥塞避免"></a>B. 拥塞避免</h4><ul>
<li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。</li>
<li>每经过一个传输轮次，拥塞窗口 <strong>cwnd &#x3D; cwnd + 1</strong>。</li>
<li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li>
<li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。<img src="https://upload-images.jianshu.io/upload_images/24878825-f5db7ea25d8aca73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></li>
</ul>
<h3 id="（2）快重传和快恢复"><a href="#（2）快重传和快恢复" class="headerlink" title="（2）快重传和快恢复"></a>（2）快重传和快恢复</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-fee86fb3707a175c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="A-快重传"><a href="#A-快重传" class="headerlink" title="A. 快重传"></a>A. 快重传</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a57c7cc819aa4bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="B-快恢复"><a href="#B-快恢复" class="headerlink" title="B. 快恢复"></a>B. 快恢复</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-ab5a63efbd586eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="C-改进后的整体示意图"><a href="#C-改进后的整体示意图" class="headerlink" title="C. 改进后的整体示意图"></a>C. 改进后的整体示意图</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-8f61b8eddb5b2624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="6、TCP超时重传"><a href="#6、TCP超时重传" class="headerlink" title="6、TCP超时重传"></a>6、TCP超时重传</h2><blockquote>
<p>往返时间：<strong>RTT0</strong></p>
<p>超时重传时间：<strong>RTO</strong></p>
</blockquote>
<p>如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大；如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率。因此需要合理选择RTO的值。</p>
<ul>
<li>不能直接使用某次测量得到的RTT样本来计算超时重传时间RTO。应该利用每次测量得到的RTT样本，计算加权平均往返时间<strong>RTTs</strong>（又称为平滑的往返时间）</li>
</ul>
<p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107689.webp" alt="img"></p>
<p><strong>往返时间RTT的测量比较复杂</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107552.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107260.webp" alt="img"></p>
<p><strong>TCP超时重传的计算</strong></p>
<p>举例</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107514.webp" alt="img"></p>
<h2 id="7、TCP可靠传输的实现"><a href="#7、TCP可靠传输的实现" class="headerlink" title="7、TCP可靠传输的实现"></a>7、TCP可靠传输的实现</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-6d10ea76a1ea032b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-92d975bc880db892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-35bff0a8cc5b0d71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="8、三次握手"><a href="#8、三次握手" class="headerlink" title="8、三次握手"></a>8、三次握手</h2><h3 id="（1）三次握手详解"><a href="#（1）三次握手详解" class="headerlink" title="（1）三次握手详解"></a>（1）三次握手详解</h3><ul>
<li>采用<strong>三次握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li>
</ul>
<ul>
<li><p>TCP的连接建立要解决以下三个问题</p>
<ul>
<li>使得双方能够确知对方的存在；</li>
<li>使得双方能够协商一些参数（如最大窗口值、是否使用时间戳选项和服务质量等）；</li>
<li>使得双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li>
</ul>
</li>
<li><p><strong>具体过程</strong></p>
<ol>
<li><p><strong>TCP服务器进程创建传输控制块，用来存储TCP连接中的一些重要信息，并进入监听状态，等待TCP客户端进程的连接请求</strong></p>
</li>
<li><p><strong>TCP客户进程也是首先创建传输控制块</strong></p>
</li>
<li><p><strong>TCP客户进程向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态。</strong></p>
<ol>
<li>其中， TCP连接请求报文段首部中的同步位syn被设置为1，表明这是一个TCP连接请求报文段；</li>
<li>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号；</li>
<li>注意<em>该报文段不能携带数据</em>，但要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态。</strong></p>
<ol>
<li>同步位SYN和确认位ACK都设置为1，表明这是一个TCP连接请求确认报文段；</li>
<li>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号；</li>
<li>确认位ACK的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认；</li>
<li>注意<em>该报文段也不能携带数据</em>，且同样要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态。</strong></p>
<ol>
<li>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1；</li>
<li>确认位ACK被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认；</li>
<li>注意<em>普通的TCP确认报文段可以携带数据</em>，但如果不携带数据，则不消耗序号。</li>
</ol>
</li>
<li><p><strong>TCP服务器进程收到该确认报文段后也进入连接已建立状态。</strong></p>
</li>
</ol>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-987d5c8512392422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（2）为什么不能“两次握手”？"><a href="#（2）为什么不能“两次握手”？" class="headerlink" title="（2）为什么不能“两次握手”？"></a>（2）为什么不能“两次握手”？</h3><blockquote>
<p>不采用两次握手主要是为了<strong>防止已经失效的连接请求报文段突然又传到服务端</strong>，因而产生错误。</p>
<p>这种情况是：<strong>客户端发出的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到下一个连接释放以后的某个时间才到达服务器端。</strong>当服务器端收到此失效报文后，会误认为是客户端发出的一个新连接请求，于是客户端又发出确认报文，表示同意建立连接。</p>
<p>如果不采用“三次握手”，那么只要服务器端发出确认报文就会认为新的连接已经建立了，但此时客户端并没有发出建立连接的请求，因此不会向服务器端发送数据。服务器端没有收到数据就会一直等待，这样就会白白浪费掉很多资源。</p>
<p>所以必须采用“三次握手”而非“两次握手”。</p>
</blockquote>
<p>下图是“两次握手”的示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0a5773a600817c41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="9、四次挥手"><a href="#9、四次挥手" class="headerlink" title="9、四次挥手"></a>9、四次挥手</h2><h3 id="（1）四次挥手详解"><a href="#（1）四次挥手详解" class="headerlink" title="（1）四次挥手详解"></a>（1）四次挥手详解</h3><ul>
<li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong>端，被动等待连接建立的应用进程叫做<strong>TCP服务器</strong>。<strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong>。</li>
</ul>
<ul>
<li><p>具体过程</p>
<ol>
<li><p><strong>当客户端和服务器端都处于连接已建立状态时，若要释放连接，客户进程会发送TCP连接释放报文段，并进入终止等待状态。</strong></p>
<ol>
<li>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；</li>
<li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1；</li>
<li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1；</li>
<li>注意FIN等于1的报文段即使不携带数据，也要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态。</strong></p>
<ol>
<li>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配；</li>
<li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认。</li>
</ol>
</li>
<li><p><strong>此时，从客户进程到服务器进程这个方向的连接就释放了，这时的TCP连接属于半关闭状态，也就是客户进程已经没有数据要发送了。但如果服务器进程还有数据要发送，客户进程仍要接收，也就是说从服务器进程到客户进程这个方向的连接并未关闭。</strong></p>
</li>
<li><p><strong>客户进程收到TCP确认报文段后就进入终止等待状态，等待服务器进程发出的TCP连接释放报文段。若服务器进程已经没有数据要发送了，服务器进程即释放连接。由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接。</strong></p>
</li>
<li><p><strong>服务器进程发送TCP连接释放报文段并进入最后确认状态。</strong></p>
<ol>
<li><p>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；</p>
</li>
<li><p>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送；</p>
</li>
<li><p>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认。</p>
</li>
</ol>
</li>
<li><p><strong>客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态。服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要经过2MSL后才能进入关闭状态。</strong></p>
<ol>
<li>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号；</li>
<li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认。</li>
</ol>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1c5e0c6357d039ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
</li>
</ul>
<h3 id="（2）为什么不能“三次挥手”？"><a href="#（2）为什么不能“三次挥手”？" class="headerlink" title="（2）为什么不能“三次挥手”？"></a>（2）为什么不能“三次挥手”？</h3><p>TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p>
<blockquote>
<p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。</p>
<p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ef85470fe120f146.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="10、TCP保活计时器"><a href="#10、TCP保活计时器" class="headerlink" title="10、TCP保活计时器"></a>10、TCP保活计时器</h2><p>TCP双方已经建立连接时，TCP客户进程所在的主机突然出现了故障。此时服务器进程无法再收到客户进程发来的数据。因此，应当有措施使TCP服务器进程不要再白白等待下去。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2dc97e06fe1d82ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h1 id="四、应用层"><a href="#四、应用层" class="headerlink" title="四、应用层"></a>四、应用层</h1><h2 id="1、CS方式和P2P方式"><a href="#1、CS方式和P2P方式" class="headerlink" title="1、CS方式和P2P方式"></a>1、CS方式和P2P方式</h2><h3 id="（1）CS方式（客户-服务器方式）"><a href="#（1）CS方式（客户-服务器方式）" class="headerlink" title="（1）CS方式（客户&#x2F;服务器方式）"></a>（1）CS方式（客户&#x2F;服务器方式）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121850174.webp" alt="img"></p>
<h3 id="（2）P2P方式（对等方式）"><a href="#（2）P2P方式（对等方式）" class="headerlink" title="（2）P2P方式（对等方式）"></a>（2）P2P方式（对等方式）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121850280.webp" alt="img"></p>
<h2 id="2、动态主机配置协议DHCP"><a href="#2、动态主机配置协议DHCP" class="headerlink" title="2、动态主机配置协议DHCP"></a>2、动态主机配置协议DHCP</h2><ul>
<li><p>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</p>
</li>
<li><p>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</p>
</li>
<li><p>DHCP的工作过程</p>
<ul>
<li><p><strong>DHCP 使用客户 - 服务器方式</strong></p>
<ul>
<li><p>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文  （DHCP DISCOVER），这时该主机就成为 DHCP 客户。</p>
</li>
<li><p>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</p>
</li>
<li><p>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</p>
</li>
</ul>
</li>
<li><p><strong>DHCP 工作方式</strong></p>
<ul>
<li><p>DHCP 使用客户-服务器方式，采用请求&#x2F;应答方式工作。</p>
</li>
<li><p>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121853443.webp" alt="img"></p>
<ul>
<li><p>DHCP中继代理</p>
<h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p>下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-33c64efac75f0ad2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p>
</blockquote>
</li>
<li><p>总结</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121854516.webp" alt="img"></p>
</li>
</ul>
<h2 id="3、域名系统DNS"><a href="#3、域名系统DNS" class="headerlink" title="3、域名系统DNS"></a>3、域名系统DNS</h2><h3 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855489.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855338.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855952.webp" alt="img"></p>
<h3 id="（2）域名解析过程"><a href="#（2）域名解析过程" class="headerlink" title="（2）域名解析过程"></a>（2）域名解析过程</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856499.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856729.webp" alt="img"></p>
<h2 id="4、文件传送协议FTP"><a href="#4、文件传送协议FTP" class="headerlink" title="4、文件传送协议FTP"></a>4、文件传送协议FTP</h2><blockquote>
<p>注意两种模式都是（1）控制连接在整个会话期间保持打开状态；（2）数据连接传输完毕后就关闭。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856907.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121857685.webp" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/08/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E6%AF%95%E8%AE%BE%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/08/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E6%AF%95%E8%AE%BE%E9%A1%B9%E7%9B%AE/" class="post-title-link" itemprop="url">毕设项目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-08 00:57:15" itemprop="dateCreated datePublished" datetime="2024-04-08T00:57:15+08:00">2024-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-02 19:24:47" itemprop="dateModified" datetime="2024-07-02T19:24:47+08:00">2024-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h2 id="一、项目介绍"><a href="#一、项目介绍" class="headerlink" title="一、项目介绍"></a>一、项目介绍</h2><p>名称：<strong>多用户智能家居控制系统设计</strong>。</p>
<p><strong>设计了一个多用户智能家居控制系统。基于Qt平台开发Android客户端，同时基于MySQL数据库及多线程编程技术完成多用户操作，并利用MQTT通信协议实现了Android客户端与嵌入式控制终端之间的信息交互。、在此系统下Android 客户端的不同用户，可以通过Mosquitto云服务器转发的控制信息实现对iTop4412开发板的照明、警报及温度设备的实时控制。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404142132653.png" alt="image-20240414213213414"></p>
<p>1、 基于Linux多线程编程，结合MQTT协议的订阅-发布模式，完成多用户智能控制；</p>
<p>2、 在用户端设计双模式。共享模式：多个用户同时控制，且共享当前设备的状态；私人模式：被控制端的某一功能同一时间只能由一个用户控制；</p>
<p>3、 采用MQTT协议进行数据传送。通过实验对比HTTP协议和MQTT协议在智能家居领域的应用，结果表明MQTT在降低功耗和推送功能开发上优势明显，其即便是在资源有限的环境中也能易于使用。</p>
<p><strong>本项目的重点与核心在实现客户端的多用户控制。</strong></p>
<p>1、 针对发布者，利用Qt开发平台设计手机App作为客户端，它有两个特点，分别是多用户和双模式。多用户指不同的客户端均可进行控制操作；双模式指针对客户端本身，有共享模式和私人模式两种，在共享模式下可实现多个用户同时控制，且共享当前设备的状态；在私人模式下被控制端的某一功能同一时间只能由一个用户控制；</p>
<p>2、 针对消息代理者，选择在阿里云上部署mosquitto。选用MQTT协议的原因已在前述加以说明，而由于mosquitto是一种流行的mqtt服务器，且易于安装和配置，因此选用mosquitto进行部署；</p>
<p>3、 针对订阅者，主要以iTop4412开发板作为功能实现端。同时基于Linux多线程来配合实现多用户控制。</p>
<p><strong>本项目的数据转发过程如下。</strong></p>
<p>每个用户在该客户端程序中都对应操作两个线程：</p>
<p>（1）发送控制指令时的发布者身份，代表用户从Android客户端向嵌入式控制终端发送照明及警报的控制指令；<br>用户可自主规定订阅主题为“home&#x2F;*”格式。</p>
<p>（2）接收控制指令时的订阅者身份，代表开发板向用户发送温度数据；统一规定“temp”为传送温度数据的主题。</p>
<p><strong>发布者发出的控制指令将以json数据的格式被封装，经mosquitto云服务器转发后送至开发板侧，订阅者读取json包，解析出对应的命令行指令，对相应的硬件进行控制。</strong></p>
<h2 id="二、相关问题"><a href="#二、相关问题" class="headerlink" title="二、相关问题"></a>二、相关问题</h2><ol>
<li><p><strong>在项目中做了哪些工作，遇到了哪些困难，是怎么解决的？</strong></p>
<ul>
<li>工作：设计并实现了一个多用户智能家居控制系统，包括Android客户端、服务器软件和嵌入式控制终端。</li>
<li>困难：处理多用户操作的并发控制，确保数据一致性和系统稳定性。</li>
<li>解决方法：利用多线程编程技术和锁机制，以及基于MQTT的消息订阅和发布来处理并发控制问题。</li>
</ul>
</li>
<li><p><strong>整个项目包含哪几端之间的的通信？</strong></p>
<p>项目包含（1）Android客户端与服务器的通信；（2）服务器与嵌入式控制终端的通信；以及（3）客户端之间的间接通信（通过服务器转发）。</p>
</li>
<li><p><strong>客户端与客户端之间的通信是基于自己实现的协议吗？</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404142133602.png" alt="image-20240414213314541"></p>
</li>
<li><p><strong>是在客户端上面跑的MySQL吗？</strong></p>
<p>不是，MySQL数据库运行在服务器端，用于存储用户数据和状态信息，客户端通过网络与之通信。</p>
</li>
<li><p><strong>Qt可以直接打包安卓客户端吗？</strong>、</p>
<p>是的，Qt提供了支持Android的工具和库，可以直接将应用打包为Android客户端。</p>
</li>
<li><p><strong>Qt中做多线程的编程，有哪一些是线程同步的技术？</strong></p>
<p>Qt支持多种线程同步技术，包括互斥锁（QMutex）、读写锁（QReadWriteLock）、信号量（QSemaphore）、条件变量（QWaitCondition）等。</p>
</li>
<li><p><strong>为什么用多线程能解决冲突问题？</strong></p>
<p>程序通过 <code>pthread_create</code> 函数创建了两个线程，多线程主要用于处理订阅和发布MQTT消息的任务。</p>
<ol>
<li><code>sub_thread</code> 用于订阅 MQTT 消息并处理接收到的消息，涉及到订阅者之间的状态共享或者资源竞争，因此使用互斥锁来保护共享资源的访问，确保线程安全。</li>
<li><code>pub_thread</code> 用于发布 MQTT 消息。操作和<code>sub_thread</code>类似，但不需要对其进行加锁操作。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404142139031.png" alt="image-20240414213944988"></p>
</li>
<li><p><strong>锁是放在哪里的？</strong></p>
<p>互斥锁放在嵌入式控制终端中。</p>
</li>
<li><p><strong>比如说你有多个客户端，你怎么知道对面锁住了呢？</strong></p>
<p>客户端设计了共享模式和私人模式两种，当一个用户选择进入私人模式时，会通过Qt的信号与槽机制在客户端进行更新，告诉其他用户已经有用户进入了私人模式，本客户端无法再进入。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404142136791.png" alt="image-20240414213614733"></p>
</li>
<li><p><strong>在做技术选型的时候，什么时候选多线程，什么时候选多进程？</strong></p>
<ul>
<li><strong>选择多线程</strong>：当应用需要共享大量数据时，多线程是一种更合适的选择。多线程同一进程内的线程共享内存和资源，上下文切换成本较低，适用于对性能要求较高的场景，如实时计算、游戏开发等。</li>
<li><strong>选择多进程</strong>：多进程则适用于需要增强应用稳定性和安全性的场景，因为各进程间相互独立，一个进程的崩溃不会直接影响到其他进程。此外，多进程可以利用多核CPU的优势，实现真正的并行执行，适用于需要大量并行计算的应用，如视频处理、大规模数据分析等。</li>
</ul>
</li>
<li><p><strong>在Android客户端中，如何实现界面的实时更新和数据同步？</strong></p>
<ul>
<li>使用信号与槽机制： 在Qt中，通过信号与槽机制实现对象之间的通信。当数据发生变化时，可以通过信号发送变化的消息，然后在界面组件中连接相应的槽函数来更新界面。</li>
</ul>
</li>
<li><p><strong>如何通过mosquitto服务器将客户端的控制指令转发给iTop4412开发板？</strong></p>
<ul>
<li>在mosquitto服务器上配置相应的主题和订阅关系，客户端发布控制指令到对应的主题，mosquitto服务器将控制指令转发给iTop4412开发板的订阅者。</li>
</ul>
</li>
<li><p><strong>MQTT协议与HTTP协议相比，有何优势？为什么选择MQTT协议进行数据传送？</strong></p>
<ul>
<li>MQTT协议相比HTTP协议在降低功耗和推送功能开发上具有明显优势，适合于资源有限的环境和实时数据传输的场景。因此选择MQTT协议进行数据传送。</li>
</ul>
</li>
<li><p><strong>介绍一下阿里云上部署mosquitto的过程。</strong></p>
<ul>
<li><p>在阿里云上安装mosquitto，配置mosquitto的配置文件，设置端口号和用户名密码等参数，启动mosquitto服务，配置防火墙规则允许外部访问。</p>
</li>
<li><p>MQTT服务器的端口号通常是1883。</p>
</li>
</ul>
</li>
<li><p><strong>如何在iTop4412开发板上实现对控制指令的接收和执行？</strong></p>
<ul>
<li>通过Linux多线程编程，在iTop4412开发板上创建一个线程来监听MQTT服务器发送的控制指令，接收到指令后解析并执行对应的命令。</li>
</ul>
</li>
<li><p><strong>在Android客户端中，如何使用JSON格式封装控制指令？</strong></p>
<ul>
<li>使用 <code>cJSON_CreateObject()</code> 函数创建一个空的JSON对象。</li>
<li>使用 <code>cJSON_AddNumberToObject()</code> 函数向JSON对象中添加一个键值对，键为 “temp”，值为一个随机生成的温度值 <code>a</code>。</li>
<li>使用 <code>cJSON_Print()</code> 函数将JSON对象打印成JSON格式的字符串，并将其赋值给 <code>json_buf</code>。</li>
<li>使用 <code>mosquitto_publish()</code> 函数将JSON字符串发布到MQTT服务器上的主题为 “temp” 的通道中。</li>
</ul>
</li>
<li><p><strong>在iTop4412开发板上，如何解析JSON格式的控制指令并执行相应的功能操作？</strong></p>
<ul>
<li>使用第三方JSON库cJSON在Linux环境下解析JSON格式的控制指令，提取出对应的命令参数，然后调用相应的系统调用或执行命令行来控制硬件设备。</li>
</ul>
</li>
<li><p><strong>在多用户智能家居控制系统中，如何实现用户认证和权限管理？</strong></p>
<ul>
<li>在安卓客户端上实现用户登录和注册功能。将用户信息存储在MySQL数据库上，在登陆查询当前用户是否属于该数据库，以及用户名与密码是否匹配；若不存在，可进行注册操作。</li>
<li>由于本设计要访问特定公网的阿里云服务器上的数据库，因此在Qt开发平台上需要首先提供所需要的驱动插件之后，再利用QSqlDatabase来处理与数据库的连接，利用QSqlQuery类来执行底层数据库支持的任何SQL语句。</li>
</ul>
</li>
<li><p><strong>在iTop4412开发板上，如何实现硬件设备的驱动和控制？</strong></p>
<ul>
<li>通过 MQTT 实现硬件设备的驱动和控制：<ul>
<li>当用户在 UI 上进行操作时，比如点击 LED 开关按钮，UI 触发对应的槽函数，如 <code>on_ledBt_ON_1_clicked()</code>。</li>
<li>在槽函数中构造一个JSON 数据包，其中包含了需要控制的硬件设备信息，比如 LED 的状态。然后将这个 JSON 数据包发布到 MQTT 主题上，通过 MQTT 协议发送给 MQTT 服务器。</li>
<li>在硬件设备端，通过订阅相应的 MQTT 主题，监听来自 MQTT 服务器的消息。</li>
<li>当硬件设备端接收到相应的消息后，解析 JSON 数据包，获取到控制指令，并执行相应的操作，例如打开或关闭 LED。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>该项目还有哪些可以改进的地方？</strong></p>
<ul>
<li><p>可以在mosquitto服务器上配置TLS&#x2F;SSL加密通信，客户端和服务器之间通过证书验证进行安全连接，防止数据被窃取或篡改。确保安卓客户端与mosquitto服务器之间的通信安全性。</p>
</li>
<li><p>此外，对于多线程部分我觉得还可以再考虑细化锁的粒度，以及进行RAII技术管理互斥锁，避免在某些异常情况下未释放锁导致资源泄露问题。</p>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="midorii"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">midorii</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">midorii</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">287k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:25</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
