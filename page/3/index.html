<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch_cat_logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/site_cat-32%C3%9732.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/site_cat-16%C3%9716.png">
  <link rel="mask-icon" href="/images/cat_logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="MIDORII&#39;S JOURNEY">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="MIDORII&#39;S JOURNEY">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="midorii">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>MIDORII'S JOURNEY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MIDORII'S JOURNEY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">a little bit sweet</p>
      <a>
        <img class="custom-logo-image" src="/images/cat.jpeg" alt="MIDORII'S JOURNEY">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/07/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/C&C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/C&C++/" class="post-title-link" itemprop="url">C/C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 15:02:11" itemprop="dateCreated datePublished" datetime="2024-04-07T15:02:11+08:00">2024-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-12 09:44:40" itemprop="dateModified" datetime="2024-07-12T09:44:40+08:00">2024-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>32k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:55</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h2 id="一、C-C"><a href="#一、C-C" class="headerlink" title="一、C&#x2F;C++"></a>一、C&#x2F;C++</h2><h3 id="1、在main执行之前和之后执行的代码可能是什么？"><a href="#1、在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="1、在main执行之前和之后执行的代码可能是什么？"></a>1、在main执行之前和之后执行的代码可能是什么？</h3><p><strong>main 函数执行之前</strong>，主要就是初始化系统相关资源：</p>
<ul>
<li>设置栈指针；</li>
<li>初始化静态变量和全局变量，即 .data 段的内容；</li>
<li>将未初始化部分的全局变量赋初值，即 .bss 段的内容；</li>
<li>全局对象初始化，在 main 之前调用构造函数；</li>
<li>将 main 函数的参数 argc，argv 等传递给 main 函数，然后才真正运行 main 函数</li>
<li><code>__attribute__((constructor))</code></li>
</ul>
<p><strong>main 函数执行之后</strong>：</p>
<ul>
<li>调用全局对象的析构函数；</li>
<li>可以用 atexit 注册一个函数，它会在 main 之后执行;</li>
<li><code>__attribute__((destructor))</code></li>
</ul>
<h3 id="2、如何看待-C-和-C-的关系？"><a href="#2、如何看待-C-和-C-的关系？" class="headerlink" title="2、如何看待 C++ 和 C 的关系？"></a>2、如何看待 C++ 和 C 的关系？</h3><p>C++ 最初只是在 C 的基础上增加了面向对象的特性，后来随着 C++ 的发展，其灵活性不断增加，现在 C++ 已经成为了一个语言联邦，他包含了 C 语言，但也延伸出许多其他特性。</p>
<ul>
<li>面向对象：C++ 包含封装、继承、多态的特性；</li>
<li>C++ 支持泛型编程；</li>
<li>C++ 包含了STL部分。</li>
</ul>
<h3 id="3、结构体和联合体"><a href="#3、结构体和联合体" class="headerlink" title="3、结构体和联合体"></a>3、结构体和联合体</h3><ol>
<li><p>结构体(Struct)</p>
<ol>
<li><strong>存储</strong>：结构体可以包含多个不同类型的数据成员，每个成员各自独立拥有内存空间。</li>
<li><strong>内存占用</strong>：结构体的总大小至少等于所有成员大小的总和(还需要考虑对齐)。</li>
<li><strong>用途</strong>：常用于存储具有逻辑关系但数据类型不同的数据集合。</li>
<li><strong>访问</strong>：每个成员都可以同时被独立访问，并且对一个成员的修改不会影响到其他成员。</li>
</ol>
</li>
<li><p>联合体(Union)</p>
<ol>
<li><strong>存储</strong>：联合体的所有成员共享同一块内存区域。</li>
<li><strong>内存占用</strong>：联合体的大小等于其最大成员的大小。</li>
<li><strong>用途</strong>：常用于节省空间，或用于实现对同一内存区域的不同解释(例如，可以存储一个整数和一个浮点数，但只能使用其中一个值)。</li>
<li><strong>访问</strong>：对联合体中的一个成员赋值可能会影响到其他成员的值(因为内存共享)。</li>
</ol>
</li>
</ol>
<h3 id="4、平时用哪个版本的-C-？为什么用-C-11，说一下"><a href="#4、平时用哪个版本的-C-？为什么用-C-11，说一下" class="headerlink" title="4、平时用哪个版本的 C++？为什么用 C++11，说一下"></a>4、平时用哪个版本的 C++？为什么用 C++11，说一下</h3><p>  （从三个方面答，线程支持，泛化编程，简化使用）</p>
<h3 id="【-】5、面向对象设计的主要的原则"><a href="#【-】5、面向对象设计的主要的原则" class="headerlink" title="【*】5、面向对象设计的主要的原则"></a>【*】5、面向对象设计的主要的原则</h3><ol>
<li><p>**依赖倒置原则(DIP)**：⾼层模块(稳定)不应该依赖于底层模式(变化)，⼆者都应该依赖于抽象。抽象(稳定)不应该依赖于实现细节(变化)，实现细节应该依赖于抽象(稳定)。(所说的依赖都是编译时依赖。A 依赖 B，意味着 A 编译的时候 B 需要存在 A 才能编译通过)</p>
</li>
<li><p>**开放封闭原则(OCP)**：对扩展开放，对更改封闭。(尽可能地去扩展，而不要修改)类模块应该是可扩展的，但是不可修改。</p>
</li>
<li><p><strong>单⼀职责原则</strong>：⼀个类应该仅有⼀个引起它变化的原因，变化的方向隐含着类的责任。</p>
</li>
<li><p><strong>Liskov 替换原则</strong>：子类必须能够替换他们的基类(is-a)。</p>
</li>
<li><p><strong>接口隔离原则</strong>：不应该强迫客户依赖它们不用的方法。接口应该小而完备。</p>
</li>
<li><p><strong>优先使用对象组合，而不是使用类继承</strong>：类继承通常为白箱复用，对象组合通常为黑箱复用。继承在某种程度上破坏了封装性，子类父类的耦合度⾼。而对象组合则只要求被组合的对象具有良好的外部接口，耦合度相对更低。</p>
</li>
<li><p><strong>封装变化点</strong>：使用封装来创建对象之间的分界层，让设计者在⼀侧进行修改，而不会对另⼀侧产生不良的影响，从而实现层次的直接耦合。</p>
</li>
<li><p><strong>针对接口编程，而不是针对实现编程</strong>：不将变量类型声明为某个特定的具体类，而是声明为某个接口。客户无需获知对象的具体类型，而是只需要知道对象所具有的接口。</p>
</li>
</ol>
<h3 id="【-】6、面向对象的三大特性，并举例说明"><a href="#【-】6、面向对象的三大特性，并举例说明" class="headerlink" title="【*】6、面向对象的三大特性，并举例说明"></a>【*】6、面向对象的三大特性，并举例说明</h3><p>C++ 面向对象的三大特性是：封装、继承、多态。</p>
<ol>
<li><p><strong>所谓封装</strong>是指把客观事物封装成抽象的类，类中的数据和方法只能被信任的类或者对象操作，对不可信的则进行隐藏。</p>
</li>
<li><p><strong>所谓继承</strong>是指让某个类型的对象获得另⼀个类型的对象的属性的方法。继承后可以使用现有类的所有功能，并在无需重新编写原来类的情况下对这些功能进行扩展。</p>
</li>
<li><p><strong>所谓多态</strong>是指⼀个接口可以实现多种方法。多态与非多态的实质区别就是函数地址是静态绑定还是动态绑定。如果在编译期间就可以确定函数的调用地址并产生代码，则是静态的；而需要在运行时才能确定，则是动态的。</p>
</li>
</ol>
<h2 id="二、智能指针相关"><a href="#二、智能指针相关" class="headerlink" title="二、智能指针相关"></a>二、智能指针相关</h2><h3 id="7、野指针是什么？"><a href="#7、野指针是什么？" class="headerlink" title="7、野指针是什么？"></a>7、野指针是什么？</h3><p>野指针是指向未知内存位置的指针。野指针的出现通常是由于以下几种情况：</p>
<ol>
<li><strong>未初始化的指针</strong>：声明指针变量但未给其赋予一个明确的初始地址。</li>
<li><strong>已释放的内存</strong>：指针指向的内存通过<code>free</code>或<code>delete</code>被释放，但指针没有被置为<code>NULL</code>，之后再次使用这个指针时，它指向的是已经回收的内存。</li>
<li><strong>越界的指针</strong>：指针超出了其原本指向的数据结构的边界。</li>
</ol>
<h3 id="8、讲一下什么是智能指针？"><a href="#8、讲一下什么是智能指针？" class="headerlink" title="8、讲一下什么是智能指针？"></a>8、讲一下什么是智能指针？</h3><p>智能指针是对裸指针的封装，其实质上是一个类，在离开类的作用范围后会自动调用析构函数释放资源，因此避免了程序员手动操作时忘记释放资源导致的内存泄漏问题。</p>
<p>智能指针包含4类：</p>
<p>(1)<strong>auto_ptr</strong>：在 C++11 中已经被废弃使用。它提供独占所有权，但没有复制语义，存在潜在的危险，例如当它被复制后原始指针可能被意外释放。</p>
<p>(2)<strong>unique_ptr</strong>：实现了对资源的独占访问，同一时刻只能有一个指针对资源进行访问。<strong>大小通常为一个指针的大小(在大多数系统上为8字节)。</strong></p>
<p>(3)<strong>shared_ptr</strong>：当有多个对象需要共享资源时，则使用 shared_ptr。其内部维护了一个引用计数器，当引用计数减少为0时调用delete释放资源。<strong>大小通常是两个指针的大小(在大多数系统上为16字节)。</strong></p>
<p>当存在下列情况时会使得引用计数增加：</p>
<p>​		1)新建一个 shared_ptr 指向对象；2)拷贝构造函数复制一个 shared_ptr；3)复制操作将一个 shared_ptr 复制给另一个 shared_ptr。</p>
<p>当存在下列操作时会使得引用计数减少：</p>
<p>​		1)当一个 shared_ptr 被销毁时，如离开作用域，或调用了析构函数；2)当一个 shared_ptr 不再指向某个资源，如调用reset方法。</p>
<p>(4)<strong>weak_ptr</strong>：指向一个 shared_ptr 对象，并不会增加其引用计数，而只是提供一种访问方式。可以解决 shared_ptr 中存在的循环引用问题。<strong>大小通常是两个指针的大小(在大多数系统上为16字节)。</strong></p>
<h3 id="9、weak-ptr-如何获得-shared-ptr？"><a href="#9、weak-ptr-如何获得-shared-ptr？" class="headerlink" title="9、weak_ptr 如何获得 shared_ptr？"></a>9、weak_ptr 如何获得 shared_ptr？</h3><p>使用 <code>std::weak_ptr</code> 的成员函数 <code>lock()</code> 来从 <code>weak_ptr</code> 中创建一个 <code>shared_ptr</code> 实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">  std::weak_ptr&lt;<span class="type">int</span>&gt; wp = sp;</span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; sp2 = wp.<span class="built_in">lock</span>();</span><br><span class="line">  </span><br><span class="line">  sp.<span class="built_in">reset</span>();</span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; sp3 = wp.<span class="built_in">lock</span>();  <span class="comment">// sp3仍有效</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10、循环引用是如何发生的？如何解决？"><a href="#10、循环引用是如何发生的？如何解决？" class="headerlink" title="10、循环引用是如何发生的？如何解决？"></a>10、循环引用是如何发生的？如何解决？</h3><p>当多个 shared_ptr 对象互相引用，或是在某些比较复杂的数据结构中存在多条引用路径时，可能存在循环引用问题，导致资源无法被释放。此时就可以使用 weak_ptr 来打破循环，因为 weak_ptr 不会增加引用计数。</p>
<p>具体来说，shared_ptr 内部包含 _shared_count 对象，其内部包含两个计数器，分别是 use_count 和 weak_count，use_count 主要用来标记被管理对象的生命周期，weak_count 主要用来标记管理对象的生命周期。当执行相关操作时这两个 count 的值都会对应变化。而weak_ptr 内部包含的 _weak_count 对象也管理同样的两个计数器，但是 weak_ptr 相关的赋值拷贝以及析构函数均只会影响到weak_count 的值，对 use_count 没有影响，因此 weak_ptr 不影响被管理对象的生命周期。</p>
<h3 id="11、shared-ptr-是线程安全的吗？多线程使用时需要注意什么问题？"><a href="#11、shared-ptr-是线程安全的吗？多线程使用时需要注意什么问题？" class="headerlink" title="11、shared_ptr 是线程安全的吗？多线程使用时需要注意什么问题？"></a>11、shared_ptr 是线程安全的吗？多线程使用时需要注意什么问题？</h3><p><code>shared_ptr</code>的引用计数是线程安全的，即引用计数的增加和减少操作是原子操作，保证了多个线程能够安全地共享同一个<code>shared_ptr</code>对象。但是，<code>shared_ptr</code>本身并不对其所管理的对象提供线程安全性。如果多个线程需要同时访问或修改共享对象，用户需要自己管理对象的同步(例如使用<code>mutex</code>)。</p>
<h3 id="12、引用计数的线程安全性怎么实现的？"><a href="#12、引用计数的线程安全性怎么实现的？" class="headerlink" title="12、引用计数的线程安全性怎么实现的？"></a>12、引用计数的线程安全性怎么实现的？</h3><p>引用计数的线程安全性通过原子操作实现。原子操作是不可分割的，这意味着在任意时刻只有一个线程能够修改引用计数。</p>
<p><strong>对于增加引用计数来说，只需要简单的原子递增操作</strong>。因为其本质上是一种写操作，只需要确保引用计数值的一致性，而不涉及对共享对象的状态读取或修改，不需要立刻在多个线程之间可见。</p>
<p><strong>对于减少引用计数来说，则需要利用到内存同步事件和内存屏障，来结合原子操作减少引用计数。</strong>因为当引用计数减少到<code>0</code>时，需要执行资源释放操作，涉及到对共享对象状态的修改和删除，因此需要保证内存的正确同步和可见性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加引用计数</span></span><br><span class="line"><span class="type">void</span> _M_add_ref_copy() &#123;</span><br><span class="line">    <span class="comment">// 原子操作</span></span><br><span class="line">    __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count， <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减少引用计数</span></span><br><span class="line"><span class="type">void</span> _M_release() &#123;</span><br><span class="line">    <span class="comment">// 内存同步事件，与数据竞赛检测工具(如ThreadSanitizer)协同工作，确保内存操作的可见性</span></span><br><span class="line">    _GLIBXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子操作，减少引用计数，并检查是否是最后一个引用</span></span><br><span class="line">    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count， <span class="number">-1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 另一个内存同步事件，通知数据竞赛检测工具此时的引用计数减少操作已经完成</span></span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);</span><br><span class="line">        _M_dispose();  <span class="comment">// 释放对象资源</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保在 _M_dispose() 和 _M_destroy() 之间有一个内存屏障，</span></span><br><span class="line">        <span class="comment">// 以确保所有 _M_dispose() 的效果对调用 _M_destroy() 的线程可见</span></span><br><span class="line">        <span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barries) &#123;</span><br><span class="line">            __atomic_thread_fence (__ATOMIC_ACQ_REL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减少弱引用计数，并检查是否是最后一个弱引用</span></span><br><span class="line">        <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count， <span class="number">-1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 另一个内存同步事件，通知数据竞赛检测工具此时的弱引用计数减少操作已经完成</span></span><br><span class="line">            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">            _M_destroy();  <span class="comment">// 释放控制块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13、引用计数是普通成员变量还是指针变量？"><a href="#13、引用计数是普通成员变量还是指针变量？" class="headerlink" title="13、引用计数是普通成员变量还是指针变量？"></a>13、引用计数是普通成员变量还是指针变量？</h3><p>引用计数是普通成员变量，用于跟踪当前有多少个指针共享了同一个对象。</p>
<h3 id="14、如果有一个场景需要用到线程安全的-shared-ptr-，一般你会怎么做？"><a href="#14、如果有一个场景需要用到线程安全的-shared-ptr-，一般你会怎么做？" class="headerlink" title="14、如果有一个场景需要用到线程安全的 shared_ptr ，一般你会怎么做？"></a>14、如果有一个场景需要用到线程安全的 shared_ptr ，一般你会怎么做？</h3><p>通常会使用 std::atomic 或者 std::mutex 来保护对 shared_ptr 的访问。</p>
<h3 id="15、以传引用的形式传递-shared-ptr-有什么问题？"><a href="#15、以传引用的形式传递-shared-ptr-有什么问题？" class="headerlink" title="15、以传引用的形式传递 shared_ptr 有什么问题？"></a>15、以传引用的形式传递 shared_ptr 有什么问题？</h3><p>以传引用的形式传递 <code>shared_ptr</code> 不会增加对象的引用计数，因为传递的是对 <code>shared_ptr</code> 对象本身的引用，而不是对它所管理的资源的引用。</p>
<p>由于以传引用的形式传递 <code>shared_ptr</code> 不会增加对象的引用计数，所以可能会导致以下问题：</p>
<ol>
<li><p>若函数内部存储或复制了这个引用，而在函数外部，原 <code>shared_ptr</code>已经被销毁，那么这个存储的引用将成为悬空引用，导致未定义的行为。</p>
</li>
<li><p>函数调用者可能会期望传递的 <code>shared_ptr</code> 对象因函数调用而共享其所有权，但实际上却没有发生。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt;&amp; ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数内部持有ptr引用</span></span><br><span class="line">&#125;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; sp = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">func</span>(sp);</span><br><span class="line">sp.<span class="built_in">reset</span>(); <span class="comment">// 销毁原始的shared_ptr</span></span><br><span class="line"><span class="comment">// 此时func中的ptr引用已经无效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------- </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt;&amp; ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数内部没有增加引用计数</span></span><br><span class="line">    <span class="comment">// 因为传递的是引用</span></span><br><span class="line">&#125;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; sp = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">func</span>(sp);</span><br><span class="line"><span class="comment">// 调用者可能期望func内部增加引用计数，但实际上没有</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<ul>
<li><strong>按值传递</strong>：当按值传递一个对象时，传递的是对象的一个副本。对于 <code>shared_ptr</code> 来说，按值传递会创建一个新的 <code>shared_ptr</code> 实例，这个实例管理同一个资源，并且引用计数增加。</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt; ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传递的是一个新的shared_ptr副本，引用计数增加</span></span><br><span class="line">&#125;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; sp = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">func</span>(sp);  <span class="comment">// sp 的引用计数增加</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>按引用传递</strong>：按引用传递时，传递的是对 <code>shared_ptr</code> 对象本身的引用，而不是它管理的资源。因此，不会创建新的 <code>shared_ptr</code> 实例，也不会增加引用计数。</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt;&amp; ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传递的是shared_ptr的引用，引用计数不变</span></span><br><span class="line">&#125;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; sp = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">func</span>(sp);  <span class="comment">// sp 的引用计数不变</span></span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="16、通过-make-shared-构造，与先-new-再用裸指针构造-shared-ptr-相比有什么好处？"><a href="#16、通过-make-shared-构造，与先-new-再用裸指针构造-shared-ptr-相比有什么好处？" class="headerlink" title="16、通过 make_shared 构造，与先 new 再用裸指针构造 shared_ptr 相比有什么好处？"></a>16、通过 make_shared 构造，与先 new 再用裸指针构造 shared_ptr 相比有什么好处？</h3><p>使用<code>make_shared</code>构造<code>shared_ptr</code>有以下几个好处：</p>
<ul>
<li><strong>性能优化</strong>：<code>make_shared</code> 在单一的内存分配中同时分配了对象和控制块，减少了内存分配的次数；而先 <code>new</code> 再用裸指针构造 <code>shared_ptr</code> 会进行两次内存分配，一次给对象，一次给控制块。</li>
<li><strong>安全性</strong>：如果在 <code>shared_ptr </code>构造过程中抛出异常，使用裸指针的方式可能导致内存泄漏；而 <code>make_shared</code> 会确保所有资源都被正确管理。</li>
<li><strong>代码简洁</strong>：<code>make_shared</code>使代码更简洁，更易读。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// make_shared</span></span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; sp1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;value = &quot;</span> &lt;&lt; *sp1 &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;use count = &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 先new再构造</span></span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;value = &quot;</span> &lt;&lt; *sp2 &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;use count = &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17、如果构造函数传入同一裸指针构造两个-shared-ptr-对象，会发生什么现象？"><a href="#17、如果构造函数传入同一裸指针构造两个-shared-ptr-对象，会发生什么现象？" class="headerlink" title="17、如果构造函数传入同一裸指针构造两个 shared_ptr 对象，会发生什么现象？"></a>17、如果构造函数传入同一裸指针构造两个 shared_ptr 对象，会发生什么现象？</h3><p>虽然 <code>sp1</code> 和 <code>sp2</code> 都指向同一个 <code>int</code> 对象，但是它们在构造时并不知道彼此存在，因此各自的引用计数是独立计算的。当程序结束时，会首先销毁 <code>sp2</code>，此时引用计数减少为 <code>0</code>，释放原裸指针。接着，当销毁 <code>sp1</code> 时，由于引用计数已经为 <code>0</code>，再次尝试释放原裸指针，导致错误发生。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *p1 = &amp;x;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="comment">// 若sp2要和sp1共享引用计数，应写成如下方式：</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line">    <span class="comment">// 或</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sp2 = sp1;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value = &quot;</span> &lt;&lt; *sp1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count = &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value = &quot;</span> &lt;&lt; *sp2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count = &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value = 1</span><br><span class="line">use count = 1</span><br><span class="line">value = 1</span><br><span class="line">use count = 1</span><br><span class="line">munmap_chunk(): invalid pointer</span><br></pre></td></tr></table></figure>

<h3 id="18、还是上面的问题，你觉得对于所谓的智能指针，为什么会出现这样的现象？"><a href="#18、还是上面的问题，你觉得对于所谓的智能指针，为什么会出现这样的现象？" class="headerlink" title="18、还是上面的问题，你觉得对于所谓的智能指针，为什么会出现这样的现象？"></a>18、还是上面的问题，你觉得对于所谓的智能指针，为什么会出现这样的现象？</h3><p>这是因为在构造时 <code>shared_ptr</code> 并不会检查裸指针是否已经由其他 <code>shared_ptr</code> 对象管理。因此，当 <code>sp1</code> 和 <code>sp2</code> 分别使用相同的裸指针构造时，它们实际上管理的是同一块内存，但彼此相互独立。因此若一方先被销毁，另一方不知道，再尝试管理这片内存时就会造成未定义的行为。</p>
<p>只有用一个 <code>shared_ptr</code> 对象来初始化另一个 <code>shared_ptr</code> 对象时，二者才能共享引用计数。</p>
<h3 id="19、很多人说到-weak-ptr-就会说是为了解决循环引用，你觉得这是关键的因素吗？"><a href="#19、很多人说到-weak-ptr-就会说是为了解决循环引用，你觉得这是关键的因素吗？" class="headerlink" title="19、很多人说到 weak_ptr 就会说是为了解决循环引用，你觉得这是关键的因素吗？"></a>19、很多人说到 weak_ptr 就会说是为了解决循环引用，你觉得这是关键的因素吗？</h3><p><code>std::weak_ptr</code> 的主要作用是提供一种非拥有性的智能指针，用于解决共享指针的循环引用问题，避免内存泄漏和资源泄露。它不会增加对象的引用计数，也不会影响对象的生命周期，因此适用于表示临时性的对象引用或者避免循环引用的情况。</p>
<p>除了解决循环引用之外，<code>std::weak_ptr</code> 还具有其他用途，例如：</p>
<ol>
<li><strong>观察者模式(Observer Pattern)：</strong> <code>std::weak_ptr</code> 可用于实现观察者模式，其中观察者持有被观察者对象的弱引用，以避免循环引用和对象生命周期管理的问题。</li>
<li><strong>缓存：</strong> 在缓存系统中，可以使用 <code>std::weak_ptr</code> 来保存对象的缓存项，以避免对对象的强引用导致缓存项无法被释放。</li>
<li><strong>延迟初始化：</strong> <code>std::weak_ptr</code> 可用于实现延迟初始化(Lazy Initialization)，只有在需要时才创建对象，以提高性能和资源利用率。</li>
</ol>
<h3 id="20、如果传给-shared-ptr-一个引用，那么引用计数会不会加-1？"><a href="#20、如果传给-shared-ptr-一个引用，那么引用计数会不会加-1？" class="headerlink" title="20、如果传给 shared_ptr 一个引用，那么引用计数会不会加 1？"></a>20、如果传给 shared_ptr 一个引用，那么引用计数会不会加 1？</h3><p>只有在<code>std::shared_ptr</code>发生<strong>值传递</strong>时，计数才会增加，而在<strong>传递引用( <code>&amp;</code> )类型</strong>的 <code>shared_ptr</code> 的时，计数不会增加。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printUseCount</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;<span class="type">int</span>&gt;&amp; sp， <span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; use_count: &quot;</span> &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传copy</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">passByVal</span><span class="params">(std::shared_ptr&lt;<span class="type">int</span>&gt; sp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printUseCount</span>(sp， <span class="string">&quot;sp (pass by value)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">passByRef</span><span class="params">(std::shared_ptr&lt;<span class="type">int</span>&gt;&amp; sp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printUseCount</span>(sp， <span class="string">&quot;sp (pass by reference)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="built_in">printUseCount</span>(sp1， <span class="string">&quot;sp1 (initial)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">passByVal</span>(sp1);</span><br><span class="line">    <span class="built_in">printUseCount</span>(sp1， <span class="string">&quot;sp1 (after passByValue)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">passByRef</span>(sp1);</span><br><span class="line">    <span class="built_in">printUseCount</span>(sp1， <span class="string">&quot;sp1 (after passByReference)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sp1 (initial) use_count: 1</span><br><span class="line">sp (pass by value) use_count: 2</span><br><span class="line">sp1 (after passByValue) use_count: 1</span><br><span class="line">sp (pass by reference) use_count: 1</span><br><span class="line">sp1 (after passByReference) use_count: 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释<code>sp1 (after passByValue) use_count: 1</code>：</strong></p>
<p>在使用 <code>std::shared_ptr</code> 时，当一个函数以值传递(copy)的方式接收一个 <code>std::shared_ptr</code>，该函数内部会创建一个新的 <code>std::shared_ptr</code> 实例，并将引用计数增加。当函数返回时，局部的 <code>std::shared_ptr</code> 对象会被销毁，其引用计数会随之减少。</p>
</blockquote>
<h3 id="21、unique-ptr-主要为了解决什么问题？"><a href="#21、unique-ptr-主要为了解决什么问题？" class="headerlink" title="21、unique_ptr 主要为了解决什么问题？"></a>21、unique_ptr 主要为了解决什么问题？</h3><p><code>unique_ptr</code> 主要用于解决以下问题：</p>
<ul>
<li><strong>独占所有权</strong>：<code>unique_ptr</code> 保证一个指针在任一时刻只有一个拥有者，避免了多重删除( double delete )的问题。</li>
<li><strong>自动释放资源</strong>：当 <code>unique_ptr</code> 超出其作用域时，会自动释放其管理的资源，防止内存泄漏。</li>
<li><strong>移动语义</strong>：<code>unique_ptr</code> 可以移动而不是复制，这使得所有权可以安全地从一个对象转移到另一个对象。</li>
</ul>
<h3 id="22、unique-ptr-指向一个对象，普通指针可以指向那个对象吗？"><a href="#22、unique-ptr-指向一个对象，普通指针可以指向那个对象吗？" class="headerlink" title="22、unique_ptr 指向一个对象，普通指针可以指向那个对象吗？"></a>22、unique_ptr 指向一个对象，普通指针可以指向那个对象吗？</h3><p>是的，<code>unique_ptr</code>指向一个对象时，可以通过 <code>get()</code> 函数获取对应的裸指针来指向那个对象。但要注意这个普通指针不能改变或释放对象的内存，否则会破坏 <code>unique_ptr</code> 的内存管理。</p>
<p>这样做并没有破坏 <code>unique_ptr</code> 的独占性，理由是，<code>unique_ptr</code> 的独占所有权意味着它是唯一一个负责管理和释放该对象的智能指针。换句话说，没有其他 <code>unique_ptr</code> 或 <code>shared_ptr</code> 可以共享这个对象的所有权。</p>
<p>某些情况下需要这种用法，比如当需要暂时访问对象而不需要改变其生命周期时，就可以获取其对应的裸指针来实现，只是要注意应采用只读访问的方式，同时尽量短期使用，避免 <code>unique_ptr</code> 被销毁后裸指针成为悬空指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span>* raw_ptr = uptr.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *raw_ptr &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23、指针解引用性能"><a href="#23、指针解引用性能" class="headerlink" title="23、指针解引用性能"></a>23、指针解引用性能</h3><p>智能指针的解引用性能基本与原生指针相同，因为解引用操作只需访问内存地址。然而，智能指针在生命周期管理上有额外的开销。例如，<code>shared_ptr</code> 在每次构造、赋值和销毁时需要更新引用计数，这比 <code>unique_ptr</code> 和原生指针的开销要大。</p>
<h2 id="三、变量-关键字"><a href="#三、变量-关键字" class="headerlink" title="三、变量&#x2F;关键字"></a>三、变量&#x2F;关键字</h2><h3 id="24、string-的-size-类型为什么是-string-size-t-而不是-int？"><a href="#24、string-的-size-类型为什么是-string-size-t-而不是-int？" class="headerlink" title="24、string 的 size 类型为什么是 string::size_t 而不是 int？"></a>24、string 的 size 类型为什么是 string::size_t 而不是 int？</h3><p>原因如下：</p>
<ol>
<li><strong>能够表示更大的字符串：</strong> 无符号整数类型 <code>size_t</code> 可以容纳比 <code>int</code> 更大的值，这对于处理非常大的字符串是必要的。</li>
<li><strong>提高可移植性：</strong> 使用 <code>size_t</code> 可以确保代码在不同的平台上具有相同的行为，因为 <code>size_t</code> 的大小会根据平台而变化，而不是固定的。</li>
<li><strong>避免符号问题：</strong> <code>size_t</code> 是无符号类型，避免了符号整数的问题，如溢出等。</li>
</ol>
<h3 id="25、介绍一下-static-？"><a href="#25、介绍一下-static-？" class="headerlink" title="25、介绍一下 static ？"></a>25、介绍一下 static ？</h3><p><code>static</code>修改存储方式和可见范围。主要包含4类：</p>
<ul>
<li>静态成员变量：静态成员变量不属于类的任何一个对象，而只属于类本身，所有对象共享一个静态成员变量；</li>
<li>静态成员函数：静态成员函数同理；</li>
<li>静态局部变量：定义在函数内部，和普通局部变量不同，在函数整个运行期间只会初始化一次，即使函数被多次调用也是如此；</li>
<li>静态全局变量：静态全局变量在某个源文件中被定义后则只能在该源文件中被使用，而不能在其他文件中使用，有助于封装和避免命名冲突。</li>
</ul>
<h3 id="26、extern-关键字的作用？"><a href="#26、extern-关键字的作用？" class="headerlink" title="26、extern 关键字的作用？"></a>26、extern 关键字的作用？</h3><p><code>extern </code>关键字用于声明一个变量或函数，其定义可能在另一个文件或同一文件的不同位置。使用 <code>extern</code> 的主要目的是在多个文件之间共享变量或函数。</p>
<ol>
<li><strong>声明外部变量</strong>：<ul>
<li>当在多个源文件中使用同一个全局变量时，你可以在一个文件中不使用 <code>extern</code> 定义该变量，并在其他文件中使用 <code>extern</code> 关键字来声明它们。这告诉编译器变量在其他地方定义，避免了多重定义的错误。</li>
</ul>
</li>
<li><strong>声明外部函数</strong>：<ul>
<li>使用 <code>extern</code> 可以明确表示函数可以被其他文件调用。</li>
</ul>
</li>
<li><strong>链接不同编程语言</strong>：<ul>
<li>在 C++ 中，<code>extern &quot;C&quot; </code>用于告诉 C++ 编译器某个函数或变量应该以 C 语言的方式进行链接。</li>
</ul>
</li>
</ol>
<h3 id="27、extern-声明全局变量的内部实现是怎样的？"><a href="#27、extern-声明全局变量的内部实现是怎样的？" class="headerlink" title="27、extern 声明全局变量的内部实现是怎样的？"></a>27、extern 声明全局变量的内部实现是怎样的？</h3><p>被 extern 修饰的全局变量，在编译期不会分配空间，而是在链接的时候通过索引去别的文件中查找索引对应的地址。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404170950469.jpeg" alt="IMG_183F6F3B95EC-1"></p>
<h3 id="28、在-C-程序中调用被-C-编译器编译后的函数，为什么要加-extern-“C”？"><a href="#28、在-C-程序中调用被-C-编译器编译后的函数，为什么要加-extern-“C”？" class="headerlink" title="28、在 C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”？"></a>28、在 C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”？</h3><p><strong>目的是为了解决名字匹配问题，实现 C++ 与 C 的混合编程。</strong>由于 C++ 有<strong>重载</strong>的特性而 C 没有，因此函数被 C++ 编译后在符号库中的名字与 C 语言的不同。例如，假设某个函数的原型为：<code>void foo(int x，int y);</code>该函数被 C 编译器编译后在符号库中的名字为 <code>_foo</code>，而 C++ 编译器则会产生类似 <code>_foo_int_int</code> 之类的名字。 </p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404170951735.jpeg" alt="IMG_EC64DA9B254B-1"></p>
<h3 id="29、explicit-关键字用在什么情况下？"><a href="#29、explicit-关键字用在什么情况下？" class="headerlink" title="29、explicit 关键字用在什么情况下？"></a>29、explicit 关键字用在什么情况下？</h3><p>explicit 关键用于声明一个单参数的构造函数，阻止该构造函数隐式转换为该类的类型。</p>
<h3 id="30、inline-关键字遇到过吗？作用是什么？和-define-有什么区别？"><a href="#30、inline-关键字遇到过吗？作用是什么？和-define-有什么区别？" class="headerlink" title="30、inline 关键字遇到过吗？作用是什么？和 #define 有什么区别？"></a>30、inline 关键字遇到过吗？作用是什么？和 #define 有什么区别？</h3><p><code>inline</code> 关键字作为函数定义的关键字，说明该函数是内联函数。内联函数会将代码块嵌入到每个调用该函数的地方，减少了函数调用的开销，但增加了代码量。同时要注意 <code>inline</code> 只是对编译器的一个建议，真正能否内联还是要看编译器自己的判断。</p>
<p><code>C++17</code> 引入了内联变量，允许在头文件中定义全局变量，而不会导致重复定义错误。使用 <code>inline</code> 关键字修饰的变量可以在多个翻译单元中定义，但会被视为同一个变量。</p>
<p><strong>和 <code>#define</code> 的区别在于：</strong></p>
<ul>
<li>宏定义，在预处理阶段进行文本替换；而<code>inline</code> 函数在编译时进行替换，且由编译器自己决定是否需要内联；</li>
<li><code>inline</code> 有类型检查，相对于 <code>#define</code> 较安全；</li>
<li>宏定义在预处理阶段展开，可以在整个翻译单元内使用，这可能导致命名冲突和意外的宏展开；<code>inline</code> 函数有明确的作用域，只能在定义它们的命名空间或类的作用域内访问。</li>
</ul>
<h3 id="31、-define、const-和-constexpr-的区別和应用场景？"><a href="#31、-define、const-和-constexpr-的区別和应用场景？" class="headerlink" title="31、#define、const 和 constexpr 的区別和应用场景？"></a>31、#define、const 和 constexpr 的区別和应用场景？</h3><ol>
<li><code>#define</code> 是预处理指令，用于定义常量宏。它<strong>在预处理阶段将标识符替换为指定的文本</strong>。不包含类型检查。</li>
<li><code>const</code> 用于定义类型安全的常量，<strong>在编译时被创建，并且会占用内存，可以在运行时被初始化</strong>。在编译期间会检查程序是否对其进行了修改，避免意外修改；同时会对其进行类型检查，因此是安全的。</li>
<li><code>constexpr</code>用于声明常量表达式，在编译时被求值。因此<strong>适用于在编译时期就能确定初始值，并且在整个程序生命周期内都不会改变的常量</strong>。</li>
</ol>
<h3 id="32、简单说说-lambda-表达式？"><a href="#32、简单说说-lambda-表达式？" class="headerlink" title="32、简单说说 lambda 表达式？"></a>32、简单说说 lambda 表达式？</h3><p><code>Lambda</code> 表达式是 C++11 引入的一种新特性，允许在代码中<strong>定义匿名函数</strong>。Lambda 表达式提供了一种简洁的方式来创建内联函数，特别适用于需要短小函数的场景，如排序、自定义算法或回调函数等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda表达式的具体形式： [capture](parameter)-&gt;retrun_type&#123;body&#125;</span></span><br><span class="line"><span class="comment">// capture     要用到的外部变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="comment">// bool cmp(int a， int b) &#123; return a &gt; b;&#125;</span></span><br><span class="line"><span class="comment">// 可改写为：</span></span><br><span class="line"><span class="comment">// std::sort(arr， arr+len， [](int a， int b) &#123; return a &gt; b; &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> add_n              = [n](<span class="type">int</span> a) &#123; <span class="keyword">return</span> a + n; &#125;;</span><br><span class="line">    <span class="keyword">auto</span> add_and_modify_n   = [n](<span class="type">int</span> a) <span class="keyword">mutable</span> &#123; n += a; <span class="keyword">return</span> n;&#125;;  <span class="comment">// 只在lambda的内部生效，不会改变外部变量n的值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add_n(5): &quot;</span> &lt;&lt; <span class="built_in">add_n</span>(<span class="number">5</span>) &lt;&lt; std::endl;  <span class="comment">// 15</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add_and_modify_n(5): &quot;</span> &lt;&lt; <span class="built_in">add_and_modify_n</span>(<span class="number">5</span>) &lt;&lt; std::endl;  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;n: &quot;</span> &lt;&lt; n &lt;&lt; std::endl;  <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="33、使用-lambda-表达式，捕获局部变量时有什么规则？"><a href="#33、使用-lambda-表达式，捕获局部变量时有什么规则？" class="headerlink" title="33、使用 lambda 表达式，捕获局部变量时有什么规则？"></a>33、使用 lambda 表达式，捕获局部变量时有什么规则？</h3><p>Lambada表达式的捕获规则主要有：<strong>值捕获</strong>，<strong>引用捕获</strong>，<strong>隐式捕获</strong>和<strong>显示捕获</strong>。</p>
<ol>
<li><strong>值捕获</strong>指复制外部作用域的局部变量，并在 lambda 表达式内部使用它们的副本，表达式内部的操作不会影响原始变量的值。</li>
<li><strong>引用捕获</strong>指获取外部作用域的局部变量的引用，表达式内部对变量的操作会影响到原始变量。</li>
<li><strong>隐式捕获</strong>：通过在捕获列表中使用 &#x3D; 或 &amp; 符号，可以实现隐式捕获。使用 &#x3D; 捕获外部作用域的所有变量的副本，而使用 &amp; 捕获所有变量的引用。</li>
<li><strong>显式捕获</strong>：在捕获列表中，可以指定要捕获的特定变量，并且可以同时使用值捕获和引用捕获。</li>
</ol>
<h3 id="34、virtual-和-override-的区别和应用场景？"><a href="#34、virtual-和-override-的区别和应用场景？" class="headerlink" title="34、virtual 和 override 的区别和应用场景？"></a>34、virtual 和 override 的区别和应用场景？</h3><ol>
<li><code>virtual</code> 用于声明虚函数，即在基类中声明一个函数为虚函数，以便在派生类中进行覆盖或重写。</li>
<li><code>override</code> 用于显式地告诉编辑器，当前函数是基类中虚函数的重写版本。</li>
</ol>
<h3 id="【-】-35、volatile-关键字的作用？应用场景如何？"><a href="#【-】-35、volatile-关键字的作用？应用场景如何？" class="headerlink" title="【*】 35、volatile 关键字的作用？应用场景如何？"></a>【*】 35、volatile 关键字的作用？应用场景如何？</h3><p>使用<code>volatile</code>关键字是为了提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，告诉编译器对该变量不做优化，而总是重新从它所在的内存读取数据，而且读取的数据立刻被保存。</p>
<p><code>volatile</code>有以下应用场景：</p>
<p><strong>(1)中断服务程序中修改的供其它程序检测的变量，需要加 volatile</strong></p>
<p>当变量在触发某中断程序后修改，而编译器判断主函数里面没有修改该变量，因此可能只执行一次从内存到某寄存器的读操作，而后每次只会从该寄存器中读取变量副本，使得中断程序的操作被短路。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span> (i) &#123; dosomething();&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Interrupt service routine. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ISR_2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">      i=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)多任务环境下各任务间共享的标志，应该加 volatile</strong></p>
<p>在本次线程内，当读取一个变量时，为提高存取速度，编译器优化时可能会先把变量读取到一个寄存器中，之后再取变量值时，就直接从寄存器中取值。当变量值在本线程里改变时，会同时把变量的新值 copy 到该寄存器中，以便保持一致。此时，当变量因其它线程改变了值时，该寄存器的值不会改变，从而造成应用程序读取的值和实际的变量值不一致。</p>
<p><strong>(3)存储器映射的硬件寄存器通常也要加 volatile，因为每次对它的读写都可能有不同意义</strong></p>
<p>例如，在做按键检测时是如下流程：</p>
<ul>
<li>设置 GPIO 对应的寄存器配置成输入模式；</li>
<li>不断地去访问 GPIO 电平标志寄存器(或者是一个寄存器的标志位)；</li>
<li>根据寄存器值的某个二进制位确定当前引脚电平</li>
</ul>
<p>硬件寄存器上的值的是和底层电路相关的，硬件寄存器的值会影响电路，电路也会反过来影响硬件寄存器的值。所以在这种情况下，编译器更不应该拷贝副本，而应该每次读写都从内存中读写，保证数据正确，声明成 volatile 可以防止出现数据出错问题。</p>
<p>假设要对一个设备进行初始化，此设备的某一个寄存器为 0xff800000：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  *output = (<span class="type">unsigned</span>  <span class="type">int</span> *)<span class="number">0xff800000</span>;<span class="comment">//定义一个IO端口；</span></span><br><span class="line"><span class="type">int</span>   <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> i;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; <span class="number">10</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">      *output = i;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将 output 这个指针赋值为 9，所以编译器最后给你编译编译的代码结果相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">      *output = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>下面的函数有什么错误？</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *ptr)</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> *ptr * *ptr;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的目的是用来返指针<code>*ptr</code>指向值的平方，但是，由于<code>*ptr</code>指向一个 volatile 型参数，编译器将产生类似下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *ptr)</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">  <span class="type">int</span> a，b;</span><br><span class="line">  a = *ptr;</span><br><span class="line">  b = *ptr;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>*ptr</code>的值可能被意想不到地该变，因此 a 和 b 可能是不同的。结果，这段代码可能返不是你所期望的平方值。</p>
</blockquote>
<h3 id="36、sizeof-和-strlen-之间的区别是什么？"><a href="#36、sizeof-和-strlen-之间的区别是什么？" class="headerlink" title="36、sizeof 和 strlen 之间的区别是什么？"></a>36、sizeof 和 strlen 之间的区别是什么？</h3><p>(1)<code>sizeof</code> 是一个运算符而不是函数，用于获取指定类型或变量在内存中占用的字节数，在编译时进行计算，不会对实际的内存内容进行操作，返回类型是 <code>size_t</code>。</p>
<p>(2)<code>strlen</code> 是一个函数，用于获取以 <code>null</code> 结尾的 <code>C</code> 风格字符串的长度，即字符串中有效字符的数量，不包含结尾的 <code>null</code> 字符。在运行时进行遍历计算，返回类型是 <code>size_t</code>。</p>
<h3 id="37、scanf-和-std-cin-有什么区别？"><a href="#37、scanf-和-std-cin-有什么区别？" class="headerlink" title="37、scanf() 和 std::cin 有什么区别？"></a>37、scanf() 和 std::cin 有什么区别？</h3><ol>
<li><p><code>scanf()</code> 是 C 标准库中的一个函数，用于<strong>从标准输入(通常是键盘)读取格式化输入</strong>。<strong>对输入的类型不进行类型检查</strong>，可能会导致类型不匹配或溢出等问题，相对于 <code>std::cin</code>通常更高效，因为它直接操作输入缓冲区；</p>
</li>
<li><p><code>std::cin</code> 是 C++ 标准库中的一个对象，用于<strong>从标准输入流读取数据，可以链式输入多个变量</strong>，格式更加灵活；同时<strong>自动跳过空白字符</strong>(如空格、换行符等)。<code>scanf()</code> <code>std::cin</code> 是 C+ 中的<strong>类型安全输入方式</strong>。</p>
</li>
</ol>
<h3 id="38、struct-和-class-的区别是什么？"><a href="#38、struct-和-class-的区别是什么？" class="headerlink" title="38、struct 和 class 的区别是什么？"></a>38、struct 和 class 的区别是什么？</h3><p>struct 和 class 是用于定义自定义数据类型的关键字。其中：</p>
<p><strong>(1)struct 默认的访问类型是 <code>public</code> ，而class默认的访问类型是 <code>private</code>；</strong></p>
<p><strong>(2)struct 的继承是 <code>public</code> 的，而class的继承默认是 <code>private</code>的；</strong></p>
<p>(3)struct 用于较为简单的结构，而 class 用于更加复杂的结构。</p>
<blockquote>
<p><strong>为什么有了 class 还要有 struct?</strong> </p>
<p>原因是 C++ 需要保留对 C 的兼容性，C 中有 struct，所以 C++ 也保留。</p>
</blockquote>
<h3 id="39、C-中-delete-一个对象和数组有什么区别？"><a href="#39、C-中-delete-一个对象和数组有什么区别？" class="headerlink" title="39、C++ 中 delete 一个对象和数组有什么区别？"></a>39、C++ 中 delete 一个对象和数组有什么区别？</h3><ol>
<li>使用<code>delete</code>释放单个对象时只调用一次析构函数，而使用<code>delete[]</code>释放对象数组时需要为数组中的每个对象调用析构函数；</li>
<li><code>delete</code>数组要用<code>delete[]</code>，数组头部有一块内存空间记录数组长度，调用<code>delete[]</code>才能析构每个对象。</li>
</ol>
<h3 id="40、如何防止重复引用头文件？"><a href="#40、如何防止重复引用头文件？" class="headerlink" title="40、如何防止重复引用头文件？"></a>40、如何防止重复引用头文件？</h3><p>(1)使用<code>#ifndef</code>、<code>#define</code>和<code>#endif</code>；</p>
<p>(2)使用<code>#pragma once</code></p>
<h3 id="41、如何预防变量的重定义？"><a href="#41、如何预防变量的重定义？" class="headerlink" title="41、如何预防变量的重定义？"></a>41、如何预防变量的重定义？</h3><ol>
<li>使用命名空间；</li>
<li>使用 <code>static</code> 关键字或匿名命名空间来限制变量的作用域至单个文件；</li>
<li>使用 <code>extern</code> 关键字确保全局变量只有一个定义；</li>
<li>避免在头文件中定义变量，将定义放在源文件( <code>.cpp</code> )中</li>
</ol>
<h3 id="42、virtual-和-static-为什么不能修饰同一个成员函数？"><a href="#42、virtual-和-static-为什么不能修饰同一个成员函数？" class="headerlink" title="42、virtual 和 static 为什么不能修饰同一个成员函数？"></a>42、virtual 和 static 为什么不能修饰同一个成员函数？</h3><p>因为它们的语义和用途在本质上是互相冲突的。</p>
<ol>
<li><p><code>virtual</code> 关键字用于支持多态性，在基类中声明虚函数。虚函数的调用需要对象的实例，通过对象实例的虚函数指针 vptr 指向虚函数表 vtable 实现来解析其函数调用。</p>
</li>
<li><p><code>static</code> 关键字：<code>static</code> 关键字用于声明类的静态成员函数。静态成员函数属于类本身，而不属于类的任何一个对象实例，也就是说，静态成员函数可以在没有任何对象实例的情况下调用。</p>
</li>
</ol>
<h3 id="43、sizeof-一个-std-string-变量的结果？"><a href="#43、sizeof-一个-std-string-变量的结果？" class="headerlink" title="43、sizeof 一个 std::string 变量的结果？"></a>43、sizeof 一个 std::string 变量的结果？</h3><p>当对一个 <code>std::string</code> 类型的变量使用 <code>sizeof</code> 时，得到的结果是该 <code>std::string</code> 对象本身在栈上所占的大小，而不是它所管理的字符串数据的大小。</p>
<p><code>std::string</code> 通常由以下成员组成，在 64 位系统下通常为 32 字节：</p>
<ul>
<li><strong>指向动态分配内存的指针：</strong> 当字符串长度超过小型对象优化的限制时，字符串数据会被动态分配并存储在堆上。这个指针指向堆上的数据。</li>
<li><strong>大小信息：</strong> 存储字符串当前的长度信息。</li>
<li><strong>容量信息：</strong> 存储字符串的容量信息（即分配的内存大小）。</li>
<li><strong>小型对象优化存储空间：</strong> 一些实现会在 <code>std::string</code> 对象内部预留一块内存，用于存储较短的字符串数据，以避免动态分配内存的开销。具体来说，当字符串的长度在一定范围内（例如 15 个字符以内）时，<code>std::string</code> 对象内部会直接存储这些字符数据，而不会进行动态内存分配。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设的内存分配如下：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">string_with_sso</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>* data;           <span class="comment">// 8 字节 - 指向动态分配内存的指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="type">size_t</span> size;     <span class="comment">// 8 字节 - 当前字符串长度</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="type">size_t</span> capacity; <span class="comment">// 8 字节 - 当前容量</span></span><br><span class="line">    <span class="type">char</span> small_buffer[<span class="number">8</span>]; <span class="comment">// 8 字节 - 用于存储短字符串的小缓冲区</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="44、空类的-sizeof-结果是多少？为什么？"><a href="#44、空类的-sizeof-结果是多少？为什么？" class="headerlink" title="44、空类的 sizeof 结果是多少？为什么？"></a>44、空类的 sizeof 结果是多少？为什么？</h3><p>空类会占用至少一个字节的内存空间。 <code>sizeof</code> 结果通常是 1，但也可能会更大，这取决于编译器和平台的实现。</p>
<p><strong>-为什么？</strong></p>
<p>因为编译器需要区分空类的实例，而我们区分的方法就是看其在内存中的地址是不是相同的。所以编译器强制给它分配了冗余的空间，这样创建空类实例时返回的地址才会不一样。</p>
<h3 id="45、只包含虚函数的类-sizeof-的结果是多少？"><a href="#45、只包含虚函数的类-sizeof-的结果是多少？" class="headerlink" title="45、只包含虚函数的类 sizeof 的结果是多少？"></a>45、只包含虚函数的类 sizeof 的结果是多少？</h3><p>类中包含一个指向虚函数表的指针，结果是<code>8</code>(64 位系统)。</p>
<h3 id="【-】46、decltype"><a href="#【-】46、decltype" class="headerlink" title="【*】46、decltype"></a>【*】46、decltype</h3><p><code>decltype(declare type)</code>关键字在 C++11 中引入，它可以在<strong>编译</strong>时获取<strong>表达式</strong>的类型，包括变量、函数调用、表达式等。</p>
<p>decltype 的一些关键点解读如下：</p>
<ul>
<li>表达式类型的推导：decltype 可以用来推导几乎任何表达式的类型，包括变量、函数调用、解引用操作符、成员访问等。它推导的类型是表达式的静态类型，而不是运行时类型。</li>
<li>保留 cv-限定词：与 auto 不同，decltype 在推导类型时会保留表达式的 const 和 volatile 属性。这意味着 decltype 可以推导出更精确的类型。</li>
<li>不推导表达式的值：decltype 只关注表达的类型，而不关心表达式的值。因此，它可以用来推导不产生值的表达式（如函数调用或对象创建）的类型。</li>
<li>decltype 与 decltype specifier：decltype 还可以用作模板参数的 specifier，这允许模板根据其参数的类型来推导其他模板参数的类型。</li>
<li>推导 Lambda 表达式的类型：decltype 可以用来推导 Lambda 表达式的类型，这在泛型编程中非常有用。</li>
</ul>
<h3 id="47、static-在-C-与-C-中的差别？"><a href="#47、static-在-C-与-C-中的差别？" class="headerlink" title="47、static 在 C++与 C 中的差别？"></a>47、static 在 C++与 C 中的差别？</h3><ol>
<li>在 C 中，<code>static </code>关键字用于扩展局部变量的生命周期和限制全局变量&#x2F;函数的作用域。</li>
<li>在 C++ 中，<code>static</code> 关键字除了具有与 C 中相同的功能外，还用于定义类的静态成员变量和静态成员函数，使这些成员在类的所有实例之间共享，并且可以通过类名直接访问。</li>
</ol>
<h3 id="【-】48、static-变量什么时候初始化"><a href="#【-】48、static-变量什么时候初始化" class="headerlink" title="【*】48、static 变量什么时候初始化?"></a>【*】48、static 变量什么时候初始化?</h3><ol>
<li>对于 C 语言中的全局和静态变量，初始化发生在任何代码执行之前，即编译期进行初始化；</li>
<li>对于 C++ 来说，全局和静态对象<strong>当且仅当对象首次用到时才进行构造</strong>。</li>
</ol>
<h3 id="49、C-中新增了-string，它与-C-语言中的-char-有什么区别吗？如何实现？"><a href="#49、C-中新增了-string，它与-C-语言中的-char-有什么区别吗？如何实现？" class="headerlink" title="49、C++ 中新增了 string，它与 C 语言中的 char * 有什么区别吗？如何实现？"></a>49、C++ 中新增了 string，它与 C 语言中的 char * 有什么区别吗？如何实现？</h3><ol>
<li><code>string</code> 继承自 <code>basic_string</code>，其实是对 <code>char*</code>进行了封装，封装的 <code>string</code> 包含了 <code>char*</code> 数组，容量，长度等等属性。</li>
<li><code>string</code> 可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。</li>
</ol>
<h2 id="四、左值引用和右值引用"><a href="#四、左值引用和右值引用" class="headerlink" title="四、左值引用和右值引用"></a>四、左值引用和右值引用</h2><h3 id="50、什么是左值，什么是右值？"><a href="#50、什么是左值，什么是右值？" class="headerlink" title="50、什么是左值，什么是右值？"></a>50、什么是左值，什么是右值？</h3><ul>
<li>左值(<code>lvalue， localtor value</code>)是指一段指向内存的，具有名称的值，通常有较长的声明周期；左值引用即常见的定义引用的方式，引用相当于变量的别名。</li>
<li>右值(<code>rvalue， read value</code>)是指向不稳定内存的匿名值，声明周期较短。</li>
</ul>
<p>可以通过取址符号来进行判断，能取到地址的是左值，取不到的是右值。</p>
<h3 id="51、前置-c-后置-c-字符串字面量是左值还是右值？"><a href="#51、前置-c-后置-c-字符串字面量是左值还是右值？" class="headerlink" title="51、前置 c++ &#x2F;后置 c++ &#x2F;字符串字面量是左值还是右值？"></a>51、前置 c++ &#x2F;后置 c++ &#x2F;字符串字面量是左值还是右值？</h3><ul>
<li>前置 C++ 的实现是直接对传入的变量进行自增，然后返回这个对象，即一个具有名称的稳定的值，因此返回的是左值。</li>
<li>后置 C++ 是创建一个临时对象，然后对对象自增，再返回这个临时对象，因此返回的是右值。</li>
<li>字符串字面量也是左值。他会将字符串变量存放在程序的数据段中，程序加载时为其分配一段内存。</li>
</ul>
<blockquote>
<p>字面量(Literal)是编程语言中的一个概念，代表着源代码中的常量值，可以直接使用而不需要经过计算或处理。在 C++ 中，常见的字面量包括整数字面量、浮点数字面量、字符字面量、字符串字面量等。</p>
</blockquote>
<h3 id="52、什么是左值引用和右值引用？"><a href="#52、什么是左值引用和右值引用？" class="headerlink" title="52、什么是左值引用和右值引用？"></a>52、什么是左值引用和右值引用？</h3><ul>
<li>左值引用是指向左值的引用，用单个&amp;表示。常量左值引用可以绑定左值，也可以绑定右值。非常量左值引用只能绑定左值。</li>
<li>右值引用是指向右值的引用，用两个&amp;&amp;表示。右值引用主要用于移动语义。通过移动语义，可以避免不必要的拷贝操作，从而提升性能。</li>
</ul>
<h3 id="53、右值引用是如何提高性能的？"><a href="#53、右值引用是如何提高性能的？" class="headerlink" title="53、右值引用是如何提高性能的？"></a>53、右值引用是如何提高性能的？</h3><p>右值引用主要是通过避免不必要的拷贝操作来提升性能的。</p>
<p>举两个例子：</p>
<ol>
<li>当使用右值引用接收函数返回的局部变量时，可以延长该局部变量的声明周期，使得右值引用直接利用该局部变量的内存，而不是创建一个临时对象，从而避免了不必要的开销。</li>
<li>当使用一个临时对象来创建一个新对象时，可以使用移动构造函数，直接将资源从一个对象复制到另一个对象上，避免了不必要的复制操作。</li>
</ol>
<h3 id="54、指针和引用的区别？"><a href="#54、指针和引用的区别？" class="headerlink" title="54、指针和引用的区别？"></a>54、指针和引用的区别？</h3><p>指针和引用都是⼀种内存地址的概念，区别在于指针是⼀个实体，而引用只是⼀个别名。</p>
<ul>
<li><p><strong>(1)在程序编译时：</strong></p>
<ul>
<li>指针指向⼀块内存，指针的内容是所指向的内存的地址，在编译的时候，则是将<strong>“指针变量名-指针变量的地址”</strong>添加到符号表中，所以说，指针包含的内容是可以改变的，允许拷贝和赋值，有 const 和非 const 区别，甚至可以为空。</li>
<li>而对于引用来说，它只是⼀块内存的别名，在添加到符号表的时候，是将<strong>“引用变量名-引用对象的地址”</strong>添加到符号表中，符号表⼀经完成不能改变，所以引用必须而且只能在定义时被绑定到⼀块内存上，后续不能更改，也不能为空，也没有 const 和非 const 区别。</li>
</ul>
</li>
<li><p><strong>(2)sizeof：</strong></p>
<ul>
<li>sizeof 引用得到代表对象的大小；</li>
<li>sizeof 指针得到的是指针本身的大小。</li>
</ul>
</li>
<li><p><strong>(3)在参数传递中：</strong></p>
<ul>
<li>指针需要被解引用后才可以对对象进行操作；</li>
<li>而对引用进行的修改会直接作用到引用对象上。</li>
</ul>
</li>
<li><p><strong>(4)作为参数时：</strong></p>
<ul>
<li>传指针的实质是传值，传递的值是指针的地址；</li>
<li>传引用的实质是传地址，传递的是变量的地址。</li>
</ul>
</li>
</ul>
<h3 id="55、push-back-和-emplace-back-的区别？"><a href="#55、push-back-和-emplace-back-的区别？" class="headerlink" title="55、push_back() 和 emplace_back() 的区别？"></a>55、push_back() 和 emplace_back() 的区别？</h3><p><code>push_back()</code> 和 <code>emplace_back()</code> 都是用于向容器(比如 std::vector)尾部添加新元素的成员函数，但它们在</p>
<p>背后执行的动作略有不同。</p>
<p>区别如下：</p>
<p>(1)<code>push_back()</code>接收一个元素的拷贝或移动作为参数，并将其复制或移动到容器的末端。</p>
<p>(2)<code>emplace_back()</code>则直接在向量的尾部构造元素，而不是先构造一个临时对象然后再进行拷贝或移动。</p>
<blockquote>
<p><code>push_back</code>一定是模板，但是模板的类型一定是与vector的模板一致，因此无法进行类型推导，一定不能是通用引用；2)能够区分左值和右值，所以重载2个函数分别接收左值和右值。</p>
<p><code>emplace_back</code> 1)可以接收任意参数，一定是可变参数模板；2)能够区分左值和右值。因此一定是通用引用。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a) : <span class="built_in">x</span>(a) &#123; std::cout &lt;&lt; <span class="string">&quot;Constructing MyClass with &quot;</span> &lt;&lt; x &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// emplace_back</span></span><br><span class="line">    std::vector&lt;MyClass&gt; vec;</span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="number">42</span>);            <span class="comment">// 直接在 vec 末尾构造 MyClass 对象</span></span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; v.x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push_back</span></span><br><span class="line">    std::vector&lt;MyClass&gt; vec1;</span><br><span class="line">    <span class="function">MyClass <span class="title">my</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    vec1.<span class="built_in">push_back</span>(my);              <span class="comment">// 复制 my 到 vec1 末尾</span></span><br><span class="line">    vec1.<span class="built_in">push_back</span>(<span class="built_in">MyClass</span>(<span class="number">11</span>));     <span class="comment">// 直接构造临时对象并移动到 vec1 末尾</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v1 : vec1) &#123;</span><br><span class="line">        std::cout &lt;&lt; v1.x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="56、push-back-可以传入-std-move-的变量吗？"><a href="#56、push-back-可以传入-std-move-的变量吗？" class="headerlink" title="56、push_back() 可以传入 std::move() 的变量吗？"></a>56、push_back() 可以传入 std::move() 的变量吗？</h3><p><code>push_back</code> 可以接受通过 <code>std::move</code> 传递的变量，这样可以将变量的资源移动到容器中，而不是复制。</p>
<p>这样做和直接使用<code>emplace_back</code>的性能是相似的。因为它们都是在进行移动操作，而非复制操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push_back</span></span><br><span class="line">std::vector&lt;MyClass&gt; vec1;</span><br><span class="line">vec1.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(<span class="built_in">MyClass</span>(<span class="number">11</span>)));</span><br></pre></td></tr></table></figure>

<h3 id="【-】57、std-move-的实现？"><a href="#【-】57、std-move-的实现？" class="headerlink" title="【*】57、std::move() 的实现？"></a>【*】57、std::move() 的实现？</h3><ol>
<li><p>通过类型萃取<strong>移除</strong>引用属性，获取传入参数的类型；</p>
</li>
<li><p>将传入的参数显式转换为右值引用类型，确保返回的值是一个右值引用，从而启用移动语义；</p>
</li>
<li><p>注意加上<code>noexcept</code> 关键字，表示此函数不会抛出异常。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * std::move 的本质总是将左值转换为右值</span></span><br><span class="line"><span class="comment"> * 对一个对象是用std::move就是告诉编译器，这个对象很适合被移动，但是实际移动的操作是由类自己完成的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="comment">// std::move()的实现 C++11</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态断言：确保 T 不是左值引用类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::move()的实现 C++14</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move2</span><span class="params">(T &amp;&amp;param)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> ReturnType = std::<span class="type">remove_reference_t</span>&lt;T&gt; &amp;&amp;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>

<h3 id="【-】58、std-move-的应用场景？"><a href="#【-】58、std-move-的应用场景？" class="headerlink" title="【*】58、std::move() 的应用场景？"></a>【*】58、std::move() 的应用场景？</h3><p>通常来说，主要是使用 move 操作来优化性能，避免不必要的开销。比如使用 move 来在容器间转移元素，而不是复制。当我们<strong>确定一个对象不再使用或者有一个临时对象时</strong>，使用 move 可以将对象的内容转移到另一个对象，<strong>最典型场景是使用 unique_ptr 来改变资源所有权</strong>。</p>
<h3 id="【-】59、如果一个对象被使用-std-move-了，再使用它，会产生什么问题？"><a href="#【-】59、如果一个对象被使用-std-move-了，再使用它，会产生什么问题？" class="headerlink" title="【*】59、如果一个对象被使用 std::move 了，再使用它，会产生什么问题？"></a>【*】59、如果一个对象被使用 std::move 了，再使用它，会产生什么问题？</h3><p>被移动的对象进入一个<strong>合法但未定义状态</strong>，它是合法的数据，它可以被正常析构，可以被重新赋值。但是它又是未定义的，使用它的数据后可能会导致崩溃，数据损坏等其它错误的行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_and_move</span><span class="params">(std::string str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    std::string new_str = std::<span class="built_in">move</span>(str);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Moved-to new_str: &quot;</span> &lt;&lt; new_str &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 未定义行为</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After move, original str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正确行为</span></span><br><span class="line">    <span class="comment">// str = &quot;New value after move&quot;;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;After move, original str reassigned: &quot; &lt;&lt; str &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="built_in">print_and_move</span>(s);</span><br><span class="line">    <span class="comment">// 未定义行为</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;In main, after move s: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正确行为</span></span><br><span class="line">    <span class="comment">// s = &quot;New value in main after move&quot;;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;In main, after move, original s reassigned:: &quot; &lt;&lt; s &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试结果</span></span><br><span class="line">Original str: Hello, World!</span><br><span class="line">Moved-to new_str: Hello, World!  </span><br><span class="line">After move, original str: 				<span class="comment">// str变成了一个合法但未定义的状态。在许多标准库实现中，移动后会变成空字符串</span></span><br><span class="line">In main, after move s: Hello, World!  	<span class="comment">// 在调用时传递的是s的一个副本，因此依旧可以输出</span></span><br></pre></td></tr></table></figure>

<h3 id="【-】60、std-move-究竟移动了什么？"><a href="#【-】60、std-move-究竟移动了什么？" class="headerlink" title="【*】60、std::move 究竟移动了什么？"></a>【*】60、std::move 究竟移动了什么？</h3><p>移动的是对象的所有权。通常来说 std::move 做了以下事情：</p>
<ol>
<li>将参数(对象)转换为<strong>右值引用</strong>，这意味着该对象可以被移动；</li>
<li>将资源的所有权从一个对象<strong>转移</strong>到另一个对象，通常通过移动构造函数或移动赋值运算符来完成；</li>
<li>将源对象的状态置为<strong>有效但未指定的状态</strong>，以避免重复释放资源或访问已移动的资源</li>
</ol>
<h3 id="61、区别-std-move-和-std-forward"><a href="#61、区别-std-move-和-std-forward" class="headerlink" title="61、区别 std::move() 和 std::forward()"></a>61、区别 std::move() 和 std::forward()</h3><p>(1)<code>std::move</code> 将一个对象显式地转换为右值引用，从而启用移动语义；</p>
<p>(2)<code>std::forward</code> 完美转发参数，保持参数的值类别；根据传入参数的类型和值类别，返回左值引用或右值引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span> (<span class="type">int</span> value) : <span class="built_in">b</span>(value) &#123; &#125;</span><br><span class="line">    <span class="built_in">A</span> (<span class="type">const</span> A &amp;value) &#123; b = value.b; &#125;</span><br><span class="line">    <span class="built_in">A</span>(A &amp;&amp;value) &#123;</span><br><span class="line">        b = value.b;</span><br><span class="line">        value.b = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * std::forward&lt;T&gt; 的本质是有条件的move，只有当实参用右值初始化时才转换为右值</span></span><br><span class="line"><span class="comment"> * 对一个对象是用std::move就是告诉编译器，这个对象很适合被移动，但是实际移动的操作是由类自己完成的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> A &amp;lvalArg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deal lvalArg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(A &amp;&amp;lvalArg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;deal rvalArg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndProcess</span><span class="params">(T &amp;&amp;param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无论param是左值还是右值，只会被认为是左值</span></span><br><span class="line">    <span class="comment">// 因为param是一个具有名称的变量，即使它是通过右值引用(T&amp;&amp;)传递进来的，</span></span><br><span class="line">    <span class="comment">// 所以，当我们直接使用它时，无论哪种情况它都会被视为左值</span></span><br><span class="line">    <span class="built_in">process</span>(param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无论param是左值还是右值，都会被转换成右值</span></span><br><span class="line">    <span class="built_in">process</span>(std::<span class="built_in">move</span>(param));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅当实参用右值初始化时，转换为一个右值</span></span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="62、什么是引用折叠？"><a href="#62、什么是引用折叠？" class="headerlink" title="62、什么是引用折叠？"></a>62、什么是引用折叠？</h3><p><strong>引用折叠</strong>用于处理在模板中出现的多重引用情况，定义了在模板实例化和类型推导过程中，如何将多个引用折叠成一个最终的引用类型。具体规则如下：</p>
<ol>
<li><code>T&amp; &amp;</code> -&gt; <code>T&amp;</code></li>
<li><code>T&amp; &amp;&amp;</code> -&gt; <code>T&amp;</code></li>
<li><code>T&amp;&amp; &amp;</code> -&gt; <code>T&amp;</code></li>
<li><code>T&amp;&amp; &amp;&amp;</code> -&gt; <code>T&amp;&amp;</code></li>
</ol>
<p>换句话说：</p>
<ul>
<li>如果任何一个引用是左值引用，则结果是左值引用。</li>
<li>只有当两个都是右值引用时，结果才是右值引用。</li>
</ul>
<h3 id="63、为什么要引入引用折叠？"><a href="#63、为什么要引入引用折叠？" class="headerlink" title="63、为什么要引入引用折叠？"></a>63、为什么要引入引用折叠？</h3><p>引用折叠的引入主要是为了支持<strong>完美转发</strong>。完美转发使得函数模板能够将参数完全按原样传递给另一个函数，而不会丢失信息。</p>
<h3 id="64、什么是通用引用？如何表示通用引用？"><a href="#64、什么是通用引用？如何表示通用引用？" class="headerlink" title="64、什么是通用引用？如何表示通用引用？"></a>64、什么是通用引用？如何表示通用引用？</h3><p><strong>通用引用</strong>(Universal Reference)是 C++11 引入的一种概念，用于描述一种特殊的引用类型。通过**在类型推导的上下文中使用 <code>T&amp;&amp;</code>(此处共提到了两个条件，类型推导和T &amp;&amp;)**来实现，既可以绑定到左值，也可以绑定到右值，并且结合<code>std::forward</code>可以实现完美转发。</p>
<p>对右值引用使用 std::move()，对通用引用使用 std::forward()。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这种实现方式存在两个问题：1)不够高效；2)如果有n个参数，则需要2^n个重载函数</span></span><br><span class="line">    <span class="comment">// void setName(const std::string &amp;name) &#123; _name = name; &#125;</span></span><br><span class="line">    <span class="comment">// void setName(std::string &amp;&amp;name) &#123; _name = std::move(name); &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用通用引用来改写</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">setName</span><span class="params">(T &amp;&amp;name)</span> </span>&#123; _name = std::forward&lt;T&gt;(name); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及多个参数时</span></span><br><span class="line">    <span class="comment">// template&lt;typename T， typename... Args&gt;</span></span><br><span class="line">    <span class="comment">// std::shared_ptr&lt;T&gt; make_shared(Args &amp;&amp;... args) &#123;</span></span><br><span class="line">    <span class="comment">//   return std::make_shared&lt;T&gt;(std::forward&lt;Args&gt;(args)...);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通用引用的表示方式：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通用引用既可以表示左值引用，也可以表示右值引用</span></span><br><span class="line"><span class="comment"> * 要求 1)T &amp;&amp;； 2)类型推导</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// T &amp;&amp;param 是通用引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T &amp;&amp;param)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;T&amp;&amp;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// param是右值引用，因为 std::vector&lt;T&gt; &amp;&amp; 和 T &amp;&amp; 形式不一样</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(std::vector&lt;T&gt; &amp;&amp;param)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// param是右值引用，因为 const T &amp;&amp; 和 T &amp;&amp; 形式不一样</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> T &amp;&amp;param)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x是右值引用</span></span><br><span class="line"><span class="comment">// 因为push_back在有一个特定的vector实例之前不可能存在</span></span><br><span class="line"><span class="comment">// 而实例化vector时，T的类型已经决定了</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>， <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line">    <span class="keyword">class</span> vector&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">void</span> <span class="built_in">push_back</span>(T &amp;&amp; x);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// std::vector&lt;int&gt; vec&#123;1， 2， 3&#125;;</span></span><br><span class="line"><span class="comment">// vec.push_back(4);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 可变参数模版的通用引用</span></span><br><span class="line"><span class="comment"> * 要求：Args &amp;&amp;... + 类型推导</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>， <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line">    <span class="keyword">class</span> vector&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Args&gt;</span><br><span class="line">        <span class="type">void</span> <span class="built_in">emplace_back</span>(Args &amp;&amp;... args);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="65、为什么要避免在通用引用上重载？"><a href="#65、为什么要避免在通用引用上重载？" class="headerlink" title="65、为什么要避免在通用引用上重载？"></a>65、为什么要避免在通用引用上重载？</h3><p>在<strong>通用引用</strong>上进行重载可能会导致函数匹配问题。因为通用引用是通过引用折叠实现的，它可以同时绑定到左值和右值，因此当<strong>同时定义了一个接受通用引用的函数和另一个接受值的函数</strong>时，编译器可能会无法确定应该调用哪个函数，从而导致编译错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板1：接受通用引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T &amp;&amp;arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing generic argument&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板2：接受整数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing integer argument&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">process</span>(<span class="number">5</span>);  <span class="comment">// 调用 process&lt;int&gt;(int)</span></span><br><span class="line">    <span class="built_in">process</span>(x);  <span class="comment">// 调用 process&lt;int&amp;&gt;(int&amp;)，但是可能会与 process(int) 重载冲突</span></span><br><span class="line">    <span class="built_in">process</span>(std::<span class="built_in">move</span>(x));  <span class="comment">// 调用 process&lt;int&gt;(int&amp;&amp;)，但也可能与 process(int) 重载冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【-】66、通用引用的重载有什么替代方法？"><a href="#【-】66、通用引用的重载有什么替代方法？" class="headerlink" title="【*】66、通用引用的重载有什么替代方法？"></a>【*】66、通用引用的重载有什么替代方法？</h3><ol>
<li>使用传值来替代通用引用；</li>
<li>使用 <code>tag dispatch</code>；</li>
<li>使用 <code>enable_if</code> 实现真正的重载。enable_if 可以用来实现函数模板的 SFINAE(Substitution Failure Is Not An Error)机制，从而实现通用引用的重载。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* tag dispatch */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(T &amp;&amp;name， std::false_type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    names.<span class="built_in">emplace_back</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(<span class="type">int</span> idx， std::true_type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    names.<span class="built_in">emplace_back</span>(std::forward&lt;T&gt;(idx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T &amp;&amp;name)</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    logAndAddImpl(std::forward&lt;T&gt;(name)，</span></span></span><br><span class="line"><span class="params"><span class="function">                  std::is_integral&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;()))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* enable_if */</span></span><br><span class="line"><span class="comment">// 通用引用的基本模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; t， <span class="keyword">typename</span> std::enable_if&lt;!std::is_lvalue_reference&lt;T&gt;::value&gt;::type* = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Called with rvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 专门用于左值引用的模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; t， <span class="keyword">typename</span> std::enable_if&lt;std::is_lvalue_reference&lt;T&gt;::value&gt;::type* = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Called with lvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="67、什么时候使用按值传递？"><a href="#67、什么时候使用按值传递？" class="headerlink" title="67、什么时候使用按值传递？"></a>67、什么时候使用按值传递？</h3><p>当<strong>参数是可拷贝的且移动成本较低</strong>时，按值传递通常是一个不错的选择。例如，对于小型的类或结构体，按值传递可以减少额外的开销。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406141533639.png" alt="image-20240614153356184"  />

<h3 id="【-】68、什么是返回值优化？"><a href="#【-】68、什么是返回值优化？" class="headerlink" title="【*】68、什么是返回值优化？"></a>【*】68、什么是返回值优化？</h3><p><strong>返回值优化，即RVO</strong>是一种编译器优化技术，在返回一个局部对象时，通过在调用函数的上下文中<strong>直接构造返回的对象</strong>来<strong>避免多次调用构造函数</strong>，从而减少拷贝或移动构造的开销。</p>
<ol>
<li><strong>匿名返回值优化</strong>(Unnamed RVO，URVO)：这是最常见的一种返回值优化，针对返回匿名对象的情况。</li>
<li><strong>命名返回值优化</strong>(Named RVO，NRVO)：针对返回具名对象的情况。</li>
</ol>
<p>举例分析： </p>
<p><strong>(1)函数返回一个未具名对象</strong></p>
<p>函数返回一个未具名对象时，执行匿名返回值优化(Unknown Return Value Optimization，URVO)，其本质是将返回值函数的原型进行调整。</p>
<p>注意在 C++17 之前可以通过设置 <code>-fno-elide-constructors</code>来禁用 URVO；从 C++17 开始，编译器要求强制 URVO 无法去掉。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 自己写的代码，执行两次移动构造：</span></span><br><span class="line"><span class="comment"> *    1) 创建一个临时对象 Test(1)</span></span><br><span class="line"><span class="comment"> *    2) Test(1) 移动到返回值的位置</span></span><br><span class="line"><span class="comment"> *    2) 返回的临时对象会被再次移动构造到 result</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Test <span class="title">getTest</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Test</span>(<span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; Test result = <span class="built_in">getTest</span>(); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执行URVO后，编译器生成的代码</span></span><br><span class="line"><span class="comment"> *  1. 将函数返回值更改为 void</span></span><br><span class="line"><span class="comment"> *  2. 将要返回的类型定义为 引用类型 的传入参数：Test &amp;t</span></span><br><span class="line"><span class="comment"> *  3. placement new：new(&amp;T) Test(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getTest</span><span class="params">(Test &amp;t)</span> </span>&#123; <span class="keyword">new</span>(&amp;T) <span class="built_in">Test</span>(<span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buff[<span class="built_in">sizeof</span>(Test)];                     <span class="comment">// 栈上开辟4个字节</span></span><br><span class="line">    Test *ptr = <span class="built_in">reinterpret_cast</span>&lt;Test *&gt;(buff);  <span class="comment">// 数据类型转换，标准写法</span></span><br><span class="line">    <span class="built_in">getTest</span>(*ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)函数返回一个具名对象</strong></p>
<p>函数返回一个具名对象时，将同时执行匿名返回值优化(Unknown Return Value Optimization，URVO)和命名返回值优化(Named Return Value Optimization， NRVO)。</p>
<p>设置<code>-fno-elide-constructors</code>可以禁止 NRVO。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自己写的代码，执行两次移动构造：</span></span><br><span class="line"><span class="comment"> *    1) 创建一个对象 a</span></span><br><span class="line"><span class="comment"> *    2) a 移动到返回值的位置</span></span><br><span class="line"><span class="comment"> *    2) 返回的临时对象会被再次移动构造到 result</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Test <span class="title">getTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Test <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test result = <span class="built_in">getTest</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对于Test result = getTest(); */</span></span><br><span class="line"><span class="comment">/* 1. 先执行一次URVO，优化 Test result = getTest(); */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getTest</span><span class="params">(Test &amp;t)</span> </span>&#123;</span><br><span class="line">  <span class="function">Test <span class="title">tt</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">new</span>(&amp;tt) <span class="built_in">Test</span>(std::<span class="built_in">move</span>(tt));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 2. 再执行一次NRVO，优化 return t; */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getTest</span><span class="params">(Test &amp;t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">new</span>(&amp;t) <span class="built_in">Test</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buff[<span class="built_in">sizeof</span>(Test)];                     <span class="comment">// 栈上开辟4个字节</span></span><br><span class="line">  Test *ptr = <span class="built_in">reinterpret_cast</span>&lt;Test *&gt;(buff);  <span class="comment">// 数据类型转换，标准写法</span></span><br><span class="line">  <span class="built_in">getTest</span>(*ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、构造-析构相关"><a href="#五、构造-析构相关" class="headerlink" title="五、构造&#x2F;析构相关"></a>五、构造&#x2F;析构相关</h2><h3 id="69、空类中有什么？"><a href="#69、空类中有什么？" class="headerlink" title="69、空类中有什么？"></a>69、空类中有什么？</h3><p>简单来说，当类中一个成员变量也没有时为空类。</p>
<p>但要注意，以下几种情况也为空类：</p>
<ol>
<li><p>类中<strong>有成员函数，但不涉及成员变量</strong>；</p>
</li>
<li><p>类中<strong>有静态成员变量、静态成员函数</strong>；</p>
</li>
<li><p>类中<strong>有 typedef 语句</strong>；</p>
</li>
<li><p>类中<strong>默认生成的6个成员函数</strong>。</p>
<ul>
<li><p>(1) 默认构造函数</p>
</li>
<li><p>(2) 析构函数</p>
</li>
<li><p>(3) 拷贝构造函数</p>
</li>
<li><p>(4) 赋值运算符</p>
</li>
<li><p>(5) 取址运算符</p>
</li>
<li><p>(6) const 取址运算符</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>可以下面这个代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmptyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认的6个成员函数</span></span><br><span class="line">    <span class="built_in">EmptyClass</span>();  <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">EmptyClass</span>();  <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="built_in">EmptyClass</span>(EmptyClass&amp; h);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    EmptyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> EmptyClass&amp; a);  <span class="comment">// 赋值运算符</span></span><br><span class="line">    EmptyClass* <span class="keyword">operator</span>&amp;();  <span class="comment">// 取址运算符</span></span><br><span class="line">    <span class="type">const</span> EmptyClass* <span class="keyword">operator</span>&amp;() <span class="type">const</span>; <span class="comment">// const取址运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// typedef并没有给类增加成员或者函数</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> INT_NUM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不涉及到内部成员变量的内部函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> a)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setStr</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="type">static</span> std::string str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> is_empty = std::is_empty&lt;EmptyClass&gt;::value;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;是否是空类：&quot;</span> &lt;&lt; is_empty &lt;&lt; std::endl;  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="70、深拷贝和浅拷贝指什么？"><a href="#70、深拷贝和浅拷贝指什么？" class="headerlink" title="70、深拷贝和浅拷贝指什么？"></a>70、深拷贝和浅拷贝指什么？</h3><ol>
<li><p><strong>深拷贝</strong>创建一个新的对象，并且复制对象的所有内容，包括对象的指针成员变量所指向的内存空间。深拷贝后的新对象和原对象之间是彼此独立的。</p>
</li>
<li><p><strong>浅拷贝</strong>只复制对象的引用，而不复制对象的内容。也就是说，浅拷贝创建一个新的对象，但是其新对象的指针成员变量指向的是原对象的指针成员变量所指向的内存空间。</p>
</li>
</ol>
<h3 id="71、拷贝构造函数与拷贝赋值运算符的区别是什么？"><a href="#71、拷贝构造函数与拷贝赋值运算符的区别是什么？" class="headerlink" title="71、拷贝构造函数与拷贝赋值运算符的区别是什么？"></a>71、拷贝构造函数与拷贝赋值运算符的区别是什么？</h3><ol>
<li><p><strong>拷贝构造函数</strong>用于创建新对象，不需要检查自赋值，没有返回值。</p>
</li>
<li><p>而<strong>拷贝赋值运算符</strong>用于更新已经存在的对象的值，<strong>需要检查自赋值</strong>，以防止对象自身赋值给自己，返回一个引用到当前对象。</p>
</li>
</ol>
<blockquote>
<p>拷贝赋值的步骤：</p>
<ol>
<li><strong>判断是否为自我赋值</strong>(important)</li>
<li>删除自己本来的指针及内存</li>
<li>根据要赋值进来的内容大小开辟一块新的内存</li>
<li>复制新的内容</li>
<li>返回<code>*this</code></li>
</ol>
</blockquote>
<h3 id="72、如果一个类要支持-std-move-操作，要完成哪些工作呢？"><a href="#72、如果一个类要支持-std-move-操作，要完成哪些工作呢？" class="headerlink" title="72、如果一个类要支持 std::move 操作，要完成哪些工作呢？"></a>72、如果一个类要支持 std::move 操作，要完成哪些工作呢？</h3><p>需要在类中实现移动构造函数和移动赋值函数。</p>
<ol>
<li><p>移动构造函数接受一个右值引用到同类型的对象，通常声明为 <code>T(T&amp;&amp; other)</code>，其中 <code>T</code> 是类名。</p>
</li>
<li><p>移动赋值运算符通常被定义为返回类的引用，并接受一个右值引用到同类型的对象，声明为 <code>T&amp; operator=(T&amp;&amp; other)</code>。</p>
</li>
<li><p>为了确保移动动作不会抛出异常，添加<code>noexcept</code>关键字。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">        : <span class="built_in">resource</span>(other.resource) &#123;</span><br><span class="line">        other.resource = <span class="literal">nullptr</span>; 		<span class="comment">// 窃取资源后，将原对象的指针设为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123; 			<span class="comment">// 防止自赋值</span></span><br><span class="line">            <span class="keyword">delete</span> resource;  			<span class="comment">// 释放当前对象的资源</span></span><br><span class="line">            resource = other.resource; 	<span class="comment">// 窃取资源</span></span><br><span class="line">            other.resource = <span class="literal">nullptr</span>; 	<span class="comment">// 将原对象的指针设为空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ResourceType* resource;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="73、移动构造函数可能会有什么问题？"><a href="#73、移动构造函数可能会有什么问题？" class="headerlink" title="73、移动构造函数可能会有什么问题？"></a>73、移动构造函数可能会有什么问题？</h3><p>在使用移动构造函数时，如果当一个对象的资源移动到另一个对象上时发生了异常，此时就会造成有一部分资源转移了，而另一部分没有，从而使得源对象和目标对象上的资源都不完整。因此在使用移动构造函数时应该避免发生异常。</p>
<p>如果无法确保移动构造函数不会发生异常，应该用<code>noexcept</code>进行修饰。这样函数如果发生异常时不会继续执行，而是抛出<code>std::terminate</code>并停止。</p>
<h3 id="74、构造函数能否为虚函数？"><a href="#74、构造函数能否为虚函数？" class="headerlink" title="74、构造函数能否为虚函数？"></a>74、构造函数能否为虚函数？</h3><p><strong>构造函数不能是虚函数。</strong>这是因为在C++中，虚函数依赖于对象中的虚函数表(vtable)来进行动态绑定，而虚函数表是在对象的内存分配后构造函数开始执行之前设置好的。在构造函数执行之前，对象还未完全构建完成，因此不存在可以指向的虚函数表。</p>
<p>如果构造函数是虚的，那么在对象创建时还无法确定调用哪一个构造函数，因为虚函数机制尚未建立，所以构造函数无法实现虚调用。</p>
<h3 id="75、析构函数是什么？"><a href="#75、析构函数是什么？" class="headerlink" title="75、析构函数是什么？"></a>75、析构函数是什么？</h3><p><strong>析构函数</strong>是类的一个成员函数，没有返回值，不接受参数，一个类只有一个析构函数。销毁对象时系统也会自动调用析构函数来进行清理工作，例如释放分配的内存、关闭打开的文件等。</p>
<blockquote>
<p>只定义了析构函数时，编译器将自动生成<strong>默认构造函数</strong>和<strong>拷贝构造函数</strong>。</p>
</blockquote>
<h3 id="76、如果在类的析构函数中调用-delete-this-会发生什么？"><a href="#76、如果在类的析构函数中调用-delete-this-会发生什么？" class="headerlink" title="76、如果在类的析构函数中调用 delete this 会发生什么？"></a>76、如果在类的析构函数中调用 delete this 会发生什么？</h3><p>会导致堆栈溢出。</p>
<p>delete 的本质是“为将被销毁的对象调用一个或多个析构函数，然后释放内存”。因此，delete this 会去调用本对象的析构函数，而析构函数内部又会调用 delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p>
<h3 id="77、一个类可以没有析构函数吗？"><a href="#77、一个类可以没有析构函数吗？" class="headerlink" title="77、一个类可以没有析构函数吗？"></a>77、一个类可以没有析构函数吗？</h3><ol>
<li><p><strong>无需编写析构函数的情况</strong>：构造函数仅做简单的成员变量初始化，且成员变量是<strong>内置类型或自动管理的资源</strong>，此时编译器会自动生成一个默认的析构函数；</p>
</li>
<li><p><strong>需要编写析构函数的情况</strong>：构造函数<strong>分配了动态内存、打开了文件或分配了其他需手动管理的资源</strong>，需在析构函数中进行资源释放；</p>
</li>
</ol>
<h3 id="78、析构函数能否为虚函数？"><a href="#78、析构函数能否为虚函数？" class="headerlink" title="78、析构函数能否为虚函数？"></a>78、析构函数能否为虚函数？</h3><ol>
<li><p><strong>不作为基类</strong>：如果类不会被继承或不会通过基类指针删除派生类对象，则不需要虚析构函数。</p>
</li>
<li><p><strong>作为基类</strong>：如果类可能被继承，并且可能通过基类指针删除派生类对象，则应将析构函数定义为虚函数，以确保正确的析构行为。否则，若基类的析构函数不是虚函数，那么调用基类指针删除派生类对象时只会调用基类的析构函数，而不会调用派生类的析构函数。</p>
</li>
</ol>
<h3 id="79、C-的类中可以定义引用的数据成员吗？"><a href="#79、C-的类中可以定义引用的数据成员吗？" class="headerlink" title="79、C++ 的类中可以定义引用的数据成员吗？"></a>79、C++ 的类中可以定义引用的数据成员吗？</h3><p>可以使用，但要注意以下几点：</p>
<ol>
<li><strong>初始化必须在构造函数初始化列表中进行</strong>：引用成员必须在构造函数的初始化列表中进行初始化，因为引用必须在声明时绑定到一个对象，不能在构造函数体内进行赋值。</li>
<li><strong>不能重新绑定</strong>：一旦引用成员被初始化，它就不能被重新绑定到另一个对象。引用成员在对象的生命周期内一直指向同一个对象。</li>
<li><strong>默认构造函数和赋值运算符可能存在错误</strong>：如果类中有引用成员，那么默认的默认构造函数(无参构造函数)就不能使用，因为引用成员需要在初始化时绑定到一个对象。同样，默认的赋值运算符也可能不能正确工作，因为引用成员不能被重新赋值。</li>
</ol>
<h3 id="80、什么情况下编译器必须为未声明构造函数的类合成一个-default-constructor？"><a href="#80、什么情况下编译器必须为未声明构造函数的类合成一个-default-constructor？" class="headerlink" title="80、什么情况下编译器必须为未声明构造函数的类合成一个 default constructor？"></a>80、什么情况下编译器必须为未声明构造函数的类合成一个 default constructor？</h3><ol>
<li><p>如果一个<strong>类没有声明构造函数，但它内部包含声明了构造函数的成员类</strong>，那么编译器需要为这个类合成一个默认构造函数。但要注意以下几点：</p>
<ol>
<li><p>只有在构造函数真正需要被调用时才会执行合成操作；</p>
</li>
<li><p>为避免在不同的编译模块中合成多个 default constructor，采用 inline 的方式完成；</p>
</li>
<li><p>被合成的 default constructor 只是编译器的需要，而不是程序的需要，因此合成时不会对类本身的数据成员进行初始化；而若是程序员已经手动编写了 default constructor，但仅初始化了数据成员，此时编译器会扩张已存在的 constructors，在用户初始化代码前安插必要的 constructors。</p>
</li>
<li><p>如果包含多个类成员，那么将按照其声明顺序来调用各自的 constructors。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; <span class="keyword">public</span>: <span class="built_in">Foo</span>(); <span class="built_in">Foo</span>(<span class="type">int</span>); ...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123; <span class="keyword">public</span>: Foo foo; <span class="type">char</span> *str; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> foo_bar &#123;</span><br><span class="line">    Bar bar;  <span class="comment">// Bar::foo必须在此处进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (str) ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设程序员定义的 default constructor 如下</span></span><br><span class="line">Bar::<span class="built_in">Bar</span>() &#123; str = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么，编译器会在编译时会进行相应扩充</span></span><br><span class="line"><span class="comment">// C++ 伪代码</span></span><br><span class="line">Bar::<span class="built_in">Bar</span>() &#123;</span><br><span class="line">    foo.Foo::<span class="built_in">Foo</span>();  <span class="comment">// 编译器扩充</span></span><br><span class="line">    str = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>如果<strong>一个没有任何构造函数的类派生自一个带有默认构造函数的基类</strong>，那么这个派生类也需要合成一个默认构造函数。注意如果该派生类中同时包含类成员(同情况1)，那么会在所有基类的默认构造函数被调用之后调用这些类成员的默认构造函数。</p>
</li>
<li><p>如果<strong>类声明或继承了一个虚函数，或类派生自一个继承串链，其中有一个或多个虚基类</strong>，那么也需要为其合成一个默认构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">flip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(<span class="type">const</span> Widget&amp; widget)</span> </span>&#123; </span><br><span class="line">    widget.<span class="built_in">flip</span>(); </span><br><span class="line">    <span class="comment">// widget.flip(); 的虚拟调用操作为： (*widget.vptr[1])(&amp;widget);</span></span><br><span class="line">    <span class="comment">//  1: flip()在vtbl中的索引</span></span><br><span class="line">    <span class="comment">//  &amp;widget: 某个实例的this指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bell b;</span><br><span class="line">    Whistle w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">flip</span>(b);</span><br><span class="line">    <span class="built_in">flip</span>(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要对 Bell 和 Whistle 合成 default constructor，为其 vptr 设定初值，指向 vtbl，这样调用 <code>flip(b)</code> 时才能够在虚表中找到对应的虚函数实现。</p>
</li>
<li><p>对于<strong>一个带有虚继承类的类</strong>，也需要合成其默认构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123; <span class="keyword">public</span>: <span class="type">int</span> i; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123; <span class="keyword">public</span>: <span class="type">int</span> j; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法在编译时期决定出 pa-&gt;X::i 的位置，因为 pa 的真正类型可以改变</span></span><br><span class="line"><span class="comment">// 因此编译器需要在派生类对象的每一个虚基类中安插一个指针，</span></span><br><span class="line"><span class="comment">// 所有经由引用或指针来存取一个虚基类的操作都可以通过相关指针完成</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A* pa)</span> </span>&#123; pa-&gt;i = <span class="number">1024</span>; &#125;;</span><br><span class="line"><span class="comment">// 此处编译器可能会执行： pa-&gt;__vbcX-&gt;i = 1024;</span></span><br><span class="line"><span class="comment">// 其中__vbcX 表示编译器产生的指针，指向 virtual base class X</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="keyword">new</span> A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="【-】81、类成员的初始化方式有哪些？"><a href="#【-】81、类成员的初始化方式有哪些？" class="headerlink" title="【*】81、类成员的初始化方式有哪些？"></a>【*】81、类成员的初始化方式有哪些？</h3><p><strong>赋值初始化</strong>，通过在函数体内进行赋值初始化；<strong>列表初始化</strong>，在冒号后使用初始化列表进行初始化。</p>
<p>这两种方式的<strong>主要区别</strong>在于：</p>
<ol>
<li>赋值初始化是在所有的数据成员被分配内存空间后才进行的；</li>
<li>列表初始化是给数据成员分配内存空间时就进行初始化，也就是说分配一个数据成员时，只要冒号后有此数据成员的赋值表达式，那么在进入函数体之前就会给该数据成员赋值；</li>
<li>列表初始化快于赋值初始化，因为 C++ 的赋值操作是会产生临时对象的。临时对象的出现会降低程序的效率。</li>
</ol>
<h3 id="【-】82、有哪些情况必须用到成员列表初始化？作用是什么？"><a href="#【-】82、有哪些情况必须用到成员列表初始化？作用是什么？" class="headerlink" title="【*】82、有哪些情况必须用到成员列表初始化？作用是什么？"></a>【*】82、有哪些情况必须用到成员列表初始化？作用是什么？</h3><ol>
<li>必须使用成员初始化的四种情况：</li>
</ol>
<p>① 当初始化一个<strong>引用成员</strong>时；</p>
<p>② 当初始化一个<strong>常量成员</strong>时；</p>
<p>③ 当调用一个<strong>基类的构造函数</strong>，而它拥有一组参数时；</p>
<p>④ 当调用一个<strong>类成员的构造函数</strong>，而它拥有一组参数时；</p>
<ol start="2">
<li>成员初始化列表做了什么</li>
</ol>
<p>① 编译器以适当的顺序在构造函数之内安插初始化操作；</p>
<p>② 列表中各数据成员的初始化顺序是由其成员声明顺序决定的，不是由初始化列表的顺序决定的。</p>
<h3 id="【-】83、定义一个-class-的object-时，编译器对其构造函数的扩充操作如何？"><a href="#【-】83、定义一个-class-的object-时，编译器对其构造函数的扩充操作如何？" class="headerlink" title="【*】83、定义一个 class 的object 时，编译器对其构造函数的扩充操作如何？"></a>【*】83、定义一个 class 的object 时，编译器对其构造函数的扩充操作如何？</h3><p>按照顺序，依次进行如下扩充：</p>
<ol>
<li>所有<strong>虚拟基类构造函数</strong>被调用；</li>
<li>所有<strong>上一层的基类构造函数</strong>被调用；</li>
<li>为<strong>虚表指针设定初值</strong>，指向适当的虚表；</li>
<li>调用<strong>类成员的构造函数</strong>；</li>
<li>对记录<strong>在列表初始化中的数据成员</strong>进行初始化操作；</li>
<li>派生类<strong>自己的构造函数</strong>函数体。</li>
</ol>
<blockquote>
<p>根据上述扩充顺序可知：<strong>在 constructor 的 member initialization list 中调用该 class 的一个虚函数，是安全行为。</strong>因为 vptr 在 member initialization list 被扩展之前已经由编译器设定好了。只是在语境上这可能是不安全的，因为函数本身可能还得依赖未被设立初值的 members。</p>
</blockquote>
<h2 id="六、多态-虚函数相关"><a href="#六、多态-虚函数相关" class="headerlink" title="六、多态&#x2F;虚函数相关"></a>六、多态&#x2F;虚函数相关</h2><h3 id="84、多态的实现原理是什么？"><a href="#84、多态的实现原理是什么？" class="headerlink" title="84、多态的实现原理是什么？"></a>84、多态的实现原理是什么？</h3><p><code>C++ </code>的多态包括<strong>静态多态</strong>(编译器多态)和<strong>动态多态</strong>(运行期多态)。</p>
<ol>
<li><strong>静态多态</strong>是指编译器的多态，主要由<strong>函数重载和函数模板</strong>实现。函数重载是指在同一作用域内，一组函数具有相同的函数名和不同的参数列表，编译器根据函数调用时传递的参数数量和类型选择调用哪个函数执行。函数模板允许编写通用的代码，编译器根据模板实例化的内容生成代码。</li>
<li><strong>动态多态</strong>则是在运行时实现，主要由<strong>虚函数和继承</strong>实现。其核心思想是类的对象会根据其属性来确定究竟调用哪一个类的函数。具体来说，每一个包含虚函数的类都分配了一个虚函数指针，这个虚函数指针指向一个虚函数表。当需要调用对应的函数时，首先根据虚函数指针找到对应的虚函数表，然后根据这个函数在表中的下标位置找到对应的函数。</li>
</ol>
<blockquote>
<p>多态(polymorphism)表示“<strong>以一个 public base class 的指针或引用，寻址出一个 derived class object</strong>”。</p>
</blockquote>
<blockquote>
<p><strong>base class 和 derived class 都从相同的地址开始，确保类型转换的安全性和多态性的正确实现。</strong></p>
<p>虽然基类和派生类对象从相同的地址开始，但它们的内存布局是严格按照类的成员声明顺序进行的。当创建派生类对象时，内存分配器会为整个对象分配足够的内存，包括基类和派生类的所有成员。基类的成员会先在内存中布局，然后是派生类的成员。因此，基类的成员和派生类的成员在内存中是连续的，不会重叠。</p>
</blockquote>
<h3 id="85、子类的构造与析构过程？"><a href="#85、子类的构造与析构过程？" class="headerlink" title="85、子类的构造与析构过程？"></a>85、子类的构造与析构过程？</h3><ul>
<li><p>构造：先调用父类——&gt;再调用子类</p>
</li>
<li><p>析构：先调用子类——&gt;再调用父类</p>
</li>
</ul>
<h3 id="86、虚函数和纯虚函数有什么区别？"><a href="#86、虚函数和纯虚函数有什么区别？" class="headerlink" title="86、虚函数和纯虚函数有什么区别？"></a>86、虚函数和纯虚函数有什么区别？</h3><ol>
<li><strong>虚函数</strong>是一种<strong>在基类中声明</strong>的函数，它可以在派生类中被重写。虚函数<strong>可以有自己的实现</strong>，也就是说，即使派生类没有重写该函数，也有一个默认的行为可供执行。</li>
<li><strong>纯虚函数</strong>是一种<strong>在基类中声明但不实现</strong>的虚函数。通过在函数声明的末尾加上<code>= 0</code>，可以将函数声明为纯虚函数。一个包含纯虚函数的类称为抽象类，这意味着它不能被实例化。纯虚函数的主要目的是强制派生类提供自己的函数实现。</li>
</ol>
<h3 id="【-】87、什么样的函数适合声明成虚函数？"><a href="#【-】87、什么样的函数适合声明成虚函数？" class="headerlink" title="【*】87、什么样的函数适合声明成虚函数？"></a>【*】87、什么样的函数适合声明成虚函数？</h3><ul>
<li><strong>基类中的函数</strong>：如果函数在基类中定义，并且子类可能需要重写该函数以提供特定实现，那么该函数通常应该声明为虚函数。这样，在运行时可以根据对象的实际类型来调用适当的函数版本。</li>
<li><strong>用于多态行为</strong>：虚函数为多态提供了支持。当通过基类指针或引用调用虚函数时，实际上调用的是相应派生类的重写版本。这种多态行为使得代码更加灵活和可扩展。</li>
<li><strong>用于接口定义</strong>：在设计接口时，通常将接口中的函数声明为虚函数。这样，派生类可以根据自己的需求来实现这些接口函数，同时保持统一的接口定义。</li>
<li><strong>需要动态绑定</strong>：虚函数可以在运行时动态绑定到适当的函数版本。这种动态绑定对于实现运行时多态非常重要。</li>
</ul>
<h3 id="【-】88、模板类能不能有虚函数？类能不能模板成员函数为虚函数？"><a href="#【-】88、模板类能不能有虚函数？类能不能模板成员函数为虚函数？" class="headerlink" title="【*】88、模板类能不能有虚函数？类能不能模板成员函数为虚函数？"></a>【*】88、模板类能不能有虚函数？类能不能模板成员函数为虚函数？</h3><p><strong>模板类</strong>可以有虚函数。虽然单个模板类的实例化是静态的，但模板类本身可以包含虚函数。这样，在实例化特定类型的模板类时，这些虚函数将成为实例化类的一部分，并且可以通过基类指针进行多态调用。</p>
<p><strong>类</strong>不能有模板成员函数为虚函数。这是因为<strong>虚函数表需要在编译时确定，而模板成员函数是在实例化时生成代码的</strong>，因此编译器无法在编译时确定模板成员函数的虚函数表条目。</p>
<h3 id="【-】89、虚函数可以内联吗？"><a href="#【-】89、虚函数可以内联吗？" class="headerlink" title="【*】89、虚函数可以内联吗？"></a>【*】89、虚函数可以内联吗？</h3><ol>
<li><p>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时不可以内联。 </p>
</li>
<li><p><strong>inline virtual 唯一可以内联的时候</strong>是：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚函数静态调用</span></span><br><span class="line">pclass-&gt;<span class="keyword">class</span>::<span class="built_in">vf</span>()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 或者在类体内调用class::vf()，相当于this-&gt;class::vf()</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="90、虚函数表是一个-map-还是一个数组？"><a href="#90、虚函数表是一个-map-还是一个数组？" class="headerlink" title="90、虚函数表是一个 map 还是一个数组？"></a>90、虚函数表是一个 map 还是一个数组？</h3><p>虚函数表(vtable，虚方法表)在实现上通常是一个<strong>数组</strong>。这个表是一个编译时构建的数组，其中存储了指向类中所有虚函数的指针。</p>
<p><strong>为什么是数组，不是map？</strong></p>
<ol>
<li><p><strong>性能</strong>：数组**通过索引直接访问元素，访问时间为O(1)**，而map(通常实现为红黑树或哈希表)的访问时间可能是O(log n)或更复杂，取决于实现。因此，数组访问速度更快，适合频繁访问的场景，如虚函数的调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">flip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(<span class="type">const</span> Widget&amp; widget)</span> </span>&#123; </span><br><span class="line">    widget.<span class="built_in">flip</span>(); </span><br><span class="line">    <span class="comment">// widget.flip(); 的虚拟调用操作为： (*widget.vptr[1])(&amp;widget);</span></span><br><span class="line">    <span class="comment">//  1: flip()在vtbl中的索引</span></span><br><span class="line">    <span class="comment">//  &amp;widget: 某个实例的this指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内存布局</strong>：由于数组具有连续的内存布局特性，这有助于提高缓存的效率，从而加速虚函数的调用过程。</p>
</li>
</ol>
<h3 id="【-】91、虚表里除了可能有虚函数，还可能有什么？"><a href="#【-】91、虚表里除了可能有虚函数，还可能有什么？" class="headerlink" title="【*】91、虚表里除了可能有虚函数，还可能有什么？"></a>【*】91、虚表里除了可能有虚函数，还可能有什么？</h3><p>虚表中除了包含虚函数的指针外，还可能包含 <strong>RTTI 信息</strong>（Run-Time Type Identification），通过运行时类型信息程序能够使用基类的指针或引用来检查这些指针或引用所指的对象的实际派生类型。</p>
<h3 id="92、一个类中有几个虚函数表？一个类的对象有几个虚函数指针？"><a href="#92、一个类中有几个虚函数表？一个类的对象有几个虚函数指针？" class="headerlink" title="92、一个类中有几个虚函数表？一个类的对象有几个虚函数指针？"></a>92、一个类中有几个虚函数表？一个类的对象有几个虚函数指针？</h3><p>**每个类只有一个虚函数表(vtable)**，不管这个类有多少个虚函数。虚函数表存储了该类所有虚函数的地址。</p>
<p>**一个类的每个对象都有一个虚表指针(vptr)**，用于指向该类的虚函数表。这个指针位于对象的内存布局的最开始位置，即使没有声明任何虚函数，编译器也会为其分配空间。</p>
<h3 id="93、现在一个类在构造函数初始化的时候初始化了虚函数表，若通过-memset-将这个类全部赋值为-0，那这个虚表指针会被损坏，有什么办法恢复它吗？"><a href="#93、现在一个类在构造函数初始化的时候初始化了虚函数表，若通过-memset-将这个类全部赋值为-0，那这个虚表指针会被损坏，有什么办法恢复它吗？" class="headerlink" title="93、现在一个类在构造函数初始化的时候初始化了虚函数表，若通过 memset() 将这个类全部赋值为 0，那这个虚表指针会被损坏，有什么办法恢复它吗？"></a>93、现在一个类在构造函数初始化的时候初始化了虚函数表，若通过 memset() 将这个类全部赋值为 0，那这个虚表指针会被损坏，有什么办法恢复它吗？</h3><p><strong>没有直接的、安全的方法来恢复虚表指针</strong>。一旦虚表指针被覆盖或破坏，这个对象基本上就已经损坏，无法保证其后续行为的正确性。</p>
<p>可考虑<strong>重新构造对象</strong>。即，如果确实需要重置对象的状态，考虑使用对象的构造函数和析构函数来正确地构建和销毁对象。例如，<strong>可以先显式调用析构函数，然后使用 <code>placement new</code> 重新在原地构造一个新对象</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.~<span class="built_in">ClassName</span>();</span><br><span class="line"><span class="keyword">new</span> (&amp;obj) <span class="built_in">ClassName</span>();</span><br></pre></td></tr></table></figure>

<h3 id="94、一个类的虚表指针在类中的内存分布是怎样的？"><a href="#94、一个类的虚表指针在类中的内存分布是怎样的？" class="headerlink" title="94、一个类的虚表指针在类中的内存分布是怎样的？"></a>94、一个类的虚表指针在类中的内存分布是怎样的？</h3><p>一般在类内存的最前方。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Base object memory layout:</span><br><span class="line">-----------------------------</span><br><span class="line">| vptr (pointer to vtable) |</span><br><span class="line">-----------------------------</span><br><span class="line">| base_data                |</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Derived object memory layout:</span><br><span class="line">-----------------------------</span><br><span class="line">| vptr (pointer to vtable)  |  &lt;- Points to the `Derived` class vtable</span><br><span class="line">-----------------------------</span><br><span class="line">| base_data                 |</span><br><span class="line">-----------------------------</span><br><span class="line">| derived_data              |</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<blockquote>
<p>程序代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base foo&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base bar&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNum_Base</span> <span class="params">(<span class="type">int</span> a)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="type">int</span> base_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived foo&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived bar&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123; std::cout &lt;&lt; <span class="string">&quot;Derived destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNum_derived</span> <span class="params">(<span class="type">int</span> a)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="type">int</span> derived_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">bar</span>();</span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意：</p>
<p>出现在 dervied class 中的 base class subobject 有其完整原样性。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406191022541.png" alt="image-20240619102242541" style="zoom: 25%;" />
</blockquote>
<h3 id="95、虚表指针在什么时候创建？虚函数表在什么时候创建、存在在什么位置？"><a href="#95、虚表指针在什么时候创建？虚函数表在什么时候创建、存在在什么位置？" class="headerlink" title="95、虚表指针在什么时候创建？虚函数表在什么时候创建、存在在什么位置？"></a>95、虚表指针在什么时候创建？虚函数表在什么时候创建、存在在什么位置？</h3><ol>
<li><p><strong>虚表指针在什么时候创建？</strong></p>
<ul>
<li><p>虚表指针在构造函数执行过程中被创建。具体来说，是在基类构造函数的调用之后，而在自己的成员列表初始化之前。</p>
</li>
<li><p>基类和派生类的<strong>构造函数负责设置 vptr 指向相应类的虚函数表</strong>。如果对象是派生类的实例，派生类的构造函数将确保 vptr 指向派生类的虚函数表。</p>
</li>
</ul>
</li>
<li><p><strong>虚函数表在什么时候创建、存在在什么位置？</strong></p>
<ul>
<li><p>编译器在<strong>编译期间</strong>生成虚函数表(vtable)，虚函数表包含类的所有虚函数的地址。每个定义了虚函数的类都有一个虚函数表，派生类可能会覆盖基类中的虚函数。如果派生类覆盖了基类的虚函数，派生类的虚函数表中对应的条目会被更新为指向派生类中的虚函数。否则，派生类的虚函数表中会保留一个指向基类虚函数的指针。</p>
</li>
<li><p>虚函数表存储在程序的**只读数据段(.rodata)<strong>，这是因为虚函数表在编译时就已经确定，运行时不会修改。虚表中的指针再指向</strong>代码段(.text)**的函数代码。</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含虚函数时的 copy constructor 操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZooAnimal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZooAnimal</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ZooAnimal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">animate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> ZooAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bear</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">animate</span><span class="params">()</span></span>;  <span class="comment">// virtual</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// yogihui被default Bear contructor初始化，</span></span><br><span class="line">    <span class="comment">// 其vptr设定指向Bear class的vtbl</span></span><br><span class="line">    Bear yogi;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// franny被copy Bear constructor初始化，</span></span><br><span class="line">    <span class="comment">// 但其vptr会被设定指向ZooAnimal class的vtbl，而不是Bear class</span></span><br><span class="line">    ZooAnimal franny = yogi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="96、抽象类和普通虚函数类的区别是什么？"><a href="#96、抽象类和普通虚函数类的区别是什么？" class="headerlink" title="96、抽象类和普通虚函数类的区别是什么？"></a>96、抽象类和普通虚函数类的区别是什么？</h3><ol>
<li>抽象类<strong>至少包含一个纯虚函数</strong>，其不能被直接实例化，必须让派生类继承并实现其纯虚函数；</li>
<li>普通虚函数类<strong>可以包含一个或多个虚函数</strong>，这些虚函数在基类中有具体的实现，但可以在派生类中被重写。可以被直接实例化。</li>
</ol>
<h3 id="97、如何设计一个不能继承的类？"><a href="#97、如何设计一个不能继承的类？" class="headerlink" title="97、如何设计一个不能继承的类？"></a>97、如何设计一个不能继承的类？</h3><ol>
<li>在 C++11 及更高版本中，可以在类声明中<strong>使用 final 关键字</strong>来防止类被继承；</li>
<li>在 C++11 之前，一个常用的技巧是<strong>将构造函数声明为私有或受保护的，并通过静态方法返回实例</strong>。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数，禁止直接实例化</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance created.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一的实例指针</span></span><br><span class="line">    <span class="type">static</span> std::unique_ptr&lt;Singleton&gt; instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态方法，用于获取单例实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Singleton</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="98、父类用-private-修饰的变量，使用多态后能不能访问到这个变量呢？"><a href="#98、父类用-private-修饰的变量，使用多态后能不能访问到这个变量呢？" class="headerlink" title="98、父类用 private 修饰的变量，使用多态后能不能访问到这个变量呢？"></a>98、父类用 private 修饰的变量，使用多态后能不能访问到这个变量呢？</h3><p>在 C++ 中，如果父类中的变量被声明为 <code>private</code>，那么这些变量只能被该父类自己的成员函数、友元函数或者同一个类的其他实例访问。即使在继承的情况下，子类是无法直接访问父类的私有成员变量的。</p>
<h3 id="99、假设一个类继承了有虚函数的类，父类会存在在子类中吗？"><a href="#99、假设一个类继承了有虚函数的类，父类会存在在子类中吗？" class="headerlink" title="99、假设一个类继承了有虚函数的类，父类会存在在子类中吗？"></a>99、假设一个类继承了有虚函数的类，父类会存在在子类中吗？</h3><ol>
<li>子类中包含父类的数据成员；</li>
<li>如果子类没有父类的虚函数进行重写，那么子类的虚表指针所指向的虚表中，会存在父类的虚函数；否则，会用子类重写后虚函数进行替代。</li>
</ol>
<h3 id="100、虚拟继承是什么？"><a href="#100、虚拟继承是什么？" class="headerlink" title="100、虚拟继承是什么？"></a>100、虚拟继承是什么？</h3><p>虚继承是一种特殊的继承方式，用于解决菱形继承中的问题。在菱形继承结构中，一个基类通过多个路径被继承多次，可能导致该基类的成员在最终派生类中出现多份拷贝。虚基类的引入可以保证基类子对象在最终派生类中只有一份，从而避免这种重复。</p>
<p>一般的实现方法如下所述。class 如果内含一个或多个 虚基类子对象(virtual base class subobject)，将被分割为两部分：一个<strong>不变区域</strong>和一个<strong>共享区域</strong>。不变区域中的数据，不管后继如何衍化，总是拥有固定的 offset，所以这一部分数据可以被直接存储；<strong>至于共享区域，所表现的就是 virtual base class subobject，其位置会因为派生的操作而变化，所以只能间接存取</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B， <span class="keyword">public</span> C &#123;</span><br><span class="line">    <span class="comment">// D中只有一份A的成员data</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="101、说一下重载，覆盖和隐藏的区别？"><a href="#101、说一下重载，覆盖和隐藏的区别？" class="headerlink" title="101、说一下重载，覆盖和隐藏的区别？"></a>101、说一下重载，覆盖和隐藏的区别？</h3><p>(1)<strong>重载(Overloading)<strong>发生</strong>在同一个作用域内</strong>，当两个或更多具有相同名称但参数列表不同的函数共存时，这些函数被称为重载函数。</p>
<p>(2)<strong>覆盖(Overriding)<strong>是面向对象编程中的一个特性，指的是</strong>在派生类中重新定义基类中的虚函数</strong>。覆盖的主要目的是实现多态。派生类的函数覆盖了基类的函数，当通过基类的指针或引用调用该函数时，会根据对象的实际类型来调用相应的函数。</p>
<p>(3)**隐藏(Hiding)<strong>发生在继承关系中，当</strong>派生类中声明了与基类同名的成员(函数或变量)**时，无论参数列表是否相同，基类中的同名成员都会被派生类中的成员隐藏。</p>
<h3 id="102、函数重载在编译期间的实现原理-（符号重命名，加上类型）？"><a href="#102、函数重载在编译期间的实现原理-（符号重命名，加上类型）？" class="headerlink" title="102、函数重载在编译期间的实现原理 （符号重命名，加上类型）？"></a>102、函数重载在编译期间的实现原理 （符号重命名，加上类型）？</h3><p>函数重载在编译期间的实现原理主要依靠“名称改编”（name mangling）。具体过程如下：</p>
<ol>
<li><strong>名称改编</strong>：编译器将函数名与其参数类型组合成一个唯一的标识符。这解决了多个同名函数的问题，使得编译器可以区分不同的重载版本。</li>
<li><strong>符号表</strong>：编译器在符号表中记录这些唯一标识符。当调用函数时，编译器根据参数类型查找匹配的标识符。</li>
<li><strong>类型检查</strong>：编译器在调用函数时，会检查传递的参数类型与符号表中的记录，以确保调用正确的函数版本。</li>
</ol>
<h3 id="103、多继承问题，如果有公共父类时调用函数产生二义性的情况下，怎么办？"><a href="#103、多继承问题，如果有公共父类时调用函数产生二义性的情况下，怎么办？" class="headerlink" title="103、多继承问题，如果有公共父类时调用函数产生二义性的情况下，怎么办？"></a>103、多继承问题，如果有公共父类时调用函数产生二义性的情况下，怎么办？</h3><p>在多继承中，如果有公共父类并调用函数时产生二义性，可以通过以下方法解决：</p>
<ol>
<li><strong>作用域解析运算符</strong>：使用类名和作用域解析运算符 (<code>::</code>) 指定调用哪个父类的函数。例如，<code>Base1::function()</code>。</li>
<li><strong>虚继承</strong>：使用虚继承（<code>virtual</code> 关键字）来确保公共父类只在派生类中存在一个实例，避免二义性。</li>
</ol>
<h3 id="104、多重继承下的内存分布如何？"><a href="#104、多重继承下的内存分布如何？" class="headerlink" title="104、多重继承下的内存分布如何？"></a>104、多重继承下的内存分布如何？</h3><p>对于一个多重派生对象：</p>
<ol>
<li>将其地址指定给<strong>第一个 base class</strong> 的指针，情况将和单一继承时相同，因为二者都指向相同的起始地址。</li>
<li>至于<strong>第二个或后继的 base class</strong> 的地址指定操作，则需要对地址进行修改：加上或减去位于中间的 base class subobject(s) 的大小。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 考虑将 vptr 放在 class object 的起始处</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point2d</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 包含virtual接口，因此Point2的对象中包含vptr</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3d</span> : <span class="keyword">public</span> Point2d &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 包含virtual接口，因此Vertex的对象中包含vptr</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex3d</span> : <span class="keyword">public</span> Point3d， <span class="keyword">public</span> Vertex &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vertex3d v3d;</span><br><span class="line">    Vertex *pv;     </span><br><span class="line">    Point2d *p2d;   </span><br><span class="line">    Point3d *p3d;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    pv = &amp;v3d;      <span class="comment">// 内部转化：pv = (Vertex*)(((char*)&amp;v3d) + sizeof(Point3d));</span></span><br><span class="line">    p2d = &amp;v3d;     <span class="comment">// 无需内部转化</span></span><br><span class="line">    p3d = &amp;v3d;     <span class="comment">// 无需内部转化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    Vertex3d *pv3d;</span><br><span class="line">    Vertex *pv1;</span><br><span class="line"></span><br><span class="line">    pv1 = pv3d;     <span class="comment">// 内部转化：pv1 = pv3d ? (Vertex*)(((char*)&amp;pv3d) + sizeof(Point3d)) : 0;</span></span><br><span class="line">                    <span class="comment">// 对于指针，内部需要有一个条件测试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="105、多重继承下，如果其中有继承一个虚基类，构造函数的调用情况如何？"><a href="#105、多重继承下，如果其中有继承一个虚基类，构造函数的调用情况如何？" class="headerlink" title="105、多重继承下，如果其中有继承一个虚基类，构造函数的调用情况如何？"></a>105、多重继承下，如果其中有继承一个虚基类，构造函数的调用情况如何？</h3><p><strong>只有当一个完整的 class object 被定义出来时，虚基类的构造函数才会被调用；如果 object 只是某个完整 object 的一个 subobject，就不会被调用(即相当于下方例子中 A 的构造函数不会在B 和 C 的实例化过程中被重复调用)。</strong></p>
<p>虚基类的构造函数仅在创建最派生类(即最终实例化的类)对象时才会被调用，而不会在创建其间接派生类对象时重复调用。</p>
<ul>
<li>完整对象(Complete Object)：指一个通过某个类直接实例化出来的对象。</li>
<li>子对象(Subobject)：指一个对象中的组成部分，可能是一个基类子对象或者是一个成员对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123; <span class="keyword">public</span>: <span class="built_in">B</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123; <span class="keyword">public</span>: <span class="built_in">C</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B， <span class="keyword">public</span> C &#123; <span class="keyword">public</span>: <span class="built_in">D</span>() &#123;&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   D d;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>main</code> 函数中创建一个 <strong>D</strong> 类的对象时，会发生以下调用顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A&#x27;s constructor</span><br><span class="line">B&#x27;s constructor</span><br><span class="line">C&#x27;s constructor</span><br><span class="line">D&#x27;s constructor</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A’s constructor：</strong>A 的构造函数首先被调用，因为 A 是一个虚基类。虚基类的构造函数只会在最派生类(即 D)实例化时调用一次。</li>
<li><strong>B’s constructor 和 C’s constructor：</strong>接下来，调用 B 和 C 的构造函数。尽管 B 和 C 都继承自 A，由于虚继承机制，A 的构造函数不会在每个子对象实例化时被重复调用。</li>
<li><strong>D’s constructor：</strong>最后，调用 D 的构造函数。</li>
</ul>
<h3 id="106、public，protect，private-在访问和继承时？"><a href="#106、public，protect，private-在访问和继承时？" class="headerlink" title="106、public，protect，private 在访问和继承时？"></a>106、public，protect，private 在访问和继承时？</h3><ul>
<li><p>在<strong>访问</strong>时：</p>
<ul>
<li><p>public 在类内部和外部均可访问；</p>
</li>
<li><p>protected 在内部可以被访问，外部不可访问；</p>
</li>
<li><p>private 在内部可以被访问，外部不可访问；</p>
</li>
</ul>
</li>
<li><p>在<strong>继承</strong>时：</p>
<ul>
<li><p>类中的成员可以分为三种类型，分别为 public 成员、protected 成员和 private 成员。<strong>类中可以直接访问自己类的 public、protected 和 private 成员，但类对象只能访问自己类的 public 成员。</strong></p>
<ol>
<li><p><strong>public 继承</strong>：<strong>派生类</strong>可以访问基类的 public、protected 成员，不可以访问基类的 private 成员；<br><strong>派生类对象</strong>可以访问基类的 public 成员，不可以访问基类的 protected、private 成员。</p>
</li>
<li><p><strong>protected 继承</strong>：<strong>派生类</strong>可以访问基类的 public、protected 成员，不可以访问基类的 private 成员；<br> <strong>派生类对象</strong>不可以访问基类的 public、protected、private 成员。</p>
</li>
<li><p><strong>private 继承</strong>：<strong>派生类</strong>可以访问基类的 public、protected 成员，不可以访问基类的 private 成员；<br><strong>派生类对象</strong>不可以访问基类的 public、protected、private 成员。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="107、继承的三种方式？"><a href="#107、继承的三种方式？" class="headerlink" title="107、继承的三种方式？"></a>107、继承的三种方式？</h3><ol>
<li><p>**公有继承(public inheritance)**：</p>
<ul>
<li><p>在公有继承中，基类的公有成员和保护成员都会成为派生类的公有成员和保护成员，而基类的私有成员仍然是私有的，不能被派生类直接访问。</p>
</li>
<li><p>公有继承实现了基类到派生类的接口继承，派生类可以使用基类的接口。</p>
</li>
</ul>
</li>
<li><p>**保护继承(protected inheritance)**：</p>
<ul>
<li>在保护继承中，基类的公有成员和保护成员都会成为派生类的保护成员，而基类的私有成员仍然是私有的，不能被派生类直接访问。</li>
<li>保护继承一般用于实现 is-a 关系，但不希望外部直接访问基类的接口，而是通过派生类进行访问。</li>
</ul>
</li>
<li><p>**私有继承(private inheritance)**：</p>
<ul>
<li>在私有继承中，基类的公有成员和保护成员都会成为派生类的私有成员，而基类的私有成员仍然是私有的，不能被派生类直接访问。</li>
<li>私有继承一般用于实现 has-a 关系，派生类可以访问基类的接口，但外部无法直接访问派生类。</li>
</ul>
</li>
</ol>
<h2 id="七、STL相关"><a href="#七、STL相关" class="headerlink" title="七、STL相关"></a>七、STL相关</h2><h3 id="108、C-的-STL-介绍"><a href="#108、C-的-STL-介绍" class="headerlink" title="108、C++ 的 STL 介绍"></a>108、C++ 的 STL 介绍</h3><p>STL ⼀共提供六大组件，包括容器，算法，迭代器，仿函数，配接器和配置器，彼此可以组合套用。容器通过配置</p>
<p>器取得数据存储空间，算法通过迭代器存取容器内容，仿函数可以协助算法完成不同的策略变化，配接器可以应用</p>
<p>于容器、 仿函数和迭代器。</p>
<ul>
<li><strong>容器：</strong>各种数据结构，如 vector，list，deque，set，map，用来存放数据， 从实现的角度来讲是⼀种类模板。</li>
<li><strong>算法：</strong>各种常用的算法，如 sort(插⼊，快排，堆排序)，search(⼆分查找)， 从实现的角度来讲是⼀种方法模板。</li>
<li><strong>迭代器：</strong>从实现的角度来看，迭代器是⼀种将 operator*、operator-&gt;、operator++ 和 operator– 等指针相关操作赋予重载的类模板，所有的 STL 容器都有⾃⼰的迭代器。</li>
<li><strong>仿函数：</strong>从实现的角度看，仿函数是⼀种重载了 operator() 的类或者类模板。 可以帮助算法实现不同的策略。</li>
<li><strong>配接器：</strong>⼀种用来修饰容器或者仿函数或迭代器接口的东⻄。</li>
<li><strong>配置器：</strong>负责空间配置与管理，从实现的角度讲，配置器是⼀个实现了动态空间配置、空间管理，空间释放的类模板。</li>
</ul>
<h3 id="109、STL-中序列式容器的实现"><a href="#109、STL-中序列式容器的实现" class="headerlink" title="109、STL 中序列式容器的实现"></a>109、<strong>STL</strong> <strong>中序列式容器的实现</strong></h3><p>(1)<strong>vector</strong>是动态空间，随着元素的加⼊，它的内部机制会⾃行扩充空间以容纳新元素。vector 维护的是⼀个连续的线性空间，而且普通指针就可以满⾜要求作为 vector 的迭代器(RandomAccessIterator)。vector 的数据结构中其实就是三个迭代器构成的，<strong>⼀个指向目前使用空间头的 iterator，⼀个指向目前使用空间尾的 iterator，⼀个指向目前可用空间尾的 iterator</strong>。当有新的元素插⼊时，如果目前容量够用则直接插⼊，如果容量不够，则容量扩充至两倍，如果两倍容量不⾜， 就扩张至⾜够大的容量。扩充的过程并不是直接在原有空间后⾯追加容量，而是重新申请⼀块连续空间，将原有的数据拷贝到新空间中，再释放原有空间，完成⼀次扩充。需要注意的是，每次扩充是重新开辟的空间，所以扩充后，原有的迭代器将会失效。</p>
<p>(2)<strong>list</strong>，与 vector 相比，list 的好处就是每次插⼊或删除⼀个元素，就配置或释放⼀个空间，而且原有的迭代器也不会失效。STL list 是⼀个双向链表，普通指针已经不能满⾜ list 迭代器的需求，因为 list 的存储空间是不连续的。list 的迭代器必需具备前移和后退功能，所以 list 提供的是 BidirectionalIterator。list 的数据结构中只要⼀个指向 node 节点的指针就可以了。</p>
<p>(3)<strong>deque</strong>，vector 是单向开口的连续线性空间，deque 则是⼀种双向开口的连续线性空间。所谓双向开口，就是说 deque ⽀持从头尾两端进行元素的插⼊和删除操作。相比于 vector 的扩充空间的方式，deque 实际上更加贴切的实现了动态空间的概念。deque 没有容量的概念，因为它是动态地以分段连续空间组合而成，随时可以增加⼀段新的空间并连接起来。由于要维护这种整体连续的假象，并提供随机存取的接口(即也提供 RandomAccessIterator)，避开了“重新配置，复制，释放”的轮回，代价是复杂的迭代器结构。也就是说除⾮必要，我们应该尽可能的使用 vector，而不是 deque。</p>
<p>(4)<strong>stack</strong>是⼀种先进后出的数据结构，只有⼀个出口，stack 允许从最顶端新增元素，移除最顶端元素，取得最顶端元素。deque 是双向开口的数据结构，所以使用 deque 作为底部结构并封闭其头端开口，就形成了⼀个 stack。</p>
<p>(5)<strong>queue</strong>是⼀种先进先出的数据结构，有两个出口，允许从最底端加⼊元素，取得最顶端元素，从最底端新增元素，从最顶端移除元素。deque 是双向开口的数据结构，若以 deque 为底部结构并封闭其底端的出口，和头端的⼊口，就形成了⼀个 queue。(其实 list 也可以实现 deque)</p>
<p>(6)<strong>heap</strong>，堆并不属于 STL 容器组件，它是个幕后英雄，扮演 priority_queue 的助⼿，priority_queue 允许用户以任何次序将任何元素推⼊容器内，但取出时⼀定是从优先权最⾼(数值最⾼)的元素开始取。大根堆(binary max heap)正具有这样的性质，适合作为 priority_queue 的底层机制。</p>
<h3 id="110、vector-使用的注意点及其原因，频繁对-vector-调用-push-back-性能影响"><a href="#110、vector-使用的注意点及其原因，频繁对-vector-调用-push-back-性能影响" class="headerlink" title="110、vector **使用的注意点及其原因，频繁对 **vector 调用 push_back() 性能影响"></a>110、vector **使用的注意点及其原因，频繁对 **vector 调用 push_back() 性能影响</h3><p><strong>（1）使用注意点：</strong></p>
<p>注意插⼊和删除元素后迭代器失效的问题；</p>
<p>清空 vector 数据时，如果保存的数据项是指针类型，需要逐项 delete，否则会造成内存泄漏。</p>
<p><strong>（2）频繁调用 push_back() 的影响：</strong></p>
<p>向 vector 的尾部添加元素，很有可能引起整个对象 存储空间的重新分配，重新分配更大的内存，再将原数据拷贝到新空间中，再释 放原有内存，这个过程是耗时耗⼒的，频繁对 vector 调用 push_back()会导致性能的下降。</p>
<p>在 C++11 之后， vector 容器中添加了新的方法： emplace_back() ，和 push_back() ⼀样的是都是在容器末尾添加⼀个新的元素进去，不同的是 emplace_back() 在效率上相比较于 push_back() 有了⼀定的提升。</p>
<p>emplace_back() 函数在原理上比 push_back() 有了⼀定的改进，包括在内存优化方⾯和运行效率方⾯。内存优化主要体现在使用了<strong>就地构造(直接在容器内构造对象，不用拷贝⼀个复制品再使用)+ 强制类型转换</strong>的方法来实现，在运行效率方⾯，由于省去了拷贝构造过程，因此也有⼀定的提升。</p>
<h3 id="111、map-和-set-有什么区别，分别又是怎么实现的？"><a href="#111、map-和-set-有什么区别，分别又是怎么实现的？" class="headerlink" title="111、map 和 set 有什么区别，分别又是怎么实现的？"></a><strong>111、map</strong> <strong>和</strong> <strong>set</strong> <strong>有什么区别，分别又是怎么实现的？</strong></h3><p>map 和 set 都是 C++ 的关联容器，其底层实现都是红⿊树(RB-Tree)。由于 map 和 set 所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和 set 的操作行为，都只是转调 RB-tree 的操作行为。</p>
<p>map 和 set 区别在于：</p>
<p>(1)map 中的元素是 key-value(关键字—值)对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set 中每个元素只包含⼀个关键字。</p>
<p>(2)set 的迭代器是 const 的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么⾸先需要删除该键，然后调节平衡，再插⼊修改后的键值，调节平衡，如此⼀来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</p>
<p>(3)map⽀持下标操作，set不⽀持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插⼊⼀个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某⼀个关键值是否存在而不希望插⼊元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。</p>
<h3 id="112、STL-中迭代器失效的情况有哪些？"><a href="#112、STL-中迭代器失效的情况有哪些？" class="headerlink" title="112、STL 中迭代器失效的情况有哪些？"></a>112、STL 中迭代器失效的情况有哪些？</h3><p>以 vector 为例：</p>
<p><strong>插入元素：</strong></p>
<p>1、尾后插入：</p>
<ul>
<li>size &lt; capacity时，首迭代器不失效，但尾迭代失效（未重新分配空间）；</li>
<li>size &#x3D;&#x3D; capacity时，所有迭代器均失效（需要重新分配空间）。</li>
</ul>
<p>2、中间插入：</p>
<ul>
<li>size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效；</li>
<li>size &#x3D;&#x3D; capacity时，所有迭代器均失效。</li>
</ul>
<p><strong>删除元素：</strong></p>
<p>1、尾后删除：只有尾迭代失效。</p>
<p>2、中间删除：删除位置之后所有迭代失效。</p>
<blockquote>
<p>deque 和 vector 的情况类似。</p>
<p>而 list 中节点内存不连续，删除节点仅当前迭代器失效，因此 erase 返回下一个有效迭代器;</p>
<p>map&#x2F;set 等关联容器的底层是红黑树，删除节点不会影响其他节点的迭代器，因此使用递增方法获取下一个迭代器 mmp.erase(iter++);</p>
<p>unordered_(hash) 迭代器意义不大，rehash之后，迭代器应该也是全部失效。</p>
</blockquote>
<h3 id="113、请你来说⼀下-STL-中迭代器的作用，有指针为何还要迭代器？"><a href="#113、请你来说⼀下-STL-中迭代器的作用，有指针为何还要迭代器？" class="headerlink" title="113、请你来说⼀下 STL 中迭代器的作用，有指针为何还要迭代器？"></a>113、请你来说⼀下 <strong>STL</strong> <strong>中迭代器的作用，有指针为何还要迭代器</strong>？</h3><p>（1）<strong>迭代器</strong></p>
<p>Iterator(迭代器)模式又称 Cursor(游标)模式，用于提供⼀种方法顺序访问⼀个聚合对象中各个元素，而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator 模式是运用于聚合对象的⼀种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照⼀定顺序(由 iterator 提供的方法)访问聚合对象中的各个元素。</p>
<p>由于 Iterator 模式的以上特性：与聚合对象耦合，在⼀定程度上限制了它的⼴泛运用，⼀般仅用于底层聚合⽀持类，如 STL 的 list、vector、stack 等容器类及 ostream_iterator 等扩展 iterator。</p>
<p>（2）<strong>迭代器和指针的区别</strong></p>
<p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的⼀些功能，通过重载了指针的⼀些操作符<code>-&gt; 、*、++、-- </code>等。迭代器封装了指针，是⼀个“可遍历STL( Standard Template Library)容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的⼀种提升(lift)，提供了比指针更⾼级的行为，相当于⼀种智能指针，他可以根据不同类型的数据结构来实现不同的 ++，– 等操作。迭代器返回的是对象引用而不是对象的值，所以 cout 只能输出迭代器使用<code>*</code>取值后的值而不能直接输出其⾃身。</p>
<p>（3）<strong>迭代器产生原因</strong></p>
<p>Iterator 类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p>
<h3 id="115、STL-里-resize-和-reserve-的区别"><a href="#115、STL-里-resize-和-reserve-的区别" class="headerlink" title="115、STL 里 resize 和 reserve 的区别"></a>115、STL 里 <strong>resize</strong> <strong>和</strong> <strong>reserve</strong> 的区别</h3><p>**resize()**：改变当前容器内含有元素的数量(size())，eg: <code>vectorv; v.resize(len);</code>v 的 size 变为 len，如果原来 v 的 size ⼩于len，那么容器新增(len-size)个元素，元素的值为默认为0.当 <code>v.push_back(3);</code> 之后，则是 3 是放在了 v 的末尾，即下标为 len，此时容器是 size 为 len+1；</p>
<p>**reserve()**：改变当前容器的最大容量(capacity)，它不会生成元素，只是确定这个容器允许放⼊多少对象，如果 reserve(len) 的值大于当前的 capacity()，那么会重新分配⼀块能存 len 个对象的空间，然后把之前 v.size() 个对象通过 copy construtor 复制过来，销毁之前的内存；</p>
<h3 id="116、vector-的扩容原理是怎样的？"><a href="#116、vector-的扩容原理是怎样的？" class="headerlink" title="116、vector 的扩容原理是怎样的？"></a>116、vector 的扩容原理是怎样的？</h3><p>当向 vector 中插入元素时，如果元素有效个数 size 与空间容量 capacity 相等时，vector 内部会触发扩容机制：</p>
<ol>
<li>开辟新空间；</li>
<li>拷贝元素；</li>
<li>释放旧空间。</li>
</ol>
<p>如果要避免扩容而导致程序效率过低问题，其实非常简单：<strong>如果在插入之前，可以预估vector存储元素的个数，提前将底层容量开辟好即可。</strong>如果插入之前进行 reserve，只要空间给足，则插入时不会扩容，如果没有 reserve，则会边插入边扩容，效率极其低下。</p>
<p>一般采用 1.5 倍的方式扩容，这是因为<strong>理想的分配方案是在第 N 次扩容时能复用之前 N-1 次释放的空间。</strong></p>
<ul>
<li>如果倍数<strong>超过2倍(包含2倍)方式</strong>扩容会存在以下问题：1)空间浪费可能会比较高，比如：扩容后申请了64个空间，但只存了33个元素，有接近一半的空间没有使用；2)无法使用到前面已释放的内存；</li>
<li>但是按照<strong>小于2倍方式</strong>扩容，多次扩容之后就可以复用之前释放的空间了**。</li>
</ul>
<p>综上所述，使用 1.5 倍的方式扩容时，在几次扩展以后，可以重用之前的内存空间了。<strong>Linux 下是按照2倍的方式扩容的，而 vs 下是按照1.5倍的方式扩容的</strong>。</p>
<h3 id="117、vector-最大的缺点是什么？"><a href="#117、vector-最大的缺点是什么？" class="headerlink" title="117、vector 最大的缺点是什么？"></a>117、vector 最大的缺点是什么？</h3><p>当 <code>std::vector</code> 的元素数量超过其当前容量时，它需要进行扩容，这通常涉及到申请一个更大的内存块，将现有元素复制到新的内存块中，然后释放原来的内存块。1)在扩容过程中，<strong>新旧两块内存会暂时同时存在</strong>，这可能导致内存使用翻倍，对于内存敏感的应用或在内存受限的环境中，这可能成为一个问题，尤其是当 <code>vector</code> 中存储的对象较大或复制开销较大时；2)同时，<strong>频繁的增加和删除操作可能导致内存碎片</strong>。</p>
<h3 id="118、vector、array-和普通数组的区别是什么？"><a href="#118、vector、array-和普通数组的区别是什么？" class="headerlink" title="118、vector、array 和普通数组的区别是什么？"></a>118、vector、array 和普通数组的区别是什么？</h3><p>(1)<strong>vector</strong> 是动态数组，在进行删除和插入操作时可能需要移动其他元素，内存连续存储，且支持随机访问；</p>
<p>(2)<strong>array</strong> 是静态数组，在编译时确定大小，内存连续存储，且支持随机访问；</p>
<p>(4)<strong>普通数组</strong>在编译时确定大小，且不能直接获取数组的长度，传递数组时，实际上是传递指向数组首元素的指针。</p>
<p>(5)对于一个含有 n 个 int 类型元素的数组 a：</p>
<ul>
<li>如果 <code>a</code> 是一个普通数组，则 <code>sizeof(a)</code> 将返回整个数组的大小，即 <code>n * sizeof(int)</code> 字节。</li>
<li>如果 <code>a</code> 是 <code>std::array&lt;int， n&gt;</code> 类型的对象，则 <code>sizeof(a)</code> 将返回整个 <code>std::array</code> 对象的大小，包括数组的大小信息等。通常情况下，<code>sizeof(std::array&lt;int， n&gt;)</code> 将等于 <code>n * sizeof(int)</code> 字节加上额外的固定大小开销。</li>
</ul>
<h3 id="119、数组和链表的区别是什么？"><a href="#119、数组和链表的区别是什么？" class="headerlink" title="119、数组和链表的区别是什么？"></a>119、数组和链表的区别是什么？</h3><p>(1)数组元素的<strong>个数</strong>是固定的，而链表结点的<strong>个数</strong>可按需增减；</p>
<p>(2)数组元素的<strong>存储单元</strong>在数组定义时分配，而链表结点的<strong>存储单元</strong>在程序执行时动态申请；</p>
<p>(3)数组元素的<strong>顺序关系</strong>由下标确定，而链表结点的<strong>顺序关系</strong>由结点所包含的指针确定；</p>
<p>(4)对于<strong>元素频繁操作的处理场合</strong>，用链表实现会比数组实现更加有效率。比如在数组中删除一个元素时，需要将删除处之后的所有元素全部前移一个位置；但对于链表来说，只需要改变删除处相关结点的指针指向，而与结点实际的存储位置无关。</p>
<h3 id="120、为什么-list-不能用-sort-，而要用自己的-sort-？"><a href="#120、为什么-list-不能用-sort-，而要用自己的-sort-？" class="headerlink" title="120、为什么 list 不能用 ::sort()，而要用自己的 sort()？"></a>120、为什么 list 不能用 ::sort()，而要用自己的 sort()？</h3><p>因为全局 sort() 函数只接受 RandomAccessIterator，但对于 list 来说，由于在 STL 中它是双向链表，指向一块不连续的内存空间，因此其迭代器是 BidirectionIterator，因此必须要用自己的 sort()。</p>
<h3 id="121、数组通过外部声明为指针时，数组和指针是不能互换使用的；那么请思考一下，在-A-文件中定义数组-char-a-100-；在-B-文件中声明为指针：extern-char-a；此时访问-a-i-，会发生什么；"><a href="#121、数组通过外部声明为指针时，数组和指针是不能互换使用的；那么请思考一下，在-A-文件中定义数组-char-a-100-；在-B-文件中声明为指针：extern-char-a；此时访问-a-i-，会发生什么；" class="headerlink" title="121、数组通过外部声明为指针时，数组和指针是不能互换使用的；那么请思考一下，在 A 文件中定义数组 char a[100]；在 B 文件中声明为指针：extern char *a；此时访问 a[i]，会发生什么；"></a>121、数组通过外部声明为指针时，数组和指针是不能互换使用的；那么请思考一下，在 A 文件中定义数组 char a[100]；在 B 文件中声明为指针：extern char *a；此时访问 a[i]，会发生什么；</h3><p>会引起 <strong>segmentation fault</strong> 报错。链接器实际上将数组的首地址赋给了指针本身，而不是我们所希望的把数组的首地址赋予指针 a 所指向的内容。原因在于<strong>使用 extern 修饰的变量在链接的时候只找寻同名的标号，不检查类型，在链接时才进行定位，所以会导致编译通过，运行时出错</strong>。</p>
<p>首先涉及到数组和指针的区别：<strong>可以将数组名看做是右值，而指针作为变量，只能看作为左值。</strong> <strong>右值永远不等于左值，所以将指针赋予数组名是不合法的。即</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>&#125;;  <span class="comment">// 声明一个包含三个整数的数组</span></span><br><span class="line">    <span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]; <span class="comment">// 分配一个新的整数数组，并将其地址赋值给指针</span></span><br><span class="line">    <span class="comment">// 尝试将指针赋值给数组名(不合法)</span></span><br><span class="line">    arr = ptr;</span><br><span class="line">    <span class="keyword">delete</span>[] ptr; <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="122、map-的实现包含哪些方式？具体应该如何选择？"><a href="#122、map-的实现包含哪些方式？具体应该如何选择？" class="headerlink" title="122、map 的实现包含哪些方式？具体应该如何选择？"></a>122、map 的实现包含哪些方式？具体应该如何选择？</h3><ul>
<li><code>std::map</code>：通常使用<strong>红黑树</strong>实现，保证了元素按照键的排序，适合需要有序数据的场景。</li>
<li><code>std::unordered_map</code>：使用<strong>哈希表</strong>实现，不保证元素的有序性，但在许多操作上提供了较快的执行时间。</li>
</ul>
<p>因此，(1)如果应用中需要一个<strong>通过键快速访问数据项且不关心元素间的顺序</strong>的关联容器，<code>std::unordered_map</code> 是一个更好的选择；(2)而如果<strong>需要有序的键值对</strong>，维护元素的插入顺序，或需要进行范围查询，那么 <code>std::map</code> 是更合适的选择。</p>
<h3 id="123、map-的插入方式有几种？"><a href="#123、map-的插入方式有几种？" class="headerlink" title="123、map 的插入方式有几种？"></a>123、map 的插入方式有几种？</h3><ol>
<li>用 insert 函数插入 pair 数据，</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>)); </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>用 insert 函数插入 value_type 数据</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapStudent.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 insert 函数中使用 make_pair() 函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>)); </span><br></pre></td></tr></table></figure>

<ol start="4">
<li>用数组方式插入数据</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapStudent[<span class="number">1</span>] = <span class="string">&quot;student_one&quot;</span>; </span><br></pre></td></tr></table></figure>

<h3 id="124、C-常见的容器有哪些，可以分成几大类？"><a href="#124、C-常见的容器有哪些，可以分成几大类？" class="headerlink" title="124、C++ 常见的容器有哪些，可以分成几大类？"></a>124、C++ 常见的容器有哪些，可以分成几大类？</h3><ol>
<li>**顺序容器(Sequence Containers)**：元素按照它们在容器中的位置顺序排列，包括：vector、deque、list、forward_list 和 array。</li>
<li>**关联容器(Associative Containers)**：元素按照某种顺序存储，并且支持高效的查找操作，包括：set、multiset、map 和 multimap。</li>
<li>**无序容器(Unordered Containers)**：元素无特定顺序排列，但支持快速的插入、删除和查找操作，包括：unordered_set、unordered_multiset、unordered_map 和 unordered_multimap。</li>
<li>**容器适配器(Container Adapters)**：容器适配器是在底层容器基础上提供了不同接口的封装，包括：stack、queue 和 priority_queue。</li>
</ol>
<h3 id="125、STL-的两级空间配置器相关"><a href="#125、STL-的两级空间配置器相关" class="headerlink" title="125、STL 的两级空间配置器相关"></a>125、STL 的两级空间配置器相关</h3><p><strong>1、为什么需要二级空间配置器？</strong></p>
<p>动态开辟内存时要在堆上申请，但若是我们需要频繁的在堆开辟释放内存，则就会<strong>在堆上造成很多外部碎片</strong>，浪费了内存空间；每次都要进行调用<strong>malloc、free</strong>函数等操作，使空间就会增加一些附加信息，降低了空间利用率；随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。于是就设置了二级空间配置器，<strong>当开辟内存&lt;&#x3D;128bytes时，即视为开辟小块内存，则调用二级空间配置器。</strong></p>
<p>关于STL中一级空间配置器和二级空间配置器的选择上，一般默认<strong>选择的为二级空间配置器</strong>。 如果大于128字节再转去一级配置器器。</p>
<p>（1）一级配置器</p>
<p><strong>一级空间配置器</strong>中重要的函数就是 allocate、deallocate、reallocate。 一级空间配置器是以 malloc()，free()，realloc() 等 C 函数执行实际的内存配置 。</p>
<img src="http://oss.interviewguide.cn/img/202205220035143.png" alt="img" style="zoom: 67%;" />

<p>（2）二级配置器</p>
<img src="http://oss.interviewguide.cn/img/202205220035104.png" alt="img" style="zoom:67%;" />

<h2 id="八、类-设计模式"><a href="#八、类-设计模式" class="headerlink" title="八、类&#x2F;设计模式"></a>八、类&#x2F;设计模式</h2><h3 id="126、传值和传引用应该如何选择？"><a href="#126、传值和传引用应该如何选择？" class="headerlink" title="126、传值和传引用应该如何选择？"></a>126、传值和传引用应该如何选择？</h3><ol>
<li><p>从执行效率上来讲，传引用要优于传值，原因在于传值的时候可能会调用传参类型的构造函数，造成额外开销；</p>
</li>
<li><p>此外，当一个派生类对象被以传值的方式传递且被视为基类对象时，基类的拷贝函数会被调用，此时派生类的一些特异功能会被切割。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBase</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;CBase::func1&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSon1</span> : <span class="keyword">public</span> CBase &#123;</span><br><span class="line">    ......</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;CSon1::func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hostFunc</span><span class="params">(CBase exp)</span> </span>&#123; exp.<span class="built_in">func1</span>(); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CSon1 son1;</span><br><span class="line">    <span class="built_in">hostFunc</span>(son1);  <span class="comment">// CBase::func1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="127、什么是单例模式？"><a href="#127、什么是单例模式？" class="headerlink" title="127、什么是单例模式？"></a>127、什么是单例模式？</h3><p>单例模式指在整个系统生命周期里，保证一个类只能产生一个实例，确保该类的<strong>唯一性</strong>。</p>
<ol>
<li><p><strong>分类：</strong>单例模式可以分为<strong>懒汉式和饿汉式</strong>，两者之间的区别在于<strong>创建实例的时间不同</strong>：</p>
<ul>
<li><p>懒汉式：指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。(这种方式要考虑线程安全)</p>
</li>
<li><p>饿汉式：指系统一运行，就初始化创建实例，当需要时，直接调用即可。(本身就线程安全，没有多线程的问题)</p>
</li>
</ul>
</li>
<li><p><strong>特点：</strong></p>
<ul>
<li>构造函数和析构函数为 <strong>private</strong> 类型，<strong>禁止</strong>外部构造和析构；</li>
<li>拷贝构造和赋值构造函数为 <strong>private</strong> 类型，<strong>禁止</strong>外部拷贝和赋值，确保实例的唯一性；</li>
<li>类里有个获取实例的<strong>静态函数</strong>，可以全局访问。</li>
</ul>
</li>
</ol>
<h3 id="128、怎么保证单例线程安全？"><a href="#128、怎么保证单例线程安全？" class="headerlink" title="128、怎么保证单例线程安全？"></a>128、怎么保证单例线程安全？</h3><ol>
<li><strong>懒汉式进行加锁处理</strong>，在第一次使用单例实例时进行初始化，并通过加锁保证线程安全。这种方法虽然线程安全，但每次获取实例时都需要加锁，效率较低。<ul>
<li>可以通过减少加锁的次数来提高效率，即<strong>双重检查锁定</strong>。在第一次检查时，如果实例已经创建，直接返回实例；如果实例尚未创建，再加锁并进行第二次检查，防止在加锁之前有其他线程已经创建了实例。<ul>
<li>在 C++11 及以上版本中是安全的，但在早期的 C++ 版本中可能会有问题：<ul>
<li>(1)内存模型问题。早期的C++标准中，没有定义明确的内存模型，不同的编译器和平台可能会有不同的内存访问顺序。这意味着在多线程环境中，某个线程在没有获取锁的情况下，可能会看到一个未完全构造的对象；</li>
<li>(2)编译器优化问题。编译器可能会对代码进行优化，导致指令重排。例如，编译器可能会将对象的指针赋值操作和对象的构造操作重排，使得其他线程在对象完全构造之前就能看到非空指针。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>直接采用饿汉式</strong>，其本身就是线程安全的，在程序启动时就创建单例实例，这样可以避免线程同步问题，但可能会导致程序启动时间增加。</li>
<li><strong>C++11 局部静态变量</strong><ul>
<li>C++11 之后，可以利用函数内的静态变量的线程安全特性来实现单例模式。</li>
</ul>
</li>
</ol>
<h3 id="129、写一个线程安全的单例模式"><a href="#129、写一个线程安全的单例模式" class="headerlink" title="129、写一个线程安全的单例模式"></a>129、写一个线程安全的单例模式</h3><p>详见文档。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406252102208.png" alt="image-20240625210242913"></p>
<h3 id="130、组合是什么概念？"><a href="#130、组合是什么概念？" class="headerlink" title="130、组合是什么概念？"></a>130、组合是什么概念？</h3><p>**组合(Composition)**是指一个类包含另一个类的对象作为其成员，表示“拥有”的关系。</p>
<h3 id="131、C-11-中比较安全的类型转换有哪些？四种类型转换用于哪些场合？dnaymic-cast-用在什么地方？父类向子类转换还是子类向父类转换？"><a href="#131、C-11-中比较安全的类型转换有哪些？四种类型转换用于哪些场合？dnaymic-cast-用在什么地方？父类向子类转换还是子类向父类转换？" class="headerlink" title="131、C++11 中比较安全的类型转换有哪些？四种类型转换用于哪些场合？dnaymic_cast 用在什么地方？父类向子类转换还是子类向父类转换？"></a>131、<strong>C++11 中比较安全的类型转换有哪些？四种类型转换用于哪些场合？dnaymic_cast 用在什么地方？父类向子类转换还是子类向父类转换？</strong></h3><p>C++11 中四种强制转换 reinterpret_cast &#x2F; const_cast &#x2F; static_cast &#x2F; dynamic_cast。</p>
<ol>
<li><p><strong>reinterpret_cast：</strong><code>reinterpret_cast&lt;type-id&gt; (expression)</code></p>
<p>reinterpret 是“重新诠释”的意思，reinterpret_cast整体的意思就是 “重新解释的转型”。type-id 必须是一个指针、引用、算术类型、函数指针或成员指针。它可以用于类型之间进行类型转换。</p>
</li>
<li><p><strong>const_cast</strong>：<code>const_cast&lt;type-id&gt;(expression)</code></p>
<p>该运算符用来修改类型的 const 或 volatile 属性。除了 const 和 volatile 修饰之外，type-id 和 expression 的类型是一样的。用法如下：</p>
<ul>
<li>常量指针被转化成非常量的指针，并且仍然指向原来的对象。</li>
<li>常量指针被转换成非常量的引用，并且仍然指向原来的对象。</li>
<li>const_cast 一般用于修改底指针，如 const char* p 形式。</li>
</ul>
</li>
<li><p><strong>static_cast</strong>：<code>static_cast&lt;type-id&gt;(expression)</code></p>
<p>该运算符把 expression 转换成 type-id 类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几个用法：</p>
<ul>
<li>用于类层次结构中基类和派生类之间指针或引用的转换。<ul>
<li>进行上行转换(把派生类的指针或引用转换成基类表示)是安全的。</li>
<li>进行下行转换(把基类指针或引用转换成派生类表示)时，由于没有动态类型检查，所以是不安全的。</li>
</ul>
</li>
<li>用于基本类型数据之间的转换，如把 int 转换成 char，把 int 转换成 enum。这种转换也要开发人员进行保证。</li>
<li>把空指针转换成目标类型的空指针。</li>
<li>把任何类型的表达式转换成 void 类型。</li>
</ul>
</li>
</ol>
<p><strong>注意：static_cast 不能转换成 experssion 的 const、volatile、或者 __unaligned 属性。</strong></p>
<ol start="4">
<li><p><strong>dynamic_cast：</strong><code>dynamic_cast(expression)</code></p>
<p>有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全。该运算符把 expression 转换成 type-id 类型的对象。type-id 必须是类的指针、类的引用或者 void*。如果 type-id 是类指针类型，那么 expression 也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用。</p>
<p>dynamic_cast 运算符可以在执行期间决定真正的类型，也就是说 experssion 必须是多态类型。如果下行转换是安全的(也就是说，如果基类指针或引用确实指向一个派生类对象)这个运算符会传回适当转型过的指针。如果下行转换不安全，这个运算符会传回空指针(就是说，基类指针或者引用没有指向一个派生类对象。)</p>
<p>在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的。在进行下行转换时，dynamic_cast 具有类型检查功能，比 static_cast 更安全。</p>
</li>
</ol>
<h2 id="九、内存相关"><a href="#九、内存相关" class="headerlink" title="九、内存相关"></a>九、内存相关</h2><h3 id="132、简要说明-C-的内存分区？"><a href="#132、简要说明-C-的内存分区？" class="headerlink" title="132、简要说明 C++ 的内存分区？"></a>132、简要说明 C++ 的内存分区？</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301608580.png" alt="image-20240630160851505"></p>
<p><strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</p>
<p><strong>堆</strong>：就是那些由 <code>new</code>分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个<code>new</code>就要对应一个 <code>delete</code>。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</p>
<p><strong>自由存储区</strong>：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，自由存储区和堆比较像，但不等价。</p>
<p><strong>全局&#x2F;静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</p>
<p><strong>常量存储区</strong>：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改</p>
<p><strong>代码区</strong>：存放函数体的二进制代码、</p>
<blockquote>
<p>对于一个类来说，类对象的大小和对象中数据成员的大小一致。也就是说，成员函数不占用对象的内存，而是存放在<strong>代码区</strong>。并且注意：<strong>静态成员函数与一般成员函数的唯一区别就是没有 this 指针，其同样存在在代码区</strong>。</p>
</blockquote>
<h3 id="133、什么是内存泄漏-内存溢出？"><a href="#133、什么是内存泄漏-内存溢出？" class="headerlink" title="133、什么是内存泄漏&#x2F;内存溢出？"></a>133、什么是内存泄漏&#x2F;内存溢出？</h3><ol>
<li><strong>内存溢出(Memory Overflow)</strong></li>
</ol>
<p>(1)指程序在执行过程中，请求分配的内存超过了系统所能提供的内存大小或者进程所能使用的内存大小。这通常会导致程序崩溃或异常终止。内存溢出的原因可能包括：</p>
<ul>
<li><strong>申请内存过多：</strong> 程序中申请了大量的动态内存，但未正确释放，导致内存耗尽；<ul>
<li>要解决这个问题，需要在动态内存分配后适时释放已申请的内存。可以使用<code>delete</code>或<code>delete[]</code>来释放单个对象或数组，或者考虑使用智能指针等RAII(资源获取即初始化)的技术来自动管理内存。</li>
</ul>
</li>
<li><strong>递归调用导致栈溢出：</strong> 如果递归调用的层数过深，会导致函数调用栈溢出；<ul>
<li>可以考虑使用迭代替代递归，或者优化算法以减少递归的深度。另外，可以通过增加栈空间的方式来缓解栈溢出的问题，但这种方法并不是根本性的解决办法，因为栈空间是有限的。在实际开发中，需要注意避免递归调用的层数过深，以及使用合适的算法和数据结构来避免栈溢出问题。</li>
</ul>
</li>
<li><strong>数据结构设计不当：</strong> 如果数据结构设计不合理，可能会导致内存的过度分配或者冗余分配；</li>
</ul>
<p>(2)分类：</p>
<ul>
<li><p><strong>堆内存泄漏</strong>：堆内存是指通过 malloc，new 等从堆中分配出来的内存，如果这部分内存没有通过 free 或者 delete 进行释放，那么就会造成堆内存泄漏；</p>
</li>
<li><p><strong>系统资源泄漏</strong>：主要是指系统分配的资源，比如套接字，文件描述符等，没有使用相应的函数释放掉，导致系统资源的浪费。</p>
</li>
</ul>
<p>(3)解决方法：</p>
<ul>
<li><p><strong>仔细管理内存分配和释放：</strong> 确保每次申请内存后都有相应的释放操作；</p>
</li>
<li><p><strong>使用静态分析工具：</strong> 使用工具来检测代码中潜在的内存泄漏或者内存溢出问题。</p>
<ul>
<li><p>Cppcheck </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cppcheck --<span class="built_in">enable</span>=all --inconclusive your_file.cpp</span><br></pre></td></tr></table></figure>
</li>
<li><p>Valgrind </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -g your_file.cpp -o your_program</span><br><span class="line">valgrind --leak-check=full ./your_program</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>优化算法和数据结构：</strong> 确保使用高效的算法和数据结构，避免不必要的内存占用。</p>
</li>
<li><p><strong>限制资源使用：</strong> 设置适当的资源使用限制，防止程序过度消耗内存。</p>
</li>
</ul>
<ol start="2">
<li><strong>内存泄漏(Memory Leak)</strong></li>
</ol>
<p>(1)指程序中分配的内存未能被释放，导致系统中有大量无法访问的内存块，最终耗尽系统内存资源。</p>
<ul>
<li><strong>未释放动态分配的内存：</strong> 程序中分配的内存未被释放，导致内存泄漏；</li>
<li><strong>循环引用：</strong> 对象之间存在循环引用，导致垃圾回收器无法释放内存；</li>
</ul>
<p>(2)解决方法：</p>
<ul>
<li><strong>使用智能指针</strong>： 智能指针通过自动管理对象的生命周期来解决内存泄漏问题。</li>
<li><strong>使用内存分析工具</strong>： 使用内存分析工具来检测程序中的内存泄漏问题，并定位到具体的代码位置。</li>
<li><strong>合理设计数据结构</strong>： 避免循环引用等设计上的问题，确保对象能够被垃圾回收器正确释放。</li>
<li><strong>及时清理缓存</strong>： 确保缓存中的对象在不再需要时能够及时清理，防止对象长时间占用内存。</li>
</ul>
<h3 id="134、智能指针怎么解决内存泄漏？"><a href="#134、智能指针怎么解决内存泄漏？" class="headerlink" title="134、智能指针怎么解决内存泄漏？"></a>134、智能指针怎么解决内存泄漏？</h3><p>智能指针通过自动管理对象的生命周期来解决内存泄漏问题。</p>
<ul>
<li><strong>自动释放资源</strong>：智能指针在超出作用域或被重置时，会自动调用其管理对象的析构函数，释放内存。</li>
<li><strong>防止悬挂指针</strong>：通过确保对象在指针超出作用域时销毁，智能指针防止了悬挂指针的产生。</li>
<li><strong>引用计数管理</strong>：<code>std::shared_ptr</code>使用引用计数来跟踪所有权，确保对象只有在最后一个<code>shared_ptr</code>销毁时才会被释放。</li>
</ul>
<h3 id="135、C-对象的大小由哪些因素决定？"><a href="#135、C-对象的大小由哪些因素决定？" class="headerlink" title="135、C++ 对象的大小由哪些因素决定？"></a>135、C++ 对象的大小由哪些因素决定？</h3><p>(1)变量的类型和大小；</p>
<p>(2)内存对齐和填充；</p>
<p>(3)虚函数所带来的开销；</p>
<p>(4)空类优化。</p>
<h3 id="136、说一下你对于内存对齐的理解？"><a href="#136、说一下你对于内存对齐的理解？" class="headerlink" title="136、说一下你对于内存对齐的理解？"></a>136、说一下你对于内存对齐的理解？</h3><p>内存对齐是指对于特定类型的数据规定了其应该位于内存的哪个位置上。比如，对于int类型的数据，在32系统上要求其内存对齐为4个字节，也就是说其起始地址应该为4的倍数。</p>
<p>内存对齐的目的是为了提高内存访问的效率。因为在许多硬件平台上，访问对齐的内存要比访问不对齐的内存更快。</p>
<h3 id="137、内存对齐可能会带来哪些问题？"><a href="#137、内存对齐可能会带来哪些问题？" class="headerlink" title="137、内存对齐可能会带来哪些问题？"></a>137、内存对齐可能会带来哪些问题？</h3><p>(1)可能会造成内存浪费问题。虽然内存对齐后其内存访问速度会大幅提升，但随之而来的可能会造成一些内存浪费现象。</p>
<p>(2)可能存在平台不兼容的问题。不同类型的数据在不同的平台上可能有不能的内存对齐规则。</p>
<h3 id="138、什么方式可以不对齐内存，什么方式可以指定内存对齐大小？"><a href="#138、什么方式可以不对齐内存，什么方式可以指定内存对齐大小？" class="headerlink" title="138、什么方式可以不对齐内存，什么方式可以指定内存对齐大小？"></a>138、什么方式可以不对齐内存，什么方式可以指定内存对齐大小？</h3><p>(1)在C语言中，可以通过指针类型转换实现对任意内存地址的访问，从而实现不对齐的内存访问。例如，可以将一个地址强制转换为一个指针类型，然后通过该指针访问数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> data[] = &#123;<span class="number">0x00</span>， <span class="number">0x01</span>， <span class="number">0x02</span>， <span class="number">0x03</span>， <span class="number">0x04</span>&#125;;</span><br><span class="line">    <span class="comment">// 假设我们需要访问从地址 &amp;data[1] 开始的一个整数，不考虑对齐</span></span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)(data + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>， *p); <span class="comment">// 可能会导致性能下降或在某些硬件上引发错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)GCC和Clang等编译器支持<code>__attribute__((aligned(N)))</code>来指定内存对齐。</p>
<p>(3)#pragma pack(1)</p>
<p>但要注意，即使使用了 <code>#pragma pack(1)</code>，在多重继承的情况下，仍然需要进行对齐填充以满足基类的对齐要求。</p>
<h3 id="139、C-内存同步方式？"><a href="#139、C-内存同步方式？" class="headerlink" title="139、C++ 内存同步方式？"></a>139、C++ 内存同步方式？</h3><ol>
<li>**互斥锁(Mutex)**：互斥锁用于保护临界区，确保同一时间只有一个线程可以访问共享资源。当一个线程获取了互斥锁后，其他线程需要等待锁被释放才能继续执行。常见的互斥锁有 std::mutex、std::lock_guard 和 std::unique_lock。</li>
<li>**信号量(Semaphore)**：信号量是一个计数器，用于控制多个线程对共享资源的访问。信号量包括两种类型：二进制信号量(只能取值 0 或 1)和计数信号量(可以取任意非负整数值)。常见的信号量有 std::binary_semaphore(C++20 中引入)和操作系统提供的信号量。</li>
<li>**条件变量(Condition Variable)**：条件变量允许线程在满足特定条件时挂起等待，在条件满足时被唤醒继续执行。条件变量通常与互斥锁一起使用，以确保在修改共享数据时不会出现竞态条件。常见的条件变量有 std::condition_variable 和 std::condition_variable_any。</li>
<li>**屏障(Barrier)**：屏障用于在多个线程中的所有线程都到达某个点时进行同步，然后继续执行。一旦所有线程都到达屏障点，它们就会全部释放，继续执行后续操作。常见的屏障有 std::barrier(C++20 中引入)。</li>
<li>**原子操作(Atomic Operation)**：原子操作是一种保证不会被中断的操作，可以确保多个线程同时对共享变量进行读取、修改和写入操作时的一致性。常见的原子操作有 std::atomic 和 C++11 中引入的原子操作函数。</li>
<li>**读写锁(Reader-Writer Lock)**：读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。当有线程在写入时，其他线程无法读取或写入，但可以等待。常见的读写锁有 std::shared_mutex(C++17 中引入)。</li>
</ol>
<h2 id="十、算法相关"><a href="#十、算法相关" class="headerlink" title="十、算法相关"></a>十、算法相关</h2><h3 id="140、主要的排序算法，其时间复杂度和空间复杂度，以及是不是稳定的？"><a href="#140、主要的排序算法，其时间复杂度和空间复杂度，以及是不是稳定的？" class="headerlink" title="140、主要的排序算法，其时间复杂度和空间复杂度，以及是不是稳定的？"></a>140、主要的排序算法，其时间复杂度和空间复杂度，以及是不是稳定的？</h3><h3 id="141、哈希算法的时间复杂度？如何解决哈希冲突？"><a href="#141、哈希算法的时间复杂度？如何解决哈希冲突？" class="headerlink" title="141、哈希算法的时间复杂度？如何解决哈希冲突？"></a>141、哈希算法的时间复杂度？如何解决哈希冲突？</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/06/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%932_Redis%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/06/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%932_Redis%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">数据库2_Redis数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-06 10:43:45" itemprop="dateCreated datePublished" datetime="2024-04-06T10:43:45+08:00">2024-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-12 17:05:55" itemprop="dateModified" datetime="2024-06-12T17:05:55+08:00">2024-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/06/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%932_Redis%E6%95%B0%E6%8D%AE%E5%BA%93/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/06/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%931_MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/06/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%931_MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">数据库1_MySQL数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-06 10:18:16" itemprop="dateCreated datePublished" datetime="2024-04-06T10:18:16+08:00">2024-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-12 17:05:57" itemprop="dateModified" datetime="2024-06-12T17:05:57+08:00">2024-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/06/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%931_MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/03/Computer/CSAPP/CSAPP_Ch2%20%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/03/Computer/CSAPP/CSAPP_Ch2%20%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">Ch2 信息的表示和处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-03 11:28:35" itemprop="dateCreated datePublished" datetime="2024-04-03T11:28:35+08:00">2024-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-30 10:36:09" itemprop="dateModified" datetime="2024-05-30T10:36:09+08:00">2024-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/CSAPP/" itemprop="url" rel="index"><span itemprop="name">CSAPP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>26</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/03/Computer/CSAPP/CSAPP_Ch2%20%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/03/Computer/CSAPP/CSAPP_Ch3%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/03/Computer/CSAPP/CSAPP_Ch3%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/" class="post-title-link" itemprop="url">Ch3 程序的机器级表示</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-03 11:27:38" itemprop="dateCreated datePublished" datetime="2024-04-03T11:27:38+08:00">2024-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-30 10:36:16" itemprop="dateModified" datetime="2024-05-30T10:36:16+08:00">2024-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/CSAPP/" itemprop="url" rel="index"><span itemprop="name">CSAPP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>32</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/03/Computer/CSAPP/CSAPP_Ch3%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/03/Computer/CSAPP/CSAPP_Ch1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/03/Computer/CSAPP/CSAPP_Ch1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/" class="post-title-link" itemprop="url">Ch1 计算机系统漫游</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-03 11:23:22" itemprop="dateCreated datePublished" datetime="2024-04-03T11:23:22+08:00">2024-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-30 10:36:00" itemprop="dateModified" datetime="2024-05-30T10:36:00+08:00">2024-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/CSAPP/" itemprop="url" rel="index"><span itemprop="name">CSAPP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/03/Computer/CSAPP/CSAPP_Ch1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/03/Computer/CSAPP/CSAPP_Ch10%20%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/03/Computer/CSAPP/CSAPP_Ch10%20%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/" class="post-title-link" itemprop="url">Ch10 系统级I/O</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-03 11:20:45" itemprop="dateCreated datePublished" datetime="2024-04-03T11:20:45+08:00">2024-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-30 10:37:22" itemprop="dateModified" datetime="2024-05-30T10:37:22+08:00">2024-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/CSAPP/" itemprop="url" rel="index"><span itemprop="name">CSAPP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>681</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/03/Computer/CSAPP/CSAPP_Ch10%20%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/03/Computer/CSAPP/CSAPP_Ch9%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/03/Computer/CSAPP/CSAPP_Ch9%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">Ch9 虚拟内存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-03 11:20:41" itemprop="dateCreated datePublished" datetime="2024-04-03T11:20:41+08:00">2024-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-30 10:37:15" itemprop="dateModified" datetime="2024-05-30T10:37:15+08:00">2024-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/CSAPP/" itemprop="url" rel="index"><span itemprop="name">CSAPP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/03/Computer/CSAPP/CSAPP_Ch9%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/03/Computer/CSAPP/CSAPP_Ch8%20%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/03/Computer/CSAPP/CSAPP_Ch8%20%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" class="post-title-link" itemprop="url">Ch8 异常控制流</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-03 11:20:00" itemprop="dateCreated datePublished" datetime="2024-04-03T11:20:00+08:00">2024-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-30 10:37:02" itemprop="dateModified" datetime="2024-05-30T10:37:02+08:00">2024-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/CSAPP/" itemprop="url" rel="index"><span itemprop="name">CSAPP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/03/Computer/CSAPP/CSAPP_Ch8%20%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/03/Computer/CSAPP/CSAPP_Ch7%20%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/03/Computer/CSAPP/CSAPP_Ch7%20%E9%93%BE%E6%8E%A5/" class="post-title-link" itemprop="url">Ch7 链接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-03 11:18:37" itemprop="dateCreated datePublished" datetime="2024-04-03T11:18:37+08:00">2024-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-30 10:36:55" itemprop="dateModified" datetime="2024-05-30T10:36:55+08:00">2024-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/CSAPP/" itemprop="url" rel="index"><span itemprop="name">CSAPP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/03/Computer/CSAPP/CSAPP_Ch7%20%E9%93%BE%E6%8E%A5/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="midorii"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">midorii</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">midorii</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">287k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:24</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
