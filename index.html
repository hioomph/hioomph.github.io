<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch_cat_logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/site_cat-32%C3%9732.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/site_cat-16%C3%9716.png">
  <link rel="mask-icon" href="/images/cat_logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="MIDORII&#39;S JOURNEY">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="MIDORII&#39;S JOURNEY">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="midorii">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>MIDORII'S JOURNEY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MIDORII'S JOURNEY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">a little bit sweet</p>
      <a>
        <img class="custom-logo-image" src="/images/cat.jpeg" alt="MIDORII'S JOURNEY">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/30/Computer/C++/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/30/Computer/C++/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">内存管理机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-30 13:07:46" itemprop="dateCreated datePublished" datetime="2024-04-30T13:07:46+08:00">2024-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-02 11:38:05" itemprop="dateModified" datetime="2024-05-02T11:38:05+08:00">2024-05-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/%E4%BE%AF%E6%8D%B7C-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">侯捷C++系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一讲-Primitives"><a href="#第一讲-Primitives" class="headerlink" title="第一讲 Primitives"></a>第一讲 Primitives</h1><h2 id="2-内存分配的每一层面"><a href="#2-内存分配的每一层面" class="headerlink" title="2 内存分配的每一层面"></a>2 内存分配的每一层面</h2><ul>
<li>C++的 Applications可以调用STL，里面会有allocator进行内存分配；</li>
<li>也可以使用C++ 基本工具primitives，比如new, new[], new(), ::operator new()；</li>
<li>还可以使用更底层的malloc和free分配和释放内存；</li>
<li>最底层的是系统调用，比如HeapAlloc，VirtualAlloc等。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404301822840.png" alt="4_内存管理_01"></p>
<p>C++ memory primitives</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302008310.png" alt="4_内存管理_02"></p>
<h2 id="3-四个层面的基本用法"><a href="#3-四个层面的基本用法" class="headerlink" title="3 四个层面的基本用法"></a>3 四个层面的基本用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>				 <span class="comment">//std::allocator  </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext\pool_allocator.h&gt;</span>	 <span class="comment">//欲使用 std::allocator 以外的 allocator, 就得自行 #include &lt;ext/...&gt; </span></span></span><br><span class="line"><span class="keyword">namespace</span> jj01</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_primitives</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\ntest_primitives().......... \n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="type">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">512</span>);	<span class="comment">//512 bytes</span></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">    complex&lt;<span class="type">int</span>&gt;* p2 = <span class="keyword">new</span> complex&lt;<span class="type">int</span>&gt;; <span class="comment">//one object</span></span><br><span class="line">    <span class="keyword">delete</span> p2;             </span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p3 = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="number">512</span>); <span class="comment">//512 bytes</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下使用 C++ 標準庫提供的 allocators。</span></span><br><span class="line"><span class="comment">//其接口雖有標準規格，但實現廠商並未完全遵守；下面三者形式略異。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">    <span class="comment">//以下兩函數都是 non-static，定要通過 object 調用。以下分配 3 個 ints.</span></span><br><span class="line">    <span class="type">int</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">3</span>, (<span class="type">int</span>*)<span class="number">0</span>); </span><br><span class="line">    <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p4,<span class="number">3</span>);           </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __BORLANDC__</span></span><br><span class="line">    <span class="comment">//以下兩函數都是 non-static，定要通過 object 調用。以下分配 5 個 ints.</span></span><br><span class="line">    <span class="type">int</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">5</span>);  </span><br><span class="line">    <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p4,<span class="number">5</span>);       </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line">    <span class="comment">//以下兩函數都是 static，可通過全名調用之。以下分配 512 bytes.(GNUC 2.9)</span></span><br><span class="line">    <span class="comment">//void* p4 = alloc::allocate(512); </span></span><br><span class="line">    <span class="comment">//alloc::deallocate(p4,512);   </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下兩函數都是 non-static，定要通過 object 調用。以下分配 7 個 ints.(GNUC 4.9) </span></span><br><span class="line">	<span class="type">void</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">7</span>); </span><br><span class="line">    <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="type">int</span>*)p4,<span class="number">7</span>);     </span><br><span class="line">	</span><br><span class="line">    <span class="comment">//以下兩函數都是 non-static，定要通過 object 調用。以下分配 9 個 ints.(GNUC 4.9) 	</span></span><br><span class="line">	<span class="type">void</span>* p5 = __gnu_cxx::__pool_alloc&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">9</span>); </span><br><span class="line">    __gnu_cxx::__pool_alloc&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="type">int</span>*)p5,<span class="number">9</span>);	</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;	</span><br><span class="line">&#125; <span class="comment">//namespace</span></span><br></pre></td></tr></table></figure>

<h2 id="4-基本构件之一new-delete-expression上"><a href="#4-基本构件之一new-delete-expression上" class="headerlink" title="4 基本构件之一new delete expression上"></a>4 基本构件之一new delete expression上</h2><ul>
<li>new expression（即new operator）（详见<a target="_blank" rel="noopener" href="https://hioomph.github.io/2024/04/24/Computer/C++/new%E4%B8%8Eoperator%20new/">new与operator new</a>）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302012729.png" alt="https://hioomph.github.io/2024/04/24/Computer/C++/new%E4%B8%8Eoperator%20new/"></p>
<ul>
<li><p>右上角的operator new的实现（VC98版）</p>
<ol>
<li>调用malloc函数；</li>
<li>若malloc无法分配内存，就一直在while循环中：调用_callnewh，即一个new handler，用于处理内存分配失败的情况。</li>
</ol>
<blockquote>
<p>_callnewh 不是 C++ 标准中的函数，而是可能是用户定义的一个函数。通常情况下，这类函数的名字以 _new_handler 结尾，用于处理内存分配失败的情况。</p>
<p>在 C++ 中，当 new 表达式无法分配所需的内存时，会调用用户指定的 new_handler 函数。new_handler 是一个函数指针，指向一个用户定义的函数，其原型通常为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数可以尝试释放内存、扩大内存池，或者执行其他操作来尝试解决内存不足的问题。如果 new_handler 能够成功处理内存不足的情况，它返回；如果不能处理，它可以选择抛出异常或者终止程序。</p>
</blockquote>
</li>
</ul>
<h2 id="5-基本构件之一new-delete-expression中"><a href="#5-基本构件之一new-delete-expression中" class="headerlink" title="5 基本构件之一new delete expression中"></a>5 基本构件之一new delete expression中</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302021318.png" alt="4_内存管理_06"></p>
<h2 id="6-基本构件之一new-delete-expression下"><a href="#6-基本构件之一new-delete-expression下" class="headerlink" title="6 基本构件之一new delete expression下"></a>6 基本构件之一new delete expression下</h2><p>下面显示不能直接调用构造函数，而只有编译器会进行隐式调用。调用时在vc6编译通过，在GCC中编译失败。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A* pA = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">1</span>);         	<span class="comment">//ctor. this=000307A8 id=1</span></span><br><span class="line">cout &lt;&lt; pA-&gt;id &lt;&lt; endl;   	<span class="comment">//1</span></span><br><span class="line"><span class="comment">//!	pA-&gt;A::A(3);                //in VC6 : ctor. this=000307A8 id=3</span></span><br><span class="line">  								<span class="comment">//in GCC : [Error] cannot call constructor &#x27;jj02::A::A&#x27; directly</span></span><br><span class="line">  								</span><br><span class="line"><span class="comment">//!	A::A(5);	  				//in VC6 : ctor. this=0013FF60 id=5</span></span><br><span class="line">                      			<span class="comment">//         dtor. this=0013FF60  	</span></span><br><span class="line">  								<span class="comment">//in GCC : [Error] cannot call constructor &#x27;jj02::A::A&#x27; directly</span></span><br><span class="line">  								<span class="comment">//         [Note] for a function-style cast, remove the redundant &#x27;::A&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-Array-new"><a href="#7-Array-new" class="headerlink" title="7 Array new"></a>7 Array new</h2><p>（1）array new和array delete的搭配使用</p>
<p>如果<code>new[]</code>不搭配<code>delete[]</code>的话，实际上是针对<code>class with pointer member</code>的情况造成内存泄漏。<strong>此时若调用<code>delete</code>，带有<code>cookie</code>的动态数组部分实际上仍然会被回收，发生错误的地方是需要调用3次析构函数（如下图右边），但实际上只调用了1次，因此造成内存泄漏</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Complex* pca = <span class="keyword">new</span> Complex[<span class="number">3</span>];  <span class="comment">// 调用三次构造函数</span></span><br><span class="line"><span class="keyword">delete</span>[] pca;  <span class="comment">// 唤起三次析构函数， 这是正确的</span></span><br><span class="line"></span><br><span class="line">string* psa = <span class="keyword">new</span> string[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> psa;  <span class="comment">// 唤起一次析构函数，这是错误的</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302024595.png" alt="4_内存管理_08"></p>
<p>（2）array size in memory size</p>
<ul>
<li>右侧的图是new int[10]的内存布局，其中：<strong>灰色</strong>表示具体数据，<strong>橙色</strong>表示debug模式下添加的内存，最上面和最下面的两个0x61(61H)是cookie，记录整体内存分配的大小；<strong>浅蓝色</strong>的pad表示补齐，填补到16的倍数。<ul>
<li>61H实际上是60H，表示内存分配的大小，后面1H意思是占用最后一位，表示内存分配出去</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302027115.png" alt="4_内存管理_10"></p>
<h2 id="8-placement-new"><a href="#8-placement-new" class="headerlink" title="8 placement new"></a>8 placement new</h2><p>palcement new允许我们将object建构于allocated memory中。<strong>没有所谓的placement new，因为placement new根本没分配memory。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">sizeof</span>(Complex) * <span class="number">3</span>]; <span class="comment">// 已经分配了内存</span></span><br><span class="line">Complex* pc = <span class="built_in">new</span>(buf)<span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 把上面分配的内存位置传进来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br></pre></td></tr></table></figure>

<p>其中<code>Complex* pc = new(buf)Complex(1, 2);</code>这句话会被编译器转换为下图中的1，2，3三行，分别调用operator new（和上文看到的不同，这里需要第二个参数，表示位置，这个函数只是传回这个位置，不再分配内存），指针转型，调用构造函数。</p>
<p>这种用法被称为 “placement new”，它允许程序员在指定的内存位置上创建对象。这通常用于特殊的内存管理场景，例如在预分配的内存池中创建对象。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302031495.png" alt="4_内存管理_12"></p>
<h2 id="9-重载"><a href="#9-重载" class="headerlink" title="9 重载"></a>9 重载</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302031922.png" alt="4_内存管理_13"></p>
<p>（1）C++容器分配内存的途径</p>
<p>容器会走分配器，分配器会调用::operator new和::operator delete，底层也是调用malloc和free。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302033606.png" alt="4_内存管理_14"></p>
<p>在 C++ 中，容器使用分配器（Allocator）来进行内存分配和释放。分配器是负责管理容器内部元素内存的组件。下面是容器分配内存的一般途径：</p>
<ol>
<li><p>容器使用分配器：<br>C++ 容器（如 std::vector、std::list、std::map 等）通常使用分配器来分配和释放内存。分配器是容器的一部分，负责处理元素的内存分配和释放操作。</p>
</li>
<li><p>分配器调用 ::operator new 和 ::operator delete：<br>分配器的实现通常会调用全局作用域下的 ::operator new 来分配内存，并在需要释放内存时调用 ::operator delete。<br>::operator new 和 ::operator delete 是 C++ 中的全局内存分配和释放函数。它们底层可能调用标准库的 malloc 和 free。</p>
</li>
<li><p>底层可能调用 malloc 和 free：<br>malloc 和 free 是 C 标准库中的内存分配和释放函数，用于分配和释放原始的、未构造的内存块。C++ 的 ::operator new 和 ::operator delete 可能在底层调用这些函数。</p>
</li>
</ol>
<p>总体来说，C++ 容器使用分配器来管理内存，而分配器可能在其实现中调用 ::operator new 和 ::operator delete，从而涉及到底层的内存分配函数 malloc 和 free。这种设计允许用户自定义容器的内存管理行为，以适应不同的需求。用户可以通过提供自定义分配器来实现特定的内存分配策略。</p>
<p>（2）重载全局的::operator new 和::operator delete</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302034363.png" alt="4_内存管理_15"></p>
<p>（3）重载operator new和operator delete</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302034714.png" alt="4_内存管理_16"></p>
<p>（3）重载operator new[]和operator delete[]</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302035382.png" alt="4_内存管理_17"></p>
<h2 id="10-重载示例（上）"><a href="#10-重载示例（上）" class="headerlink" title="10 重载示例（上）"></a>10 重载示例（上）</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302036272.png" alt="4_内存管理_18"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302036230.png" alt="4_内存管理_19"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302036668.png" alt="4_内存管理_20"></p>
<h2 id="11-重载示例（下）"><a href="#11-重载示例（下）" class="headerlink" title="11 重载示例（下）"></a>11 重载示例（下）</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302036617.png" alt="4_内存管理_21"></p>
<p>placement new的重载第一参数必须是size_t类型，对于如何区分operator new和placement new，要看调用的时候怎么用。在调用时，编译器会根据传递给new表达式的参数来匹配适当的重载版本。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302038221.png" alt="4_内存管理_22"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302038657.png" alt="4_内存管理_23"></p>
<p>basic_string使用new(extra)扩充申请量</p>
<p>重载了operator new，其实是placement new。因为用法为<code>new(extra) Rep;</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302038299.png" alt="4_内存管理_24"></p>
<h2 id="12-Per-class-allocator"><a href="#12-Per-class-allocator" class="headerlink" title="12 Per class allocator"></a>12 Per class allocator</h2><p>（1）内存池</p>
<p>内存池是一种用于管理和分配内存的机制，它可以提高内存分配的效率，减少内存碎片，并降低动态内存分配的开销。在 C++ 中，内存池通常通过重载 operator new 和 operator delete 来实现。</p>
<p>下面简要描述一下内存池的概念，并提供一个简单的示意图：</p>
<ol>
<li><p>内存池概念：</p>
<ul>
<li>内存池是一块预先分配的内存区域，它被划分为多个小块，每个小块可以被分配给程序使用；</li>
<li>内存池通常由一个或多个链表、堆栈或其他数据结构来管理，以追踪哪些内存块是空闲的，哪些是已分配的；</li>
<li>内存池的目的是减少因频繁的内存分配和释放而引起的性能开销。</li>
</ul>
</li>
<li><p>示意图：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------+</span><br><span class="line">|            Memory Pool             |</span><br><span class="line">+------------------------------------+</span><br><span class="line">|   Free Block <span class="number">1</span>   |   Free Block <span class="number">2</span>  |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">|   Allocated Block <span class="number">1</span>                |</span><br><span class="line">+------------------------------------+</span><br><span class="line">|   Free Block <span class="number">3</span>   |   Free Block <span class="number">4</span>  |</span><br><span class="line">+------------------+-----------------+</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的示意图展示了一个简单的内存池，其中包含多个内存块，有一些是空闲的，有一些是已经分配给程序使用的；</li>
<li>每个内存块的大小可能不同，取决于内存池的设计；</li>
<li>空闲的内存块可以通过链表或其他数据结构连接在一起，以便快速分配。</li>
</ul>
</li>
<li><p>内存池的操作：</p>
<ul>
<li>当程序需要分配内存时，内存池会从空闲块中选择一个合适的块分配给程序；</li>
<li>当程序释放内存时，将相应的内存块标记为空闲，并重新加入空闲块链表，以便下次分配使用。</li>
</ul>
</li>
<li><p>自定义内存池的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> size;</span><br><span class="line">        Block* next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Block* freeList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MemoryPool</span>(<span class="type">size_t</span> poolSize) &#123;</span><br><span class="line">        <span class="comment">// 初始化内存池</span></span><br><span class="line">        <span class="type">void</span>* memory = ::<span class="keyword">operator</span> <span class="built_in">new</span>(poolSize);</span><br><span class="line">        freeList = <span class="built_in">static_cast</span>&lt;Block*&gt;(memory);</span><br><span class="line">        freeList-&gt;size = poolSize;</span><br><span class="line">        freeList-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从内存池中分配内存</span></span><br><span class="line">        <span class="keyword">if</span> (!freeList || freeList-&gt;size &lt; size) &#123;</span><br><span class="line">            <span class="comment">// 内存不足，或者没有空闲块，可以根据实际情况扩展内存池</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Block* allocatedBlock = freeList;</span><br><span class="line">        freeList = freeList-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(allocatedBlock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放内存到内存池</span></span><br><span class="line">        Block* block = <span class="built_in">static_cast</span>&lt;Block*&gt;(ptr);</span><br><span class="line">        block-&gt;next = freeList;</span><br><span class="line">        freeList = block;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述示例为了简洁，省略了一些内存池的管理细节</span></span><br><span class="line"><span class="comment">// 实际的内存池实现可能需要更复杂的数据结构和算法。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>引入内存池的考量：</p>
<p>当需要多次调用new来分配内存时，为了减少malloc分配内存的数量，以及减少cookie的用量，可以选择用malloc分配一大块内存（即内存池），然后将这块内存池分成小块，在实际的分配时直接取用其中的一小块，从而减少malloc的调用次数。</p>
</blockquote>
<p>（2）对类Screen进行内存设置的示例（设计类的内存分配器_版本1）</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302045487.png" alt="4_内存管理_25"></p>
<p>如下图右侧所示：</p>
<ul>
<li>左边间隔8，表示每个Screen对象内存分配的大小为8B，说明每个Screen分配的时候没有cookie；</li>
<li>右边间隔16，表示每个Screen对象内存分配的大小为16B，这是因为对象分配的时候上下加了cookie，最上面和最下面的cookie大小共为8B。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302046008.png" alt="4_内存管理_26"></p>
<h2 id="13-Per-class-allocator-2"><a href="#13-Per-class-allocator-2" class="headerlink" title="13 Per class allocator 2"></a>13 Per class allocator 2</h2><p>（1）设计类的内存分配器_版本2</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302047081.png" alt="4_内存管理_27"></p>
<p>这里和第一版本的最大不同是设计上采用union。</p>
<p>在C++中，union 是一种特殊的数据结构，允许在相同的内存位置存储不同类型的对象。它的每个成员共享相同的内存空间，只能同时使用一个成员。union 提供了一种有效利用内存的方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AirplaneRep</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> miles;  <span class="comment">// 4B</span></span><br><span class="line">	<span class="type">char</span> type;  <span class="comment">// 1B</span></span><br><span class="line">    <span class="comment">// 由于对齐，这5B会变成8B</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">	AirplaneRep rep;</span><br><span class="line">	Airplane* next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302047903.png" alt="4_内存管理_28"></p>
<h2 id="14-Static-allocator"><a href="#14-Static-allocator" class="headerlink" title="14 Static allocator"></a>14 Static allocator</h2><p>（1）设计类的内存分配器_版本3</p>
<p>下面是内存分配的第三版本。</p>
<p>从软件工程的角度看，上面的operator new和operator delete对于不同 类都要重载，明显不是一个好的解法，下面是将allocator抽象成一个类。</p>
<p>allocator类中定义allocate和deallocate函数，用于分配和回收。</p>
<p>下图中右侧是具体的实现。这里每次分配CHUNK个大小的一大块，然后切割成小块，并用链表串起来。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302049167.png" alt="4_内存管理_29"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302049165.png" alt="4_内存管理_30"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302049639.png" alt="4_内存管理_31"></p>
<h2 id="15-Macro-for-static-allocator"><a href="#15-Macro-for-static-allocator" class="headerlink" title="15 Macro for static allocator"></a>15 Macro for static allocator</h2><p>（1）设计类的内存分配器_版本4</p>
<p>把allocator的部分拿出来用宏来定义。</p>
<p>在C++中，宏（macro）是一种预处理指令，用于在编译过程中执行文本替换。宏通常通过 #define 关键字定义，并在代码中通过宏名称来调用。它们是一种简单的文本替换机制，可以用于创建常量、函数替代、条件编译等。</p>
<p>在宏定义的末尾使用反斜杠是为了告诉编译器该宏定义将在下一行继续。如果在宏定义的最后一行没有使用反斜杠，那么编译器会认为宏定义结束了。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302050403.png" alt="4_内存管理_32"></p>
<p>（2）标准库中的allocator</p>
<p>其中一种分配器有16条自由链表，来应对不同大小的块分配，不同的大小的类对象，分配到不同的链表中。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302050613.png" alt="4_内存管理_34"></p>
<h2 id="16-New-Handler"><a href="#16-New-Handler" class="headerlink" title="16 New Handler"></a>16 New Handler</h2><p>new handler</p>
<p>new handler 是一个与 C++ 内存分配和 new 操作符相关的概念。它是一个函数指针，指向一个用户定义的函数，该函数负责处理 new 操作符无法满足内存分配请求时的情况。</p>
<p>当 new 操作符无法分配所需的内存时，它会调用与之关联的 new handler。new handler 可以执行一些操作，例如释放一些已分配的内存、尝试扩展堆的大小、选择性地抛出异常，或者执行其他用户定义的操作。</p>
<p>使用 set_new_handler 函数设置 new handler：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">customNewHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed! Custom new handler called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::<span class="built_in">terminate</span>();  <span class="comment">// 终止程序或者执行其他处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(customNewHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试分配大块内存</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1000000000000</span>];  <span class="comment">// 如果分配失败，会调用 customNewHandler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，通过 set_new_handler 函数设置了一个自定义的 new handler，即 customNewHandler。当 new 操作符在尝试分配非常大的内存块时失败，会调用这个自定义的 new handler。</p>
<p>注意事项：</p>
<ul>
<li>new handler 是全局的，一旦设置，会在程序的生命周期内一直有效，直到被其他<code>set_new_handler</code>覆盖。</li>
<li>如果 new handler 返回，new 操作符会再次尝试分配内存，如果还失败，则再次调用 new handler。这个过程会一直重复，直到 new handler 抛出异常或者不返回（例如调用 <code>std::terminate()</code>）。</li>
<li>在 C++11 及以后的版本中，可以使用 std::get_new_handler 获取当前的 new handler，以便在需要时进行保存和恢复。</li>
</ul>
<p>使用 new handler 可以提供一些灵活性，允许程序员在内存分配失败的情况下采取定制的操作，而不是默认的行为（即抛出 std::bad_alloc 异常）。<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302052495.png" alt="4_内存管理_35"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302052411.png" alt="4_内存管理_36"></p>
<h1 id="第二讲-std-allocator"><a href="#第二讲-std-allocator" class="headerlink" title="第二讲 std::allocator"></a>第二讲 std::allocator</h1><h2 id="17-VC6-malloc"><a href="#17-VC6-malloc" class="headerlink" title="17 VC6 malloc"></a>17 VC6 malloc</h2><h2 id="18-VC6标准分配器之实现"><a href="#18-VC6标准分配器之实现" class="headerlink" title="18 VC6标准分配器之实现"></a>18 VC6标准分配器之实现</h2><h2 id="19-BC5标准分配器之实现"><a href="#19-BC5标准分配器之实现" class="headerlink" title="19 BC5标准分配器之实现"></a>19 BC5标准分配器之实现</h2><h2 id="20-G2-9标准分配器之实现"><a href="#20-G2-9标准分配器之实现" class="headerlink" title="20 G2.9标准分配器之实现"></a>20 G2.9标准分配器之实现</h2><h2 id="21-G2-9-std-alloc-VS-G4-9-pull-alloc"><a href="#21-G2-9-std-alloc-VS-G4-9-pull-alloc" class="headerlink" title="21 G2.9 std::alloc VS G4.9 __pull_alloc"></a>21 G2.9 std::alloc VS G4.9 __pull_alloc</h2><h2 id="22-G4-9-pull-alloc用例"><a href="#22-G4-9-pull-alloc用例" class="headerlink" title="22 G4.9 __pull_alloc用例"></a>22 G4.9 __pull_alloc用例</h2><h2 id="23-G2-9-std-alloc"><a href="#23-G2-9-std-alloc" class="headerlink" title="23 G2.9 std::alloc"></a>23 G2.9 std::alloc</h2><p>（1）alloc的运作模式</p>
<p>第一讲中介绍的Per class allocator类，每个类里面重载了 operator new和operator delete，每个类都单独维护一个链表。如下图所示，<code>std::alloc</code>为所有的类维护16个链表，每个链表负责不同大小的区块分配，从小到大分别为：<code>8B, 16B, 24B, 32B, …, 128B</code>，按8的倍数增长。<strong>当大小不为8的倍数的时候，分配器会自动将其对齐到8的倍数。当大小超过128B时，就交给malloc来单独处理。</strong></p>
<blockquote>
<p>这里可以联系到面经中的问答：malloc函数的底层实现是什么？及相关问题。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011019232.png" alt="4_内存管理_51"></p>
<p><strong>举例：</strong>对于<code>#3</code>链表，每次将分配一大块内存给它（负责32B区块的分配，里面有20个小块，每个都是32B，但是实际分配的时候是20块的两倍大小，剩余的部分可能分配给其他的<code>#x</code>链表）。当一个vector里面存储一个32B的stone类型的对象，会在<code>#3</code>链表里指定一小块给该对象。</p>
<p>（2）embedded pointers</p>
<blockquote>
<p>嵌入式指针工作原理：借用A对象所占用的内存空间中的前4个字节，这4个字节用来 链住这些空闲的内存块；<br>但是，一旦某一块被分配出去，那么这个块的 前4个字节 就不再需要，此时这4个字节可以被正常使用；</p>
<p>参考:<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42604176/article/details/113871565">https://blog.csdn.net/qq_42604176/article/details/113871565</a></p>
<p>内存的使用方法是,使用的时候看成对象实例,空闲的时候会看成next指针.</p>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/KinWaiYuen/KinWaiYuen.github.io/blob/master/c%2B%2B/%E4%BE%AF%E6%8D%B7%E5%86%85%E5%AD%98.md">https://github.com/KinWaiYuen/KinWaiYuen.github.io/blob/master/c%2B%2B/%E4%BE%AF%E6%8D%B7%E5%86%85%E5%AD%98.md</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011041526.png" alt="4_内存管理_52"></p>
<h2 id="24-G2-9-std-alloc运行一瞥01-05"><a href="#24-G2-9-std-alloc运行一瞥01-05" class="headerlink" title="24 G2.9 std::alloc运行一瞥01-05"></a>24 G2.9 std::alloc运行一瞥01-05</h2><p>（1）源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;                        <span class="comment">//小區塊的上調邊界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;                  <span class="comment">//小區塊的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;; <span class="comment">//free-lists 個數</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// union obj &#123;                   //G291[o],CB5[x],VC6[x]</span></span><br><span class="line"><span class="comment">//   union obj* free_list_link;  //這麼寫在 VC6 和 CB5 中也可以，</span></span><br><span class="line"><span class="comment">// &#125;;                            //但以後就得使用 &quot;union obj&quot; 而不能只寫 &quot;obj&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__obj</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__obj</span>* free_list_link;</span><br><span class="line">&#125; obj;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*   start_free = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>*   end_free = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span>  heap_size = <span class="number">0</span>;</span><br><span class="line">obj* free_list[__NFREELISTS]</span><br><span class="line">     = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="meta"># enum &#123;__ALIGN = 8&#125;;  </span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ROUND_UP</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个常量<code>__ALIGN</code>，它表示内存分配时的对齐边界，设定为8字节。然后，定义了一个函数 <code>ROUND_UP</code>，该函数接受一个大小（<code>bytes</code>）作为参数，然后将其上调到对齐边界。</p>
<p>具体来说，<code>ROUND_UP</code>函数的作用是将传入的大小（<code>bytes</code>）上调到<code>__ALIGN</code>的倍数。这是通过以下步骤实现的：</p>
<ul>
<li>将<code>bytes</code>加上<code> __ALIGN-1</code>，即<code> bytes + 7</code>；</li>
<li>对结果进行按位与操作，通过<code>&amp; ~(__ALIGN - 1)</code>将最低的3位清零，确保结果是<code>__ALIGN</code>的倍数。</li>
</ul>
<blockquote>
<p>这样做的目的是为了满足内存对齐的要求。在一些硬件体系结构中，访问未对齐的内存可能会导致性能问题或者错误，因此内存分配时通常需要对齐到某个特定的边界。这个函数就提供了一种简单的方法来确保分配的内存大小是对齐的。</p>
</blockquote>
<p>（2）std::alloc运行01-05</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053088.png" alt="4_内存管理_53"></p>
<ol start="2">
<li>当一个容器里面存储的元素大小是<code>32B</code>时，它的运作过程如下：</li>
</ol>
<ul>
<li><p>挂在<code>32 / 8 - 1 = #3</code>号链表；</p>
</li>
<li><p>刚开始的时候pool为空，此时要分配<code>32 * 20 *2 + RoundUp(0 &gt;&gt; 4)= 1280B</code>大小的空间为pool，然后从pool里面切割20个小块（共640B）挂在<code>#3</code>链表上。第1个给容器，剩下的19个挂在<code>#3</code>链表；</p>
</li>
<li><p>此时pool的余量为<code>640B</code>。RoundUp是追加量，里面的大小是把上次的累计申请量右移4位(除以16)，由于这里是刚开始，没有累计申请量，故为0&gt;&gt;4。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053848.png" alt="4_内存管理_54"></p>
</li>
</ul>
<ol start="3">
<li>此时，又创建了新的容器，它里面的元素大小为<code>64B</code></li>
</ol>
<ul>
<li>对应#7链表；</li>
<li>此时链表为空。由于上页的pool里面还剩<code>640B</code>，现在将其切分为<code>640/64 = 10</code>个区块，第1个给容器，剩下的9个挂在<code>#7</code>链表；</li>
<li>此时pool的余量为<code>0B</code>，因为被切分挂到链表上了。<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053984.png" alt="4_内存管理_55"></li>
</ul>
<ol start="4">
<li>在上面的基础上，现在新建容器，它的元素大小为<code>96B</code></li>
</ol>
<ul>
<li>对应<code>96 / 8 - 1 = #11</code>链表；</li>
<li>先检查pool是否有余量，由于pool为空，此时调用malloc分配一大块作为pool，总共大小为<code>96x 20 x 2 + RoundUp(1280 &gt;&gt; 4) = 3840 + 80 = 3920B</code>，切割20个区块拿出来用，第1个给容器，另外19个挂在<code>#11</code>链表上；</li>
<li>此时pool的余量为<code>3920−(96×20)=3920−1920=2000 B</code>。累计申请量是1280 + 3920 &#x3D; 5200B。<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053482.png" alt="4_内存管理_56"></li>
</ul>
<ol start="5">
<li>再次新建容器，里面元素大小是<code>88B</code></li>
</ol>
<ul>
<li><p>挂在<code>88 / 8 - 1 = #10</code>号链表；</p>
</li>
<li><p>现在pool中的余量为<code>2000B</code>，将2000B切分为20个区块（每个区块88B），第1个给容器，剩下的19个挂在<code>#10</code>链表上；</p>
</li>
<li><p>此时pool的余量为<code>2000 - 88 x 20 = 240B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405011053390.png" alt="4_内存管理_57"></p>
</li>
</ul>
<h2 id="25-G2-9-std-alloc运行一瞥06-10"><a href="#25-G2-9-std-alloc运行一瞥06-10" class="headerlink" title="25 G2.9 std::alloc运行一瞥06-10"></a>25 G2.9 std::alloc运行一瞥06-10</h2><ol start="6">
<li>下面这张图表示容器**连续申请3次<code>88B</code>**大小的空间</li>
</ol>
<ul>
<li><p>由于上面已经在<code>#10</code>链表上挂了19个大小为<code>88B</code>的区块，这时候直接从该链表上拿下来3个区块返回给容器即可；</p>
</li>
<li><p>此时pool的余量为<code>240B</code>没变。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021045105.png" alt="4_内存管理_58"></p>
</li>
</ul>
<ol start="7">
<li>又来新的容器，它的元素大小为8B</li>
</ol>
<ul>
<li><p>挂在<code>8 / 8 - 1 = #0</code>号链表；</p>
</li>
<li><p>根据06，pool容量为<code>240B</code>，从pool里面切分出20个区块，共<code>8B x 20 = 160B</code>大小，第1个返回给容器，其余19个区块挂在<code>#0</code>链表上；</p>
</li>
<li><p>此时pool的余量为<code>240 - 160 = 80B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021045366.png" alt="4_内存管理_59"></p>
</li>
</ul>
<ol start="8">
<li>又来新的容器，它的元素大小为<code>104B</code></li>
</ol>
<ul>
<li><p>挂在<code>104 / 8 - 1 = #12</code>链表；</p>
</li>
<li><p>由于此时pool余量为<code>80B</code>，一个大小为<code>104B</code>的区块都切分不了。此时这个<code>80B</code>大小的空间就是碎片，需要将其挂在<code>80 / 8 - 1 = #9</code>链表上。碎片处理完之后， 再来应付现在的需求：<code>104B</code>的分配；</p>
</li>
<li><p>现在再调用<code>malloc</code>分配一大块，大小为<code>104 x 20 x 2 + RoundUp(5200 &gt;&gt; 4) = 4160 + RoundUp(325) = 4160 + 328 = 4488</code>；把第1个分配给容器，切出的19个挂在<code>#12</code>链表上。累计申请量为<code>5200 + 4488 = 9688B</code>；</p>
</li>
<li><p>此时pool的余量为<code>4488 - 104 x 20 = 2408B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021045618.png" alt="4_内存管理_60"></p>
</li>
</ul>
<ol start="9">
<li>现在申请<code>112B</code></li>
</ol>
<ul>
<li><p>挂在<code>112 / 8 - 1 = #13</code>链表上；</p>
</li>
<li><p>根据08，pool容量为<code>2408B</code>，从里面取出<code>112 * 20 = 2240B</code>，第1个返回给容器，留下19个挂在<code>#13</code>链表上；</p>
</li>
<li><p>此时pool的余量为<code>2408 - 2240 = 168B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021045344.png" alt="4_内存管理_61"></p>
</li>
</ul>
<ol start="10">
<li>现在的新需求是申请<code>48B</code></li>
</ol>
<ul>
<li>挂在<code>48 / 8 - 1 = #5</code>链表上；</li>
<li>根据09，pool余量是<code>168B</code>，可以分配<code>168 / 48 = 3</code>个区块，第1个返回给容器，剩下2个挂在<code>#5</code>链表上；</li>
<li>此时pool的余量为<code>24B</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021046301.png" alt="4_内存管理_62"></p>
<h2 id="26-G2-9-std-alloc运行一瞥11-13"><a href="#26-G2-9-std-alloc运行一瞥11-13" class="headerlink" title="26 G2.9 std::alloc运行一瞥11-13"></a>26 G2.9 std::alloc运行一瞥11-13</h2><p>下面看一下内存分配失败的动作。</p>
<ol start="11">
<li>新的容器请求<code>72B</code>的大小</li>
</ol>
<ul>
<li><p>挂在<code>72 / 8 - 1 = #8</code>链表；</p>
</li>
<li><p>pool容量为<code>24B</code>，不足以分配一个大小为<code>72B</code>的区块，于是这个大小为<code>24B</code>的pool就成为碎片，需要先挂在<code>24 / 8 - 1 = #2</code>链表，所以把这个pool余量挂在#2链表, 然后调用malloc分配<code>72 x 20 x 2 + RoundUP(9688 &gt;&gt; 4) = 3488B</code>。在实验过程中把系统heap大小设置为<code>10000B</code>，前面已经累计分配了<code>9688B</code>，因此无法满足本次内存分配。</p>
</li>
<li><p>此时，alloc从手中资源取最接近<code>72B</code>的大小回填pool，这里最接近的是<code>80B</code>(即在<code>#9</code>链表有1个空的区块可用)，然后从其<code>80B</code>中切<code>72B</code>给容器，此时pool的余量为<code>80 - 72 = 8B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021131569.png" alt="4_内存管理_63"></p>
</li>
</ul>
<ol start="12">
<li>容器再申请<code>72B</code></li>
</ol>
<ul>
<li><p><code>#8</code>链表没有区块可用，而pool余量为<code>8B</code>，不足以供应1个区块。因此先将pool余量挂在<code>#0</code>链表上，然后想要调用malloc分配<code>72 x 20 x 2 + RoundUP(9688 &gt;&gt; 4) = 3488B</code>的空间，此时依然无法满足分配；</p>
</li>
<li><p>于是alloc从手中资源取最接近<code>72B</code>的<code>88B</code>（#10链表）回填pool。因为上面的<code>80B</code>（<code>#9</code>链表）已经用完了，从<code>88B</code>中切出<code>72B</code>返回给容器；</p>
</li>
<li><p>此时pool余量为<code>88 - 72 = 16B</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021133827.png" alt="4_内存管理_64"></p>
</li>
</ul>
<ol start="13">
<li>新的容器申请<code>120B</code></li>
</ol>
<ul>
<li><p>挂在<code>120 / 8 - 1 = #14</code>链表；</p>
</li>
<li><p>同样的，pool供应不足，先将上面的<code>16B</code>挂在<code>#1</code>链表上，再想要malloc分配一大块也分配不出，无法满足需求；</p>
</li>
<li><p>于是，alloc从手中资源中取最接近<code>120B</code>的区块回填pool，但是<code>#14</code>链表和<code>#15</code>链表都是空的，于是无法分配。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021135087.png" alt="4_内存管理_65"></p>
</li>
</ul>
<p>检讨：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405021135931.png" alt="4_内存管理_66"></p>
<h2 id="27-G2-9-std-alloc源码剖析（上）"><a href="#27-G2-9-std-alloc源码剖析（上）" class="headerlink" title="27 G2.9 std::alloc源码剖析（上）"></a>27 G2.9 std::alloc源码剖析（上）</h2><h2 id="28-G2-9-std-alloc源码剖析（中）"><a href="#28-G2-9-std-alloc源码剖析（中）" class="headerlink" title="28 G2.9 std::alloc源码剖析（中）"></a>28 G2.9 std::alloc源码剖析（中）</h2><h2 id="29-G2-9-std-alloc源码剖析（下）"><a href="#29-G2-9-std-alloc源码剖析（下）" class="headerlink" title="29 G2.9 std::alloc源码剖析（下）"></a>29 G2.9 std::alloc源码剖析（下）</h2><h2 id="30-G2-9-std-alloc观念大整理"><a href="#30-G2-9-std-alloc观念大整理" class="headerlink" title="30 G2.9 std::alloc观念大整理"></a>30 G2.9 std::alloc观念大整理</h2><h2 id="31-G4-9-pull-allocator运行观察"><a href="#31-G4-9-pull-allocator运行观察" class="headerlink" title="31 G4.9 pull allocator运行观察"></a>31 G4.9 pull allocator运行观察</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/29/Computer/C++/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/STL%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/29/Computer/C++/%E4%BE%AF%E6%8D%B7C++%E7%B3%BB%E5%88%97/STL%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">STL标准库与泛型编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-29 19:16:16 / 修改时间：19:17:57" itemprop="dateCreated datePublished" datetime="2024-04-29T19:16:16+08:00">2024-04-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/%E4%BE%AF%E6%8D%B7C-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">侯捷C++系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>27</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>STL容器的大概分类如下：</p>
<ul>
<li>标准STL序列容器</li>
<li>标准STL关联容器</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/26/Computer/C++/STL/STL%E4%B9%8B%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%88priority_queue%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/26/Computer/C++/STL/STL%E4%B9%8B%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%88priority_queue%EF%BC%89/" class="post-title-link" itemprop="url">STL之优先级队列（priority_queue）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-26 15:58:50 / 修改时间：16:33:23" itemprop="dateCreated datePublished" datetime="2024-04-26T15:58:50+08:00">2024-04-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/STL/" itemprop="url" rel="index"><span itemprop="name">STL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>659</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>优先级队列（priority_queue）是C++标准库中的一个容器适配器（container adapter），其中的元素按照一定的优先级进行排序，每次取出的元素都是优先级最高的。其底层实现通常使用堆（heap）数据结构。</p>
<p>定义在<queue>头文件中。</p>
<p>默认情况下，priority_queue使用std::less作为比较函数，即元素的优先级按照从大到小的顺序排列。</p>
<h2 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a>二、特点</h2><p>优先级排序：priority_queue中的元素按照一定的优先级进行排序。默认情况下，元素的优先级按照从大到小的顺序排列，也可以通过自定义的比较函数来指定不同的排序方式。</p>
<p>自动排序：在插入元素时，priority_queue会根据元素的优先级自动进行排序。每次插入新元素时，都会将新元素放置在正确的位置上。</p>
<p>取出优先级最高元素：priority_queue提供了一种方便的方式来取出优先级最高的元素。使用top()函数可以访问优先级最高的元素，而使用pop()函数可以将该元素从队列中移除。</p>
<p>底层实现采用堆：priority_queue通常使用堆（heap）数据结构来实现。堆是一种具有特定性质的二叉树，可以高效地插入新元素和取出优先级最高的元素。</p>
<p>动态大小：priority_queue的大小可以根据需要进行动态调整。可以随时插入新元素和删除已有元素，并在必要时自动重新排序。</p>
<h2 id="三、相关函数"><a href="#三、相关函数" class="headerlink" title="三、相关函数"></a>三、相关函数</h2><h3 id="1-声明"><a href="#1-声明" class="headerlink" title="1. 声明"></a>1. 声明</h3>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">priority_queue &lt;node&gt; q;</span><br><span class="line"><span class="comment">// node是一个结构体</span></span><br><span class="line"><span class="comment">// 结构体里重载了‘&lt;’小于符号</span></span><br><span class="line"></span><br><span class="line">priority_queue &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">// 不需要#include&lt;vector&gt;头文件</span></span><br><span class="line"><span class="comment">// 注意后面两个“&gt;”不要写在一起，“&gt;&gt;”是右移运算符</span></span><br><span class="line"></span><br><span class="line">priority_queue &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure>

<h3 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h3>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">size</span>();	<span class="comment">// 返回q里元素个数</span></span><br><span class="line">q.<span class="built_in">empty</span>();	<span class="comment">// 返回q是否为空，空则返回1，否则返回0</span></span><br><span class="line">q.<span class="built_in">push</span>(k);	<span class="comment">// 在q的末尾插入k</span></span><br><span class="line">q.<span class="built_in">pop</span>();	<span class="comment">// 删掉q的第一个元素</span></span><br><span class="line">q.<span class="built_in">top</span>();	<span class="comment">// 返回q的第一个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="3-排序实现"><a href="#3-排序实现" class="headerlink" title="3. 排序实现"></a>3. 排序实现</h3><ol>
<li><p>默认的优先队列（结构体，重载小于）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node &amp; a) <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> x&lt;a.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>less和greater优先队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt; p;</span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// less&lt;int&gt;:14 12 10 8 6（大顶堆）</span></span><br><span class="line"><span class="comment">// greater&lt;int&gt;:6 8 10 12 14（小顶堆）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义仿函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义仿函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareByAge</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person&amp; p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.age &gt; p2.age;  <span class="comment">// 按照年龄从小到大排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/26/Computer/C++/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/26/Computer/C++/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97/" class="post-title-link" itemprop="url">字符串与整数的相互转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-26 10:40:36 / 修改时间：17:05:52" itemprop="dateCreated datePublished" datetime="2024-04-26T10:40:36+08:00">2024-04-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>529</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天在做<strong>Leetcode 150. 逆波兰表达式求值</strong>一题时，涉及到字符串转换为整数的相关问题，遂进行如下探讨：</p>
<h2 id="1、字符串转换为整数"><a href="#1、字符串转换为整数" class="headerlink" title="1、字符串转换为整数"></a>1、字符串转换为整数</h2><h3 id="（1）四种转换方法"><a href="#（1）四种转换方法" class="headerlink" title="（1）四种转换方法"></a>（1）四种转换方法</h3>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、stoi()，传入string类型</span></span><br><span class="line">  string s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">  <span class="type">int</span> num1 = <span class="built_in">stoi</span>(s1);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2、atoi()，传入const char *类型</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s2 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">  <span class="type">int</span> num2 = <span class="built_in">atoi</span>(s2);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3、stringstream</span></span><br><span class="line">  <span class="function">stringstream <span class="title">ss</span><span class="params">(s1)</span></span>;</span><br><span class="line">  <span class="type">int</span> num3;</span><br><span class="line">  ss &gt;&gt; num3;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="type">int</span> num4;</span><br><span class="line">  <span class="built_in">sscanf</span>(s1.<span class="built_in">c_str</span>(), <span class="string">&quot;%d&quot;</span>, &amp;num4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）为什么下面四行代码得到了如下结果？"><a href="#（2）为什么下面四行代码得到了如下结果？" class="headerlink" title="（2）为什么下面四行代码得到了如下结果？"></a>（2）为什么下面四行代码得到了如下结果？</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">stoi</span>(<span class="string">&quot;13&quot;</span>) &lt;&lt; endl;  <span class="comment">// 13</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;13&quot;</span> - <span class="string">&quot;0&quot;</span> &lt;&lt; endl;  <span class="comment">// -3</span></span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;1&#x27;</span> - <span class="string">&#x27;0&#x27;</span> &lt;&lt; endl;   <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;1&quot;</span> - <span class="string">&quot;0&quot;</span> &lt;&lt; endl;   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>解释如下：</p>
<ol>
<li><code>stoi(&quot;13&quot;)</code> 将字符串 “13” 转换为整数，结果是 13。</li>
<li><code>&quot;13&quot; - &quot;0&quot;</code> 这里使用了字符串字面值进行减法运算，实际上这是不允许的，因为 C++ 中字符串字面值不能直接进行减法运算。但是在这个上下文中，编译器会尝试将字符串字面值转换为字符指针，然后进行指针运算，因此得到的结果是字符指针之间的差，即指向字符串 “13” 和 “0” 的地址之间的距离，而不是它们所代表的整数之差。在这个例子中，”13” 的地址比 “0” 的地址大，因此结果是负值，具体数值取决于编译器和平台。</li>
<li><code>&#39;1&#39; - &#39;0&#39;</code> 是字符之间的减法运算。字符 ‘1’ 对应的 ASCII 码是 49，字符 ‘0’ 对应的 ASCII 码是 48，因此结果是 1。</li>
<li><code>&quot;1&quot; - &quot;0&quot;</code> 和第二行的情况类似，仍然是字符串字面值之间的指针运算，结果是字符串指针之间的差，而不是字符串所代表的整数之差。</li>
</ol>
<h2 id="2、整数转换为字符串"><a href="#2、整数转换为字符串" class="headerlink" title="2、整数转换为字符串"></a>2、整数转换为字符串</h2>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">intToString</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">  string str;</span><br><span class="line">  <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> digit = num % <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> ch = digit + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    str = ch + str;  <span class="comment">// 将字符添加到字符串的前面</span></span><br><span class="line">    num /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、to_string</span></span><br><span class="line">  <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">  string str1 = <span class="built_in">to_string</span>(num);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2、stringstream</span></span><br><span class="line">  stringstream ss;</span><br><span class="line">  ss &lt;&lt; num;</span><br><span class="line">  string str2 = ss.<span class="built_in">str</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3、sprintf</span></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">20</span>];</span><br><span class="line">  <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">  <span class="function">string <span class="title">str</span><span class="params">(buffer)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4、自定义实现</span></span><br><span class="line">  str = <span class="built_in">intToString</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/24/Computer/C++/new%E4%B8%8Eoperator%20new/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/24/Computer/C++/new%E4%B8%8Eoperator%20new/" class="post-title-link" itemprop="url">new与operator new</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-24 14:13:55 / 修改时间：15:30:55" itemprop="dateCreated datePublished" datetime="2024-04-24T14:13:55+08:00">2024-04-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>区分三个概念：new operator、operator new和placement new</strong></p>
</blockquote>
<h1 id="一、new-operator、operator-new和placement-new"><a href="#一、new-operator、operator-new和placement-new" class="headerlink" title="一、new operator、operator new和placement new"></a>一、new operator、operator new和placement new</h1><h2 id="1、new-operator（new-操作符）"><a href="#1、new-operator（new-操作符）" class="headerlink" title="1、new operator（new 操作符）"></a>1、new operator（new 操作符）</h2><p>当写下<code>string *ps = new string(&quot;Memory Management&quot;)</code>时，使用的<code>new</code>是<strong>new操作符</strong>。这个操作符和<code>sizeof</code>一样是语言内置的，它总是完成以下功能：</p>
<ol>
<li>分配内存（调用operator new函数）；</li>
<li>调用构造函数初始化内存中的对象。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241419515.png" alt="image-20240424141921292"></p>
<h2 id="2、operator-new"><a href="#2、operator-new" class="headerlink" title="2、operator new"></a>2、operator new</h2><p>new操作符调用一个函数来完毕必需的内存分配，即<strong>operator new</strong>。注意这个函数的职责和<code>malloc</code>一样，只是为了分配内存。</p>
<p>函数operator new 通常这样声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值类型：<code>void *</code>（返回一个未经处理的<code>raw</code>指针）</li>
<li>参数<code>size_t size</code>：确定分配多少内存。可以添加额外的參数重载函数<code>operator new</code>，但第一个參数类型必须是<code>size_t</code>。</li>
</ul>
<h2 id="3、placement-new"><a href="#3、placement-new" class="headerlink" title="3、placement new"></a>3、placement new</h2><blockquote>
<p><strong>placement new是一种特殊的operator new，作用于一块已分配但未处理或未初始化的raw内存。</strong></p>
</blockquote>
<p>当存在一些已经被分配单尚未被处理的<code>raw</code>内存时，如果需要再这些内存中构造一个对象，可以使用<strong>一个特殊的operator new</strong> ，它被称为<strong>placement new</strong>。当程序使用共享内存或memory-mapped I&#x2F;O时这个函数可能实用，由于在这样程序里对象必须被放置在一个确定地址上或一块被例程分配的内存里。</p>
<p>如下例所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">　<span class="keyword">public</span>:</span><br><span class="line">　　<span class="built_in">Widget</span>(<span class="type">int</span> widgetSize);</span><br><span class="line">　　...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Widget * <span class="title">constructWidgetInBuffer</span><span class="params">(<span class="type">void</span> *buffer,<span class="type">int</span> widgetSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　<span class="keyword">return</span> <span class="built_in">new</span> (buffer) <span class="built_in">Widget</span>(widgetSize);  <span class="comment">// placement new的用法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细来说，<code>new (buffer) Widget(widgetSize)</code>是new操作符的一个使用方法，需要使用一个额外的变量<code>buffer</code>。当new操作符隐含调用operator new函数时，把这个变量传递给它，此时，被调用的operator new函数除了带有强制的参数<code>size_t</code>外，还必须接受<code>void *</code>指针参数，指向构造对象占用的内存空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>, <span class="type">void</span> *location)</span>  <span class="comment">// size_t没有名字，以防止编译器发出警告说它没有使用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　<span class="keyword">return</span> location;</span><br><span class="line">  <span class="comment">// 在使用placement new的情况下，调用者已经获得了指向内存的指针</span></span><br><span class="line">  <span class="comment">// 由于调用者知道对象应该放在哪里，placement new必须做的就是返回转递给它的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p><strong>new 、operator new 和 placement new 区别</strong></p>
<p>（1）<code>new</code>：不能被重载，其行为总是一致的。它先调用operator new分配内存，然后调用构造函数初始化那段内存。</p>
<p>（2）<code>operator new</code>：要实现不同的内存分配行为，应该重载operator new，而不是new。</p>
<p>operator new就像operator +一样，是可以重载的。如果类中没有重载operator new，那么调用的就是全局的::operator  new来完成堆的分配。同理，operator new[]、operator delete、operator delete[]也是可以重载的。</p>
<p>重载时，返回类型必须声明为void*，第一个参数类型必须为表达要求分配空间的大小（字节），类型为size_t，可以带其它参数。</p>
<p>（3）<code>placement new</code>：只是operator new重载的一个标准、全局的版本。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。因此不能删除它，但需要调用对象的析构函数。</p>
<p>如果你想在已经分配的内存中创建一个对象，使用new时行不通的。也就是说placement new允许你在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。原型中void* p实际上就是指向一个已经分配好的内存缓冲区的的首地址。</p>
<h1 id="二、Deletion-and-Memory-Deallocation"><a href="#二、Deletion-and-Memory-Deallocation" class="headerlink" title="二、Deletion and Memory Deallocation"></a>二、Deletion and Memory Deallocation</h1><h2 id="1、delete和operator-delete"><a href="#1、delete和operator-delete" class="headerlink" title="1、delete和operator delete"></a>1、delete和operator delete</h2><p>为了避免内存泄漏，每一个动态内存分配必须与一个等同相反的deallocation相应。<strong>函数operator delete</strong>与<strong>delete操作符</strong>的关系与<strong>operator new</strong>与<strong>new操作符</strong>的关系一样。</p>
<p><code>delete</code>总是完成下述功能：</p>
<ol>
<li>调用析构函数；</li>
<li>释放内存。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241445181.png" alt="image-20240424144503094"></p>
<p><code>operator delete</code>函数用来释放内存，声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *memoryToBeDeallocated)</span></span>;</span><br></pre></td></tr></table></figure>

<p>因此，<strong>假设你仅仅想处理未被初始化的内存，你应该绕过new和delete操作符，而调用operator new 获得内存和operator delete释放内存给系统</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *buffer = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="number">50</span>*<span class="built_in">sizeof</span>(<span class="type">char</span>)); <span class="comment">// 分配足够的内存以容纳50个char</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//没有调用构造函数</span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>; <span class="comment">// 释放内存</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 没有调用析构函数</span></span><br></pre></td></tr></table></figure>

<p>这与在C中调用malloc和free等同。</p>
<h2 id="2、placement-new建立的对象怎样释放？"><a href="#2、placement-new建立的对象怎样释放？" class="headerlink" title="2、placement new建立的对象怎样释放？"></a>2、placement new建立的对象怎样释放？</h2><p>假设用<code>placement new</code>在内存中建立对象，应该避免在该内存中使用delete 操作符。</p>
<p>由于delete操作符调用operator delete释放内存，但这片存最开始并不是被operator new分配的，placement new只是返回传递给它的这片内存的指针，因此无法得知这片内存究竟来自何处。因此，<strong>应该显式调用析构函数来解除构造函数的影响</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在共享内存中分配和释放内存的函数 void * mallocShared(size_t size);</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">freeShared</span><span class="params">(<span class="type">void</span> *memory)</span></span>;</span><br><span class="line"><span class="type">void</span> *sharedMemory = <span class="built_in">mallocShared</span>(<span class="built_in">sizeof</span>(Widget));</span><br><span class="line">Widget *pw = <span class="comment">// 如上所看到的</span></span><br><span class="line"><span class="built_in">constructWidgetInBuffer</span>(sharedMemory, <span class="number">10</span>); <span class="comment">// 使用</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 执行placement new操作 </span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">delete</span> pw;      <span class="comment">// 结果不确定! 共享内存来自mallocShared, 而不是operator new</span></span><br><span class="line">pw-&gt;~<span class="built_in">Widget</span>();  <span class="comment">// 正确。 析构pw指向的Widget，但并未释放存放Widget的这片内存</span></span><br><span class="line"><span class="built_in">freeShared</span>(pw); <span class="comment">// 正确。 释放pw指向的共享内存，但并未调用析构函数</span></span><br></pre></td></tr></table></figure>

<h2 id="3、new-delete和array-new-array-delete应该搭配使用"><a href="#3、new-delete和array-new-array-delete应该搭配使用" class="headerlink" title="3、new&#x2F;delete和array new&#x2F;array delete应该搭配使用"></a>3、new&#x2F;delete和array new&#x2F;array delete应该搭配使用</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241457401.png" alt="image-20240424145754309"></p>
<h1 id="三、相关问题"><a href="#三、相关问题" class="headerlink" title="三、相关问题"></a>三、相关问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Accoun *parray= <span class="keyword">new</span> Account[<span class="number">100</span>]; </span><br><span class="line"><span class="keyword">delete</span> parray; </span><br><span class="line"><span class="keyword">delete</span>[] parray; </span><br></pre></td></tr></table></figure>

<p>方括号的存在会使编译器获取数组大小（size）然后析构函数再被依次应用在每个元素上，一共size次。否则，只有一个元素被析构。 但无论哪种情况，分配的全部空间被返还给自由存储区。 </p>
<h2 id="1、为什么无论哪种情况，分配的全部空间被返还给自由存储区"><a href="#1、为什么无论哪种情况，分配的全部空间被返还给自由存储区" class="headerlink" title="1、为什么无论哪种情况，分配的全部空间被返还给自由存储区?"></a>1、为什么无论哪种情况，分配的全部空间被返还给自由存储区?</h2><p>首先，针对最后一句话“<strong>无论哪种情况，分配的全部空间被返还给自由存储区</strong>”，实际上是指：</p>
<p>无论是使用 <code>delete</code> 还是 <code>delete []</code>，分配的全部空间都会被释放，并返回给自由存储区。区别在于，<code>delete</code> 只会调用一次析构函数，而 <code>delete []</code> 会调用数组中每个元素的析构函数。因此，如果你分配了一个数组并使用 <code>delete</code> 来释放，只有一个元素的析构函数会被调用，可能导致内存泄漏，因为其他元素的资源没有得到正确释放。而使用 <code>delete []</code> 则能保证每个元素的析构函数都被正确调用，避免了这种潜在的内存泄漏问题。</p>
<h2 id="2、对于delete-parray，编译器怎么知道parray这个指针实际指向的是数组还是单个元素？"><a href="#2、对于delete-parray，编译器怎么知道parray这个指针实际指向的是数组还是单个元素？" class="headerlink" title="2、对于delete[] parray，编译器怎么知道parray这个指针实际指向的是数组还是单个元素？"></a>2、对于delete[] parray，编译器怎么知道parray这个指针实际指向的是数组还是单个元素？</h2><p>（1）一般在分配时分配器会自动写一个日志（即在分配的内存之前有一个结构）用于记录分配的大小，分配内容的sizeof等等。 </p>
<p>直观来说，<code>delete</code>和<code>delete[]</code>都是传入一个<code>void*</code>，因此如果不保存日志就无法知道分配时到底是分配了一个还是多个单元。所以虽然<code>delete</code>和<code>delete[]</code>不同，但是分配器在执行释放过程中都会读取这个日志，从而了解到底应该释放多少内存，但是从程序员的角度来说，既然分配了数组，就应该用<code>delete[]</code>。</p>
<p>（2）在VC下用汇编跟过delete[]的执行情况,发现这个 “日志 “就是一个4字节长的整数记录数组元素个数,紧挨在数组第一个元素之前。但是有个前提：对象类型(或其基类)有显式析构函数.换句话说,析构函数是非<code>virtual</code>的。否则的话,数组前面是没有这个日志的。其实对于析构函数是<code>virtual</code>的情况，<code>delete[]</code>时无需调用其析构函数，因此此时<code>VC</code>把<code>delete[]</code>当做<code>delete</code>同样处理。</p>
<p>（3）<code>delete parray</code>，编译器得到类型信息是<code>Account</code>单个的指针，那么释放时，只调用一次析构函数。<br><code>delete[] parray</code>，编译器得到的类型信息是<code>Account[]</code>类型，则按照<code>Account</code>数组来处理，依次调用每个元素的析构函数。 </p>
<h2 id="3、编译器又是如何获知这个数组的大小？"><a href="#3、编译器又是如何获知这个数组的大小？" class="headerlink" title="3、编译器又是如何获知这个数组的大小？"></a>3、编译器又是如何获知这个数组的大小？</h2><p>当我们使用<code>operator new</code>为一个自定义类型对象分配内存时，我们得到的内存要比实际对象的内存大一些，这些内存除了要存储对象数据外，还需要记录这片内存的大小，此方法称为<code>cookie</code>。这一点上的实现依据不同的编译器不同。（例如<code>MFC</code>选择在所分配内存的头部存储对象实际数据，而后面的部分存储边界标志和内存大小信息。<code>g++</code>则采用在所分配内存的头4个自己存储相关信息，而后面的内存存储对象实际数据。）当我们使用<code>delete operator</code>进行内存释放操作时，<code>delete operator</code>就可以根据这些信息正确的释放指针所指向的内存块。<br>对于<code>parray</code>指针，可以根据这样的<code>cookie</code>信息来得到指向内存空间的大小，<code>delete parray</code>和<code>delete[] parray</code>都是一样的，同样一个指针，<code>cookie</code>信息是相同的，所以对应的内存都会被释放掉。但是由于编译器理解两种情况下的类型是不同的，所以调用析构函数会有不同。 </p>
<h1 id="四、相关参考"><a href="#四、相关参考" class="headerlink" title="四、相关参考"></a>四、相关参考</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241530554.png" alt="image-20240424153034458"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241530444.png" alt="image-20240424153053351"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luxiaoxun/archive/2012/08/10/2631812.html">C++中的new、operator new与placement new</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/17/Computer/Linux%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/17/Computer/Linux%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Linux基础相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-17 10:06:59 / 修改时间：10:36:05" itemprop="dateCreated datePublished" datetime="2024-04-17T10:06:59+08:00">2024-04-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>39 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、GCC安装"><a href="#1、GCC安装" class="headerlink" title="1、GCC安装"></a>1、GCC安装</h2><h3 id="（1）GCC相关知识点"><a href="#（1）GCC相关知识点" class="headerlink" title="（1）GCC相关知识点"></a>（1）GCC相关知识点</h3><p>GCC（GNU Compiler Collection， GNU编译器套件）是由GNU开发的编程语言译器。</p>
<p>gcc和g++都是GNU（组织）的一个编译器</p>
<ul>
<li>误区一：gcc只能编译C程序，g++只能编译C++代码：<ul>
<li>后缀为.c时，gcc认为其是C程序，g++认为其是C++程序；</li>
<li>后缀为.cpp时，gcc和g++均认为其是C++程序。</li>
</ul>
</li>
<li>误区二：编译只能用gcc，链接只能用g++：<ul>
<li>严格来说不算错误，但混淆了概念，应该说：编译可以用gcc&#x2F;g++，而链接可以用g++或者gcc -lstdc++;</li>
<li>gcc命令不能自动和C++程序使用的库链接，所以通常使用g++来完成链接。但在编译阶段，g++会自动调用gcc，二者等价。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171012036.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171012580.png" alt="2"></p>
<h3 id="（2）GCC工作流程"><a href="#（2）GCC工作流程" class="headerlink" title="（2）GCC工作流程"></a>（2）GCC工作流程</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013866.png" alt="3"></p>
<ul>
<li><p>预处理：对头文件展开\删除代码中的注释\宏替换</p>
</li>
<li><p><strong>程序编译成可执行程序的过程：</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013529.png" alt="4"></p>
</li>
</ul>
<h2 id="2、静态库和动态库"><a href="#2、静态库和动态库" class="headerlink" title="2、静态库和动态库"></a>2、静态库和动态库</h2><h3 id="（1）静态库"><a href="#（1）静态库" class="headerlink" title="（1）静态库"></a>（1）静态库</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013337.png" alt="5"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013840.png" alt="6"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson/library<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">├── add.c</span><br><span class="line">├── div.c</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br><span class="line">root@iisayhi:~/lesson/library<span class="comment"># gcc main.c -o app -I ./include/ -l calc -L ./lib/</span></span><br><span class="line">root@iisayhi:~/lesson/library<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── app</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">		├── add.c</span><br><span class="line">		├── div.c</span><br><span class="line">		├── mult.c</span><br><span class="line">		└── sub.c</span><br></pre></td></tr></table></figure>

<h3 id="（2）动态库"><a href="#（2）动态库" class="headerlink" title="（2）动态库"></a>（2）动态库</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013622.png" alt="7"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013961.png" alt="8"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013076.png" alt="9"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/calc# **gcc -c -fpic add.c mult.c sub.c div.c** </span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# ls</span><br><span class="line">add.c  add.o  div.c  div.o  head.h  main.c  mult.c  mult.o  sub.c  sub.o</span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# **gcc -shared *.o -o libcalc.so**</span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# ll</span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x 2 root root  4096 Apr  6 22:49 ./</span><br><span class="line">drwxr-xr-x 4 root root  4096 Apr  6 22:47 ../</span><br><span class="line">-rw-r--r-- 1 root root    80 Apr  6 22:47 add.c</span><br><span class="line">-rw-r--r-- 1 root root  1376 Apr  6 22:48 add.o</span><br><span class="line">-rw-r--r-- 1 root root    94 Apr  6 22:47 div.c</span><br><span class="line">-rw-r--r-- 1 root root  1384 Apr  6 22:48 div.o</span><br><span class="line">-rw-r--r-- 1 root root   189 Apr  6 22:47 head.h</span><br><span class="line">-rwxr-xr-x 1 root root 15824 Apr  6 22:49 libcalc.so*</span><br><span class="line">-rw-r--r-- 1 root root   306 Apr  6 22:47 main.c</span><br><span class="line">-rw-r--r-- 1 root root    85 Apr  6 22:47 mult.c</span><br><span class="line">-rw-r--r-- 1 root root  1384 Apr  6 22:48 mult.o</span><br><span class="line">-rw-r--r-- 1 root root    85 Apr  6 22:47 sub.c</span><br><span class="line">-rw-r--r-- 1 root root  1376 Apr  6 22:48 sub.o</span><br></pre></td></tr></table></figure>

<ul>
<li>运行main可执行文件报错：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># gcc main.c -o main -I include/ -L lib/ -l calc</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ls</span></span><br><span class="line">include  lib  main  main.c  src</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">**./main: error <span class="keyword">while</span> loading shared libraries: [libcalc.so](&lt;http://libcalc.so/&gt;): cannot open shared object file: No such file or directory**</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffda29fd000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; not found</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbe8fa25000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007fbe8fc31000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>原因即是由于动态库是在程序启动后才被加载到内存中，而我们自己写的动态库libcalc.so并没有给出对应的路径去查找它，所以会报错。</p>
<p>解决方法：</p>
<blockquote>
<p>对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的 <strong>DT_RPATH段</strong> ——&gt; <strong>环境变量LD_LIBRARY_PATH</strong> ——&gt; <strong>&#x2F;etc&#x2F;ld.so.cache</strong>文件列表 ——&gt; <strong>&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib</strong>目录找到库文件后将其载入内存</p>
</blockquote>
<p><strong>1）DT_RPATH段 无法修改，系统本身固定值</strong></p>
<p><strong>2）环境变量LD_LIBRARY_PATH</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># echo $LD_LIBRARY_PATH </span></span><br><span class="line">:/root/lesson/lesson01/library/lib</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffff57e5000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; /root/lesson/lesson01/library/lib/libcalc.so (0x00007f06515af000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f06513aa000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f06515bb000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">a = 20, b = 12</span><br><span class="line">a + b = 32</span><br><span class="line">a - b = 8</span><br><span class="line">a * b = 240</span><br><span class="line">a / b = 1.666667</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>直接在终端中配置，当终端被关闭后该环境变量就会消失了，属于临时性配置。</p>
<p>永久性配置：</p>
<ul>
<li><p>用户级别</p>
<ul>
<li><p>根目录下，<code>vim .bashrc</code></p>
</li>
<li><p>在最后一行加上要添加的路径</p>
<p><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</code></p>
</li>
<li><p><code>source ~/.bashrc</code></p>
</li>
</ul>
</li>
<li><p>系统级别</p>
<ul>
<li><p><code>sudo vim /etc/profile</code></p>
</li>
<li><p>在最后一行加上要添加的路径</p>
<p><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</code></p>
</li>
<li><p><code>source /etc/profile</code></p>
</li>
</ul>
</li>
</ul>
<p><strong>3）&#x2F;etc&#x2F;ld.so.cache文件列表</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson<span class="comment"># ll /etc/ld.so.cache</span></span><br><span class="line">-rw-r--r-- 1 root root 74025 Jan 12 21:15 /etc/ld.so.cache</span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># **sudo vim /etc/ld.so.conf**</span></span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># **sudo ldconfig**</span></span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># cd lesson01/library/</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffd633f6000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; /root/lesson/lesson01/library/lib/libcalc.so (0x00007f7b8a4e1000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7b8a2ef000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f7b8a500000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">a = 20, b = 12</span><br><span class="line">a + b = 32</span><br><span class="line">a - b = 8</span><br><span class="line">a * b = 240</span><br><span class="line">a / b = 1.666667</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p><code>/etc/ld.so.cache</code>是一个二进制文件，无法直接用vim进行修改；</p>
<p>因此要借助<code>/etc/ld.so.conf</code>的帮助：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014770.png" alt="10"></p>
<p><strong>4）&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib目录</strong></p>
<p>不推荐使用，因为在上述目录下已经包含很多系统自带的库文件，因此可能存在重名导致被替换的问题存在。</p>
<h3 id="（3）静态库和动态库的对比"><a href="#（3）静态库和动态库的对比" class="headerlink" title="（3）静态库和动态库的对比"></a>（3）静态库和动态库的对比</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014481.png" alt="11"></p>
<ul>
<li>消耗系统资源、浪费内存：<ul>
<li>每个程序在运行时都会将静态库复制一份到内存中，多个程序同时运行时浪费内存；</li>
</ul>
</li>
<li>更新、部署、发布麻烦：<ul>
<li>每次更新、部署或发布时都需要重新编译</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014264.png" alt="12"></p>
<h2 id="3、Makefile"><a href="#3、Makefile" class="headerlink" title="3、Makefile"></a>3、Makefile</h2><ul>
<li>定义<ul>
<li>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 <code>Makefile 文件就像一个 Shell 脚本一样，也可以执行操作系统的命令</code>。</li>
<li><strong>Makefile 带来的好处就是“自动化编译”</strong> ，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如 Delphi 的 <code>make</code>，Visual C++ 的 <code>nmake</code>，Linux 下 GNU 的 <code>make</code>。</li>
</ul>
</li>
<li>命名规则</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014308.png" alt="13"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014605.png" alt="14"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014917.png" alt="15"></p>
<ul>
<li>工作原理</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015389.png" alt="16"></p>
<ul>
<li>变量</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015553.png" alt="17"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171018439.png" alt="Untitled"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019513.png" alt="Untitled"></p>
<p><strong>对原始写法进行简写：</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015837.png" alt="20"></p>
<p>改进1：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171018316.png" alt="Untitled"></p>
<p>改进2：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015549.png" alt="22"></p>
<p>改进3：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015818.png" alt="23"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY:clean  # 定义clean为伪目标</span><br></pre></td></tr></table></figure>

<p>改进4：<code>Makefile</code>中写了<code>clean</code>之后，在命令行要用<code>make clean</code>来调用</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019153.png" alt="24"></p>
<h2 id="4、GDB调试"><a href="#4、GDB调试" class="headerlink" title="4、GDB调试"></a>4、GDB调试</h2>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/17/Computer/Linux%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/13/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/13/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">手撕算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-13 14:56:15" itemprop="dateCreated datePublished" datetime="2024-04-13T14:56:15+08:00">2024-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-17 10:33:32" itemprop="dateModified" datetime="2024-04-17T10:33:32+08:00">2024-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9A%82%E4%B8%8D%E5%88%86%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">--暂不分类</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>455</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>合并K个有序数组</p>
<p>TOPK问题</p>
<p>逆波兰表达式</p>
<p>动态规划</p>
<p>快排最坏情况的比较次数，归并排序呢？</p>
<p>自定义实现strcpy函数</p>
<h3 id="1、字符串分割函数"><a href="#1、字符串分割函数" class="headerlink" title="1、字符串分割函数"></a>1、字符串分割函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//字符串分割函数</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">split</span><span class="params">(std::string str, std::string pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string::size_type pos;</span><br><span class="line">    std::vector&lt;std::string&gt; result;</span><br><span class="line">    str += pattern;<span class="comment">//扩展字符串以方便操作</span></span><br><span class="line">    <span class="type">int</span> size = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = str.<span class="built_in">find</span>(pattern, i);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; size)</span><br><span class="line">        &#123;</span><br><span class="line">            std::string s = str.<span class="built_in">substr</span>(i, pos - i);</span><br><span class="line">            result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            i = pos + pattern.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、string转int"><a href="#2、string转int" class="headerlink" title="2、string转int"></a>2、string转int</h3><p>1、使用atoi转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure>

<p>2、 使用std::stoi</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;-10&quot;</span>;</span><br><span class="line">std::<span class="built_in">stoi</span>(str);</span><br><span class="line"><span class="comment">// stoi()函数没有数字的话，程序虽然可以编译，但运行时会出错</span></span><br></pre></td></tr></table></figure>

<p>3、 通过 istringstream 转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;668&quot;</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function">std::istringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">ss &gt;&gt; num;</span><br></pre></td></tr></table></figure>

<p>使用 istringstream 可以从字符流中读取整数，与 ostringstream 是一种相反的操作</p>
<p>4、使用 sscanf</p>
<p>sscanf 函数是 C 语言标准库中的函数，可以用于从一个格式化的字符串中提取数据。在 C++ 中，可以使用 sscanf 函数将字符串转换为整数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">sscanf</span>(str.<span class="built_in">c_str</span>(), <span class="string">&quot;%d&quot;</span>, &amp;num) == <span class="number">1</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted number: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to convert the string to an integer.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、int转为string"><a href="#3、int转为string" class="headerlink" title="3、int转为string"></a>3、int转为string</h3><p>1、通过 std::to_string() 函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">to_string</span>(num)</span><br></pre></td></tr></table></figure>

<p>这种方式在 C++11 中才能使用，编译时记得加上 –std&#x3D;c++11 的选项</p>
<p>2、通过 ostringstream</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">std::ostringstream ss;</span><br><span class="line">ss &lt;&lt; num;</span><br><span class="line">std::cout &lt;&lt; ss.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure>

<p>这是一种通过字符流的方式将整数转换成字符串，这种方式在C++11之前也可以使用</p>
<p>3、通过 sprintf</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br></pre></td></tr></table></figure>

<p>这是一种C语言中的转换方式，sprintf 也可以换成更安全的 snprintf 函数，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;%d&quot;</span>, num);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/09/Computer/DataStruct/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/09/Computer/DataStruct/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="post-title-link" itemprop="url">代码随想录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-09 20:29:30" itemprop="dateCreated datePublished" datetime="2024-04-09T20:29:30+08:00">2024-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-30 20:03:53" itemprop="dateModified" datetime="2024-04-30T20:03:53+08:00">2024-04-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/DataStruct/" itemprop="url" rel="index"><span itemprop="name">DataStruct</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>36 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><h2 id="1、二分法"><a href="#1、二分法" class="headerlink" title="1、二分法"></a>1、二分法</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></p>
<ol>
<li><p>本题我采用左闭右开的取法，因此：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// &amp;&amp;</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br></pre></td></tr></table></figure>

<p>当<code>nums[mid]</code>和<code>target</code>不相等需要更新<code>left/right</code>时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = mid + <span class="number">1</span>;  <span class="comment">// left是取得到的</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">right = mid;	 <span class="comment">// right是取不到的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新<code>mid</code>时采用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/submissions/521863494/">35. 搜索插入位置</a></p>
<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<p>这道题做的时候卡了很久，最开始采用前闭后开的区间，但结果是错的，改成前闭后闭的区间就正确了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">searchLeftRange</span>(nums, target);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">searchRightRange</span>(nums, target);</span><br><span class="line">        <span class="comment">// 情况一</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">-2</span> || r == <span class="number">-2</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="comment">// 情况三</span></span><br><span class="line">        <span class="keyword">if</span> (r - l &gt; <span class="number">1</span>) <span class="keyword">return</span> &#123;l + <span class="number">1</span>, r - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 情况二</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchLeftRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">-2</span>;</span><br><span class="line">        <span class="comment">// 寻找左边界</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                l = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchRightRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">-2</span>;</span><br><span class="line">        <span class="comment">// 寻找右边界</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                r = left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69. x的平方根"></a>69. x的平方根</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/">69. x的平方根</a></p>
<p>1、由于y&#x3D;√x的图像是单调递增的，符合二分查找的条件，因此本题可采用二分查找的方式解决。</p>
<p>2、题目所述x为非负整数，因此left应该初始化为1而非0。</p>
<p>3、<strong>最后结束循环，返回右边界，主要是因为平方根是向下取整，例如 8 的平方跟是 2，而循环结束的条件又是 l &gt; r，因此最后返回右边界 r</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int left = 0;</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = x;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// int tmp = mid * mid;</span></span><br><span class="line">            <span class="comment">// if (mid == x / mid) &#123;</span></span><br><span class="line">            <span class="comment">//     return mid;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">if</span> (mid &lt; x / mid) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; x / mid)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return -1;</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、双指针法"><a href="#2、双指针法" class="headerlink" title="2、双指针法"></a>2、双指针法</h2><p>双指针法：通过一个快指针和一个慢指针在一个for循环下完成两个for循环的工作</p>
<ol>
<li><p><strong>快慢指针</strong>：<strong>快慢指针通常都从下标为0的地方开始走</strong>，当快指针达到末尾时，慢指针通常还在中间位置。</p>
</li>
<li><p><strong>左右指针</strong>：<strong>左右指针分别从数组的两端出发</strong>，根据问题的要求移动指针，并通过调整指针位置来实现问题的解决。</p>
</li>
<li><p><strong>滑动窗口</strong>：常用于解决数组或字符串中的子数组或子串问题，如最小覆盖子串、最长无重复字符的子串等。滑动窗口由左右指针定义，<strong>左指针指向窗口的起始位置，右指针指向窗口的结束位置，通过移动两个指针来扩大或缩小窗口</strong>，从而找到满足特定条件的子数组或子串。</p>
<p>在采用滑动窗口解决问题时，主要确定以下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
</li>
</ol>
<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></p>
<ul>
<li><p>解题思路</p>
<p>本题要求：<em>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组</em>，看到这样的要求时，就要很快地联想到<strong>双指针法（快慢指针法）</strong>。</p>
<ol>
<li><code>fast</code>和<code>slow</code>同时指向数组开始；</li>
<li>判断是否<code>nums[fast]==val</code>，若相等，<code>fast</code>前移一位，继续判断，直到<code>nums[fast]!=val</code>；</li>
<li>此时，将<code>nums[fast]</code>赋值给<code>nums[slow]</code>，<code>slow</code>前移一位；</li>
<li>循环执行步骤<strong>2&amp;3</strong>，直到<code>fast</code>遍历到数组末尾。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[fast] == val) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">                <span class="keyword">if</span> (fast == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> slow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></p>
<ul>
<li><p>解题思路</p>
<p>由于题目中已经说了“整数数组<code>nums</code>是非递减的”，那么在包含负数的情况下，平方后最大值就只能位于数组的两端。因此可以采用<strong>双指针法</strong>，用两个指针分别指向最左边和最右边，依次向中间移动。</p>
<ol>
<li>用两个指针<code>l</code>和<code>r</code>分别指向最左边和最右边，同时定义一个新的数组作为结果数组返回；</li>
<li>判断左右两边谁平方后的值更大，将大的那个放入结果数组的最右边；</li>
<li>更新指针；</li>
<li>重复步骤2&amp;3，直到原数组遍历完毕。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> index = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> tmpl = nums[l] * nums[l];</span><br><span class="line">            <span class="type">int</span> tmpr = nums[r] * nums[r];</span><br><span class="line">            <span class="keyword">if</span> (tmpl &lt; tmpr) &#123;</span><br><span class="line">                res[index] = tmpr;</span><br><span class="line">                index--;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[index] = tmpl;</span><br><span class="line">                index--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></p>
<ul>
<li><p>解题思路</p>
<p><strong>当看到题目中出现“子数组”、“子序列”等时，一般就要想到采用滑动窗口来解决。</strong>但这里我最开始想的是下面这种解法，这样实际上就是一种暴力的思想，而非双指针的思想。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样写会超时</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="type">int</span> sum = nums[i];</span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        sum += nums[j];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = j-i+<span class="number">1</span>;</span><br><span class="line">            len = tmp &lt; len ? tmp : len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，在本题中窗口就是满足其<code>和&gt;=target</code>的长度最小的连续子数组。移动窗口的起始位置是为了在满足条件的情况下缩小窗口，移动窗口的结束位置是为了遍历数组的所有元素。</p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                <span class="type">int</span> sublen = j-i+<span class="number">1</span>;</span><br><span class="line">                len = sublen &lt; len ? sublen : len;</span><br><span class="line">                sum -= nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == INT32_MAX) len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、循环不变原则"><a href="#3、循环不变原则" class="headerlink" title="3、循环不变原则"></a>3、循环不变原则</h2><h3 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59. 螺旋矩阵II"></a>59. 螺旋矩阵II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵II</a></p>
<ul>
<li><p>解题思路</p>
<p>本题实际上就是考察了<strong>循环不变量原则</strong>，要注意选择好了遍历<strong>区间的开闭</strong>后就一定要贯彻其开闭原则。</p>
<p>将整个过程分为从外到内“画”每一圈的过程。在此基础上，每一圈又包含4步：</p>
<ol>
<li>从左至右</li>
<li>从上至下</li>
<li>从右至左</li>
<li>从下至上</li>
</ol>
<p>这样经过一圈之后，就会回到这一圈的起点，接下来遍历下一圈，直到结束为止。</p>
<p>要注意几个地方：</p>
<ol>
<li><p>每一圈的起始坐标依次为<code>(1, 1)</code>，<code>(2, 2)</code>，….，因此每一圈结束后，<code>x</code>和<code>y</code>的起始位置都要分别加1才能进入下一圈；</p>
</li>
<li><p>循环的结束条件就是遍历到了最后一圈，其中要循环的圈数是<code>n/2</code>，这个可以举几个例子推导；另外一个要注意的就是当<code>n</code>为奇数时，最内圈是一个单独的值<code>n^2</code>，需要单独填充；</p>
</li>
<li><p>在遍历每一圈的4条边时，坚持左闭右开的原则：也就是说，每一条边的最后<code>n</code>个值属于下一条边。如下图所示，这是第一圈的情况。一定要记得设置一个<code>offset</code>，<strong>因为每遍历一圈，每条边的右边界就要收缩一位。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404102110076.png" alt="image-20240410211008731" style="zoom:33%;" /></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>;     <span class="comment">// 定义每一圈的起始坐标位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>;               <span class="comment">// 定义循环几圈</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>;                 <span class="comment">// 定义每一条边遍历的长度 </span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;                  <span class="comment">// 用来给矩阵赋值</span></span><br><span class="line">        <span class="keyword">while</span> (loop--) &#123;</span><br><span class="line">            <span class="type">int</span> i = startx;</span><br><span class="line">            <span class="type">int</span> j = starty;</span><br><span class="line">            <span class="comment">// 从左至右</span></span><br><span class="line">            <span class="keyword">for</span> (j; j&lt;n-offset; ++j) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="comment">// 从上至下</span></span><br><span class="line">            <span class="keyword">for</span> (i; i&lt;n-offset; ++i) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从右至左</span></span><br><span class="line">            <span class="keyword">for</span> (j; j&gt;starty; --j) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从下至上</span></span><br><span class="line">            <span class="keyword">for</span> (i; i&gt;startx; --i) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset++;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            res[n/<span class="number">2</span>][n/<span class="number">2</span>] = n*n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h1><p>实际上感觉链表的题都可以用快慢指针来解决。</p>
<h2 id="1、链表的定义"><a href="#1、链表的定义" class="headerlink" title="1、链表的定义"></a>1、链表的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	ListNode *next;</span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、删除链表元素"><a href="#2、删除链表元素" class="headerlink" title="2、删除链表元素"></a>2、删除链表元素</h2><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><p>举例来说，从<code>2-&gt;6-&gt;3</code>中删除节点6，需要完成以下几步：</p>
<p>（1）保存节点6，便于后续释放；</p>
<p>（2）将2的next改完3；</p>
<p>（3）释放原节点6。</p>
</li>
<li><p>注意要引入一个虚拟头结点，这样就可以避免在操作时还要区分头节点和非头节点两种情况。并且注意在最后返回真正的头节点时，返回的是<code>dummyhead-&gt;next</code>。</p>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *dummynode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummynode-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode *cur = dummynode;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode *tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummynode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummynode;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a>707. 设计链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></p>
<ul>
<li><p>解题思路</p>
<p>这里有一个要注意的点，那就是对于这个<code>index</code>，在访问操作和增删操作时，遍历停止的位置是不同的：</p>
<ol>
<li>对于访问操作，需要<code>cur</code>正好停在<strong>下标为<code>index</code>的节点</strong>上，这样才能正确取到值；</li>
<li>对于增删操作，需要<code>cur</code>停在<strong>下标为<code>index</code>的前一个节点</strong>上，这样才方便进行增删操作。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (index-- &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        tmp-&gt;next = _dummyhead-&gt;next;</span><br><span class="line">        _dummyhead-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListNode *_dummyhead;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="19-删除链表的倒数第N个结点"><a href="#19-删除链表的倒数第N个结点" class="headerlink" title="19. 删除链表的倒数第N个结点"></a>19. 删除链表的倒数第N个结点</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第N个结点</a></p>
<ul>
<li><p>解题思路</p>
<p>本题我采用了两趟扫描的方式进行解答。第一趟扫描确定了链表的长度，第二趟扫描则定位到了<strong>要删除结点的前一个结点</strong>。</p>
<ol>
<li><p>由于涉及到对头节点<code>head</code>的操作，因此定义一个<code>dummyhead</code>，避免需要对头结点单独操作；</p>
</li>
<li><p>如何定位到要删除结点的前一个结点，实际上需要分析<code>n</code>和<code>sz</code>之间的关系，如下图所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404120946983.png" alt="image-20240412094658218" style="zoom: 33%;" /></li>
</ol>
<blockquote>
<p>然而这道题我看了代码随想录提供的题解，实际上也是快慢指针法的一种变体，并且使用快慢指针法就可以无需先遍历一遍链表来求出链表的总长度。</p>
<p>只需要定义<code>fast</code>和<code>slow</code>两个指针</p>
<ul>
<li><code>fast</code>先走<code>n+1</code>步。之后<code>fast</code>和<code>slow</code>同时向前走；</li>
<li>当<code>fast</code>指向<code>nullptr</code>时，<code>slow</code>就正好指向要删除结点的前一个结点。</li>
</ul>
</blockquote>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *cur1 = head;</span><br><span class="line">        <span class="type">int</span> sz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            sz++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line">        ListNode *cur = dummyhead;</span><br><span class="line">        <span class="type">int</span> m = sz-n;</span><br><span class="line">        <span class="keyword">while</span> (m &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        head = dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyhead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、反转链表"><a href="#3、反转链表" class="headerlink" title="3、反转链表"></a>3、反转链表</h2><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><p>这道题实际上也相当于是双指针法中的快慢指针，通过定义两个指针<code>pre</code>和<code>cur</code>来依次遍历链表中的所有元素，并在遍历的过程中修改指针的指向。</p>
</li>
<li><p>有一个要注意的点在于：<code>while</code>循环的终止条件是<code>cur != nullptr</code>，若采用<code>cur-&gt;next != nullptr</code>，则最后一个节点不会被遍历到。</p>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p>
<ul>
<li><p>解题思路</p>
<p>实际上这道题只要能够画图模拟出交换的过程，就没有问题了。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404111457295.png" alt="image-20240411145728810"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode *cur = dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode *tmp1 = cur-&gt;next;</span><br><span class="line">            ListNode *tmp2 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next = tmp1;</span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = tmp2;</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next;  <span class="comment">// cur要往后跳两步</span></span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyhead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、链表相交"><a href="#4、链表相交" class="headerlink" title="4、链表相交"></a>4、链表相交</h2><h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></p>
<ul>
<li><p>解题思路</p>
<p>主要有以下几个点要注意：</p>
<ol>
<li><p>最开始我额外定义了<code>a</code>和<code>b</code>用于去遍历两个链表来长度，实际上可以直接定义<code>curA</code>和<code>curB</code>，在遍历结束上让其重新指向头结点即可；</p>
</li>
<li><p>该题交点不是数值相等，而是指针相等！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curA-&gt;val == curB-&gt;val)  <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">if</span> (curA == curB)			 <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size_a = <span class="number">0</span>, size_b = <span class="number">0</span>;</span><br><span class="line">        ListNode *curA = headA;</span><br><span class="line">        ListNode *curB = headB;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            size_a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">            size_b++;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">abs</span>(size_a - size_b);</span><br><span class="line">        <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// if (curA-&gt;val == curB-&gt;val) &#123;</span></span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></p>
<ul>
<li><p>解题思路</p>
<p>定义快慢指针<code>fast</code>和<code>slow</code>，其中<code>fast</code>每次走两个结点，<code>slow</code>每次走一个结点。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121316807.png" alt="image-20240412131623148"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *index1 = fast;</span><br><span class="line">                ListNode *index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三、哈希表"><a href="#三、哈希表" class="headerlink" title="三、哈希表"></a>三、哈希表</h1><h2 id="1、理论基础"><a href="#1、理论基础" class="headerlink" title="1、理论基础"></a>1、理论基础</h2><p>哈希表即为散列表，一般用于判断一个元素是否出现在集合里。</p>
<p>（1）常见的三种哈希函数：</p>
<ul>
<li><p>数组</p>
</li>
<li><p>集合（<code>set</code>）</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<ul>
<li><code>std::unordered_set</code>底层实现为哈希表；</li>
<li><code>std::set</code>和<code>std::multiset</code>的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以<code>key</code>值是有序的，但<code>key</code>不可以修改，改动<code>key</code>值会导致整棵树的错乱，所以只能删除和增加。</li>
</ul>
</li>
<li><p>映射（<code>map</code>）</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<ul>
<li><code>std::unordered_map</code>底层实现为哈希表；</li>
<li><code>std::map</code>和<code>std::multimap</code>的底层实现是红黑树。同理，<code>std::map</code>和<code>std::multimap</code>的<code>key</code>也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</li>
</ul>
</li>
</ul>
<p>（2）<code>std::unordered_set</code>提供了一系列方法来管理集合中的元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">插入元素：</span><br><span class="line">    <span class="built_in">insert</span>(): 向集合中插入元素。</span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">    <span class="built_in">erase</span>(): 删除集合中的元素。</span><br><span class="line">    <span class="built_in">clear</span>(): 清空集合中的所有元素。</span><br><span class="line"></span><br><span class="line">查找元素：</span><br><span class="line">    <span class="built_in">find</span>(): 查找集合中是否存在指定元素。</span><br><span class="line">    <span class="built_in">count</span>(): 统计集合中指定元素的个数。</span><br><span class="line"></span><br><span class="line">迭代器：</span><br><span class="line">    <span class="built_in">begin</span>(): 返回指向集合起始元素的迭代器。</span><br><span class="line">    <span class="built_in">end</span>(): 返回指向集合末尾元素的迭代器。</span><br><span class="line"></span><br><span class="line">大小和容量：</span><br><span class="line">    <span class="built_in">size</span>(): 返回集合中元素的个数。</span><br><span class="line">    <span class="built_in">empty</span>(): 检查集合是否为空。</span><br><span class="line"></span><br><span class="line">其他操作：</span><br><span class="line">    <span class="built_in">bucket_count</span>(): 返回集合中桶的数量。</span><br><span class="line">    <span class="built_in">load_factor</span>(): 返回集合的负载因子。</span><br><span class="line">    <span class="built_in">max_load_factor</span>(): 设置或返回集合的最大负载因子。</span><br></pre></td></tr></table></figure>

<p>（3）<code>std::set</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">插入元素：</span><br><span class="line">    <span class="built_in">insert</span>(): 向集合中插入元素。</span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">    <span class="built_in">erase</span>(): 删除集合中的元素。</span><br><span class="line">    <span class="built_in">clear</span>(): 清空集合中的所有元素。</span><br><span class="line"></span><br><span class="line">查找元素：</span><br><span class="line">    <span class="built_in">find</span>(): 查找集合中是否存在指定元素。</span><br><span class="line">    <span class="built_in">count</span>(): 统计集合中指定元素的个数。</span><br><span class="line"></span><br><span class="line">迭代器：</span><br><span class="line">    <span class="built_in">begin</span>(): 返回指向集合起始元素的迭代器。</span><br><span class="line">    <span class="built_in">end</span>(): 返回指向集合末尾元素的迭代器。</span><br><span class="line"></span><br><span class="line">大小和容量：</span><br><span class="line">    <span class="built_in">size</span>(): 返回集合中元素的个数。</span><br><span class="line">    <span class="built_in">empty</span>(): 检查集合是否为空。</span><br><span class="line"></span><br><span class="line">其他操作：</span><br><span class="line">    <span class="built_in">lower_bound</span>(): 返回指向大于或等于给定值的第一个元素的迭代器。</span><br><span class="line">    <span class="built_in">upper_bound</span>(): 返回指向大于给定值的第一个元素的迭代器。</span><br><span class="line">    <span class="built_in">equal_range</span>(): 返回集合中与给定值相等的元素范围。</span><br></pre></td></tr></table></figure>

<p>（3）<code>std::map</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">相关操作：</span><br><span class="line">    <span class="built_in">insert</span>()：用于将元素插入到map中。</span><br><span class="line">    <span class="built_in">erase</span>()：用于从map中删除指定的元素。</span><br><span class="line">    <span class="built_in">find</span>()：用于查找指定键对应的元素。</span><br><span class="line">    <span class="built_in">size</span>()：返回map中元素的数量。</span><br><span class="line">    <span class="built_in">clear</span>()：清空map中的所有元素。</span><br><span class="line">    <span class="built_in">begin</span>()：返回指向map起始元素的迭代器。</span><br><span class="line">    <span class="built_in">end</span>()：返回指向map末尾元素的迭代器。</span><br><span class="line">    <span class="built_in">count</span>()：返回指定键在map中出现的次数。</span><br></pre></td></tr></table></figure>

<h2 id="2、数组、set和map该如何选择？"><a href="#2、数组、set和map该如何选择？" class="headerlink" title="2、数组、set和map该如何选择？"></a>2、数组、set和map该如何选择？</h2><h3 id="什么时候选择用哈希表？"><a href="#什么时候选择用哈希表？" class="headerlink" title="什么时候选择用哈希表？"></a>什么时候选择用哈希表？</h3><p>当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候。</p>
<h3 id="什么时候选择用数组？"><a href="#什么时候选择用数组？" class="headerlink" title="什么时候选择用数组？"></a>什么时候选择用数组？</h3><p>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</p>
<p>如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费，此时不应使用数组。</p>
<h3 id="什么时候选择用set？"><a href="#什么时候选择用set？" class="headerlink" title="什么时候选择用set？"></a>什么时候选择用set？</h3><h3 id="什么时候选择用map？"><a href="#什么时候选择用map？" class="headerlink" title="什么时候选择用map？"></a>什么时候选择用map？</h3><h2 id="3、采用数组作为哈希函数"><a href="#3、采用数组作为哈希函数" class="headerlink" title="3、采用数组作为哈希函数"></a>3、采用数组作为哈希函数</h2><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></p>
<ul>
<li><p>解题思路</p>
<p>由于“字母异位词”的定义是：两个词中每个字符出现的数组相同，而本题假设词中仅包含小写字母。因此直观的想法就是定义一个数组，先遍历<code>s</code>，将每个字符在数组中对应的位置加1，再遍历<code>t</code>，将每个字符在数组中对应的位置减1，这样若最终数组为全0，则这两个词是字母异位词。</p>
<p>但我陷入的思维瓶颈在于，我想的是按照<code>s</code>中每个字符出现的顺序定义数组<code>a</code>，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s = &quot;anagram&quot;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">// 其中下标1代表字符a</span></span><br></pre></td></tr></table></figure>

<p>但这样实际上就相当于是一个<code>map</code>了，操作变得格外复杂。</p>
<p>实际上，由于小写字母是有顺序的26个，因此只需要定义一个<code>int a[26]</code>，对于<code>s</code>中遍历到的每个字符，通过<code>s[i] - &#39;a&#39;</code>就可以定位到对应的下标。</p>
</li>
<li><p>易混知识点：</p>
<ol>
<li><p><code>a - &#39;a&#39;</code>:</p>
<ul>
<li><strong>用于将字母字符转换成一个从0开始的索引</strong>（例如，’a’变成0, ‘b’变成1, 等等）。</li>
</ul>
<ul>
<li>这里 <code>&#39;a&#39;</code> 是一个字符，其ASCII值是 97。</li>
<li>所以 <code>a - &#39;a&#39;</code> 实际上是计算 <code>97 - 97</code>，结果是 0。</li>
</ul>
</li>
<li><p><code>&#39;1&#39; - &#39;0&#39;</code> </p>
<ul>
<li><strong>计算两个字符的ASCII值之差，用于将字符表示的数字转换成其对应的整数值。</strong></li>
</ul>
<ul>
<li><code>&#39;1&#39;</code> 的 ASCII 值是 49，<code>&#39;0&#39;</code>是 48。所以，<code>&#39;1&#39;-&#39;0&#39;</code> 的计算过程是 <code>49-48</code>，结果是 1。</li>
</ul>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;t.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            record[t[j] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m=<span class="number">0</span>; m&lt;<span class="number">26</span>; ++m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[m] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></p>
<ul>
<li><p>解题思路</p>
<p>和242完全一致。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131611.png" alt="image-20240420113156470"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;magazine.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            record[magazine[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ransomNote.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            record[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m=<span class="number">0</span>; m&lt;<span class="number">26</span>; ++m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[m] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、采用set解题"><a href="#4、采用set解题" class="headerlink" title="4、采用set解题"></a>4、采用set解题</h2><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></p>
<ul>
<li><p>解题思路</p>
<p>由于本题的哈希值较少、较分散且跨度非常大，因此不能采用数组来实现。由于最终的结果无需排序，无重复，且只需要返回元素本身，不需要返回对应的下标，因此采用set即可。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131372.png" alt="image-20240420113120142"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; nums_set;</span><br><span class="line">        nums_set.<span class="built_in">insert</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> nums : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums_set.<span class="built_in">find</span>(nums) != nums_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></p>
<ul>
<li><p>解题思路</p>
<p>可以发现</p>
<ul>
<li>1）哈希值较分散，且跨度较大（不采用数组，应采用set或map）；</li>
<li>2）不需要同时保存元素和下标等成对出现，有对应关系的元素（不采用map）；</li>
<li>3）就是要找是否有重复的元素出现，因此采用set实现。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131501.png" alt="image-20240420113130345"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            sum += (n%<span class="number">10</span>) * (n%<span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; compare_set = &#123;n&#125;;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">        <span class="keyword">while</span> (sum != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compare_set.<span class="built_in">find</span>(sum) != compare_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// sum = getSum(sum);</span></span><br><span class="line">                compare_set.<span class="built_in">insert</span>(sum);</span><br><span class="line">                sum = <span class="built_in">getSum</span>(sum);  <span class="comment">// 这里一定要先把上一步计算得到的sum加入compare_set后，再计算新的sum</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、采用map解题"><a href="#5、采用map解题" class="headerlink" title="5、采用map解题"></a>5、采用map解题</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p>
<ul>
<li><p>解题思路</p>
<p>本题不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，<strong>需要使用key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p>
<p><strong>这道题目中并不需要key有序，选择std::unordered_map 效率更高</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131120.png" alt="image-20240420113138973"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; compare_map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = compare_map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (iter != compare_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second, i&#125;;           </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// compare_map.insert(nums[i], i);</span></span><br><span class="line">                compare_map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(nums[i], i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454. 四数相加II"></a>454. 四数相加II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加II</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131021.png" alt="image-20240420113148798"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; res1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num1 : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num2 : nums2) &#123;</span><br><span class="line">                <span class="type">int</span> sum = num1 + num2;</span><br><span class="line">                res1[sum]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num3 : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num4 : nums4) &#123;</span><br><span class="line">                <span class="type">int</span> sum = num3 + num4;</span><br><span class="line">                cnt += res1[-sum];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h1><h2 id="1、反转字符串"><a href="#1、反转字符串" class="headerlink" title="1、反转字符串"></a>1、反转字符串</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h3><ul>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> il = s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">auto</span> ir = s.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (il &lt;= ir) &#123;</span><br><span class="line">            <span class="comment">// char tmp;</span></span><br><span class="line">            <span class="comment">// tmp = *il;</span></span><br><span class="line">            <span class="comment">// *il = *ir;</span></span><br><span class="line">            <span class="comment">// *ir = tmp;</span></span><br><span class="line">            <span class="built_in">swap</span>(*il, *ir)</span><br><span class="line">            il++;</span><br><span class="line">            ir--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404222114861.png" alt="image-20240422211359195"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i+=<span class="number">2</span>*k) &#123;</span><br><span class="line">            <span class="type">int</span> start = i;</span><br><span class="line">            <span class="type">int</span> end = std::<span class="built_in">min</span>(start+k, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>()));</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+start, s.<span class="built_in">begin</span>()+end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a>151. 反转字符串中的单词</h3><ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404222114609.png" alt="image-20240422211419481"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string &amp;s, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=begin, j=end; i&lt;=j; ++i, --j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeSpace</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slow) &#123;</span><br><span class="line">                    s[slow++] = <span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">                    <span class="comment">// 当slow不在开头时，如果此时遇到了s[i]不为空格，则说明接下来需要从slow开始写新的单词了</span></span><br><span class="line">                    <span class="comment">// 因此手动控制添加一个空格</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow);  <span class="comment">// important</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeSpace</span>(s);</span><br><span class="line">        <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// for (int i=0; i&lt;s.size(); ++i) &#123;</span></span><br><span class="line">            <span class="comment">// if (s[i] == &#x27; &#x27;) &#123;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() || s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s, start, i<span class="number">-1</span>);  <span class="comment">// 翻转当前单词</span></span><br><span class="line">                <span class="comment">// start = i;</span></span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2、KMP算法"><a href="#2、KMP算法" class="headerlink" title="2、KMP算法"></a>2、KMP算法</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242023050.png" alt="image-20240424202306816"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> *next, <span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// i -&gt; 待匹配的后缀的末尾</span></span><br><span class="line">   <span class="comment">// j -&gt; 待匹配的前缀的末尾</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1. 初始化</span></span><br><span class="line">   <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">   next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">       <span class="comment">// 2. 处理前后缀不相同的情况</span></span><br><span class="line">       <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">           j = next[j<span class="number">-1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 3. 处理前后缀不相同的情况</span></span><br><span class="line">       <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">           j++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4. 更新next数组</span></span><br><span class="line">       next[i] = j;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 实现 strStr()</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li>求解字符串<code>s</code>的<code>next</code>数组；</li>
<li>定义<code>i</code>和<code>j</code>分别用来遍历<code>haystack</code>和<code>needle</code>，根据<code>next</code>数组调整对比的位置；</li>
<li>当<code>j</code>等于<code>needle</code>字符串的长度时，说明此时在<code>haystack</code>中找到了对应的匹配子串，因此返回该子串的开始下标。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line">        <span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;haystack.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> (i-needle.<span class="built_in">size</span>()+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a>459. 重复的子字符串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242023207.png" alt="image-20240424202348060"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> *next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; s[i]!=s[j]) &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(s.size())</span></span>;</span><br><span class="line">        <span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], s);</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(next[len<span class="number">-1</span>]!=<span class="number">0</span> &amp;&amp; (len%(len-next[len<span class="number">-1</span>])==<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="五、栈和队列"><a href="#五、栈和队列" class="headerlink" title="五、栈和队列"></a>五、栈和队列</h1><h2 id="1、栈和队列的理论基础"><a href="#1、栈和队列的理论基础" class="headerlink" title="1、栈和队列的理论基础"></a>1、栈和队列的理论基础</h2><ol>
<li><p>C++中stack 是容器么？</p>
<p>STL中stack往往不被归类为容器，而被归类为容器适配器（container adapter）。因为<strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p>
</li>
<li><p>我们使用的stack是属于哪个版本的STL？</p>
<p>SGI STL。</p>
</li>
<li><p>我们使用的STL中stack是如何实现的？</p>
<p>栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。<strong>常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。</strong></p>
<p>此外，<strong>SGI STL中队列一样是以deque为缺省情况下的底部结构。</strong></p>
<p>可以指定vector为栈的底层实现，初始化语句如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br></pre></td></tr></table></figure>

<p>也可以指定list 为起底层实现，初始化queue的语句如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242029774.png" alt="栈与队列理论3" style="zoom:50%;" />
</li>
<li><p>stack 提供迭代器来遍历stack空间么？</p>
<p>不提供。</p>
</li>
</ol>
<blockquote>
<p>三个最为普遍的STL版本：</p>
<ol>
<li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li>
<li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li>
<li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li>
</ol>
</blockquote>
<h2 id="2、栈的基本操作"><a href="#2、栈的基本操作" class="headerlink" title="2、栈的基本操作"></a>2、栈的基本操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">empty</span>();		<span class="comment">// 栈为空时返回1，非空返回0</span></span><br><span class="line">st.<span class="built_in">size</span>();		<span class="comment">// 返回栈中元素数量，size_type size() const;</span></span><br><span class="line">st.<span class="built_in">top</span>();		<span class="comment">// 返回栈顶元素，value_type&amp; top();</span></span><br><span class="line">st.<span class="built_in">push</span>(value);	<span class="comment">// 在栈顶插入一个元素，void push( const value_tyoe&amp; val );</span></span><br><span class="line">st.<span class="built_in">emplace</span>(value);	<span class="comment">// 在栈顶增加一个元素，void emplace( args&amp;&amp; args );</span></span><br><span class="line">st.<span class="built_in">pop</span>();			<span class="comment">// 栈顶元素出栈，即删除栈顶元素，void pop(); </span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st2;</span><br><span class="line">st1.<span class="built_in">swap</span>( st2 );	<span class="comment">// 交换两个栈中的内容，void swap( stack&amp; x );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与vector一样，重载了运算符：== != &lt; &lt;= &gt; &gt;=</span></span><br></pre></td></tr></table></figure>

<h2 id="3、队列的基本操作"><a href="#3、队列的基本操作" class="headerlink" title="3、队列的基本操作"></a>3、队列的基本操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">queue&lt;<span class="type">double</span>&gt; d;</span><br><span class="line">queue&lt;node&gt; n;  <span class="comment">// node是一个结构体</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">size</span>();	<span class="comment">// 返回q里元素个数</span></span><br><span class="line">q.<span class="built_in">empty</span>();	<span class="comment">// 返回q是否为空，空则返回1，否则返回0</span></span><br><span class="line">q.<span class="built_in">push</span>(k);	<span class="comment">// 在q的末尾插入k</span></span><br><span class="line">q.<span class="built_in">pop</span>();	<span class="comment">// 删掉q的第一个元素</span></span><br><span class="line">q.<span class="built_in">front</span>();	<span class="comment">// 返回q的第一个元素</span></span><br><span class="line">q.<span class="built_in">back</span>();	<span class="comment">// 返回q的末尾元素</span></span><br></pre></td></tr></table></figure>

<h2 id="4、对称匹配问题"><a href="#4、对称匹配问题" class="headerlink" title="4、对称匹配问题"></a>4、对称匹配问题</h2><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404252121420.png" alt="image-20240425212136199"></p>
<p>这里有两个要注意的地方：</p>
<ol>
<li><p>在遍历到左括号时，可以直接向栈中放入对应的右括号，这样遍历到右括号时可以直接比较是否相等；</p>
</li>
<li><p>注意在遍历到右括号时需要先判断此时栈是否为空。</p>
<p>对于<code>s = &quot;)&#123;&quot;</code>的情况，由于遍历到左括号时才会入栈，遍历到右括号时只执行比较操作，因此此时<code>st</code>为空，若直接执行<code>st.top()</code>会造成错误！</p>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">&#x27;)&#x27;</span> || i == <span class="string">&#x27;]&#x27;</span> || i == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == i) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404252121802.png" alt="image-20240425212128346"></p>
<p>注意输出的时候要进行一个reverse操作，因为栈是先进先出，和需要的结果次序是相反的。</p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == i) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res += st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261554153.png" alt="image-20240426155453665"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isDigit</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> token : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isDigit</span>(token)) &#123;</span><br><span class="line">                    <span class="comment">// 操作符</span></span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> tmp1 = res.<span class="built_in">top</span>();</span><br><span class="line">                    res.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> tmp2 = res.<span class="built_in">top</span>();</span><br><span class="line">                    res.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 + tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 - tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 * tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 / tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res.<span class="built_in">push</span>(tmp);   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push</span>(<span class="built_in">stoi</span>(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、队列解决相关问题"><a href="#5、队列解决相关问题" class="headerlink" title="5、队列解决相关问题"></a>5、队列解决相关问题</h2><blockquote>
<p>可用于以下题目：</p>
<ol>
<li>单调队列解决“<strong>区间内的最大值</strong>”问题；</li>
<li>优先级队列解决“<strong>统计元素出现频率</strong>”问题</li>
</ol>
</blockquote>
<h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261557720.png" alt="image-20240426155748508"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            <span class="comment">// 如果val == que.front()</span></span><br><span class="line">            <span class="comment">// 说明队列要pop()的元素为此时滑动窗口的最大值，需要执行实际的pop()操作</span></span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          que.<span class="built_in">push_back</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getMaxValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">      MyQueue que;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">      <span class="comment">// 先将前k个元素放进单调队列</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; ++i) &#123;</span><br><span class="line">        que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// res先记录这前k个元素的最大值</span></span><br><span class="line">      res.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=k; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        que.<span class="built_in">pop</span>(nums[i-k]);</span><br><span class="line">        que.<span class="built_in">push</span>((nums[i]));</span><br><span class="line">        res.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">347.前 K 个高频元素</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261557691.png" alt="image-20240426155759481"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// step1</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            map[num]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step2</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pri_que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it=map.<span class="built_in">begin</span>(); it!=map.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            pri_que.<span class="built_in">push</span>(*it);</span><br><span class="line">            <span class="comment">// step3</span></span><br><span class="line">            <span class="keyword">if</span> (pri_que.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                pri_que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step4</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=k<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">            res[i] = pri_que.<span class="built_in">top</span>().first;</span><br><span class="line">            pri_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="六、二叉树"><a href="#六、二叉树" class="headerlink" title="六、二叉树"></a>六、二叉树</h1><h2 id="1、理论基础-1"><a href="#1、理论基础-1" class="headerlink" title="1、理论基础"></a>1、理论基础</h2><h3 id="（1）分类"><a href="#（1）分类" class="headerlink" title="（1）分类"></a>（1）分类</h3><blockquote>
<p>度：二叉树中某个结点的子结点或直接后继结点的个数。叶子节点的度为0。</p>
</blockquote>
<ul>
<li><p>满二叉树：一课二叉树上只有度为0的结点和度为2的结点，且度为0的结点在同一层上，则为满二叉树。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035207.png" alt="img"></p>
</li>
<li><p>完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035385.png" alt="img"></p>
</li>
<li><p>二叉搜索树：有序树。1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；3）左、右子树也分别为二叉排序树。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035643.png" alt="img"></p>
</li>
<li><p>平衡二叉搜索树：又称AVL（Adelson-Velsky and Landis）树。它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271035200.png" alt="img"></p>
</li>
</ul>
<h3 id="（2）存储方式"><a href="#（2）存储方式" class="headerlink" title="（2）存储方式"></a>（2）存储方式</h3><ul>
<li><p>链式存储：指针。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271036601.png" alt="img"></p>
</li>
<li><p>顺序存储：数组。此时若父结点下标为<code>i</code>，则左孩子下标为<code>i*2+1</code>，右孩子下标为<code>i*2+2</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271036512.png" alt="img"></p>
</li>
</ul>
<h3 id="（3）遍历方式"><a href="#（3）遍历方式" class="headerlink" title="（3）遍历方式"></a>（3）遍历方式</h3><ul>
<li><p>深度优先遍历</p>
<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404271039957.png" alt="img"></p>
</li>
<li><p>广度优先遍历</p>
<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ul>
<p>栈其实就是递归的一种实现结构，<strong>深度优先遍历可以借助栈来使用递归的方式实现。而广度优先遍历一般使用队列来实现</strong>。</p>
<h3 id="（4）定义方式"><a href="#（4）定义方式" class="headerlink" title="（4）定义方式"></a>（4）定义方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	TreeNode *left;</span><br><span class="line">	TreeNode *right;</span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、深度优先遍历"><a href="#2、深度优先遍历" class="headerlink" title="2、深度优先遍历"></a>2、深度优先遍历</h2><p>递归三要素：</p>
<ul>
<li>确定递归函数的参数和返回值：如果在递归过程中需要处理某些参数，就在递归函数中加上这个参数；</li>
<li>确定终止条件</li>
<li>确定单层递归的逻辑</li>
</ul>
<h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h3><ul>
<li><p>AC代码（递归遍历）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, v);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">traversal</span>(root, v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代遍历的思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292106760.png" alt="image-20240429210650617"></p>
</li>
<li><p>AC代码（迭代遍历）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> v; &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *node = st.<span class="built_in">top</span>();                  <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            v.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) &#123; st.<span class="built_in">push</span>(node-&gt;right); &#125;  <span class="comment">// 右（入栈时先入右，出栈时才能先出左）</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) &#123; st.<span class="built_in">push</span>(node-&gt;left); &#125;    <span class="comment">// 左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h3><ul>
<li><p>AC代码（递归遍历）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, v);</span><br><span class="line">        v.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">traversal</span>(root, v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AC代码（迭代遍历）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历到最左侧的左孩子</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;        <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将左孩子加入完毕，开始从栈中弹出元素</span></span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                v.<span class="built_in">push_back</span>(cur-&gt;val);  <span class="comment">// 中</span></span><br><span class="line">                cur = cur-&gt;right;       <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h3><ul>
<li><p>AC代码（递归遍历）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;int&gt; v;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        while (cur != nullptr || !st.empty()) &#123;</span><br><span class="line">            if (cur != nullptr) &#123;</span><br><span class="line">                // 遍历到最左侧的左孩子</span><br><span class="line">                st.push(cur);</span><br><span class="line">                cur = cur-&gt;left;        // 左</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 将左孩子加入完毕，开始从栈中弹出元素</span><br><span class="line">                cur = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                v.push_back(cur-&gt;val);  // 中</span><br><span class="line">                cur = cur-&gt;right;       // 右</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AC代码（迭代遍历）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> v; &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            v.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123; st.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123; st.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、广度优先遍历"><a href="#3、广度优先遍历" class="headerlink" title="3、广度优先遍历"></a>3、广度优先遍历</h2><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292104737.png" alt="image-20240429210415502"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                v.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292105474.png" alt="image-20240429210504161"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                v.<span class="built_in">push_back</span>(node-&gt;val);  <span class="comment">// 方法1</span></span><br><span class="line">                <span class="comment">// if (i == (size - 1)) result.push_back(node-&gt;val);  // 方法2</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(*(v.<span class="built_in">end</span>()<span class="number">-1</span>));  <span class="comment">// 方法1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429. N叉树的层序遍历"></a>429. N叉树的层序遍历</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N叉树的层序遍历</a></p>
<ul>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Node* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;children.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 将节点孩子加入队列</span></span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;children[i]) que.<span class="built_in">push</span>(node-&gt;children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404292105156.png" alt="image-20240429210553988"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node *node;</span><br><span class="line">            Node *nodePre;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    nodePre = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    node = nodePre;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    nodePre-&gt;next = node;  <span class="comment">// 本层前一个节点(nodePre)的next指向本节点(node)</span></span><br><span class="line">                    nodePre = nodePre-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nodePre-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 本层最后一个节点指向NULL</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、二叉树的属性"><a href="#4、二叉树的属性" class="headerlink" title="4、二叉树的属性"></a>4、二叉树的属性</h2><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404301959840.png" alt="image-20240430195926626"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode *left, TreeNode *right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);</span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> outside &amp;&amp; inside;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p>
<ul>
<li><p>解题思路</p>
<blockquote>
<ul>
<li>二叉树节点的<strong>深度</strong>：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）</li>
<li>二叉树节点的<strong>高度</strong>：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）</li>
</ul>
</blockquote>
<p>本题牢记一点，<strong>根节点的高度就是二叉树的最大深度</strong>。</p>
</li>
<li><p>AC代码（解法1：层序遍历）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123; que.<span class="built_in">push</span>(root); &#125;</span><br><span class="line">        <span class="type">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; que.<span class="built_in">push</span>(node-&gt;left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; que.<span class="built_in">push</span>(node-&gt;right); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
<li><p>AC代码（解法2：递归法）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getdepth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftdepth = <span class="built_in">getdepth</span>(node-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightdepth = <span class="built_in">getdepth</span>(node-&gt;right);     <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth); <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getdepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="111"><a href="#111" class="headerlink" title="111."></a>111.</h3><h2 id="5、二叉树的修改与构造"><a href="#5、二叉树的修改与构造" class="headerlink" title="5、二叉树的修改与构造"></a>5、二叉树的修改与构造</h2><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></p>
<ul>
<li><p>解题思路</p>
<p>这道题只需要在遍历的过程中将每个节点的左右孩子翻转一遍，最终就可以达到整体翻转的效果。<strong>注意本题不能使用中序遍历，因为会把某些节点的左右孩子翻转两次。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404302000083.png" alt="image-20240430200020967"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversel</span><span class="params">(TreeNode *cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left || cur-&gt;right) &#123;</span><br><span class="line">            TreeNode *tmp;</span><br><span class="line">            tmp = cur-&gt;left;</span><br><span class="line">            cur-&gt;left = cur-&gt;right;</span><br><span class="line">            cur-&gt;right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traversel</span>(cur-&gt;left);</span><br><span class="line">        <span class="built_in">traversel</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversel</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6、求二叉搜索树的属性"><a href="#6、求二叉搜索树的属性" class="headerlink" title="6、求二叉搜索树的属性"></a>6、求二叉搜索树的属性</h2><h2 id="7、二叉树公共祖先问题"><a href="#7、二叉树公共祖先问题" class="headerlink" title="7、二叉树公共祖先问题"></a>7、二叉树公共祖先问题</h2><h2 id="8、二叉搜索数的修改与构造"><a href="#8、二叉搜索数的修改与构造" class="headerlink" title="8、二叉搜索数的修改与构造"></a>8、二叉搜索数的修改与构造</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/08/Computer/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/08/Computer/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-08 23:57:17" itemprop="dateCreated datePublished" datetime="2024-04-08T23:57:17+08:00">2024-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-17 10:36:11" itemprop="dateModified" datetime="2024-04-17T10:36:11+08:00">2024-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、因特网概述"><a href="#1、因特网概述" class="headerlink" title="1、因特网概述"></a>1、因特网概述</h2><p><strong>internet与Internet的区别</strong></p>
<ul>
<li><p><strong>internet(互联网或互连网)<strong>是一个通用名词，它泛指</strong>多个计算机网络互连而成的网络</strong>。在这些网络之间的通信协议可以是任意的。</p>
</li>
<li><p><strong>Internet（因特网）则是一个专用名词</strong>，它指<strong>当前全球最大的、开放的、由众多网络互连而成的特定计算机网络</strong>，它采用TCP&#x2F;IP协议族作为通信的规则，其前身是美国的ARPANET。</p>
</li>
</ul>
<p>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是互联网(Internet)。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121642022.webp" alt="img"></p>
<blockquote>
<p>普通用户是如何接入到因特网的呢？</p>
<p>答：<strong>通过ISP接入因特网</strong></p>
<p>ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从<strong>ISP的得到所需要的IP地址</strong>。</p>
<p><strong>因为因特网上的主机都必须有IP地址才能进行通信，这样就可以通过该ISP接入到因特网</strong></p>
</blockquote>
<h2 id="2、计算机网络体系结构"><a href="#2、计算机网络体系结构" class="headerlink" title="2、计算机网络体系结构"></a>2、计算机网络体系结构</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121644183.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121645050.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121645246.webp" alt="img"></p>
<h1 id="二、网络层"><a href="#二、网络层" class="headerlink" title="二、网络层"></a>二、网络层</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646323.png" alt="image-20240412164600035"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646120.png" alt="image-20240412164607943"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646736.png" alt="image-20240412164616479"></p>
<h1 id="三、运输层"><a href="#三、运输层" class="headerlink" title="三、运输层"></a>三、运输层</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-d9a70806edc95dc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的。</strong></p>
<h2 id="2、运输层端口号、复用与分用的概念"><a href="#2、运输层端口号、复用与分用的概念" class="headerlink" title="2、运输层端口号、复用与分用的概念"></a>2、运输层端口号、复用与分用的概念</h2><h3 id="（1）为什么用端口号"><a href="#（1）为什么用端口号" class="headerlink" title="（1）为什么用端口号"></a>（1）为什么用端口号</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-de597eda77aa6acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（2）发送方的复用和接收方的分用"><a href="#（2）发送方的复用和接收方的分用" class="headerlink" title="（2）发送方的复用和接收方的分用"></a>（2）发送方的复用和接收方的分用</h3><ul>
<li><p><strong>多个进程</strong>利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据——<strong>复用</strong></p>
</li>
<li><p><strong>多个进程</strong>利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>数据—— <strong>分用</strong></p>
</li>
<li><p>这里一个端口表示一个进程</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2a4ec3f5d5c11433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（3）常用端口号"><a href="#（3）常用端口号" class="headerlink" title="（3）常用端口号"></a>（3）常用端口号</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2117fa99a7f2a89c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="3、TCP和UDP的对比"><a href="#3、TCP和UDP的对比" class="headerlink" title="3、TCP和UDP的对比"></a>3、TCP和UDP的对比</h2><h3 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h3><ul>
<li><p>TCP</p>
<ol>
<li>面向连接，需要在两个套接字之间建立连接，提供可靠服务；</li>
<li>传送TCP报文；</li>
<li>支持点对点单播，不支持多播、广播；</li>
<li>应用场景如万维网、电子邮件、文件传送等。</li>
</ol>
</li>
<li><p>UDP</p>
<ol>
<li><p>无连接，不需要套接字，不提供可靠交付；</p>
</li>
<li><p>传送UDP报文或用户数据报；</p>
</li>
<li><p>支持单播、多播和广播；</p>
</li>
<li><p>应用场景如多媒体应用等。</p>
<img src="https:////upload-images.jianshu.io/upload_images/24878825-624005a24bc5bfcd.png?imageMogr2/auto-orient/strip|imageView2/2/w/871/format/webp" alt="img" style="zoom: 50%;" /></li>
</ol>
</li>
</ul>
<h3 id="（2）TCP"><a href="#（2）TCP" class="headerlink" title="（2）TCP"></a>（2）TCP</h3><p>TCP（Transmission Control Protocol）</p>
<p>发送方</p>
<ul>
<li><p>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，但不知道这些待传送的字节流的含义</p>
</li>
<li><p>将他们编号，并存储在自己发送缓存中</p>
</li>
<li><p>根据发送策略，提取一定量的字节构建TCP报文并发送</p>
</li>
</ul>
<p>接收方</p>
<ul>
<li><p>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</p>
</li>
<li><p>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</p>
</li>
<li><p>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</p>
</li>
</ul>
<p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础。在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收。</p>
<img src="https:////upload-images.jianshu.io/upload_images/24878825-db48b70af7fb7884.png?imageMogr2/auto-orient/strip|imageView2/2/w/897/format/webp" alt="img" style="zoom:50%;" />

<h2 id="4、TCP的流量控制"><a href="#4、TCP的流量控制" class="headerlink" title="4、TCP的流量控制"></a>4、TCP的流量控制</h2><p>流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p>
<ul>
<li>当主机A收到主机B对相关字节数据的<strong>累计确认</strong>时，可以将其在发送缓存中删除。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f73e94f75e94ea4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5bd53b8a5a5ac400.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ea9dc3589e6c6bd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面。因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传。</p>
</blockquote>
<h2 id="5、TCP的拥塞控制"><a href="#5、TCP的拥塞控制" class="headerlink" title="5、TCP的拥塞控制"></a>5、TCP的拥塞控制</h2><p>在某段时间中，若对网络中某一资源（如链路容量&#x2F;带宽、缓存和处理机等）的需求超过了该资源所能提供的可用部分，就称发生了<strong>拥塞</strong>。</p>
<p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p>
<ol>
<li>点缓存的容量太小；</li>
<li>链路的容量不足；</li>
<li>处理机处理的速率太慢；</li>
<li>拥塞本身会进一步加剧拥塞；</li>
</ol>
<blockquote>
<p>相关算法</p>
<ul>
<li><strong>慢开始（slow-start）</strong></li>
<li><strong>拥塞避免（congestion avoidance）</strong></li>
<li><strong>快重传（fast transmit）</strong></li>
<li><strong>快恢复（fast recovery）</strong></li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c7682fe29ebcb6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>真正的发送窗口值 &#x3D; Min (接收方窗口值，拥塞窗口值)</p>
</blockquote>
<h3 id="（1）慢开始和拥塞避免"><a href="#（1）慢开始和拥塞避免" class="headerlink" title="（1）慢开始和拥塞避免"></a>（1）慢开始和拥塞避免</h3><h4 id="A-慢开始"><a href="#A-慢开始" class="headerlink" title="A. 慢开始"></a>A. 慢开始</h4><ul>
<li>目的：用来确定网络的负载能力或拥塞程度。</li>
<li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li>
<li>两个变量：<ul>
<li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。<ul>
<li>1 至 2 个最大报文段 （旧标准）</li>
<li>2 至 4 个最大报文段 （RFC 5681）</li>
</ul>
</li>
<li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-47dba7f2068f35df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1bca665e8eaa965a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/713/format/webp" alt="img"></p>
<blockquote>
<p>图中swnd是发送窗口</p>
<p>每经过一个传输轮次，拥塞窗口就加倍</p>
<p>窗口大小按<strong>指数增加</strong>，2的n-1次方</p>
</blockquote>
<h4 id="B-拥塞避免"><a href="#B-拥塞避免" class="headerlink" title="B. 拥塞避免"></a>B. 拥塞避免</h4><ul>
<li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。</li>
<li>每经过一个传输轮次，拥塞窗口 <strong>cwnd &#x3D; cwnd + 1</strong>。</li>
<li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li>
<li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。<img src="https://upload-images.jianshu.io/upload_images/24878825-f5db7ea25d8aca73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></li>
</ul>
<h3 id="（2）快重传和快恢复"><a href="#（2）快重传和快恢复" class="headerlink" title="（2）快重传和快恢复"></a>（2）快重传和快恢复</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-fee86fb3707a175c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="A-快重传"><a href="#A-快重传" class="headerlink" title="A. 快重传"></a>A. 快重传</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a57c7cc819aa4bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="B-快恢复"><a href="#B-快恢复" class="headerlink" title="B. 快恢复"></a>B. 快恢复</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-ab5a63efbd586eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="C-改进后的整体示意图"><a href="#C-改进后的整体示意图" class="headerlink" title="C. 改进后的整体示意图"></a>C. 改进后的整体示意图</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-8f61b8eddb5b2624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="6、TCP超时重传"><a href="#6、TCP超时重传" class="headerlink" title="6、TCP超时重传"></a>6、TCP超时重传</h2><blockquote>
<p>往返时间：<strong>RTT0</strong></p>
<p>超时重传时间：<strong>RTO</strong></p>
</blockquote>
<p>如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大；如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率。因此需要合理选择RTO的值。</p>
<ul>
<li>不能直接使用某次测量得到的RTT样本来计算超时重传时间RTO。应该利用每次测量得到的RTT样本，计算加权平均往返时间<strong>RTTs</strong>（又称为平滑的往返时间）</li>
</ul>
<p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107689.webp" alt="img"></p>
<p><strong>往返时间RTT的测量比较复杂</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107552.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107260.webp" alt="img"></p>
<p><strong>TCP超时重传的计算</strong></p>
<p>举例</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107514.webp" alt="img"></p>
<h2 id="7、TCP可靠传输的实现"><a href="#7、TCP可靠传输的实现" class="headerlink" title="7、TCP可靠传输的实现"></a>7、TCP可靠传输的实现</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-6d10ea76a1ea032b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-92d975bc880db892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-35bff0a8cc5b0d71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="8、三次握手"><a href="#8、三次握手" class="headerlink" title="8、三次握手"></a>8、三次握手</h2><h3 id="（1）三次握手详解"><a href="#（1）三次握手详解" class="headerlink" title="（1）三次握手详解"></a>（1）三次握手详解</h3><ul>
<li>采用<strong>三次握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li>
</ul>
<ul>
<li><p>TCP的连接建立要解决以下三个问题</p>
<ul>
<li>使得双方能够确知对方的存在；</li>
<li>使得双方能够协商一些参数（如最大窗口值、是否使用时间戳选项和服务质量等）；</li>
<li>使得双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li>
</ul>
</li>
<li><p><strong>具体过程</strong></p>
<ol>
<li><p><strong>TCP服务器进程创建传输控制块，用来存储TCP连接中的一些重要信息，并进入监听状态，等待TCP客户端进程的连接请求</strong></p>
</li>
<li><p><strong>TCP客户进程也是首先创建传输控制块</strong></p>
</li>
<li><p><strong>TCP客户进程向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态。</strong></p>
<ol>
<li>其中， TCP连接请求报文段首部中的同步位syn被设置为1，表明这是一个TCP连接请求报文段；</li>
<li>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号；</li>
<li>注意<em>该报文段不能携带数据</em>，但要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态。</strong></p>
<ol>
<li>同步位SYN和确认位ACK都设置为1，表明这是一个TCP连接请求确认报文段；</li>
<li>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号；</li>
<li>确认位ACK的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认；</li>
<li>注意<em>该报文段也不能携带数据</em>，且同样要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态。</strong></p>
<ol>
<li>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1；</li>
<li>确认位ACK被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认；</li>
<li>注意<em>普通的TCP确认报文段可以携带数据</em>，但如果不携带数据，则不消耗序号。</li>
</ol>
</li>
<li><p><strong>TCP服务器进程收到该确认报文段后也进入连接已建立状态。</strong></p>
</li>
</ol>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-987d5c8512392422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（2）为什么不能“两次握手”？"><a href="#（2）为什么不能“两次握手”？" class="headerlink" title="（2）为什么不能“两次握手”？"></a>（2）为什么不能“两次握手”？</h3><blockquote>
<p>不采用两次握手主要是为了<strong>防止已经失效的连接请求报文段突然又传到服务端</strong>，因而产生错误。</p>
<p>这种情况是：<strong>客户端发出的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到下一个连接释放以后的某个时间才到达服务器端。</strong>当服务器端收到此失效报文后，会误认为是客户端发出的一个新连接请求，于是客户端又发出确认报文，表示同意建立连接。</p>
<p>如果不采用“三次握手”，那么只要服务器端发出确认报文就会认为新的连接已经建立了，但此时客户端并没有发出建立连接的请求，因此不会向服务器端发送数据。服务器端没有收到数据就会一直等待，这样就会白白浪费掉很多资源。</p>
<p>所以必须采用“三次握手”而非“两次握手”。</p>
</blockquote>
<p>下图是“两次握手”的示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0a5773a600817c41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="9、四次挥手"><a href="#9、四次挥手" class="headerlink" title="9、四次挥手"></a>9、四次挥手</h2><h3 id="（1）四次挥手详解"><a href="#（1）四次挥手详解" class="headerlink" title="（1）四次挥手详解"></a>（1）四次挥手详解</h3><ul>
<li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong>端，被动等待连接建立的应用进程叫做<strong>TCP服务器</strong>。<strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong>。</li>
</ul>
<ul>
<li><p>具体过程</p>
<ol>
<li><p><strong>当客户端和服务器端都处于连接已建立状态时，若要释放连接，客户进程会发送TCP连接释放报文段，并进入终止等待状态。</strong></p>
<ol>
<li>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；</li>
<li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1；</li>
<li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1；</li>
<li>注意FIN等于1的报文段即使不携带数据，也要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态。</strong></p>
<ol>
<li>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配；</li>
<li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认。</li>
</ol>
</li>
<li><p><strong>此时，从客户进程到服务器进程这个方向的连接就释放了，这时的TCP连接属于半关闭状态，也就是客户进程已经没有数据要发送了。但如果服务器进程还有数据要发送，客户进程仍要接收，也就是说从服务器进程到客户进程这个方向的连接并未关闭。</strong></p>
</li>
<li><p><strong>客户进程收到TCP确认报文段后就进入终止等待状态，等待服务器进程发出的TCP连接释放报文段。若服务器进程已经没有数据要发送了，服务器进程即释放连接。由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接。</strong></p>
</li>
<li><p><strong>服务器进程发送TCP连接释放报文段并进入最后确认状态。</strong></p>
<ol>
<li><p>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；</p>
</li>
<li><p>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送；</p>
</li>
<li><p>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认。</p>
</li>
</ol>
</li>
<li><p><strong>客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态。服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要经过2MSL后才能进入关闭状态。</strong></p>
<ol>
<li>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号；</li>
<li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认。</li>
</ol>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1c5e0c6357d039ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
</li>
</ul>
<h3 id="（2）为什么不能“三次挥手”？"><a href="#（2）为什么不能“三次挥手”？" class="headerlink" title="（2）为什么不能“三次挥手”？"></a>（2）为什么不能“三次挥手”？</h3><p>TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p>
<blockquote>
<p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。</p>
<p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ef85470fe120f146.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="10、TCP保活计时器"><a href="#10、TCP保活计时器" class="headerlink" title="10、TCP保活计时器"></a>10、TCP保活计时器</h2><p>TCP双方已经建立连接时，TCP客户进程所在的主机突然出现了故障。此时服务器进程无法再收到客户进程发来的数据。因此，应当有措施使TCP服务器进程不要再白白等待下去。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2dc97e06fe1d82ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h1 id="四、应用层"><a href="#四、应用层" class="headerlink" title="四、应用层"></a>四、应用层</h1><h2 id="1、CS方式和P2P方式"><a href="#1、CS方式和P2P方式" class="headerlink" title="1、CS方式和P2P方式"></a>1、CS方式和P2P方式</h2><h3 id="（1）CS方式（客户-服务器方式）"><a href="#（1）CS方式（客户-服务器方式）" class="headerlink" title="（1）CS方式（客户&#x2F;服务器方式）"></a>（1）CS方式（客户&#x2F;服务器方式）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121850174.webp" alt="img"></p>
<h3 id="（2）P2P方式（对等方式）"><a href="#（2）P2P方式（对等方式）" class="headerlink" title="（2）P2P方式（对等方式）"></a>（2）P2P方式（对等方式）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121850280.webp" alt="img"></p>
<h2 id="2、动态主机配置协议DHCP"><a href="#2、动态主机配置协议DHCP" class="headerlink" title="2、动态主机配置协议DHCP"></a>2、动态主机配置协议DHCP</h2><ul>
<li><p>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</p>
</li>
<li><p>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</p>
</li>
<li><p>DHCP的工作过程</p>
<ul>
<li><p><strong>DHCP 使用客户 - 服务器方式</strong></p>
<ul>
<li><p>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文  （DHCP DISCOVER），这时该主机就成为 DHCP 客户。</p>
</li>
<li><p>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</p>
</li>
<li><p>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</p>
</li>
</ul>
</li>
<li><p><strong>DHCP 工作方式</strong></p>
<ul>
<li><p>DHCP 使用客户-服务器方式，采用请求&#x2F;应答方式工作。</p>
</li>
<li><p>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121853443.webp" alt="img"></p>
<ul>
<li><p>DHCP中继代理</p>
<h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p>下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-33c64efac75f0ad2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p>
</blockquote>
</li>
<li><p>总结</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121854516.webp" alt="img"></p>
</li>
</ul>
<h2 id="3、域名系统DNS"><a href="#3、域名系统DNS" class="headerlink" title="3、域名系统DNS"></a>3、域名系统DNS</h2><h3 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855489.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855338.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855952.webp" alt="img"></p>
<h3 id="（2）域名解析过程"><a href="#（2）域名解析过程" class="headerlink" title="（2）域名解析过程"></a>（2）域名解析过程</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856499.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856729.webp" alt="img"></p>
<h2 id="4、文件传送协议FTP"><a href="#4、文件传送协议FTP" class="headerlink" title="4、文件传送协议FTP"></a>4、文件传送协议FTP</h2><blockquote>
<p>注意两种模式都是（1）控制连接在整个会话期间保持打开状态；（2）数据连接传输完毕后就关闭。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856907.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121857685.webp" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/08/%E9%9D%A2%E8%AF%95/%E6%AF%95%E8%AE%BE%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/08/%E9%9D%A2%E8%AF%95/%E6%AF%95%E8%AE%BE%E9%A1%B9%E7%9B%AE/" class="post-title-link" itemprop="url">毕设项目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-08 00:57:15" itemprop="dateCreated datePublished" datetime="2024-04-08T00:57:15+08:00">2024-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-17 10:32:53" itemprop="dateModified" datetime="2024-04-17T10:32:53+08:00">2024-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h2 id="一、项目介绍"><a href="#一、项目介绍" class="headerlink" title="一、项目介绍"></a>一、项目介绍</h2><p>名称：<strong>多用户智能家居控制系统设计</strong>。</p>
<p><strong>设计了一个多用户智能家居控制系统。基于Qt平台开发Android客户端，同时基于MySQL数据库及多线程编程技术完成多用户操作，并利用MQTT通信协议实现了Android客户端与嵌入式控制终端之间的信息交互。、在此系统下Android 客户端的不同用户，可以通过Mosquitto云服务器转发的控制信息实现对iTop4412开发板的照明、警报及温度设备的实时控制。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404142132653.png" alt="image-20240414213213414"></p>
<p>1、 基于Linux多线程编程，结合MQTT协议的订阅-发布模式，完成多用户智能控制；</p>
<p>2、 在用户端设计双模式。共享模式：多个用户同时控制，且共享当前设备的状态；私人模式：被控制端的某一功能同一时间只能由一个用户控制；</p>
<p>3、 采用MQTT协议进行数据传送。通过实验对比HTTP协议和MQTT协议在智能家居领域的应用，结果表明MQTT在降低功耗和推送功能开发上优势明显，其即便是在资源有限的环境中也能易于使用。</p>
<p><strong>本项目的重点与核心在实现客户端的多用户控制。</strong></p>
<p>1、 针对发布者，利用Qt开发平台设计手机App作为客户端，它有两个特点，分别是多用户和双模式。多用户指不同的客户端均可进行控制操作；双模式指针对客户端本身，有共享模式和私人模式两种，在共享模式下可实现多个用户同时控制，且共享当前设备的状态；在私人模式下被控制端的某一功能同一时间只能由一个用户控制；</p>
<p>2、 针对消息代理者，选择在阿里云上部署mosquitto。选用MQTT协议的原因已在前述加以说明，而由于mosquitto是一种流行的mqtt服务器，且易于安装和配置，因此选用mosquitto进行部署；</p>
<p>3、 针对订阅者，主要以iTop4412开发板作为功能实现端。同时基于Linux多线程来配合实现多用户控制。</p>
<p><strong>本项目的数据转发过程如下。</strong></p>
<p>每个用户在该客户端程序中都对应操作两个线程：</p>
<p>（1）发送控制指令时的发布者身份，代表用户从Android客户端向嵌入式控制终端发送照明及警报的控制指令；<br>用户可自主规定订阅主题为“home&#x2F;*”格式。</p>
<p>（2）接收控制指令时的订阅者身份，代表开发板向用户发送温度数据；统一规定“temp”为传送温度数据的主题。</p>
<p><strong>发布者发出的控制指令将以json数据的格式被封装，经mosquitto云服务器转发后送至开发板侧，订阅者读取json包，解析出对应的命令行指令，对相应的硬件进行控制。</strong></p>
<h2 id="二、相关问题"><a href="#二、相关问题" class="headerlink" title="二、相关问题"></a>二、相关问题</h2><ol>
<li><p><strong>在项目中做了哪些工作，遇到了哪些困难，是怎么解决的？</strong></p>
<ul>
<li>工作：设计并实现了一个多用户智能家居控制系统，包括Android客户端、服务器软件和嵌入式控制终端。</li>
<li>困难：处理多用户操作的并发控制，确保数据一致性和系统稳定性。</li>
<li>解决方法：利用多线程编程技术和锁机制，以及基于MQTT的消息订阅和发布来处理并发控制问题。</li>
</ul>
</li>
<li><p><strong>整个项目包含哪几端之间的的通信？</strong></p>
<p>项目包含（1）Android客户端与服务器的通信；（2）服务器与嵌入式控制终端的通信；以及（3）客户端之间的间接通信（通过服务器转发）。</p>
</li>
<li><p><strong>客户端与客户端之间的通信是基于自己实现的协议吗？</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404142133602.png" alt="image-20240414213314541"></p>
</li>
<li><p><strong>是在客户端上面跑的MySQL吗？</strong></p>
<p>不是，MySQL数据库运行在服务器端，用于存储用户数据和状态信息，客户端通过网络与之通信。</p>
</li>
<li><p><strong>Qt可以直接打包安卓客户端吗？</strong>、</p>
<p>是的，Qt提供了支持Android的工具和库，可以直接将应用打包为Android客户端。</p>
</li>
<li><p><strong>Qt中做多线程的编程，有哪一些是线程同步的技术？</strong></p>
<p>Qt支持多种线程同步技术，包括互斥锁（QMutex）、读写锁（QReadWriteLock）、信号量（QSemaphore）、条件变量（QWaitCondition）等。</p>
</li>
<li><p><strong>为什么用多线程能解决冲突问题？</strong></p>
<p>程序通过 <code>pthread_create</code> 函数创建了两个线程，多线程主要用于处理订阅和发布MQTT消息的任务。</p>
<ol>
<li><code>sub_thread</code> 用于订阅 MQTT 消息并处理接收到的消息，涉及到订阅者之间的状态共享或者资源竞争，因此使用互斥锁来保护共享资源的访问，确保线程安全。</li>
<li><code>pub_thread</code> 用于发布 MQTT 消息。操作和<code>sub_thread</code>类似，但不需要对其进行加锁操作。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404142139031.png" alt="image-20240414213944988"></p>
</li>
<li><p><strong>锁是放在哪里的？</strong></p>
<p>互斥锁放在嵌入式控制终端中。</p>
</li>
<li><p><strong>比如说你有多个客户端，你怎么知道对面锁住了呢？</strong></p>
<p>客户端设计了共享模式和私人模式两种，当一个用户选择进入私人模式时，会通过Qt的信号与槽机制在客户端进行更新，告诉其他用户已经有用户进入了私人模式，本客户端无法再进入。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404142136791.png" alt="image-20240414213614733"></p>
</li>
<li><p><strong>在做技术选型的时候，什么时候选多线程，什么时候选多进程？</strong></p>
<ul>
<li><strong>选择多线程</strong>：当应用需要共享大量数据时，多线程是一种更合适的选择。多线程同一进程内的线程共享内存和资源，上下文切换成本较低，适用于对性能要求较高的场景，如实时计算、游戏开发等。</li>
<li><strong>选择多进程</strong>：多进程则适用于需要增强应用稳定性和安全性的场景，因为各进程间相互独立，一个进程的崩溃不会直接影响到其他进程。此外，多进程可以利用多核CPU的优势，实现真正的并行执行，适用于需要大量并行计算的应用，如视频处理、大规模数据分析等。</li>
</ul>
</li>
<li><p><strong>在Android客户端中，如何实现界面的实时更新和数据同步？</strong></p>
<ul>
<li>使用信号与槽机制： 在Qt中，通过信号与槽机制实现对象之间的通信。当数据发生变化时，可以通过信号发送变化的消息，然后在界面组件中连接相应的槽函数来更新界面。</li>
</ul>
</li>
<li><p><strong>如何通过mosquitto服务器将客户端的控制指令转发给iTop4412开发板？</strong></p>
<ul>
<li>在mosquitto服务器上配置相应的主题和订阅关系，客户端发布控制指令到对应的主题，mosquitto服务器将控制指令转发给iTop4412开发板的订阅者。</li>
</ul>
</li>
<li><p><strong>MQTT协议与HTTP协议相比，有何优势？为什么选择MQTT协议进行数据传送？</strong></p>
<ul>
<li>MQTT协议相比HTTP协议在降低功耗和推送功能开发上具有明显优势，适合于资源有限的环境和实时数据传输的场景。因此选择MQTT协议进行数据传送。</li>
</ul>
</li>
<li><p><strong>介绍一下阿里云上部署mosquitto的过程。</strong></p>
<ul>
<li><p>在阿里云上安装mosquitto，配置mosquitto的配置文件，设置端口号和用户名密码等参数，启动mosquitto服务，配置防火墙规则允许外部访问。</p>
</li>
<li><p>MQTT服务器的端口号通常是1883。</p>
</li>
</ul>
</li>
<li><p><strong>如何在iTop4412开发板上实现对控制指令的接收和执行？</strong></p>
<ul>
<li>通过Linux多线程编程，在iTop4412开发板上创建一个线程来监听MQTT服务器发送的控制指令，接收到指令后解析并执行对应的命令。</li>
</ul>
</li>
<li><p><strong>在Android客户端中，如何使用JSON格式封装控制指令？</strong></p>
<ul>
<li>使用 <code>cJSON_CreateObject()</code> 函数创建一个空的JSON对象。</li>
<li>使用 <code>cJSON_AddNumberToObject()</code> 函数向JSON对象中添加一个键值对，键为 “temp”，值为一个随机生成的温度值 <code>a</code>。</li>
<li>使用 <code>cJSON_Print()</code> 函数将JSON对象打印成JSON格式的字符串，并将其赋值给 <code>json_buf</code>。</li>
<li>使用 <code>mosquitto_publish()</code> 函数将JSON字符串发布到MQTT服务器上的主题为 “temp” 的通道中。</li>
</ul>
</li>
<li><p><strong>在iTop4412开发板上，如何解析JSON格式的控制指令并执行相应的功能操作？</strong></p>
<ul>
<li>使用第三方JSON库cJSON在Linux环境下解析JSON格式的控制指令，提取出对应的命令参数，然后调用相应的系统调用或执行命令行来控制硬件设备。</li>
</ul>
</li>
<li><p><strong>在多用户智能家居控制系统中，如何实现用户认证和权限管理？</strong></p>
<ul>
<li>在安卓客户端上实现用户登录和注册功能。将用户信息存储在MySQL数据库上，在登陆查询当前用户是否属于该数据库，以及用户名与密码是否匹配；若不存在，可进行注册操作。</li>
<li>由于本设计要访问特定公网的阿里云服务器上的数据库，因此在Qt开发平台上需要首先提供所需要的驱动插件之后，再利用QSqlDatabase来处理与数据库的连接，利用QSqlQuery类来执行底层数据库支持的任何SQL语句。</li>
</ul>
</li>
<li><p><strong>在iTop4412开发板上，如何实现硬件设备的驱动和控制？</strong></p>
<ul>
<li>通过 MQTT 实现硬件设备的驱动和控制：<ul>
<li>当用户在 UI 上进行操作时，比如点击 LED 开关按钮，UI 触发对应的槽函数，如 <code>on_ledBt_ON_1_clicked()</code>。</li>
<li>在槽函数中构造一个JSON 数据包，其中包含了需要控制的硬件设备信息，比如 LED 的状态。然后将这个 JSON 数据包发布到 MQTT 主题上，通过 MQTT 协议发送给 MQTT 服务器。</li>
<li>在硬件设备端，通过订阅相应的 MQTT 主题，监听来自 MQTT 服务器的消息。</li>
<li>当硬件设备端接收到相应的消息后，解析 JSON 数据包，获取到控制指令，并执行相应的操作，例如打开或关闭 LED。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>该项目还有哪些可以改进的地方？</strong></p>
<ul>
<li><p>可以在mosquitto服务器上配置TLS&#x2F;SSL加密通信，客户端和服务器之间通过证书验证进行安全连接，防止数据被窃取或篡改。确保安卓客户端与mosquitto服务器之间的通信安全性。</p>
</li>
<li><p>此外，对于多线程部分我觉得还可以再考虑细化锁的粒度，以及进行RAII技术管理互斥锁，避免在某些异常情况下未释放锁导致资源泄露问题。</p>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="midorii"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">midorii</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">midorii</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">123k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:29</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
