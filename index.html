<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch_cat_logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/site_cat-32%C3%9732.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/site_cat-16%C3%9716.png">
  <link rel="mask-icon" href="/images/cat_logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="MIDORII&#39;S JOURNEY">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="MIDORII&#39;S JOURNEY">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="midorii">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>MIDORII'S JOURNEY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MIDORII'S JOURNEY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">a little bit sweet</p>
      <a>
        <img class="custom-logo-image" src="/images/cat.jpeg" alt="MIDORII'S JOURNEY">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/26/Computer/C++/STL/STL%E4%B9%8B%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%88priority_queue%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/26/Computer/C++/STL/STL%E4%B9%8B%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%88priority_queue%EF%BC%89/" class="post-title-link" itemprop="url">STL之优先级队列（priority_queue）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-26 15:58:50 / 修改时间：16:33:23" itemprop="dateCreated datePublished" datetime="2024-04-26T15:58:50+08:00">2024-04-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/STL/" itemprop="url" rel="index"><span itemprop="name">STL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>659</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>优先级队列（priority_queue）是C++标准库中的一个容器适配器（container adapter），其中的元素按照一定的优先级进行排序，每次取出的元素都是优先级最高的。其底层实现通常使用堆（heap）数据结构。</p>
<p>定义在<queue>头文件中。</p>
<p>默认情况下，priority_queue使用std::less作为比较函数，即元素的优先级按照从大到小的顺序排列。</p>
<h2 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a>二、特点</h2><p>优先级排序：priority_queue中的元素按照一定的优先级进行排序。默认情况下，元素的优先级按照从大到小的顺序排列，也可以通过自定义的比较函数来指定不同的排序方式。</p>
<p>自动排序：在插入元素时，priority_queue会根据元素的优先级自动进行排序。每次插入新元素时，都会将新元素放置在正确的位置上。</p>
<p>取出优先级最高元素：priority_queue提供了一种方便的方式来取出优先级最高的元素。使用top()函数可以访问优先级最高的元素，而使用pop()函数可以将该元素从队列中移除。</p>
<p>底层实现采用堆：priority_queue通常使用堆（heap）数据结构来实现。堆是一种具有特定性质的二叉树，可以高效地插入新元素和取出优先级最高的元素。</p>
<p>动态大小：priority_queue的大小可以根据需要进行动态调整。可以随时插入新元素和删除已有元素，并在必要时自动重新排序。</p>
<h2 id="三、相关函数"><a href="#三、相关函数" class="headerlink" title="三、相关函数"></a>三、相关函数</h2><h3 id="1-声明"><a href="#1-声明" class="headerlink" title="1. 声明"></a>1. 声明</h3>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">priority_queue &lt;node&gt; q;</span><br><span class="line"><span class="comment">// node是一个结构体</span></span><br><span class="line"><span class="comment">// 结构体里重载了‘&lt;’小于符号</span></span><br><span class="line"></span><br><span class="line">priority_queue &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">// 不需要#include&lt;vector&gt;头文件</span></span><br><span class="line"><span class="comment">// 注意后面两个“&gt;”不要写在一起，“&gt;&gt;”是右移运算符</span></span><br><span class="line"></span><br><span class="line">priority_queue &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure>

<h3 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h3>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">size</span>();	<span class="comment">// 返回q里元素个数</span></span><br><span class="line">q.<span class="built_in">empty</span>();	<span class="comment">// 返回q是否为空，空则返回1，否则返回0</span></span><br><span class="line">q.<span class="built_in">push</span>(k);	<span class="comment">// 在q的末尾插入k</span></span><br><span class="line">q.<span class="built_in">pop</span>();	<span class="comment">// 删掉q的第一个元素</span></span><br><span class="line">q.<span class="built_in">top</span>();	<span class="comment">// 返回q的第一个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="3-排序实现"><a href="#3-排序实现" class="headerlink" title="3. 排序实现"></a>3. 排序实现</h3><ol>
<li><p>默认的优先队列（结构体，重载小于）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node &amp; a) <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> x&lt;a.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>less和greater优先队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt; p;</span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// less&lt;int&gt;:14 12 10 8 6（大顶堆）</span></span><br><span class="line"><span class="comment">// greater&lt;int&gt;:6 8 10 12 14（小顶堆）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义仿函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义仿函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareByAge</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person&amp; p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.age &gt; p2.age;  <span class="comment">// 按照年龄从小到大排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/26/Computer/C++/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/26/Computer/C++/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97/" class="post-title-link" itemprop="url">字符串与整数的相互转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-26 10:40:36 / 修改时间：17:05:52" itemprop="dateCreated datePublished" datetime="2024-04-26T10:40:36+08:00">2024-04-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>529</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天在做<strong>Leetcode 150. 逆波兰表达式求值</strong>一题时，涉及到字符串转换为整数的相关问题，遂进行如下探讨：</p>
<h2 id="1、字符串转换为整数"><a href="#1、字符串转换为整数" class="headerlink" title="1、字符串转换为整数"></a>1、字符串转换为整数</h2><h3 id="（1）四种转换方法"><a href="#（1）四种转换方法" class="headerlink" title="（1）四种转换方法"></a>（1）四种转换方法</h3>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、stoi()，传入string类型</span></span><br><span class="line">  string s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">  <span class="type">int</span> num1 = <span class="built_in">stoi</span>(s1);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2、atoi()，传入const char *类型</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s2 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">  <span class="type">int</span> num2 = <span class="built_in">atoi</span>(s2);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3、stringstream</span></span><br><span class="line">  <span class="function">stringstream <span class="title">ss</span><span class="params">(s1)</span></span>;</span><br><span class="line">  <span class="type">int</span> num3;</span><br><span class="line">  ss &gt;&gt; num3;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="type">int</span> num4;</span><br><span class="line">  <span class="built_in">sscanf</span>(s1.<span class="built_in">c_str</span>(), <span class="string">&quot;%d&quot;</span>, &amp;num4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）为什么下面四行代码得到了如下结果？"><a href="#（2）为什么下面四行代码得到了如下结果？" class="headerlink" title="（2）为什么下面四行代码得到了如下结果？"></a>（2）为什么下面四行代码得到了如下结果？</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">stoi</span>(<span class="string">&quot;13&quot;</span>) &lt;&lt; endl;  <span class="comment">// 13</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;13&quot;</span> - <span class="string">&quot;0&quot;</span> &lt;&lt; endl;  <span class="comment">// -3</span></span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;1&#x27;</span> - <span class="string">&#x27;0&#x27;</span> &lt;&lt; endl;   <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;1&quot;</span> - <span class="string">&quot;0&quot;</span> &lt;&lt; endl;   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>解释如下：</p>
<ol>
<li><code>stoi(&quot;13&quot;)</code> 将字符串 “13” 转换为整数，结果是 13。</li>
<li><code>&quot;13&quot; - &quot;0&quot;</code> 这里使用了字符串字面值进行减法运算，实际上这是不允许的，因为 C++ 中字符串字面值不能直接进行减法运算。但是在这个上下文中，编译器会尝试将字符串字面值转换为字符指针，然后进行指针运算，因此得到的结果是字符指针之间的差，即指向字符串 “13” 和 “0” 的地址之间的距离，而不是它们所代表的整数之差。在这个例子中，”13” 的地址比 “0” 的地址大，因此结果是负值，具体数值取决于编译器和平台。</li>
<li><code>&#39;1&#39; - &#39;0&#39;</code> 是字符之间的减法运算。字符 ‘1’ 对应的 ASCII 码是 49，字符 ‘0’ 对应的 ASCII 码是 48，因此结果是 1。</li>
<li><code>&quot;1&quot; - &quot;0&quot;</code> 和第二行的情况类似，仍然是字符串字面值之间的指针运算，结果是字符串指针之间的差，而不是字符串所代表的整数之差。</li>
</ol>
<h2 id="2、整数转换为字符串"><a href="#2、整数转换为字符串" class="headerlink" title="2、整数转换为字符串"></a>2、整数转换为字符串</h2>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">intToString</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">  string str;</span><br><span class="line">  <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> digit = num % <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> ch = digit + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    str = ch + str;  <span class="comment">// 将字符添加到字符串的前面</span></span><br><span class="line">    num /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、to_string</span></span><br><span class="line">  <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">  string str1 = <span class="built_in">to_string</span>(num);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2、stringstream</span></span><br><span class="line">  stringstream ss;</span><br><span class="line">  ss &lt;&lt; num;</span><br><span class="line">  string str2 = ss.<span class="built_in">str</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3、sprintf</span></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">20</span>];</span><br><span class="line">  <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">  <span class="function">string <span class="title">str</span><span class="params">(buffer)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4、自定义实现</span></span><br><span class="line">  str = <span class="built_in">intToString</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/24/Computer/C++/new%E4%B8%8Eoperator%20new/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/24/Computer/C++/new%E4%B8%8Eoperator%20new/" class="post-title-link" itemprop="url">new与operator new</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-24 14:13:55 / 修改时间：15:30:55" itemprop="dateCreated datePublished" datetime="2024-04-24T14:13:55+08:00">2024-04-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>区分三个概念：new operator、operator new和placement new</strong></p>
</blockquote>
<h1 id="一、new-operator、operator-new和placement-new"><a href="#一、new-operator、operator-new和placement-new" class="headerlink" title="一、new operator、operator new和placement new"></a>一、new operator、operator new和placement new</h1><h2 id="1、new-operator（new-操作符）"><a href="#1、new-operator（new-操作符）" class="headerlink" title="1、new operator（new 操作符）"></a>1、new operator（new 操作符）</h2><p>当写下<code>string *ps = new string(&quot;Memory Management&quot;)</code>时，使用的<code>new</code>是<strong>new操作符</strong>。这个操作符和<code>sizeof</code>一样是语言内置的，它总是完成以下功能：</p>
<ol>
<li>分配内存（调用operator new函数）；</li>
<li>调用构造函数初始化内存中的对象。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241419515.png" alt="image-20240424141921292"></p>
<h2 id="2、operator-new"><a href="#2、operator-new" class="headerlink" title="2、operator new"></a>2、operator new</h2><p>new操作符调用一个函数来完毕必需的内存分配，即<strong>operator new</strong>。注意这个函数的职责和<code>malloc</code>一样，只是为了分配内存。</p>
<p>函数operator new 通常这样声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值类型：<code>void *</code>（返回一个未经处理的<code>raw</code>指针）</li>
<li>参数<code>size_t size</code>：确定分配多少内存。可以添加额外的參数重载函数<code>operator new</code>，但第一个參数类型必须是<code>size_t</code>。</li>
</ul>
<h2 id="3、placement-new"><a href="#3、placement-new" class="headerlink" title="3、placement new"></a>3、placement new</h2><blockquote>
<p><strong>placement new是一种特殊的operator new，作用于一块已分配但未处理或未初始化的raw内存。</strong></p>
</blockquote>
<p>当存在一些已经被分配单尚未被处理的<code>raw</code>内存时，如果需要再这些内存中构造一个对象，可以使用<strong>一个特殊的operator new</strong> ，它被称为<strong>placement new</strong>。当程序使用共享内存或memory-mapped I&#x2F;O时这个函数可能实用，由于在这样程序里对象必须被放置在一个确定地址上或一块被例程分配的内存里。</p>
<p>如下例所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">　<span class="keyword">public</span>:</span><br><span class="line">　　<span class="built_in">Widget</span>(<span class="type">int</span> widgetSize);</span><br><span class="line">　　...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Widget * <span class="title">constructWidgetInBuffer</span><span class="params">(<span class="type">void</span> *buffer,<span class="type">int</span> widgetSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　<span class="keyword">return</span> <span class="built_in">new</span> (buffer) <span class="built_in">Widget</span>(widgetSize);  <span class="comment">// placement new的用法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细来说，<code>new (buffer) Widget(widgetSize)</code>是new操作符的一个使用方法，需要使用一个额外的变量<code>buffer</code>。当new操作符隐含调用operator new函数时，把这个变量传递给它，此时，被调用的operator new函数除了带有强制的参数<code>size_t</code>外，还必须接受<code>void *</code>指针参数，指向构造对象占用的内存空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>, <span class="type">void</span> *location)</span>  <span class="comment">// size_t没有名字，以防止编译器发出警告说它没有使用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　<span class="keyword">return</span> location;</span><br><span class="line">  <span class="comment">// 在使用placement new的情况下，调用者已经获得了指向内存的指针</span></span><br><span class="line">  <span class="comment">// 由于调用者知道对象应该放在哪里，placement new必须做的就是返回转递给它的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p><strong>new 、operator new 和 placement new 区别</strong></p>
<p>（1）<code>new</code>：不能被重载，其行为总是一致的。它先调用operator new分配内存，然后调用构造函数初始化那段内存。</p>
<p>（2）<code>operator new</code>：要实现不同的内存分配行为，应该重载operator new，而不是new。</p>
<p>operator new就像operator +一样，是可以重载的。如果类中没有重载operator new，那么调用的就是全局的::operator  new来完成堆的分配。同理，operator new[]、operator delete、operator delete[]也是可以重载的。</p>
<p>重载时，返回类型必须声明为void*，第一个参数类型必须为表达要求分配空间的大小（字节），类型为size_t，可以带其它参数。</p>
<p>（3）<code>placement new</code>：只是operator new重载的一个标准、全局的版本。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。因此不能删除它，但需要调用对象的析构函数。</p>
<p>如果你想在已经分配的内存中创建一个对象，使用new时行不通的。也就是说placement new允许你在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。原型中void* p实际上就是指向一个已经分配好的内存缓冲区的的首地址。</p>
<h1 id="二、Deletion-and-Memory-Deallocation"><a href="#二、Deletion-and-Memory-Deallocation" class="headerlink" title="二、Deletion and Memory Deallocation"></a>二、Deletion and Memory Deallocation</h1><h2 id="1、delete和operator-delete"><a href="#1、delete和operator-delete" class="headerlink" title="1、delete和operator delete"></a>1、delete和operator delete</h2><p>为了避免内存泄漏，每一个动态内存分配必须与一个等同相反的deallocation相应。<strong>函数operator delete</strong>与<strong>delete操作符</strong>的关系与<strong>operator new</strong>与<strong>new操作符</strong>的关系一样。</p>
<p><code>delete</code>总是完成下述功能：</p>
<ol>
<li>调用析构函数；</li>
<li>释放内存。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241445181.png" alt="image-20240424144503094"></p>
<p><code>operator delete</code>函数用来释放内存，声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *memoryToBeDeallocated)</span></span>;</span><br></pre></td></tr></table></figure>

<p>因此，<strong>假设你仅仅想处理未被初始化的内存，你应该绕过new和delete操作符，而调用operator new 获得内存和operator delete释放内存给系统</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *buffer = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="number">50</span>*<span class="built_in">sizeof</span>(<span class="type">char</span>)); <span class="comment">// 分配足够的内存以容纳50个char</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//没有调用构造函数</span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>; <span class="comment">// 释放内存</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 没有调用析构函数</span></span><br></pre></td></tr></table></figure>

<p>这与在C中调用malloc和free等同。</p>
<h2 id="2、placement-new建立的对象怎样释放？"><a href="#2、placement-new建立的对象怎样释放？" class="headerlink" title="2、placement new建立的对象怎样释放？"></a>2、placement new建立的对象怎样释放？</h2><p>假设用<code>placement new</code>在内存中建立对象，应该避免在该内存中使用delete 操作符。</p>
<p>由于delete操作符调用operator delete释放内存，但这片存最开始并不是被operator new分配的，placement new只是返回传递给它的这片内存的指针，因此无法得知这片内存究竟来自何处。因此，<strong>应该显式调用析构函数来解除构造函数的影响</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在共享内存中分配和释放内存的函数 void * mallocShared(size_t size);</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">freeShared</span><span class="params">(<span class="type">void</span> *memory)</span></span>;</span><br><span class="line"><span class="type">void</span> *sharedMemory = <span class="built_in">mallocShared</span>(<span class="built_in">sizeof</span>(Widget));</span><br><span class="line">Widget *pw = <span class="comment">// 如上所看到的</span></span><br><span class="line"><span class="built_in">constructWidgetInBuffer</span>(sharedMemory, <span class="number">10</span>); <span class="comment">// 使用</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 执行placement new操作 </span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">delete</span> pw;      <span class="comment">// 结果不确定! 共享内存来自mallocShared, 而不是operator new</span></span><br><span class="line">pw-&gt;~<span class="built_in">Widget</span>();  <span class="comment">// 正确。 析构pw指向的Widget，但并未释放存放Widget的这片内存</span></span><br><span class="line"><span class="built_in">freeShared</span>(pw); <span class="comment">// 正确。 释放pw指向的共享内存，但并未调用析构函数</span></span><br></pre></td></tr></table></figure>

<h2 id="3、new-delete和array-new-array-delete应该搭配使用"><a href="#3、new-delete和array-new-array-delete应该搭配使用" class="headerlink" title="3、new&#x2F;delete和array new&#x2F;array delete应该搭配使用"></a>3、new&#x2F;delete和array new&#x2F;array delete应该搭配使用</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241457401.png" alt="image-20240424145754309"></p>
<h1 id="三、相关问题"><a href="#三、相关问题" class="headerlink" title="三、相关问题"></a>三、相关问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Accoun *parray= <span class="keyword">new</span> Account[<span class="number">100</span>]; </span><br><span class="line"><span class="keyword">delete</span> parray; </span><br><span class="line"><span class="keyword">delete</span>[] parray; </span><br></pre></td></tr></table></figure>

<p>方括号的存在会使编译器获取数组大小（size）然后析构函数再被依次应用在每个元素上，一共size次。否则，只有一个元素被析构。 但无论哪种情况，分配的全部空间被返还给自由存储区。 </p>
<h2 id="1、为什么无论哪种情况，分配的全部空间被返还给自由存储区"><a href="#1、为什么无论哪种情况，分配的全部空间被返还给自由存储区" class="headerlink" title="1、为什么无论哪种情况，分配的全部空间被返还给自由存储区?"></a>1、为什么无论哪种情况，分配的全部空间被返还给自由存储区?</h2><p>首先，针对最后一句话“<strong>无论哪种情况，分配的全部空间被返还给自由存储区</strong>”，实际上是指：</p>
<p>无论是使用 <code>delete</code> 还是 <code>delete []</code>，分配的全部空间都会被释放，并返回给自由存储区。区别在于，<code>delete</code> 只会调用一次析构函数，而 <code>delete []</code> 会调用数组中每个元素的析构函数。因此，如果你分配了一个数组并使用 <code>delete</code> 来释放，只有一个元素的析构函数会被调用，可能导致内存泄漏，因为其他元素的资源没有得到正确释放。而使用 <code>delete []</code> 则能保证每个元素的析构函数都被正确调用，避免了这种潜在的内存泄漏问题。</p>
<h2 id="2、对于delete-parray，编译器怎么知道parray这个指针实际指向的是数组还是单个元素？"><a href="#2、对于delete-parray，编译器怎么知道parray这个指针实际指向的是数组还是单个元素？" class="headerlink" title="2、对于delete[] parray，编译器怎么知道parray这个指针实际指向的是数组还是单个元素？"></a>2、对于delete[] parray，编译器怎么知道parray这个指针实际指向的是数组还是单个元素？</h2><p>（1）一般在分配时分配器会自动写一个日志（即在分配的内存之前有一个结构）用于记录分配的大小，分配内容的sizeof等等。 </p>
<p>直观来说，<code>delete</code>和<code>delete[]</code>都是传入一个<code>void*</code>，因此如果不保存日志就无法知道分配时到底是分配了一个还是多个单元。所以虽然<code>delete</code>和<code>delete[]</code>不同，但是分配器在执行释放过程中都会读取这个日志，从而了解到底应该释放多少内存，但是从程序员的角度来说，既然分配了数组，就应该用<code>delete[]</code>。</p>
<p>（2）在VC下用汇编跟过delete[]的执行情况,发现这个 “日志 “就是一个4字节长的整数记录数组元素个数,紧挨在数组第一个元素之前。但是有个前提：对象类型(或其基类)有显式析构函数.换句话说,析构函数是非<code>virtual</code>的。否则的话,数组前面是没有这个日志的。其实对于析构函数是<code>virtual</code>的情况，<code>delete[]</code>时无需调用其析构函数，因此此时<code>VC</code>把<code>delete[]</code>当做<code>delete</code>同样处理。</p>
<p>（3）<code>delete parray</code>，编译器得到类型信息是<code>Account</code>单个的指针，那么释放时，只调用一次析构函数。<br><code>delete[] parray</code>，编译器得到的类型信息是<code>Account[]</code>类型，则按照<code>Account</code>数组来处理，依次调用每个元素的析构函数。 </p>
<h2 id="3、编译器又是如何获知这个数组的大小？"><a href="#3、编译器又是如何获知这个数组的大小？" class="headerlink" title="3、编译器又是如何获知这个数组的大小？"></a>3、编译器又是如何获知这个数组的大小？</h2><p>当我们使用<code>operator new</code>为一个自定义类型对象分配内存时，我们得到的内存要比实际对象的内存大一些，这些内存除了要存储对象数据外，还需要记录这片内存的大小，此方法称为<code>cookie</code>。这一点上的实现依据不同的编译器不同。（例如<code>MFC</code>选择在所分配内存的头部存储对象实际数据，而后面的部分存储边界标志和内存大小信息。<code>g++</code>则采用在所分配内存的头4个自己存储相关信息，而后面的内存存储对象实际数据。）当我们使用<code>delete operator</code>进行内存释放操作时，<code>delete operator</code>就可以根据这些信息正确的释放指针所指向的内存块。<br>对于<code>parray</code>指针，可以根据这样的<code>cookie</code>信息来得到指向内存空间的大小，<code>delete parray</code>和<code>delete[] parray</code>都是一样的，同样一个指针，<code>cookie</code>信息是相同的，所以对应的内存都会被释放掉。但是由于编译器理解两种情况下的类型是不同的，所以调用析构函数会有不同。 </p>
<h1 id="四、相关参考"><a href="#四、相关参考" class="headerlink" title="四、相关参考"></a>四、相关参考</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241530554.png" alt="image-20240424153034458"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404241530444.png" alt="image-20240424153053351"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luxiaoxun/archive/2012/08/10/2631812.html">C++中的new、operator new与placement new</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/17/Computer/Linux%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/17/Computer/Linux%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Linux基础相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-17 10:06:59 / 修改时间：10:36:05" itemprop="dateCreated datePublished" datetime="2024-04-17T10:06:59+08:00">2024-04-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>39 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、GCC安装"><a href="#1、GCC安装" class="headerlink" title="1、GCC安装"></a>1、GCC安装</h2><h3 id="（1）GCC相关知识点"><a href="#（1）GCC相关知识点" class="headerlink" title="（1）GCC相关知识点"></a>（1）GCC相关知识点</h3><p>GCC（GNU Compiler Collection， GNU编译器套件）是由GNU开发的编程语言译器。</p>
<p>gcc和g++都是GNU（组织）的一个编译器</p>
<ul>
<li>误区一：gcc只能编译C程序，g++只能编译C++代码：<ul>
<li>后缀为.c时，gcc认为其是C程序，g++认为其是C++程序；</li>
<li>后缀为.cpp时，gcc和g++均认为其是C++程序。</li>
</ul>
</li>
<li>误区二：编译只能用gcc，链接只能用g++：<ul>
<li>严格来说不算错误，但混淆了概念，应该说：编译可以用gcc&#x2F;g++，而链接可以用g++或者gcc -lstdc++;</li>
<li>gcc命令不能自动和C++程序使用的库链接，所以通常使用g++来完成链接。但在编译阶段，g++会自动调用gcc，二者等价。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171012036.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171012580.png" alt="2"></p>
<h3 id="（2）GCC工作流程"><a href="#（2）GCC工作流程" class="headerlink" title="（2）GCC工作流程"></a>（2）GCC工作流程</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013866.png" alt="3"></p>
<ul>
<li><p>预处理：对头文件展开\删除代码中的注释\宏替换</p>
</li>
<li><p><strong>程序编译成可执行程序的过程：</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013529.png" alt="4"></p>
</li>
</ul>
<h2 id="2、静态库和动态库"><a href="#2、静态库和动态库" class="headerlink" title="2、静态库和动态库"></a>2、静态库和动态库</h2><h3 id="（1）静态库"><a href="#（1）静态库" class="headerlink" title="（1）静态库"></a>（1）静态库</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013337.png" alt="5"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013840.png" alt="6"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson/library<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">├── add.c</span><br><span class="line">├── div.c</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br><span class="line">root@iisayhi:~/lesson/library<span class="comment"># gcc main.c -o app -I ./include/ -l calc -L ./lib/</span></span><br><span class="line">root@iisayhi:~/lesson/library<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── app</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">		├── add.c</span><br><span class="line">		├── div.c</span><br><span class="line">		├── mult.c</span><br><span class="line">		└── sub.c</span><br></pre></td></tr></table></figure>

<h3 id="（2）动态库"><a href="#（2）动态库" class="headerlink" title="（2）动态库"></a>（2）动态库</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013622.png" alt="7"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013961.png" alt="8"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171013076.png" alt="9"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/calc# **gcc -c -fpic add.c mult.c sub.c div.c** </span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# ls</span><br><span class="line">add.c  add.o  div.c  div.o  head.h  main.c  mult.c  mult.o  sub.c  sub.o</span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# **gcc -shared *.o -o libcalc.so**</span><br><span class="line">root@iisayhi:~/lesson/lesson01/calc# ll</span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x 2 root root  4096 Apr  6 22:49 ./</span><br><span class="line">drwxr-xr-x 4 root root  4096 Apr  6 22:47 ../</span><br><span class="line">-rw-r--r-- 1 root root    80 Apr  6 22:47 add.c</span><br><span class="line">-rw-r--r-- 1 root root  1376 Apr  6 22:48 add.o</span><br><span class="line">-rw-r--r-- 1 root root    94 Apr  6 22:47 div.c</span><br><span class="line">-rw-r--r-- 1 root root  1384 Apr  6 22:48 div.o</span><br><span class="line">-rw-r--r-- 1 root root   189 Apr  6 22:47 head.h</span><br><span class="line">-rwxr-xr-x 1 root root 15824 Apr  6 22:49 libcalc.so*</span><br><span class="line">-rw-r--r-- 1 root root   306 Apr  6 22:47 main.c</span><br><span class="line">-rw-r--r-- 1 root root    85 Apr  6 22:47 mult.c</span><br><span class="line">-rw-r--r-- 1 root root  1384 Apr  6 22:48 mult.o</span><br><span class="line">-rw-r--r-- 1 root root    85 Apr  6 22:47 sub.c</span><br><span class="line">-rw-r--r-- 1 root root  1376 Apr  6 22:48 sub.o</span><br></pre></td></tr></table></figure>

<ul>
<li>运行main可执行文件报错：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># gcc main.c -o main -I include/ -L lib/ -l calc</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ls</span></span><br><span class="line">include  lib  main  main.c  src</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">**./main: error <span class="keyword">while</span> loading shared libraries: [libcalc.so](&lt;http://libcalc.so/&gt;): cannot open shared object file: No such file or directory**</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffda29fd000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; not found</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbe8fa25000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007fbe8fc31000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>原因即是由于动态库是在程序启动后才被加载到内存中，而我们自己写的动态库libcalc.so并没有给出对应的路径去查找它，所以会报错。</p>
<p>解决方法：</p>
<blockquote>
<p>对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的 <strong>DT_RPATH段</strong> ——&gt; <strong>环境变量LD_LIBRARY_PATH</strong> ——&gt; <strong>&#x2F;etc&#x2F;ld.so.cache</strong>文件列表 ——&gt; <strong>&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib</strong>目录找到库文件后将其载入内存</p>
</blockquote>
<p><strong>1）DT_RPATH段 无法修改，系统本身固定值</strong></p>
<p><strong>2）环境变量LD_LIBRARY_PATH</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># echo $LD_LIBRARY_PATH </span></span><br><span class="line">:/root/lesson/lesson01/library/lib</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffff57e5000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; /root/lesson/lesson01/library/lib/libcalc.so (0x00007f06515af000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f06513aa000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f06515bb000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">a = 20, b = 12</span><br><span class="line">a + b = 32</span><br><span class="line">a - b = 8</span><br><span class="line">a * b = 240</span><br><span class="line">a / b = 1.666667</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>直接在终端中配置，当终端被关闭后该环境变量就会消失了，属于临时性配置。</p>
<p>永久性配置：</p>
<ul>
<li><p>用户级别</p>
<ul>
<li><p>根目录下，<code>vim .bashrc</code></p>
</li>
<li><p>在最后一行加上要添加的路径</p>
<p><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</code></p>
</li>
<li><p><code>source ~/.bashrc</code></p>
</li>
</ul>
</li>
<li><p>系统级别</p>
<ul>
<li><p><code>sudo vim /etc/profile</code></p>
</li>
<li><p>在最后一行加上要添加的路径</p>
<p><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/lesson/lesson01/library/lib</code></p>
</li>
<li><p><code>source /etc/profile</code></p>
</li>
</ul>
</li>
</ul>
<p><strong>3）&#x2F;etc&#x2F;ld.so.cache文件列表</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@iisayhi:~/lesson<span class="comment"># ll /etc/ld.so.cache</span></span><br><span class="line">-rw-r--r-- 1 root root 74025 Jan 12 21:15 /etc/ld.so.cache</span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># **sudo vim /etc/ld.so.conf**</span></span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># **sudo ldconfig**</span></span><br><span class="line">root@iisayhi:~/lesson<span class="comment"># cd lesson01/library/</span></span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ldd main</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffd633f6000)</span><br><span class="line">[libcalc.so](&lt;http://libcalc.so/&gt;) =&gt; /root/lesson/lesson01/library/lib/libcalc.so (0x00007f7b8a4e1000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7b8a2ef000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f7b8a500000)</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment"># ./main</span></span><br><span class="line">a = 20, b = 12</span><br><span class="line">a + b = 32</span><br><span class="line">a - b = 8</span><br><span class="line">a * b = 240</span><br><span class="line">a / b = 1.666667</span><br><span class="line">root@iisayhi:~/lesson/lesson01/library<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p><code>/etc/ld.so.cache</code>是一个二进制文件，无法直接用vim进行修改；</p>
<p>因此要借助<code>/etc/ld.so.conf</code>的帮助：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014770.png" alt="10"></p>
<p><strong>4）&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib目录</strong></p>
<p>不推荐使用，因为在上述目录下已经包含很多系统自带的库文件，因此可能存在重名导致被替换的问题存在。</p>
<h3 id="（3）静态库和动态库的对比"><a href="#（3）静态库和动态库的对比" class="headerlink" title="（3）静态库和动态库的对比"></a>（3）静态库和动态库的对比</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014481.png" alt="11"></p>
<ul>
<li>消耗系统资源、浪费内存：<ul>
<li>每个程序在运行时都会将静态库复制一份到内存中，多个程序同时运行时浪费内存；</li>
</ul>
</li>
<li>更新、部署、发布麻烦：<ul>
<li>每次更新、部署或发布时都需要重新编译</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014264.png" alt="12"></p>
<h2 id="3、Makefile"><a href="#3、Makefile" class="headerlink" title="3、Makefile"></a>3、Makefile</h2><ul>
<li>定义<ul>
<li>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 <code>Makefile 文件就像一个 Shell 脚本一样，也可以执行操作系统的命令</code>。</li>
<li><strong>Makefile 带来的好处就是“自动化编译”</strong> ，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如 Delphi 的 <code>make</code>，Visual C++ 的 <code>nmake</code>，Linux 下 GNU 的 <code>make</code>。</li>
</ul>
</li>
<li>命名规则</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014308.png" alt="13"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014605.png" alt="14"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171014917.png" alt="15"></p>
<ul>
<li>工作原理</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015389.png" alt="16"></p>
<ul>
<li>变量</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015553.png" alt="17"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171018439.png" alt="Untitled"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019513.png" alt="Untitled"></p>
<p><strong>对原始写法进行简写：</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015837.png" alt="20"></p>
<p>改进1：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171018316.png" alt="Untitled"></p>
<p>改进2：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015549.png" alt="22"></p>
<p>改进3：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171015818.png" alt="23"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY:clean  # 定义clean为伪目标</span><br></pre></td></tr></table></figure>

<p>改进4：<code>Makefile</code>中写了<code>clean</code>之后，在命令行要用<code>make clean</code>来调用</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404171019153.png" alt="24"></p>
<h2 id="4、GDB调试"><a href="#4、GDB调试" class="headerlink" title="4、GDB调试"></a>4、GDB调试</h2>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/17/Computer/Linux%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/13/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/13/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">手撕算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-13 14:56:15" itemprop="dateCreated datePublished" datetime="2024-04-13T14:56:15+08:00">2024-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-17 10:33:32" itemprop="dateModified" datetime="2024-04-17T10:33:32+08:00">2024-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9A%82%E4%B8%8D%E5%88%86%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">--暂不分类</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>455</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>合并K个有序数组</p>
<p>TOPK问题</p>
<p>逆波兰表达式</p>
<p>动态规划</p>
<p>快排最坏情况的比较次数，归并排序呢？</p>
<p>自定义实现strcpy函数</p>
<h3 id="1、字符串分割函数"><a href="#1、字符串分割函数" class="headerlink" title="1、字符串分割函数"></a>1、字符串分割函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//字符串分割函数</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">split</span><span class="params">(std::string str, std::string pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string::size_type pos;</span><br><span class="line">    std::vector&lt;std::string&gt; result;</span><br><span class="line">    str += pattern;<span class="comment">//扩展字符串以方便操作</span></span><br><span class="line">    <span class="type">int</span> size = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = str.<span class="built_in">find</span>(pattern, i);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; size)</span><br><span class="line">        &#123;</span><br><span class="line">            std::string s = str.<span class="built_in">substr</span>(i, pos - i);</span><br><span class="line">            result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            i = pos + pattern.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、string转int"><a href="#2、string转int" class="headerlink" title="2、string转int"></a>2、string转int</h3><p>1、使用atoi转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure>

<p>2、 使用std::stoi</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;-10&quot;</span>;</span><br><span class="line">std::<span class="built_in">stoi</span>(str);</span><br><span class="line"><span class="comment">// stoi()函数没有数字的话，程序虽然可以编译，但运行时会出错</span></span><br></pre></td></tr></table></figure>

<p>3、 通过 istringstream 转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;668&quot;</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function">std::istringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">ss &gt;&gt; num;</span><br></pre></td></tr></table></figure>

<p>使用 istringstream 可以从字符流中读取整数，与 ostringstream 是一种相反的操作</p>
<p>4、使用 sscanf</p>
<p>sscanf 函数是 C 语言标准库中的函数，可以用于从一个格式化的字符串中提取数据。在 C++ 中，可以使用 sscanf 函数将字符串转换为整数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">sscanf</span>(str.<span class="built_in">c_str</span>(), <span class="string">&quot;%d&quot;</span>, &amp;num) == <span class="number">1</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted number: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to convert the string to an integer.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、int转为string"><a href="#3、int转为string" class="headerlink" title="3、int转为string"></a>3、int转为string</h3><p>1、通过 std::to_string() 函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">to_string</span>(num)</span><br></pre></td></tr></table></figure>

<p>这种方式在 C++11 中才能使用，编译时记得加上 –std&#x3D;c++11 的选项</p>
<p>2、通过 ostringstream</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">std::ostringstream ss;</span><br><span class="line">ss &lt;&lt; num;</span><br><span class="line">std::cout &lt;&lt; ss.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure>

<p>这是一种通过字符流的方式将整数转换成字符串，这种方式在C++11之前也可以使用</p>
<p>3、通过 sprintf</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br></pre></td></tr></table></figure>

<p>这是一种C语言中的转换方式，sprintf 也可以换成更安全的 snprintf 函数，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;%d&quot;</span>, num);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/09/Computer/DataStruct/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/09/Computer/DataStruct/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="post-title-link" itemprop="url">代码随想录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-09 20:29:30" itemprop="dateCreated datePublished" datetime="2024-04-09T20:29:30+08:00">2024-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-26 16:29:09" itemprop="dateModified" datetime="2024-04-26T16:29:09+08:00">2024-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/DataStruct/" itemprop="url" rel="index"><span itemprop="name">DataStruct</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>29 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><h2 id="1、二分法"><a href="#1、二分法" class="headerlink" title="1、二分法"></a>1、二分法</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></p>
<ol>
<li><p>本题我采用左闭右开的取法，因此：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// &amp;&amp;</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br></pre></td></tr></table></figure>

<p>当<code>nums[mid]</code>和<code>target</code>不相等需要更新<code>left/right</code>时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = mid + <span class="number">1</span>;  <span class="comment">// left是取得到的</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">right = mid;	 <span class="comment">// right是取不到的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新<code>mid</code>时采用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/submissions/521863494/">35. 搜索插入位置</a></p>
<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<p>这道题做的时候卡了很久，最开始采用前闭后开的区间，但结果是错的，改成前闭后闭的区间就正确了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">searchLeftRange</span>(nums, target);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">searchRightRange</span>(nums, target);</span><br><span class="line">        <span class="comment">// 情况一</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">-2</span> || r == <span class="number">-2</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="comment">// 情况三</span></span><br><span class="line">        <span class="keyword">if</span> (r - l &gt; <span class="number">1</span>) <span class="keyword">return</span> &#123;l + <span class="number">1</span>, r - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 情况二</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchLeftRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">-2</span>;</span><br><span class="line">        <span class="comment">// 寻找左边界</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                l = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchRightRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">-2</span>;</span><br><span class="line">        <span class="comment">// 寻找右边界</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                r = left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69. x的平方根"></a>69. x的平方根</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/">69. x的平方根</a></p>
<p>1、由于y&#x3D;√x的图像是单调递增的，符合二分查找的条件，因此本题可采用二分查找的方式解决。</p>
<p>2、题目所述x为非负整数，因此left应该初始化为1而非0。</p>
<p>3、<strong>最后结束循环，返回右边界，主要是因为平方根是向下取整，例如 8 的平方跟是 2，而循环结束的条件又是 l &gt; r，因此最后返回右边界 r</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int left = 0;</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = x;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// int tmp = mid * mid;</span></span><br><span class="line">            <span class="comment">// if (mid == x / mid) &#123;</span></span><br><span class="line">            <span class="comment">//     return mid;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">if</span> (mid &lt; x / mid) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; x / mid)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return -1;</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、双指针法"><a href="#2、双指针法" class="headerlink" title="2、双指针法"></a>2、双指针法</h2><p>双指针法：通过一个快指针和一个慢指针在一个for循环下完成两个for循环的工作</p>
<ol>
<li><p><strong>快慢指针</strong>：<strong>快慢指针通常都从下标为0的地方开始走</strong>，当快指针达到末尾时，慢指针通常还在中间位置。</p>
</li>
<li><p><strong>左右指针</strong>：<strong>左右指针分别从数组的两端出发</strong>，根据问题的要求移动指针，并通过调整指针位置来实现问题的解决。</p>
</li>
<li><p><strong>滑动窗口</strong>：常用于解决数组或字符串中的子数组或子串问题，如最小覆盖子串、最长无重复字符的子串等。滑动窗口由左右指针定义，<strong>左指针指向窗口的起始位置，右指针指向窗口的结束位置，通过移动两个指针来扩大或缩小窗口</strong>，从而找到满足特定条件的子数组或子串。</p>
<p>在采用滑动窗口解决问题时，主要确定以下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
</li>
</ol>
<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></p>
<ul>
<li><p>解题思路</p>
<p>本题要求：<em>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组</em>，看到这样的要求时，就要很快地联想到<strong>双指针法（快慢指针法）</strong>。</p>
<ol>
<li><code>fast</code>和<code>slow</code>同时指向数组开始；</li>
<li>判断是否<code>nums[fast]==val</code>，若相等，<code>fast</code>前移一位，继续判断，直到<code>nums[fast]!=val</code>；</li>
<li>此时，将<code>nums[fast]</code>赋值给<code>nums[slow]</code>，<code>slow</code>前移一位；</li>
<li>循环执行步骤<strong>2&amp;3</strong>，直到<code>fast</code>遍历到数组末尾。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[fast] == val) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">                <span class="keyword">if</span> (fast == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> slow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></p>
<ul>
<li><p>解题思路</p>
<p>由于题目中已经说了“整数数组<code>nums</code>是非递减的”，那么在包含负数的情况下，平方后最大值就只能位于数组的两端。因此可以采用<strong>双指针法</strong>，用两个指针分别指向最左边和最右边，依次向中间移动。</p>
<ol>
<li>用两个指针<code>l</code>和<code>r</code>分别指向最左边和最右边，同时定义一个新的数组作为结果数组返回；</li>
<li>判断左右两边谁平方后的值更大，将大的那个放入结果数组的最右边；</li>
<li>更新指针；</li>
<li>重复步骤2&amp;3，直到原数组遍历完毕。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> index = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> tmpl = nums[l] * nums[l];</span><br><span class="line">            <span class="type">int</span> tmpr = nums[r] * nums[r];</span><br><span class="line">            <span class="keyword">if</span> (tmpl &lt; tmpr) &#123;</span><br><span class="line">                res[index] = tmpr;</span><br><span class="line">                index--;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[index] = tmpl;</span><br><span class="line">                index--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></p>
<ul>
<li><p>解题思路</p>
<p><strong>当看到题目中出现“子数组”、“子序列”等时，一般就要想到采用滑动窗口来解决。</strong>但这里我最开始想的是下面这种解法，这样实际上就是一种暴力的思想，而非双指针的思想。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样写会超时</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="type">int</span> sum = nums[i];</span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        sum += nums[j];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = j-i+<span class="number">1</span>;</span><br><span class="line">            len = tmp &lt; len ? tmp : len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，在本题中窗口就是满足其<code>和&gt;=target</code>的长度最小的连续子数组。移动窗口的起始位置是为了在满足条件的情况下缩小窗口，移动窗口的结束位置是为了遍历数组的所有元素。</p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                <span class="type">int</span> sublen = j-i+<span class="number">1</span>;</span><br><span class="line">                len = sublen &lt; len ? sublen : len;</span><br><span class="line">                sum -= nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == INT32_MAX) len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、循环不变原则"><a href="#3、循环不变原则" class="headerlink" title="3、循环不变原则"></a>3、循环不变原则</h2><h3 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59. 螺旋矩阵II"></a>59. 螺旋矩阵II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵II</a></p>
<ul>
<li><p>解题思路</p>
<p>本题实际上就是考察了<strong>循环不变量原则</strong>，要注意选择好了遍历<strong>区间的开闭</strong>后就一定要贯彻其开闭原则。</p>
<p>将整个过程分为从外到内“画”每一圈的过程。在此基础上，每一圈又包含4步：</p>
<ol>
<li>从左至右</li>
<li>从上至下</li>
<li>从右至左</li>
<li>从下至上</li>
</ol>
<p>这样经过一圈之后，就会回到这一圈的起点，接下来遍历下一圈，直到结束为止。</p>
<p>要注意几个地方：</p>
<ol>
<li><p>每一圈的起始坐标依次为<code>(1, 1)</code>，<code>(2, 2)</code>，….，因此每一圈结束后，<code>x</code>和<code>y</code>的起始位置都要分别加1才能进入下一圈；</p>
</li>
<li><p>循环的结束条件就是遍历到了最后一圈，其中要循环的圈数是<code>n/2</code>，这个可以举几个例子推导；另外一个要注意的就是当<code>n</code>为奇数时，最内圈是一个单独的值<code>n^2</code>，需要单独填充；</p>
</li>
<li><p>在遍历每一圈的4条边时，坚持左闭右开的原则：也就是说，每一条边的最后<code>n</code>个值属于下一条边。如下图所示，这是第一圈的情况。一定要记得设置一个<code>offset</code>，<strong>因为每遍历一圈，每条边的右边界就要收缩一位。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404102110076.png" alt="image-20240410211008731" style="zoom:33%;" /></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>;     <span class="comment">// 定义每一圈的起始坐标位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>;               <span class="comment">// 定义循环几圈</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>;                 <span class="comment">// 定义每一条边遍历的长度 </span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;                  <span class="comment">// 用来给矩阵赋值</span></span><br><span class="line">        <span class="keyword">while</span> (loop--) &#123;</span><br><span class="line">            <span class="type">int</span> i = startx;</span><br><span class="line">            <span class="type">int</span> j = starty;</span><br><span class="line">            <span class="comment">// 从左至右</span></span><br><span class="line">            <span class="keyword">for</span> (j; j&lt;n-offset; ++j) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="comment">// 从上至下</span></span><br><span class="line">            <span class="keyword">for</span> (i; i&lt;n-offset; ++i) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从右至左</span></span><br><span class="line">            <span class="keyword">for</span> (j; j&gt;starty; --j) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从下至上</span></span><br><span class="line">            <span class="keyword">for</span> (i; i&gt;startx; --i) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset++;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            res[n/<span class="number">2</span>][n/<span class="number">2</span>] = n*n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h1><p>实际上感觉链表的题都可以用快慢指针来解决。</p>
<h2 id="1、链表的定义"><a href="#1、链表的定义" class="headerlink" title="1、链表的定义"></a>1、链表的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	ListNode *next;</span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、删除链表元素"><a href="#2、删除链表元素" class="headerlink" title="2、删除链表元素"></a>2、删除链表元素</h2><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><p>举例来说，从<code>2-&gt;6-&gt;3</code>中删除节点6，需要完成以下几步：</p>
<p>（1）保存节点6，便于后续释放；</p>
<p>（2）将2的next改完3；</p>
<p>（3）释放原节点6。</p>
</li>
<li><p>注意要引入一个虚拟头结点，这样就可以避免在操作时还要区分头节点和非头节点两种情况。并且注意在最后返回真正的头节点时，返回的是<code>dummyhead-&gt;next</code>。</p>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *dummynode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummynode-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode *cur = dummynode;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode *tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummynode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummynode;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a>707. 设计链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></p>
<ul>
<li><p>解题思路</p>
<p>这里有一个要注意的点，那就是对于这个<code>index</code>，在访问操作和增删操作时，遍历停止的位置是不同的：</p>
<ol>
<li>对于访问操作，需要<code>cur</code>正好停在<strong>下标为<code>index</code>的节点</strong>上，这样才能正确取到值；</li>
<li>对于增删操作，需要<code>cur</code>停在<strong>下标为<code>index</code>的前一个节点</strong>上，这样才方便进行增删操作。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (index-- &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        tmp-&gt;next = _dummyhead-&gt;next;</span><br><span class="line">        _dummyhead-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = tmp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListNode *_dummyhead;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="19-删除链表的倒数第N个结点"><a href="#19-删除链表的倒数第N个结点" class="headerlink" title="19. 删除链表的倒数第N个结点"></a>19. 删除链表的倒数第N个结点</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第N个结点</a></p>
<ul>
<li><p>解题思路</p>
<p>本题我采用了两趟扫描的方式进行解答。第一趟扫描确定了链表的长度，第二趟扫描则定位到了<strong>要删除结点的前一个结点</strong>。</p>
<ol>
<li><p>由于涉及到对头节点<code>head</code>的操作，因此定义一个<code>dummyhead</code>，避免需要对头结点单独操作；</p>
</li>
<li><p>如何定位到要删除结点的前一个结点，实际上需要分析<code>n</code>和<code>sz</code>之间的关系，如下图所示：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404120946983.png" alt="image-20240412094658218" style="zoom: 33%;" /></li>
</ol>
<blockquote>
<p>然而这道题我看了代码随想录提供的题解，实际上也是快慢指针法的一种变体，并且使用快慢指针法就可以无需先遍历一遍链表来求出链表的总长度。</p>
<p>只需要定义<code>fast</code>和<code>slow</code>两个指针</p>
<ul>
<li><code>fast</code>先走<code>n+1</code>步。之后<code>fast</code>和<code>slow</code>同时向前走；</li>
<li>当<code>fast</code>指向<code>nullptr</code>时，<code>slow</code>就正好指向要删除结点的前一个结点。</li>
</ul>
</blockquote>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *cur1 = head;</span><br><span class="line">        <span class="type">int</span> sz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            sz++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line">        ListNode *cur = dummyhead;</span><br><span class="line">        <span class="type">int</span> m = sz-n;</span><br><span class="line">        <span class="keyword">while</span> (m &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        head = dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyhead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、反转链表"><a href="#3、反转链表" class="headerlink" title="3、反转链表"></a>3、反转链表</h2><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li><p>这道题实际上也相当于是双指针法中的快慢指针，通过定义两个指针<code>pre</code>和<code>cur</code>来依次遍历链表中的所有元素，并在遍历的过程中修改指针的指向。</p>
</li>
<li><p>有一个要注意的点在于：<code>while</code>循环的终止条件是<code>cur != nullptr</code>，若采用<code>cur-&gt;next != nullptr</code>，则最后一个节点不会被遍历到。</p>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p>
<ul>
<li><p>解题思路</p>
<p>实际上这道题只要能够画图模拟出交换的过程，就没有问题了。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404111457295.png" alt="image-20240411145728810"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode *cur = dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode *tmp1 = cur-&gt;next;</span><br><span class="line">            ListNode *tmp2 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next = tmp1;</span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = tmp2;</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next;  <span class="comment">// cur要往后跳两步</span></span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyhead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、链表相交"><a href="#4、链表相交" class="headerlink" title="4、链表相交"></a>4、链表相交</h2><h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></p>
<ul>
<li><p>解题思路</p>
<p>主要有以下几个点要注意：</p>
<ol>
<li><p>最开始我额外定义了<code>a</code>和<code>b</code>用于去遍历两个链表来长度，实际上可以直接定义<code>curA</code>和<code>curB</code>，在遍历结束上让其重新指向头结点即可；</p>
</li>
<li><p>该题交点不是数值相等，而是指针相等！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curA-&gt;val == curB-&gt;val)  <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">if</span> (curA == curB)			 <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size_a = <span class="number">0</span>, size_b = <span class="number">0</span>;</span><br><span class="line">        ListNode *curA = headA;</span><br><span class="line">        ListNode *curB = headB;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            size_a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">            size_b++;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">abs</span>(size_a - size_b);</span><br><span class="line">        <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// if (curA-&gt;val == curB-&gt;val) &#123;</span></span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></p>
<ul>
<li><p>解题思路</p>
<p>定义快慢指针<code>fast</code>和<code>slow</code>，其中<code>fast</code>每次走两个结点，<code>slow</code>每次走一个结点。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121316807.png" alt="image-20240412131623148"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *index1 = fast;</span><br><span class="line">                ListNode *index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三、哈希表"><a href="#三、哈希表" class="headerlink" title="三、哈希表"></a>三、哈希表</h1><h2 id="1、理论基础"><a href="#1、理论基础" class="headerlink" title="1、理论基础"></a>1、理论基础</h2><p>哈希表即为散列表，一般用于判断一个元素是否出现在集合里。</p>
<p>（1）常见的三种哈希函数：</p>
<ul>
<li><p>数组</p>
</li>
<li><p>集合（<code>set</code>）</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<ul>
<li><code>std::unordered_set</code>底层实现为哈希表；</li>
<li><code>std::set</code>和<code>std::multiset</code>的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以<code>key</code>值是有序的，但<code>key</code>不可以修改，改动<code>key</code>值会导致整棵树的错乱，所以只能删除和增加。</li>
</ul>
</li>
<li><p>映射（<code>map</code>）</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<ul>
<li><code>std::unordered_map</code>底层实现为哈希表；</li>
<li><code>std::map</code>和<code>std::multimap</code>的底层实现是红黑树。同理，<code>std::map</code>和<code>std::multimap</code>的<code>key</code>也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</li>
</ul>
</li>
</ul>
<p>（2）<code>std::unordered_set</code>提供了一系列方法来管理集合中的元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">插入元素：</span><br><span class="line">    <span class="built_in">insert</span>(): 向集合中插入元素。</span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">    <span class="built_in">erase</span>(): 删除集合中的元素。</span><br><span class="line">    <span class="built_in">clear</span>(): 清空集合中的所有元素。</span><br><span class="line"></span><br><span class="line">查找元素：</span><br><span class="line">    <span class="built_in">find</span>(): 查找集合中是否存在指定元素。</span><br><span class="line">    <span class="built_in">count</span>(): 统计集合中指定元素的个数。</span><br><span class="line"></span><br><span class="line">迭代器：</span><br><span class="line">    <span class="built_in">begin</span>(): 返回指向集合起始元素的迭代器。</span><br><span class="line">    <span class="built_in">end</span>(): 返回指向集合末尾元素的迭代器。</span><br><span class="line"></span><br><span class="line">大小和容量：</span><br><span class="line">    <span class="built_in">size</span>(): 返回集合中元素的个数。</span><br><span class="line">    <span class="built_in">empty</span>(): 检查集合是否为空。</span><br><span class="line"></span><br><span class="line">其他操作：</span><br><span class="line">    <span class="built_in">bucket_count</span>(): 返回集合中桶的数量。</span><br><span class="line">    <span class="built_in">load_factor</span>(): 返回集合的负载因子。</span><br><span class="line">    <span class="built_in">max_load_factor</span>(): 设置或返回集合的最大负载因子。</span><br></pre></td></tr></table></figure>

<p>（3）<code>std::set</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">插入元素：</span><br><span class="line">    <span class="built_in">insert</span>(): 向集合中插入元素。</span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">    <span class="built_in">erase</span>(): 删除集合中的元素。</span><br><span class="line">    <span class="built_in">clear</span>(): 清空集合中的所有元素。</span><br><span class="line"></span><br><span class="line">查找元素：</span><br><span class="line">    <span class="built_in">find</span>(): 查找集合中是否存在指定元素。</span><br><span class="line">    <span class="built_in">count</span>(): 统计集合中指定元素的个数。</span><br><span class="line"></span><br><span class="line">迭代器：</span><br><span class="line">    <span class="built_in">begin</span>(): 返回指向集合起始元素的迭代器。</span><br><span class="line">    <span class="built_in">end</span>(): 返回指向集合末尾元素的迭代器。</span><br><span class="line"></span><br><span class="line">大小和容量：</span><br><span class="line">    <span class="built_in">size</span>(): 返回集合中元素的个数。</span><br><span class="line">    <span class="built_in">empty</span>(): 检查集合是否为空。</span><br><span class="line"></span><br><span class="line">其他操作：</span><br><span class="line">    <span class="built_in">lower_bound</span>(): 返回指向大于或等于给定值的第一个元素的迭代器。</span><br><span class="line">    <span class="built_in">upper_bound</span>(): 返回指向大于给定值的第一个元素的迭代器。</span><br><span class="line">    <span class="built_in">equal_range</span>(): 返回集合中与给定值相等的元素范围。</span><br></pre></td></tr></table></figure>

<p>（3）<code>std::map</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">相关操作：</span><br><span class="line">    <span class="built_in">insert</span>()：用于将元素插入到map中。</span><br><span class="line">    <span class="built_in">erase</span>()：用于从map中删除指定的元素。</span><br><span class="line">    <span class="built_in">find</span>()：用于查找指定键对应的元素。</span><br><span class="line">    <span class="built_in">size</span>()：返回map中元素的数量。</span><br><span class="line">    <span class="built_in">clear</span>()：清空map中的所有元素。</span><br><span class="line">    <span class="built_in">begin</span>()：返回指向map起始元素的迭代器。</span><br><span class="line">    <span class="built_in">end</span>()：返回指向map末尾元素的迭代器。</span><br><span class="line">    <span class="built_in">count</span>()：返回指定键在map中出现的次数。</span><br></pre></td></tr></table></figure>

<h2 id="2、数组、set和map该如何选择？"><a href="#2、数组、set和map该如何选择？" class="headerlink" title="2、数组、set和map该如何选择？"></a>2、数组、set和map该如何选择？</h2><h3 id="什么时候选择用哈希表？"><a href="#什么时候选择用哈希表？" class="headerlink" title="什么时候选择用哈希表？"></a>什么时候选择用哈希表？</h3><p>当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候。</p>
<h3 id="什么时候选择用数组？"><a href="#什么时候选择用数组？" class="headerlink" title="什么时候选择用数组？"></a>什么时候选择用数组？</h3><p>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</p>
<p>如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费，此时不应使用数组。</p>
<h3 id="什么时候选择用set？"><a href="#什么时候选择用set？" class="headerlink" title="什么时候选择用set？"></a>什么时候选择用set？</h3><h3 id="什么时候选择用map？"><a href="#什么时候选择用map？" class="headerlink" title="什么时候选择用map？"></a>什么时候选择用map？</h3><h2 id="3、采用数组作为哈希函数"><a href="#3、采用数组作为哈希函数" class="headerlink" title="3、采用数组作为哈希函数"></a>3、采用数组作为哈希函数</h2><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></p>
<ul>
<li><p>解题思路</p>
<p>由于“字母异位词”的定义是：两个词中每个字符出现的数组相同，而本题假设词中仅包含小写字母。因此直观的想法就是定义一个数组，先遍历<code>s</code>，将每个字符在数组中对应的位置加1，再遍历<code>t</code>，将每个字符在数组中对应的位置减1，这样若最终数组为全0，则这两个词是字母异位词。</p>
<p>但我陷入的思维瓶颈在于，我想的是按照<code>s</code>中每个字符出现的顺序定义数组<code>a</code>，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s = &quot;anagram&quot;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">// 其中下标1代表字符a</span></span><br></pre></td></tr></table></figure>

<p>但这样实际上就相当于是一个<code>map</code>了，操作变得格外复杂。</p>
<p>实际上，由于小写字母是有顺序的26个，因此只需要定义一个<code>int a[26]</code>，对于<code>s</code>中遍历到的每个字符，通过<code>s[i] - &#39;a&#39;</code>就可以定位到对应的下标。</p>
</li>
<li><p>易混知识点：</p>
<ol>
<li><p><code>a - &#39;a&#39;</code>:</p>
<ul>
<li><strong>用于将字母字符转换成一个从0开始的索引</strong>（例如，’a’变成0, ‘b’变成1, 等等）。</li>
</ul>
<ul>
<li>这里 <code>&#39;a&#39;</code> 是一个字符，其ASCII值是 97。</li>
<li>所以 <code>a - &#39;a&#39;</code> 实际上是计算 <code>97 - 97</code>，结果是 0。</li>
</ul>
</li>
<li><p><code>&#39;1&#39; - &#39;0&#39;</code> </p>
<ul>
<li><strong>计算两个字符的ASCII值之差，用于将字符表示的数字转换成其对应的整数值。</strong></li>
</ul>
<ul>
<li><code>&#39;1&#39;</code> 的 ASCII 值是 49，<code>&#39;0&#39;</code>是 48。所以，<code>&#39;1&#39;-&#39;0&#39;</code> 的计算过程是 <code>49-48</code>，结果是 1。</li>
</ul>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;t.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            record[t[j] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m=<span class="number">0</span>; m&lt;<span class="number">26</span>; ++m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[m] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></p>
<ul>
<li><p>解题思路</p>
<p>和242完全一致。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131611.png" alt="image-20240420113156470"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;magazine.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            record[magazine[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ransomNote.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            record[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m=<span class="number">0</span>; m&lt;<span class="number">26</span>; ++m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[m] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、采用set解题"><a href="#4、采用set解题" class="headerlink" title="4、采用set解题"></a>4、采用set解题</h2><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></p>
<ul>
<li><p>解题思路</p>
<p>由于本题的哈希值较少、较分散且跨度非常大，因此不能采用数组来实现。由于最终的结果无需排序，无重复，且只需要返回元素本身，不需要返回对应的下标，因此采用set即可。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131372.png" alt="image-20240420113120142"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; nums_set;</span><br><span class="line">        nums_set.<span class="built_in">insert</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> nums : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums_set.<span class="built_in">find</span>(nums) != nums_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></p>
<ul>
<li><p>解题思路</p>
<p>可以发现</p>
<ul>
<li>1）哈希值较分散，且跨度较大（不采用数组，应采用set或map）；</li>
<li>2）不需要同时保存元素和下标等成对出现，有对应关系的元素（不采用map）；</li>
<li>3）就是要找是否有重复的元素出现，因此采用set实现。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131501.png" alt="image-20240420113130345"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            sum += (n%<span class="number">10</span>) * (n%<span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; compare_set = &#123;n&#125;;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">        <span class="keyword">while</span> (sum != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compare_set.<span class="built_in">find</span>(sum) != compare_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// sum = getSum(sum);</span></span><br><span class="line">                compare_set.<span class="built_in">insert</span>(sum);</span><br><span class="line">                sum = <span class="built_in">getSum</span>(sum);  <span class="comment">// 这里一定要先把上一步计算得到的sum加入compare_set后，再计算新的sum</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、采用map解题"><a href="#5、采用map解题" class="headerlink" title="5、采用map解题"></a>5、采用map解题</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p>
<ul>
<li><p>解题思路</p>
<p>本题不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，<strong>需要使用key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p>
<p><strong>这道题目中并不需要key有序，选择std::unordered_map 效率更高</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131120.png" alt="image-20240420113138973"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; compare_map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = compare_map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (iter != compare_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second, i&#125;;           </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// compare_map.insert(nums[i], i);</span></span><br><span class="line">                compare_map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(nums[i], i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454. 四数相加II"></a>454. 四数相加II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加II</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404201131021.png" alt="image-20240420113148798"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; res1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num1 : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num2 : nums2) &#123;</span><br><span class="line">                <span class="type">int</span> sum = num1 + num2;</span><br><span class="line">                res1[sum]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num3 : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num4 : nums4) &#123;</span><br><span class="line">                <span class="type">int</span> sum = num3 + num4;</span><br><span class="line">                cnt += res1[-sum];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h1><h2 id="1、反转字符串"><a href="#1、反转字符串" class="headerlink" title="1、反转字符串"></a>1、反转字符串</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h3><ul>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> il = s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">auto</span> ir = s.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (il &lt;= ir) &#123;</span><br><span class="line">            <span class="comment">// char tmp;</span></span><br><span class="line">            <span class="comment">// tmp = *il;</span></span><br><span class="line">            <span class="comment">// *il = *ir;</span></span><br><span class="line">            <span class="comment">// *ir = tmp;</span></span><br><span class="line">            <span class="built_in">swap</span>(*il, *ir)</span><br><span class="line">            il++;</span><br><span class="line">            ir--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404222114861.png" alt="image-20240422211359195"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i+=<span class="number">2</span>*k) &#123;</span><br><span class="line">            <span class="type">int</span> start = i;</span><br><span class="line">            <span class="type">int</span> end = std::<span class="built_in">min</span>(start+k, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>()));</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+start, s.<span class="built_in">begin</span>()+end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a>151. 反转字符串中的单词</h3><ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404222114609.png" alt="image-20240422211419481"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string &amp;s, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=begin, j=end; i&lt;=j; ++i, --j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeSpace</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slow) &#123;</span><br><span class="line">                    s[slow++] = <span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">                    <span class="comment">// 当slow不在开头时，如果此时遇到了s[i]不为空格，则说明接下来需要从slow开始写新的单词了</span></span><br><span class="line">                    <span class="comment">// 因此手动控制添加一个空格</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow);  <span class="comment">// important</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeSpace</span>(s);</span><br><span class="line">        <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// for (int i=0; i&lt;s.size(); ++i) &#123;</span></span><br><span class="line">            <span class="comment">// if (s[i] == &#x27; &#x27;) &#123;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() || s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s, start, i<span class="number">-1</span>);  <span class="comment">// 翻转当前单词</span></span><br><span class="line">                <span class="comment">// start = i;</span></span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2、KMP算法"><a href="#2、KMP算法" class="headerlink" title="2、KMP算法"></a>2、KMP算法</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242023050.png" alt="image-20240424202306816"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> *next, <span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// i -&gt; 待匹配的后缀的末尾</span></span><br><span class="line">   <span class="comment">// j -&gt; 待匹配的前缀的末尾</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1. 初始化</span></span><br><span class="line">   <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">   next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">       <span class="comment">// 2. 处理前后缀不相同的情况</span></span><br><span class="line">       <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">           j = next[j<span class="number">-1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 3. 处理前后缀不相同的情况</span></span><br><span class="line">       <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">           j++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4. 更新next数组</span></span><br><span class="line">       next[i] = j;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 实现 strStr()</a></p>
<ul>
<li><p>解题思路</p>
<ol>
<li>求解字符串<code>s</code>的<code>next</code>数组；</li>
<li>定义<code>i</code>和<code>j</code>分别用来遍历<code>haystack</code>和<code>needle</code>，根据<code>next</code>数组调整对比的位置；</li>
<li>当<code>j</code>等于<code>needle</code>字符串的长度时，说明此时在<code>haystack</code>中找到了对应的匹配子串，因此返回该子串的开始下标。</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line">        <span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;haystack.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> (i-needle.<span class="built_in">size</span>()+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a>459. 重复的子字符串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242023207.png" alt="image-20240424202348060"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> *next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; s[i]!=s[j]) &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(s.size())</span></span>;</span><br><span class="line">        <span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], s);</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(next[len<span class="number">-1</span>]!=<span class="number">0</span> &amp;&amp; (len%(len-next[len<span class="number">-1</span>])==<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="五、栈和队列"><a href="#五、栈和队列" class="headerlink" title="五、栈和队列"></a>五、栈和队列</h1><h2 id="1、栈和队列的理论基础"><a href="#1、栈和队列的理论基础" class="headerlink" title="1、栈和队列的理论基础"></a>1、栈和队列的理论基础</h2><ol>
<li><p>C++中stack 是容器么？</p>
<p>STL中stack往往不被归类为容器，而被归类为容器适配器（container adapter）。因为<strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p>
</li>
<li><p>我们使用的stack是属于哪个版本的STL？</p>
<p>SGI STL。</p>
</li>
<li><p>我们使用的STL中stack是如何实现的？</p>
<p>栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。<strong>常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。</strong></p>
<p>此外，<strong>SGI STL中队列一样是以deque为缺省情况下的底部结构。</strong></p>
<p>可以指定vector为栈的底层实现，初始化语句如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br></pre></td></tr></table></figure>

<p>也可以指定list 为起底层实现，初始化queue的语句如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404242029774.png" alt="栈与队列理论3" style="zoom:50%;" />
</li>
<li><p>stack 提供迭代器来遍历stack空间么？</p>
<p>不提供。</p>
</li>
</ol>
<blockquote>
<p>三个最为普遍的STL版本：</p>
<ol>
<li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li>
<li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li>
<li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li>
</ol>
</blockquote>
<h2 id="2-栈的基本操作"><a href="#2-栈的基本操作" class="headerlink" title="2. 栈的基本操作"></a>2. 栈的基本操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">empty</span>();		<span class="comment">// 栈为空时返回1，非空返回0</span></span><br><span class="line">st.<span class="built_in">size</span>();		<span class="comment">// 返回栈中元素数量，size_type size() const;</span></span><br><span class="line">st.<span class="built_in">top</span>();		<span class="comment">// 返回栈顶元素，value_type&amp; top();</span></span><br><span class="line">st.<span class="built_in">push</span>(value);	<span class="comment">// 在栈顶插入一个元素，void push( const value_tyoe&amp; val );</span></span><br><span class="line">st.<span class="built_in">emplace</span>(value);	<span class="comment">// 在栈顶增加一个元素，void emplace( args&amp;&amp; args );</span></span><br><span class="line">st.<span class="built_in">pop</span>();			<span class="comment">// 栈顶元素出栈，即删除栈顶元素，void pop(); </span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st2;</span><br><span class="line">st1.<span class="built_in">swap</span>( st2 );	<span class="comment">// 交换两个栈中的内容，void swap( stack&amp; x );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与vector一样，重载了运算符：== != &lt; &lt;= &gt; &gt;=</span></span><br></pre></td></tr></table></figure>

<h2 id="3、队列的基本操作"><a href="#3、队列的基本操作" class="headerlink" title="3、队列的基本操作"></a>3、队列的基本操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">queue&lt;<span class="type">double</span>&gt; d;</span><br><span class="line">queue&lt;node&gt; n;  <span class="comment">// node是一个结构体</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">size</span>();	<span class="comment">// 返回q里元素个数</span></span><br><span class="line">q.<span class="built_in">empty</span>();	<span class="comment">// 返回q是否为空，空则返回1，否则返回0</span></span><br><span class="line">q.<span class="built_in">push</span>(k);	<span class="comment">// 在q的末尾插入k</span></span><br><span class="line">q.<span class="built_in">pop</span>();	<span class="comment">// 删掉q的第一个元素</span></span><br><span class="line">q.<span class="built_in">front</span>();	<span class="comment">// 返回q的第一个元素</span></span><br><span class="line">q.<span class="built_in">back</span>();	<span class="comment">// 返回q的末尾元素</span></span><br></pre></td></tr></table></figure>

<h2 id="4、对称匹配问题"><a href="#4、对称匹配问题" class="headerlink" title="4、对称匹配问题"></a>4、对称匹配问题</h2><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404252121420.png" alt="image-20240425212136199"></p>
<p>这里有两个要注意的地方：</p>
<ol>
<li><p>在遍历到左括号时，可以直接向栈中放入对应的右括号，这样遍历到右括号时可以直接比较是否相等；</p>
</li>
<li><p>注意在遍历到右括号时需要先判断此时栈是否为空。</p>
<p>对于<code>s = &quot;)&#123;&quot;</code>的情况，由于遍历到左括号时才会入栈，遍历到右括号时只执行比较操作，因此此时<code>st</code>为空，若直接执行<code>st.top()</code>会造成错误！</p>
</li>
</ol>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">&#x27;)&#x27;</span> || i == <span class="string">&#x27;]&#x27;</span> || i == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == i) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404252121802.png" alt="image-20240425212128346"></p>
<p>注意输出的时候要进行一个reverse操作，因为栈是先进先出，和需要的结果次序是相反的。</p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == i) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res += st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261554153.png" alt="image-20240426155453665"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isDigit</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> token : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isDigit</span>(token)) &#123;</span><br><span class="line">                    <span class="comment">// 操作符</span></span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> tmp1 = res.<span class="built_in">top</span>();</span><br><span class="line">                    res.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> tmp2 = res.<span class="built_in">top</span>();</span><br><span class="line">                    res.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 + tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 - tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 * tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                        tmp = tmp2 / tmp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res.<span class="built_in">push</span>(tmp);   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push</span>(<span class="built_in">stoi</span>(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、队列解决相关问题"><a href="#5、队列解决相关问题" class="headerlink" title="5、队列解决相关问题"></a>5、队列解决相关问题</h2><blockquote>
<p>可用于以下题目：</p>
<ol>
<li>单调队列解决“<strong>区间内的最大值</strong>”问题；</li>
<li>优先级队列解决“<strong>统计元素出现频率</strong>”问题</li>
</ol>
</blockquote>
<h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261557720.png" alt="image-20240426155748508"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            <span class="comment">// 如果val == que.front()</span></span><br><span class="line">            <span class="comment">// 说明队列要pop()的元素为此时滑动窗口的最大值，需要执行实际的pop()操作</span></span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          que.<span class="built_in">push_back</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getMaxValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">      MyQueue que;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">      <span class="comment">// 先将前k个元素放进单调队列</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; ++i) &#123;</span><br><span class="line">        que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// res先记录这前k个元素的最大值</span></span><br><span class="line">      res.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=k; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        que.<span class="built_in">pop</span>(nums[i-k]);</span><br><span class="line">        que.<span class="built_in">push</span>((nums[i]));</span><br><span class="line">        res.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">347.前 K 个高频元素</a></p>
<ul>
<li><p>解题思路</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404261557691.png" alt="image-20240426155759481"></p>
</li>
<li><p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// step1</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            map[num]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step2</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pri_que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it=map.<span class="built_in">begin</span>(); it!=map.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            pri_que.<span class="built_in">push</span>(*it);</span><br><span class="line">            <span class="comment">// step3</span></span><br><span class="line">            <span class="keyword">if</span> (pri_que.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                pri_que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step4</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=k<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">            res[i] = pri_que.<span class="built_in">top</span>().first;</span><br><span class="line">            pri_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/08/Computer/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/08/Computer/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-08 23:57:17" itemprop="dateCreated datePublished" datetime="2024-04-08T23:57:17+08:00">2024-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-17 10:36:11" itemprop="dateModified" datetime="2024-04-17T10:36:11+08:00">2024-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、因特网概述"><a href="#1、因特网概述" class="headerlink" title="1、因特网概述"></a>1、因特网概述</h2><p><strong>internet与Internet的区别</strong></p>
<ul>
<li><p><strong>internet(互联网或互连网)<strong>是一个通用名词，它泛指</strong>多个计算机网络互连而成的网络</strong>。在这些网络之间的通信协议可以是任意的。</p>
</li>
<li><p><strong>Internet（因特网）则是一个专用名词</strong>，它指<strong>当前全球最大的、开放的、由众多网络互连而成的特定计算机网络</strong>，它采用TCP&#x2F;IP协议族作为通信的规则，其前身是美国的ARPANET。</p>
</li>
</ul>
<p>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是互联网(Internet)。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121642022.webp" alt="img"></p>
<blockquote>
<p>普通用户是如何接入到因特网的呢？</p>
<p>答：<strong>通过ISP接入因特网</strong></p>
<p>ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从<strong>ISP的得到所需要的IP地址</strong>。</p>
<p><strong>因为因特网上的主机都必须有IP地址才能进行通信，这样就可以通过该ISP接入到因特网</strong></p>
</blockquote>
<h2 id="2、计算机网络体系结构"><a href="#2、计算机网络体系结构" class="headerlink" title="2、计算机网络体系结构"></a>2、计算机网络体系结构</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121644183.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121645050.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121645246.webp" alt="img"></p>
<h1 id="二、网络层"><a href="#二、网络层" class="headerlink" title="二、网络层"></a>二、网络层</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646323.png" alt="image-20240412164600035"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646120.png" alt="image-20240412164607943"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121646736.png" alt="image-20240412164616479"></p>
<h1 id="三、运输层"><a href="#三、运输层" class="headerlink" title="三、运输层"></a>三、运输层</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-d9a70806edc95dc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的。</strong></p>
<h2 id="2、运输层端口号、复用与分用的概念"><a href="#2、运输层端口号、复用与分用的概念" class="headerlink" title="2、运输层端口号、复用与分用的概念"></a>2、运输层端口号、复用与分用的概念</h2><h3 id="（1）为什么用端口号"><a href="#（1）为什么用端口号" class="headerlink" title="（1）为什么用端口号"></a>（1）为什么用端口号</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-de597eda77aa6acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（2）发送方的复用和接收方的分用"><a href="#（2）发送方的复用和接收方的分用" class="headerlink" title="（2）发送方的复用和接收方的分用"></a>（2）发送方的复用和接收方的分用</h3><ul>
<li><p><strong>多个进程</strong>利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据——<strong>复用</strong></p>
</li>
<li><p><strong>多个进程</strong>利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>数据—— <strong>分用</strong></p>
</li>
<li><p>这里一个端口表示一个进程</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2a4ec3f5d5c11433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（3）常用端口号"><a href="#（3）常用端口号" class="headerlink" title="（3）常用端口号"></a>（3）常用端口号</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2117fa99a7f2a89c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="3、TCP和UDP的对比"><a href="#3、TCP和UDP的对比" class="headerlink" title="3、TCP和UDP的对比"></a>3、TCP和UDP的对比</h2><h3 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h3><ul>
<li><p>TCP</p>
<ol>
<li>面向连接，需要在两个套接字之间建立连接，提供可靠服务；</li>
<li>传送TCP报文；</li>
<li>支持点对点单播，不支持多播、广播；</li>
<li>应用场景如万维网、电子邮件、文件传送等。</li>
</ol>
</li>
<li><p>UDP</p>
<ol>
<li><p>无连接，不需要套接字，不提供可靠交付；</p>
</li>
<li><p>传送UDP报文或用户数据报；</p>
</li>
<li><p>支持单播、多播和广播；</p>
</li>
<li><p>应用场景如多媒体应用等。</p>
<img src="https:////upload-images.jianshu.io/upload_images/24878825-624005a24bc5bfcd.png?imageMogr2/auto-orient/strip|imageView2/2/w/871/format/webp" alt="img" style="zoom: 50%;" /></li>
</ol>
</li>
</ul>
<h3 id="（2）TCP"><a href="#（2）TCP" class="headerlink" title="（2）TCP"></a>（2）TCP</h3><p>TCP（Transmission Control Protocol）</p>
<p>发送方</p>
<ul>
<li><p>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，但不知道这些待传送的字节流的含义</p>
</li>
<li><p>将他们编号，并存储在自己发送缓存中</p>
</li>
<li><p>根据发送策略，提取一定量的字节构建TCP报文并发送</p>
</li>
</ul>
<p>接收方</p>
<ul>
<li><p>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</p>
</li>
<li><p>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</p>
</li>
<li><p>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</p>
</li>
</ul>
<p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础。在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收。</p>
<img src="https:////upload-images.jianshu.io/upload_images/24878825-db48b70af7fb7884.png?imageMogr2/auto-orient/strip|imageView2/2/w/897/format/webp" alt="img" style="zoom:50%;" />

<h2 id="4、TCP的流量控制"><a href="#4、TCP的流量控制" class="headerlink" title="4、TCP的流量控制"></a>4、TCP的流量控制</h2><p>流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p>
<ul>
<li>当主机A收到主机B对相关字节数据的<strong>累计确认</strong>时，可以将其在发送缓存中删除。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f73e94f75e94ea4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5bd53b8a5a5ac400.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ea9dc3589e6c6bd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面。因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传。</p>
</blockquote>
<h2 id="5、TCP的拥塞控制"><a href="#5、TCP的拥塞控制" class="headerlink" title="5、TCP的拥塞控制"></a>5、TCP的拥塞控制</h2><p>在某段时间中，若对网络中某一资源（如链路容量&#x2F;带宽、缓存和处理机等）的需求超过了该资源所能提供的可用部分，就称发生了<strong>拥塞</strong>。</p>
<p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p>
<ol>
<li>点缓存的容量太小；</li>
<li>链路的容量不足；</li>
<li>处理机处理的速率太慢；</li>
<li>拥塞本身会进一步加剧拥塞；</li>
</ol>
<blockquote>
<p>相关算法</p>
<ul>
<li><strong>慢开始（slow-start）</strong></li>
<li><strong>拥塞避免（congestion avoidance）</strong></li>
<li><strong>快重传（fast transmit）</strong></li>
<li><strong>快恢复（fast recovery）</strong></li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c7682fe29ebcb6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>真正的发送窗口值 &#x3D; Min (接收方窗口值，拥塞窗口值)</p>
</blockquote>
<h3 id="（1）慢开始和拥塞避免"><a href="#（1）慢开始和拥塞避免" class="headerlink" title="（1）慢开始和拥塞避免"></a>（1）慢开始和拥塞避免</h3><h4 id="A-慢开始"><a href="#A-慢开始" class="headerlink" title="A. 慢开始"></a>A. 慢开始</h4><ul>
<li>目的：用来确定网络的负载能力或拥塞程度。</li>
<li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li>
<li>两个变量：<ul>
<li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。<ul>
<li>1 至 2 个最大报文段 （旧标准）</li>
<li>2 至 4 个最大报文段 （RFC 5681）</li>
</ul>
</li>
<li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-47dba7f2068f35df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1bca665e8eaa965a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/713/format/webp" alt="img"></p>
<blockquote>
<p>图中swnd是发送窗口</p>
<p>每经过一个传输轮次，拥塞窗口就加倍</p>
<p>窗口大小按<strong>指数增加</strong>，2的n-1次方</p>
</blockquote>
<h4 id="B-拥塞避免"><a href="#B-拥塞避免" class="headerlink" title="B. 拥塞避免"></a>B. 拥塞避免</h4><ul>
<li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。</li>
<li>每经过一个传输轮次，拥塞窗口 <strong>cwnd &#x3D; cwnd + 1</strong>。</li>
<li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li>
<li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。<img src="https://upload-images.jianshu.io/upload_images/24878825-f5db7ea25d8aca73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></li>
</ul>
<h3 id="（2）快重传和快恢复"><a href="#（2）快重传和快恢复" class="headerlink" title="（2）快重传和快恢复"></a>（2）快重传和快恢复</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-fee86fb3707a175c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="A-快重传"><a href="#A-快重传" class="headerlink" title="A. 快重传"></a>A. 快重传</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a57c7cc819aa4bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="B-快恢复"><a href="#B-快恢复" class="headerlink" title="B. 快恢复"></a>B. 快恢复</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-ab5a63efbd586eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="C-改进后的整体示意图"><a href="#C-改进后的整体示意图" class="headerlink" title="C. 改进后的整体示意图"></a>C. 改进后的整体示意图</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-8f61b8eddb5b2624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="6、TCP超时重传"><a href="#6、TCP超时重传" class="headerlink" title="6、TCP超时重传"></a>6、TCP超时重传</h2><blockquote>
<p>往返时间：<strong>RTT0</strong></p>
<p>超时重传时间：<strong>RTO</strong></p>
</blockquote>
<p>如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大；如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率。因此需要合理选择RTO的值。</p>
<ul>
<li>不能直接使用某次测量得到的RTT样本来计算超时重传时间RTO。应该利用每次测量得到的RTT样本，计算加权平均往返时间<strong>RTTs</strong>（又称为平滑的往返时间）</li>
</ul>
<p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107689.webp" alt="img"></p>
<p><strong>往返时间RTT的测量比较复杂</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107552.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107260.webp" alt="img"></p>
<p><strong>TCP超时重传的计算</strong></p>
<p>举例</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404122107514.webp" alt="img"></p>
<h2 id="7、TCP可靠传输的实现"><a href="#7、TCP可靠传输的实现" class="headerlink" title="7、TCP可靠传输的实现"></a>7、TCP可靠传输的实现</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-6d10ea76a1ea032b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-92d975bc880db892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-35bff0a8cc5b0d71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="8、三次握手"><a href="#8、三次握手" class="headerlink" title="8、三次握手"></a>8、三次握手</h2><h3 id="（1）三次握手详解"><a href="#（1）三次握手详解" class="headerlink" title="（1）三次握手详解"></a>（1）三次握手详解</h3><ul>
<li>采用<strong>三次握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li>
</ul>
<ul>
<li><p>TCP的连接建立要解决以下三个问题</p>
<ul>
<li>使得双方能够确知对方的存在；</li>
<li>使得双方能够协商一些参数（如最大窗口值、是否使用时间戳选项和服务质量等）；</li>
<li>使得双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li>
</ul>
</li>
<li><p><strong>具体过程</strong></p>
<ol>
<li><p><strong>TCP服务器进程创建传输控制块，用来存储TCP连接中的一些重要信息，并进入监听状态，等待TCP客户端进程的连接请求</strong></p>
</li>
<li><p><strong>TCP客户进程也是首先创建传输控制块</strong></p>
</li>
<li><p><strong>TCP客户进程向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态。</strong></p>
<ol>
<li>其中， TCP连接请求报文段首部中的同步位syn被设置为1，表明这是一个TCP连接请求报文段；</li>
<li>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号；</li>
<li>注意<em>该报文段不能携带数据</em>，但要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态。</strong></p>
<ol>
<li>同步位SYN和确认位ACK都设置为1，表明这是一个TCP连接请求确认报文段；</li>
<li>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号；</li>
<li>确认位ACK的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认；</li>
<li>注意<em>该报文段也不能携带数据</em>，且同样要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态。</strong></p>
<ol>
<li>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1；</li>
<li>确认位ACK被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认；</li>
<li>注意<em>普通的TCP确认报文段可以携带数据</em>，但如果不携带数据，则不消耗序号。</li>
</ol>
</li>
<li><p><strong>TCP服务器进程收到该确认报文段后也进入连接已建立状态。</strong></p>
</li>
</ol>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-987d5c8512392422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="（2）为什么不能“两次握手”？"><a href="#（2）为什么不能“两次握手”？" class="headerlink" title="（2）为什么不能“两次握手”？"></a>（2）为什么不能“两次握手”？</h3><blockquote>
<p>不采用两次握手主要是为了<strong>防止已经失效的连接请求报文段突然又传到服务端</strong>，因而产生错误。</p>
<p>这种情况是：<strong>客户端发出的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到下一个连接释放以后的某个时间才到达服务器端。</strong>当服务器端收到此失效报文后，会误认为是客户端发出的一个新连接请求，于是客户端又发出确认报文，表示同意建立连接。</p>
<p>如果不采用“三次握手”，那么只要服务器端发出确认报文就会认为新的连接已经建立了，但此时客户端并没有发出建立连接的请求，因此不会向服务器端发送数据。服务器端没有收到数据就会一直等待，这样就会白白浪费掉很多资源。</p>
<p>所以必须采用“三次握手”而非“两次握手”。</p>
</blockquote>
<p>下图是“两次握手”的示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0a5773a600817c41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="9、四次挥手"><a href="#9、四次挥手" class="headerlink" title="9、四次挥手"></a>9、四次挥手</h2><h3 id="（1）四次挥手详解"><a href="#（1）四次挥手详解" class="headerlink" title="（1）四次挥手详解"></a>（1）四次挥手详解</h3><ul>
<li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong>端，被动等待连接建立的应用进程叫做<strong>TCP服务器</strong>。<strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong>。</li>
</ul>
<ul>
<li><p>具体过程</p>
<ol>
<li><p><strong>当客户端和服务器端都处于连接已建立状态时，若要释放连接，客户进程会发送TCP连接释放报文段，并进入终止等待状态。</strong></p>
<ol>
<li>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；</li>
<li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1；</li>
<li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1；</li>
<li>注意FIN等于1的报文段即使不携带数据，也要消耗掉一个序号。</li>
</ol>
</li>
<li><p><strong>服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态。</strong></p>
<ol>
<li>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配；</li>
<li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认。</li>
</ol>
</li>
<li><p><strong>此时，从客户进程到服务器进程这个方向的连接就释放了，这时的TCP连接属于半关闭状态，也就是客户进程已经没有数据要发送了。但如果服务器进程还有数据要发送，客户进程仍要接收，也就是说从服务器进程到客户进程这个方向的连接并未关闭。</strong></p>
</li>
<li><p><strong>客户进程收到TCP确认报文段后就进入终止等待状态，等待服务器进程发出的TCP连接释放报文段。若服务器进程已经没有数据要发送了，服务器进程即释放连接。由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接。</strong></p>
</li>
<li><p><strong>服务器进程发送TCP连接释放报文段并进入最后确认状态。</strong></p>
<ol>
<li><p>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；</p>
</li>
<li><p>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送；</p>
</li>
<li><p>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认。</p>
</li>
</ol>
</li>
<li><p><strong>客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态。服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要经过2MSL后才能进入关闭状态。</strong></p>
<ol>
<li>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段；</li>
<li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号；</li>
<li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认。</li>
</ol>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1c5e0c6357d039ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
</li>
</ul>
<h3 id="（2）为什么不能“三次挥手”？"><a href="#（2）为什么不能“三次挥手”？" class="headerlink" title="（2）为什么不能“三次挥手”？"></a>（2）为什么不能“三次挥手”？</h3><p>TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p>
<blockquote>
<p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。</p>
<p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ef85470fe120f146.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="10、TCP保活计时器"><a href="#10、TCP保活计时器" class="headerlink" title="10、TCP保活计时器"></a>10、TCP保活计时器</h2><p>TCP双方已经建立连接时，TCP客户进程所在的主机突然出现了故障。此时服务器进程无法再收到客户进程发来的数据。因此，应当有措施使TCP服务器进程不要再白白等待下去。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2dc97e06fe1d82ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h1 id="四、应用层"><a href="#四、应用层" class="headerlink" title="四、应用层"></a>四、应用层</h1><h2 id="1、CS方式和P2P方式"><a href="#1、CS方式和P2P方式" class="headerlink" title="1、CS方式和P2P方式"></a>1、CS方式和P2P方式</h2><h3 id="（1）CS方式（客户-服务器方式）"><a href="#（1）CS方式（客户-服务器方式）" class="headerlink" title="（1）CS方式（客户&#x2F;服务器方式）"></a>（1）CS方式（客户&#x2F;服务器方式）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121850174.webp" alt="img"></p>
<h3 id="（2）P2P方式（对等方式）"><a href="#（2）P2P方式（对等方式）" class="headerlink" title="（2）P2P方式（对等方式）"></a>（2）P2P方式（对等方式）</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121850280.webp" alt="img"></p>
<h2 id="2、动态主机配置协议DHCP"><a href="#2、动态主机配置协议DHCP" class="headerlink" title="2、动态主机配置协议DHCP"></a>2、动态主机配置协议DHCP</h2><ul>
<li><p>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</p>
</li>
<li><p>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</p>
</li>
<li><p>DHCP的工作过程</p>
<ul>
<li><p><strong>DHCP 使用客户 - 服务器方式</strong></p>
<ul>
<li><p>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文  （DHCP DISCOVER），这时该主机就成为 DHCP 客户。</p>
</li>
<li><p>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</p>
</li>
<li><p>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</p>
</li>
</ul>
</li>
<li><p><strong>DHCP 工作方式</strong></p>
<ul>
<li><p>DHCP 使用客户-服务器方式，采用请求&#x2F;应答方式工作。</p>
</li>
<li><p>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121853443.webp" alt="img"></p>
<ul>
<li><p>DHCP中继代理</p>
<h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p>下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-33c64efac75f0ad2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p>
</blockquote>
</li>
<li><p>总结</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121854516.webp" alt="img"></p>
</li>
</ul>
<h2 id="3、域名系统DNS"><a href="#3、域名系统DNS" class="headerlink" title="3、域名系统DNS"></a>3、域名系统DNS</h2><h3 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855489.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855338.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121855952.webp" alt="img"></p>
<h3 id="（2）域名解析过程"><a href="#（2）域名解析过程" class="headerlink" title="（2）域名解析过程"></a>（2）域名解析过程</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856499.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856729.webp" alt="img"></p>
<h2 id="4、文件传送协议FTP"><a href="#4、文件传送协议FTP" class="headerlink" title="4、文件传送协议FTP"></a>4、文件传送协议FTP</h2><blockquote>
<p>注意两种模式都是（1）控制连接在整个会话期间保持打开状态；（2）数据连接传输完毕后就关闭。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121856907.webp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404121857685.webp" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/08/%E9%9D%A2%E8%AF%95/%E6%AF%95%E8%AE%BE%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/08/%E9%9D%A2%E8%AF%95/%E6%AF%95%E8%AE%BE%E9%A1%B9%E7%9B%AE/" class="post-title-link" itemprop="url">毕设项目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-08 00:57:15" itemprop="dateCreated datePublished" datetime="2024-04-08T00:57:15+08:00">2024-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-17 10:32:53" itemprop="dateModified" datetime="2024-04-17T10:32:53+08:00">2024-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h2 id="一、项目介绍"><a href="#一、项目介绍" class="headerlink" title="一、项目介绍"></a>一、项目介绍</h2><p>名称：<strong>多用户智能家居控制系统设计</strong>。</p>
<p><strong>设计了一个多用户智能家居控制系统。基于Qt平台开发Android客户端，同时基于MySQL数据库及多线程编程技术完成多用户操作，并利用MQTT通信协议实现了Android客户端与嵌入式控制终端之间的信息交互。、在此系统下Android 客户端的不同用户，可以通过Mosquitto云服务器转发的控制信息实现对iTop4412开发板的照明、警报及温度设备的实时控制。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404142132653.png" alt="image-20240414213213414"></p>
<p>1、 基于Linux多线程编程，结合MQTT协议的订阅-发布模式，完成多用户智能控制；</p>
<p>2、 在用户端设计双模式。共享模式：多个用户同时控制，且共享当前设备的状态；私人模式：被控制端的某一功能同一时间只能由一个用户控制；</p>
<p>3、 采用MQTT协议进行数据传送。通过实验对比HTTP协议和MQTT协议在智能家居领域的应用，结果表明MQTT在降低功耗和推送功能开发上优势明显，其即便是在资源有限的环境中也能易于使用。</p>
<p><strong>本项目的重点与核心在实现客户端的多用户控制。</strong></p>
<p>1、 针对发布者，利用Qt开发平台设计手机App作为客户端，它有两个特点，分别是多用户和双模式。多用户指不同的客户端均可进行控制操作；双模式指针对客户端本身，有共享模式和私人模式两种，在共享模式下可实现多个用户同时控制，且共享当前设备的状态；在私人模式下被控制端的某一功能同一时间只能由一个用户控制；</p>
<p>2、 针对消息代理者，选择在阿里云上部署mosquitto。选用MQTT协议的原因已在前述加以说明，而由于mosquitto是一种流行的mqtt服务器，且易于安装和配置，因此选用mosquitto进行部署；</p>
<p>3、 针对订阅者，主要以iTop4412开发板作为功能实现端。同时基于Linux多线程来配合实现多用户控制。</p>
<p><strong>本项目的数据转发过程如下。</strong></p>
<p>每个用户在该客户端程序中都对应操作两个线程：</p>
<p>（1）发送控制指令时的发布者身份，代表用户从Android客户端向嵌入式控制终端发送照明及警报的控制指令；<br>用户可自主规定订阅主题为“home&#x2F;*”格式。</p>
<p>（2）接收控制指令时的订阅者身份，代表开发板向用户发送温度数据；统一规定“temp”为传送温度数据的主题。</p>
<p><strong>发布者发出的控制指令将以json数据的格式被封装，经mosquitto云服务器转发后送至开发板侧，订阅者读取json包，解析出对应的命令行指令，对相应的硬件进行控制。</strong></p>
<h2 id="二、相关问题"><a href="#二、相关问题" class="headerlink" title="二、相关问题"></a>二、相关问题</h2><ol>
<li><p><strong>在项目中做了哪些工作，遇到了哪些困难，是怎么解决的？</strong></p>
<ul>
<li>工作：设计并实现了一个多用户智能家居控制系统，包括Android客户端、服务器软件和嵌入式控制终端。</li>
<li>困难：处理多用户操作的并发控制，确保数据一致性和系统稳定性。</li>
<li>解决方法：利用多线程编程技术和锁机制，以及基于MQTT的消息订阅和发布来处理并发控制问题。</li>
</ul>
</li>
<li><p><strong>整个项目包含哪几端之间的的通信？</strong></p>
<p>项目包含（1）Android客户端与服务器的通信；（2）服务器与嵌入式控制终端的通信；以及（3）客户端之间的间接通信（通过服务器转发）。</p>
</li>
<li><p><strong>客户端与客户端之间的通信是基于自己实现的协议吗？</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404142133602.png" alt="image-20240414213314541"></p>
</li>
<li><p><strong>是在客户端上面跑的MySQL吗？</strong></p>
<p>不是，MySQL数据库运行在服务器端，用于存储用户数据和状态信息，客户端通过网络与之通信。</p>
</li>
<li><p><strong>Qt可以直接打包安卓客户端吗？</strong>、</p>
<p>是的，Qt提供了支持Android的工具和库，可以直接将应用打包为Android客户端。</p>
</li>
<li><p><strong>Qt中做多线程的编程，有哪一些是线程同步的技术？</strong></p>
<p>Qt支持多种线程同步技术，包括互斥锁（QMutex）、读写锁（QReadWriteLock）、信号量（QSemaphore）、条件变量（QWaitCondition）等。</p>
</li>
<li><p><strong>为什么用多线程能解决冲突问题？</strong></p>
<p>程序通过 <code>pthread_create</code> 函数创建了两个线程，多线程主要用于处理订阅和发布MQTT消息的任务。</p>
<ol>
<li><code>sub_thread</code> 用于订阅 MQTT 消息并处理接收到的消息，涉及到订阅者之间的状态共享或者资源竞争，因此使用互斥锁来保护共享资源的访问，确保线程安全。</li>
<li><code>pub_thread</code> 用于发布 MQTT 消息。操作和<code>sub_thread</code>类似，但不需要对其进行加锁操作。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404142139031.png" alt="image-20240414213944988"></p>
</li>
<li><p><strong>锁是放在哪里的？</strong></p>
<p>互斥锁放在嵌入式控制终端中。</p>
</li>
<li><p><strong>比如说你有多个客户端，你怎么知道对面锁住了呢？</strong></p>
<p>客户端设计了共享模式和私人模式两种，当一个用户选择进入私人模式时，会通过Qt的信号与槽机制在客户端进行更新，告诉其他用户已经有用户进入了私人模式，本客户端无法再进入。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404142136791.png" alt="image-20240414213614733"></p>
</li>
<li><p><strong>在做技术选型的时候，什么时候选多线程，什么时候选多进程？</strong></p>
<ul>
<li><strong>选择多线程</strong>：当应用需要共享大量数据时，多线程是一种更合适的选择。多线程同一进程内的线程共享内存和资源，上下文切换成本较低，适用于对性能要求较高的场景，如实时计算、游戏开发等。</li>
<li><strong>选择多进程</strong>：多进程则适用于需要增强应用稳定性和安全性的场景，因为各进程间相互独立，一个进程的崩溃不会直接影响到其他进程。此外，多进程可以利用多核CPU的优势，实现真正的并行执行，适用于需要大量并行计算的应用，如视频处理、大规模数据分析等。</li>
</ul>
</li>
<li><p><strong>在Android客户端中，如何实现界面的实时更新和数据同步？</strong></p>
<ul>
<li>使用信号与槽机制： 在Qt中，通过信号与槽机制实现对象之间的通信。当数据发生变化时，可以通过信号发送变化的消息，然后在界面组件中连接相应的槽函数来更新界面。</li>
</ul>
</li>
<li><p><strong>如何通过mosquitto服务器将客户端的控制指令转发给iTop4412开发板？</strong></p>
<ul>
<li>在mosquitto服务器上配置相应的主题和订阅关系，客户端发布控制指令到对应的主题，mosquitto服务器将控制指令转发给iTop4412开发板的订阅者。</li>
</ul>
</li>
<li><p><strong>MQTT协议与HTTP协议相比，有何优势？为什么选择MQTT协议进行数据传送？</strong></p>
<ul>
<li>MQTT协议相比HTTP协议在降低功耗和推送功能开发上具有明显优势，适合于资源有限的环境和实时数据传输的场景。因此选择MQTT协议进行数据传送。</li>
</ul>
</li>
<li><p><strong>介绍一下阿里云上部署mosquitto的过程。</strong></p>
<ul>
<li><p>在阿里云上安装mosquitto，配置mosquitto的配置文件，设置端口号和用户名密码等参数，启动mosquitto服务，配置防火墙规则允许外部访问。</p>
</li>
<li><p>MQTT服务器的端口号通常是1883。</p>
</li>
</ul>
</li>
<li><p><strong>如何在iTop4412开发板上实现对控制指令的接收和执行？</strong></p>
<ul>
<li>通过Linux多线程编程，在iTop4412开发板上创建一个线程来监听MQTT服务器发送的控制指令，接收到指令后解析并执行对应的命令。</li>
</ul>
</li>
<li><p><strong>在Android客户端中，如何使用JSON格式封装控制指令？</strong></p>
<ul>
<li>使用 <code>cJSON_CreateObject()</code> 函数创建一个空的JSON对象。</li>
<li>使用 <code>cJSON_AddNumberToObject()</code> 函数向JSON对象中添加一个键值对，键为 “temp”，值为一个随机生成的温度值 <code>a</code>。</li>
<li>使用 <code>cJSON_Print()</code> 函数将JSON对象打印成JSON格式的字符串，并将其赋值给 <code>json_buf</code>。</li>
<li>使用 <code>mosquitto_publish()</code> 函数将JSON字符串发布到MQTT服务器上的主题为 “temp” 的通道中。</li>
</ul>
</li>
<li><p><strong>在iTop4412开发板上，如何解析JSON格式的控制指令并执行相应的功能操作？</strong></p>
<ul>
<li>使用第三方JSON库cJSON在Linux环境下解析JSON格式的控制指令，提取出对应的命令参数，然后调用相应的系统调用或执行命令行来控制硬件设备。</li>
</ul>
</li>
<li><p><strong>在多用户智能家居控制系统中，如何实现用户认证和权限管理？</strong></p>
<ul>
<li>在安卓客户端上实现用户登录和注册功能。将用户信息存储在MySQL数据库上，在登陆查询当前用户是否属于该数据库，以及用户名与密码是否匹配；若不存在，可进行注册操作。</li>
<li>由于本设计要访问特定公网的阿里云服务器上的数据库，因此在Qt开发平台上需要首先提供所需要的驱动插件之后，再利用QSqlDatabase来处理与数据库的连接，利用QSqlQuery类来执行底层数据库支持的任何SQL语句。</li>
</ul>
</li>
<li><p><strong>在iTop4412开发板上，如何实现硬件设备的驱动和控制？</strong></p>
<ul>
<li>通过 MQTT 实现硬件设备的驱动和控制：<ul>
<li>当用户在 UI 上进行操作时，比如点击 LED 开关按钮，UI 触发对应的槽函数，如 <code>on_ledBt_ON_1_clicked()</code>。</li>
<li>在槽函数中构造一个JSON 数据包，其中包含了需要控制的硬件设备信息，比如 LED 的状态。然后将这个 JSON 数据包发布到 MQTT 主题上，通过 MQTT 协议发送给 MQTT 服务器。</li>
<li>在硬件设备端，通过订阅相应的 MQTT 主题，监听来自 MQTT 服务器的消息。</li>
<li>当硬件设备端接收到相应的消息后，解析 JSON 数据包，获取到控制指令，并执行相应的操作，例如打开或关闭 LED。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>该项目还有哪些可以改进的地方？</strong></p>
<ul>
<li><p>可以在mosquitto服务器上配置TLS&#x2F;SSL加密通信，客户端和服务器之间通过证书验证进行安全连接，防止数据被窃取或篡改。确保安卓客户端与mosquitto服务器之间的通信安全性。</p>
</li>
<li><p>此外，对于多线程部分我觉得还可以再考虑细化锁的粒度，以及进行RAII技术管理互斥锁，避免在某些异常情况下未释放锁导致资源泄露问题。</p>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/07/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/" class="post-title-link" itemprop="url">面试八股</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 15:02:11" itemprop="dateCreated datePublished" datetime="2024-04-07T15:02:11+08:00">2024-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-26 10:43:55" itemprop="dateModified" datetime="2024-04-26T10:43:55+08:00">2024-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>35k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2:07</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="一、C-C"><a href="#一、C-C" class="headerlink" title="一、C&#x2F;C++"></a>一、C&#x2F;C++</h1><h2 id="1、C-C"><a href="#1、C-C" class="headerlink" title="1、C&#x2F;C++"></a>1、C&#x2F;C++</h2><h3 id="如何看待C-和C的关系？"><a href="#如何看待C-和C的关系？" class="headerlink" title="如何看待C++和C的关系？"></a>如何看待C++和C的关系？</h3><p>C++最初只是在C的基础上增加了面向对象的特性，后来随着C++的发展，其灵活性不断增加，现在C++已经成为了一个语言联邦，他包含了C语言，但也延伸出许多其他特性。<br>（1）面向对象：C++包含封装、继承、多态的特性；<br>（2）C++支持泛型编程；<br>（3）C++包含了STL部分。</p>
<h3 id="C和C-结构体的差别？"><a href="#C和C-结构体的差别？" class="headerlink" title="C和C++结构体的差别？"></a>C和C++结构体的差别？</h3><p>（1）默认访问修饰符</p>
<ul>
<li><strong>C中的结构体</strong>：C语言中结构体的成员默认都是公开（public）的。C主要用于数据存储，不支持封装和隐藏。</li>
<li><strong>C++中的结构体</strong>：在C++中，结构体的成员默认也是公开的。这与C++中的类不同，类的成员默认是私有（private）的。</li>
</ul>
<p>（2）函数成员</p>
<ul>
<li><strong>C中的结构体</strong>：不能包含函数。C的结构体仅用于数据的存储。</li>
<li><strong>C++中的结构体</strong>：可以包含函数，包括构造函数、析构函数、成员函数等。这使得C++的结构体能够支持类似类的行为，如构造和析构行为、方法调用等。</li>
</ul>
<p>（3）继承和多态</p>
<ul>
<li><strong>C中的结构体</strong>：不支持继承和多态。C是一种过程式语言，不具备面向对象语言的特性。</li>
<li><strong>C++中的结构体</strong>：支持继承和多态。在C++中，结构体可以继承其他的结构体或类，并且可以使用虚函数来实现多态。</li>
</ul>
<p>（4）访问修饰符</p>
<ul>
<li><strong>C中的结构体</strong>：没有访问修饰符的概念。</li>
<li><strong>C++中的结构体</strong>：可以使用<code>public</code>、<code>protected</code>和<code>private</code>等访问修饰符来控制成员的访问级别。</li>
</ul>
<p>（5）静态成员</p>
<ul>
<li><strong>C中的结构体</strong>：不支持静态成员。</li>
<li><strong>C++中的结构体</strong>：支持静态成员，这些成员属于类本身，而不是任何特定的实例。</li>
</ul>
<p>（6）模板</p>
<ul>
<li><strong>C中的结构体</strong>：不支持模板。</li>
<li><strong>C++中的结构体</strong>：可以是模板结构体，允许用户定义在编译时可以配置类型的结构体。</li>
</ul>
<h3 id="结构体和联合体"><a href="#结构体和联合体" class="headerlink" title="结构体和联合体"></a>结构体和联合体</h3><p>（1）结构体（Struct）</p>
<ol>
<li><strong>存储</strong>：结构体可以包含多个不同类型的数据成员，每个成员各自独立拥有内存空间。</li>
<li><strong>内存占用</strong>：结构体的总大小至少等于所有成员大小的总和（还需要考虑对齐）。</li>
<li><strong>用途</strong>：常用于存储具有逻辑关系但数据类型不同的数据集合。</li>
<li><strong>访问</strong>：每个成员都可以同时被独立访问，并且对一个成员的修改不会影响到其他成员。</li>
</ol>
<p>（2）联合体（Union）</p>
<ol>
<li><strong>存储</strong>：联合体的所有成员共享同一块内存区域。</li>
<li><strong>内存占用</strong>：联合体的大小等于其最大成员的大小。</li>
<li><strong>用途</strong>：常用于节省空间，或用于实现对同一内存区域的不同解释（例如，可以存储一个整数和一个浮点数，但只能使用其中一个值）。</li>
<li><strong>访问</strong>：对联合体中的一个成员赋值可能会影响到其他成员的值（因为内存共享）。</li>
</ol>
<h3 id="面向对象解决了什么问题？"><a href="#面向对象解决了什么问题？" class="headerlink" title="面向对象解决了什么问题？"></a>面向对象解决了什么问题？</h3><h3 id="C-11一些主要的新特性有哪些？"><a href="#C-11一些主要的新特性有哪些？" class="headerlink" title="C++11一些主要的新特性有哪些？"></a>C++11一些主要的新特性有哪些？</h3><ol>
<li>自动类型推导（auto）</li>
<li>基于范围的for循环（Range-based for loop）</li>
<li>智能指针（Smart Pointers）</li>
<li>Lambda表达式</li>
<li>nullptr关键字</li>
<li>右值引用和移动语义（Rvalue references and Move semantics）</li>
<li>常量表达式（constexpr）</li>
<li>多线程支持（Multithreading support）</li>
<li>枚举类（Enum classes）</li>
<li>删除和默认的函数（Deleted and defaulted functions）</li>
</ol>
<h2 id="2、智能指针相关"><a href="#2、智能指针相关" class="headerlink" title="2、智能指针相关"></a>2、智能指针相关</h2><h3 id="野指针是什么？"><a href="#野指针是什么？" class="headerlink" title="野指针是什么？"></a>野指针是什么？</h3><p>野指针是指向未知内存位置的指针。在编程中，特别是在使用C或C++这类允许直接内存操作的语言时，野指针问题是常见的错误来源之一。野指针的出现通常是由于以下几种情况：</p>
<ol>
<li><strong>未初始化的指针</strong>：声明指针变量但未给其赋予一个明确的初始地址。</li>
<li><strong>已释放的内存</strong>：指针指向的内存通过<code>free</code>或<code>delete</code>被释放，但指针没有被置为<code>NULL</code>，之后再次使用这个指针时，它指向的是已经回收的内存。</li>
<li><strong>越界的指针</strong>：指针超出了其原本指向的数据结构的边界。</li>
</ol>
<h3 id="讲一下什么是智能指针？"><a href="#讲一下什么是智能指针？" class="headerlink" title="讲一下什么是智能指针？"></a>讲一下什么是智能指针？</h3><p>智能指针是对裸指针的封装，其实质上是一个类，在离开类的作用范围后会自动调用析构函数释放资源，因此避免了程序员手动操作时忘记释放资源导致的内存泄漏问题。<br>智能指针包含4类：<br>（1）auto_ptr：在C++11中已经被废弃使用。它提供独占所有权，但没有复制语义，存在潜在的危险，例如当它被复制后原始指针可能被意外释放。<br>（2）unique_ptr：实现了对资源的独占访问，同一时刻只能有一个指针对资源进行访问。<br>（3）shared_ptr：当有多个对象需要共享资源时，则使用shared_ptr。其内部维护了一个引用计数器，当引用计数减少为0时调用delete释放资源。<br>当存在下列情况时会使得引用计数增加：1）新建一个shared_ptr指向对象；2）拷贝构造函数复制一个shared_ptr；3）复制操作将一个shared_ptr复制给另一个shared_ptr。<br>当存在下列操作时会使得引用计数减少：1）当一个shared_ptr被销毁时，如离开作用域，或调用了析构函数；2）当一个shared_ptr不再指向某个资源，如调用reset方法。<br>（4）weak_ptr：指向一个shared_ptr对象，并不会增加其引用计数，而只是提供一种访问方式。可以解决shared_ptr中存在的循环引用问题。</p>
<h3 id="weak-ptr如何获得shared-ptr？"><a href="#weak-ptr如何获得shared-ptr？" class="headerlink" title="weak_ptr如何获得shared_ptr？"></a>weak_ptr如何获得shared_ptr？</h3><p>使用 <code>std::weak_ptr</code> 的成员函数 <code>lock()</code>。这个函数尝试从 <code>std::weak_ptr</code> 创建一个 <code>std::shared_ptr</code> 实例。</p>
<h3 id="循环引用是如何发生的？如何解决？"><a href="#循环引用是如何发生的？如何解决？" class="headerlink" title="循环引用是如何发生的？如何解决？"></a>循环引用是如何发生的？如何解决？</h3><p>当多个shared_ptr对象互相引用，或是在某些比较复杂的数据结构中存在多条引用路径时，可能存在循环引用问题，导致资源无法被释放。此时就可以使用weak_ptr来打破循环，因为waek_ptr不会增加引用计数。</p>
<h3 id="shared-ptr是线程安全的吗？多线程使用时需要注意什么问题？"><a href="#shared-ptr是线程安全的吗？多线程使用时需要注意什么问题？" class="headerlink" title="shared_ptr是线程安全的吗？多线程使用时需要注意什么问题？"></a>shared_ptr是线程安全的吗？多线程使用时需要注意什么问题？</h3><p>shared_ptr并不是线程安全的，当多个线程同时访问或修改同一个shared_ptr对象时，可能会导致数据竞争或未定义的行为。但shared_ptr内部的计数器操作是线程安全的。</p>
<p>因此，在多线程使用时，需要避免多个线程同时访问一个shared_ptr对象或对其修改。</p>
<h3 id="引用计数的线程安全性怎么实现的？"><a href="#引用计数的线程安全性怎么实现的？" class="headerlink" title="引用计数的线程安全性怎么实现的？"></a>引用计数的线程安全性怎么实现的？</h3><p>为了保证引用计数在多线程中的线程安全，<code>shared_ptr</code> 通常采用原子操作来修改引用计数。原子操作是不可分割的，这意味着在任何时间点上，只有一个线程能够修改引用计数。这样可以避免在并发环境中发生竞争条件，确保引用计数的正确性不会因为多线程访问而被破坏。使用 <code>&lt;atomic&gt;</code> 库中提供的功能来实现引用计数的原子增加和减少。</p>
<h3 id="如果有一个场景需要用到线程安全的shared-ptr，一般你会怎么做？"><a href="#如果有一个场景需要用到线程安全的shared-ptr，一般你会怎么做？" class="headerlink" title="如果有一个场景需要用到线程安全的shared_ptr，一般你会怎么做？"></a>如果有一个场景需要用到线程安全的shared_ptr，一般你会怎么做？</h3><p>如果需要在多线程环境下使用线程安全的 shared_ptr，通常会使用 std::atomic 或者 std::mutex 来保护对 shared_ptr 的访问。</p>
<h3 id="make-shared和shared-ptr构造函数创建shared-ptr的区别？"><a href="#make-shared和shared-ptr构造函数创建shared-ptr的区别？" class="headerlink" title="make_shared和shared_ptr构造函数创建shared_ptr的区别？"></a>make_shared和shared_ptr构造函数创建shared_ptr的区别？</h3><p>make_shared 创建的对象和 shared_ptr 一起存储在同一块内存中，而使用构造函数创建的 shared_ptr 需要额外的内存用于存储引用计数。</p>
<h3 id="如果构造函数传入同一裸指针构造两个shared-ptr对象，会发生什么现象？"><a href="#如果构造函数传入同一裸指针构造两个shared-ptr对象，会发生什么现象？" class="headerlink" title="如果构造函数传入同一裸指针构造两个shared_ptr对象，会发生什么现象？"></a>如果构造函数传入同一裸指针构造两个shared_ptr对象，会发生什么现象？</h3><p>如果构造函数传入同一个裸指针构造两个 shared_ptr 对象，会导致两个 shared_ptr 对象都管理同一个对象，引用计数会变为 2。</p>
<h3 id="还是上面的问题，你觉得对于所谓的智能指针，为什么会出现这样的现象？"><a href="#还是上面的问题，你觉得对于所谓的智能指针，为什么会出现这样的现象？" class="headerlink" title="还是上面的问题，你觉得对于所谓的智能指针，为什么会出现这样的现象？"></a>还是上面的问题，你觉得对于所谓的智能指针，为什么会出现这样的现象？</h3><p>这种现象是因为 shared_ptr 的设计决定了它的共享性质，即多个 shared_ptr 可以管理同一个对象。</p>
<h3 id="很多人说到weak-ptr就会说是为了解决循环引用，你觉得这是关键的因素吗？"><a href="#很多人说到weak-ptr就会说是为了解决循环引用，你觉得这是关键的因素吗？" class="headerlink" title="很多人说到weak_ptr就会说是为了解决循环引用，你觉得这是关键的因素吗？"></a>很多人说到weak_ptr就会说是为了解决循环引用，你觉得这是关键的因素吗？</h3><p><code>std::weak_ptr</code> 的主要作用是提供一种非拥有性的智能指针，用于解决共享指针的循环引用问题，避免内存泄漏和资源泄露。它不会增加对象的引用计数，也不会影响对象的生命周期，因此适用于表示临时性的对象引用或者避免循环引用的情况。</p>
<p>除了解决循环引用之外，<code>std::weak_ptr</code> 还具有其他用途，例如：</p>
<ol>
<li><strong>观察者模式（Observer Pattern）：</strong> <code>std::weak_ptr</code> 可用于实现观察者模式，其中观察者持有被观察者对象的弱引用，以避免循环引用和对象生命周期管理的问题。</li>
<li><strong>缓存：</strong> 在缓存系统中，可以使用 <code>std::weak_ptr</code> 来保存对象的缓存项，以避免对对象的强引用导致缓存项无法被释放。</li>
<li><strong>延迟初始化：</strong> <code>std::weak_ptr</code> 可用于实现延迟初始化（Lazy Initialization），只有在需要时才创建对象，以提高性能和资源利用率。</li>
</ol>
<h3 id="如果传给shared-ptr一个引用，那么引用计数会不会加1？"><a href="#如果传给shared-ptr一个引用，那么引用计数会不会加1？" class="headerlink" title="如果传给shared_ptr一个引用，那么引用计数会不会加1？"></a>如果传给shared_ptr一个引用，那么引用计数会不会加1？</h3><p>（1）当一个裸指针（raw pointer）被传递给<code>std::shared_ptr</code>的构造函数时，<code>std::shared_ptr</code>会接管该裸指针的所有权，并初始化引用计数为1。</p>
<p>（2）当一个<code>std::shared_ptr</code>的引用被传递给另一个<code>std::shared_ptr</code>对象时（例如通过拷贝构造函数或拷贝赋值操作），新的<code>std::shared_ptr</code>对象会共享原有对象的所有权，并且引用计数会增加1。</p>
<p>（3）<code>std::shared_ptr</code>不能直接从非指针类型的引用构造。如果尝试从一个对象的引用或其他非指针类型的引用创建<code>std::shared_ptr</code>，需要先获取该对象的地址，然后传递给<code>std::shared_ptr</code>。这种情况下，会创建一个新的<code>std::shared_ptr</code>实例，引用计数从1开始。</p>
<h2 id="3、C-C-关键字"><a href="#3、C-C-关键字" class="headerlink" title="3、C&#x2F;C++关键字"></a>3、C&#x2F;C++关键字</h2><h3 id="printf的实现细节是什么"><a href="#printf的实现细节是什么" class="headerlink" title="printf的实现细节是什么"></a>printf的实现细节是什么</h3><p>主要包含以下几个步骤：</p>
<ol>
<li>首先解析字符串中的指定符，如%d，%s等；</li>
<li>再读取可变参数；</li>
<li>将读取的参数按照格式字符串指定的格式转换成字符串；</li>
<li>最终生成的字符串输出到标准输出设备。</li>
</ol>
<h3 id="string的size类型为什么是string-size-t而不是int？"><a href="#string的size类型为什么是string-size-t而不是int？" class="headerlink" title="string的size类型为什么是string::size_t而不是int？"></a>string的size类型为什么是string::size_t而不是int？</h3><p><code>std::string</code> 的 <code>size</code> 类型被定义为 <code>string::size_t</code> 而不是 <code>int</code>，是为了提高通用性和可移植性。这是因为字符串的大小（长度）可能非常大，而 <code>int</code> 类型的范围是有限的，因此可能无法表示所有可能的字符串大小。</p>
<p><code>string::size_t</code> 是一个无符号整数类型，通常被定义为一个足够大的整数，以便可以容纳字符串的任何合法大小。它的大小通常与系统架构和编译器有关，但通常足够大以容纳大多数字符串的长度。</p>
<p>使用 <code>string::size_t</code> 而不是 <code>int</code> 有以下几个好处：</p>
<ol>
<li><strong>能够表示更大的字符串：</strong> 无符号整数类型 <code>size_t</code> 可以容纳比 <code>int</code> 更大的值，这对于处理非常大的字符串是必要的。</li>
<li><strong>提高可移植性：</strong> 使用 <code>string::size_t</code> 可以确保代码在不同的平台上具有相同的行为，因为 <code>size_t</code> 的大小会根据平台而变化，而不是固定的。</li>
<li><strong>避免符号问题：</strong> <code>size_t</code> 是无符号类型，避免了符号整数的问题，如溢出等。</li>
</ol>
<p>综上所述，使用 <code>string::size_t</code> 作为字符串大小的类型是一种良好的设计选择，可以确保代码能够处理各种大小的字符串，并提高了代码的可移植性。如果你需要与其他整数类型进行比较，你可以将 <code>size_t</code> 强制类型转换为 <code>int</code> 或其他整数类型。</p>
<h3 id="介绍一下static和const？"><a href="#介绍一下static和const？" class="headerlink" title="介绍一下static和const？"></a>介绍一下static和const？</h3><p>const允许我们指定一个语义约束，告诉编译器某个变量不应该被修改。<strong>const可以用于修饰普通变量、函数、类等</strong>。比如在重载解引用操作符时，就可以用const来修饰，因为在解引用操作前后指针所指向的值是不应该被改变的。<br>static则修改存储方式和可见范围。主要包含4类：<br>（1）静态成员变量：静态成员变量不属于类的任何一个对象，而只属于类本身，所有对象共享一个静态成员变量。<br>（2）静态成员函数：静态成员函数同理。<br>（3）静态局部变量：定义在函数内部，和普通局部变量不同，在函数整个运行期间只会初始化一次，即使函数被多次调用也是如此。<br>（4）静态全局变量：静态全局变量在某个源文件中被定义后则只能在该源文件中被使用，而不能在其他文件中使用，有助于封装和避免命名冲突。</p>
<h3 id="extern-关键字的作用？"><a href="#extern-关键字的作用？" class="headerlink" title="extern 关键字的作用？"></a>extern 关键字的作用？</h3><p><code>extern</code>关键字用于声明一个变量或函数，其定义可能在另一个文件或同一文件的不同位置。使用<code>extern</code>的主要目的是在多个文件之间共享变量或函数。</p>
<ol>
<li><strong>声明外部变量</strong>：<ul>
<li>当你在多个源文件中使用同一个全局变量时，你可以在一个文件中定义该变量（不使用<code>extern</code>），并在其他文件中使用<code>extern</code>关键字来声明它们。这告诉编译器变量在其他地方定义，避免了多重定义的错误。</li>
</ul>
</li>
<li><strong>声明外部函数</strong>：<ul>
<li>使用<code>extern</code>可以明确表示函数可以被其他文件调用。</li>
</ul>
</li>
<li><strong>链接不同编程语言</strong>：<ul>
<li>在C++中，<code>extern &quot;C&quot;</code>用于告诉C++编译器某个函数或变量应该以C语言的方式进行链接。</li>
</ul>
</li>
</ol>
<h3 id="extern-声明全局变量的内部实现是怎样的？"><a href="#extern-声明全局变量的内部实现是怎样的？" class="headerlink" title="extern 声明全局变量的内部实现是怎样的？"></a>extern 声明全局变量的内部实现是怎样的？</h3><p>被extern修饰的全局变量，在编译期不会分配空间，而是在链接的时候通过索引去别的文件中查找索引对应的地址。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404170950469.jpeg" alt="IMG_183F6F3B95EC-1"></p>
<h3 id="在C-程序中调用被C编译器编译后的函数，为什么要加extern-“C”？"><a href="#在C-程序中调用被C编译器编译后的函数，为什么要加extern-“C”？" class="headerlink" title="在C++ 程序中调用被C编译器编译后的函数，为什么要加extern “C”？"></a>在C++ 程序中调用被C编译器编译后的函数，为什么要加extern “C”？</h3><p>extern “C”是连接申明，被其修饰的变量和函数是按照类C的编译和连接规约来编译和连接，这样在类C的代码中就可以调用C++的函数or变量等。</p>
<p>由于C++有重载的特性而C没有，因此函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：void foo(int x，int y);该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。 因此，extern “C”这个声明的真实目的：解决名字匹配问题，实现C++与C的混合编程。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202404170951735.jpeg" alt="IMG_EC64DA9B254B-1"></p>
<h3 id="explicit关键字用在什么情况下？"><a href="#explicit关键字用在什么情况下？" class="headerlink" title="explicit关键字用在什么情况下？"></a>explicit关键字用在什么情况下？</h3><p>explicit关键用于声明一个单参数的构造函数，阻止该构造函数隐式转换为该类的类型。</p>
<h3 id="inline关键字遇到过吗？作用是什么？和-define有什么区别？"><a href="#inline关键字遇到过吗？作用是什么？和-define有什么区别？" class="headerlink" title="inline关键字遇到过吗？作用是什么？和#define有什么区别？"></a>inline关键字遇到过吗？作用是什么？和#define有什么区别？</h3><p>inline关键字作为函数定义的关键字，说明该函数是内联函数。内联函数会将代码块嵌入到每个调用该函数的地方，减少函数调用的开销，但增加了代码量。同时要注意inline只是对编译器的一个建议，真正能否内联还是要看编译器自己的判断。</p>
<p>和#define的区别在于：</p>
<p>（1）#define是关键字，inline是函数。</p>
<p>（2）宏定义在预处理阶段进行文本替换，inline函数在编译时进行替换。</p>
<p>（3）inline有类型检查，相对于#define较安全。</p>
<h3 id="define、const和constexpr的区別和应用场景？"><a href="#define、const和constexpr的区別和应用场景？" class="headerlink" title="#define、const和constexpr的区別和应用场景？"></a>#define、const和constexpr的区別和应用场景？</h3><p>（1）#define是预处理指令，用于定义常量宏。它在预处理阶段将标识符替换为指定的文本。不包含类型检查。</p>
<p>（2）const用于定义类型安全的常量，在编译时被创建，并且会占用内存，可以在运行时被初始化。之所以说其是类型安全的，是因为声明为const的常量在编译期间会检查程序是否对其进行了修改，避免意外修改；同时会对其进行类型检查，因此是安全的。</p>
<p>（3）constexpr用于声明常量表达式，在编译时被求值。因此适用于在编译时期就能确定初始值，并且在整个程序生命周期内都不会改变的常量。</p>
<h3 id="简单说说lambda表达式？"><a href="#简单说说lambda表达式？" class="headerlink" title="简单说说lambda表达式？"></a>简单说说lambda表达式？</h3><p>Lambda表达式是C++11中引入的一种匿名函数，可以在需要函数的地方直接定义，无需提前命名。</p>
<p>它可以显著减少代码的数量和复杂性，特性是在一些需要简单的函数作为参数传递给算法或函数对象时，可以简化代码的书写。</p>
<p>Lambda表达式可以捕获定义范围内的局部变量，形成闭包。这是Lambda表达式可以在其定义范围之外使用局部变量。</p>
<h3 id="virtual和override的区别和应用场景？"><a href="#virtual和override的区别和应用场景？" class="headerlink" title="virtual和override的区别和应用场景？"></a>virtual和override的区别和应用场景？</h3><p>（1）virtual用于声明虚函数，即在基类中声明一个函数为虚函数，以便在派生类中进行覆盖或重写。</p>
<p>（2）override用于显式地告诉编辑器，当前函数是基类中虚函数的重写版本。</p>
<h3 id="volatile关键字的作用？"><a href="#volatile关键字的作用？" class="headerlink" title="volatile关键字的作用？"></a>volatile关键字的作用？</h3><p><code>volatile</code>关键字用于告诉编译器，一个变量的值可能会在程序的控制之外发生改变。这意味着编译器在处理这种变量时，应避免优化掉那些看似无用的读取或写入操作。</p>
<ol>
<li><strong>防止编译器优化</strong>：<ul>
<li>编译器在优化代码时，可能会移除或修改一些看似不必要的操作。当一个变量被声明为<code>volatile</code>时，编译器会保留对这个变量的所有读写操作，确保它们按照程序的指令执行。</li>
</ul>
</li>
<li><strong>用于硬件访问</strong>：<ul>
<li>在嵌入式系统或操作系统的开发中，硬件的状态可能会独立于程序的控制而改变（例如，通过硬件设备的寄存器）。使用<code>volatile</code>可以确保程序正确读取最新的硬件状态。</li>
</ul>
</li>
<li><strong>用于中断服务例程</strong>：<ul>
<li>在使用中断服务例程（ISR）时，变量可能在中断处理函数中被修改。主程序需要使用<code>volatile</code>声明这些变量，以确保获取到最新的值，而不是编译器优化后的旧值。</li>
</ul>
</li>
<li><strong>多线程编程</strong>：<ul>
<li>在多线程环境中，一个线程可能修改另一个线程可以访问的变量。声明这些共享变量为<code>volatile</code>可以防止编译器对这些变量的潜在优化，确保所有线程都能看到最新的修改。</li>
</ul>
</li>
</ol>
<p>例如，如果有一个由硬件事件更新的变量<code>status</code>，可以这样声明它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> status;</span><br></pre></td></tr></table></figure>

<p>这样，每次访问<code>status</code>时，程序都会直接从其内存位置读取，而不是使用可能已经过时的寄存器或缓存中的值。</p>
<p>通过这种方式，<code>volatile</code>关键字在需要直接与硬件交互或在多线程环境中确保数据一致性的场景中非常有用。</p>
<h3 id="sizeof和strlen之间的区别是什么？"><a href="#sizeof和strlen之间的区别是什么？" class="headerlink" title="sizeof和strlen之间的区别是什么？"></a>sizeof和strlen之间的区别是什么？</h3><p>（1）sizeof是一个运算符而不是函数，用于获取指定类型或变量在内存中占用的字节数，在编译时进行计算；</p>
<p>（2）strlen是一个函数，用于获取以null结尾的C风格字符串的长度，即字符串中有效字符的数量，不包含结尾的null字符。在运行时进行遍历计算。</p>
<h3 id="scanf-和std-cin有什么区别？"><a href="#scanf-和std-cin有什么区别？" class="headerlink" title="scanf()和std::cin有什么区别？"></a>scanf()和std::cin有什么区别？</h3><p>（1）<code>scanf()</code> 是 C 语言标准库中的函数，用于从标准输入流（通常是键盘）读取数据，并按照指定的格式进行解析；<code>std::cin</code> 是 C++ 中的输入流对象，属于标准库 <code>iostream</code> 中的一部分，用于从标准输入流或其他流中读取数据；</p>
<p>（2）<code>scanf()</code> 对输入的类型不进行类型检查，可能会导致类型不匹配或溢出等问题；<code>std::cin</code> 是 C++ 中的类型安全输入方式。</p>
<h3 id="struct和class的区别是什么？"><a href="#struct和class的区别是什么？" class="headerlink" title="struct和class的区别是什么？"></a>struct和class的区别是什么？</h3><p>struct和class是用于定义自定义数据类型的关键字。其中：</p>
<p>（1）struct默认的访问类型是public，而class默认的访问类型是private；</p>
<p>（2）struct的继承是public的，而class的继承默认是private的；</p>
<p>（3）struct用于较为简单的结构，而class用于更加复杂的结构。</p>
<h3 id="C-中delete一个对象和数组有什么区别？"><a href="#C-中delete一个对象和数组有什么区别？" class="headerlink" title="C++中delete一个对象和数组有什么区别？"></a>C++中delete一个对象和数组有什么区别？</h3><p>使用<code>delete</code>释放单个对象时只调用一次析构函数，而使用<code>delete[]</code>释放对象数组时需要为数组中的每个对象调用析构函数。<code>delete</code>数组要用<code>delete[]</code>，数组头部有一块内存空间记录数组长度，调用<code>delete[]</code>才能析构每个对象。</p>
<h3 id="如何防止重复引用头文件？"><a href="#如何防止重复引用头文件？" class="headerlink" title="如何防止重复引用头文件？"></a>如何防止重复引用头文件？</h3><p>（1）使用#ifndef&#96;、#define和#endif；</p>
<p>（2）使用#pragma once&#96;</p>
<h3 id="如何预防变量的重定义？"><a href="#如何预防变量的重定义？" class="headerlink" title="如何预防变量的重定义？"></a>如何预防变量的重定义？</h3><p>（1）使用命名空间</p>
<p>（2）使用<code>static</code>关键字或匿名命名空间来限制变量的作用域至单个文件</p>
<p>（3）使用<code>extern</code>关键字确保全局变量只有一个定义</p>
<p>（4）避免在头文件中定义变量，将定义放在源文件（<code>.cpp</code>）中</p>
<h2 id="4、左值引用和右值引用"><a href="#4、左值引用和右值引用" class="headerlink" title="4、左值引用和右值引用"></a>4、左值引用和右值引用</h2><h3 id="什么是左值，什么是右值？"><a href="#什么是左值，什么是右值？" class="headerlink" title="什么是左值，什么是右值？"></a>什么是左值，什么是右值？</h3><p>左值是指一段指向内存的，具有名称的值，通常有较长的声明周期；右值是指向不稳定内存的匿名值，声明周期较短。可以通过取址符号来进行判断，能取到地址的是左值，取不到的是右值。</p>
<h3 id="前置c-返回的是左值还是右值？后置c-呢？字符串字面量呢？"><a href="#前置c-返回的是左值还是右值？后置c-呢？字符串字面量呢？" class="headerlink" title="前置c++返回的是左值还是右值？后置c++呢？字符串字面量呢？"></a>前置c++返回的是左值还是右值？后置c++呢？字符串字面量呢？</h3><p>前置C++的实现是直接对传入的变量进行自增，然后返回这个对象，即一个具有名称的稳定的值，因此返回的是左值。后置C++是创建一个临时对象，然后对对象自增，再返回这个临时对象自增，因此返回的是右值。<br>字符串字面量也是左值。他会将字符串变量存放在程序的数据段中，程序加载时为其分配一段内存。</p>
<h3 id="什么是左值引用和右值引用？"><a href="#什么是左值引用和右值引用？" class="headerlink" title="什么是左值引用和右值引用？"></a>什么是左值引用和右值引用？</h3><p>左值引用是指向左值的引用，用单个&amp;表示。常量左值引用可以绑定左值，也可以绑定右值。非常量左值引用只能绑定左值。<br>右值引用是指向右值的引用，用两个&amp;&amp;表示。右值引用主要用于移动语义。通过移动语义，可以避免不必要的拷贝操作，从而提升性能。</p>
<h3 id="右值引用是如何提高性能的？"><a href="#右值引用是如何提高性能的？" class="headerlink" title="右值引用是如何提高性能的？"></a>右值引用是如何提高性能的？</h3><p>右值引用主要是通过避免不必要的拷贝操作来提升性能的。<br>举两个例子：<br>（1）当使用右值引用接收函数返回的局部变量时，可以延长该局部变量的声明周期，使得右值引用直接利用该局部变量的内存，而不是创建一个临时对象，从而避免了不必要的开销。<br>（2）当使用一个临时对象来创建一个新对象时，可以使用移动构造函数，直接将资源从一个对象复制到另一个对象上，避免了不必要的复制操作。</p>
<h2 id="5、构造-析构相关"><a href="#5、构造-析构相关" class="headerlink" title="5、构造&#x2F;析构相关"></a>5、构造&#x2F;析构相关</h2><h3 id="构造函数中各个元素的初始化顺序是什么？"><a href="#构造函数中各个元素的初始化顺序是什么？" class="headerlink" title="构造函数中各个元素的初始化顺序是什么？"></a>构造函数中各个元素的初始化顺序是什么？</h3><p>（1）基类构造函数；</p>
<p>（2）成员变量，按照其在类定义中声明的顺序初始化；</p>
<p>（3）派生类构造函数体。</p>
<h3 id="深拷贝和浅拷贝指什么？"><a href="#深拷贝和浅拷贝指什么？" class="headerlink" title="深拷贝和浅拷贝指什么？"></a>深拷贝和浅拷贝指什么？</h3><p>（1）深拷贝创建一个新的对象，并且复制对象的所有内容，包括对象的指针成员变量所指向的内存空间。深拷贝后的新对象和原对象之间是彼此独立的。</p>
<p>（2）浅拷贝只复制对象的引用，而不复制对象的内容。也就是说，浅拷贝创建一个新的对象，但是其新对象的指针成员变量指向的是原对象的指针成员变量所指向的内存空间。</p>
<h3 id="拷贝构造函数与拷贝赋值运算符的区别是什么"><a href="#拷贝构造函数与拷贝赋值运算符的区别是什么" class="headerlink" title="拷贝构造函数与拷贝赋值运算符的区别是什么?"></a>拷贝构造函数与拷贝赋值运算符的区别是什么?</h3><p>（1）拷贝构造函数用于创建对象，没有返回值。</p>
<p>（2）而拷贝赋值运算符用于更新已经存在的对象的值，返回一个引用到当前对象。</p>
<blockquote>
<p>拷贝赋值的步骤：</p>
<ol>
<li><strong>判断是否为自我赋值</strong>（important）</li>
<li>删除自己本来的指针及内存</li>
<li>根据要赋值进来的内容大小开辟一块新的内存</li>
<li>复制新的内容</li>
<li>返回*this</li>
</ol>
</blockquote>
<h3 id="如果一个类要支持std-move操作，要完成哪些工作呢？"><a href="#如果一个类要支持std-move操作，要完成哪些工作呢？" class="headerlink" title="如果一个类要支持std::move操作，要完成哪些工作呢？"></a>如果一个类要支持std::move操作，要完成哪些工作呢？</h3><p>需要在类中实现移动构造函数和移动赋值函数。</p>
<p>（1）移动构造函数接受一个右值引用到同类型的对象，通常声明为 <code>T(T&amp;&amp; other)</code>，其中 <code>T</code> 是类名。</p>
<p>（2）移动赋值运算符通常被定义为返回类的引用，并接受一个右值引用到同类型的对象，声明为 <code>T&amp; operator=(T&amp;&amp; other)</code>。</p>
<p>（3）为了确保移动动作不会抛出异常，添加<code>noexcept</code>关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">        : <span class="built_in">resource</span>(other.resource) &#123;</span><br><span class="line">        other.resource = <span class="literal">nullptr</span>; <span class="comment">// 窃取资源后，将原对象的指针设为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123; <span class="comment">// 防止自赋值</span></span><br><span class="line">            <span class="keyword">delete</span> resource;  <span class="comment">// 释放当前对象的资源</span></span><br><span class="line">            resource = other.resource; <span class="comment">// 窃取资源</span></span><br><span class="line">            other.resource = <span class="literal">nullptr</span>; <span class="comment">// 将原对象的指针设为空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ResourceType* resource;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="移动构造函数可能会有什么问题？"><a href="#移动构造函数可能会有什么问题？" class="headerlink" title="移动构造函数可能会有什么问题？"></a>移动构造函数可能会有什么问题？</h3><p>在使用移动构造函数时，如果当一个对象的资源移动到另一个对象上时发生了异常，此时就会造成有一部分资源转移了，而另一部分没有，从而使得源对象和目标对象上的资源都不完整。因此在使用移动构造函数时应该避免发生异常。如果无法确保移动构造函数不会发生异常，应该用noexcept进行修饰。这样函数如果发生异常时不会继续执行，而是抛出std::terminate并停止。</p>
<h3 id="移动构造函数的使用场景是什么？"><a href="#移动构造函数的使用场景是什么？" class="headerlink" title="移动构造函数的使用场景是什么？"></a>移动构造函数的使用场景是什么？</h3><p>移动构造函数是 C++11 新增的特性，用于实现右值引用语义，可以将临时对象的资源有效地转移给目标对象，避免不必要的资源复制，提高程序的性能和效率。</p>
<p>（1）容器元素的插入和移动</p>
<p>（2）返回临时对象</p>
<h3 id="构造函数能否为虚函数？"><a href="#构造函数能否为虚函数？" class="headerlink" title="构造函数能否为虚函数？"></a>构造函数能否为虚函数？</h3><p>构造函数不能是虚函数。这是因为在C++中，虚函数依赖于对象中的虚函数表（vtable）来进行动态绑定，而虚函数表是在对象的内存分配后构造函数开始执行之前设置好的。在构造函数执行之前，对象还未完全构建完成，因此不存在可以指向的虚函数表。如果构造函数是虚的，那么在对象创建时还无法确定调用哪一个构造函数，因为虚函数机制尚未建立，所以构造函数无法实现虚调用。</p>
<h3 id="析构函数为什么设置成虚函数？"><a href="#析构函数为什么设置成虚函数？" class="headerlink" title="析构函数为什么设置成虚函数？"></a>析构函数为什么设置成虚函数？</h3><p>如果这个类是一个多态性质的类，其析构函数应该设置为虚函数，否则就不应该被设置为虚函数。<br>由于基类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。假如析构函数非虚函数，如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，造成内存的局部释放，内存泄漏。因此此时析构函数应该设置为虚函数。<br>但如果这个类不包含多态性，就不应该设置为虚函数，否则会引入虚函数指针和虚函数表，造成内存浪费。</p>
<h3 id="C-在返回⼀个局部对象的时候是如何避免多次调用构造函数的，返回局部对象⼀定会多次构造吗？"><a href="#C-在返回⼀个局部对象的时候是如何避免多次调用构造函数的，返回局部对象⼀定会多次构造吗？" class="headerlink" title="C++在返回⼀个局部对象的时候是如何避免多次调用构造函数的，返回局部对象⼀定会多次构造吗？"></a>C++在返回⼀个局部对象的时候是如何避免多次调用构造函数的，返回局部对象⼀定会多次构造吗？</h3><p>在 C++ 中，返回局部对象时会发生返回值优化（Return Value Optimization，RVO）和命名返回值优化（Named Return Value Optimization，NRVO）。这些优化技术可以避免多次调用构造函数，提高程序的性能和效率。</p>
<p>具体来说，当函数返回一个局部对象时，编译器可以将该对象直接构造在函数调用方的目标对象的位置上，而不是在函数内部创建一个局部对象然后再拷贝到目标对象中。这样就避免了额外的构造和拷贝操作。</p>
<h3 id="一个空类包含什么？"><a href="#一个空类包含什么？" class="headerlink" title="一个空类包含什么？"></a>一个空类包含什么？</h3><p>在C++中空类会占一个字节。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> </span><br><span class="line">&#123;   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Empty</span>();                            <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Empty</span>(<span class="type">const</span> Empty &amp;rhs);            <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">Empty</span>();                           <span class="comment">// 析构函数 </span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty &amp;rhs); <span class="comment">// 赋值运算符</span></span><br><span class="line">    Empty* <span class="keyword">operator</span>&amp;();                 <span class="comment">// 取址运算符</span></span><br><span class="line">    <span class="type">const</span> Empty* <span class="keyword">operator</span>&amp;() <span class="type">const</span>;     <span class="comment">// 取址运算符(const版本) </span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="C-的类中可以定义引用的数据成员吗？"><a href="#C-的类中可以定义引用的数据成员吗？" class="headerlink" title="C++的类中可以定义引用的数据成员吗？"></a>C++的类中可以定义引用的数据成员吗？</h3><p>可以使用，但要注意以下几点：</p>
<ol>
<li><strong>初始化必须性</strong>：引用成员必须在构造函数的初始化列表中被初始化。引用一经初始化后，就不能再指向另一个对象或变量。因此，每一个含有引用成员的对象必须在创建时提供引用的初始化。</li>
<li><strong>复制语义</strong>：如果类含有引用成员，需要特别注意类的复制构造函数和赋值运算符的行为。默认生成的复制构造函数和赋值运算符只会进行浅拷贝，即复制引用但不复制引用所指向的对象。这可能导致两个对象的引用成员指向相同的数据，当其中一个修改数据时会影响到另一个对象。如果这不是你想要的行为，你可能需要自定义复制构造函数和赋值运算符以适应特定的需求。</li>
<li><strong>使用限制</strong>：含有引用成员的对象无法进行标准的赋值，因为引用一旦初始化后不能被改变指向。这可能限制该类对象的使用方式。</li>
</ol>
<h2 id="6、多态-虚函数相关"><a href="#6、多态-虚函数相关" class="headerlink" title="6、多态&#x2F;虚函数相关"></a>6、多态&#x2F;虚函数相关</h2><h3 id="多态的实现原理是什么？"><a href="#多态的实现原理是什么？" class="headerlink" title="多态的实现原理是什么？"></a>多态的实现原理是什么？</h3><p>c++的多态包括<strong>静态多态（编译器多态）</strong>和<strong>动态多态（运行期多态）</strong>。</p>
<p>（1）静态多态是指编译器的多态，主要由函数重载和函数模板实现。函数重载是指在同一作用域内，一组函数具有相同的函数名和不同的参数列表，编译器根据函数调用时传递的参数数量和类型选择调用哪个函数执行。函数模板允许编写通用的代码，编译器根据模板实例化的内容生成代码。</p>
<p>（2）动态多态则是在运行时实现，主要由虚函数和继承实现。其核心思想是类的对象会根据其属性来确定究竟调用哪一个类的函数。具体来说，每一个包含虚函数的类都分配了一个虚函数指针，这个虚函数指针指向一个虚函数表。当需要调用对应的函数时，首先根据虚函数指针找到对应的虚函数表，然后根据这个函数在表中的下标位置找到对应的函数。</p>
<h3 id="子类中需要virtual关键字吗？需要override关键字吗？编码过程中加不加override-有什么区别？"><a href="#子类中需要virtual关键字吗？需要override关键字吗？编码过程中加不加override-有什么区别？" class="headerlink" title="子类中需要virtual关键字吗？需要override关键字吗？编码过程中加不加override 有什么区别？"></a>子类中需要virtual关键字吗？需要override关键字吗？编码过程中加不加override 有什么区别？</h3><p>在基类中，声明虚函数时需要使用<code>virtual</code>关键字来指示该函数可以在派生类中被重写。在派生类中重写虚函数时，即使没有显式地使用<code>virtual</code>关键字，该函数自动被视为虚函数。</p>
<p>使用<code>override</code>可以使得编译器帮助检查函数重写的正确性。如果标记了<code>override</code>但并未正确重写基类的虚函数（例如参数类型不匹配），编译器将报错。</p>
<h3 id="虚函数和纯虚函数有什么区别？"><a href="#虚函数和纯虚函数有什么区别？" class="headerlink" title="虚函数和纯虚函数有什么区别？"></a>虚函数和纯虚函数有什么区别？</h3><p>（1）虚函数是一种在基类中声明的函数，它可以在派生类中被重写。声明为虚函数的目的是允许在通过基类指针或引用调用时，执行相应派生类中的函数。虚函数可以有自己的实现，也就是说，即使派生类没有重写该函数，也有一个默认的行为可供执行。</p>
<p>（2）纯虚函数是一种在基类中声明但不实现的虚函数。通过在函数声明的末尾加上<code>= 0</code>，可以将函数声明为纯虚函数。一个包含纯虚函数的类称为抽象类，这意味着它不能被实例化。纯虚函数的主要目的是强制派生类提供自己的函数实现。</p>
<h3 id="什么样的函数适合声明成虚函数？"><a href="#什么样的函数适合声明成虚函数？" class="headerlink" title="什么样的函数适合声明成虚函数？"></a>什么样的函数适合声明成虚函数？</h3><p>（1）需要在派生类中重写的函数；</p>
<p>（2）在抽象基类中，可能会定义一组纯虚函数，这些函数构成了一个接口，派生类必须实现这些接口；</p>
<p>（3）如果一个类已经有虚析构函数，这通常意味着该类设计为基类，并且预期会通过基类指针来删除派生类对象。在这种情况下，类中的其他成员函数也可能需要声明为虚函数以支持多态性。</p>
<h3 id="虚函数表是一个map还是一个数组？"><a href="#虚函数表是一个map还是一个数组？" class="headerlink" title="虚函数表是一个map还是一个数组？"></a>虚函数表是一个map还是一个数组？</h3><p>虚函数表（vtable，虚方法表）在实现上通常是一个数组。这个表是一个编译时构建的数组，其中存储了指向类中所有虚函数的指针。</p>
<p><strong>为什么是数组，不是map？</strong></p>
<ol>
<li><strong>性能</strong>：数组通过索引直接访问元素，访问时间为O(1)，而map（通常实现为红黑树或哈希表）的访问时间可能是O(log n)或更复杂，取决于实现。因此，数组访问速度更快，适合频繁访问的场景，如虚函数的调用。</li>
<li><strong>简单性</strong>：数组提供了一种简单而直接的方式来存储和访问虚函数的指针。每个对象都有一个指向其类的虚函数表的指针（通常是对象内存布局的第一个元素），通过这个指针可以直接访问到具体的虚函数实现。</li>
<li><strong>内存布局</strong>：由于数组具有连续的内存布局特性，这有助于提高缓存的效率，从而加速虚函数的调用过程。</li>
</ol>
<h3 id="一个类中有几个虚函数表？一个类的对象有几个虚函数指针？"><a href="#一个类中有几个虚函数表？一个类的对象有几个虚函数指针？" class="headerlink" title="一个类中有几个虚函数表？一个类的对象有几个虚函数指针？"></a>一个类中有几个虚函数表？一个类的对象有几个虚函数指针？</h3><p>一个类继承了多少个父类，就有多少张虚函数表。一个类的对象包含多少张虚函数表，就有多少虚函数指针。</p>
<h3 id="现在一个类在构造函数初始化的时候初始化了虚函数表，若通过-memset将这个类全部赋值为0，那这个虚表指针会被损坏，有什么办法恢复它吗？"><a href="#现在一个类在构造函数初始化的时候初始化了虚函数表，若通过-memset将这个类全部赋值为0，那这个虚表指针会被损坏，有什么办法恢复它吗？" class="headerlink" title="现在一个类在构造函数初始化的时候初始化了虚函数表，若通过 memset将这个类全部赋值为0，那这个虚表指针会被损坏，有什么办法恢复它吗？"></a>现在一个类在构造函数初始化的时候初始化了虚函数表，若通过 memset将这个类全部赋值为0，那这个虚表指针会被损坏，有什么办法恢复它吗？</h3><p><strong>没有直接的、安全的方法来恢复虚表指针</strong>。一旦虚表指针被覆盖或破坏，这个对象基本上就已经损坏，无法保证其后续行为的正确性。</p>
<p>可考虑<strong>重新构造对象</strong>。即，如果确实需要重置对象的状态，考虑使用对象的构造函数和析构函数来正确地构建和销毁对象。例如，可以先显式调用析构函数，然后使用 <code>placement new</code> 重新在原地构造一个新对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeobj.~<span class="built_in">ClassName</span>();</span><br><span class="line"><span class="keyword">new</span> (&amp;obj) <span class="built_in">ClassName</span>();</span><br></pre></td></tr></table></figure>

<h3 id="一个类的虚函数指针在类中的内存分布是怎样的？"><a href="#一个类的虚函数指针在类中的内存分布是怎样的？" class="headerlink" title="一个类的虚函数指针在类中的内存分布是怎样的？"></a>一个类的虚函数指针在类中的内存分布是怎样的？</h3><p>根据该类继承父类的顺序，从对象的首地址开始依次排列。</p>
<h3 id="父类中有虚函数，普通函数和数据。子类继承父类，有自己的虚函数及数据，new一个子类对象，它的内存是如何排布的？"><a href="#父类中有虚函数，普通函数和数据。子类继承父类，有自己的虚函数及数据，new一个子类对象，它的内存是如何排布的？" class="headerlink" title="父类中有虚函数，普通函数和数据。子类继承父类，有自己的虚函数及数据，new一个子类对象，它的内存是如何排布的？"></a>父类中有虚函数，普通函数和数据。子类继承父类，有自己的虚函数及数据，new一个子类对象，它的内存是如何排布的？</h3><ol>
<li><strong>虚函数指针（vptr）</strong>：<ul>
<li>如果父类有虚函数，子类对象中会有一个虚函数指针（通常称为vptr），它指向虚函数表（vtable）。虚函数表是一个包含函数指针的数组，用于支持运行时多态。</li>
<li>如果子类覆盖了父类的虚函数或添加了新的虚函数，vptr将指向一个扩展或修改后的vtable，这个表包括了父类的虚函数和子类的新虚函数的指针。</li>
</ul>
</li>
<li><strong>父类成员变量</strong>：<ul>
<li>子类对象中首先包含来自父类的成员变量。这些变量的排列顺序与它们在父类中的声明顺序相同。</li>
</ul>
</li>
<li><strong>子类成员变量</strong>：<ul>
<li>父类成员之后是子类自己的成员变量。这些变量的排列顺序与它们在子类中的声明顺序相同。</li>
</ul>
</li>
<li><strong>普通函数</strong>：<ul>
<li>对于非虚普通函数，不需要在对象的内存布局中单独存储指针。普通函数的调用是静态解析的，即编译时就已确定。</li>
</ul>
</li>
</ol>
<h3 id="虚函数指针在什么时候创建？"><a href="#虚函数指针在什么时候创建？" class="headerlink" title="虚函数指针在什么时候创建？"></a>虚函数指针在什么时候创建？</h3><p>虚函数指针（vptr）的创建和初始化实际上发生在<strong>对象的构造阶段</strong>。当一个对象被创建时，编译器会在对象的内存布局中的特定位置（通常是对象内存布局的开始位置）插入一个指针，这个指针指向该对象所属类的虚函数表。这个过程是自动发生的，确保了对象能够通过虚函数指针访问到正确的虚函数表，从而实现多态性。</p>
<h3 id="虚函数表在什么时候创建、存在在什么位置？"><a href="#虚函数表在什么时候创建、存在在什么位置？" class="headerlink" title="虚函数表在什么时候创建、存在在什么位置？"></a>虚函数表在什么时候创建、存在在什么位置？</h3><p>（1）虚函数表在<strong>编译时期</strong>创建。编译器在处理类定义时，如果发现类中有虚函数（包括从基类继承的虚函数），它会为这个类生成一个虚函数表。这个表包含了指向类的虚函数的指针。如果类中没有虚函数，则不会生成虚函数表。对于继承的情况，如果派生类覆盖了基类的虚函数，派生类的虚函数表中对应的条目会被更新为指向派生类中的虚函数。如果派生类没有覆盖基类的某个虚函数，那么派生类的虚函数表中会保留一个指向基类虚函数的指针。</p>
<p>（2）虚函数表存储在程序的只读数据段（.rodata section），这是因为虚函数表在编译时就已经确定，运行时不会修改。虚表中的指针再指向代码段（.text section）的函数代码。</p>
<h3 id="抽象类和普通虚函数类的区别是什么？"><a href="#抽象类和普通虚函数类的区别是什么？" class="headerlink" title="抽象类和普通虚函数类的区别是什么？"></a>抽象类和普通虚函数类的区别是什么？</h3><p>（1）抽象类至少包含一个纯虚函数，其不能被直接实例化，必须让派生类继承并实现其纯虚函数；</p>
<p>（2）普通虚函数类可以包含一个或多个虚函数，这些虚函数在基类中有具体的实现，但可以在派生类中被重写。可以被直接实例化。</p>
<h3 id="如何设计一个不能继承的类？"><a href="#如何设计一个不能继承的类？" class="headerlink" title="如何设计一个不能继承的类？"></a>如何设计一个不能继承的类？</h3><p>（1）在C++11及更高版本中，可以在类声明中使用<code>final</code>关键字来防止类被继承；</p>
<p>（2）在C++11之前，一个常用的技巧是将构造函数声明为私有或受保护的，并通过静态方法返回实例。</p>
<h3 id="菱形继承指什么？"><a href="#菱形继承指什么？" class="headerlink" title="菱形继承指什么？"></a>菱形继承指什么？</h3><p>菱形继承指两个及以上的派生类继承自同一个基类，而另外又有一个类继承了这些派生类，导致最终生成的派生类中包含多个基类的子对象副本。</p>
<h3 id="父类用private修饰的变量，使用多态后能不能访问到这个变量呢？"><a href="#父类用private修饰的变量，使用多态后能不能访问到这个变量呢？" class="headerlink" title="父类用private修饰的变量，使用多态后能不能访问到这个变量呢？"></a>父类用private修饰的变量，使用多态后能不能访问到这个变量呢？</h3><p>在 C++ 中，如果父类中的变量被声明为 <code>private</code>，那么这些变量只能被该父类自己的成员函数、友元函数或者同一个类的其他实例访问。即使在继承的情况下，子类是无法直接访问父类的私有成员变量的。</p>
<h3 id="说一下重载，覆盖和隐藏的区别？"><a href="#说一下重载，覆盖和隐藏的区别？" class="headerlink" title="说一下重载，覆盖和隐藏的区别？"></a>说一下重载，覆盖和隐藏的区别？</h3><p>重载（Overloading）、覆盖（Overriding）和隐藏（Hiding）是三种不同的概念。</p>
<p>（1）重载发生在同一个作用域内，当两个或更多具有相同名称但参数列表不同的函数共存时，这些函数被称为重载函数。</p>
<p>（2）覆盖是面向对象编程中的一个特性，指的是在派生类中重新定义基类中的虚函数。覆盖的主要目的是实现多态。派生类的函数覆盖了基类的函数，当通过基类的指针或引用调用该函数时，会根据对象的实际类型来调用相应的函数。</p>
<p>（3）隐藏发生在继承关系中，当派生类中声明了与基类同名的成员（函数或变量）时，无论参数列表是否相同，基类中的同名成员都会被派生类中的成员隐藏。</p>
<h2 id="7、STL相关"><a href="#7、STL相关" class="headerlink" title="7、STL相关"></a>7、STL相关</h2><h3 id="vector的扩容原理是怎样的？"><a href="#vector的扩容原理是怎样的？" class="headerlink" title="vector的扩容原理是怎样的？"></a>vector的扩容原理是怎样的？</h3><p>vector可以进行自动扩容，以容纳更多的元素。主要包含以下几步：</p>
<p>（1）确定新容量。根据平台的不同，有不同的扩容倍数。其中linux和gcc下为2倍，windows下为1.5倍。</p>
<p>（2）开辟内存空间。确定了新容量后，在堆上开辟一块新的连续内存空间。</p>
<p>（3）复制元素。通过拷贝构造或移动构造将现有元素从旧内存空间复制到新内存空间。</p>
<p>（4）释放旧内存。</p>
<p>（5）更新内部指针。在元素复制完成后，vector更新其内部数据结构，如指向元素数组的指针、大小和容量。</p>
<h3 id="vector最大的缺点是什么？"><a href="#vector最大的缺点是什么？" class="headerlink" title="vector最大的缺点是什么？"></a>vector最大的缺点是什么？</h3><ol>
<li><strong>内存重新分配和复制</strong>：<ul>
<li>当 <code>std::vector</code> 的元素数量超过其当前容量时，它需要进行扩容，这通常涉及到申请一个更大的内存块，将现有元素复制到新的内存块中，然后释放原来的内存块。这个过程是成本较高的，尤其是当vector中存储的对象较大或复制开销较大时。</li>
<li>在扩容过程中，新旧两块内存会暂时同时存在，这可能导致内存使用翻倍，对于内存敏感的应用或在内存受限的环境中，这可能成为一个问题。</li>
</ul>
</li>
<li><strong>内存碎片</strong>：<ul>
<li>频繁的增加和删除操作可能导致内存碎片，尤其是在多次扩容和收缩后。虽然 <code>std::vector</code> 通常只在增加元素时扩容，但如果频繁地增加和删除大量元素，可能会导致实际占用的内存量和容器大小之间存在较大差异。</li>
</ul>
</li>
<li><strong>性能不可预测</strong>：<ul>
<li>由于扩容操作的不可预测性，<code>std::vector</code> 的性能可能在某些情况下变得不稳定，特别是在连续插入元素时。如果每次插入后都触发扩容，性能会受到较大影响。</li>
</ul>
</li>
<li>从操作系统内存监管者的视角来看，其需要处理应用程序的内存请求和释放。对于 <code>std::vector</code>，操作系统需要能够快速响应内存申请请求，并处理可能的大量内存释放操作。</li>
</ol>
<h3 id="push-back和emplace-back的区别？"><a href="#push-back和emplace-back的区别？" class="headerlink" title="push_back和emplace_back的区别？"></a>push_back和emplace_back的区别？</h3><p>（1）push_back()接收一个元素的拷贝或移动作为参数，并将其复制或移动到容器的末端。</p>
<p>（2）emplace_back()则直接在向量的尾部构造元素，而不是先构造一个临时对象然后再进行拷贝或移动。</p>
<h3 id="vector、list和array的区别是什么？"><a href="#vector、list和array的区别是什么？" class="headerlink" title="vector、list和array的区别是什么？"></a>vector、list和array的区别是什么？</h3><p>（1）vector是动态数组，支持随机访问，内部使用连续的内存存储元素，在进行删除和插入操作时可能需要移动其他元素；</p>
<p>（2）list是双向链表，不支持随机访问，插入和删除的操作效率高，内存不连续，每个元素存储在独立的节点中；</p>
<p>（3）array是静态数组，大小固定，在编译时就确定，内存连续存储，且支持随机访问。</p>
<h3 id="数组和链表的区别是什么？"><a href="#数组和链表的区别是什么？" class="headerlink" title="数组和链表的区别是什么？"></a>数组和链表的区别是什么？</h3><p>（1）数组元素的个数是固定的，而链表结点的个数可按需增减；</p>
<p>（2）数组元素的存储单元在数组定义时分配，而链表结点的存储单元在程序执行时动态申请；</p>
<p>（3）数组元素的顺序关系由下标确定，而链表结点的顺序关系由结点所包含的指针确定；</p>
<p>（4）对于元素频繁操作的处理场合，用链表实现会比数组实现更加有效率。比如在数组中删除一个元素时，需要将删除处之后的所有元素全部前移一个位置；但对于链表来说，只需要改变删除处相关结点的指针指向，而与结点实际的存储位置无关。</p>
<h3 id="为什么list不能用-sort-，而要用自己的sort-？"><a href="#为什么list不能用-sort-，而要用自己的sort-？" class="headerlink" title="为什么list不能用::sort()，而要用自己的sort()？"></a>为什么list不能用::sort()，而要用自己的sort()？</h3><p>list不能用::sort()，而要用自己的sort()的原因是，全局实现::sort()中有一个操作是对迭代器进行(first + (last - first) &#x2F; 2)，而这个只有针对RandomAccessIterator才能如此操作，而list的在内存中的存放是不连续的，因此不能随机存取。</p>
<h3 id="指针与数组的外部声明相关"><a href="#指针与数组的外部声明相关" class="headerlink" title="指针与数组的外部声明相关"></a>指针与数组的外部声明相关</h3><p><strong>数组通过外部声明为指针时，数组和指针是不能互换使用的；那么请思考一下，在 A 文件中定义数组 char a[100]；在 B 文件中声明为指针：extern char *a；此时访问 a[i]，会发生什么；</strong></p>
<p>答1：会引起 <strong>segmentation fault</strong> 报错。链接器实际上是把指针 a 自身的地址定位到了另一个 .cpp 文件中定义的数组首地址上。也就是说，链接器将数组的首地址赋给了指针本身，而不是我们所希望的把数组的首地址赋予指针 a。原因在于使用 extern 修饰的变量在链接的时候只找寻同名的标号，不检查类型，在链接时才进行定位，所以会导致编译通过，运行时出错。</p>
<p>首先涉及到数组和指针的区别：<strong>可以将数组名看做是右值，而指针作为变量，只能看作为左值。</strong> <strong>右值永远不等于左值，所以将指针赋予数组名是不合法的。即</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">// 声明一个包含三个整数的数组</span></span><br><span class="line">    <span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]; <span class="comment">// 分配一个新的整数数组，并将其地址赋值给指针</span></span><br><span class="line">    <span class="comment">// 尝试将指针赋值给数组名（不合法）</span></span><br><span class="line">    arr = ptr;</span><br><span class="line">    <span class="keyword">delete</span>[] ptr; <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-中map的实现包含哪些方式？具体应该如何选择？"><a href="#C-中map的实现包含哪些方式？具体应该如何选择？" class="headerlink" title="C++中map的实现包含哪些方式？具体应该如何选择？"></a>C++中map的实现包含哪些方式？具体应该如何选择？</h3><ul>
<li><code>std::map</code>：通常使用红黑树实现，保证了元素按照键的排序，适合需要有序数据的场景。</li>
<li><code>std::unordered_map</code>：使用哈希表实现，不保证元素的有序性，但在许多操作上提供了较快的执行时间。</li>
</ul>
<p>因此，（1）如果应用中需要一个通过键快速访问数据项且不关心元素间的顺序的关联容器，<code>std::unordered_map</code> 是一个更好的选择；（2）而如果需要有序的键值对，维护元素的插入顺序，或需要进行范围查询，那么 <code>std::map</code> 是更合适的选择。</p>
<h3 id="map和set保存的元素有什么区别？"><a href="#map和set保存的元素有什么区别？" class="headerlink" title="map和set保存的元素有什么区别？"></a>map和set保存的元素有什么区别？</h3><p>（1）map保存的是键值对元素，其中key是不能重复的，一旦重复将对value进行覆盖。只能通过key来访问value。</p>
<p>（2）set保存的元素是无序的，且元素也是不能重复的。只能通过迭代器遍历访问set。</p>
<h3 id="map的插入方式和访问方式有哪些？"><a href="#map的插入方式和访问方式有哪些？" class="headerlink" title="map的插入方式和访问方式有哪些？"></a>map的插入方式和访问方式有哪些？</h3><ul>
<li><p>插入方式：</p>
<p>（1）operator []；（2）emplace()；（3）insert()。</p>
</li>
<li><p>访问方式：</p>
<p>（1）operator []；（2）使用at；（3）find()；（4）使用迭代器。</p>
</li>
</ul>
<h2 id="8、类的设计"><a href="#8、类的设计" class="headerlink" title="8、类的设计"></a>8、类的设计</h2><h3 id="传值和传引用应该如何选择？"><a href="#传值和传引用应该如何选择？" class="headerlink" title="传值和传引用应该如何选择？"></a>传值和传引用应该如何选择？</h3><p>（1）传递参数或返回值时，当需要传值的时候尽量传引用；</p>
<p>（2）但要注意，如果返回值是一个local对象，那么就不能传引用；</p>
<p>（3）最后还要注意是否需要加const关键字。如果需要确保传递的对象不能被修改，就加上const。</p>
<p><strong>【】相同class的各个objects互为friends。</strong></p>
<p><strong>【】通过每个类自己的this pointer不同的地址来取到不同的对象。</strong></p>
<p><strong>【】类的静态成员变量需要在类的外部进行定义，但是给不给初值都可以</strong></p>
<p><strong>【】不带指针的类大多数不需要写析构函数</strong></p>
<p><strong>【】typename() 可以创建一个临时对象</strong></p>
<h1 id="二、操作系统"><a href="#二、操作系统" class="headerlink" title="二、操作系统"></a>二、操作系统</h1><h2 id="1、线程与进程"><a href="#1、线程与进程" class="headerlink" title="1、线程与进程"></a>1、线程与进程</h2><h3 id="进程和线程以及并发和并行的概念是什么？"><a href="#进程和线程以及并发和并行的概念是什么？" class="headerlink" title="进程和线程以及并发和并行的概念是什么？"></a>进程和线程以及并发和并行的概念是什么？</h3><p>（1）线程是操作系统中的最小执行单元，进程是程序的一次执行过程，是系统资源分配的最小单位。并发是指多个任务交替执行，而并行是指多个任务同时执行。</p>
<p>（2）并发是在单个处理器上实现多个线程同时执行的假象，而并行是在多个处理器上实现多个线程同时执行。</p>
<h3 id="线程内存存储在哪里？"><a href="#线程内存存储在哪里？" class="headerlink" title="线程内存存储在哪里？"></a>线程内存存储在哪里？</h3><ol>
<li><strong>线程栈</strong>（Thread Stack）：每个线程都有自己的栈空间，这是线程存储本地变量、函数参数和返回地址的地方。线程栈通常有固定的大小，这个大小可以在创建线程时指定，也可能由操作系统预设。这部分内存通常位于用户空间的栈内存中。</li>
<li><strong>线程堆</strong>（Thread Heap）：虽然线程可以访问进程级的堆（共享资源），但它们通常不拥有私有的堆空间。然而，线程可以通过特定的内存分配策略（如使用线程局部存储）在堆上分配数据，这些数据只对分配它的线程可见。</li>
<li><strong>寄存器集</strong>：包括程序计数器、堆栈指针和其他必要的硬件寄存器。这些通常是在处理器内部维护的，并且每个线程都有自己的寄存器状态。</li>
<li><strong>线程局部存储（TLS）</strong>：这是一种允许数据在多个线程之间被隔离的机制。每个线程可以访问自己的专用数据副本，对其他线程不可见。这在编程中用于保持数据的线程安全性。</li>
<li><strong>线程控制块（TCB）</strong>：这是一个内核数据结构，包含了管理线程所需的所有信息，如线程的状态、优先级、调度信息等。线程控制块通常存储在操作系统内核的内存中。</li>
</ol>
<p>这些部分合在一起定义了一个线程的运行环境。每个线程的栈是独立的，但它们共享进程的堆和其他全局资源。</p>
<h3 id="Linux的Fork怎么实现的？"><a href="#Linux的Fork怎么实现的？" class="headerlink" title="Linux的Fork怎么实现的？"></a>Linux的Fork怎么实现的？</h3><ol>
<li><strong>复制进程结构</strong>：<ul>
<li>当一个进程调用 <code>fork()</code> 时，内核首先为新的子进程创建一个进程控制块（Process Control Block, PCB），它包含了父进程的诸多属性的复制，如进程状态、程序计数器、CPU寄存器、环境设置、栈、内存段的权限等。</li>
</ul>
</li>
<li><strong>写时复制（Copy-on-Write, CoW）</strong>：<ul>
<li>在早期的UNIX系统中，<code>fork()</code> 会复制父进程的整个地址空间到子进程中，这种做法在资源消耗和效率上是非常昂贵的。现代的Linux使用了写时复制技术（CoW），这意味着父进程和子进程会共享相同的物理内存页面，只有在其中一个进程需要修改内存时，才会真正复制那个内存页面。</li>
<li>这种方法减少了 <code>fork()</code> 的开销，因为复制动作仅在必要时发生，并且只复制被修改的部分。</li>
</ul>
</li>
<li><strong>分配唯一的进程标识符（PID）</strong>：<ul>
<li>子进程会被赋予一个新的、唯一的进程标识符（PID）。</li>
</ul>
</li>
<li><strong>复制文件描述符</strong>：<ul>
<li>如果父进程打开了文件或网络连接，这些文件描述符也会被复制到子进程中。默认情况下，它们指向相同的文件表项，即父子进程会共享文件指针，但是可以通过调用<code>dup()</code>等操作独立管理。</li>
</ul>
</li>
<li><strong>返回值</strong>：<ul>
<li>在父进程中，<code>fork()</code> 返回新创建的<strong>子进程的PID</strong>。</li>
<li>在子进程中，<code>fork()</code> 返回<strong>0</strong>。</li>
<li>如果出错，例如因为内存不足或达到了系统对进程数的限制，<code>fork()</code> 会返回一个<strong>负值</strong>。</li>
</ul>
</li>
</ol>
<h3 id="线程中的锁包含哪些？"><a href="#线程中的锁包含哪些？" class="headerlink" title="线程中的锁包含哪些？"></a>线程中的锁包含哪些？</h3><p>（1）互斥锁：用于对共享资源的互斥访问。当有线程对该资源加了互斥锁后，其他线程尝试加锁时会被阻塞，直至锁被释放。</p>
<p>（2）递归锁：是一种特殊的互斥锁，当有同一个线程尝试对同一个线程不断加锁时，不会被阻塞。</p>
<p>（3）读写锁：允许多个线程同时进行读操作，但仅允许一个线程进行写操作，使用的读多于写的场景。</p>
<p>（4）自旋锁：当有线程对资源加了自旋锁后，其他线程尝试加锁时将忙等待，而非被阻塞。</p>
<h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>死锁（Deadlock）是指在多线程或多进程的环境中，两个或多个执行单元因为争夺资源而造成的一种相互等待的现象，如果没有外力干涉，这些进程将无法向前推进。</p>
<h3 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h3><p>死锁产生主要有以下几个条件，这些条件同时满足时，就可能发生死锁：</p>
<ol>
<li><strong>互斥条件</strong>：资源不能被多个线程（或进程）共享，只能被一个线程（或进程）所占用。</li>
<li><strong>请求与保持条件</strong>：线程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他线程占有。</li>
<li><strong>不剥夺条件</strong>：线程所获得的资源在未使用完之前，不能被其他线程强行剥夺。</li>
<li><strong>循环等待条件</strong>：存在一种线程资源循环等待链，每个线程占有一种资源并等待另一种被下一个线程占有的资源。</li>
</ol>
<h3 id="如何发现程序出现死锁？"><a href="#如何发现程序出现死锁？" class="headerlink" title="如何发现程序出现死锁？"></a>如何发现程序出现死锁？</h3><ol>
<li><strong>运行时诊断</strong>：<ul>
<li>使用操作系统提供的工具进行线程分析。例如，Linux下的<code>ps</code>和<code>top</code>命令可以帮助观察线程的状态，查看是否有线程处于不正常的等待状态。</li>
<li>使用GDB等调试器检查运行时线程的状态和锁的占用情况。通过查看线程的堆栈跟踪，可以了解它们当前在等待什么资源。</li>
</ul>
</li>
<li><strong>日志记录</strong>：<ul>
<li>在代码中添加日志记录，尤其是在获取和释放锁的操作前后记录详细信息。这有助于追踪锁的使用情况和线程的执行流程。</li>
<li>分析日志文件以查找可能的死锁模式，如重复的锁请求和长时间未释放的锁。</li>
</ul>
</li>
<li><strong>专用工具</strong>：<ul>
<li>使用专门的线程分析工具，如Valgrind的Helgrind工具，它可以在运行时检测死锁及其他同步问题。</li>
<li>使用像ThreadSanitizer这样的动态分析工具，这些工具能够在执行期间检测数据竞争和死锁。</li>
</ul>
</li>
</ol>
<h3 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h3><p>避免死锁的策略主要包括预防、避免和检测及恢复。以下是一些常见的避免死锁的方法：</p>
<ol>
<li>尽可能将资源设置为可以共享，这在实际中可能较难实现，因为某些资源本身就是不可共享的。</li>
<li>一次性申请所有需要的资源，不再分步申请；只有当所有请求的资源都得到满足时，线程才开始执行。</li>
<li>如果一个已经持有某些资源的线程进一步申请其他资源时被拒绝，则释放它原先持有的资源。允许剥夺已分配的资源，重新分配给其他线程。</li>
<li>对所有资源类型进行排序，强制每个线程按顺序申请资源。</li>
<li>线程尝试锁定资源时添加超时时间，超时未能锁定资源则释放已占有的资源并重新尝试。</li>
<li>设计时确保所有线程获取锁的顺序一致，避免循环等待。</li>
</ol>
<h3 id="多线程怎么保证线程安全？"><a href="#多线程怎么保证线程安全？" class="headerlink" title="多线程怎么保证线程安全？"></a>多线程怎么保证线程安全？</h3><p>一般会使用原子操作和互斥锁来确保多线程环境下的线程安全性。</p>
<h3 id="多线程环境下对变量的读写操作是否是原子的？内部是怎么实现的？"><a href="#多线程环境下对变量的读写操作是否是原子的？内部是怎么实现的？" class="headerlink" title="多线程环境下对变量的读写操作是否是原子的？内部是怎么实现的？"></a>多线程环境下对变量的读写操作是否是原子的？内部是怎么实现的？</h3><p>在多线程环境下，对变量的读写操作默认并不是原子的，除非使用特定的机制或工具来确保操作的原子性。</p>
<p>（1）CAS（Compare-And-Swap）操作是一种重要的同步机制，用来实现原子操作。它涉及三个操作数：</p>
<ul>
<li>内存位置（V）：要更新的变量的地址；</li>
<li>期望值（E）：预期变量当前应该拥有的值；</li>
<li>新值（N）：如果变量的当前值与期望值相匹配，应该赋给变量的新值。</li>
</ul>
<p>（2）CAS 操作的步骤如下：</p>
<ul>
<li>首先检查内存位置的当前值是否与期望值相等。</li>
<li>如果相等，就将新值写入到内存位置。</li>
<li>返回之前内存位置上的值。</li>
</ul>
<p>如果原始值与期望值相等，更新成功；如果不相等，表示其他线程已经修改了该位置的数据，更新失败。</p>
<p>（3）CAS 的内部实现</p>
<p>底层实现通常依赖于处理器提供的特定指令集。例如，在 x86 架构中，CAS 通常是通过 <code>CMPXCHG</code> 指令实现的。这个指令原子地比较寄存器的值与内存位置的值，如果相同，则将新值写入内存位置。整个操作是原子的，意味着在执行过程中不会被其他线程的指令中断。</p>
<h3 id="如何实现一个线程池？"><a href="#如何实现一个线程池？" class="headerlink" title="如何实现一个线程池？"></a>如何实现一个线程池？</h3><p>线程池是一组预先创建好的线程，用于执行多个任务。它可以提高任务调度的效率和性能。实现一个线程池可以使用 C++11 提供的 std::thread和 std::mutex 等多线程库，结合队列等数据结构来管理任务的提交和执行。</p>
<h3 id="一个线程池中最重要的部分是什么？"><a href="#一个线程池中最重要的部分是什么？" class="headerlink" title="一个线程池中最重要的部分是什么？"></a>一个线程池中最重要的部分是什么？</h3><p>我认为线程池中最重要的部分是任务队列和线程池管理策略：</p>
<ul>
<li><strong>任务队列</strong>：它是线程池的核心，因为所有的任务都需要通过这个队列进行调度。队列的设计（如是否阻塞、优先级如何处理等）直接影响线程池的效率和公平性。</li>
<li><strong>线程池管理策略</strong>：包括线程池的大小管理、线程的创建与销毁、负载均衡和异常处理等。管理策略决定了线程池如何响应不同的负载情况，以及如何有效地利用系统资源，避免过载或资源浪费。</li>
</ul>
<h3 id="线程池中的线程数量是保持不变的吗？"><a href="#线程池中的线程数量是保持不变的吗？" class="headerlink" title="线程池中的线程数量是保持不变的吗？"></a>线程池中的线程数量是保持不变的吗？</h3><p>不一定。线程池有固定大小的线程池和动态大小的线程池两种。</p>
<h3 id="线程池如何优化？"><a href="#线程池如何优化？" class="headerlink" title="线程池如何优化？"></a>线程池如何优化？</h3><ol>
<li><strong>动态调整线程数目</strong>：根据任务的实际负载动态调整线程池中的线程数量。当任务量增加时增加线程数，任务量减少时减少线程数，以保证资源的合理使用并避免过载或资源闲置。</li>
<li><strong>任务队列优化</strong>：优化任务队列的管理方式，如选择合适的数据结构（例如优先队列）以支持优先级调度，确保紧急任务能够优先处理。</li>
<li><strong>线程生命周期管理</strong>：管理线程的生命周期，避免频繁地创建和销毁线程。可以设置线程的最大空闲时间，超过这个时间线程则自动销毁。</li>
<li><strong>监控和调试</strong>：实现监控机制来监控线程池的性能，如任务等待时间、任务执行时间、线程利用率等，以便及时发现问题并进行调整。</li>
</ol>
<h3 id="多线程是怎么处理许多个任务一起到来的？"><a href="#多线程是怎么处理许多个任务一起到来的？" class="headerlink" title="多线程是怎么处理许多个任务一起到来的？"></a>多线程是怎么处理许多个任务一起到来的？</h3><ol>
<li><strong>任务分配</strong>：当多个任务同时到来时，这些任务通常被添加到一个<strong>共享的任务队列</strong>中。这个队列可以被所有的线程访问。线程池中的每个线程会从这个队列中取出任务并执行。</li>
<li><strong>并行处理</strong>：在多核处理器上，多个线程可以被同时调度到不同的核上执行。这样，多个任务可以实际上同时进行，这极大地提高了处理效率和程序的响应速度。</li>
<li><strong>上下文切换</strong>：当某个线程等待（例如，等待I&#x2F;O操作完成）时，操作系统可以执行上下文切换，让其他的线程运行。这样可以确保CPU的使用效率最大化，即使某些线程暂时不能进行计算也不会浪费CPU资源。</li>
<li><strong>同步机制</strong>：在多线程环境中，可能需要对共享资源进行访问控制，以避免数据不一致或竞态条件。常用的同步机制包括互斥锁、条件变量、读写锁等。这些机制帮助确保即使多个线程尝试同时访问同一资源，程序的行为也是正确和可预测的。</li>
</ol>
<h3 id="多线程切换，cpu和内存会做一些什么处理"><a href="#多线程切换，cpu和内存会做一些什么处理" class="headerlink" title="多线程切换，cpu和内存会做一些什么处理"></a>多线程切换，cpu和内存会做一些什么处理</h3><p>在多线程环境下，当操作系统进行线程切换时，CPU 和内存会做一些处理：</p>
<ol>
<li><strong>保存当前线程的上下文：</strong> 当一个线程被抢占时，CPU 会保存当前线程的上下文信息，包括程序计数器（PC）、寄存器状态、栈指针（SP）等。这样做是为了在之后恢复线程时能够继续执行。</li>
<li><strong>加载下一个线程的上下文：</strong> CPU 根据调度算法选择下一个需要执行的线程，然后加载其上下文信息到寄存器和其他硬件状态中。</li>
<li><strong>切换内存空间：</strong> 在多线程环境下，不同线程可能会访问不同的内存区域。因此，在线程切换时，操作系统需要更新页表（Page Table）等内存映射表，以确保下一个线程能够访问到正确的内存空间。</li>
<li><strong>处理器流水线的清空和填充：</strong> 在 CPU 进行线程切换时，可能存在流水线（Pipeline）中的指令未执行完毕。在切换时，CPU 可能需要将流水线清空，以避免对新线程执行的指令产生影响。</li>
<li><strong>更新调度器信息：</strong> 操作系统需要更新线程的调度信息，包括线程的状态（就绪、运行、阻塞等），以及相关的时间片（Time Slice）等调度参数。</li>
</ol>
<h3 id="如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？"><a href="#如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？" class="headerlink" title="如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？"></a>如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？</h3><p>首先判断这个请求数量远远多于线程是常态吗，如果是常态则先要考虑是不是线程数量设置有问题，然后判断机器是否能力不足以处理这些数据。</p>
<p>假如说硬件软件都没有问题，那么考虑这个问题为什么会产生，是不是我们的高计算密集型任务太多了，如果说我们的请求任务比较复杂，那么考虑进行一个分类，将处理特别慢的请求作为一个特定类，将一些线程固定给他们使用，而不是所有线程都用来处理这种任务，因为既然很慢，那么慢1个和慢10个点区别就没有那么大了，将其他线程用来处理能够快速处理完的请求。</p>
<h3 id="线程间的通信包括哪些方式？"><a href="#线程间的通信包括哪些方式？" class="headerlink" title="线程间的通信包括哪些方式？"></a>线程间的通信包括哪些方式？</h3><ol>
<li><strong>共享内存</strong>：线程间共享相同的内存空间，可以通过共享变量进行通信，需要同步机制（如互斥锁、信号量等）来防止数据竞争和保证一致性。</li>
<li><strong>互斥锁（Mutex）</strong>：用于控制多个线程对共享资源的访问，保证同一时间只有一个线程可以访问资源。</li>
<li><strong>条件变量</strong>：用于线程间的同步，允许一个或多个线程在某些条件下暂停执行并等待，直到另一个线程通知它们条件已经满足。</li>
<li><strong>信号量（Semaphores）</strong>：用于控制对共享资源的访问数量。信号量维护了一个计数器，表示可用资源的数量，线程在进入临界区前必须获取信号量。</li>
<li><strong>事件（Event）</strong>：类似于条件变量，用于通知一个或多个正在等待的线程某个事件已经发生。</li>
<li><strong>消息队列</strong>：线程可以发送和接收消息，消息以队列的形式管理。消息队列允许线程以异步的方式进行数据交换和事件通知。</li>
<li><strong>屏障（Barriers）</strong>：用于多个线程同步到某一点，当所有线程都达到屏障点后，它们再同时开始执行后续操作。常用于并行计算，确保所有线程在进行下一步操作前已完成当前操作。</li>
</ol>
<h3 id="线程同步是什么？从底层原理分析一下为什么会出现线程同步？"><a href="#线程同步是什么？从底层原理分析一下为什么会出现线程同步？" class="headerlink" title="线程同步是什么？从底层原理分析一下为什么会出现线程同步？"></a>线程同步是什么？从底层原理分析一下为什么会出现线程同步？</h3><p>（1）线程同步是多线程编程中保证多个线程安全访问共享资源或协调工作的一种机制。它确保在任何给定时刻，只有一个线程可以访问特定的数据或代码块，以防止数据损坏或不一致性。线程同步通常通过使用各种同步原语（如互斥锁、信号量、条件变量等）来实现。</p>
<p>（2）底层原理上，线程同步问题主要是由于以下几个因素导致的：</p>
<ol>
<li>并发性：多个线程同时执行，导致对共享资源的访问不可控。</li>
<li>不确定性：线程的执行顺序和执行时间不确定，可能导致对共享资源的交叉访问。</li>
<li>原子性：对共享资源的操作可能不是原子操作，而是由多条指令组成，这会导致中间状态的出现，从而引发问题。</li>
</ol>
<h3 id="处理多线程同步问题有哪些机制？举例来说信号量如何实现？他们一般会调用到什么样的函数？如果想等待线程a执行完任务后再去执行b，这种情况要怎么处理？"><a href="#处理多线程同步问题有哪些机制？举例来说信号量如何实现？他们一般会调用到什么样的函数？如果想等待线程a执行完任务后再去执行b，这种情况要怎么处理？" class="headerlink" title="处理多线程同步问题有哪些机制？举例来说信号量如何实现？他们一般会调用到什么样的函数？如果想等待线程a执行完任务后再去执行b，这种情况要怎么处理？"></a>处理多线程同步问题有哪些机制？举例来说信号量如何实现？他们一般会调用到什么样的函数？如果想等待线程a执行完任务后再去执行b，这种情况要怎么处理？</h3><p>在处理多线程同步问题时，常用的机制包括互斥锁（Mutex）、条件变量（Condition Variable）、信号量（Semaphore）等。下面简要介绍一下信号量的实现和处理方式，并举例说明如何使用。</p>
<p>（1）信号量（Semaphore）</p>
<p>信号量是一种用于多线程同步的机制，它可以用来控制对临界资源的访问。信号量维护了一个计数器，表示可用资源的数量，线程在访问临界资源之前必须先获取信号量，如果信号量计数器大于零，则线程可以获取资源并将计数器减一；如果计数器等于零，则线程将被阻塞，直到有其他线程释放资源并增加计数器。当线程使用完资源后，需要释放信号量，使计数器加一，以便其他线程可以继续访问资源。</p>
<p>（2）等待线程A执行完任务后再执行线程B的处理方式</p>
<p>在示例中，使用了条件变量 <code>std::condition_variable</code> 来等待线程A执行完任务后再执行线程B。线程A在等待条件时会调用 <code>cv.wait(lock, predicate)</code> 函数，其中 <code>predicate</code> 是一个lambda表达式，表示等待的条件。线程B在执行完任务后调用 <code>cv.notify_one()</code> 函数来发送信号给等待中的线程A，从而唤醒线程A并开始执行任务。</p>
<h3 id="进程的五种状态分别是？"><a href="#进程的五种状态分别是？" class="headerlink" title="进程的五种状态分别是？"></a>进程的五种状态分别是？</h3><p>1）就绪态：所有运行条件已就绪，只要得到了CPU时间就可运行。</p>
<p>2）运行态：得到CPU时间正在运行；</p>
<p>3）僵尸态：进程已经结束了但父进程还没来得及回收；</p>
<p>4）等待态：包括浅度睡眠跟深度睡进程在等待某种条件，条件成熟后即是就绪态。浅度睡眠时进程可以被信号唤醒，但深度睡眠时必须等到条件成熟后才能结束睡眠状态。</p>
<p>5）暂停态：暂时停止参与CPU调度（即使条件成熟），可以恢复。</p>
<h3 id="两个进程的内核空间是共享的吗？"><a href="#两个进程的内核空间是共享的吗？" class="headerlink" title="两个进程的内核空间是共享的吗？"></a>两个进程的内核空间是共享的吗？</h3><p>在大多数现代操作系统中，包括Linux和Windows，内核空间是在所有进程之间共享的。这意味着内核空间中的代码和数据结构对所有进程来说都是相同的，并且在任何时候都位于相同的物理内存位置。</p>
<h3 id="如何让进程后台运行？"><a href="#如何让进程后台运行？" class="headerlink" title="如何让进程后台运行？"></a>如何让进程后台运行？</h3><ol>
<li><p><strong>使用 &amp; 符号</strong>：</p>
<ul>
<li><p>在命令行中，在命令的末尾加上 <code>&amp;</code> 符号，可以让该命令在后台执行。</p>
</li>
<li><p>例如，要让 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python script.py</span><br></pre></td></tr></table></figure>

<p> 在后台运行，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">python script.py &amp;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用 nohup 命令</strong>：</p>
<ul>
<li><p><code>nohup</code> 命令用于将程序以忽略挂断信号的方式运行，这样即使终端关闭，程序也会继续在后台运行。</p>
</li>
<li><p>使用方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line"><span class="built_in">nohup</span> python script.py &amp;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="进程间的通信包括哪些方式？"><a href="#进程间的通信包括哪些方式？" class="headerlink" title="进程间的通信包括哪些方式？"></a>进程间的通信包括哪些方式？</h3><p>（1）管道，半双工的通信方式，可以在父子进程间进行数据传递。通常用于具有亲缘关系的进程之间的通信。</p>
<p>（2）命名管道，与普通管道类似，但可以在无亲缘关系的进程之间使用。命名管道通过文件系统进行通信。</p>
<p>（3）消息队列，允许一个或多个进程向队列中发送消息，并从队列中接收消息。消息队列通常用于在不同进程之间传递结构化的数据。</p>
<p>（4）信号量，控制进程间访问共享资源的机制，可以用来解决进程同步和互斥的问题，防止竞态条件的发生。</p>
<p>（5）共享内存，允许多个进程共享同一块内存区域，进程可以直接读写共享内存中的数据。</p>
<p>（6）套接字，适用于在不同主机和不同进程之间进行通信，通常用于网络编程。</p>
<h3 id="进程间的通信，哪个通信方式效率最高"><a href="#进程间的通信，哪个通信方式效率最高" class="headerlink" title="进程间的通信，哪个通信方式效率最高"></a>进程间的通信，哪个通信方式效率最高</h3><p>1、<strong>共享内存（Shared Memory）</strong>:</p>
<ul>
<li><strong>效率</strong>: 最高</li>
<li><strong>原因</strong>: 共享内存允许多个进程访问同一块内存区域，没有数据复制的开销，因此通信速度非常快。不过，需要额外的同步机制（如信号量或互斥锁）来防止并发访问问题。</li>
</ul>
<p>2、<strong>消息队列（Message Queues）</strong>:</p>
<ul>
<li><strong>效率</strong>: 中等</li>
<li><strong>原因</strong>: 消息队列提供了一种从一个进程向另一个进程发送数据包的方法，数据在发送过程中需要被复制到和从内核空间，这增加了开销，但它提供了比共享内存更好的数据管理和安全性。</li>
</ul>
<p>3、<strong>管道（Pipes）和命名管道（Named Pipes&#x2F;FIFOs）</strong>:</p>
<ul>
<li><strong>效率</strong>: 较低</li>
<li><strong>原因</strong>: 数据需要在发送进程和接收进程之间进行复制，且管道通常是半双工的，这限制了通信的灵活性和效率。</li>
</ul>
<p>4、<strong>套接字（Sockets）</strong>:</p>
<ul>
<li><strong>效率</strong>: 低到中等</li>
<li><strong>原因</strong>: 套接字支持网络层面的通信，即使是在同一台机器上的进程间通信也涉及到网络协议栈，这增加了额外的开销。但套接字非常灵活，支持包括TCP和UDP在内的多种协议。</li>
</ul>
<h3 id="信号量与互斥锁的区别？"><a href="#信号量与互斥锁的区别？" class="headerlink" title="信号量与互斥锁的区别？"></a>信号量与互斥锁的区别？</h3><ol>
<li><strong>互斥锁</strong>：用于线程的互斥，即在同一时间内只允许一个线程访问某个资源。互斥锁保证了资源的唯一性和排他性。当一个线程获得互斥锁时，其他试图访问被锁保护的资源的线程将被阻塞，直到锁被释放。</li>
<li><strong>信号量</strong>：用于线程的同步，可以允许多个线程根据信号量的值同时访问同一资源或一组资源。信号量主要用于控制资源的可用数量。信号量有一个计数器，表示可用资源的数量。线程在访问资源前需要先获得信号量（计数器减1），如果信号量的值为0，则线程进入等待状态。当资源释放时，信号量计数器增加，等待的线程可以继续执行。</li>
</ol>
<h3 id="信号量和互斥锁解决父子线程同时阻塞的区别"><a href="#信号量和互斥锁解决父子线程同时阻塞的区别" class="headerlink" title="信号量和互斥锁解决父子线程同时阻塞的区别"></a>信号量和互斥锁解决父子线程同时阻塞的区别</h3><p>假设有一个场景，其中父线程和子线程需要按特定顺序访问某个资源（例如，父线程需要等待子线程完成某个任务后才能继续执行）。</p>
<ul>
<li><strong>使用互斥锁</strong>：如果使用互斥锁，你可能需要配合条件变量来实现这种顺序控制。互斥锁本身只能保证互斥，不能控制线程之间的执行顺序。父线程需要在条件变量上等待一个特定条件（通常由子线程设置）。</li>
<li><strong>使用信号量</strong>：信号量可以更直接地控制执行顺序。例如，可以初始化一个信号量为0。父线程在尝试访问资源之前会首先对信号量执行等待操作，由于信号量的初始值是0，所以父线程会阻塞。子线程在完成其任务后对信号量执行信号操作，从而增加信号量的值并解除父线程的阻塞。这样，子线程可以直接通过信号量控制父线程的执行。</li>
</ul>
<h3 id="使用共享内存的时候需要注意什么呢？"><a href="#使用共享内存的时候需要注意什么呢？" class="headerlink" title="使用共享内存的时候需要注意什么呢？"></a>使用共享内存的时候需要注意什么呢？</h3><p>对共享资源的访问需要注意临界变量的保护，利用锁机制互斥访问，保证运行结果一致性</p>
<h2 id="2、内存模型-虚拟内存"><a href="#2、内存模型-虚拟内存" class="headerlink" title="2、内存模型&#x2F;虚拟内存"></a>2、内存模型&#x2F;虚拟内存</h2><h3 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h3><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
<h3 id="为什么操作系统要使用虚拟内存？"><a href="#为什么操作系统要使用虚拟内存？" class="headerlink" title="为什么操作系统要使用虚拟内存？"></a>为什么操作系统要使用虚拟内存？</h3><ol>
<li>虚拟内存允许系统使用硬盘空间来模拟额外的RAM，这样应用程序就可以使用比实际物理内存更多的内存空间。这对于运行内存需求大于物理内存的应用程序特别有用。</li>
<li>每个进程都有自己独立的虚拟地址空间，这意味着一个进程不能直接访问另一个进程的内存空间。这种隔离提高了系统的安全性，因为它阻止了进程间的意外或恶意的内存访问。</li>
<li>虚拟内存简化了内存的管理，因为每个进程都可以认为自己在使用一大块连续的内存区域。这使得程序的编写和调试变得更加简单，因为程序员不需要考虑内存碎片或其他内存布局问题。</li>
<li>虚拟内存可以更方便地在不同进程之间共享内存。例如，多个进程可以映射到相同的物理内存，实现共享库等数据的共享，从而节约内存。</li>
</ol>
<h3 id="一个由C-C-编译的程序的内存分布（内存模型）？"><a href="#一个由C-C-编译的程序的内存分布（内存模型）？" class="headerlink" title="一个由C&#x2F;C++编译的程序的内存分布（内存模型）？"></a>一个由C&#x2F;C++编译的程序的内存分布（内存模型）？</h3><p>其内存分布或内存模型实际上就是虚拟内存。主要分为以下几个部分，分别是：<br>.text段，.rodata段，.data段，.bss段，堆，内存映射区，栈，内核空间。<br>其中，各项主要内容如下：<br>（1）.text段主要存在程序编译后的机器指令<br>（2）.rodata段主要存放程序中的各种只读变量<br>（3）.data段主要存放已经被初始化了的全局静态变量和局部静态变量<br>（4）.bss段主要存放未被初始化的全局静态变量和局部静态变量<br>（5）堆：由程序员进行动态分配，如调用malloc或new<br>（6）栈：由编译器自动分配释放，存放一些局部变量等<br>（7）内核空间：存放操作系统的一些内核数据和代码</p>
<h3 id="为什么要区分代码段和数据段？"><a href="#为什么要区分代码段和数据段？" class="headerlink" title="为什么要区分代码段和数据段？"></a>为什么要区分代码段和数据段？</h3><ul>
<li><strong>访问权限控制</strong>：代码段通常设置为只读，以防止程序代码被意外或恶意修改，这可能导致程序行为不正确或系统安全受到威胁。数据段则通常需要读写权限，因为程序在运行时需要修改数据。</li>
<li><strong>防止代码注入</strong>：通过将代码段设置为只读，可以防止恶意代码注入和执行，这是提高系统安全性的重要措施。</li>
<li><strong>分页策略</strong>：代码段和数据段可能会采用不同的分页和交换策略。例如，代码页可能较少交换出内存，因为它们被频繁访问；而数据段的某些部分如果使用不频繁可以被交换出去以节约资源。</li>
</ul>
<h3 id="什么时候用栈，什么时候用堆？"><a href="#什么时候用栈，什么时候用堆？" class="headerlink" title="什么时候用栈，什么时候用堆？"></a>什么时候用栈，什么时候用堆？</h3><p>1.与堆相比，栈不会导致内存碎片，分配效率高。函数调用过程中的参数，返回地址和局部变量都采取栈的形式存放，<strong>如果少量数据需要频繁的操作，那么在程序中动态申请少量栈内存会获得很好的性能提升。</strong></p>
<p>2.堆可以申请的内存大很多，与堆相比，栈的使用没那么灵活，<strong>如果分配大量的内存空间，推荐使用堆内存。</strong></p>
<h3 id="不同段上的对象的生命周期是怎样的？"><a href="#不同段上的对象的生命周期是怎样的？" class="headerlink" title="不同段上的对象的生命周期是怎样的？"></a>不同段上的对象的生命周期是怎样的？</h3><p>（1）.data&#x2F;.bss段的生命周期和程序的生命周期一致，在程序加载到内存时被分配，程序结束时被销毁<br>（2）堆上的对象由程序员进行动态分配<br>（3）栈上的对象由编译器进行分配，当离开作用域范围时被编译器销毁</p>
<h3 id="如何让对象只能存在于栈-堆中？"><a href="#如何让对象只能存在于栈-堆中？" class="headerlink" title="如何让对象只能存在于栈&#x2F;堆中？"></a>如何让对象只能存在于栈&#x2F;堆中？</h3><p>如果将operator new设置为私有的，此时尝试在堆上分配内存失败，对象就会存在于栈中。<br>由于编译器在栈上分配内存时会自动调用其构造函数和析构函数，因此如果将析构函数设置为私有的，在栈上分配内存失败，对象就会存在于堆中。</p>
<h3 id="new和malloc的区别？"><a href="#new和malloc的区别？" class="headerlink" title="new和malloc的区别？"></a>new和malloc的区别？</h3><p>主要包含以下区别：<br>（1）new是c++特有的操作符，只能在C++中使用；malloc是C中的函数，但可以同时在c&#x2F;c++中使用。<br>（2）malloc在使用时需要指定分配内存的大小，如malloc(sizeof(int))，但new的使用则比较简洁，如new int。<br>（3）malloc分配的内存是未定义的，而new在分配内存时还会调用构造函数进行初始化。<br>（4）malloc返回的是void *类型的指针，需要进行强制类型转换以得到需要的指针类型，而new会自动转换为响应的指针类型。<br>（5）malloc调用free进行释放， ew调用delete进行释放。</p>
<h3 id="malloc函数的底层实现是什么？"><a href="#malloc函数的底层实现是什么？" class="headerlink" title="malloc函数的底层实现是什么？"></a>malloc函数的底层实现是什么？</h3><p>（1）当开辟的空间小于128kb时，调用brk()函数，先遍历空闲内存链表，如果有已释放且空间足够的内存块就拿来用。如果找不到就移动指针_enddata，即堆区的末尾地址。</p>
<p>（2）当开辟的空间大于128kb时，系统调用mmap()函数来在虚拟地址中找一块空间来开辟，即堆和栈中间的文件映射区域。</p>
<p>malloc()在分配用户传入大小的内存时，还分配一个用于管理的额外内存，大小为8字节。而由于堆中的内存是成块分配的，与内存对齐有关，在64为系统中，内存对齐为16字节，因此<strong>实际分配的内存大小还要考虑8字节的管理内存和内存对齐</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mem_control_block</span> &#123;</span><br><span class="line">    <span class="type">int</span> is_available;      <span class="comment">// 1表可用，0表不可用</span></span><br><span class="line">    <span class="type">int</span> size;                 <span class="comment">// 总大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="对于malloc分配的内存，调用free后立即释放吗？"><a href="#对于malloc分配的内存，调用free后立即释放吗？" class="headerlink" title="对于malloc分配的内存，调用free后立即释放吗？"></a>对于malloc分配的内存，调用free后立即释放吗？</h3><p>在使用 <code>brk</code> 或 <code>sbrk</code> 分配的情况下，这块内存并不会立即返还给操作系统，而是标记为可再利用状态。如果释放的是堆末端的内存，程序的断点可能会被回退，从而实际上将内存返还给操作系统。</p>
<p>而对于使用 <code>mmap</code> 分配的较大内存块，在调用 <code>free</code> 后通常会通过 <code>munmap</code> 立即返还给操作系统。</p>
<h3 id="既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么-malloc-不全部使用-mmap-来实现呢-mmap分配的内存可以会通过-munmap-进行-free-，实现真正释放-？而是仅仅对于大于-128k-的大块内存才使用-mmap-？"><a href="#既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么-malloc-不全部使用-mmap-来实现呢-mmap分配的内存可以会通过-munmap-进行-free-，实现真正释放-？而是仅仅对于大于-128k-的大块内存才使用-mmap-？" class="headerlink" title="既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么 malloc 不全部使用 mmap 来实现呢(mmap分配的内存可以会通过 munmap 进行 free ，实现真正释放)？而是仅仅对于大于 128k 的大块内存才使用 mmap ？"></a>既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么 malloc 不全部使用 mmap 来实现呢(mmap分配的内存可以会通过 munmap 进行 free ，实现真正释放)？而是仅仅对于大于 128k 的大块内存才使用 mmap ？</h3><p>进程向 OS 申请和释放地址空间的接口 sbrk&#x2F;mmap&#x2F;munmap 都是系统调用，<strong>频繁调用系统调用都比较消耗系统资源的</strong>。并且， mmap 申请的内存被 munmap 后，重新申请会产生更多的缺页中断。例如使用 mmap 分配 1M 空间，第一次调用产生了大量缺页中断  (1M&#x2F;4K 次 ) ，当munmap 后再次分配 1M 空间，会再次产生大量缺页中断。<strong>缺页中断是内核行为，会导致内核态CPU消耗较大。  另外，如果使用 mmap 分配小内存，会导致地址空间的分片更多，内核的管理负担更大。</strong></p>
<p>同时堆是一个连续空间，并且堆内碎片由于没有归还 OS ，<strong>如果可重用碎片，再次访问该内存很可能不需产生任何系统调用和缺页中断，这将大大降低  CPU 的消耗。</strong> 因此， glibc 的 malloc 实现中，充分考虑了 sbrk 和 mmap 行为上的差异及优缺点，默认分配大块内存  (128k) 才使用 mmap 获得地址空间。</p>
<h3 id="内存模型是什么？是指可执行文件中包含这些东西吗？"><a href="#内存模型是什么？是指可执行文件中包含这些东西吗？" class="headerlink" title="内存模型是什么？是指可执行文件中包含这些东西吗？"></a>内存模型是什么？是指可执行文件中包含这些东西吗？</h3><p>内存模型是指虚拟内存。<br>可执行文件中只包含.text .rodata和.data，不包含.bss、栈和堆。.bss段存放的是未初始化的全局静态变量和局部静态变量，在程序加载到内存中时，这些变量会被初始化为0或空指针，在生成可执行文件时不会占用内存空间。而栈和堆是动态加载的，只有在程序运行时才会分配。</p>
<h3 id="在已申请的内存中构造对象如何实现？"><a href="#在已申请的内存中构造对象如何实现？" class="headerlink" title="在已申请的内存中构造对象如何实现？"></a>在已申请的内存中构造对象如何实现？</h3><p>使用<code>placement new</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="built_in">sizeof</span>(MyClass)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在buffer指定的地址上构造MyClass对象</span></span><br><span class="line">MyClass* pMyClass = <span class="built_in">new</span> (buffer) <span class="built_in">MyClass</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动调用析构函数</span></span><br><span class="line">pMyClass-&gt;~<span class="built_in">MyClass</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>构造和析构</strong>：使用placement new构造对象后，必须手动调用该对象的析构函数来确保正确的资源释放。因为普通的<code>delete</code>操作符会尝试释放内存，这在使用placement new时是不适用的。</li>
<li><strong>对齐要求</strong>：需要确保传递给placement new的内存地址满足对象的对齐要求。</li>
<li><strong>内存管理</strong>：使用placement new的代码需要格外注意内存的管理，以避免内存泄露或重复析构等问题。</li>
</ul>
<h3 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h3><p>内存泄漏是指在程序运行过程中，已经分配的内存由于某种原因未能正确释放，导致这部分内存无法再次被使用。随着程序的运行，未释放的内存积累越来越多，最终可能导致程序性能下降或崩溃。</p>
<h3 id="C-对象的大小由哪些因素决定？"><a href="#C-对象的大小由哪些因素决定？" class="headerlink" title="C++对象的大小由哪些因素决定？"></a>C++对象的大小由哪些因素决定？</h3><p>（1）变量的类型和大小；</p>
<p>（2）内存对齐和填充；</p>
<p>（3）虚函数所带来的开销；</p>
<p>（4）空类优化。</p>
<h3 id="说一下你对于内存对齐的理解？"><a href="#说一下你对于内存对齐的理解？" class="headerlink" title="说一下你对于内存对齐的理解？"></a>说一下你对于内存对齐的理解？</h3><p>内存对齐是指对于特定类型的数据规定了其应该位于内存的哪个位置上。比如，对于int类型的数据，在32系统上要求其内存对齐为4个字节，也就是说其起始地址应该为4的倍数。</p>
<p>内存对齐的目的是为了提高内存访问的效率。因为在许多硬件平台上，访问对齐的内存要比访问不对齐的内存更快。</p>
<h3 id="内存对齐可能会带来哪些问题？"><a href="#内存对齐可能会带来哪些问题？" class="headerlink" title="内存对齐可能会带来哪些问题？"></a>内存对齐可能会带来哪些问题？</h3><p>（1）可能会造成内存浪费问题。虽然内存对齐后其内存访问速度会大幅提升，但随之而来的可能会造成一些内存浪费现象。</p>
<p>（2）可能存在平台不兼容的问题。不同类型的数据在不同的平台上可能有不能的内存对齐规则。</p>
<h3 id="什么方式可以不对齐内存，什么方式可以指定内存对齐大小？"><a href="#什么方式可以不对齐内存，什么方式可以指定内存对齐大小？" class="headerlink" title="什么方式可以不对齐内存，什么方式可以指定内存对齐大小？"></a>什么方式可以不对齐内存，什么方式可以指定内存对齐大小？</h3><p>（1）在C语言中，可以通过指针类型转换实现对任意内存地址的访问，从而实现不对齐的内存访问。例如，可以将一个地址强制转换为一个指针类型，然后通过该指针访问数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> data[] = &#123;<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>&#125;;</span><br><span class="line">    <span class="comment">// 假设我们需要访问从地址 &amp;data[1] 开始的一个整数，不考虑对齐</span></span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)(data + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p); <span class="comment">// 可能会导致性能下降或在某些硬件上引发错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）GCC和Clang等编译器支持<code>__attribute__((aligned(N)))</code>来指定内存对齐。</p>
<h3 id="swap分区"><a href="#swap分区" class="headerlink" title="swap分区"></a>swap分区</h3><p>Swap分区是操作系统中用于扩展物理内存（RAM）的一种机制。当系统的物理内存不足时，操作系统可以使用swap分区作为虚拟内存，将不活跃的内存页（即暂时不需要的数据）移出物理内存，存储到硬盘上的swap分区中。这样可以释放物理内存空间，供当前活跃的应用程序使用。</p>
<p>在Linux系统中，配置swap分区通常涉及以下步骤：</p>
<ul>
<li><strong>创建Swap分区</strong>：使用磁盘分区工具（如fdisk或parted）创建一个新的分区，并将其类型设置为swap。</li>
<li><strong>格式化Swap分区</strong>：使用<code>mkswap</code>命令格式化新创建的分区。</li>
<li><strong>启用Swap分区</strong>：使用<code>swapon</code>命令启用swap分区。</li>
<li><strong>配置自动挂载</strong>：在<code>/etc/fstab</code>文件中添加条目，以便在系统启动时自动启用swap分区。</li>
</ul>
<h3 id="虚拟地址怎么转换到物理地址？"><a href="#虚拟地址怎么转换到物理地址？" class="headerlink" title="虚拟地址怎么转换到物理地址？"></a>虚拟地址怎么转换到物理地址？</h3><ol>
<li><p><strong>分页机制</strong>，Linux使用分页机制来管理内存，这意味着虚拟内存和物理内存都被分割成固定大小的块，称为页（通常大小为4KB）。每个虚拟页通过页表映射到相应的物理页。</p>
</li>
<li><p><strong>页表</strong>，页表是一种数据结构，用于存储虚拟地址到物理地址的映射信息。每个进程都有自己的页表，这使得每个进程都有自己独立的虚拟地址空间。</p>
</li>
<li><p><strong>页表条目（PTE）</strong>，页表中的每一项称为页表条目（PTE），它包含了映射到的物理页的地址以及一些状态位（如访问权限、是否已加载到物理内存等）。</p>
</li>
<li><p><strong>地址转换过程</strong>，当CPU尝试访问一个虚拟地址时，MMU会将这个地址分解为两部分：页号和页内偏移。如果找到的PTE表明该虚拟页已经映射到一个物理页，MMU就将虚拟页号替换为物理页号，加上原始的页内偏移，形成完整的物理地址。</p>
<ul>
<li><p><strong>页号</strong>用于在页表中查找对应的PTE。</p>
</li>
<li><p><strong>页内偏移</strong>指示在物理页中的具体位置。</p>
</li>
</ul>
</li>
<li><p><strong>TLB（Translation Lookaside Buffer）</strong>，为了加速地址转换过程，MMU使用一种称为转换后援缓冲（TLB）的缓存，它存储最近使用的页表条目。如果虚拟地址的转换在TLB中找到匹配，那么就不需要再访问完整的页表，从而大大加快了内存访问速度。</p>
</li>
<li><p><strong>页错误（Page Fault）</strong>，如果在页表或TLB中找不到虚拟地址对应的物理地址，将触发一个页错误中断。操作系统的内存管理器会处理这个中断，可能会从磁盘加载缺失的页到物理内存中，然后更新页表并重新尝试访问。</p>
</li>
</ol>
<h3 id="页表是什么，页多大，为什么是4KB？"><a href="#页表是什么，页多大，为什么是4KB？" class="headerlink" title="页表是什么，页多大，为什么是4KB？"></a>页表是什么，页多大，为什么是4KB？</h3><p>页表是操作系统中用于实现虚拟内存管理的一种数据结构，它用于将虚拟地址映射到物理地址。这种机制允许计算机的操作系统为每个运行的程序提供一种看似连续的内存地址空间，即使物理内存是分散存储的。</p>
<p>每个页表条目存储着虚拟页面到物理页面的映射信息，通常包括物理页帧的基地址和一些状态位（如访问权限、是否已加载到物理内存中等）。由于地址空间的扩大，单级页表的大小会非常庞大，因此现代操作系统通常使用多级页表结构来减少内存占用，如x86架构常用的二级或三级页表。</p>
<p>在多数现代操作系统中，标准的页面大小是4KB（4096字节）。linux 会以页面为单位对内存进行管理。不论是将磁盘中的数据加载到内存中，还是将内存中的数据写回磁盘中，操作系统都会以页面为单位进行操作，这也意味着如果我们只向磁盘中写入一个字节的数据，操作系统也需要将整个页面中的全部数据刷入磁盘中。过小的页面大小会带来较大的页表项增加寻址时 TLB（Translation lookaside buffer）的查找速度和额外开销；过大的页面大小会浪费内存空间，造成内存碎片，降低内存的利用率；上个世纪在设计内存页大小时充分考虑了上述的两个因素，最终选择了 4KB 的内存页作为操作系统最常见的页大小，这个大小也就沿用至今。</p>
<h3 id="缺页中断什么时候发生？"><a href="#缺页中断什么时候发生？" class="headerlink" title="缺页中断什么时候发生？"></a>缺页中断什么时候发生？</h3><p>（1）当程序要访问的页面不在物理内存中时，会触发缺页中断。这通常发生在虚拟内存中，即当前只有部分的页面写入了物理内存。</p>
<p>（2）当程序尝试进行一个违反内存规则的操作时，也会触发缺页中断。比如，当程序试图对一个只读页面进行写操作，或是访问一个不允许被访问的页面。</p>
<h3 id="常见的缺页中断算法有哪些？"><a href="#常见的缺页中断算法有哪些？" class="headerlink" title="常见的缺页中断算法有哪些？"></a>常见的缺页中断算法有哪些？</h3><p>（1）LRU，最近最少使用。</p>
<p>（2）LFU，使用频率最低。</p>
<p>（3）FIFO，先进先出。</p>
<h3 id="写时拷贝在操作系统中有哪些应用？"><a href="#写时拷贝在操作系统中有哪些应用？" class="headerlink" title="写时拷贝在操作系统中有哪些应用？"></a>写时拷贝在操作系统中有哪些应用？</h3><ol>
<li><strong>内存管理</strong>：<ul>
<li><strong>分页系统</strong>：在许多操作系统中，写时拷贝技术常用于内存管理。当进程执行fork操作创建子进程时，操作系统并不立即为子进程复制父进程的整个地址空间。相反，它让父子进程共享同一物理内存页面，只有当其中一个进程尝试修改这些共享页面时，操作系统才会复制这些页面（COW），从而实现了资源的有效利用和快速的进程创建。</li>
<li><strong>虚拟内存系统</strong>：在虚拟内存系统中，写时拷贝技术可以减少不必要的数据复制，提高内存使用效率，只有在需要写入时才进行物理内存的分配和数据复制。</li>
</ul>
</li>
<li><strong>文件系统</strong>：<ul>
<li><strong>快照功能</strong>：在支持快照的文件系统（如ZFS或Btrfs）中，写时拷贝用于实现文件系统的版本控制。当文件系统状态需要保存为历史快照时，原始数据保持不变，任何对数据的修改都通过复制修改前的数据块来实现，从而快速创建快照并节省空间。</li>
</ul>
</li>
</ol>
<h2 id="3、编译程序相关"><a href="#3、编译程序相关" class="headerlink" title="3、编译程序相关"></a>3、编译程序相关</h2><h3 id="kmalloc（）和用户态的malloc（）有什么区别。"><a href="#kmalloc（）和用户态的malloc（）有什么区别。" class="headerlink" title="kmalloc（）和用户态的malloc（）有什么区别。"></a>kmalloc（）和用户态的malloc（）有什么区别。</h3><ul>
<li><code>kmalloc()</code> 是在内核空间中使用的内存分配函数，主要用于为内核模块或驱动程序分配内存，直接从操作系统的内核内存池中分配内存，这部分内存通常是预先保留给内核的，不会被用户空间的应用程序直接访问。</li>
<li><code>malloc()</code> 是在用户空间中使用的内存分配函数，用于应用程序分配内存，分配的内存来自于用户空间的堆区，这部分内存是由操作系统管理，供所有用户程序共享使用。</li>
</ul>
<h3 id="什么是内存泄漏，如何防止？"><a href="#什么是内存泄漏，如何防止？" class="headerlink" title="什么是内存泄漏，如何防止？"></a>什么是内存泄漏，如何防止？</h3><p>内存泄漏是发生在程序分配了堆内存但未释放，导致内存无法被再次使用。长时间的内存泄漏可能导致程序运行缓慢或异常终止。</p>
<p>主要有以下策略来防止内存泄漏：</p>
<p>（1）使用智能指针。这些智能指针利用RAII（Resource Acquisition Is Initialization）原则，确保资源（如动态分配的内存）在不再需要时能够被自动释放。</p>
<p>（2）手动管理内存。</p>
<p>（3）使用RAII原则。RAII是C++中的一种编程技术，通过将资源封装在对象中，并在对象的构造函数中分配资源，在析构函数中释放资源，可以确保资源总是被正确管理。</p>
<p>（4）使用内存泄漏检测工具。如Valgrind、AddressSanitizer等，可以帮助识别程序中的内存泄漏。</p>
<h3 id="从C-文件到可执行文件经过了哪几个阶段？"><a href="#从C-文件到可执行文件经过了哪几个阶段？" class="headerlink" title="从C++文件到可执行文件经过了哪几个阶段？"></a>从C++文件到可执行文件经过了哪几个阶段？</h3><p>预编译、编译、汇编、链接，最后生成可执行文件。</p>
<h3 id="预编译的过程？"><a href="#预编译的过程？" class="headerlink" title="预编译的过程？"></a>预编译的过程？</h3><p>（1）处理包含指令<code>#include</code></p>
<p>（2）进行宏展开</p>
<p>（3）进行条件编译</p>
<p>（4）删除注释</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E myfile.c -o myfile.i</span><br></pre></td></tr></table></figure>

<h3 id="为什么需要有链接的过程？"><a href="#为什么需要有链接的过程？" class="headerlink" title="为什么需要有链接的过程？"></a>为什么需要有链接的过程？</h3><p>因为软件开发的规模很大，不可能将它们都放在同一个模块中。因此按照层次化以及模块化的视线方法，将代码分成多个部分，每个部分分别开发。因此就需要在最后将它们组装起来，这就是链接的过程。通过链接，实现符号解析、地址分配和库依赖管理等工作。</p>
<h3 id="链接这个过程做了什么？"><a href="#链接这个过程做了什么？" class="headerlink" title="链接这个过程做了什么？"></a>链接这个过程做了什么？</h3><p>（1）符号解析。在目标文件和库中存在许多符号（如函数名或变量名等），需要在其他的目标文件或库中找到相应的定义，并将它们连接起来，使得程序在运行时可以找到正确的内存地址。</p>
<p>（2）地址分配。给目标文件和库分配内存地址，并确定其在程序中的内存布局。同时需要完成重定位的工作，用实际的内存地址去替换其中的地址引用。</p>
<p>（3）库依赖管理。链接器处理程序和库之间的依赖关系，确保所有库都被正确地包含在目标文件中。同时要处理库与库之间的依赖关系。</p>
<h3 id="程序链接完毕之后分几部分？"><a href="#程序链接完毕之后分几部分？" class="headerlink" title="程序链接完毕之后分几部分？"></a>程序链接完毕之后分几部分？</h3><p>程序连接完毕后生成可执行文件，包含代码段和数据段。不包含堆区和栈区，这两个区是在程序运行时由操作系统动态管理的内存区域。</p>
<h3 id="假设有一个A-dll和B-dll，A-dll调用了B-dll的方法，A-dll是如何找到B-dll中的方法的？"><a href="#假设有一个A-dll和B-dll，A-dll调用了B-dll的方法，A-dll是如何找到B-dll中的方法的？" class="headerlink" title="假设有一个A.dll和B.dll，A.dll调用了B.dll的方法，A.dll是如何找到B.dll中的方法的？"></a>假设有一个A.dll和B.dll，A.dll调用了B.dll的方法，A.dll是如何找到B.dll中的方法的？</h3><p>在使用动态库时，链接器会将动态库的相关信息，包括动态库的名字、符号表以及可重定位信息存储到相应的可执行文件中。在可执行文件运行时，链接器会根据这些信息找到动态库是否存在、在哪里、符号引用的内存地址是哪里，也就是说找到A.dll引用的B.dll的相关方法，并通过重定位找到其物理内存地址。</p>
<h3 id="函数调用中堆和栈的变化情况是怎样的？"><a href="#函数调用中堆和栈的变化情况是怎样的？" class="headerlink" title="函数调用中堆和栈的变化情况是怎样的？"></a>函数调用中堆和栈的变化情况是怎样的？</h3><p>函数调用时主要影响的是栈（stack）的变化，而不直接影响堆（heap）的变化。</p>
<ul>
<li><strong>函数进栈</strong>：<ul>
<li>调用函数时，会先将函数的参数压入栈中，参数的顺序通常是从右向左依次压入。</li>
<li>接着将当前函数的返回地址压入栈中，这个返回地址指向了调用该函数的下一条指令，用于函数执行结束后返回到调用处继续执行。</li>
<li>如果函数中有局部变量，则会在栈上为这些变量分配空间，并进行初始化。</li>
<li>最后，将当前栈指针（ESP）的值赋给基址指针（EBP），建立当前函数的栈帧。</li>
</ul>
</li>
<li><strong>函数退栈</strong>：<ul>
<li>当函数执行结束时，首先会将局部变量的值从栈中弹出，释放局部变量所占用的空间。</li>
<li>接着会将基址指针（EBP）的值赋给栈指针（ESP），恢复到函数调用之前的栈状态。</li>
</ul>
</li>
</ul>
<p>在这个过程中，函数的参数传递通常是通过栈来完成的。对于一般的函数调用，在调用函数前，调用者会将参数压入栈中；而在函数内部，被调用函数通过栈指针（ESP）来访问这些参数。在 x86 架构中，通常采用栈来传递函数参数，参数从右向左依次入栈。</p>
<h3 id="代码崩溃怎么解决，常见的原因是什么？"><a href="#代码崩溃怎么解决，常见的原因是什么？" class="headerlink" title="代码崩溃怎么解决，常见的原因是什么？"></a>代码崩溃怎么解决，常见的原因是什么？</h3><p><strong>（1）常见的崩溃原因</strong></p>
<ol>
<li><strong>访问非法内存</strong>，如已释放的内存（悬挂指针）、未初始化的指针或越界访问数组或字符串</li>
<li><strong>资源管理错误</strong>，如内存泄露，或文件或网络句柄未正确关闭</li>
<li><strong>并发错误</strong>：1）竞态条件：多个线程或进程争用数据，未正确同步；2）死锁：多个线程或进程相互等待对方持有的资源</li>
<li><strong>栈溢出</strong>：递归调用过深，或大量局部变量分配</li>
<li><strong>除零错误</strong>：整数或浮点数除以零</li>
</ol>
<p><strong>（2）解决方法</strong></p>
<ol>
<li><strong>调试工具</strong>：使用调试器（如 GDB）检查崩溃时的栈跟踪（stack trace）</li>
<li><strong>代码审查</strong></li>
<li><strong>增加日志记录</strong>：在关键操作前后添加日志记录，以追踪崩溃前的程序状态和行为；使用断言检查程序运行时的预期状态</li>
<li><strong>单元测试</strong>：编写和维护单元测试</li>
<li><strong>优化设计</strong>，避免过深的递归调用，考虑使用循环或其他算法策略；为并发操作设计合理的锁策略和线程同步机制</li>
</ol>
<h2 id="4、Linux相关"><a href="#4、Linux相关" class="headerlink" title="4、Linux相关"></a>4、Linux相关</h2><h3 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h3><ol>
<li><p>切换目录：<code>cd</code></p>
</li>
<li><p>查看端口绑定情况：<code>lsof -i : [端口号]</code>或<code>netstat -tuln</code>（列出所有监听端口）</p>
</li>
<li><p>查看CPU利用率：<code>top</code>或<code>htop</code></p>
</li>
<li><p>查看进程状态：<code>ps</code>，其中进程的状态码如下：</p>
</li>
</ol>
<ul>
<li>**R (Running)**：进程正在运行或在运行队列中等待</li>
<li>**S (Sleeping)**：进程处于睡眠状态，等待某个事件或资源。</li>
<li>**D (Uninterruptible Sleep)**：进程处于不可中断的睡眠状态，通常是在等待I&#x2F;O操作</li>
<li>**T (Stopped)**：进程已停止运行，通常是因为它正在被调试或已经收到停止信号</li>
<li>**Z (Zombie)**：进程已完成执行，但仍在进程表中等待父进程读取其退出状态</li>
<li>**I (Idle)**：这是一个空闲的内核线程，这个状态在某些版本的ps输出中可能不会显示</li>
</ul>
<ol start="5">
<li>查询网络状态：<code>ifconfig</code>、<code>netstat -r # 显示路由表</code></li>
<li>查看磁盘：<code>df -h</code>、<code>lsblk</code></li>
<li>查看是哪个进程的内存占用最大：<code>top</code>+<code>M</code>键、<code>ps aux --sort=-%mem | head -10</code></li>
<li>查找文件：<code>find</code>、<code>locate</code></li>
<li>查找文件内容：<code>grep -r &quot;hello&quot; /path/to/directory</code></li>
<li>查找系统命令的位置：<code>which ls</code></li>
</ol>
<h3 id="0、1、2的文件描述符是什么含义？指向什么类型的文件？"><a href="#0、1、2的文件描述符是什么含义？指向什么类型的文件？" class="headerlink" title="0、1、2的文件描述符是什么含义？指向什么类型的文件？"></a>0、1、2的文件描述符是什么含义？指向什么类型的文件？</h3><ol>
<li>文件描述符0（标准输入）：指向标准输入设备，通常是终端（键盘）。</li>
<li>文件描述符1（标准输出）：指向标准输出设备，通常是终端（屏幕）。</li>
<li>文件描述符2（标准错误）：指向标准错误设备，通常也是终端（屏幕）。</li>
</ol>
<h3 id="Linux系统中的中断为什么分为上下两个部分？"><a href="#Linux系统中的中断为什么分为上下两个部分？" class="headerlink" title="Linux系统中的中断为什么分为上下两个部分？"></a>Linux系统中的中断为什么分为上下两个部分？</h3><p>在Linux系统中，中断处理通常被分为上半部（Top Half）和下半部（Bottom Half）：</p>
<ol>
<li><strong>上半部</strong>：<ul>
<li>上半部是中断处理的第一阶段，它在CPU接收到中断信号后立即执行。</li>
<li>在这一阶段中，中断和调度器通常被禁用，以避免在处理中断时发生新的中断，从而保证处理的原子性。</li>
<li>上半部的代码通常包含处理中断的关键代码，这部分代码的执行时间应尽可能短，以快速释放CPU资源，处理更多的中断或其他任务。</li>
</ul>
</li>
<li><strong>下半部</strong>：<ul>
<li>下半部处理的是中断处理的后续部分，通常在上半部完成后，通过添加工作项到工作队列中来延后执行。</li>
<li>在下半部执行时，中断通常是被允许的，这样可以在处理较长时间的任务时不阻塞其他中断的处理。</li>
<li>下半部负责完成数据处理、复制等操作，这些操作不需要立即完成，可以稍后处理。</li>
</ul>
</li>
</ol>
<p>这种分割方法的主要优点是能够快速响应中断，同时又不会因为长时间的数据处理而阻塞CPU，影响系统的整体性能。通过这种方式，Linux系统能够在保证响应速度的同时，也能有效地处理大量的数据。</p>
<h3 id="0-3G用户空间有哪些内容"><a href="#0-3G用户空间有哪些内容" class="headerlink" title="0-3G用户空间有哪些内容"></a>0-3G用户空间有哪些内容</h3><p>在传统的 32 位 Linux 操作系统中，内存通常被分为用户空间和内核空间。用户空间占据了低地址部分，从 0 到 3GB（0-3G），而内核空间占据了高地址部分，从 3GB 到 4GB。这种分配方式是基于 4GB 总地址空间的限制。</p>
<h3 id="Linux用户态如何进入内核态？"><a href="#Linux用户态如何进入内核态？" class="headerlink" title="Linux用户态如何进入内核态？"></a>Linux用户态如何进入内核态？</h3><ol>
<li><strong>系统调用（System Call）</strong>:<ul>
<li>系统调用是最常见的从用户态切换到内核态的方式。</li>
<li>程序在需要执行诸如文件操作、网络通信、进程控制等操作时，会通过系统调用请求操作系统提供服务。</li>
<li>Linux提供了大量的系统调用，例如<code>read()</code>, <code>write()</code>, <code>open()</code>, <code>fork()</code>等。</li>
<li>系统调用通过软件中断（通常是中断指令<code>int 0x80</code>或<code>syscall</code>指令）来实现，这导致处理器从用户态切换到内核态，并跳转到预定义的内核入口点执行相应的内核代码。</li>
</ul>
</li>
<li><strong>异常（Exception）</strong>:<ul>
<li>当程序执行出现错误时（如除零、访问非法内存等），会触发异常。</li>
<li>处理器会自动从用户态切换到内核态，并调用相应的异常处理程序。</li>
<li>异常处理程序在内核中定义，负责处理这些错误并决定如何恢复程序执行或终止出错的程序。</li>
</ul>
</li>
<li><strong>中断（Interrupt）</strong>:<ul>
<li>当外部设备（如键盘、鼠标、网络接口等）需要处理时，它们会向处理器发送中断信号。</li>
<li>中断信号会导致当前正在执行的用户态程序被挂起，处理器切换到内核态处理这些外部事件。</li>
<li>中断处理程序在内核中定义，用于响应和处理这些外部事件。</li>
</ul>
</li>
</ol>
<h3 id="Linux设备树解析是什么时候"><a href="#Linux设备树解析是什么时候" class="headerlink" title="Linux设备树解析是什么时候"></a>Linux设备树解析是什么时候</h3><p>在Linux系统中，设备树（Device  Tree）是一种数据结构，用于描述硬件设备的信息，特别是在嵌入式系统中。设备树以一种树状的格式组织，提供了硬件设备的详细信息，如设备的类型、配置参数和与其他设备的关系等。这种机制特别适用于那些硬件配置多样化的平台，如ARM架构。</p>
<p>设备树的解析主要发生在Linux内核的启动阶段，具体步骤如下：</p>
<ol>
<li><strong>引导加载器阶段</strong>：<ul>
<li>在系统启动时，引导加载器（如U-Boot）首先读取设备树文件（通常是<code>.dtb</code>文件，即Device Tree Blob）。引导加载器负责将设备树文件和内核映像加载到内存中。</li>
</ul>
</li>
<li><strong>内核初始化阶段</strong>：<ul>
<li>内核在启动初期，会从引导加载器传递过来的设备树中读取硬件配置信息。</li>
<li>在内核的早期初始化代码中，会解析设备树数据结构，以构建内核的内部表示，这包括设置CPU、内存、各种外设的配置和驱动加载等。</li>
</ul>
</li>
<li><strong>设备和驱动初始化</strong>：<ul>
<li>根据设备树中的描述，内核会初始化硬件设备，并加载相应的驱动程序。设备树中的节点和属性告诉内核哪些驱动需要被初始化，以及如何配置这些硬件设备。</li>
</ul>
</li>
<li><strong>运行时访问</strong>：<ul>
<li>虽然设备树主要在启动时解析，但内核和驱动程序可以在整个系统运行期间访问设备树的信息，以获取设备的配置详情或进行某些特定的硬件操作。</li>
</ul>
</li>
</ol>
<h3 id="如何用gbd调试发现线程阻塞？"><a href="#如何用gbd调试发现线程阻塞？" class="headerlink" title="如何用gbd调试发现线程阻塞？"></a>如何用gbd调试发现线程阻塞？</h3><ol>
<li><strong>启动GDB并附加到进程</strong></li>
</ol>
<p>从GDB启动程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy codegdb ./your_program</span><br><span class="line">run [arguments]</span><br></pre></td></tr></table></figure>

<p>附加到已经运行的程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">gdb -p [pid]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>列出所有线程</strong></li>
</ol>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">info threads</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>切换线程</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">thread [thread-id]</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>检查线程的栈帧</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">backtrace</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>检查锁的状态。如果怀疑是死锁或资源竞争引起的阻塞，你可以检查锁的状态。这通常需要一些对应用程序逻辑的理解，以及可能需要查看源码来确定哪些锁可能涉及阻塞。</strong></li>
</ol>
<h3 id="gdb查看所有线程线程栈的命令是什么？"><a href="#gdb查看所有线程线程栈的命令是什么？" class="headerlink" title="gdb查看所有线程线程栈的命令是什么？"></a>gdb查看所有线程线程栈的命令是什么？</h3><ol>
<li>查看所有线程： <code>info threads</code></li>
<li>查看所有线程的栈信息： <code>thread apply all bt</code></li>
</ol>
<h3 id="gdb-查看内存地址的命令是什么？"><a href="#gdb-查看内存地址的命令是什么？" class="headerlink" title="gdb 查看内存地址的命令是什么？"></a>gdb 查看内存地址的命令是什么？</h3><p><code>x/NFU address</code></p>
<ul>
<li><code>N</code> 表示要检查的单元格的数量。</li>
<li><code>F</code> 表示显示格式，例如 <code>x</code>（十六进制）、<code>d</code>（十进制）、<code>u</code>（无符号十进制）、<code>t</code>（二进制）、<code>a</code>（地址）、<code>i</code>（机器指令）、<code>c</code>（字符）等。</li>
<li><code>U</code> 表示单位大小，例如 <code>b</code>（字节）、<code>h</code>（半字，2字节）、<code>w</code>（字，4字节）、<code>g</code>（双字，8字节）。</li>
</ul>
<h2 id="5、处理器相关"><a href="#5、处理器相关" class="headerlink" title="5、处理器相关"></a>5、处理器相关</h2><h3 id="什么是大小端？如何区分？有几种方法？网络通信一般是什么字节序？"><a href="#什么是大小端？如何区分？有几种方法？网络通信一般是什么字节序？" class="headerlink" title="什么是大小端？如何区分？有几种方法？网络通信一般是什么字节序？"></a>什么是大小端？如何区分？有几种方法？网络通信一般是什么字节序？</h3><ol>
<li><p>大端字节序是指高位字节存储在内存的低地址端，低位字节存储在内存的高地址端；小端字节序则与之相反。</p>
</li>
<li><p>区分的方法如下：</p>
<p>（1）通过检查整数的首个字节来确定字节序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">char</span> *c = (<span class="type">char</span>*)&amp;x;</span><br><span class="line">    <span class="keyword">if</span> (*c == <span class="number">0x78</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Little Endian\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big Endian\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）<code>htons()</code>和<code>ntohs()</code></p>
<ul>
<li><code>htons(host_port)</code>：将端口号从主机字节序转换为网络字节序</li>
<li><code>ntohs(net_port)</code>：将端口号从网络字节序转换回主机字节序</li>
</ul>
</li>
<li><p>网络通信一般是大端字节序，即无论发送和接收的系统是大端还是小端，数据在通过网络传输时都必须转换为网络字节序。</p>
</li>
</ol>
<h3 id="什么是qps和tps，如何计算？"><a href="#什么是qps和tps，如何计算？" class="headerlink" title="什么是qps和tps，如何计算？"></a>什么是qps和tps，如何计算？</h3><p>（1）<strong>QPS（Queries Per Second）</strong>：每秒查询率，是衡量每秒能处理多少个查询请求的指标。它通常用于评估搜索引擎、数据库服务器和Web服务器的性能。QPS可以通过将总查询数除以时间（秒）来计算。</p>
<p>（2）<strong>TPS（Transactions Per Second）</strong>：每秒事务数，是衡量系统每秒能处理多少个事务的指标。一个事务是指一个完整的业务操作，可能包含多个查询和更新。TPS是数据库操作和商业应用（如在线支付平台）的常用性能指标。TPS的计算方法与QPS类似，将总事务数除以时间（秒）。</p>
<h3 id="CPU利用率拉满的时候在线程池中增加线程是否能提高qps？"><a href="#CPU利用率拉满的时候在线程池中增加线程是否能提高qps？" class="headerlink" title="CPU利用率拉满的时候在线程池中增加线程是否能提高qps？"></a>CPU利用率拉满的时候在线程池中增加线程是否能提高qps？</h3><p>（1）对于CPU密集型应用，CPU是性能瓶颈。如果CPU利用率已经达到100%，这意味着CPU资源已经被完全使用。在这种情况下，增加更多的线程实际上会导致线程之间的竞争更加激烈，因为更多的线程需要共享有限的CPU资源。这可能导致上下文切换增加，反而降低了程序的效率和QPS。</p>
<p>（2）对于IO密集型应用，主要的瓶颈在于IO操作，如磁盘读写或网络通信等。即使CPU利用率很高，增加线程数仍然可能提高QPS，因为当一部分线程在等待IO操作完成时，其他线程可以继续执行，从而提高整体的吞吐量。在这种情况下，增加线程数可以有效利用CPU在等待IO时的空闲周期，提高QPS。</p>
<p>（3）混合型应用同时包含CPU密集型和IO密集型的操作。在这种情况下，是否增加线程以提高QPS取决于应用中CPU密集型和IO密集型操作的比例。如果IO操作占主导，增加线程可能有助于提高QPS；但如果CPU密集型操作占主导，增加线程可能不会带来预期的效果，甚至可能因为线程竞争导致性能下降。</p>
<h3 id="什么是CPU密集型应用和IO密集型应用？"><a href="#什么是CPU密集型应用和IO密集型应用？" class="headerlink" title="什么是CPU密集型应用和IO密集型应用？"></a>什么是CPU密集型应用和IO密集型应用？</h3><p>（1）CPU密集型应用是指那些需要进行大量计算，消耗大量CPU资源的应用。这类应用的特点是CPU使用率很高，因为它们主要进行数学计算、逻辑判断或者数据处理等操作，这些操作需要大量的CPU周期来完成。CPU密集型应用的性能很大程度上依赖于CPU的处理能力。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>科学计算软件</li>
<li>图像处理和视频编码</li>
<li>大数据处理应用</li>
<li>游戏服务器的游戏逻辑处理</li>
<li>加密和解密操作</li>
</ul>
<p>（2）IO密集型应用是指那些主要时间花费在输入输出操作上，而不是CPU计算上的应用。这类应用的特点是频繁地进行磁盘操作或网络通信，CPU使用率不高，但是需要等待IO操作的完成，因此对IO性能的依赖很高。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>Web服务器</li>
<li>数据库服务器</li>
<li>文件服务器</li>
<li>客户端&#x2F;服务器应用</li>
<li>大规模日志处理系统</li>
</ul>
<h3 id="IO密集型任务把IO和业务逻辑分离有什么好处？"><a href="#IO密集型任务把IO和业务逻辑分离有什么好处？" class="headerlink" title="IO密集型任务把IO和业务逻辑分离有什么好处？"></a>IO密集型任务把IO和业务逻辑分离有什么好处？</h3><p>（1）在IO密集型应用中，IO操作（如文件读写、网络数据传输等）往往是性能瓶颈。通过异步IO或使用专门的线程&#x2F;进程处理IO操作，主业务逻辑不需要等待IO操作的完成，从而减少等待时间，提高整体应用的响应速度和吞吐量。</p>
<p>（2）分离IO和业务逻辑可以使系统更有效地使用CPU和IO资源。当IO操作在执行时，通常涉及等待外部设备响应，这段时间CPU可以处理其他任务，从而提高资源的利用率。</p>
<p>（3）当IO操作与业务逻辑分开后，更易于对系统进行扩展。例如，可以根据需要增加处理IO的线程或进程，或者改用更高效的IO处理模式（如使用更高级的异步IO库），而不需要重大修改应用的业务逻辑部分。</p>
<p>（4）分离IO和业务逻辑可以使测试变得更加简单。可以独立地对IO部分和业务逻辑部分进行测试，例如使用模拟的IO操作来测试业务逻辑，确保业务逻辑的正确性而不受IO影响。</p>
<h3 id="CPU流水线技术是什么？"><a href="#CPU流水线技术是什么？" class="headerlink" title="CPU流水线技术是什么？"></a>CPU流水线技术是什么？</h3><p>CPU流水线技术是一种将指令分解为多步骤并让这些步骤并行执行的技术，从而提高CPU的执行效率。<strong>流水线技术通过将指令执行过程分解为取指令、译码、执行、访存和写回等阶段</strong>，每个阶段由不同的硬件单元处理，使得<strong>多条指令能够重叠执行</strong>，提高了处理速度。</p>
<h3 id="流水线技术中的分支预测的实现和意义？"><a href="#流水线技术中的分支预测的实现和意义？" class="headerlink" title="流水线技术中的分支预测的实现和意义？"></a>流水线技术中的分支预测的实现和意义？</h3><p>（1） 分支预测是流水线技术中用来<strong>处理指令跳转（如条件分支）带来的中断问题</strong>。现代CPU使用复杂的算法来预测程序中的分支跳转是否会发生，以及跳转到哪里。常见的分支预测技术包括静态分支预测（如始终预测跳转或不跳转）和动态分支预测（如基于历史信息的预测）。</p>
<p>（2）分支预测的主要目的是减少由于分支指令导致的流水线中断，从而提高程序执行的效率。正确的分支预测可以使CPU继续填充流水线而不必等待分支决定，错误的预测则会导致已经进入流水线的指令被撤销，降低效率。</p>
<h3 id="内核和应用进行数据交互的方法有哪些？"><a href="#内核和应用进行数据交互的方法有哪些？" class="headerlink" title="内核和应用进行数据交互的方法有哪些？"></a>内核和应用进行数据交互的方法有哪些？</h3><ol>
<li><strong>系统调用</strong> (System Calls):<ul>
<li>系统调用是应用程序与操作系统内核之间进行交互的主要方式。应用程序通过系统调用请求内核提供服务，如文件操作、进程控制、网络通信等。系统调用提供了一种安全的机制来执行硬件操作或访问内核级资源。</li>
</ul>
</li>
<li><strong>中断和异常</strong> (Interrupts and Exceptions):<ul>
<li>中断是外部设备或条件触发的，用于通知内核需要处理某些事件。异常则是程序执行错误时的一种特殊类型的中断，如除零错误或访问违规。</li>
<li>应用程序可以通过处理这些中断和异常来与内核交互，响应外部事件或错误。</li>
</ul>
</li>
<li><strong>共享内存</strong> (Shared Memory):<ul>
<li>共享内存是一种高效的数据交换方式，允许内核和一个或多个进程之间共享一段内存区域。这种方法可以避免复制数据，提高性能。</li>
</ul>
</li>
<li><strong>信号</strong> (Signals):<ul>
<li>信号是一种通知机制，用于通知进程发生了某些事件。内核可以向进程发送信号，以响应外部事件或内部错误，进程也可以发送信号给其他进程。</li>
</ul>
</li>
<li><strong>管道和套接字</strong> (Pipes and Sockets):<ul>
<li>管道提供了一种进程间通信的方法，允许数据在进程之间单向流动。套接字则支持更复杂的网络通信，包括进程间和网络间的数据交换。</li>
</ul>
</li>
<li><strong>文件系统操作</strong>:<ul>
<li>文件系统提供了一种存储和检索数据的方法，应用程序可以通过文件操作API与内核交互，进行数据的读写、查询和管理。</li>
</ul>
</li>
</ol>
<h3 id="系统调用从用户到内核的底层实现是什么？"><a href="#系统调用从用户到内核的底层实现是什么？" class="headerlink" title="系统调用从用户到内核的底层实现是什么？"></a>系统调用从用户到内核的底层实现是什么？</h3><ol>
<li><strong>系统调用接口</strong>：<ul>
<li>用户程序通常通过一个库（如C标准库）提供的封装函数来发起系统调用。这些库函数会设置好所有必要的参数供系统调用使用。</li>
</ul>
</li>
<li><strong>陷入指令（Trap）</strong>：<ul>
<li>库函数内部会执行一个特殊的指令，通常是<code>syscall</code>（在x86-64架构中）或<code>int 0x80</code>（在较老的x86架构中）。这个指令会生成一个软件中断，将处理器从用户模式切换到内核模式。</li>
</ul>
</li>
<li><strong>系统调用编号</strong>：<ul>
<li>每个系统调用都有一个唯一的编号。这个编号由用户程序设置在一个特定的寄存器（如x86中的EAX）中，内核通过这个编号来识别具体执行哪一个系统调用。</li>
</ul>
</li>
<li><strong>上下文切换</strong>：<ul>
<li>执行系统调用指令后，CPU进入内核模式，操作系统接管控制权。此时，操作系统会保存用户程序的状态（如寄存器等），并准备执行相应的内核函数。</li>
</ul>
</li>
<li><strong>执行系统调用</strong>：<ul>
<li>内核根据寄存器中的系统调用编号，通过查找系统调用表来找到对应的处理函数，并执行之。</li>
</ul>
</li>
<li><strong>返回用户态</strong>：<ul>
<li>系统调用完成后，操作系统将结果返回给用户程序，恢复用户程序的上下文，并将CPU控制权返回给用户程序。</li>
</ul>
</li>
<li><strong>结果传递</strong>：<ul>
<li>系统调用的结果通常通过寄存器或用户空间的内存位置返回给用户程序。</li>
</ul>
</li>
</ol>
<h3 id="内核的调度方式是什么？"><a href="#内核的调度方式是什么？" class="headerlink" title="内核的调度方式是什么？"></a>内核的调度方式是什么？</h3><p>在Linux操作系统中，内核的调度方式是指如何管理和调度系统中的进程和线程，以优化性能和响应时间。Linux内核使用多种调度策略和算法，主要包括以下几种：</p>
<ol>
<li><p><strong>完全公平调度器（Completely Fair Scheduler, CFS）</strong></p>
</li>
<li><p><strong>实时调度器</strong>，Linux 提供了两种实时调度策略：<code>SCHED_FIFO</code>（先进先出）和 <code>SCHED_RR</code>（时间片轮转）。</p>
</li>
<li><p><strong>Deadline 调度器（SCHED_DEADLINE）</strong>，这是一种较新的调度策略，用于确保任务在指定的截止时间之前完成。</p>
</li>
</ol>
<ul>
<li><strong>Cgroups 和任务组</strong>，Linux 还支持通过控制组（cgroups）对进程进行分组管理，这允许系统管理员根据需要对不同组的资源使用进行限制和监控。</li>
</ul>
<h3 id="为什么要设计用户态和内核态两种状态？"><a href="#为什么要设计用户态和内核态两种状态？" class="headerlink" title="为什么要设计用户态和内核态两种状态？"></a>为什么要设计用户态和内核态两种状态？</h3><p>这样做是为了保护操作系统的核心部分不被用户程序直接访问和修改，从而增加系统的稳定性和安全性。</p>
<p>（1）内核态主要允许操作系统访问受保护的硬件资源和内存区域，而用户态的控制程序则限制执行一些会影响系统稳定性和安全性的操作。</p>
<p>（2）如果用户态程序崩溃，它通常不会影响运行在内核态的系统核心部分，因此整个操作系统可以继续稳定运行。</p>
<p>（3）同时用户态程序也可能因为一些错误而尝试执行非法操作，此时操作系统可以拦截这些操作，避免对核心部分造成影响。</p>
<h1 id="三、计算机网络"><a href="#三、计算机网络" class="headerlink" title="三、计算机网络"></a>三、计算机网络</h1><h2 id="1、网络层"><a href="#1、网络层" class="headerlink" title="1、网络层"></a>1、网络层</h2><h3 id="什么是ICMP？"><a href="#什么是ICMP？" class="headerlink" title="什么是ICMP？"></a>什么是ICMP？</h3><p>ICMP是TCP&#x2F;IP协议族中网络层的协议，通过传输网络层控制消息的协议来实现网络诊断，以及发送错误报告的目的。<br>如ping&#x2F;traceout就是通过icmp来诊断网络质量以及追踪数据包在网络中的传输路径来达到网络诊断的目的。</p>
<h2 id="2、TCP和UD"><a href="#2、TCP和UD" class="headerlink" title="2、TCP和UD"></a>2、TCP和UD</h2><h3 id="什么是TCP粘包？"><a href="#什么是TCP粘包？" class="headerlink" title="什么是TCP粘包？"></a>什么是TCP粘包？</h3><p>TCP粘包是指在使用TCP协议传输数据时，发送方发送的多个数据包被接收方一次性接收。这是由于TCP发送的数据是以字节流为单位的，无法确定消数据边界。</p>
<h3 id="如何解决TCP粘包？"><a href="#如何解决TCP粘包？" class="headerlink" title="如何解决TCP粘包？"></a>如何解决TCP粘包？</h3><p>（1）添加数据边界，在数据中添加一个一个特定边界标识<br>（2）发送定长数据，不满足定长的数据用特定字符填充<br>（3）添加消息头<br>（4）使用应用层协议，如HTTP&#x2F;FTP协议都已经针对粘包问题进行了处理</p>
<h3 id="UDP会发生粘包吗？"><a href="#UDP会发生粘包吗？" class="headerlink" title="UDP会发生粘包吗？"></a>UDP会发生粘包吗？</h3><p>不会，因为UDP数据报格式的协议，发送时的数据报是独立的，因此有明确的边界。</p>
<h3 id="UDP为什么会发生乱序问题？"><a href="#UDP为什么会发生乱序问题？" class="headerlink" title="UDP为什么会发生乱序问题？"></a>UDP为什么会发生乱序问题？</h3><p>UDP不像TCP，存在滑动窗、序列号、确认序列和超时重传机制。因此由于存在网络抖动问题，接收方接收到的UDP数据报可能是乱序的，需要自行处理。</p>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p>TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种常见的传输层协议，它们在网络通信中有以下几点区别：</p>
<ol>
<li><strong>连接性：</strong>TCP 是面向连接的协议；UDP 是无连接的协议</li>
<li><strong>可靠性：</strong><ul>
<li>TCP 提供可靠的数据传输，保证数据的完整性和顺序性，通过确认应答机制和重传机制来确保数据的可靠传输。</li>
<li>UDP 不提供可靠的数据传输，数据包可能会丢失、重复或者乱序，不保证数据的可靠性和顺序性。</li>
</ul>
</li>
<li><strong>传输效率：</strong><ul>
<li>TCP 的数据传输效率相对较低</li>
<li>UDP 的数据传输效率相对较高，适用于实时性要求较高的应用场景。</li>
</ul>
</li>
<li><strong>应用场景：</strong><ul>
<li>TCP 可进行网页浏览、文件传输、电子邮件等。</li>
<li>UDP 适用于实时性要求较高、对数据可靠性要求不高的应用，如音视频传输、在线游戏、DNS 查询等。</li>
</ul>
</li>
<li><strong>头部开销：</strong><ul>
<li>TCP 头部开销较大，包含了序列号、确认号、窗口大小等字段，用于实现可靠传输和流量控制。</li>
<li>UDP 头部开销较小，只包含了源端口、目标端口、长度和校验和字段，不包含额外的控制信息。</li>
</ul>
</li>
</ol>
<h3 id="UDP报文的最大报文限制（说错了，应该是DNS中UDP限制512字节）？"><a href="#UDP报文的最大报文限制（说错了，应该是DNS中UDP限制512字节）？" class="headerlink" title="UDP报文的最大报文限制（说错了，应该是DNS中UDP限制512字节）？"></a>UDP报文的最大报文限制（说错了，应该是DNS中UDP限制512字节）？</h3><h2 id="3、TCP三次握手"><a href="#3、TCP三次握手" class="headerlink" title="3、TCP三次握手"></a>3、TCP三次握手</h2><h3 id="详细说明三次握手"><a href="#详细说明三次握手" class="headerlink" title="详细说明三次握手"></a>详细说明三次握手</h3><ol>
<li><p>TCP服务器进程创建传输控制块，用来存储TCP连接中的一些重要信息，并进入监听状态，等待TCP客户端进程的连接请求</p>
</li>
<li><p>TCP客户进程也是首先创建传输控制块</p>
</li>
<li><p>TCP客户进程向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态。</p>
</li>
<li><p>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态。</p>
</li>
<li><p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态。</p>
</li>
<li><p>TCP服务器进程收到该确认报文段后也进入连接已建立状态。</p>
</li>
</ol>
<h3 id="为什么不能两次握手？"><a href="#为什么不能两次握手？" class="headerlink" title="为什么不能两次握手？"></a>为什么不能两次握手？</h3><p>不采用两次握手主要是为了<strong>防止已经失效的连接请求报文段突然又传到服务端</strong>，因而产生错误。</p>
<p>这种情况是：<strong>客户端发出的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到下一个连接释放以后的某个时间才到达服务器端。</strong>当服务器端收到此失效报文后，会误认为是客户端发出的一个新连接请求，于是客户端又发出确认报文，表示同意建立连接。</p>
<p>如果不采用“三次握手”，那么只要服务器端发出确认报文就会认为新的连接已经建立了，但此时客户端并没有发出建立连接的请求，因此不会向服务器端发送数据。服务器端没有收到数据就会一直等待，这样就会白白浪费掉很多资源。</p>
<p>所以必须采用“三次握手”而非“两次握手”。</p>
<h3 id="三次握手为什么ACK信号是SYN信号值-1？"><a href="#三次握手为什么ACK信号是SYN信号值-1？" class="headerlink" title="三次握手为什么ACK信号是SYN信号值+1？"></a>三次握手为什么ACK信号是SYN信号值+1？</h3><p>TCP（传输控制协议）的三次握手过程是建立一个可靠的连接会话的关键步骤。在这个过程中，ACK（确认）信号的值为SYN（同步）信号的值加1的原因主要是为了确认双方的接收能力和确保序列号的同步。</p>
<h3 id="TCP三次握手的过程中可以携带数据吗"><a href="#TCP三次握手的过程中可以携带数据吗" class="headerlink" title="TCP三次握手的过程中可以携带数据吗"></a>TCP三次握手的过程中可以携带数据吗</h3><p>第三次握手的时候可以携带数据，第一次和第二次握手不可以。</p>
<h3 id="TCP挥手过程中，为什么存在一个time-wait状态？"><a href="#TCP挥手过程中，为什么存在一个time-wait状态？" class="headerlink" title="TCP挥手过程中，为什么存在一个time_wait状态？"></a>TCP挥手过程中，为什么存在一个time_wait状态？</h3><p>（1）防止错误接收报文。如果立刻断掉连接，那么当客户端复位ip地址和端口号重新建立连接时，可能会收到上一个连接发送过来的历史报文，而当前建立的新连接无法判断这个报文是否为历史报文，因此会出现错误。</p>
<p>（2）确保双方正常关闭。当客户端发送ACK报文给服务器端时，若该报文丢失，需要等待服务器端重新发送一个FIN报文给客户端，这个等待的时间最大为2MSL，因此需要一个time_wait状态来让客户端等到是否再次接受到一个FIN报文。</p>
<h3 id="什么情况下会出现大量time-wait状态？如何优化？"><a href="#什么情况下会出现大量time-wait状态？如何优化？" class="headerlink" title="什么情况下会出现大量time_wait状态？如何优化？"></a>什么情况下会出现大量time_wait状态？如何优化？</h3><p>在以下两种场景会出现大量time_wait状态：</p>
<p>（1）高并发场景下。此时存在大量的客户端和服务器端建立连接，因此在断开连接时就会出现大量的time_wait状态。</p>
<p>（2）短连接场景下。短连接场景下的TCP连接生命周期较短，很快就会断开连接，就导致出现大量的time_wait状态。</p>
<p>可以通过下列方式进行优化：</p>
<p>（1）缩短MSL的时间。</p>
<p>（2）建立连接池。在客户端和服务器端中间建立连接池，这样就可以复用已经建立的的TCP连接。</p>
<p>（3）在服务器端开启SO_REUSEADDR套接字，这样可以使得服务器端在time_wait状态时就可以重新绑定并监听端口号。</p>
<p>（4）在客户端开启SO_LINGER套接字，并将延迟设置为0。这样当断开连接时，客户端会直接发送一个RST信号，不再进行四次挥手，从而避免进入time_wait状态。</p>
<h2 id="4、TCP四次挥手"><a href="#4、TCP四次挥手" class="headerlink" title="4、TCP四次挥手"></a>4、TCP四次挥手</h2><h3 id="详细说明四次挥手"><a href="#详细说明四次挥手" class="headerlink" title="详细说明四次挥手"></a>详细说明四次挥手</h3><ol>
<li>当客户端和服务器端都处于连接已建立状态时，若要释放连接，客户进程会发送TCP连接释放报文段，并进入终止等待状态。</li>
<li>服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态。</li>
<li>此时，从客户进程到服务器进程这个方向的连接就释放了，这时的TCP连接属于半关闭状态，也就是客户进程已经没有数据要发送了。但如果服务器进程还有数据要发送，客户进程仍要接收，也就是说从服务器进程到客户进程这个方向的连接并未关闭。</li>
<li>客户进程收到TCP确认报文段后就进入终止等待状态，等待服务器进程发出的TCP连接释放报文段。若服务器进程已经没有数据要发送了，服务器进程即释放连接。由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接。</li>
<li>服务器进程发送TCP连接释放报文段并进入最后确认状态。</li>
<li>客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态。服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要经过2MSL后才能进入关闭状态。</li>
</ol>
<h3 id="为什么不能三次挥手？"><a href="#为什么不能三次挥手？" class="headerlink" title="为什么不能三次挥手？"></a>为什么不能三次挥手？</h3><p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。</p>
<p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段。</p>
<h2 id="5、TCP可靠传输"><a href="#5、TCP可靠传输" class="headerlink" title="5、TCP可靠传输"></a>5、TCP可靠传输</h2><h3 id="流量控制和拥塞控制"><a href="#流量控制和拥塞控制" class="headerlink" title="流量控制和拥塞控制"></a>流量控制和拥塞控制</h3><p>流量控制和拥塞控制都是网络通信中用于控制数据传输的机制，但它们针对的对象和目的略有不同。</p>
<p>（1）流量控制（Flow Control）</p>
<p>流量控制是指在数据传输过程中，接收方通过一定的方式告诉发送方自己的接收能力，以控制发送方的发送速率，防止发送方发送过多的数据导致接收方无法及时处理。流量控制通常发生在端到端之间，其主要目的是保护接收方不被发送方的数据压倒。</p>
<p>常见的流量控制机制包括<strong>滑动窗口协议（如TCP的滑动窗口机制）和通告窗口大小（advertised window size）</strong>等。接收方通过不断调整通告窗口大小来告诉发送方自己的接收能力，从而控制发送方的发送速率。</p>
<p>（2）拥塞控制（Congestion Control）</p>
<p>拥塞控制是指在网络中避免过多的数据包拥塞在网络节点或链路上，从而影响网络性能和吞吐量的机制。拥塞控制通常发生在网络中，其主要目的是保护网络免受过载和崩溃。</p>
<p>拥塞控制通过监控网络的拥塞程度，并采取一系列措施来降低数据包的发送速率，从而避免网络拥塞。常见的拥塞控制算法包括<strong>拥塞窗口控制、慢启动、拥塞避免、快速重传、快速恢复</strong>等。这些算法通过动态调整数据包的发送速率，以适应网络的负载情况，从而确保网络的稳定性和性能。</p>
<h3 id="在流量控制中，如果接受窗口已经是0了，还会发生吗？"><a href="#在流量控制中，如果接受窗口已经是0了，还会发生吗？" class="headerlink" title="在流量控制中，如果接受窗口已经是0了，还会发生吗？"></a>在流量控制中，如果接受窗口已经是0了，还会发生吗？</h3><ul>
<li><strong>窗口更新</strong>：即使窗口大小为0，发送方仍然需要接收来自接收方的ACK包。接收方在其缓冲区有了新的空间可用时，会发送一个新的窗口大小。这可以是在处理了一些数据之后。</li>
<li><strong>零窗口探测</strong>：TCP实现通常会使用零窗口探测（Zero Window Probing）机制。如果窗口大小长时间保持为0，发送方会定期发送探测包以检查接收方的窗口是否已经开放。这些探测包通常很小，确保不会因额外的数据负载而导致问题。</li>
<li><strong>窗口开放</strong>：一旦接收方的窗口再次开放，它会通过发送一个窗口更新的ACK包来通知发送方。收到这个ACK后，发送方可以恢复数据传输。</li>
</ul>
<h3 id="TCP可靠传输的⼏种机制"><a href="#TCP可靠传输的⼏种机制" class="headerlink" title="TCP可靠传输的⼏种机制"></a>TCP可靠传输的⼏种机制</h3><p>TCP（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层协议。它采用了多种机制来保证数据的可靠传输，以下是几种常见的机制：</p>
<ol>
<li><strong>序列号和确认应答：</strong> TCP 使用序列号和确认应答机制来确保数据的可靠传输。发送方将每个数据包都标记上序列号，并等待接收方发送确认应答。接收方收到数据后，会发送确认应答，告诉发送方已成功接收到数据，如果发送方在一定时间内没有收到确认应答，则会重新发送数据。</li>
<li><strong>超时重传：</strong> TCP 采用超时重传机制来处理丢失的数据包。如果发送方在一定时间内没有收到确认应答，则会认为数据包丢失，会重新发送该数据包。</li>
<li><strong>滑动窗口：</strong> TCP 使用滑动窗口机制来进行流量控制和拥塞控制。滑动窗口指定了发送方可以发送的数据量，接收方通过发送窗口大小来告知发送方自己的接收能力。发送方根据接收窗口的大小来控制发送速率，以避免发送过多的数据导致接收方无法及时处理。</li>
<li><strong>累积确认：</strong> TCP 使用累积确认机制来确认已成功接收的数据。接收方发送的确认应答中包含了已成功接收的数据的最大序列号，发送方根据该确认号来确认哪些数据已经被成功接收。</li>
<li><strong>拥塞控制算法：</strong> TCP 使用拥塞控制算法来避免网络拥塞和过载。常见的拥塞控制算法包括慢启动、拥塞避免、快速重传和快速恢复等，通过动态调整发送窗口大小和数据包的发送速率来适应网络的负载情况，从而确保网络的稳定性和性能。</li>
</ol>
<h2 id="6、应用层"><a href="#6、应用层" class="headerlink" title="6、应用层"></a>6、应用层</h2><h3 id="打开一个网址，发生了什么，HTTP报文怎么发送Server的（提示路由，不会）"><a href="#打开一个网址，发生了什么，HTTP报文怎么发送Server的（提示路由，不会）" class="headerlink" title="打开一个网址，发生了什么，HTTP报文怎么发送Server的（提示路由，不会）?"></a>打开一个网址，发生了什么，HTTP报文怎么发送Server的（提示路由，不会）?</h3><h3 id="HTTP的状态码有哪些？"><a href="#HTTP的状态码有哪些？" class="headerlink" title="HTTP的状态码有哪些？"></a>HTTP的状态码有哪些？</h3><h3 id="HTTPS和HTTP的区别是什么？"><a href="#HTTPS和HTTP的区别是什么？" class="headerlink" title="HTTPS和HTTP的区别是什么？"></a>HTTPS和HTTP的区别是什么？</h3><h3 id="HTTPS是如何进行加密的？"><a href="#HTTPS是如何进行加密的？" class="headerlink" title="HTTPS是如何进行加密的？"></a>HTTPS是如何进行加密的？</h3><p>HTTPS（HyperText Transfer Protocol Secure）是一种基于HTTP协议和SSL&#x2F;TLS协议的安全传输协议，它通过使用加密技术来保护通信数据的安全性和完整性。下面是HTTPS进行加密的基本流程：</p>
<ol>
<li><strong>建立SSL&#x2F;TLS连接：</strong> 客户端与服务器之间首先建立SSL&#x2F;TLS连接，这个过程通常称为SSL&#x2F;TLS握手。在握手过程中，客户端和服务器协商使用的加密算法、密钥长度和其他参数，同时进行身份验证。</li>
<li><strong>进行证书交换：</strong> 在握手过程中，服务器会向客户端发送数字证书，用于证明服务器的身份。数字证书包含了服务器的公钥以及与证书相关的信息，如证书颁发者、有效期等。</li>
<li><strong>验证证书：</strong> 客户端收到服务器的证书后，会对证书进行验证。这个过程通常包括检查证书的有效性、签发者的可信度、证书是否过期等。如果证书验证通过，则客户端继续握手过程；否则，可能会发出警告或中止连接。</li>
<li><strong>生成会话密钥：</strong> 一旦证书验证通过，客户端会生成一个用于对通信数据进行加密和解密的会话密钥（Session Key）。通常情况下，客户端使用服务器的公钥来加密这个会话密钥，并发送给服务器。</li>
<li><strong>加密通信：</strong> 一旦服务器收到客户端发送的加密的会话密钥，服务器使用自己的私钥解密会话密钥。此后，客户端和服务器之间的通信就使用这个会话密钥来进行对称加密和解密了。这意味着通信数据在传输过程中是加密的，保护了数据的机密性和完整性。</li>
</ol>
<h3 id="对称加密和非对称加密的区别，哈希散列算不算加密算法"><a href="#对称加密和非对称加密的区别，哈希散列算不算加密算法" class="headerlink" title="对称加密和非对称加密的区别，哈希散列算不算加密算法"></a>对称加密和非对称加密的区别，哈希散列算不算加密算法</h3><h3 id="HTTPS的端口？其证书是怎么验证的？"><a href="#HTTPS的端口？其证书是怎么验证的？" class="headerlink" title="HTTPS的端口？其证书是怎么验证的？"></a>HTTPS的端口？其证书是怎么验证的？</h3><h3 id="OKHttp的原理、功能，以及在哪些地方应用，做了哪些优化"><a href="#OKHttp的原理、功能，以及在哪些地方应用，做了哪些优化" class="headerlink" title="OKHttp的原理、功能，以及在哪些地方应用，做了哪些优化"></a>OKHttp的原理、功能，以及在哪些地方应用，做了哪些优化</h3><h3 id="大量网络请求，怎么优化（不会，应该是在客户端做离散化处理）？"><a href="#大量网络请求，怎么优化（不会，应该是在客户端做离散化处理）？" class="headerlink" title="大量网络请求，怎么优化（不会，应该是在客户端做离散化处理）？"></a>大量网络请求，怎么优化（不会，应该是在客户端做离散化处理）？</h3><h1 id="四、单片机"><a href="#四、单片机" class="headerlink" title="四、单片机"></a>四、单片机</h1><h3 id="单片机启动程序，在执行main之前的是什么"><a href="#单片机启动程序，在执行main之前的是什么" class="headerlink" title="单片机启动程序，在执行main之前的是什么"></a>单片机启动程序，在执行main之前的是什么</h3><p>在单片机启动程序中，执行main函数之前的过程主要包括以下几个步骤：</p>
<ol>
<li><strong>硬件设置</strong>：单片机上电后，首先进行的是硬件的初始化，包括设置堆栈指针（SP）和程序计数器（PC）。</li>
<li><strong>启动文件执行</strong>：接下来，单片机会执行启动文件，通常是名为 <code>startup_xxxxx.s</code> 的汇编语言文件。这个文件负责设置单片机的初始环境和配置，为main函数的执行做准备。</li>
<li><strong>初始化代码</strong>：在启动文件执行后，可能还会有一些初始化代码，这些代码用于初始化单片机的硬件和软件环境，比如设置时钟、配置中断等。</li>
<li><strong>跳转到main函数</strong>：所有的初始化和设置完成后，单片机最终会跳转到main函数开始执行用户的程序。</li>
</ol>
<p>这个过程确保了单片机在执行用户代码之前，硬件和系统环境已经被正确地设置和初始化，从而可以正确地运行用户程序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/06/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%932_Redis%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/06/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%932_Redis%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">数据库2_Redis数据库.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-06 10:43:45" itemprop="dateCreated datePublished" datetime="2024-04-06T10:43:45+08:00">2024-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-11 16:21:50" itemprop="dateModified" datetime="2024-04-11T16:21:50+08:00">2024-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、Redis简介"><a href="#1、Redis简介" class="headerlink" title="1、Redis简介"></a>1、Redis简介</h1><p>Redis是一个基于内存的数据存储系统，它<strong>将数据完全存储在内存中</strong>，通过使用<strong>持久化机制</strong>来将数据定期写入磁盘以保证数据的持久性。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/06/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%932_Redis%E6%95%B0%E6%8D%AE%E5%BA%93/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="midorii"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">midorii</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">midorii</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">115k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
