<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch_cat_logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/site_cat-32%C3%9732.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/site_cat-16%C3%9716.png">
  <link rel="mask-icon" href="/images/cat_logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="MIDORII&#39;S JOURNEY">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="MIDORII&#39;S JOURNEY">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="midorii">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>MIDORII'S JOURNEY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MIDORII'S JOURNEY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">a little bit sweet</p>
      <a>
        <img class="custom-logo-image" src="/images/cat.jpeg" alt="MIDORII'S JOURNEY">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/03/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE2_diy_tcpip/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/03/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE2_diy_tcpip/" class="post-title-link" itemprop="url">项目2_diy_tcpip</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-03 16:21:03" itemprop="dateCreated datePublished" datetime="2024-07-03T16:21:03+08:00">2024-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-12 17:01:04" itemprop="dateModified" datetime="2024-07-12T17:01:04+08:00">2024-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407042007671.png" alt="image-20240704200718437"></p>
<h2 id="1、数据包收发"><a href="#1、数据包收发" class="headerlink" title="1、数据包收发"></a>1、数据包收发</h2><p>利用 pcap 往网络上收发数据包。</p>
<p>以下为测试代码，主要功能：</p>
<ul>
<li>在一个无限循环中不断捕获和修改网络数据包，然后将其发送出去，并在每次循环中打印计数器值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pcap/pcap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys_plat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">pcap_t</span> *pcap = pcap_device_open(netdev0_phy_ip, netdev0_hwaddr); </span><br><span class="line">	<span class="keyword">while</span> (pcap) &#123;</span><br><span class="line">		<span class="type">static</span> <span class="type">uint8_t</span> buffer[<span class="number">1024</span>];  	<span class="comment">// 缓存</span></span><br><span class="line">		<span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pcap_pkthdr</span> *<span class="title">pkthdr</span>;</span>  	<span class="comment">// 存储抓取的数据包包头</span></span><br><span class="line">		<span class="type">const</span> <span class="type">uint8_t</span> *pkt_data;  		<span class="comment">// 存储抓取的数据包</span></span><br><span class="line"></span><br><span class="line">		plat_printf(<span class="string">&quot;begin test: %d\n&quot;</span>, counter++);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(buffer); i++) &#123;</span><br><span class="line">			buffer[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 接收数据包</span></span><br><span class="line">		<span class="keyword">if</span> (pcap_next_ex(pcap, &amp;pkthdr, &amp;pkt_data) == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> len = pkthdr-&gt;len &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : pkthdr-&gt;len;</span><br><span class="line">		plat_memcpy(buffer, pkt_data, len);</span><br><span class="line">		buffer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		buffer[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 发送数据包</span></span><br><span class="line">		<span class="keyword">if</span> (pcap_inject(pcap, buffer, len) == <span class="number">-1</span>) &#123;</span><br><span class="line">			plat_printf(<span class="string">&quot;pcap send: send packet failed %s \n&quot;</span>, pcap_geterr(pcap));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="库文件"><a href="#库文件" class="headerlink" title="库文件"></a>库文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pcap/pcap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys_plat.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p><code>#include &lt;stdio.h&gt;</code>：包含标准输入输出库，用于打印信息。</p>
<p><code>#include &quot;pcap/pcap.h&quot;</code>：包含 <code>pcap</code> 库的头文件，用于网络数据包捕获和发送。</p>
<p><code>#include &quot;sys_plat.h&quot;</code>：包含自定义平台相关的头文件，假设其中定义了 <code>plat_printf</code> 和 <code>plat_memcpy</code> 函数，以及网络设备相关的信息。</p>
<h3 id="打开-pcap-会话"><a href="#打开-pcap-会话" class="headerlink" title="打开 pcap 会话"></a>打开 pcap 会话</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pcap_t</span> *pcap = pcap_device_open(netdev0_phy_ip, netdev0_hwaddr); </span><br></pre></td></tr></table></figure>

<h3 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> buffer[<span class="number">1024</span>];  	<span class="comment">// 静态缓存</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;			<span class="comment">// 计数器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcap_pkthdr</span> *<span class="title">pkthdr</span>;</span>  	<span class="comment">// 存储抓取的数据包包头</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> *pkt_data;  		<span class="comment">// 存储抓取的数据包</span></span><br></pre></td></tr></table></figure>

<h3 id="接收数据包"><a href="#接收数据包" class="headerlink" title="接收数据包"></a>接收数据包</h3><p>接收一个数据包，如果接收失败，继续下一个循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据包</span></span><br><span class="line"><span class="keyword">if</span> (pcap_next_ex(pcap, &amp;pkthdr, &amp;pkt_data) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确定要拷贝的数据包长度，不能超过定义的 buffer 的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = pkthdr-&gt;len &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : pkthdr-&gt;len;</span><br></pre></td></tr></table></figure>

<p>将数据包数据拷贝到缓存 buffer 中，并在此处做简单的修改，将缓存 buffer 的前两个字节设为 1 和 2，以用于区别该数据包是接收还是发送。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plat_memcpy(buffer, pkt_data, len);</span><br><span class="line">buffer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">buffer[<span class="number">1</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="发送数据包"><a href="#发送数据包" class="headerlink" title="发送数据包"></a>发送数据包</h3><p>发送修改后的数据包。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送数据包</span></span><br><span class="line"><span class="keyword">if</span> (pcap_inject(pcap, buffer, len) == <span class="number">-1</span>) &#123;</span><br><span class="line">	plat_printf(<span class="string">&quot;pcap send: send packet failed %s \n&quot;</span>, pcap_geterr(pcap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 wireshark 中抓取相应的数据包如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407042013405.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407042013776.png" alt="2"></p>
<h2 id="2、多线程环境"><a href="#2、多线程环境" class="headerlink" title="2、多线程环境"></a>2、多线程环境</h2><h3 id="结合计数信号量-互斥锁实现多线程环境"><a href="#结合计数信号量-互斥锁实现多线程环境" class="headerlink" title="结合计数信号量+互斥锁实现多线程环境"></a>结合计数信号量+互斥锁实现多线程环境</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407051056708.png" alt="image-20240705105613396"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pcap/pcap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys_plat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">sys_sem_t</span> sem;</span><br><span class="line"><span class="type">static</span> <span class="type">sys_mutex_t</span> mutex;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count;  <span class="comment">// 共享资源</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1_entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		sys_mutex_lock(mutex);</span><br><span class="line">		count++;</span><br><span class="line">		sys_mutex_unlock(mutex);</span><br><span class="line">	&#125;</span><br><span class="line">	plat_printf(<span class="string">&quot;thread1: count = %d\n&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		plat_printf(<span class="string">&quot;this is thread1: %s\n&quot;</span>, (<span class="type">char</span> *)arg);</span><br><span class="line">		sys_sleep(<span class="number">1000</span>);</span><br><span class="line">		sys_sem_notify(sem);</span><br><span class="line">		sys_sleep(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2_entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		sys_mutex_lock(mutex);</span><br><span class="line">		count--;</span><br><span class="line">		sys_mutex_unlock(mutex);</span><br><span class="line">	&#125;</span><br><span class="line">	plat_printf(<span class="string">&quot;thread2: count = %d\n&quot;</span>, count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		sys_sem_wait(sem, <span class="number">0</span>);</span><br><span class="line">		plat_printf(<span class="string">&quot;this is thread2: %s\n&quot;</span>, (<span class="type">char</span> *)arg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	sem = sys_sem_create(<span class="number">0</span>);  <span class="comment">// 初始化信号量</span></span><br><span class="line">	mutex = sys_mutex_create();  <span class="comment">// 初始化互斥锁</span></span><br><span class="line"></span><br><span class="line">	sys_thread_create(thread1_entry, <span class="string">&quot;1_test_thread1&quot;</span>);</span><br><span class="line">	sys_thread_create(thread2_entry, <span class="string">&quot;2_test_thread2&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">pcap_t</span> *pcap = pcap_device_open(netdev0_phy_ip, netdev0_hwaddr); </span><br><span class="line">	<span class="keyword">while</span> (pcap) &#123;</span><br><span class="line">		<span class="comment">// 接收数据包</span></span><br><span class="line">		...</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 发送数据包</span></span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407042003498.png" alt="image-20240704200358198"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407051105206.png" alt="image-20240705110539162"></p>
<h3 id="线程间的资源访问控制实例"><a href="#线程间的资源访问控制实例" class="headerlink" title="线程间的资源访问控制实例"></a>线程间的资源访问控制实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生产者线程 --(生产)--&gt; 数据 --(消费)--&gt; 消费者线程</span><br></pre></td></tr></table></figure>

<h4 id="（1）循环缓存"><a href="#（1）循环缓存" class="headerlink" title="（1）循环缓存"></a>（1）循环缓存</h4><p>当生产者线程的生产速率和消费者线程的消费速率不匹配时，就需要缓存来不及消耗的产品。</p>
<p>使用环形缓存区的方式来实现。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407051948932.png" alt="image-20240705194807866"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生产者线程 --(生产)--&gt; [数据缓存] --(消费)--&gt; 消费者线程</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buffer[<span class="number">100</span>];  <span class="comment">// 环形数据缓冲区</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> write_idx, read_idx;  <span class="comment">// 写索引和读索引</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1_entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="comment">// 消费者线程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * <span class="keyword">sizeof</span>(buffer); i++) &#123;</span><br><span class="line">		<span class="type">char</span> data = buffer[read_idx++];</span><br><span class="line">		<span class="keyword">if</span> (read_idx &gt;= <span class="keyword">sizeof</span>(buffer)) &#123;</span><br><span class="line">			read_idx = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		plat_printf(<span class="string">&quot;thread1: read data = %d\n&quot;</span>, data);</span><br><span class="line">		sys_sleep(<span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2_entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="comment">// 生产者线程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * <span class="keyword">sizeof</span>(buffer); i++) &#123;</span><br><span class="line">		buffer[write_idx++] = i;</span><br><span class="line">		<span class="keyword">if</span> (write_idx &gt;= <span class="keyword">sizeof</span>(buffer)) &#123;</span><br><span class="line">			write_idx = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		plat_printf(<span class="string">&quot;thread2: write data = %d\n&quot;</span>, i);</span><br><span class="line">		sys_sleep(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>此处并未控制读&#x2F;写速率，可以看出先执行读数据操作，再执行写数据操作，实际上是不正确的。</li>
<li>观察读&#x2F;写的频次，可以看出写数据的速率较快，大约为读速率的两倍。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407051921443.png" alt="image-20240705192122236"></p>
<h4 id="（2）控制读速率"><a href="#（2）控制读速率" class="headerlink" title="（2）控制读速率"></a>（2）控制读速率</h4><blockquote>
<p><strong>消费者线程必须在缓存中有数据的情况下才能读，否则应该等待。因此对于读速率需要进行控制。</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buffer[<span class="number">100</span>];  <span class="comment">// 环形数据缓冲区</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> write_idx, read_idx;  <span class="comment">// 写索引和读索引</span></span><br><span class="line"><span class="type">static</span> <span class="type">sys_sem_t</span> read_sem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1_entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="comment">// 消费者线程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * <span class="keyword">sizeof</span>(buffer); i++) &#123;</span><br><span class="line">		sys_sem_wait(read_sem, <span class="number">0</span>);</span><br><span class="line">		<span class="type">char</span> data = buffer[read_idx++];</span><br><span class="line">		<span class="keyword">if</span> (read_idx &gt;= <span class="keyword">sizeof</span>(buffer)) &#123;</span><br><span class="line">			read_idx = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		plat_printf(<span class="string">&quot;thread1: read data = %d\n&quot;</span>, data);</span><br><span class="line">		sys_sleep(<span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2_entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="comment">// 生产者线程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * <span class="keyword">sizeof</span>(buffer); i++) &#123;</span><br><span class="line">		buffer[write_idx++] = i;</span><br><span class="line">		<span class="keyword">if</span> (write_idx &gt;= <span class="keyword">sizeof</span>(buffer)) &#123;</span><br><span class="line">			write_idx = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		plat_printf(<span class="string">&quot;thread2: write data = %d\n&quot;</span>, i);</span><br><span class="line">		sys_sem_notify(read_sem);</span><br><span class="line">		sys_sleep(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	read_sem = sys_sem_create(<span class="number">0</span>);</span><br><span class="line">	sys_thread_create(thread1_entry, <span class="string">&quot;1_test_thread1&quot;</span>);</span><br><span class="line">	sys_thread_create(thread2_entry, <span class="string">&quot;2_test_thread2&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407051937633.png" alt="image-20240705193710559"></p>
<h4 id="（3）控制写速率"><a href="#（3）控制写速率" class="headerlink" title="（3）控制写速率"></a>（3）控制写速率</h4><p>如果设置<strong>读数据的速率大于写数据的速率</strong>，则会产生以下效果，可以发现生产者写一个数据，消费者读一个数据：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407051938284.png" alt="image-20240705193854205"></p>
<blockquote>
<p><strong>此外，生产者线程必须在缓存中有空闲单元的情况下才能往里面写数据，否则应该等待。因此对于写速率也需要进行控制。</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buffer[<span class="number">100</span>];  <span class="comment">// 环形数据缓冲区</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> write_idx, read_idx;  <span class="comment">// 写索引和读索引</span></span><br><span class="line"><span class="type">static</span> <span class="type">sys_sem_t</span> read_sem;</span><br><span class="line"><span class="type">static</span> <span class="type">sys_sem_t</span> write_sem;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1_entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="comment">// 消费者线程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * <span class="keyword">sizeof</span>(buffer); i++) &#123;</span><br><span class="line">		sys_sem_wait(read_sem, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> data = buffer[read_idx++];</span><br><span class="line">		<span class="keyword">if</span> (read_idx &gt;= <span class="keyword">sizeof</span>(buffer)) &#123;</span><br><span class="line">			read_idx = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		plat_printf(<span class="string">&quot;thread1: read data = %d\n&quot;</span>, data);</span><br><span class="line">		</span><br><span class="line">		sys_sem_notify(write_sem);</span><br><span class="line">		sys_sleep(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2_entry</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="comment">// 生产者线程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * <span class="keyword">sizeof</span>(buffer); i++) &#123;</span><br><span class="line">		sys_sem_wait(write_sem, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		buffer[write_idx++] = i;</span><br><span class="line">		<span class="keyword">if</span> (write_idx &gt;= <span class="keyword">sizeof</span>(buffer)) &#123;</span><br><span class="line">			write_idx = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		plat_printf(<span class="string">&quot;thread2: write data = %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">		sys_sem_notify(read_sem);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	read_sem = sys_sem_create(<span class="number">0</span>);</span><br><span class="line">	write_sem = sys_sem_create(<span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上述程序后，出现下列现象：</p>
<ol>
<li><p>生产者线程进行大量写操作，<strong>迅速将缓存区占满</strong>（体现为write data &#x3D; 99）;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys_sem_wait(write_sem, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>程序开始运行时，write_sem 初始值为 100，即缓存区大小，因此此时生产者的写入不受限制，可以一直往缓存区中写入数据，直到缓存区占满。</p>
</li>
<li><p>当缓存区满后，写速率大幅度减慢，受到读速率的影响，此时读一个数据后再写一个数据。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407051948347.png" alt="image-20240705194831290"></p>
<h2 id="3、网络编程"><a href="#3、网络编程" class="headerlink" title="3、网络编程"></a>3、网络编程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端             2.启动并发起请求         4.处理相应，关闭连接</span><br><span class="line">                         |                        |</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">                   |                    |                  |</span><br><span class="line">服务器端    1.启动并等待请求     3.接受请求，并发回响应       5.关闭</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端   // 服务器端</span></span><br><span class="line"></span><br><span class="line">			   socket()  </span><br><span class="line">	              |</span><br><span class="line">socket()        bind()</span><br><span class="line">   |              |</span><br><span class="line">connect() --&gt;  listen() --&gt; accept()</span><br><span class="line">   |              |</span><br><span class="line"> send()   --&gt;   recv()</span><br><span class="line">   |              |</span><br><span class="line"> recv()   &lt;--   send()</span><br><span class="line">   |              |</span><br><span class="line"> close()        close()</span><br></pre></td></tr></table></figure>

<h3 id="利用套接字设计客户端"><a href="#利用套接字设计客户端" class="headerlink" title="利用套接字设计客户端"></a>利用套接字设计客户端</h3><p>创建一个基于 TCP 协议的 echo 客户端：</p>
<ol>
<li>读取键盘输入的字符串并发送给服务器；</li>
<li>接收服务器发回来的回应，并显示在屏幕上。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">键盘  --(fgets)--&gt;              --(send)-------(recv)--&gt; </span><br><span class="line">                    TCP客户端                              TCP客户端</span><br><span class="line">屏幕  &lt;--(printf)--             --(recv)-------(send)--&gt;</span><br></pre></td></tr></table></figure>

<h3 id="利用套接字设计服务器端"><a href="#利用套接字设计服务器端" class="headerlink" title="利用套接字设计服务器端"></a>利用套接字设计服务器端</h3><h1 id="二、整体结构设计"><a href="#二、整体结构设计" class="headerlink" title="二、整体结构设计"></a>二、整体结构设计</h1><h2 id="1、整体结构"><a href="#1、整体结构" class="headerlink" title="1、整体结构"></a>1、整体结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- src</span><br><span class="line">	- app</span><br><span class="line">		- test</span><br><span class="line">			- main.c</span><br><span class="line">    - net</span><br><span class="line">    	- net</span><br><span class="line">    		- net_err.h  <span class="comment">// net相关的变量定义</span></span><br><span class="line">    		- net.h		 <span class="comment">// tcp/ip协议栈初始化</span></span><br><span class="line">    		- exmsg.h	 <span class="comment">// 核心工作线程初始化，所有tcp/ip相关的事件都交由该线程处理</span></span><br><span class="line">    	- src</span><br><span class="line">    - plat</span><br><span class="line">    	- net_plat.c</span><br><span class="line">    	- sys_plat.c</span><br></pre></td></tr></table></figure>



<p>整个项目的核心为<strong>工作线程</strong>，对应于<code>src/net/src/exmsg.c</code>模块。这个模块是TCP&#x2F;IP核心线程通信模块，运行了一个核心线程，<strong>所有 TCP&#x2F;IP 中相关的事件都交由该线程处理</strong>。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 协议栈初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">net_err_t</span> <span class="title function_">net_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    net_plat_init();  <span class="comment">// 初始化硬件资源</span></span><br><span class="line"></span><br><span class="line">    exmsg_init();</span><br><span class="line">    <span class="keyword">return</span> NET_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么在协议栈初始化时需要先进行硬件资源初始化？是为了适应不同平台吗？</strong></p>
<p>在编写 TCP&#x2F;IP 协议栈的过程中，在协议栈初始化时首先进行硬件资源初始化是非常重要的一步，原因主要有以下几个方面：</p>
<ol>
<li>适应不同平台：不同的平台可能有不同的硬件资源和配置要求。进行硬件资源初始化可以确保协议栈能够适应不同的平台，并能够正确地与底层硬件进行交互。</li>
<li>确保硬件资源可用：协议栈的运行依赖于底层的网络硬件资源（如网卡、网络接口等）。在协议栈初始化时，首先初始化硬件资源可以确保这些资源是可用的，并且已经准备好进行数据传输。</li>
<li>设置硬件参数：硬件资源初始化过程通常包括设置硬件参数（如网卡的 MAC 地址、IP 地址、子网掩码等）。这些参数对于协议栈的正确运行至关重要，因为它们决定了如何在网络中进行数据传输。</li>
<li>注册硬件中断和回调函数：硬件资源初始化过程中通常需要注册硬件中断和回调函数，以便在数据包到达时能够及时通知协议栈进行处理。如果没有进行硬件资源初始化，协议栈将无法及时响应网络事件。</li>
<li>分配和管理资源：硬件资源初始化过程可能涉及到分配和管理一些必要的资源，如内存缓冲区、DMA 通道等。这些资源对于协议栈的高效运行也是至关重要的。</li>
<li>错误处理：在硬件资源初始化阶段，可以检测和处理可能的硬件错误。如果硬件资源不可用或者初始化失败，可以在这个阶段进行相应的错误处理，避免后续协议栈运行时出现难以调试的问题。</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407061944836.png" alt="软件整体流程"></p>
<h2 id="2、网络结构"><a href="#2、网络结构" class="headerlink" title="2、网络结构"></a>2、网络结构</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407061739436.png" alt="整体结构设计" style="zoom: 33%;" />

<h2 id="3、协议分层"><a href="#3、协议分层" class="headerlink" title="3、协议分层"></a>3、协议分层</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407061739339.png" alt="软件层级结构"></p>
<h1 id="三、调试信息输出模块"><a href="#三、调试信息输出模块" class="headerlink" title="三、调试信息输出模块"></a>三、调试信息输出模块</h1><p>这个项目的调试信息输出模块主要用于在开发和调试过程中输出各种调试信息，包括错误、警告和一般信息。它包含了一些宏定义、函数和常量，用于控制调试信息的输出格式和级别。下面是对该模块的详细总结：</p>
<h2 id="1、dbg-c"><a href="#1、dbg-c" class="headerlink" title="1、dbg.c"></a>1、dbg.c</h2><ol>
<li><p><strong>调试信息显示样式设置</strong>：通过 ANSI 转义序列设置不同等级的显示样式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_STYLE_RESET       <span class="string">&quot;\033[0m&quot;</span>       <span class="comment">// 复位显示</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_STYLE_ERROR       <span class="string">&quot;\033[31m&quot;</span>      <span class="comment">// 红色显示</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_STYLE_WARNING     <span class="string">&quot;\033[33m&quot;</span>      <span class="comment">// 黄色显示</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调试信息输出级别</strong>：定义了不同的调试信息输出级别，每个级别对应不同的数值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_LEVEL_NONE           0         <span class="comment">// 不开启任何输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_LEVEL_ERROR          1         <span class="comment">// 只开启错误信息输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_LEVEL_WARNING        2         <span class="comment">// 开启错误和警告信息输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_LEVEL_INFO           3         <span class="comment">// 开启错误、警告、一般信息输出</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调试信息输出函数</strong></p>
<ul>
<li><p><code>dbg_print</code>：根据不同的级别输出调试信息，包括文件名、函数名、行号和具体的调试信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dbg_print</span><span class="params">(<span class="type">int</span> m_level, <span class="type">int</span> s_level, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* func, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span>* fmt, ...)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>dump_mac</code>：输出MAC地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dump_mac</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * msg, <span class="type">const</span> <span class="type">uint8_t</span> * mac)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>dump_ip_buf</code>：输出IP地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dump_ip_buf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">const</span> <span class="type">uint8_t</span>* ip)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>调试输出宏</strong>：提供了便捷的宏用于不同级别的调试信息输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> dbg_info(module, fmt, ...)  dbg_print(module, DBG_LEVEL_INFO, __FILE__, __FUNCTION__, __LINE__, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dbg_error(module, fmt, ...)  dbg_print(module, DBG_LEVEL_ERROR, __FILE__, __FUNCTION__, __LINE__, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dbg_warning(module, fmt, ...) dbg_print(module, DBG_LEVEL_WARNING, __FILE__, __FUNCTION__, __LINE__, fmt, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>断言宏</strong>：提供断言宏用于在调试过程中验证表达式的正确性，如果表达式为假，则输出错误信息并进入无限循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> dbg_assert(expr, msg)   &#123;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!(expr)) &#123;\</span></span><br><span class="line"><span class="meta">        dbg_print(DBG_LEVEL_ERROR, DBG_LEVEL_ERROR, __FILE__, __FUNCTION__, __LINE__, <span class="string">&quot;assert failed:&quot;</span>#expr<span class="string">&quot;,&quot;</span>msg); \</span></span><br><span class="line"><span class="meta">        while(1);   \</span></span><br><span class="line"><span class="meta">    &#125;   \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调试信息输出开关</strong>：定义了不同模块的调试信息输出级别：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_MBLOCK           DBG_LEVEL_ERROR         <span class="comment">// 内存块管理器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_QUEUE            DBG_LEVEL_ERROR         <span class="comment">// 定长存储块</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_MSG              DBG_LEVEL_ERROR         <span class="comment">// 消息通信</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_BUF              DBG_LEVEL_ERROR         <span class="comment">// 数据包管理器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_PLAT             DBG_LEVEL_ERROR         <span class="comment">// 系统平台</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_INIT             DBG_LEVEL_ERROR         <span class="comment">// 初始化模块</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_NETIF            DBG_LEVEL_ERROR         <span class="comment">// 网络接口层</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_ETHER            DBG_LEVEL_ERROR         <span class="comment">// 以太网协议层</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_TOOLS            DBG_LEVEL_ERROR         <span class="comment">// 工具集</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_TIMER            DBG_LEVEL_ERROR         <span class="comment">// 定时器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_ARP              DBG_LEVEL_ERROR         <span class="comment">// ARP协议</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_IP               DBG_LEVEL_ERROR         <span class="comment">// 调试开关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_ICMP             DBG_LEVEL_ERROR         <span class="comment">// 调试开关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_SOCKET           DBG_LEVEL_ERROR         <span class="comment">// 调试开关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_RAW              DBG_LEVEL_ERROR         <span class="comment">// 调试开关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_UDP              DBG_LEVEL_ERROR         <span class="comment">// 调试开关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_DNS              DBG_LEVEL_ERROR         <span class="comment">// DNS调试开关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG_TCP              DBG_LEVEL_INFO          <span class="comment">// 调试开关</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="具体实现分析"><a href="#具体实现分析" class="headerlink" title="具体实现分析"></a>具体实现分析</h3><h4 id="dbg-print-函数"><a href="#dbg-print-函数" class="headerlink" title="dbg_print 函数"></a><code>dbg_print</code> 函数</h4><p>该函数根据日志等级输出调试信息，具体实现如下：</p>
<ol>
<li><p>定义日志等级标题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* title[] = &#123;</span><br><span class="line">    [DBG_LEVEL_ERROR] = DBG_STYLE_ERROR<span class="string">&quot;error&quot;</span>,</span><br><span class="line">    [DBG_LEVEL_WARNING] = DBG_STYLE_WARNING<span class="string">&quot;warning&quot;</span>,</span><br><span class="line">    [DBG_LEVEL_INFO] = <span class="string">&quot;info&quot;</span>,</span><br><span class="line">    [DBG_LEVEL_NONE] = <span class="string">&quot;none&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是否输出日志信息：仅当主日志等级 <code>m_level</code> 大于等于子日志等级 <code>s_level</code> 时，才输出日志信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_level &gt;= s_level) &#123;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提取文件名：通过遍历字符串，从路径中提取文件名部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> * end = file + plat_strlen(file);</span><br><span class="line"><span class="keyword">while</span> (end &gt;= file) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((*end == <span class="string">&#x27;\\&#x27;</span>) || (*end == <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    end--;</span><br><span class="line">&#125;</span><br><span class="line">end++;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出日志头部信息：输出日志级别、文件名、函数名和行号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plat_printf(<span class="string">&quot;%s(%s-%s-%d):&quot;</span>, title[s_level], end, func, line);</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出具体日志信息：使用可变参数列表处理格式化字符串，输出具体日志信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str_buf[<span class="number">128</span>];</span><br><span class="line">va_list args;</span><br><span class="line"></span><br><span class="line">va_start(args, fmt);</span><br><span class="line">plat_vsprintf(str_buf, fmt, args);</span><br><span class="line">plat_printf(<span class="string">&quot;%s\n&quot;</span>DBG_STYLE_RESET, str_buf);</span><br><span class="line">va_end(args);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>假设在代码的某处使用这些宏和函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dbg_info(DBG_TCP, <span class="string">&quot;TCP connection established&quot;</span>);</span><br><span class="line">dbg_warning(DBG_TCP, <span class="string">&quot;TCP connection may be slow&quot;</span>);</span><br><span class="line">dbg_error(DBG_TCP, <span class="string">&quot;TCP connection failed&quot;</span>);</span><br><span class="line">dbg_assert(ptr != <span class="literal">NULL</span>, <span class="string">&quot;Pointer should not be NULL&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>当 <code>DBG_TCP</code> 的日志等级大于等于 <code>DBG_LEVEL_INFO</code> 时，会输出 “TCP connection established” 信息。</li>
<li>当 <code>DBG_TCP</code> 的日志等级大于等于 <code>DBG_LEVEL_WARNING</code> 时，会输出 “TCP connection may be slow” 警告。</li>
<li>当 <code>DBG_TCP</code> 的日志等级大于等于 <code>DBG_LEVEL_ERROR</code> 时，会输出 “TCP connection failed” 错误。</li>
<li>如果 <code>ptr</code> 为 <code>NULL</code>，则输出断言失败信息并进入无限循环。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>该调试信息输出模块通过定义不同的日志等级和使用可变参数处理，提供了灵活且易用的调试信息输出功能。通过宏定义，开发者可以方便地在代码中插入调试信息输出，帮助快速定位问题，提高开发效率。</p>
<h1 id="四、定长内存块管理"><a href="#四、定长内存块管理" class="headerlink" title="四、定长内存块管理"></a>四、定长内存块管理</h1><h2 id="1、协议栈中的存储管理"><a href="#1、协议栈中的存储管理" class="headerlink" title="1、协议栈中的存储管理"></a>1、协议栈中的存储管理</h2><p>当应用程序需要请求工作线程去做某事时，需要先申请一个消息结构，即一个内存块，并将这个内存块的指针插入消息队列中。工作线程在接收到这个指针后执行相应的操作，完成后释放该内存块。</p>
<p>将数据包拆分成大小一致的数据块，如下图所示。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407091442502.png" alt="image-20240709144204250" style="zoom: 67%;" />

<p>本协议栈在设计时采用<strong>固定长度</strong>的存储分配，考虑以下两点：</p>
<p>1、在某些系统上，内核并没有提供动态内存分配函数；– 考虑可移植性。</p>
<p>2、减少动态分配造成的内存碎片问题。</p>
<p>在初始化时，将数组中各个数组元素构建成一个<strong>空闲链表</strong>，当需要内存时，从中取出一个内存块用于分配，并且进行<strong>加锁</strong>处理，以适用于多线程场景。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407091805403.png" alt="定长存储分配" style="zoom: 67%;" />

<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407091701626.png" alt="image-20240709170116444"></p>
<p>实现了一个存储块管理器（<code>mblock</code>），用于管理内存块的分配和释放。通过使用链表和锁机制，实现了多线程环境下的安全内存管理。下面是对文件的详细分析和总结：</p>
<h2 id="2、mblock-c"><a href="#2、mblock-c" class="headerlink" title="2、mblock.c"></a>2、mblock.c</h2><p>定长内存块管理器（Fixed-size Memory Block Manager）通过将一个连续的内存区域分割成固定大小的块，然后使用链表管理这些块，实现了高效的内存分配和释放。以下是该模块的详细分析：</p>
<h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">mblock_t</span> &#123;</span></span><br><span class="line">    <span class="type">nlist_t</span> free_list;      <span class="comment">// 空闲块链表</span></span><br><span class="line">    <span class="type">void</span> *start;            <span class="comment">// 内存块起始地址（未使用）</span></span><br><span class="line">    <span class="type">nlocker_t</span> locker;       <span class="comment">// 锁，用于多线程同步</span></span><br><span class="line">    <span class="type">sys_sem_t</span> alloc_sem;    <span class="comment">// 分配信号量，用于控制分配时的等待</span></span><br><span class="line">&#125; <span class="type">mblock_t</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>free_list</code>: 空闲块链表，用于存储空闲内存块。</li>
<li><code>start</code>: 内存块起始地址，目前未使用。</li>
<li><code>locker</code>: 互斥锁 <code>nlocker_t</code>，用于保护对 <code>free_list</code> 的访问，确保线程安全性。</li>
<li><code>alloc_sem</code>: 分配信号量 <code>sys_sem_t</code>，用于控制在没有空闲块时的等待。</li>
</ul>
<h3 id="初始化函数-mblock-init"><a href="#初始化函数-mblock-init" class="headerlink" title="初始化函数 mblock_init"></a>初始化函数 <code>mblock_init</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">net_err_t</span> <span class="title function_">mblock_init</span><span class="params">(<span class="type">mblock_t</span> *mblock, <span class="type">void</span> *mem, <span class="type">int</span> blk_size, <span class="type">int</span> cnt, <span class="type">nlocker_type_t</span> locker_type)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于初始化定长内存块管理器：</p>
<ol>
<li>将传入的内存区域 <code>mem</code> 按照 <code>blk_size</code> 划分为 <code>cnt</code> 个固定大小的内存块，并将这些块使用链表 <code>free_list</code> 连接起来。</li>
<li>初始化互斥锁 <code>locker</code>，用于保护对 <code>free_list</code> 的并发访问。</li>
<li>如果 <code>locker_type</code> 表示需要多线程支持，就创建分配信号量 <code>alloc_sem</code>，用于在没有空闲块时的等待。</li>
</ol>
<h3 id="分配函数-mblock-alloc"><a href="#分配函数-mblock-alloc" class="headerlink" title="分配函数 mblock_alloc"></a>分配函数 <code>mblock_alloc</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mblock_alloc</span><span class="params">(<span class="type">mblock_t</span> *mblock, <span class="type">int</span> ms)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于从管理的内存块中分配一个空闲块：</p>
<ol>
<li>如果 <code>ms &lt; 0</code> 或者管理器未使用锁（即 <code>locker.type == NLOCKER_NONE</code>），则直接查询空闲块数量。</li>
<li>如果有等待信号量，使用 <code>sys_sem_wait</code> 等待空闲块的释放。</li>
<li>使用互斥锁保护对 <code>free_list</code> 的访问，从链表头部取出一个空闲块。</li>
<li>返回分配的空闲块地址。</li>
</ol>
<h3 id="空闲块数量查询函数-mblock-free-cnt"><a href="#空闲块数量查询函数-mblock-free-cnt" class="headerlink" title="空闲块数量查询函数 mblock_free_cnt"></a>空闲块数量查询函数 <code>mblock_free_cnt</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mblock_free_cnt</span><span class="params">(<span class="type">mblock_t</span> *mblock)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于获取当前空闲块的数量：</p>
<ol>
<li>使用互斥锁保护对 <code>free_list</code> 的访问，获取链表中当前空闲块的数量。</li>
<li>返回空闲块数量。</li>
</ol>
<h3 id="释放函数-mblock-free"><a href="#释放函数-mblock-free" class="headerlink" title="释放函数 mblock_free"></a>释放函数 <code>mblock_free</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mblock_free</span><span class="params">(<span class="type">mblock_t</span> *mblock, <span class="type">void</span> *block)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于释放先前分配的空闲块：</p>
<ol>
<li>使用互斥锁保护对 <code>free_list</code> 的访问，将要释放的空闲块插入到链表的尾部。</li>
<li>如果存在等待信号量，使用 <code>sys_sem_notify</code> 通知等待的线程有新的空闲块可用。</li>
</ol>
<h3 id="销毁函数-mblock-destroy"><a href="#销毁函数-mblock-destroy" class="headerlink" title="销毁函数 mblock_destroy"></a>销毁函数 <code>mblock_destroy</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mblock_destroy</span><span class="params">(<span class="type">mblock_t</span> *mblock)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于销毁内存块管理器：</p>
<ol>
<li>如果存在分配信号量 <code>alloc_sem</code>，释放该信号量。</li>
<li>销毁互斥锁 <code>locker</code>。</li>
<li>注意：该函数不会释放内存块本身，需要调用者负责管理 <code>mem</code> 的释放。</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>定长内存块管理器通过互斥锁和信号量保证了在多线程环境下的安全操作，有效地管理和利用固定大小的内存块，避免了内存碎片和资源竞争问题。每个操作都经过严格的同步控制，确保了对内存块的分配和释放的正确性和高效性。</p>
<h2 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h2><p>测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mblock_test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">mblock_t</span> blist;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> buffer[<span class="number">100</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *temp[<span class="number">10</span>];</span><br><span class="line">	mblock_init(&amp;blist, buffer, <span class="number">100</span>, <span class="number">10</span>, NLOCKER_THREAD);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		temp[i] = mblock_alloc(&amp;blist, <span class="number">0</span>);</span><br><span class="line">        plat_printf(<span class="string">&quot;block: %p, free_count: %d\n&quot;</span>, temp[i], mblock_free_cnt(&amp;blist));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		mblock_free(&amp;blist, temp[i]);</span><br><span class="line">		plat_printf(<span class="string">&quot;after free, free_count: %d\n&quot;</span>, mblock_free_cnt(&amp;blist));</span><br><span class="line">	&#125;</span><br><span class="line">	mblock_destroy(&amp;blist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407091756328.png" alt="image-20240709175656172"></p>
<h1 id="五、定长消息队列的实现"><a href="#五、定长消息队列的实现" class="headerlink" title="五、定长消息队列的实现"></a>五、定长消息队列的实现</h1><h2 id="1、协议栈中涉及定长消息队列的部分"><a href="#1、协议栈中涉及定长消息队列的部分" class="headerlink" title="1、协议栈中涉及定长消息队列的部分"></a>1、协议栈中涉及定长消息队列的部分</h2><p>消息队列主要用在两个地方：</p>
<ol>
<li>工作线程，接收来自应用程序或网卡的消息；</li>
<li>网卡部分，涉及输入队列和输出队列，放置需要发送的数据包。</li>
</ol>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407111015126.png" alt="image-20240711101556780" style="zoom: 50%;" />

<h2 id="2、fixq-c"><a href="#2、fixq-c" class="headerlink" title="2、fixq.c"></a>2、fixq.c</h2><p>定长消息队列的实现在多线程环境中非常关键，它能有效地管理有限的资源，避免资源耗尽和竞争条件。让我们来分析一下定长消息队列的具体实现：</p>
<h3 id="结构体定义-1"><a href="#结构体定义-1" class="headerlink" title="结构体定义"></a>结构体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fixq_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;               <span class="comment">// 消息队列空闲单元长度</span></span><br><span class="line">    <span class="type">int</span> in, out;            <span class="comment">// 写入/读取时的索引位置</span></span><br><span class="line">    <span class="type">int</span> cnt;                <span class="comment">// 消息队列的当前消息个数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> **buf;             <span class="comment">// 消息结构数组</span></span><br><span class="line"></span><br><span class="line">    <span class="type">nlocker_t</span> locker;       <span class="comment">// 互斥锁</span></span><br><span class="line">    <span class="type">sys_sem_t</span> recv_sem;     <span class="comment">// 读信号量</span></span><br><span class="line">    <span class="type">sys_sem_t</span> send_sem;     <span class="comment">// 写信号量</span></span><br><span class="line">&#125; <span class="type">fixq_t</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>size</code>: 消息队列的大小，即可以容纳的消息数量。</li>
<li><code>in</code>, <code>out</code>: 写入和读取消息的索引位置，循环使用以节约空间。</li>
<li><code>cnt</code>: 当前消息队列中的消息个数。</li>
<li><code>buf</code>: 指向存储消息的数组。</li>
<li><code>locker</code>: 用于保护消息队列的互斥锁。</li>
<li><code>recv_sem</code>, <code>send_sem</code>: 分别用于控制读和写的信号量。</li>
</ul>
<h3 id="初始化函数-fixq-init"><a href="#初始化函数-fixq-init" class="headerlink" title="初始化函数 fixq_init"></a>初始化函数 <code>fixq_init</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">net_err_t</span> <span class="title function_">fixq_init</span><span class="params">(<span class="type">fixq_t</span> *q, <span class="type">void</span> **buf, <span class="type">int</span> size, <span class="type">nlocker_type_t</span> type)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于初始化定长消息队列：</p>
<ol>
<li>初始化互斥锁 <code>locker</code>，确保在多线程环境下对队列操作的原子性和互斥性。</li>
<li>创建两个信号量 <code>recv_sem</code> 和 <code>send_sem</code>，用于控制读和写操作的同步，确保队列空间和消息的正确使用。</li>
<li>将外部传入的消息缓冲区 <code>buf</code> 和队列大小 <code>size</code> 赋值给消息队列结构体。</li>
</ol>
<h3 id="发送函数-fixq-send"><a href="#发送函数-fixq-send" class="headerlink" title="发送函数 fixq_send"></a>发送函数 <code>fixq_send</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">net_err_t</span> <span class="title function_">fixq_send</span><span class="params">(<span class="type">fixq_t</span> *q, <span class="type">void</span> *msg, <span class="type">int</span> tmo)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于向消息队列中发送消息 <code>msg</code>：</p>
<ol>
<li>首先通过互斥锁 <code>locker</code> 确保对队列操作的互斥性。</li>
<li>判断消息队列是否已满，如果满且超时参数 <code>tmo</code> 小于 0，则返回 <code>NET_ERR_FULL</code> 表示队列已满且不等待。</li>
<li>使用写信号量 <code>send_sem</code> 等待有空闲单元可以写入。</li>
<li>通过互斥锁再次确认队列未满，将消息写入队列，并更新索引和计数器。</li>
<li>发送完毕后，通过读信号量 <code>recv_sem</code> 通知其他线程有新消息可读取。</li>
</ol>
<h3 id="接收函数-fixq-recv"><a href="#接收函数-fixq-recv" class="headerlink" title="接收函数 fixq_recv"></a>接收函数 <code>fixq_recv</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">fixq_recv</span><span class="params">(<span class="type">fixq_t</span> *q, <span class="type">int</span> tmo)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于从消息队列中接收消息：</p>
<ol>
<li>首先通过互斥锁 <code>locker</code> 确保对队列操作的互斥性。</li>
<li>如果队列为空且超时参数 <code>tmo</code> 小于 0，则立即返回 <code>NULL</code> 表示超时或队列为空。</li>
<li>使用读信号量 <code>recv_sem</code> 等待有消息可读。</li>
<li>通过互斥锁再次确认队列非空，从队列中读取消息，并更新索引和计数器。</li>
<li>接收完毕后，通过写信号量 <code>send_sem</code> 通知其他线程有空闲空间可以写入新消息。</li>
</ol>
<h3 id="销毁函数-fixq-destroy"><a href="#销毁函数-fixq-destroy" class="headerlink" title="销毁函数 fixq_destroy"></a>销毁函数 <code>fixq_destroy</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fixq_destroy</span><span class="params">(<span class="type">fixq_t</span> *q)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于销毁消息队列：</p>
<ol>
<li>销毁互斥锁 <code>locker</code>。</li>
<li>释放读信号量 <code>recv_sem</code> 和写信号量 <code>send_sem</code>。</li>
<li>不会释放消息缓冲区 <code>buf</code>，因为它是外部传入的，由外部管理。</li>
</ol>
<h3 id="计数函数-fixq-count"><a href="#计数函数-fixq-count" class="headerlink" title="计数函数 fixq_count"></a>计数函数 <code>fixq_count</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fixq_count</span><span class="params">(<span class="type">fixq_t</span> *q)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于获取当前消息队列中的消息个数：</p>
<ol>
<li>使用互斥锁 <code>locker</code> 锁定，获取 <code>cnt</code> 计数器的值。</li>
<li>返回当前消息个数。</li>
</ol>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>定长消息队列通过互斥锁和信号量确保了多线程环境下对队列操作的安全性和同步性，避免了竞争条件和资源冲突。每个操作函数都在操作前后使用互斥锁进行保护，并利用信号量进行同步控制，保证了队列的正确操作顺序和状态。</p>
<blockquote>
<p>定长消息队列依赖定长内存块来管理消息的存储。每当需要<strong>发送一个消息</strong>时，消息队列会向内存块管理器申请一个空闲的内存块来存储该消息。当<strong>消息处理完毕后</strong>，消息队列会将该内存块释放回内存块管理器，以便再次利用。</p>
</blockquote>
<h1 id="六、网络数据包结构设计"><a href="#六、网络数据包结构设计" class="headerlink" title="六、网络数据包结构设计"></a>六、网络数据包结构设计</h1><h2 id="1、网络数据包的具体设计"><a href="#1、网络数据包的具体设计" class="headerlink" title="1、网络数据包的具体设计"></a>1、网络数据包的具体设计</h2><p>当协议栈连接网络后，将接收到来自网络的各种不同大小的数据包，应用程序也会发送各种不同大小的数据包，长度从几字节到几十 KB 不等。若全部采用定长的数据包来存储，较为死板；而如果采用动态分配的方式，则会产生大量的内部碎片。因此借鉴 FAT32 文件系统的文件管理方式，采用<strong>链式存储</strong>的方式管理数据包。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407111625628.png" alt="image-20240711162533261"></p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="添加包头和移除包头"><a href="#添加包头和移除包头" class="headerlink" title="添加包头和移除包头"></a>添加包头和移除包头</h4><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407111628778.png" alt="image-20240711162806417"></p>
<h4 id="对数据包中的任意位置进行读写"><a href="#对数据包中的任意位置进行读写" class="headerlink" title="对数据包中的任意位置进行读写"></a>对数据包中的任意位置进行读写</h4><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407111628400.png" alt="image-20240711162830179" style="zoom:50%;" />

<h4 id="调整大小、合并数据包"><a href="#调整大小、合并数据包" class="headerlink" title="调整大小、合并数据包"></a>调整大小、合并数据包</h4><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407111629556.png" alt="image-20240711162910344" style="zoom: 33%;" />

<h3 id="数据包整体框图"><a href="#数据包整体框图" class="headerlink" title="数据包整体框图"></a>数据包整体框图</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407121512637.png" alt="数据包"></p>
<p>尾插法方式分配块列表：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407121521391.png" alt="image-20240712152100299"></p>
<p>头插法方式分配块列表：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407121601312.png" alt="image-20240712160144214"></p>
<h2 id="2、基本操作1：添加包头和移除包头"><a href="#2、基本操作1：添加包头和移除包头" class="headerlink" title="2、基本操作1：添加包头和移除包头"></a>2、基本操作1：添加包头和移除包头</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407112011374.png" alt="image-20240711201125051"></p>
<p>针对这两种不同的建立快链表的方式，选择<strong>头插法</strong>建立链表。这样做<strong>可以给包头预留空间，方便以后直接添加包头</strong>。这样做就不必频繁分配包头的空间，可以直接利用头部的未用空间。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407112014885.png" alt="image-20240711201455593"></p>
<p>为了便于后续访问，需要保证包头的数据在一片连续的内存空间里。有两种添加包头的方式如下：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407121633164.png" alt="image-20240712163322897" style="zoom: 50%;" />

<h3 id="2-2-测试"><a href="#2-2-测试" class="headerlink" title="2.2 测试"></a>2.2 测试</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pktbuf_test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pktbuf_t</span> *buf = pktbuf_alloc(<span class="number">2000</span>);</span><br><span class="line">    pktbuf_free(buf);</span><br><span class="line"></span><br><span class="line">    buf = pktbuf_alloc(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; i++) &#123;</span><br><span class="line">        pkybuf_add_header(buf, <span class="number">33</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407121658896.png" alt="image-20240712165851854"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407121659577.png" alt="image-20240712165911505"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407121659478.png" alt="image-20240712165920430"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407121659111.png" alt="image-20240712165932061"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407121659904.png" alt="image-20240712165950857"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407121700405.png" alt="image-20240712170003359"></p>
<p>当 16 次分配结束，最后的结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407121700168.png" alt="image-20240712170041116"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/03/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE3_C++%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/03/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE3_C++%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">项目2_C++高性能服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-07-03 11:16:57 / 修改时间：16:21:51" itemprop="dateCreated datePublished" datetime="2024-07-03T11:16:57+08:00">2024-07-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>108</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>Centos7</p>
<p>GCC 9.1</p>
<p>cmake</p>
<h2 id="项目路径"><a href="#项目路径" class="headerlink" title="项目路径"></a>项目路径</h2><p>bin – 二进制文件</p>
<p>build – 中间文件路径</p>
<p>cmake – cmake函数文件夹</p>
<p>CMakeLists.txt – cmake的定义文件</p>
<p>lib – 库的输出路径</p>
<p>Makefile</p>
<p>sylar – 源代码路径</p>
<p>tests – 测试代码</p>
<h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><h3 id="1）Log4J"><a href="#1）Log4J" class="headerlink" title="1）Log4J"></a>1）Log4J</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logger(定义日志类别)</span><br><span class="line">    |</span><br><span class="line">    |--------- Formatter(日志格式)</span><br><span class="line">    |</span><br><span class="line">Appender(日志输出地方)</span><br></pre></td></tr></table></figure>



<h2 id="协程库封装"><a href="#协程库封装" class="headerlink" title="协程库封装"></a>协程库封装</h2><h2 id="socket-函数库"><a href="#socket-函数库" class="headerlink" title="socket 函数库"></a>socket 函数库</h2><h2 id="http-协议开发"><a href="#http-协议开发" class="headerlink" title="http 协议开发"></a>http 协议开发</h2><h2 id="分布式协议库"><a href="#分布式协议库" class="headerlink" title="分布式协议库"></a>分布式协议库</h2><h2 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/03/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1_diy_x86os/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/03/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1_diy_x86os/" class="post-title-link" itemprop="url">项目1_diyx86os</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-03 11:16:42" itemprop="dateCreated datePublished" datetime="2024-07-03T11:16:42+08:00">2024-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-04 16:09:38" itemprop="dateModified" datetime="2024-07-04T16:09:38+08:00">2024-07-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>56k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3:24</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="一、源码测试过程报错"><a href="#一、源码测试过程报错" class="headerlink" title="一、源码测试过程报错"></a>一、源码测试过程报错</h1><p>1、出现报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[build] x86_64-elf-objdump: Dwarf Error: found dwarf version <span class="string">&#x27;7424&#x27;</span>, this reader only handles version 2, 3 and 4 information.</span><br></pre></td></tr></table></figure>

<p>工具链相关错误，可忽略。</p>
<p>2、测试过程中的编译时遇到错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DiskPart 遇到错误: 由于虚拟磁盘系统限制，无法完成请求的操作。虚拟硬盘文件必须是未压缩和未加密的文件，并且不能是稀疏文件。</span><br></pre></td></tr></table></figure>

<p>解决：取消勾选“压缩或加密属性”</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081530696.png" alt="image-20240508153049493" style="zoom: 67%;" />

<p>3、dd命令不存在：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;dd if=kernel.elf of=disk1.vhd bs=512 conv=notrunc seek=100 &#x27;dd&#x27; 不是内部或外部命令，也不是可运行的程序 或批处理文件。</span><br></pre></td></tr></table></figure>

<p>在Git的安装路径下找到dd.exe文件，并将对应的bin目录添加到系统变量中：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081641135.png" alt="image-20240508164113684"></p>
<p>4、调试成功时，终端显示如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> not exist <span class="string">&quot;disk1.vhd&quot;</span> (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;disk1.vhd not found in image directory&quot;</span></span><br><span class="line"> notepad win_error.txt</span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> not exist <span class="string">&quot;disk2.vhd&quot;</span> (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;disk2.vhd not found in image directory&quot;</span></span><br><span class="line"> notepad win_error.txt</span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">set</span> DISK1_NAME=disk1.vhd</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">dd</span> <span class="keyword">if</span>=boot.bin of=disk1.vhd bs=512 conv=notrunc count=1 </span><br><span class="line">1+0 records <span class="keyword">in</span></span><br><span class="line">1+0 records out</span><br><span class="line">512 bytes copied, 0.009362 s, 54.7 kB/s</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">dd</span> <span class="keyword">if</span>=loader.bin of=disk1.vhd bs=512 conv=notrunc seek=1 </span><br><span class="line">24+0 records <span class="keyword">in</span></span><br><span class="line">24+0 records out</span><br><span class="line">12288 bytes (12 kB, 12 KiB) copied, 0.0077902 s, 1.6 MB/s</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">dd</span> <span class="keyword">if</span>=kernel.elf of=disk1.vhd bs=512 conv=notrunc seek=100 </span><br><span class="line">98+1 records <span class="keyword">in</span></span><br><span class="line">98+1 records out</span><br><span class="line">50452 bytes (50 kB, 49 KiB) copied, 0.0353497 s, 1.4 MB/s</span><br><span class="line">83+1 records <span class="keyword">in</span></span><br><span class="line">83+1 records out</span><br><span class="line">42968 bytes (43 kB, 42 KiB) copied, 0.0838259 s, 513 kB/s</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">set</span> DISK2_NAME=disk2.vhd</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">set</span> TARGET_PATH=k</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> <span class="keyword">select</span> vdisk file=<span class="string">&quot;D:\PostGraduate\cppex\diyx86os\image\disk2.vhd&quot;</span>  1&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> attach vdisk  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> <span class="keyword">select</span> partition 1  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> assign letter=k  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;diskpart /s a.txt</span><br><span class="line"></span><br><span class="line">Microsoft DiskPart 版本 10.0.19041.3636</span><br><span class="line"></span><br><span class="line">Copyright (C) Microsoft Corporation.</span><br><span class="line">在计算机上: DESKTOP-TVGU2EA</span><br><span class="line"></span><br><span class="line">DiskPart 已成功选择虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">  100 百分比已完成</span><br><span class="line"></span><br><span class="line">DiskPart 已成功连接虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">分区 1 现在是所选分区。</span><br><span class="line"></span><br><span class="line">DiskPart 成功地分配了驱动器号或装载点。</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> 0 NEQ 0 (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;attach disk2.vhd failed&quot;</span></span><br><span class="line"> notepad win_error.txt</span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;del a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;copy /Y *.elf k:\</span><br><span class="line">init.elf</span><br><span class="line">kernel.elf</span><br><span class="line">loop.elf</span><br><span class="line">shell.elf</span><br><span class="line">snake.elf</span><br><span class="line">已复制         5 个文件。</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> <span class="keyword">select</span> vdisk file=<span class="string">&quot;D:\PostGraduate\cppex\diyx86os\image\disk2.vhd&quot;</span>  1&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="built_in">echo</span> detach vdisk  1&gt;&gt;a.txt</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;diskpart /s a.txt</span><br><span class="line"></span><br><span class="line">Microsoft DiskPart 版本 10.0.19041.3636</span><br><span class="line"></span><br><span class="line">Copyright (C) Microsoft Corporation.</span><br><span class="line">在计算机上: DESKTOP-TVGU2EA</span><br><span class="line"></span><br><span class="line">DiskPart 已成功选择虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">DiskPart 已成功分离虚拟磁盘文件。</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;<span class="keyword">if</span> 0 NEQ 0 (</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;detach disk2.vhd failed&quot;</span></span><br><span class="line"> notepad win_error.txt  </span><br><span class="line"> <span class="built_in">exit</span> -1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;del a.txt</span><br><span class="line"> *  终端将被任务重用，按任意键关闭。 </span><br><span class="line"></span><br><span class="line"> *  正在执行任务: D:\PostGraduate\cppex\diyx86os\start\<span class="built_in">test</span>/script/qemu-debug-win.bat </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D:\PostGraduate\cppex\diyx86os\image&gt;start qemu-system-i386  -m 128M -s -S -serial stdio -drive file=disk1.vhd,index=0,media=disk,format=raw -drive file=disk2.vhd,index=1,media=disk,format=raw -d pcall,page,mmu,cpu_reset,guest_errors,page,trace:ps2_keyboard_set_translation</span><br><span class="line"> *  终端将被任务重用，按任意键关闭。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二、引导程序：接管控制权"><a href="#二、引导程序：接管控制权" class="headerlink" title="二、引导程序：接管控制权"></a>二、引导程序：接管控制权</h1><h2 id="2-1-计算机启动流程简介"><a href="#2-1-计算机启动流程简介" class="headerlink" title="2.1 计算机启动流程简介"></a>2.1 计算机启动流程简介</h2><p>从上电到运行计算机经历了什么？</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081654966.png" alt="image-20240508165407603"></p>
<p><code>BIOS</code>：基本输入输出系统。固化在flash芯片上。</p>
<p><strong>BIOS程序由硬件自己控制，本项目编写自己的引导代码和操作系统代码。</strong></p>
<p><code>disk1</code>是<code>qemu</code>的启动硬盘，<code>qemu</code>启动时会从磁盘最开始取<code>512</code>字节。</p>
<p><code>BIOS</code>在加载引导代码时，会根据用户的配置选择从磁盘加载还是从软盘加载，整个课程处理从磁盘加载的情况。</p>
<h2 id="2-2-接管计算机运行控制权"><a href="#2-2-接管计算机运行控制权" class="headerlink" title="2.2 接管计算机运行控制权"></a>2.2 接管计算机运行控制权</h2><p>硬盘的分类：</p>
<ul>
<li><p>机械硬盘：包含电机。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081957449.png" alt="image-20240508195742085"></p>
</li>
<li><p>固态硬盘：容量小但速度快。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405081959718.png" alt="image-20240508195937467"></p>
</li>
</ul>
<p>启动时，<code>BIOS</code>会将磁盘的第<code>0</code>个扇区加载到<code>0x7c00</code>处开始运行。即只需要将程序放在第<code>0</code>号扇区，就会自动被加载到内存中运行。完成从<code>BIOS</code>程序到引导程序的跳转过程。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082011134.png" alt="image-20240508201149042"></p>
<p>在<code>vscode</code>中以十六进制编辑器模式打开<code>disk1.vhd</code>，在<code>000001F0</code>处（即第<code>0</code>号扇区的最后两个字节）可看到<code>1FE:0x55</code>, <code>1FF:0xAA</code>，即为上图所示的两个引导标志所在位置。只有这两个引导标志正确时，<code>BIOS</code>才会将磁盘的第<code>0</code>个扇区加载到<code>0x7c00</code>处开始运行。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082008662.png" alt="image-20240508200825616"></p>
<p>此时，若将<code>55/AA</code>进行改动，并重新启动<code>qemu</code>，操作系统将无法被正常启动，会显示如下结果：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082009410.png" alt="image-20240508200958280" style="zoom:67%;" />

<p><strong>为简化，本项目不考虑引导过程中一个磁盘包含多个分区的情况。</strong></p>
<h2 id="2-3-创建可引导的启动程序"><a href="#2-3-创建可引导的启动程序" class="headerlink" title="2.3 创建可引导的启动程序"></a>2.3 创建可引导的启动程序</h2><h3 id="1-整体的项目逻辑"><a href="#1-整体的项目逻辑" class="headerlink" title="1. 整体的项目逻辑"></a>1. 整体的项目逻辑</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-.vscode</span><br><span class="line">	- launch.json	// GDB调试相关信息</span><br><span class="line">	- settings.json</span><br><span class="line">	- tasks.json	// 定义[终端-运行任务]中的相关任务</span><br><span class="line">	</span><br><span class="line">// 定义了[终端-运行任务]中相关任务的命令脚本</span><br><span class="line">- script	</span><br><span class="line"></span><br><span class="line">// 包含若干个子工程</span><br><span class="line">- <span class="built_in">source</span>			</span><br><span class="line">    - applib		// 系统调用库</span><br><span class="line">    - boot			// 引导程序</span><br><span class="line">    - <span class="built_in">comm</span></span><br><span class="line">    - init			// 初始进程</span><br><span class="line">    - kernel		// 操作系统内核</span><br><span class="line">    	- cpu			// 存放cpu相关</span><br><span class="line">    	- include		// 存放头文件</span><br><span class="line">    	- init			// 相关初始化</span><br><span class="line">    - loader		// 加载程序</span><br><span class="line">    - loop			// 应用程序</span><br><span class="line">    - shell			// 命令行应用</span><br><span class="line">    </span><br><span class="line">- CMakeLists.txt</span><br></pre></td></tr></table></figure>

<h3 id="2-整体的开发工作流程："><a href="#2-整体的开发工作流程：" class="headerlink" title="2. 整体的开发工作流程："></a>2. 整体的开发工作流程：</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082034893.png" alt="image-20240508203408507" style="zoom:150%;" />

<h2 id="2-4-初始化引导程序"><a href="#2-4-初始化引导程序" class="headerlink" title="2.4 初始化引导程序"></a>2.4 初始化引导程序</h2><p><strong>主要任务：对boot程序进行简单初始化。</strong></p>
<h3 id="1-什么是引导程序？"><a href="#1-什么是引导程序？" class="headerlink" title="1. 什么是引导程序？"></a>1. 什么是引导程序？</h3><ul>
<li><p>主要用于为操作系统运行初始化运行环境，并加载操作系统运行。</p>
</li>
<li><p><strong>本项目中的引导程序涉及以下三个工作</strong>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082059875.png" alt="image-20240508205916747"></p>
</li>
</ul>
<p>由于BIOS只加载磁盘的第0扇区（512字节）到内存中，对于上述功能来说这个代码大小是不够的，因此需要考虑采用扩展程序的办法。</p>
<p>有以下两种方式，<strong>本项目采用方式二</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082102910.png" alt="image-20240508210246804"></p>
<h3 id="2-为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。"><a href="#2-为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。" class="headerlink" title="2. 为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。"></a>2. 为了兼容早期的应用程序，x86在上电启动后，会自动进行实模式。</h3><p>实模式包含以下特点：</p>
<ul>
<li>16位代码</li>
<li>无保护机制</li>
<li>无分页机制</li>
<li>仅使用1MB内存</li>
</ul>
<h3 id="3-x86与编程相关的主要内核寄存器"><a href="#3-x86与编程相关的主要内核寄存器" class="headerlink" title="3. x86与编程相关的主要内核寄存器"></a>3. x86与编程相关的主要内核寄存器</h3><p>   <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082107803.png" alt="image-20240508210729628"></p>
<ul>
<li><p>CS&#x2F;DS&#x2F;SS&#x2F;ES&#x2F;FS&#x2F;GS为段寄存器</p>
<ul>
<li><p>当访问特定内存地址时，需要采用<code>段:偏移</code>的形式，即实际地址为<code>段值&lt;&lt;4+偏移</code>。</p>
</li>
<li><p>例如：访问<code>0x7c00</code>，需要使用<code>0x7c0:0</code>，或<code>0:0x7c00</code></p>
</li>
<li><p>注意：初始化段寄存器时无需显示初始化<code>CS</code>。</p>
<blockquote>
<p>在 x86 架构中，CS（Code Segment）寄存器是用于存放代码段的选择子，在实模式下，CS 寄存器的初始化通常由处理器自动完成。</p>
<p>在启动阶段，处理器会将 CS 寄存器设置为默认值，通常为 0xFFFF，这意味着 CS 段选择子为 0xFFFF，代码段的起始地址是 0xFFFF0。这个默认的值使得处理器能够正常从 BIOS 的 ROM 中加载启动代码，并执行第一条指令。因此，在启动阶段，通常不需要显式地设置 CS 寄存器。</p>
<p>相反，通过设置 DS、SS、ES、FS、GS 等段寄存器为 0，可以将默认的段地址 0 应用于数据段、栈段和其他段。这样，CPU 将能够正确访问位于物理地址 0 处的引导程序代码，并且在实模式下，所有的段都共享同一个地址空间，因此 CS 寄存器的设置可以由 CPU 自动处理。</p>
</blockquote>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082110449.png" alt="image-20240508211028354"></p>
</li>
</ul>
<h3 id="4-实模式下的内存映射（8086）"><a href="#4-实模式下的内存映射（8086）" class="headerlink" title="4. 实模式下的内存映射（8086）"></a>4. 实模式下的内存映射（8086）</h3><ul>
<li><p>其中灰色为可用区域。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405082112921.png" alt="image-20240508211243702" style="zoom:50%;" /></li>
</ul>
<h2 id="2-5-使用BIOS中断显示字符"><a href="#2-5-使用BIOS中断显示字符" class="headerlink" title="2.5 使用BIOS中断显示字符"></a>2.5 使用BIOS中断显示字符</h2><h3 id="1-如何显示字符？"><a href="#1-如何显示字符？" class="headerlink" title="1. 如何显示字符？"></a>1. 如何显示字符？</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090906770.png" alt="image-20240509090652672" style="zoom: 80%;" />

<p>BIOS提供了一组服务，可以方便地帮助我们操纵硬件，避免与硬件细节打交道。</p>
<ul>
<li>当调用<code>INT</code>软中断时，<code>CPU</code>会转到中断向量表处（<code>0x00000000~0x000003FF</code>），从中取出相应的地址位置，取出<code>BIOS</code>程序的入口地址，从而转到<code>BIOS</code>程序中运行。</li>
<li>参数通过寄存器传递。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090908623.png" alt="image-20240509090809536" />

<ul>
<li>本项目采用<code>INT 10, AH=0xE</code>显示字符<ul>
<li>该<code>BIOS</code>中断的作用是：显示字符，同时光标前移，其中（寄存器）<code>AL=字符</code>、<code>BL=前景色</code>、<code>BH=页码</code>。</li>
<li>具体来说<ul>
<li><code>BH</code>为目前的显示页。若在图形模式，<code>BH</code>需设置为0；</li>
<li>假如在图形模式下，也可设定<code>BL</code>来表示文字的颜色，文字模式下的<code>BL</code>则无此功能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2、BIOS-INT-10中断功能"><a href="#2、BIOS-INT-10中断功能" class="headerlink" title="2、BIOS INT 10中断功能"></a>2、BIOS INT 10中断功能</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_28256699/article/details/121103977">BIOS INT 10中断功能详解</a></p>
<h2 id="2-6-使用BIOS中断读取磁盘"><a href="#2-6-使用BIOS中断读取磁盘" class="headerlink" title="2.6 使用BIOS中断读取磁盘"></a>2.6 使用BIOS中断读取磁盘</h2><h3 id="1-怎样完成从Boot加载loader的过程？"><a href="#1-怎样完成从Boot加载loader的过程？" class="headerlink" title="1. 怎样完成从Boot加载loader的过程？"></a>1. 怎样完成从Boot加载loader的过程？</h3><p><code>BIOS</code>提供了磁盘读取的接口，便于从磁盘上读取<code>loader</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090926726.png" alt="image-20240509092600575"></p>
<p><strong>本项目的设计是在磁盘的第<code>0</code>号扇区（即<code>Boot</code>程序后）紧挨着放置<code>loader</code>程序。在加载时，考虑将其加载到<code>0x8000</code>处。</strong></p>
<ul>
<li>从磁盘上的第<code>1</code>号扇区开始，读取指定数量的扇区；</li>
<li>将其加载到内存中的指定地址处（<code>0x8000</code>）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405090931367.png" alt="image-20240509093110267"></p>
<h3 id="2-INT-13磁盘读取"><a href="#2-INT-13磁盘读取" class="headerlink" title="2. INT 13磁盘读取"></a>2. INT 13磁盘读取</h3><p>（1）BIOS提供了磁盘操作的服务中断，其具体使用方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口参数								</span></span><br><span class="line">    AH = <span class="number">02</span>H							   						</span><br><span class="line">    AL = 扇区数								 </span><br><span class="line">    CH = 柱面									  </span><br><span class="line">    CL = 扇区								     </span><br><span class="line">    DH = 磁头								 </span><br><span class="line">    DL = 驱动器</span><br><span class="line">      - <span class="number">00</span>H~<span class="number">7F</span>H  ：软盘</span><br><span class="line">      - <span class="number">80</span>H~<span class="number">0F</span>FH ：硬盘</span><br><span class="line">    ES:BX = 缓冲区地址（即要加载到的内存中的地址）</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 出口参数</span></span><br><span class="line">- 若传输成功，	</span><br><span class="line">	CF = <span class="number">0</span></span><br><span class="line">	AH = <span class="number">00</span>H</span><br><span class="line">	AL = 传输的扇区数</span><br><span class="line">- 若传输失败，AH = 状态码</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cx=ch:cl</code>（<code>ch</code>占高<code>8</code>位，<code>cl</code>占低<code>8</code>位）。<ul>
<li>因此<code>mov $0x2, %cx</code>相当于直接一步到位，将<code>ch</code>设置为<code>0</code>，<code>cl</code>设置为<code>2</code>。</li>
<li>注意<code>cl</code>为<code>2</code>是因为：<strong>在本项目采用的读取方法下，BIOS认为磁盘的编号是从1开始的。</strong></li>
</ul>
</li>
<li><code>mov $64, %al</code><ul>
<li><code>al</code>为读取的扇区数量，必须小于<code>128</code>，暂设置成<code>32KB</code></li>
<li>因为一个扇区大小是<code>512B</code>，即<code>0.5KB</code>。因此若要暂设成<code>32KB</code>，即相当于<code>64</code>个扇区。</li>
</ul>
</li>
</ul>
<p>（2）运行完成后，将会把磁盘<code>1</code>中的相关内容加载到内存的<code>0x8000</code>处：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091016385.png" alt="image-20240509101626325"></p>
<h2 id="2-7-初始化引导程序"><a href="#2-7-初始化引导程序" class="headerlink" title="2.7 初始化引导程序"></a>2.7 初始化引导程序</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091022007.png" alt="image-20240509102201895"></p>
<h3 id="1、如何生成loader并写入磁盘映像？"><a href="#1、如何生成loader并写入磁盘映像？" class="headerlink" title="1、如何生成loader并写入磁盘映像？"></a>1、如何生成loader并写入磁盘映像？</h3><h3 id="2、怎样从boot跳转到loader执行？"><a href="#2、怎样从boot跳转到loader执行？" class="headerlink" title="2、怎样从boot跳转到loader执行？"></a>2、怎样从boot跳转到loader执行？</h3><h1 id="三、加载器loader的实现"><a href="#三、加载器loader的实现" class="headerlink" title="三、加载器loader的实现"></a>三、加载器loader的实现</h1><h2 id="3-1-利用内联汇编显示字符串"><a href="#3-1-利用内联汇编显示字符串" class="headerlink" title="3.1 利用内联汇编显示字符串"></a>3.1 利用内联汇编显示字符串</h2><p>用于显示loader加载过程，从而提示加载到哪一步时出现问题。</p>
<h3 id="1、内联汇编理论"><a href="#1、内联汇编理论" class="headerlink" title="1、内联汇编理论"></a>1、内联汇编理论</h3><ul>
<li><p><strong>概述</strong></p>
<p>在开发操作系统过程中，有时必须使用某些特殊的指令（如<code>int/outb/hlt</code>等），而<code>C</code>编译器无法自动使用这些指令。因此，如果要使用这些指令，有两种方式：</p>
<ul>
<li>在汇编文件中为该指令的使用<strong>创建汇编函数（子程序）</strong>，然后在C代码中以函数调用的方式去使用；</li>
<li>使用<strong>内联汇编</strong>，即在C代码中嵌入汇编程序。</li>
</ul>
<p>在大多数情况下，使用内联汇编会更加简单、易用。因此，以下将简要介绍本项目中所用的相关的GCC内联汇编的写法。</p>
</li>
<li><p><strong>基本格式</strong></p>
<p>基本格式如下，以<code>asm</code>关键字开头，包含<code>3</code>个可选的配置项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(汇编语句</span><br><span class="line"> :输出操作数(可选)</span><br><span class="line"> :输入操作数(可选)</span><br><span class="line"> :被破坏的寄存器列表(可选)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>下面举个例子，其功能为将<code>a</code>的值赋值给<code>b</code>，具体代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>, b;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;movl %1,%%eax; movl %%eax, %0;&quot;</span></span><br><span class="line">	:<span class="string">&quot;=r&quot;</span>(b)	<span class="comment">/* 输出 */</span></span><br><span class="line">	:<span class="string">&quot;r&quot;</span>(a)		<span class="comment">/* 输入 */</span></span><br><span class="line">	:<span class="string">&quot;%eax&quot;</span>		<span class="comment">/* 破坏寄存器 */</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其效果等价于<code>movl a, %%eax; movl %%eax, b</code>，即：将<code>a</code>的值先给<code>eax</code>寄存器，再将<code>eax</code>寄存器的值给到<code>b</code>，最终实现<code>b=a</code>的效果。</p>
</li>
<li><p><strong>具体格式说明</strong></p>
<ul>
<li><p>只有一条汇编语句</p>
<p>在内联汇编中，可以只有汇编语句，即没有输出、输入操作数，没有被破坏的寄存器列表。例如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;hlt&quot;</span>);  <span class="comment">// 让CPU暂停运行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有多条汇编语句</p>
<p>当有多条汇编语句时，需要写在同一字符串中，不同语句之间用<code>;</code>或者<code>\n\t</code>分隔。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;sti; hlt&quot;</span>);	<span class="comment">// 开启中断，然后让CPU暂停运行</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;sti\n\thlt&quot;</span>);	<span class="comment">// 开启中断，然后让CPU暂停运行</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;sti\n\t&quot;</span>		<span class="comment">// 同上。C语言中多个连续的字符串，会被认为是同一字符串</span></span><br><span class="line">    <span class="string">&quot;hlt&quot;</span>);			<span class="comment">// 开启中断，然后让CPU暂停运行</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>有输出操作数</strong></p>
<p>当汇编语句中有些数据需要存储到<code>C</code>语言中的某些变量中时，则可以使用输出操作数。例如，下面的代码是将<code>c</code>变量的值通过<code>mov $3, c</code>设置成<code>3</code>。其中<code>%[out]</code>为定义的一个输出约束，其名称应与<code>:</code>后的<code>out</code>相同，<code>&quot;=r&quot;(c)</code>指定了<code>c</code>变量映射到某个寄存器中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;mov $3, %[out]&quot;</span>:[out]<span class="string">&quot;=r&quot;</span>(c));</span><br></pre></td></tr></table></figure>

<p>通过上述方式，即实现了类似<code>mov $3,c</code>的效果。</p>
<p>其中<code>=r</code>还可以设置成其它，如下表所示</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">寄存器</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="center">任意寄存器</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">%eax,%ax,%al</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">%ebx,%bx,%bl</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">%ecx,%cx,%cl</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">%edx,%dx,%d</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">%esi,%si</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">%edi,%di</td>
</tr>
</tbody></table>
</li>
<li><p><strong>有输入操作数</strong></p>
<p>当需要从<code>C</code>语言中读取变量的值到汇编语句中时，则需要使用输入操作数。例如，下面的代码中，<code>mov%[ch], %%al</code>用于将<code>c</code>变量中的字符写到<code>al</code>中。因此，在输入操作数中使用了<code>[ch]&quot;r&quot;(c)</code>，即<code>c</code>变量映射到某个寄存器上（见上文中输出操作数的类似设置）。最终的效果为：<code>mov$0xe,%%ah、mov%[c],%%al</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line">    <span class="string">&quot;mov $0xe, %%ah\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;mov %[ch], %%al\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;int $Ox10&quot;</span>::[ch]<span class="string">&quot;r&quot;</span>(c)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免优化</p>
<p>在某些情况下，<code>GCC</code>编译器会对内联汇编中的汇编语句进行优化处理，最终导致生成语句和预期的不同，影响程序的执行结果。为了避免这些问题，可以强制要求<code>GCC</code>不对其进行优化，即原样的生成。要达到这点，可以使用<code>__asm__ __volatile_</code>替代原来的<code>asm</code>。</p>
</li>
<li><p>参考资料</p>
<p>GCC内联汇编介绍：<a target="_blank" rel="noopener" href="https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a><br>GCC内联汇编介绍：<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Inline_Assembly">https://wiki.osdev.org/Inline_Assembly</a><br>内联汇编示例：<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Inline_Assembly/Examples">https://wiki.osdev.org/Inline_Assembly/Examples</a></p>
</li>
</ul>
<h3 id="2、示例"><a href="#2、示例" class="headerlink" title="2、示例"></a>2、示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_msg</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> * msg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = *msg++) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 利用内联汇编显示字符串</span></span><br><span class="line">        <span class="keyword">asm</span>(</span><br><span class="line">            <span class="string">&quot;mov $0xe, %%ah\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;mov %[ch], %%al\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;int $0x10&quot;</span></span><br><span class="line">            ::[ch]<span class="string">&quot;r&quot;</span>(c)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loader_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    show_msg(<span class="string">&quot;....loading....\n\r&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405091941355.png" alt="image-20240509194129987"></p>
<h2 id="3-2-检测内存容量"><a href="#3-2-检测内存容量" class="headerlink" title="3.2 检测内存容量"></a>3.2 检测内存容量</h2><p>对<code>loader</code>做一些功能扩展。</p>
<h3 id="1、内存检测方法理论"><a href="#1、内存检测方法理论" class="headerlink" title="1、内存检测方法理论"></a>1、内存检测方法理论</h3><p>内存检测方法：<code>INT 0x15, EAX = 0xE820</code></p>
<p>没有找到专门介绍内存检测方法的官方文档，只在<code>osdev</code>网站上（见下文参考资料）中找到相关的检测方法。具体来看，其中有简单也有复杂的方法，有的只在某些机器上可用。最推荐的一种方法如下（摘自osdev）：</p>
<blockquote>
<p><strong>第一次调用时，ES: DI存储保存读取的信息的存储位置：</strong><br>清除<code>EBX</code>，设置为<code>0</code><br><code>EDX</code>设置成	<code>0x534D4150</code><br><code>EAX</code>设置成	<code>0xE820</code><br><code>ECX</code>设置成	<code>24</code><br>执行		   	 <code>INT 0x15</code><br>返回结果      <code>EAX=0x534D4150</code>，<code>CF</code>标志清<code>0</code>，<code>EBX</code>被设置成某个数值用于下次调用，<code>CL</code>&#x3D;实际读取的字节数</p>
<p><strong>后续调用：</strong><br><code>EDX</code>设置成	<code>0x534D4150</code><br><code>EAX</code>重设为	<code>0xE820</code><br><code>ECX</code>重设为	<code>24</code><br>执行				  <code>INT 0x15</code><br>返回结果	   <code>EAX=0x534D4150</code>，<code>CF</code>标志清<code>0</code>。如果<code>EBX=0</code>，则表明读取完毕，否则当前条目有效。</p>
</blockquote>
<p>参考资料——内存检测方法：<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Detecting_Memory_(x86)">https://wiki.osdev.org/Detecting_Memory_(x86)</a></p>
<h3 id="2、示例-1"><a href="#2、示例-1" class="headerlink" title="2、示例"></a>2、示例</h3><p>首先需要自定义一个结构体来保存boot获取到的硬件信息，以便后期传递给操作系统使用。定义在comm中</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092034455.png" alt="image-20240509203459102"></p>
<p>当<code>for</code>循环执行完毕后，<code>boot_info</code>内部的信息如下，共分配两块内存区域：</p>
<ul>
<li>第1块，<code>0-640KB</code>左右，在<code>1MB</code>以内；</li>
<li>第2块，<code>1MB-128MB</code>左右。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092042975.png" alt="image-20240509204234901"></p>
<p>可以结合<code>qemu</code>的配置脚本来看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@REM 适用于windows</span><br><span class="line">start qemu-system-i386  -m 128M -s -S  -drive file=disk1.vhd,index=0,media=disk,format=raw -drive file=disk2.vhd,index=1,media=disk,format=raw -d pcall,page,mmu,cpu_reset,guest_errors,page,trace:ps2_keyboard_set_translation</span><br></pre></td></tr></table></figure>

<p><code>qemu</code>启动时内存大小分配即为<code>128M</code>，即<code>-m 128M</code>。</p>
<h2 id="3-3-切换至保护模式"><a href="#3-3-切换至保护模式" class="headerlink" title="3.3 切换至保护模式"></a>3.3 切换至保护模式</h2><h3 id="1、理论基础"><a href="#1、理论基础" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092111828.png" alt="image-20240509211140943"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405092111423.png" alt="image-20240509211151568"></p>
<h3 id="2、编程细节"><a href="#2、编程细节" class="headerlink" title="2、编程细节"></a>2、编程细节</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdt.start31_16 = start &gt;&gt; <span class="number">16</span>;</span><br><span class="line">gdt.start15_0 = start &amp; <span class="number">0xffff</span>;</span><br></pre></td></tr></table></figure>

<p><strong>（1）关闭中断</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关中断</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">cli</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;cli&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 禁用中断</span></span><br><span class="line">cli();</span><br></pre></td></tr></table></figure>

<p><code>cli()</code>会影响<code>eflags</code>寄存器：</p>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405100950973.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405100954581.png" width="300"/>
</center>

<p><strong>（2）打开<code>A20</code>地址线</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinolover/article/details/93877845">一步步编写操作系统 26 打开A20地址线</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 打开A20地址线</span></span><br><span class="line"><span class="type">uint8_t</span> v = inb(<span class="number">0x92</span>);</span><br><span class="line">outb(<span class="number">0x92</span>, v | <span class="number">0x2</span>);  <span class="comment">// 0x00000010</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）加载<code>GDT</code>表</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> gdt_table[][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xffff</span>, <span class="number">0x0000</span>, <span class="number">0x9a00</span>, <span class="number">0x00cf</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xffff</span>, <span class="number">0x0000</span>, <span class="number">0x9200</span>, <span class="number">0x00cf</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 加载GDT表</span></span><br><span class="line">lgdt((<span class="type">uint32_t</span>)gdt_table, <span class="keyword">sizeof</span>(gdt_table));</span><br></pre></td></tr></table></figure>

<p>在<code>qemu</code>的<code>[view-&gt;compatmonitor()]</code>中输入<code>info registers</code>，可以看到<code>GDT</code>的信息变化：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101016115.png" alt="image-20240510101651071"></p>
<p><code>GDT</code>表写入后，<code>GDT=00009358 00000017</code>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101452241.png" alt="image-20240510145235174"></p>
<p>加载的<code>GDT</code>表项与所给出的表项一致：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101453798.png" alt="image-20240510145356743"></p>
<p><strong>（4）开启保护模式使能位</strong></p>
<p>开启保护位时，需设置<code>CR0</code>寄存器的<code>PE</code>位为<code>1</code>。由于<code>CR0</code>无法直接读写，必须先读取到某个中间寄存器，修改值后，再将值回写到<code>CR0</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 开启保护模式使能位</span></span><br><span class="line"><span class="type">uint32_t</span> cr0 = read_cr0();</span><br><span class="line">write_cr0(cr0 | (<span class="number">1</span> &lt;&lt; <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p><strong>（5）远跳转</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5. 远跳转，跳转到32位指令的入口处</span></span><br><span class="line">far_jump(<span class="number">8</span>, (<span class="type">uint32_t</span>)protect_mode_entry);  <span class="comment">// 这个8和保护模式的硬件细节，以及GDT表有关</span></span><br></pre></td></tr></table></figure>

<p>当跳转到<code>protect_mode_entry</code>后，可以看到段寄存器<code>CS</code>项变为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 00000000 0000ffff 00cf9a00 DPL=0 CS32</span><br></pre></td></tr></table></figure>

<p>即进入<code>32</code>位代码模式。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101455214.png" alt="image-20240510145523144"></p>
<p>将剩余的寄存器也修改到32位模式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protect_mode_entry:</span><br><span class="line">	mov $<span class="number">16</span>, %ax</span><br><span class="line">	mov %ax, %ds</span><br><span class="line">	mov %ax, %ss</span><br><span class="line">	mov %ax, %es</span><br><span class="line">	mov %ax, %fs</span><br><span class="line">	mov %ax, %gs</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101500881.png" alt="image-20240510150001767"></p>
<h2 id="3-4-使用LBA读取磁盘"><a href="#3-4-使用LBA读取磁盘" class="headerlink" title="3.4 使用LBA读取磁盘"></a>3.4 使用LBA读取磁盘</h2><p>参考资料：<a target="_blank" rel="noopener" href="https://wiki.osdev.org/ATA_PIO_Mode">硬盘访问模式及相关寄存器</a></p>
<p>虽然<code>BIOS</code>提供了磁盘读取的接口，方便从磁盘上读取<code>loader</code>，但在进入保护模式后，<code>BIOS</code>功能无法使用，<strong>读取磁盘需要使用到<code>LBA</code>模式</strong>。因此必须自己设计磁盘读取的代码。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101510647.png" alt="image-20240510151038444"></p>
<p>具体来讲，本项目采用<code>LBA48</code>模式。<code>LBA48</code>模式将硬盘上所有的扇区看成线性排列，没有磁盘、柱面等概念，因此访问起来更加简单，序号从<code>0</code>开始，其访问序列如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">outb(0x1F6,0x40|(slavebit&lt;&lt;4))  	// 选择硬盘:主盘或从盘</span><br><span class="line"></span><br><span class="line">outb(0x1F2,sectorcount high byte)	// 将扇区数量的高8位写入端口0x1F2</span><br><span class="line">// 分别将LBA(Logical Block Address)的第4、5、6个字节写入端口0x1F3、0x1F4、0x1F5</span><br><span class="line">outb(0x1F3,LBA4)							 </span><br><span class="line">outb(0x1F4,LBA5)</span><br><span class="line">outb(0x1F5,LBA6)</span><br><span class="line"></span><br><span class="line">outb (0x1F2,sectorcount low byte)	// 将扇区数量的低8位写入端口0x1F2</span><br><span class="line">// 分别将LBA(Logical Block Address)的第1、2、3个字节写入端口0x1F3、0x1F4、0x1F5</span><br><span class="line">outb(0x1F3,LBA1)</span><br><span class="line">outb(0x1F4,LBA2)</span><br><span class="line">outb(0x1F5,LBA3)</span><br><span class="line"></span><br><span class="line">Send the &quot;READ SECTORS EXT&quot; command (0x24) to port 0x1F7: </span><br><span class="line">outb(0x1F7,0x24)	// 告诉硬盘要读取扇区的数据</span><br></pre></td></tr></table></figure>

<p>各寄存器说明如下:</p>
<table>
<thead>
<tr>
<th>寄存器偏移</th>
<th>读写</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>R&#x2F;W</td>
<td>数据寄存器</td>
</tr>
<tr>
<td>1</td>
<td>R</td>
<td>错误寄存器</td>
</tr>
<tr>
<td>1</td>
<td>W</td>
<td>特性寄存器</td>
</tr>
<tr>
<td>2</td>
<td>R&#x2F;W</td>
<td>扇区数量寄存器</td>
</tr>
<tr>
<td>3</td>
<td>R&#x2F;W</td>
<td>Sector Number Register (LBAlo)</td>
</tr>
<tr>
<td>4</td>
<td>R&#x2F;W</td>
<td>Cylinder Low Register &#x2F;(LBAmid)</td>
</tr>
<tr>
<td>5</td>
<td>R&#x2F;W</td>
<td>Cylinder High Register &#x2F;(LBAhi)</td>
</tr>
<tr>
<td>6</td>
<td>R&#x2F;W</td>
<td>Drive &#x2F; Head Register</td>
</tr>
<tr>
<td>7</td>
<td>R</td>
<td>状态寄存器</td>
</tr>
<tr>
<td>7</td>
<td>W</td>
<td>命令寄存器</td>
</tr>
</tbody></table>
<ul>
<li>其中<code>0x1F6</code>寄存器（<code>Drive/Head</code>）对应的位如下：</li>
</ul>
<table>
<thead>
<tr>
<th>位</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0-3</td>
<td></td>
<td>在, bits 24 to 27 of the block number.</td>
</tr>
<tr>
<td>4</td>
<td>DRV</td>
<td>驱动器号（驱动器号：主盘和从盘。当只有一块硬盘时，默认第一块硬盘上放在主盘上。）</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>LBA</td>
<td>LBA模式下设置为1</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><code>Status Register(I/O base + 7)</code></li>
</ul>
<table>
<thead>
<tr>
<th>位</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>ERR</td>
<td>发生错误</td>
</tr>
<tr>
<td>1</td>
<td>IDX</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>CORR</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>DRQ</td>
<td>就绪，可以写数据或读取数据</td>
</tr>
<tr>
<td>4</td>
<td>SRV</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>DF</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>RDY</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>BSY</td>
<td>忙</td>
</tr>
</tbody></table>
<p>由于<code>loader</code>占用的大小较大，约几十<code>kb</code>的样子。由于不确定具体大小，因此尽量将内核往后放，放在第<code>100</code>个扇区的位置，并且将内核的大小为<code>500</code>，即<code>250kb</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static void read_disk (uint32_t sector, uint32_t sector_count, uint8_t *buf);</span></span><br><span class="line">read_disk(<span class="number">100</span>, <span class="number">500</span>, (<span class="type">uint8_t</span> *)SYS_KERNEL_LOAD_ADDR);</span><br></pre></td></tr></table></figure>

<h2 id="3-5-创建内核工程"><a href="#3-5-创建内核工程" class="headerlink" title="3.5 创建内核工程"></a>3.5 创建内核工程</h2><p>创建内核工程，并将工程写到磁盘上第<code>1MB</code>位置处，<code>loader</code>加载后将跳转过去。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101622446.png" alt="image-20240510162243231"></p>
<p>新建<code>kernel</code>文件夹，并在内部新建<code>CMakeLists.txt</code>如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">project(kernel LANGUAGES C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的链接器</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;-m elf_i386  -Ttext=0x100000&quot;</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_LINK_EXECUTABLE <span class="string">&quot;<span class="variable">$&#123;LINKER_TOOL&#125;</span> &lt;OBJECTS&gt; <span class="variable">$&#123;CMAKE_EXE_LINKER_FLAGS&#125;</span> -o <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有的汇编、C文件加入工程</span></span><br><span class="line"><span class="comment"># 注意保证start.asm在最前头，这样对应的程序会放在bin文件开头，从而在加载到0x8000时能在开头处</span></span><br><span class="line">file(GLOB_RECURSE C_LIST <span class="string">&quot;*.c&quot;</span> <span class="string">&quot;*.h&quot;</span>)</span><br><span class="line"><span class="comment"># 将GLOB改为GLOB_RECURSE，因为kernel目录下包含init等子目录，需要进行递归</span></span><br><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> init/start.S <span class="variable">$&#123;C_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bin文件生成，写入到image目录下</span></span><br><span class="line">add_custom_command(TARGET <span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">                   POST_BUILD</span><br><span class="line">                   COMMAND <span class="variable">$&#123;OBJCOPY_TOOL&#125;</span> -O binary <span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../../image/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.bin</span><br><span class="line">                   COMMAND <span class="variable">$&#123;OBJDUMP_TOOL&#125;</span> -x -d -S -m i386 <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf &gt; <span class="variable">$&#123;PROJECT_NAME&#125;</span>_dis.txt</span><br><span class="line">                   <span class="comment"># i8086改为i386，即从16位模式改为32位模式</span></span><br><span class="line">                   COMMAND <span class="variable">$&#123;READELF_TOOL&#125;</span> -a <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf &gt; <span class="variable">$&#123;PROJECT_NAME&#125;</span>_elf.txt</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="3-6-向内核传递启动信息"><a href="#3-6-向内核传递启动信息" class="headerlink" title="3.6 向内核传递启动信息"></a>3.6 向内核传递启动信息</h2><h3 id="1、如何实现从loader到kernel的信息传输？"><a href="#1、如何实现从loader到kernel的信息传输？" class="headerlink" title="1、如何实现从loader到kernel的信息传输？"></a>1、如何实现从loader到kernel的信息传输？</h3><p>信息的传递流程为：<code>boot_info-&gt;loader-&gt;kernel</code>。现在的问题就是如何实现从<code>loader</code>到<code>kernel</code>的传输？</p>
<ul>
<li><p>方式一：将<code>boot_info</code>写到某个固定的地址，再由<code>kernel</code>自行去取：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101952279.png" alt="image-20240510195254050"></p>
</li>
<li><p>方式二：将内核的入口地址处视为存放着一个接受启动信息参数的函数，使用函数调用：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405101954937.png" alt="image-20240510195449809"></p>
<blockquote>
<p><code>(void(*)(boot_info_t *))(SYS_KERNEL_LOAD_ADDR)(&amp;boot_info)</code></p>
<p>这个表达式是一个函数指针的类型转换，用于将一个特定地址处的函数映射到一个特定类型的函数指针。调用这个函数指针，并将 <code>boot_info</code> 作为参数传递给该函数。</p>
<ol>
<li><code>(SYS_KERNEL_LOAD_ADDR)</code>：<ul>
<li>这部分表示一个地址，即内核加载的地址 <code>SYS_KERNEL_LOAD_ADDR</code>。</li>
</ul>
</li>
<li><code>(void (*)(boot_info_t *))</code>：<ul>
<li>这部分是一个函数指针类型的转换。</li>
<li><code>void (*)(boot_info_t *)</code> 表示一个函数指针，指向一个接受 <code>boot_info_t *</code> 类型参数并返回 <code>void</code> 类型的函数。</li>
</ul>
</li>
<li><code>(SYS_KERNEL_LOAD_ADDR)(&amp;boot_info)</code>：<ul>
<li>这部分将 <code>boot_info</code> 的地址作为参数传递给地址 <code>SYS_KERNEL_LOAD_ADDR</code> 处的函数，并且将返回的结果转换为 <code>(void (*)(boot_info_t *))</code> 类型的函数指针。</li>
</ul>
</li>
</ol>
<p>综合起来，整个表达式的作用是将位于地址 <code>SYS_KERNEL_LOAD_ADDR</code> 处的函数转换为一个接受 <code>boot_info_t *</code> 类型参数的函数指针，并且调用这个函数，将 <code>boot_info</code> 作为参数传递给它。</p>
</blockquote>
</li>
</ul>
<h3 id="2、x86栈的基本结构"><a href="#2、x86栈的基本结构" class="headerlink" title="2、x86栈的基本结构"></a>2、x86栈的基本结构</h3><p>保护模式下，栈单元大小为<code>32</code>位&#x2F;<code>4</code>字节。（在<code>32</code>位系统中）</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102027415.png" alt="image-20240510202728422"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102027751.png" alt="image-20240510202743173"></p>
<h3 id="3、实现细节"><a href="#3、实现细节" class="headerlink" title="3、实现细节"></a>3、实现细节</h3><p>（1）总体程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    .text</span><br><span class="line">    .extern kernel_init</span><br><span class="line">    .global _start</span><br><span class="line">    # void start (boot_info_t *boot_info)</span><br><span class="line">_start:</span><br><span class="line">    /*</span><br><span class="line">        将boot_info压入栈中，并传递给kernel_init</span><br><span class="line">        boot_info则来自_start被调用时，((void (*)(boot_info_t *))SYS_KERNEL_LOAD_ADDR)(&amp;boot_info);也会压栈</span><br><span class="line">            ((void (*)(boot_info_t *))SYS_KERNEL_LOAD_ADDR)(&amp;boot_info);</span><br><span class="line">            84d8:	83 ec 0c             	sub    $0xc,%sp</span><br><span class="line">            84db:	68 40 95             	push   $0x9540</span><br><span class="line">            84de:	00 00                	add    %al,(%bx,%si)</span><br><span class="line">            84e0:	b8 00 00             	mov    $0x0,%ax</span><br><span class="line">            84e3:	10 00                	adc    %al,(%bx,%si)</span><br><span class="line">            84e5:	ff d0                	call   *%ax</span><br><span class="line">            84e7:	83 c4 10             	add    $0x10,%sp</span><br><span class="line">        也即是说_start实际上是被调函数，参考讲义中的test函数的逻辑来操作</span><br><span class="line">    */</span><br><span class="line">    push %ebp</span><br><span class="line">    mov %esp, %ebp</span><br><span class="line">    mov 0x8(%ebp), %eax</span><br><span class="line">    /*</span><br><span class="line">        通过ebp+偏移来取得boot_info</span><br><span class="line">        由于_start仅1个参数，因此栈的局部结构为：</span><br><span class="line">            - 参数：boot_info</span><br><span class="line">            - 返回地址</span><br><span class="line">            - ebp当前指向位置（esp当前指向位置）</span><br><span class="line">        所以为0x8(%ebp)</span><br><span class="line">    */  </span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        由于最终是原地跳转，不会回到loader中，因此也可以不考虑ebp恢复的情况，此时上述三行可用一行来实现：</span><br><span class="line">            mov 4(%esp), %eax</span><br><span class="line"></span><br><span class="line">        当不考虑ebp时，esp+4即可取到boot_info</span><br><span class="line">        由于_start仅1个参数，因此栈的局部结构为：</span><br><span class="line">            - 参数：boot_info</span><br><span class="line">            - 返回地址（esp当前指向位置）</span><br><span class="line">        所以为4(%esp)</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    # kernel_init (boot_info)</span><br><span class="line">    push %eax  </span><br><span class="line">    call kernel_init  # 此时的kernel_init是被_start调用的函数</span><br><span class="line"></span><br><span class="line">    jmp .</span><br></pre></td></tr></table></figure>

<p>（2）具体执行</p>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push %ebp</span><br><span class="line">mov %esp, %ebp</span><br><span class="line">mov 0x8(%ebp), %eax</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102049124.png" alt="image-20240510204938049"></p>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov 0x8(%ebp), %eax</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102050925.png" alt="image-20240510205045871"></p>
<p>而在<code>./build/source/loader/loder_elf.txt</code>的符号表中，可以看到<code>boot_info</code>的地址即为<code>0x9540</code>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102052194.png" alt="image-20240510205246084"></p>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push %eax  </span><br><span class="line">call kernel_init  # 此时的kernel_init是被_start调用的函数</span><br><span class="line">jmp .</span><br></pre></td></tr></table></figure>

<p>当进入<code>kernel_init</code>函数后，可以看到传入的<code>boot_info</code>的地址也是<code>0x9540</code>：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102054365.png" alt="image-20240510205443276"></p>
<h2 id="3-7-代码-数据段与链接脚本"><a href="#3-7-代码-数据段与链接脚本" class="headerlink" title="3.7 代码&#x2F;数据段与链接脚本"></a>3.7 代码&#x2F;数据段与链接脚本</h2><h3 id="1、链接的理论基础"><a href="#1、链接的理论基础" class="headerlink" title="1、链接的理论基础"></a>1、链接的理论基础</h3><blockquote>
<p>可参考【Computer-&gt;CSAPP-CSAPP_Ch7 链接】相关笔记。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102057812.png" alt="image-20240510205719578"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102108837.png" alt="image-20240510210839581"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102108978.png" alt="image-20240510210855757"></p>
<p>举例如下：</p>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102114815.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102116737.png" width="300"/>
</center>



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102111597.png" alt="image-20240510211122344"></p>
<h3 id="2、自定义链接脚本"><a href="#2、自定义链接脚本" class="headerlink" title="2、自定义链接脚本"></a>2、自定义链接脚本</h3><p>上述所讲为编译器默认配置。可自定义链接脚本，定义工程中相应的代码或数据放在哪些位置。</p>
<p>编写<code>kernel.lds</code>文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x20000;  // 控制.text section的起始地址，后续的section也可以进行相应的设置</span><br><span class="line"></span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text)  // 通配符： *</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		*(.rodata)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.data : &#123;</span><br><span class="line">		*(.data)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.bss : &#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并修改对应的<code>[kernel/CMakeLists.txt]</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_EXE_LINKER_FLAGS &quot;-m elf_i386  -T $&#123;PROJECT_SOURCE_DIR&#125;/kernel.lds&quot;)</span><br></pre></td></tr></table></figure>

<p>也就是说链接脚本控制了各个<code>section</code>具体的存放位置，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405102138372.png" alt="image-20240510213841287"></p>
<blockquote>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html">GCC LD官方文档</a></p>
<p><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Linker_Scripts">linker脚本(较易阅读)</a></p>
<p><a target="_blank" rel="noopener" href="http://www.bravegnu.org/gnu-eprog/linker.html">ARM Linker链接脚本</a></p>
<p><a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/ld/">ld脚本编写</a></p>
</blockquote>
<h2 id="3-8-加载内核映像文件"><a href="#3-8-加载内核映像文件" class="headerlink" title="3.8 加载内核映像文件"></a>3.8 加载内核映像文件</h2><h3 id="1、理论基础-1"><a href="#1、理论基础-1" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112014421.png" alt="image-20240511201413000"></p>
<p>若在<code>#12</code>行设置<code>. = 200000</code>，则会导致在<code>.rodata</code>和<code>.data</code>中间出现较大的空闲空间，导致最终的文件大小大于<code>1MB</code>，这个大小过大了。且如果采用二进制映像文件，操作系统是无法得知各个<code>section</code>在内存中分布的具体位置的。</p>
<p>为了更好地组织程序和数据，一般需要专用的文件格式，如<code>PE</code>格式或者<code>ELF</code>格式。<code>ELF</code>用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件的文件格式。</p>
<blockquote>
<p>ELF文件的详细细节可参考【Computer-&gt;CSAPP-CSAPP_Ch7 链接】相关笔记。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112021480.png" alt="image-20240511202122375"></p>
<ul>
<li><p>可执行代码段和数据段从<code>p_offset</code>的位置拷贝到内存的<code>p_paddr</code>中，拷贝的大小为<code>p_filesz</code>。</p>
</li>
<li><p>在<code>ELF</code>文件格式中，<code>.data</code> 和 <code>.bss</code> 区域通常用来存储程序的已初始化和未初始化数据。在加载可执行文件时，操作系统会负责为这些区域分配内存，并将它们初始化为零。</p>
<p>因此，在生成<code>ELF</code>可执行文件时，不需要将 <code>.data</code> 和 <code>.bss</code> 区域的实际数据写入文件中。相反，只需在文件中标记出这些区域的大小，并在加载时告知操作系统需要为它们分配多大的内存空间，并将其初始化为零。</p>
</li>
<li><p><code>p_memsz = p_filesz + 清零区域</code></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112105777.png" alt="image-20240511210512520"></p>
<h3 id="2、代码实现细节"><a href="#2、代码实现细节" class="headerlink" title="2、代码实现细节"></a>2、代码实现细节</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># bin文件生成，写入到image目录下</span><br><span class="line">add_custom_command(TARGET $&#123;PROJECT_NAME&#125;</span><br><span class="line">                   POST_BUILD</span><br><span class="line">                   # 修改前</span><br><span class="line">                   # COMMAND $&#123;OBJCOPY_TOOL&#125; -O binary $&#123;PROJECT_NAME&#125;.elf $&#123;CMAKE_SOURCE_DIR&#125;/../../image/$&#123;PROJECT_NAME&#125;.elf</span><br><span class="line">                   # 修改后：-O binary =&gt; -S</span><br><span class="line">                   COMMAND $&#123;OBJCOPY_TOOL&#125; -S $&#123;PROJECT_NAME&#125;.elf $&#123;CMAKE_SOURCE_DIR&#125;/../../image/$&#123;PROJECT_NAME&#125;.elf</span><br><span class="line">				   COMMAND $&#123;OBJDUMP_TOOL&#125; -x -d -S -m i386 $&#123;PROJECT_BINARY_DIR&#125;/$&#123;PROJECT_NAME&#125;.elf &gt; $&#123;PROJECT_NAME&#125;_dis.txt</span><br><span class="line">                   COMMAND $&#123;READELF_TOOL&#125; -a $&#123;PROJECT_BINARY_DIR&#125;/$&#123;PROJECT_NAME&#125;.elf &gt; $&#123;PROJECT_NAME&#125;_elf.txt</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>修改后，新的存储规划如下：</p>
<ul>
<li>将<code>kernel</code>，即内核工程放在<code>64KB/0x10000</code>的位置；</li>
<li>也就是说，<code>0x100000</code>处只是存放一个临时的<code>ELF</code>文件，实际的内容会被加载到<code>0x10000</code>处执行。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112030942.png" alt="image-20240511203046852"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">reload_elf_file</span><span class="params">(<span class="type">uint8_t</span> *file_buffer)</span> &#123;</span><br><span class="line">    Elf32_Ehdr *elf_hdr = (Elf32_Ehdr *)file_buffer;</span><br><span class="line">    <span class="comment">// 检查是否为有效文件（粗略检查）</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr-&gt;e_ident[<span class="number">0</span>] != <span class="number">0x7F</span>) || (elf_hdr-&gt;e_ident[<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">        || (elf_hdr-&gt;e_ident[<span class="number">2</span>] != <span class="string">&#x27;L&#x27;</span>) || (elf_hdr-&gt;e_ident[<span class="number">3</span>] != <span class="string">&#x27;F&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取相应的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elf_hdr-&gt;e_phnum; i++) &#123;</span><br><span class="line">        Elf32_Phdr *phdr = (Elf32_Phdr *)(file_buffer + elf_hdr-&gt;e_phoff) + i;  <span class="comment">// 偏移量：elf_hdr-&gt;e_phoff</span></span><br><span class="line">        <span class="comment">// 判断该段是需要被加载到内存中的可执行代码或数据段</span></span><br><span class="line">        <span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将可执行代码或数据段从文件中拷贝到内存中</span></span><br><span class="line">        <span class="type">uint8_t</span> *src = file_buffer + phdr-&gt;p_offset;</span><br><span class="line">        <span class="type">uint8_t</span> *dest = (<span class="type">uint8_t</span> *)phdr-&gt;p_paddr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; phdr-&gt;p_filesz; j++) &#123;</span><br><span class="line">            *dest++ = *src++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 针对.data和.bss做进一步处理</span></span><br><span class="line">        dest = (<span class="type">uint8_t</span> *)phdr-&gt;p_paddr + phdr-&gt;p_filesz;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; phdr-&gt;p_memsz - phdr-&gt;p_filesz; j++) &#123;</span><br><span class="line">            *dest++ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elf_hdr-&gt;e_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112120766.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112119587.png" width="300"/>    
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405112121617.png" width="300"/>
</center>



<h1 id="四、中断与异常处理"><a href="#四、中断与异常处理" class="headerlink" title="四、中断与异常处理"></a>四、中断与异常处理</h1><h2 id="4-1-创建GDT表及其表项"><a href="#4-1-创建GDT表及其表项" class="headerlink" title="4.1 创建GDT表及其表项"></a>4.1 创建GDT表及其表项</h2><h3 id="1、理论基础-2"><a href="#1、理论基础-2" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p><code>x86</code>系统架构（<code>IA32</code>模式）</p>
<ul>
<li><p>分段存储</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121404633.png" alt="image-20240512140427535"></p>
</li>
<li><p>分页存储</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121404406.png" alt="image-20240512140446313"></p>
</li>
</ul>
<p><strong>在进入保护模式以后，所有有关内存访问的操作都需要经过<code>GDT</code>表</strong>，表中的每项称为<strong>段描述符</strong>（<code>Segment descriptor</code>）。</p>
<p>每一项是一个结构体，<code>64</code>位结构，包含<code>base addr/基地址</code>、<code>limit/界限</code>以及<code>属性值</code></p>
<ul>
<li><code>limit</code>分为<code>2</code>块，<code>limit 15:00</code>和<code>limit 19:16</code></li>
<li><code>base addr</code>分为<code>3</code>块，<code>base 15:00</code>、<code>base 23:16</code>和<code>base 31:24</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121405202.png" alt="image-20240512140536089"></p>
<h3 id="2、代码细节"><a href="#2、代码细节" class="headerlink" title="2、代码细节"></a>2、代码细节</h3><ul>
<li><p><code>GDT</code>结构体的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">segment_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit15_0;</span><br><span class="line">    <span class="type">uint16_t</span> base15_0;</span><br><span class="line">    <span class="type">uint8_t</span> base23_16;</span><br><span class="line">    <span class="type">uint16_t</span> attr;</span><br><span class="line">    <span class="type">uint8_t</span> base31_24;</span><br><span class="line">&#125;<span class="type">segment_desc_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化<code>GDT</code>表项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">segment_desc_t</span> gdt_table[GDT_TABLE_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    selector：从gdt表中选择某个表项</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">segment_desc_set</span> <span class="params">(<span class="type">int</span> selector, <span class="type">uint32_t</span> base, <span class="type">uint32_t</span> limit, <span class="type">uint16_t</span> attr)</span> &#123;</span><br><span class="line">    <span class="type">segment_desc_t</span> *desc = gdt_table + selector / <span class="keyword">sizeof</span>(<span class="type">segment_desc_t</span>);</span><br><span class="line"></span><br><span class="line">    desc-&gt;limit15_0 = limit &amp; <span class="number">0xFFFF</span>;                   <span class="comment">// limit低16位</span></span><br><span class="line">    desc-&gt;base15_0 = base &amp; <span class="number">0xFFFF</span>;                     <span class="comment">// base低16位</span></span><br><span class="line">    desc-&gt;base23_16 = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;              <span class="comment">// base右移16位后取低8位</span></span><br><span class="line">    desc-&gt;attr = attr | (((limit &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xF</span>) &lt;&lt; <span class="number">8</span>);   <span class="comment">// 将limit的高4位存储到attr字段 </span></span><br><span class="line">    desc-&gt;base31_24 = (base &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;              <span class="comment">// base右移24位后取低8位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空gdt表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; GDT_TABLE_SIZE; ++i) &#123;</span><br><span class="line">        segment_desc_set(i * <span class="keyword">sizeof</span>(<span class="type">segment_desc_t</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cpu_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    init_gdt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>理论上，处理器可以访问寻址处理任意地址的字节，但实际上为了保证计算机读取数据的高效性，<code>CPU</code>通过地址总线来访问内存。以32位处理器为例，一般来说寻址步长为32位(4个字节)，也就是每次从内存读取4个字节。为了提高存取效率，一般来说编译器会自动将一个数据尽量放在一个步长之内，避免跨步长存储，称为内存对齐。<br>每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。可通过预编译命令<code>#pragma pack(n)</code>，<code>n=1,2,4,8,16</code>来改变这一系数，其中的n就是你要指定的“对齐系数”。</p>
</blockquote>
<h2 id="4-2-保护模式下的内存管理简介"><a href="#4-2-保护模式下的内存管理简介" class="headerlink" title="4.2 保护模式下的内存管理简介"></a>4.2 保护模式下的内存管理简介</h2><h3 id="1、理论基础-3"><a href="#1、理论基础-3" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p>参考<code>325384-sdm-vol-3abcd.pdf</code>的<code>Ch3 Protected-Mode Memory Management</code></p>
</blockquote>
<ul>
<li><p>分段存储和分页存储及其异同</p>
<ul>
<li>分页存储</li>
</ul>
<p>  将程序的逻辑地址空间划分为固定大小的页(<code>page</code>)，而物理内存划分为同样大小的页框(<code>page frame</code>)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。</p>
<ul>
<li>分段存储</li>
</ul>
<p>  在分段存储管理中，将程序的地址空间划分为若干个段(<code>segment</code>)，这样每个进程有一个二维的地址空间。每个段分配一个连续的分区，而进程中的各个段可以不连续地存放在内存的不同分区中。程序加载时，操作系统为所有段分配其所需内存，这些段不必连续。</p>
<ul>
<li><p>分页和分段的相同点</p>
<ul>
<li><p>分页机制和分段机制都是为了提高内存利用率，产生较少的内存碎片。</p>
</li>
<li><p>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是每个页和段中的内存是连续的。</p>
</li>
</ul>
</li>
<li><p>分页和分段的区别</p>
<ul>
<li><p>页的大小是固定的，由操作系统决定，而段的大小不固定，取决于我们当前运行的程序。</p>
</li>
<li><p>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，它含有一组其意义相对完整的信息，在程序中可以体现为代码段，数据段，是为了满足用户的需要。</p>
</li>
<li><p>分页的作业地址空间是维一的，即单一的线性空间，程序员只须利用一个记忆符，即可表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</p>
</li>
<li><p>段一般比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121550258.png" alt="image-20240512155014746"></p>
</li>
<li><p>下图是一种比较复杂的设计，一般不采用</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121551856.png" alt="image-20240512155154382"></p>
</li>
<li><p>为简单起见，可采用平坦模型，分为基础平坦模式和带保护的平坦模式。</p>
</li>
<li><p><strong>本项目采用基础平坦模式。</strong></p>
<ul>
<li><code>CS</code>指向代码段；剩余寄存器指向数据段；</li>
<li>两个段的起始地址均为<code>0</code>，大小为<code>4GB</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121555355.png" alt="image-20240512155513883"></p>
</li>
<li><p>从逻辑地址转换到线性地址</p>
<ul>
<li>举例，对于逻辑地址<code>0x8:0x1234</code>：<ul>
<li><code>0x8</code>对应<code>GDT</code>的表项<code>1</code>；</li>
<li><code>GDT</code>的表项<code>1</code>中基地址为<code>0x10000</code>，因此线性地址为<code>0x11234</code>。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121558156.png" alt="image-20240512155843842"></p>
</li>
<li><p>对于上文所述的<code>0x8</code>，观察选择子的结构可以得知，低<code>3</code>位用于其他用途，剩余位用于判断索引<code>index</code>。因此<code>0x8 = (b)00001000</code>，因此对应表项1。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121603986.png" alt="image-20240512160330889" style="zoom:50%;" /></li>
</ul>
<h3 id="2、内存访问的整体流程"><a href="#2、内存访问的整体流程" class="headerlink" title="2、内存访问的整体流程"></a>2、内存访问的整体流程</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121603112.png" alt="image-20240512160353942"></p>
<h2 id="4-3-重新加载GDT表"><a href="#4-3-重新加载GDT表" class="headerlink" title="4.3 重新加载GDT表"></a>4.3 重新加载GDT表</h2><p>在<code>loader_16.c</code>中曾经自定义了一个简单的<code>GDT</code>表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GDT表（临时用，后面内容会替换成自己的）</span></span><br><span class="line"><span class="type">uint16_t</span> gdt_table[][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xFFFF</span>, <span class="number">0x0000</span>, <span class="number">0x9A00</span>, <span class="number">0x00CF</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xFFFF</span>, <span class="number">0x0000</span>, <span class="number">0x9200</span>, <span class="number">0x00CF</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>存在以下不足：</p>
<p>1）表项过小，在后期涉及到多进程以及中断管理时需要加入新的配置项；</p>
<p>2）当前这个表存储所在的内存区域为<code>loader</code>，即数据区，在后面可能会被覆盖。</p>
<p>因此，在<code>kernel</code>工程中设计了一个包含<code>256</code>个表项的新<code>GDT</code>表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_TABLE_SIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">segment_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit15_0;</span><br><span class="line">    <span class="type">uint16_t</span> base15_0;</span><br><span class="line">    <span class="type">uint8_t</span> base23_16;</span><br><span class="line">    <span class="type">uint16_t</span> attr;</span><br><span class="line">    <span class="type">uint8_t</span> base31_24;</span><br><span class="line">&#125;<span class="type">segment_desc_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、实现细节"><a href="#2、实现细节" class="headerlink" title="2、实现细节"></a>2、实现细节</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121656373.png" alt="image-20240512165607190"></p>
<p>重新加载<code>GDT</code>表后：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121657737.png" alt="image-20240512165730560"></p>
<p>对于<code>CS</code>项：</p>
<ul>
<li><code>0008</code>：选择子</li>
<li>后面的数字则是具体的表项，包括<code>limit</code>、<code>base</code>和<code>attr</code>等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405121701389.png" alt="image-20240512170129300"></p>
<h2 id="4-4-触发异常与异常简介"><a href="#4-4-触发异常与异常简介" class="headerlink" title="4.4 触发异常与异常简介"></a>4.4 触发异常与异常简介</h2><h3 id="1、理论基础-4"><a href="#1、理论基础-4" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>在程序运行过程中，有可能会发生各种异常事件，CPU需要跳转到相应的程序对这些事件进行处理。</p>
<ul>
<li>异常<ul>
<li>由于CPU内部事件所引起的中断，如程序出错（非法指令、地址越界以及除0异常等）</li>
<li>通常由于执行了现行指令所引起</li>
</ul>
</li>
<li>中断<ul>
<li>由于外部设备事件所引起的中断，如通常的磁盘中断以及打印机中断等</li>
<li>通常与现行指令无关，由外部事件引起</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122031495.png" alt="image-20240512203148228"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122032412.png" alt="image-20240512203209841"></p>
<h2 id="4-5-添加中断门描述符"><a href="#4-5-添加中断门描述符" class="headerlink" title="4.5 添加中断门描述符"></a>4.5 添加中断门描述符</h2><h3 id="1、理论基础-5"><a href="#1、理论基础-5" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>进入保护模式后，中断向量表需要重新配置。</p>
<p><code>IA-32</code>中断向量表：<code>IDTR</code>寄存器指向的<code>IDT/Interrupt Descriptor Table</code>表。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122035869.png" alt="image-20240512203547782"></p>
<ul>
<li><code>IDTR</code>寄存器，由<code>Base Address</code>和<code>Limit</code>组成。<ul>
<li>基地址：保存<code>IDT</code>表的起始位置</li>
<li><code>Limit</code>：指定<code>IDT</code>表的大小</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122035976.png" alt="image-20240512203508876"></p>
<ul>
<li><p><code>IDT</code>表项的具体格式</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122039950.png" alt="image-20240512203943834"></p>
<ul>
<li><p><code>Interrupt Gate</code>：本项目主要采用该格式。</p>
<ul>
<li><p>包含选择子、偏移量以及一些其他的标志位。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122044231.png" alt="image-20240512204443158" style="zoom: 80%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IDT表项/Interrupt Gate中断门表项</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">gate_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> offset15_0;</span><br><span class="line">    <span class="type">uint16_t</span> selector;</span><br><span class="line">    <span class="type">uint16_t</span> attr;</span><br><span class="line">    <span class="type">uint16_t</span> offset31_16;</span><br><span class="line">&#125;<span class="type">gate_desc_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置IDT表项/中断门表项 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gate_desc_set</span> <span class="params">(<span class="type">gate_desc_t</span> *desc, <span class="type">uint16_t</span> selector, <span class="type">uint32_t</span> offset, <span class="type">uint16_t</span> attr)</span> &#123;</span><br><span class="line">    desc-&gt;offset15_0 = offset &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    desc-&gt;selector = selector;</span><br><span class="line">    desc-&gt;attr = attr;</span><br><span class="line">    desc-&gt;offset31_16 = (offset &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行初始化后可以看到<code>IDT</code>的值被设置为<code>idt_table</code>的首地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">irq_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空IDT表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IDT_TABLE_NR; i++) &#123;</span><br><span class="line">        gate_desc_set(idt_table + i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将IDTR寄存器指向IDT表</span></span><br><span class="line">    lidt((<span class="type">uint32_t</span>)idt_table, <span class="keyword">sizeof</span>(idt_table));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122109920.png" alt="image-20240512210927867"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122109701.png" alt="image-20240512210916635"></p>
<h2 id="4-6-捕获除0异常"><a href="#4-6-捕获除0异常" class="headerlink" title="4.6 捕获除0异常"></a>4.6 捕获除0异常</h2><h3 id="1、为所有异常配置缺省的处理程序"><a href="#1、为所有异常配置缺省的处理程序" class="headerlink" title="1、为所有异常配置缺省的处理程序"></a>1、为所有异常配置缺省的处理程序</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122113907.png" alt="image-20240512211301703"></p>
<p>设置缺省处理程序时，由于基地址为<code>0</code>，只需将处理程序的起始地址赋值给<code>offset</code>，然后将<code>IDT</code>的选择子设置为代码段的选择子即可。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122124096.png" alt="image-20240512212443637"></p>
<p>注意：中断处理程序只能用汇编来写，而不能用C语言来写！</p>
<blockquote>
<p>中断处理程序需要使用 <code>iret</code> 指令来正确地恢复被中断的程序的执行状态。<code>iret</code> 指令用于从中断处理程序返回到被中断的程序，并恢复被中断程序的执行现场，包括栈指针、标志寄存器和程序计数器等。</p>
<p>在 x86 架构中，<code>iret</code> 指令不能在 C 函数中直接使用，因为 C 函数的结尾通常是 <code>ret</code> 指令，这个指令只能用于从函数返回，而不能正确地恢复中断处理程序的执行状态。</p>
<p>因此，为了正确处理中断，特别是在中断处理程序中使用 <code>iret</code> 指令，需要使用汇编语言编写中断处理程序。只有在汇编语言中，可以直接使用 <code>iret</code> 指令来正确地返回到被中断的程序。</p>
</blockquote>
<h3 id="2、除0异常发生"><a href="#2、除0异常发生" class="headerlink" title="2、除0异常发生"></a>2、除0异常发生</h3><p>当发生除<code>0</code>异常时，首先会跳转到<code>iret</code>指令，</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122152287.png" alt="image-20240512215244219"></p>
<p>接下按<code>F11</code>单步调试，然后又会回到除<code>0</code>指令（<code>int a = 3 / 0</code>）上，</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122149517.png" alt="image-20240512214929396"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122150962.png" alt="image-20240512215020824"></p>
<p>再次处理发现仍旧无法解决，因此又会回到<code>iret</code>指令，</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122152287.png" alt="image-20240512215244219"></p>
<p>这样就会陷入死循环。因此在用户端程序遇到异常时一般需要将程序杀掉，但在操作系统中则无法处理，因此一般采用死机的处理。</p>
<p>详述“死机”的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exception_handle_unkown:</span><br><span class="line">    call do_handler_unkown</span><br><span class="line">    iret </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_default_handle</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_unkown</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    do_default_handle(<span class="string">&quot;unkown exception&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发现除<code>0</code>异常时：</p>
<p>-&gt; <code>exception_handle_unkown</code></p>
<p>-&gt; <code>do_handler_unkown</code></p>
<p>-&gt; <code>do_default_handle</code></p>
<p>-&gt; 进入死循环，即死机</p>
<h3 id="3、预先保存寄存器状态"><a href="#3、预先保存寄存器状态" class="headerlink" title="3、预先保存寄存器状态"></a>3、预先保存寄存器状态</h3><p>此外，在跳转到中断处理程序开始处理中断之前，需要先保存当前寄存器的状态，以防止后续对寄存器进行修改。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405122236298.png" alt="image-20240512223603745"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">exception_handle_unkown:</span><br><span class="line">    # 寄存器压栈</span><br><span class="line">    pusha</span><br><span class="line">    push %ds</span><br><span class="line">    push %es</span><br><span class="line">    push %fs</span><br><span class="line">    push %gs</span><br><span class="line"></span><br><span class="line">    call do_handler_unkown</span><br><span class="line"></span><br><span class="line">    # 寄存器出栈</span><br><span class="line">    pop %gs</span><br><span class="line">    pop %fs</span><br><span class="line">    pop %es</span><br><span class="line">    pop %ds</span><br><span class="line">    popa</span><br><span class="line"></span><br><span class="line">    iret </span><br></pre></td></tr></table></figure>

<p>注意：此处不必压栈<code>ss</code>和<code>esp</code>寄存器，原因如下：</p>
<blockquote>
<ol>
<li><strong>特权级不变</strong>： 在x86保护模式下，当从一个特权级（例如内核模式，特权级0）中断或异常到同一特权级时，不会自动保存 <code>ss</code> 和 <code>esp</code> 寄存器。仅当从低特权级（如用户模式，特权级3）切换到高特权级（如内核模式，特权级0）时，才会自动保存 <code>ss</code> 和 <code>esp</code> 寄存器。</li>
<li><strong>特权级切换</strong>： 如果特权级发生变化，例如从用户模式（特权级3）切换到内核模式（特权级0），CPU 会自动将 <code>ss</code> 和 <code>esp</code> 压入堆栈。为了处理这种情况，你需要一个包含 <code>ss</code> 的扩展结构体。</li>
</ol>
</blockquote>
<h2 id="4-7-解析异常栈信息"><a href="#4-7-解析异常栈信息" class="headerlink" title="4.7 解析异常栈信息"></a>4.7 解析异常栈信息</h2><h3 id="1、理论基础-6"><a href="#1、理论基础-6" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p>在发生异常而跳转到异常处理程序时，希望能够知道究竟是哪里触发了异常。此时就需要查看异常栈的相关信息。</p>
</blockquote>
<p>对于下图：当异常发生后，会将<code>EFLAGS/CS/EIP/Error Code</code>压入栈中</p>
<ul>
<li><code>EFLAGS</code>保存了状态一些相关状态</li>
<li><code>EIP</code>指示了异常发生时是哪条指令触发了异常，会将对应的地址压入<code>EIP</code>中</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131022114.png" alt="image-20240513102222754"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/650880105">x86—EFLAGS寄存器详解【转载】</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Reverse-xiaoyu/p/11397584.html">EFLAGS寄存器（标志寄存器）</a></p>
</blockquote>
<p>在调试控制台查看<code>esp:0x12e28</code>开始栈的相关信息，但这样做比较繁琐。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131026877.png" alt="image-20240513102619780"></p>
<p>在进入异常处理时，用<code>pusha</code>指令主动保存了一部分：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131032907.png" alt="image-20240513103220789"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131033545.png" alt="image-20240513103300450"></p>
<p>此外，通过<code>push</code>指令压入其他寄存器：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131034526.png" alt="image-20240513103415308"></p>
<p><strong>因此，这些要获取的栈中的寄存器信息则类似于向缺省处理函数传递的参数。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131036123.png" alt="image-20240513103626832"></p>
<p>但如果按上图中那样去写，会显得过于繁琐。因此可以将其封装为结构体，从而转换为压入这个结构体的地址（作为一个指针）。</p>
<p>根据上图，当前<code>ESP</code>指向<code>GS</code>寄存器，在将<code>ES</code>到<code>EFLAGS</code>包装为结构体后，将结构体的指针压入栈中，此时这个指针指向<code>GS</code>的地址；而执行压栈操作后，<code>ESP</code>指向该指针。</p>
<ul>
<li><p>即——<code>ESP-&gt;指针-&gt;GS</code></p>
</li>
<li><p>语法为：<code>push %esp</code></p>
<blockquote>
<p>在x86汇编语言中，<code>push %esp</code> 指令用于将栈指针 <code>%esp</code> 的当前值压入栈顶。</p>
<p>1）将 <code>%esp</code> 寄存器中的当前值（即栈指针指向的地址）减去 4；</p>
<p>2）将其指向的内存位置（即原栈顶）的值复制到减去 4 后的新栈顶地址中；</p>
<p>3）然后更新 <code>%esp</code> 寄存器的值，使其指向新的栈顶地址。</p>
</blockquote>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131039358.png" alt="image-20240513103940064"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exception_handle_unkown:</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    push %esp  </span><br><span class="line">    # 由于将GS到EFLAGS这个整体作为一个结构体，此时当前esp指向GS寄存器的下一位，因此在压入栈时只需要将GS的地址压入</span><br><span class="line">    call do_handler_unkown</span><br><span class="line">    add $(1*4), %esp  # 出栈</span><br><span class="line">	</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131104164.png" alt="image-20240513110407067"></p>
<p>对比下图，可以看到获取到的栈信息和<code>Segs</code>中的相关寄存器（左）相同，且<code>eip</code>寄存器保存的即为除<code>0</code>指令（右）所对应的地址。</p>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131104668.png" width="300"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131105155.png" width="300"/>    
</center>

<h2 id="4-8-利用宏重用异常处理代码"><a href="#4-8-利用宏重用异常处理代码" class="headerlink" title="4.8 利用宏重用异常处理代码"></a>4.8 利用宏重用异常处理代码</h2><h3 id="1、宏重用相关"><a href="#1、宏重用相关" class="headerlink" title="1、宏重用相关"></a>1、宏重用相关</h3><p>下表展示了22种异常&#x2F;中断的类型。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131125038.png" alt="image-20240513112516959"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131125775.png" alt="image-20240513112528641"></p>
<p>如果要对这22种异常&#x2F;中断各自编写一段汇编代码，就会使得代码过于冗杂，因为仅仅只有函数名称和内部调用C函数的区别，处理的逻辑是一致的。因此考虑采用<strong>宏重用</strong>的方式。</p>
<p>注意此处</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exception_handler_\name:</span><br><span class="line">    # 错误码入栈</span><br><span class="line">    .if \with_err_code == 0</span><br><span class="line">        push $0  # 压入0表示没有错误码</span><br><span class="line">    .endif</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    # 类型编号和错误码出栈</span><br><span class="line">    add $(2*4), %esp</span><br><span class="line"></span><br><span class="line">    iret </span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<blockquote>
<p>错误想法：对于有错误码的异常类型，会自动将错误码入栈，因此最后出栈时不需要考虑它，只需要<code>add $(1*4), %esp</code>；只有对于需要手动压入错误码的异常，才需要<code>add $(2*4), %esp</code>进行手动出栈。</p>
<p>这种想法的错误在于：<code>iret</code>指令在执行时会忽略<code>Error Code</code>，也就是说不管这个异常有没有自动入栈错误码，都需要我们手动去出栈。</p>
</blockquote>
<p>设定好宏后，测试并查看对应的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exception_handler unknown, -1, 0</span><br><span class="line">exception_handler divider, 0, 0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">exception_handler unknown, -1, 0</span><br><span class="line">   1002b:	6a 00                	push   $0x0</span><br><span class="line">   1002d:	6a ff                	push   $0xffffffff</span><br><span class="line">   1002f:	60                   	pusha  </span><br><span class="line">   10030:	1e                   	push   %ds</span><br><span class="line">   10031:	06                   	push   %es</span><br><span class="line">   10032:	0f a0                	push   %fs</span><br><span class="line">   10034:	0f a8                	push   %gs</span><br><span class="line">   10036:	54                   	push   %esp</span><br><span class="line">   10037:	e8 c4 01 00 00       	call   10200 &lt;do_handler_unknown&gt;</span><br><span class="line">   1003c:	83 c4 04             	add    $0x4,%esp</span><br><span class="line">   1003f:	0f a9                	pop    %gs</span><br><span class="line">   10041:	0f a1                	pop    %fs</span><br><span class="line">   10043:	07                   	pop    %es</span><br><span class="line">   10044:	1f                   	pop    %ds</span><br><span class="line">   10045:	61                   	popa   </span><br><span class="line">   10046:	83 c4 08             	add    $0x8,%esp</span><br><span class="line">   10049:	cf                   	iret   </span><br><span class="line">  </span><br><span class="line">0001004a &lt;exception_handler_divider&gt;:</span><br><span class="line">   1004a:	6a 00                	push   $0x0</span><br><span class="line">   1004c:	6a 00                	push   $0x0</span><br><span class="line">   1004e:	60                   	pusha  </span><br><span class="line">   1004f:	1e                   	push   %ds</span><br><span class="line">   10050:	06                   	push   %es</span><br><span class="line">   10051:	0f a0                	push   %fs</span><br><span class="line">   10053:	0f a8                	push   %gs</span><br><span class="line">   10055:	54                   	push   %esp</span><br><span class="line">   10056:	e8 bb 01 00 00       	call   10216 &lt;do_handler_divider&gt;</span><br><span class="line">   1005b:	83 c4 04             	add    $0x4,%esp</span><br><span class="line">   1005e:	0f a9                	pop    %gs</span><br><span class="line">   10060:	0f a1                	pop    %fs</span><br><span class="line">   10062:	07                   	pop    %es</span><br><span class="line">   10063:	1f                   	pop    %ds</span><br><span class="line">   10064:	61                   	popa   </span><br><span class="line">   10065:	83 c4 08             	add    $0x8,%esp</span><br><span class="line">   10068:	cf                   	iret   </span><br></pre></td></tr></table></figure>

<h3 id="2、向IDT表项中安装中断处理程序"><a href="#2、向IDT表项中安装中断处理程序" class="headerlink" title="2、向IDT表项中安装中断处理程序"></a>2、向IDT表项中安装中断处理程序</h3><p>接下来编写<strong>安装中断处理程序</strong>的函数，它接受两个参数：<code>irq_num</code> 表示中断号，<code>handler</code> 是一个指向中断处理函数的指针。</p>
<ul>
<li>函数首先检查给定的中断号是否超过了 IDT 表项的范围。如果超过了，就返回 <code>-1</code> 表示失败；</li>
<li>然后，函数调用 <code>gate_desc_set</code> 函数来设置 IDT 表中的表项。<code>gate_desc_set</code> 函数的目的是将中断处理函数与指定的中断号关联起来，并将相应的中断处理函数的地址写入到 IDT 表中。这样，当相应的中断发生时，CPU 就会根据 IDT 表中的设置跳转到相应的中断处理函数；</li>
<li>最后，函数返回 <code>0</code> 表示成功安装中断处理程序。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">irq_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空IDT表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IDT_TABLE_NR; i++) &#123;</span><br><span class="line">        gate_desc_set(</span><br><span class="line">            idt_table + i, </span><br><span class="line">            KERNEL_SELECTOR_CS,</span><br><span class="line">            (<span class="type">uint32_t</span>)exception_handler_unknown, </span><br><span class="line">            GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安装中断处理程序到 IDT（中断描述符表）中</span></span><br><span class="line">    irq_install(IRQ0_DE, (<span class="type">irq_handler_t</span>)exception_handler_divider);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将IDTR寄存器指向IDT表</span></span><br><span class="line">    lidt((<span class="type">uint32_t</span>)idt_table, <span class="keyword">sizeof</span>(idt_table));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">irq_install</span> <span class="params">(<span class="type">int</span> irq_num, <span class="type">irq_handler_t</span> handler)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断异常编号是否超过IDT表项的范围</span></span><br><span class="line">    <span class="keyword">if</span> (irq_num &gt;= IDT_TABLE_NR) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置IDT表项</span></span><br><span class="line">    gate_desc_set(idt_table + irq_num, KERNEL_SELECTOR_CS, </span><br><span class="line">                (<span class="type">uint32_t</span>)handler, GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131532647.png" alt="image-20240513153252414"></p>
<p>按照前述方式，可对其他类型的异常进行类似的处理。</p>
<h2 id="4-9-初始化中断控制器"><a href="#4-9-初始化中断控制器" class="headerlink" title="4.9 初始化中断控制器"></a>4.9 初始化中断控制器</h2><h3 id="1、理论基础-7"><a href="#1、理论基础-7" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p> CPU如何管理系统中的中断？</p>
</blockquote>
<p>一个<code>8259</code>芯片可以接收<code>IRQ0-IRQ7</code>共<code>8</code>个信号，当接收到相应的中断信号时，在内部进行处理，并通过<code>INT</code>信号连接到<code>CPU</code>，并向<code>CPU</code>发出中断请求。</p>
<p>由于个数限制，早期的<code>x86</code>处理器级联两片<code>8259</code>，接收共<code>15</code>个中断信号，其中一块芯片的<code>IR2</code>用于和另一块芯片连接。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131707991.png" alt="image-20240513170754592"></p>
<p>随着多核处理器的发展，<code>8259</code>被<code>APIC</code>替代。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131857119.png" alt="image-20240513185732842"></p>
<p><code>8259A</code>的内部结构图</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131859253.png" alt="image-20240513185944144"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131901488.png" alt="image-20240513190140086"></p>
<p><code>8259A</code>的初始化流程</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131902640.png" alt="image-20240513190216562"></p>
<blockquote>
<p><strong>8259的相关参考资料</strong></p>
<ul>
<li>《8259.pdf》</li>
<li><a target="_blank" rel="noopener" href="https://wiki.osdev.org/PIC">osdev关于8259的文档</a></li>
<li>《LINUX内核完全剖析:基于0.12内核》第180页</li>
</ul>
</blockquote>
<h3 id="2、实现细节-1"><a href="#2、实现细节-1" class="headerlink" title="2、实现细节"></a>2、实现细节</h3><p>初始化两个<code>8259</code>芯片。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// irq.h</span></span><br><span class="line"><span class="comment">// Interrupt Controller</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW1           0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW2           0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW3           0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW4           0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_IMR            0x21</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW1           0xA0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW2           0xA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW3           0xA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW4           0xA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_IMR            0xA1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_ICW1_ALWAYS_1   (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_ICW1_ICW4       (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_ICW4_8086       (1 &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_PIC_START       0x20</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// irq.c</span></span><br><span class="line"><span class="comment">/* Interrupt Controller Initialization */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_pic</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 对两个8259芯片进行初始化</span></span><br><span class="line">    outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);</span><br><span class="line">    outb(PIC0_ICW2, IRQ_PIC_START);</span><br><span class="line">    outb(PIC0_ICW3, <span class="number">1</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    outb(PIC0_ICW4, PIC_ICW4_8086);</span><br><span class="line"></span><br><span class="line">    outb(PIC1_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);</span><br><span class="line">    outb(PIC1_ICW2, IRQ_PIC_START + <span class="number">8</span>);</span><br><span class="line">    outb(PIC1_ICW3, <span class="number">2</span>);</span><br><span class="line">    outb(PIC1_ICW4, PIC_ICW4_8086);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断屏蔽寄存器初始化</span></span><br><span class="line">    outb(PIC0_IMR, <span class="number">0xFF</span> &amp; ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>));  <span class="comment">// 不禁止来自IRQ2的中断信号，因为其用于连接从片</span></span><br><span class="line">    outb(PIC1_IMR, <span class="number">0xFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131920596.png" alt="image-20240513192023489"></p>
<p>该寄存器的相应位为1时，会屏蔽对应的中断，使得CPU不予相应。当对芯片刚完成初始化时，还未配置相应的中断处理程序，因此需要将这个寄存器先设置为全1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断屏蔽寄存器初始化</span></span><br><span class="line">outb(PIC0_IMR, <span class="number">0xFF</span> &amp; ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>));  <span class="comment">// 不禁止来自IRQ2的中断信号，因为其用于连接从片</span></span><br><span class="line">outb(PIC1_IMR, <span class="number">0xFF</span>);</span><br></pre></td></tr></table></figure>

<h2 id="4-10-中断的打开与关闭"><a href="#4-10-中断的打开与关闭" class="headerlink" title="4.10 中断的打开与关闭"></a>4.10 中断的打开与关闭</h2><p>中断的打开与关闭受制于两个配置：</p>
<ol>
<li><code>EFLAGS</code>的<code>IF</code>标志位；</li>
<li><code>8259</code>的<code>IMR</code>寄存器。</li>
</ol>
<center class="half">
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131933225.png" width="400"/>
    <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405131920596.png" width="400"/>    
</center>




<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> mask = inb(PIC0_IMR) &amp; ~(<span class="number">1</span> &lt;&lt; irq_num);</span><br><span class="line"><span class="type">uint8_t</span> mask = inb(PIC0_IMR) | (<span class="number">1</span> &lt;&lt; irq_num);</span><br></pre></td></tr></table></figure>

<p><strong>分别做了什么操作？</strong></p>
<p>这两行代码分别对 PIC0 的中断屏蔽寄存器（PIC0_IMR）进行了修改操作：</p>
<ol>
<li><code>uint8_t mask = inb(PIC0_IMR) &amp; ~(1 &lt;&lt; irq_num);</code><ul>
<li>这行代码首先读取了 PIC0_IMR 寄存器的当前值，使用 <code>inb</code> 函数。</li>
<li>然后，它通过 <code>(1 &lt;&lt; irq_num)</code> 生成了一个只有第 <code>irq_num</code> 位为 0，其它位为 1 的屏蔽码。</li>
<li>最后，通过 <code>&amp;</code> 操作符，将读取的值与生成的屏蔽码进行按位与操作，将指定的中断号 <code>irq_num</code> 对应的位清零。</li>
<li>最终结果存储在 <code>mask</code> 变量中。</li>
</ul>
</li>
<li><code>uint8_t mask = inb(PIC0_IMR) | (1 &lt;&lt; irq_num);</code><ul>
<li>这行代码也是首先读取了 PIC0_IMR 寄存器的当前值，使用 <code>inb</code> 函数。</li>
<li>然后，它通过 <code>(1 &lt;&lt; irq_num)</code> 生成了一个只有第 <code>irq_num</code> 位为 1，其它位为 0 的屏蔽码。</li>
<li>最后，通过 <code>|</code> 操作符，将读取的值与生成的屏蔽码进行按位或操作，将指定的中断号 <code>irq_num</code> 对应的位设置为 1。</li>
<li>最终结果存储在 <code>mask</code> 变量中。</li>
</ul>
</li>
</ol>
<p>这两行代码的目的是对指定的中断号 <code>irq_num</code> 进行屏蔽或解除屏蔽操作，以控制该中断是否被响应。</p>
<h2 id="4-11-启动定时器并打开中断"><a href="#4-11-启动定时器并打开中断" class="headerlink" title="4.11 启动定时器并打开中断"></a>4.11 启动定时器并打开中断</h2><blockquote>
<p>参考资料</p>
<ul>
<li>《8259.pdf》</li>
<li><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Programmable_Interval_Timer">osdev关于8253的文档</a></li>
<li><a target="_blank" rel="noopener" href="http://www.osdever.net/bkerndev/Docs/pit.htm">关于8253配置的文档</a></li>
<li>《LINUX内核完全剖析:基于0.12内核》第316页</li>
</ul>
</blockquote>
<p>示例：外部中断的产生，以及如何跳转到对应的中断处理程序中。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405132011988.png" alt="image-20240513201126601"></p>
<ul>
<li><p>8253芯片是一个可编程的计时器&#x2F;计数器芯片，它有三个独立的计时器&#x2F;计数器通道（定时器0、定时器1和定时器2）。</p>
<ol>
<li><strong>定时器0</strong>：主要用于系统时钟中断，即产生系统时钟滴答，用于操作系统的时钟中断。这是确保操作系统能够定期执行任务调度和其他定时任务的关键。</li>
<li><strong>定时器1</strong>：通常用于动态内存刷新，但在现代系统中，这一功能已经被集成到内存控制器中，定时器1基本上已经不再使用。</li>
<li><strong>定时器2</strong>：常用于扬声器的声音发生。在大多数系统中，如果没有特别的需求，也不需要初始化定时器2。</li>
</ol>
</li>
<li><p>定时器0的初始化原因</p>
<ul>
<li><p>系统时钟中断：操作系统依赖于系统时钟中断来管理时间和任务调度。通过定时器0，操作系统可以产生定时中断（通常是每秒多次），以进行以下任务：</p>
<ul>
<li><p><strong>任务调度</strong>：定时中断使得操作系统能够在多任务环境中切换任务。</p>
</li>
<li><p><strong>系统时间更新</strong>：维护系统的时间和日期。</p>
</li>
<li><p><strong>超时处理</strong>：处理某些操作的超时功能。</p>
</li>
</ul>
</li>
<li><p>通常的配置方式：初始化定时器0时，设置它为重复模式（模式3，即方波模式），并指定合适的计数值，以产生所需频率的中断。例如，如果需要每秒产生100个中断（100Hz），则可以根据时钟频率和目标频率计算合适的计数值。</p>
</li>
</ul>
</li>
<li><p>初始化定时器0的步骤</p>
<p><strong>本项目中，只需要一个可以周期性产生中断的定时器，无需考虑各种硬件方面的东西。</strong>因此，只需要将定时器设置成自动周期性触发中断即可，而模式<code>3</code>可以方便的实现此功能，因此选用的模式<code>3</code>其它模式较为复杂，有的需要和硬件配合，有的需要在中断中重新配置定时器，所以没有使用这些模式。</p>
</li>
</ul>
<p><code>8253</code>端口地址与说明</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405140922412.png" alt="image-20240514092203861"></p>
<blockquote>
<p>（注：无论是手册上还是各种资料上关于工作模式都讲得过细，特别是有些资料还讲了一些<code>8253</code>硬件输出信号的问题。这些与我们的操作系统设计没什么关系，不用看，直接跳过即可。)</p>
</blockquote>
<ul>
<li><p>定时器工作原理</p>
<p>8253&#x2F;8254定时器芯片的工作原理是基于一个固定频率的晶体振荡器（例如1193182 Hz）。该芯片有三个独立的计数器，每个计数器都有一个初始计数值，从这个值开始<strong>倒计时</strong>。倒计时完成后，计数器会溢出，触发一个中断或者在输出引脚上产生一个信号。</p>
</li>
<li><p>初始计数值的作用</p>
<ul>
<li>控制中断频率</li>
</ul>
<ul>
<li><p>通过设置不同的初始计数值，可以控制定时器的中断频率。初始计数值越大，倒计时的时间越长，生成中断的频率就越低。反之，初始计数值越小，倒计时的时间越短，生成中断的频率就越高。</p>
</li>
<li><p>具体来说，计数器的倒计时周期是晶体振荡器周期和初始计数值的乘积。假设晶体振荡器频率为<code>1193182 Hz</code>，初始计数值为计数器倒计时的周期数，那么<code>中断频率（Hz） = 振荡器频率（Hz） / 初始计数值</code>。</p>
</li>
</ul>
</li>
<li><p>计算初始计数值</p>
<p>假设我们想设置定时器<code>0</code>生成每秒<code>100</code>次的中断（即中断频率为<code>100 Hz</code>），我们需要计算初始计数值如下：</p>
<p><code>初始计数值=振荡器频率/中断频率=1193182/100=11931</code></p>
<p>这意味着，我们将定时器<code>0</code>的初始计数值设置为<code>11931</code>，它将在每经过<code>11931</code>个时钟周期后触发一次中断，产生<code>100 Hz</code>的中断频率。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception_handler time, 0x20, 0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>0x20</code>：将<code>8253</code>芯片关联到<code>8259</code>的<code>IRQ0</code>端口，而<code>8259</code>的起始地址为<code>0x20</code>。</li>
</ul>
<h1 id="五、日志与printf格式化输出"><a href="#五、日志与printf格式化输出" class="headerlink" title="五、日志与printf格式化输出"></a>五、日志与printf格式化输出</h1><h2 id="5-1-创建日志打印接口"><a href="#5-1-创建日志打印接口" class="headerlink" title="5.1 创建日志打印接口"></a>5.1 创建日志打印接口</h2><p><strong>在操作系统内核中编写日志接口时，通常不使用C库自带的<code>printf</code>函数。</strong>这是由于以下几个关键原因：</p>
<ol>
<li><p><strong>依赖性和可移植性</strong></p>
<ul>
<li><p><strong>标准库依赖性</strong>：<code>printf</code>是标准C库的一部分，它依赖于操作系统提供的底层设施（如文件系统、IO设备、内存管理等）。在操作系统内核早期启动阶段，这些设施可能尚未初始化。</p>
</li>
<li><p><strong>可移植性问题</strong>：不同的标准库实现可能有所不同，在某些平台上，标准库可能并不适用于内核空间。</p>
</li>
</ul>
</li>
<li><p><strong>内核空间和用户空间的区别</strong></p>
<ul>
<li><p><strong>内核空间和用户空间</strong>：标准库函数如<code>printf</code>通常在用户空间中运行，而操作系统内核运行在特权的内核空间。内核代码需要直接访问硬件和内存管理，这些功能在用户空间的标准库中不可用。</p>
</li>
<li><p><strong>上下文切换</strong>：使用标准库函数可能会引起不必要的上下文切换和中断，这在内核模式下可能是不允许的或是效率低下的。</p>
</li>
</ul>
</li>
<li><p><strong>资源管理</strong></p>
<ul>
<li><p><strong>内存管理</strong>：内核必须处理自己的内存分配和管理，而标准C库中的<code>printf</code>会隐含地调用一些内存管理函数，这可能与内核的内存管理机制冲突。</p>
</li>
<li><p><strong>线程安全性</strong>：<code>printf</code>在多线程环境下的行为在内核中可能不可靠，因为内核需要处理并发性和同步问题。</p>
</li>
</ul>
</li>
<li><p><strong>性能和实时性要求</strong></p>
<ul>
<li><p><strong>性能</strong>：内核态代码通常需要高效和快速地执行，标准库的<code>printf</code>包含复杂的格式解析和输出操作，这可能带来不必要的性能开销。</p>
</li>
<li><p><strong>实时性</strong>：内核中某些操作需要实时响应，而<code>printf</code>的执行时间不可预测，这可能导致内核无法满足实时性要求。</p>
</li>
</ul>
</li>
<li><p><strong>调试和错误处理</strong></p>
<ul>
<li><p><strong>错误处理</strong>：内核需要处理低级错误，而<code>printf</code>可能引入新的故障点。例如，<code>printf</code>依赖的某些资源在内核执行时不可用或已被其他部分使用。</p>
</li>
<li><p><strong>调试支持</strong>：在内核开发过程中，使用自定义的日志函数可以提供更多控制和定制，便于内核态调试和问题追踪。</p>
</li>
</ul>
</li>
</ol>
<h2 id="5-2-实现基本的信息输出"><a href="#5-2-实现基本的信息输出" class="headerlink" title="5.2 实现基本的信息输出"></a>5.2 实现基本的信息输出</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405141437793.png" alt="image-20240514143659706"></p>
<p>在以前的计算机中有一个<code>9</code>针的串行接口<code>RS-232</code>，有两根数据线，双向通信，分别用于发送和接收数据。<strong>在本项目中会用到这个接口来实现数据的发送的接收。</strong></p>
<p>虽然现在的计算机上没有这种接口了，但是<code>QEMU</code>依然支持这种接口。选择<code>[view-&gt;serial0]</code>，则会连接到串行接口，并将串行接口发出的数据显示到此处，而不是显示在显示器上。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405141441877.png" alt="image-20240514144102736"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm/cpu_instr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM1_PORT 0x3F8     <span class="comment">// 串行接口初始地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 日志初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化串行接口，无需了解细节</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">1</span>, <span class="number">0x00</span>);  <span class="comment">// 关闭串行接口相关中断</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">3</span>, <span class="number">0x80</span>);  <span class="comment">// 数据发送速度</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">0</span>, <span class="number">0x3</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">1</span>, <span class="number">0x00</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">3</span>, <span class="number">0x03</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">2</span>, <span class="number">0xc7</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">4</span>, <span class="number">0x0F</span>);</span><br><span class="line">&#125;                  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数可变的打印模版函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = fmt;</span><br><span class="line">    <span class="comment">// 打印fmt相关内容</span></span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 串行接口忙检测</span></span><br><span class="line">        <span class="keyword">while</span> ((inb(COM1_PORT + <span class="number">5</span>) &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>)) == <span class="number">0</span>);        </span><br><span class="line">        outb(COM1_PORT, *p++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="5-3-实现字符串的格式化输出"><a href="#5-3-实现字符串的格式化输出" class="headerlink" title="5.3 实现字符串的格式化输出"></a>5.3 实现字符串的格式化输出</h2><h3 id="1、字符串的常规处理"><a href="#1、字符串的常规处理" class="headerlink" title="1、字符串的常规处理"></a>1、字符串的常规处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _KLIB_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _KLIB_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm/types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_strcopy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_strncopy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">void</span> *src, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_memset</span><span class="params">(<span class="type">void</span> *dest, <span class="type">uint8_t</span> v, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_memcmp</span><span class="params">(<span class="type">void</span> *d1, <span class="type">void</span> *d2, <span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _KLIB_H_</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2、字符串的格式化输出"><a href="#2、字符串的格式化输出" class="headerlink" title="2、字符串的格式化输出"></a>2、字符串的格式化输出</h3><ol>
<li><p><strong>枚举类型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>NORMAL, READ_FMT&#125; state = NORMAL;</span><br></pre></td></tr></table></figure>

<p>定义一个无名枚举类型，包含两个状态 <code>NORMAL</code> 和 <code>READ_FMT</code>，并将 <code>state</code> 变量初始化为 <code>NORMAL</code>。</p>
</li>
<li><p><strong>可变参数函数</strong><br>在 C 语言中，可以定义一个函数，使其接受可变数量的参数。这些函数通常使用 <code>&lt;stdarg.h&gt;</code> 中的宏来处理可变参数。下面是一些相关的宏：</p>
<ul>
<li><p><code>va_list</code>：声明一个变量，该变量用于访问可变参数列表。</p>
</li>
<li><p><code>va_start</code>：初始化一个 <code>va_list</code> 变量，使其指向第一个可变参数。</p>
</li>
<li><p><code>va_end</code>：清理 <code>va_list</code> 变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">va_list args;  <span class="comment">// 声明va_list变量</span></span><br><span class="line">va_start(args, fmt);  <span class="comment">// 指向第一个可变参数</span></span><br><span class="line">va_end(args);  <span class="comment">// 释放args</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>va_arg</code>：获取可变参数列表中的下一个参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *str = va_arg(args, <span class="type">char</span> *);</span><br><span class="line"><span class="comment">// 第一个参数是va_list变量</span></span><br><span class="line"><span class="comment">// 第二个参数是期望的参数类型</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    num = 12345 -&gt; 10</span></span><br><span class="line"><span class="comment">    1. 12345 % 10 = 5   12345 / 10 = 1234</span></span><br><span class="line"><span class="comment">    2. 1234  % 10 = 4   1234  / 10 = 123</span></span><br><span class="line"><span class="comment">    3. 123   % 10 = 3   123   / 10 = 12</span></span><br><span class="line"><span class="comment">    4. 12    % 10 = 2   12    / 10 = 1</span></span><br><span class="line"><span class="comment">    5. 1     % 10 = 1   1     / 10 = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_itoa</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> num, <span class="type">int</span> base)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *num2ch = &#123;<span class="string">&quot;0123456789ASBCDEF&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *p = buf;</span><br><span class="line">    <span class="type">int</span> is_negative = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅处理2/8/10/16进制</span></span><br><span class="line">    <span class="keyword">if</span> ((base != <span class="number">2</span>) &amp;&amp; (base != <span class="number">8</span>) &amp;&amp; (base != <span class="number">10</span>) &amp;&amp; (base != <span class="number">16</span>)) &#123;</span><br><span class="line">        *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若为负数，则添加负号</span></span><br><span class="line">    <span class="keyword">if</span> ((num &lt; <span class="number">0</span>) &amp;&amp; (base == <span class="number">10</span>)) &#123;</span><br><span class="line">        is_negative = <span class="number">1</span>;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// num to string</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">char</span> ch = num2ch[num % base];</span><br><span class="line">        *p++ = ch;</span><br><span class="line">        num /= base;       </span><br><span class="line">    &#125;<span class="keyword">while</span> (num);</span><br><span class="line">    <span class="keyword">if</span> (is_negative) &#123;</span><br><span class="line">        *p++ = <span class="string">&#x27;-&#x27;</span>;  <span class="comment">// 若为负数，添加负号，注意放到最后以便后续进行翻转</span></span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转字符串</span></span><br><span class="line">    <span class="type">char</span> *start = buf;</span><br><span class="line">    <span class="type">char</span> *end = p - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> ch = *start;</span><br><span class="line">        *start = *end;</span><br><span class="line">        *end = ch;</span><br><span class="line"></span><br><span class="line">        end--;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_printf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理可变字符串</span></span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);  </span><br><span class="line">    kernel_vsprintf(buf, fmt, args);</span><br><span class="line">    va_end(args);  <span class="comment">// 释放args</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;Version: %s&quot;, &quot;1.0.0&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span> &#123;</span><br><span class="line">    <span class="comment">// NORMAL：原样输出状态  READ_FMT：格式化输出状态</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>NORMAL, READ_FMT&#125; state = NORMAL;</span><br><span class="line">    <span class="type">char</span> *curr = buf;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = *fmt++)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (state)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> NORMAL:</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">                state = READ_FMT;  <span class="comment">// 当遇到&#x27;%&#x27;时需要切换到格式化输出状态</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *curr++ = ch;   <span class="comment">// 否则直接原样输出即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> READ_FMT:</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;d&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> num = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                kernel_itoa(curr, num, <span class="number">10</span>);  <span class="comment">// int型变量转换为ASCII码对应的字符串</span></span><br><span class="line">                curr += kernel_strlen(curr);  <span class="comment">// curr进行跳转</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> num = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                kernel_itoa(curr, num, <span class="number">16</span>);  <span class="comment">// int型变量转换为ASCII码对应的字符串</span></span><br><span class="line">                curr += kernel_strlen(curr);  <span class="comment">// curr进行跳转</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">char</span> c = va_arg(args, <span class="type">int</span>);</span><br><span class="line">                *curr++ = c;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *str = va_arg(args, <span class="type">char</span> *);  <span class="comment">// 此时const char *str = &quot;1.0.0&quot;</span></span><br><span class="line">                <span class="type">int</span> len = kernel_strlen(str);</span><br><span class="line">                <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">                    *curr++ = *str++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state = NORMAL;  <span class="comment">// 处理完可变参数，切换回NORMAL状态</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-利用assert辅助调试"><a href="#5-4-利用assert辅助调试" class="headerlink" title="5.4 利用assert辅助调试"></a>5.4 利用assert辅助调试</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RELEASE  <span class="comment">// 若未定义RELEASE版本，说明在调试状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(expr)    \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!(expr)) pannic(__FILE__, __LINE__, __func__, #expr);</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pannic</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span> *func, <span class="type">const</span> <span class="type">char</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(expr)    ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="六、实现简单的进程切换"><a href="#六、实现简单的进程切换" class="headerlink" title="六、实现简单的进程切换"></a>六、实现简单的进程切换</h1><h2 id="6-1-添加任务状态段"><a href="#6-1-添加任务状态段" class="headerlink" title="6.1 添加任务状态段"></a>6.1 添加任务状态段</h2><p><strong>目前的代码中，中断处理程序处理中断相关的工作，主程序负责执行所有其它工作</strong>（仅考虑只有一个CPU内核的情况）。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142022102.png" alt="image-20240514202203665" style="zoom: 50%;" />

<p>借助于操作系统的进程切换机制，我们可以同时运行多个程序。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142023040.png" alt="image-20240514202342715" style="zoom:50%;" />

<p>现在考虑实现这样一个任务，即利用进程切换机制，同时实现以下两个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;init task: %d&quot;</span>, count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a = 3 / 0;</span></span><br><span class="line">    <span class="comment">// irq_enable_global();</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;init main: %d&quot;</span>, count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、理论基础-8"><a href="#1、理论基础-8" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>操作系统为了让CPU能够同时执行多个程序，在切换到另一个程序运行前需要<strong>记录当前程序的运行状态</strong>。<br>这样当程序再次运行时，才能够恢复到之前的运行状态。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142039947.png" alt="image-20240514203914718" style="zoom:50%;" />

<ul>
<li><code>TSS/Task-State Segment</code>：保存当前程序的运行状态。（用<code>Task</code>表示进程的运行状态）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142038829.png" alt="image-20240514203814450"></p>
<h3 id="2、TSS定义"><a href="#2、TSS定义" class="headerlink" title="2、TSS定义"></a>2、TSS定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TSS/Task-State Segment r 任务状态段</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tss_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> pre_link;      <span class="comment">// 上一个任务链接</span></span><br><span class="line">    <span class="type">uint32_t</span> esp0, ss0;     <span class="comment">// 内核模式下的栈指针和栈段选择子</span></span><br><span class="line">    <span class="type">uint32_t</span> esp1, ss1;     <span class="comment">// 备用栈指针和栈段选择子（通常不使用）</span></span><br><span class="line">    <span class="type">uint32_t</span> esp2, ss2;     <span class="comment">// 备用栈指针和栈段选择子（通常不使用）</span></span><br><span class="line">    <span class="type">uint32_t</span> cr3;           <span class="comment">// 页目录基地址寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> eip;           <span class="comment">// 指令指针寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> eflags;        <span class="comment">// 标志寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi; <span class="comment">// 通用寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> es, cs, ss, ds, fs, gs; <span class="comment">// 段寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> ldt;           <span class="comment">// 局部描述符表的段选择子</span></span><br><span class="line">    <span class="type">uint32_t</span> iomap;         <span class="comment">// I/O许可位图的基地址</span></span><br><span class="line">&#125;<span class="type">tss_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>TSS</code>如何描述任务状态？</p>
<ul>
<li><p><code>TSS</code>中各字段的分类</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142050761.png" alt="image-20240514205059174"></p>
</li>
<li><p>程序的运行状态，包含了诸多信息：</p>
<ul>
<li>当前正执行哪些代码、有哪些数据、使用了哪块区域做堆栈、当前执行指令的地址、前一指令的运行状态、运算所用的寄存器信息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142057431.png" alt="image-20240514205712046"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142115267.png" alt="image-20240514211539824"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142117502.png" alt="image-20240514211733961"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405142118228.png" alt="image-20240514211833645"></p>
</li>
</ul>
<h2 id="6-2-任务的简单初始化"><a href="#6-2-任务的简单初始化" class="headerlink" title="6.2 任务的简单初始化"></a>6.2 任务的简单初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> *      TSS Initialization </span></span><br><span class="line"><span class="comment"> *      当有程序/进程第一次运行时会调用tss_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tss_init</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    kernel_memset(&amp;task-&gt;tss, <span class="number">0</span>, <span class="keyword">sizeof</span>(task-&gt;tss));</span><br><span class="line">    task-&gt;tss.eip = entry;  <span class="comment">// 调用tss_init的函数的入口地址（该函数第一次运行）</span></span><br><span class="line">    task-&gt;tss.esp = task-&gt;tss.esp0 = esp;  <span class="comment">// 指示调用tss_init的函数的栈顶的位置（此时栈为空）</span></span><br><span class="line">    task-&gt;tss.ss = task-&gt;tss.ss0 = KERNEL_SELECTOR_DS;  <span class="comment">// 由于第一次运行，因此寄存器设置为默认的选择子</span></span><br><span class="line">    task-&gt;tss.es = task-&gt;tss.ds = task-&gt;tss.fs = task-&gt;tss.gs = KERNEL_SELECTOR_DS;</span><br><span class="line">    task-&gt;tss.cs = KERNEL_SELECTOR_CS;</span><br><span class="line">    task-&gt;tss.eflags = EFLAGS_DEFAULT | EFLAGS_IF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task Initializtion */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ASSERT((task != (<span class="type">task_t</span> *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    tss_init(task, entry, esp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-简单双任务相互切换"><a href="#6-3-简单双任务相互切换" class="headerlink" title="6.3 简单双任务相互切换"></a>6.3 简单双任务相互切换</h2><h3 id="1、理论"><a href="#1、理论" class="headerlink" title="1、理论"></a>1、理论</h3><p><code>x86</code>硬件对于任务的管理包括：</p>
<ul>
<li><code>Task Register/TR寄存器</code>：保存了<code>Task</code>相关的选择子</li>
<li><code>TSS</code>描述符：<code>GDT</code>表中的<code>TSS Desc</code>表项，每个<code>TSS</code>有自己对应的描述符</li>
<li><code>TSS</code></li>
<li>任务的代码、数据和栈空间</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405150949978.png" alt="image-20240515094947839"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405150958664.png" alt="image-20240515095802569"></p>
<h3 id="2、采用JMP进行任务切换"><a href="#2、采用JMP进行任务切换" class="headerlink" title="2、采用JMP进行任务切换"></a>2、采用JMP进行任务切换</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151000598.png" alt="image-20240515100023458" style="zoom:50%;" />

<blockquote>
<p>解答一下<code>task init(&amp;first task,0,0)</code>两个参数为<code>0</code>的问题：由于<code>first task</code>在<code>kernel</code>跑起来后已经运行，因此并不需要从<code>tss</code>中加载初始化的值，所以里面的值无所谓，并且在后面切换到<code>init task</code>时会因保存状态而被改写。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">task_t</span> sub_task;</span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> first_task;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> init_task_stack[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;sub task: %d&quot;</span>, count++);</span><br><span class="line">        task_switch_from_to(&amp;sub_task, &amp;first_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a = 3 / 0;</span></span><br><span class="line">    <span class="comment">// irq_enable_global();</span></span><br><span class="line">    task_init(&amp;sub_task, (<span class="type">uint32_t</span>)init_task_entry, (<span class="type">uint32_t</span>)&amp;init_task_stack[<span class="number">1024</span>]);</span><br><span class="line">    task_init(&amp;first_task, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// ?-&gt;看上面的引用部分，有相关解释</span></span><br><span class="line">    write_tr(first_task.tss_sel);  <span class="comment">// 对TR寄存器初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;main task: %d&quot;</span>, count++);</span><br><span class="line">        task_switch_from_to(&amp;first_task, &amp;sub_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Task Switch */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_switch_from_to</span> <span class="params">(<span class="type">task_t</span> *from, <span class="type">task_t</span> *to)</span> &#123;</span><br><span class="line">    switch_to_tss(to-&gt;tss_sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 远跳转实现任务切换 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">switch_to_tss</span> <span class="params">(<span class="type">int</span> tss_sel)</span> &#123;</span><br><span class="line">    far_jump(tss_sel, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-4-另一种任务切换方式"><a href="#6-4-另一种任务切换方式" class="headerlink" title="6.4 另一种任务切换方式"></a>6.4 另一种任务切换方式</h2><h3 id="1、理论基础-9"><a href="#1、理论基础-9" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><blockquote>
<p>任务切换的本质是保存前一任务的运行状态，恢复下一任务的运行状态。</p>
</blockquote>
<p>硬件实际上会帮助我们去自动保存这些状态，但是如果采用手动保存的方式，切换会更快。</p>
<p>需要保存的状态如下。<strong>可以为这些状态单独设置空间保存，也可以直接将其保存在任务自己的栈中。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151054801.png" alt="image-20240515105445584" style="zoom:50%;" />

<p>当然，对于上述状态也可以进行选择性保存：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151058922.png" alt="image-20240515105836713"></p>
<p>因此，最终只需要保存少量的寄存器就可以实现任务切换：</p>
<ul>
<li>注意<code>esp</code>指示此处的栈顶位置，因此要在别处单独存放。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151454378.png" alt="image-20240515145411029" style="zoom:50%;" />

<h3 id="2、代码实现-1"><a href="#2、代码实现-1" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述程序/进程运行状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>    *<span class="built_in">stack</span>;     <span class="comment">// 当前Task的任务栈</span></span><br><span class="line">    <span class="type">tss_t</span>       tss;        <span class="comment">// TSS段</span></span><br><span class="line">    <span class="type">int</span>         tss_sel;    <span class="comment">// Task Selector</span></span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel-&gt;init-&gt;init.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> sub_task;</span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> first_task;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> init_task_stack[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;sub task: %d&quot;</span>, count++);</span><br><span class="line">        task_switch_from_to(&amp;sub_task, &amp;first_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a = 3 / 0;</span></span><br><span class="line">    <span class="comment">// irq_enable_global();</span></span><br><span class="line">    task_init(&amp;sub_task, (<span class="type">uint32_t</span>)init_task_entry, (<span class="type">uint32_t</span>)&amp;init_task_stack[<span class="number">1024</span>]);</span><br><span class="line">    task_init(&amp;first_task, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    write_tr(first_task.tss_sel);  <span class="comment">// 对TR寄存器初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;main task: %d&quot;</span>, count++);</span><br><span class="line">        task_switch_from_to(&amp;first_task, &amp;sub_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel-&gt;core-&gt;task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task Initializtion */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ASSERT((task != (<span class="type">task_t</span> *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tss_init(task, entry, esp);</span></span><br><span class="line">    <span class="type">uint32_t</span> *pesp = (<span class="type">uint32_t</span> *)esp;  <span class="comment">// 取出当前栈顶指针</span></span><br><span class="line">    <span class="keyword">if</span> (pesp) &#123;  </span><br><span class="line">        <span class="comment">// 将任务入口地址入栈</span></span><br><span class="line">        *(--pesp) = entry;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置edi, esi, ebx, ebp</span></span><br><span class="line">        *(--pesp) = <span class="number">0</span>;</span><br><span class="line">        *(--pesp) = <span class="number">0</span>;</span><br><span class="line">        *(--pesp) = <span class="number">0</span>;</span><br><span class="line">        *(--pesp) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前栈指针保存到任务结构体中</span></span><br><span class="line">        task-&gt;<span class="built_in">stack</span> = pesp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      **from      指向[当前任务的栈指针]的指针</span></span><br><span class="line"><span class="comment"> *      *to         指向[新任务]的栈指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">simple_switch</span> <span class="params">(<span class="type">uint32_t</span> **from, <span class="type">uint32_t</span> *to)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task Switch */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_switch_from_to</span> <span class="params">(<span class="type">task_t</span> *from, <span class="type">task_t</span> *to)</span> &#123;</span><br><span class="line">    <span class="comment">// switch_to_tss(to-&gt;tss_sel);</span></span><br><span class="line">    simple_switch(&amp;from-&gt;<span class="built_in">stack</span>, to-&gt;<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">simple_switch:</span><br><span class="line">    # 向当前Task对应的栈压栈</span><br><span class="line">    mov 4(%esp), %eax    # 将当前任务的栈指针地址（**from）传递给eax</span><br><span class="line">    mov 8(%esp), %edx    # 将下一个任务的栈指针地址（*to）传递给edx</span><br><span class="line"></span><br><span class="line">    push %ebp            # 保存当前任务的ebp寄存器</span><br><span class="line">    push %ebx            # 保存当前任务的ebx寄存器</span><br><span class="line">    push %esi            # 保存当前任务的esi寄存器</span><br><span class="line">    push %edi            # 保存当前任务的edi寄存器</span><br><span class="line"></span><br><span class="line">    # 从另一个任务的栈中出栈</span><br><span class="line">    mov %esp, (%eax)     # 保存当前任务的esp到eax指向的内存中（保存当前任务的栈指针）</span><br><span class="line">    mov %edx, %esp       # 切换到下一个任务的栈指针（esp指向新任务的栈顶）</span><br><span class="line">    pop %edi             # 恢复下一个任务的edi寄存器</span><br><span class="line">    pop %esi             # 恢复下一个任务的esi寄存器</span><br><span class="line">    pop %ebx             # 恢复下一个任务的ebx寄存器</span><br><span class="line">    pop %ebp             # 恢复下一个任务的ebp寄存器</span><br><span class="line"></span><br><span class="line">    ret                  # 返回，切换到下一个任务的执行</span><br></pre></td></tr></table></figure>

<h1 id="七、实现链表数据结构"><a href="#七、实现链表数据结构" class="headerlink" title="七、实现链表数据结构"></a>七、实现链表数据结构</h1><h2 id="7-1-定义结点和链表"><a href="#7-1-定义结点和链表" class="headerlink" title="7.1 定义结点和链表"></a>7.1 定义结点和链表</h2><p>在进程运行过程中，可能因为多种原因需要等待，从而加入相应的等待队列中。如下图共有三个队列，其中就绪队列中的进程已经准备好了，随时可以运行，只是在等待处理器空闲。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151550561.png" alt="image-20240515155011285" style="zoom:50%;" />

<p>考虑到系统中可能有很多进程，因此采用链表结构进行管理。</p>
<img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240515155549617.png" alt="image-20240515155549617" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list_node_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">list_node_t</span> *<span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">list_node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;<span class="type">list_node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_node_init</span> <span class="params">(<span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    node-&gt;pre = node-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">list_node_t</span> *<span class="title function_">list_node_pre</span> <span class="params">(<span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">list_node_t</span> *<span class="title function_">list_node_next</span> <span class="params">(<span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list_t</span> &#123;</span></span><br><span class="line">    <span class="type">list_node_t</span> *first;</span><br><span class="line">    <span class="type">list_node_t</span> *last;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;<span class="type">list_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_init</span> <span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-链表的两种插入"><a href="#7-2-链表的两种插入" class="headerlink" title="7.2 链表的两种插入"></a>7.2 链表的两种插入</h2><h3 id="1、头插"><a href="#1、头插" class="headerlink" title="1、头插"></a>1、头插</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151634229.png" alt="image-20240515163412939" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头插</span></span><br><span class="line"><span class="comment"> * @param list 待插入的链表</span></span><br><span class="line"><span class="comment"> * @param node 待插入的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_first</span><span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>, <span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置node</span></span><br><span class="line">    node-&gt;next = <span class="built_in">list</span>-&gt;first;</span><br><span class="line">    node-&gt;pre = (<span class="type">list_node_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list_is_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">        <span class="comment">// 若list为空，则first &amp; last均指向node</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;last = <span class="built_in">list</span>-&gt;first = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，仅调整first指向</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;first-&gt;pre = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;first = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、尾插"><a href="#2、尾插" class="headerlink" title="2、尾插"></a>2、尾插</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151730245.png" alt="image-20240515173058966" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾插</span></span><br><span class="line"><span class="comment"> * @param list 操作的链表</span></span><br><span class="line"><span class="comment"> * @param node 待插入的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_last</span><span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>, <span class="type">list_node_t</span> *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置node</span></span><br><span class="line">    node-&gt;pre = <span class="built_in">list</span>-&gt;last;</span><br><span class="line">    node-&gt;next = (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list_is_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">        <span class="comment">// 若list为空，则first &amp; last均指向node</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;first = <span class="built_in">list</span>-&gt;last = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，仅调整last指向</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;last-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;last = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-链表的两种删除"><a href="#7-3-链表的两种删除" class="headerlink" title="7.3 链表的两种删除"></a>7.3 链表的两种删除</h2><h3 id="1、头删"><a href="#1、头删" class="headerlink" title="1、头删"></a>1、头删</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151731170.png" alt="image-20240515173113880" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头删</span></span><br><span class="line"><span class="comment"> * @param list 操作的链表</span></span><br><span class="line"><span class="comment"> * @return 链表的第一个结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">list_node_t</span>* <span class="title function_">list_remove_first</span><span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// list为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (list_is_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取要删除的结点</span></span><br><span class="line">    <span class="type">list_node_t</span> * remove_node = <span class="built_in">list</span>-&gt;first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改first指向</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;first = remove_node-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;first == (<span class="type">list_node_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 若list为空，修改last也指向空</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;last = (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若list非空，修改当前first的前驱为0</span></span><br><span class="line">        remove_node-&gt;next-&gt;pre = (<span class="type">list_node_t</span> *)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改node的pre和next为0</span></span><br><span class="line">    remove_node-&gt;next = remove_node-&gt;pre = (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;count--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> remove_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、删除任意结点"><a href="#2、删除任意结点" class="headerlink" title="2、删除任意结点"></a>2、删除任意结点</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405151731210.png" alt="image-20240515173125900" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除任意结点，但不检查node是否在list中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">list_node_t</span> * <span class="title function_">list_remove</span><span class="params">(<span class="type">list_t</span> *<span class="built_in">list</span>, <span class="type">list_node_t</span> *remove_node)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是头，则头往前移</span></span><br><span class="line">    <span class="keyword">if</span> (remove_node == <span class="built_in">list</span>-&gt;first) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;first = remove_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是尾，则尾往回移</span></span><br><span class="line">    <span class="keyword">if</span> (remove_node == <span class="built_in">list</span>-&gt;last) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;last = remove_node-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有前，则调整前的后继</span></span><br><span class="line">    <span class="keyword">if</span> (remove_node-&gt;pre) &#123;</span><br><span class="line">        remove_node-&gt;pre-&gt;next = remove_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有后，则调整后的前驱</span></span><br><span class="line">    <span class="keyword">if</span> (remove_node-&gt;next) &#123;</span><br><span class="line">        remove_node-&gt;next-&gt;pre = remove_node-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空node指向</span></span><br><span class="line">    remove_node-&gt;pre = remove_node-&gt;next = (<span class="type">list_node_t</span>*)<span class="number">0</span>;</span><br><span class="line">    --<span class="built_in">list</span>-&gt;count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> remove_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-4-获取结点所在的结构"><a href="#7-4-获取结点所在的结构" class="headerlink" title="7.4 获取结点所在的结构"></a>7.4 获取结点所在的结构</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152028459.png" alt="image-20240515202836119"></p>
<p>对下图的解释：</p>
<p>比如说对于下图的<code>node</code>，要取其地址用到了<code>&amp;(a-&gt;node)</code>，这一行代码实际上是完成了<code>a的基地址+offset(node相对于基地址的offset)</code>这个操作。</p>
<p>因此，如果要求解这一段<code>offset</code>，就可以假定在最开始有一个和<code>node</code>同类型的数据，这样<code>a的基地址</code>这一项就为<code>0</code>，所以求解到的就是<code>offset</code>的值。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152033989.png" alt="image-20240515203321728"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offset_in_parent(parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    ((uint32_t)&amp;(((parent_type *)0)-&gt;node_name))</span></span><br><span class="line"><span class="comment">// parent_addr  --  parent的起始地址</span></span><br><span class="line"><span class="comment">// node         --  node的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> parent_addr(node, parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    (((uint32_t)node) -  offset_in_parent(parent_type, node_name))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_node_parent(node, parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    ((parent_type *)(node ? parent_addr(node, parent_type, node_name) : 0))</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>offset_in_parent</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offset_in_parent(parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    ((uint32_t)&amp;(((parent_type *)0)-&gt;node_name))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能</strong>：计算一个节点在其父结构体中的偏移量。</li>
<li>参数<ul>
<li><code>parent_type</code>：父结构体的类型。</li>
<li><code>node_name</code>：节点在父结构体中的成员变量名。</li>
</ul>
</li>
<li><strong>实现</strong>：通过将一个空指针类型转换为 <code>parent_type</code> 并访问 <code>node_name</code> 成员，然后取该成员的地址。由于起始地址为0，这样计算出的地址即为偏移量。</li>
</ul>
</li>
<li><p><strong>parent_addr</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> parent_addr(node, parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    (((uint32_t)node) - offset_in_parent(parent_type, node_name))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能</strong>：从节点地址推导出包含该节点的父结构体的地址。</li>
<li>参数<ul>
<li><code>node</code>：节点的地址。</li>
<li><code>parent_type</code>：父结构体的类型。</li>
<li><code>node_name</code>：节点在父结构体中的成员变量名。</li>
</ul>
</li>
<li><strong>实现</strong>：通过节点地址减去节点在父结构体中的偏移量来获取父结构体的地址。</li>
</ul>
</li>
<li><p><strong>list_node_parent</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_node_parent(node, parent_type, node_name) \</span></span><br><span class="line"><span class="meta">    ((parent_type *)(node ? parent_addr(node, parent_type, node_name) : 0))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能</strong>：从节点地址安全地获取包含该节点的父结构体的地址。</li>
<li>参数<ul>
<li><code>node</code>：节点的地址。</li>
<li><code>parent_type</code>：父结构体的类型。</li>
<li><code>node_name</code>：节点在父结构体中的成员变量名。</li>
</ul>
</li>
<li><strong>实现</strong>：如果节点不为 <code>NULL</code>，则调用 <code>parent_addr</code> 宏；否则返回 <code>NULL</code>。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_test</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">list_t</span> <span class="built_in">list</span>;</span><br><span class="line">    <span class="type">list_node_t</span> nodes[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    list_init(&amp;<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">list_node_t</span> *node = nodes + i;</span><br><span class="line">        log_printf(<span class="string">&quot;insert first to list: %d, 0x%x&quot;</span>, i, (<span class="type">uint32_t</span>)node);</span><br><span class="line">        list_insert_first(&amp;<span class="built_in">list</span>, node);</span><br><span class="line">    &#125;</span><br><span class="line">    log_printf(<span class="string">&quot;list: first=0x%x, last=0x%x, count=%d&quot;</span>,</span><br><span class="line">        list_first(&amp;<span class="built_in">list</span>), list_last(&amp;<span class="built_in">list</span>), list_count(&amp;<span class="built_in">list</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type_t</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">list_node_t</span> node;</span><br><span class="line">    &#125;v = &#123;<span class="number">0x123456</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type_t</span> *<span class="title">a</span> =</span> (<span class="keyword">struct</span> <span class="type">type_t</span> *)<span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> addr = (<span class="type">uint32_t</span>)&amp;a-&gt;node;  <span class="comment">// 4                        </span></span><br><span class="line">    <span class="type">uint32_t</span> addr_p = offset_in_parent(<span class="keyword">struct</span> <span class="type">type_t</span>, node);  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已知node的起始地址，利用定义的宏求解v的起始地址</span></span><br><span class="line">    <span class="type">list_node_t</span> *v_node = &amp;v.node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type_t</span> *<span class="title">p</span> =</span> list_node_parent(v_node, <span class="keyword">struct</span> <span class="type">type_t</span>, node);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;i != <span class="number">0x123456</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、进程的管理与延时"><a href="#八、进程的管理与延时" class="headerlink" title="八、进程的管理与延时"></a>八、进程的管理与延时</h1><h2 id="8-1-添加任务管理器"><a href="#8-1-添加任务管理器" class="headerlink" title="8.1 添加任务管理器"></a>8.1 添加任务管理器</h2><p>截止目前，只支持两个任务，切需要进程自己主动切换，不支持延时等功能。因此需要对功能进行拓展。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152102022.png" alt="image-20240515210203823" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_manager_t</span> &#123;</span></span><br><span class="line">    <span class="type">list_t</span> ready_list;  <span class="comment">// 就绪队列</span></span><br><span class="line">    <span class="type">list_t</span> task_list;   <span class="comment">// 所有已创建队列</span></span><br><span class="line">    <span class="type">task_t</span> first_task;  <span class="comment">// 最先创建的任务</span></span><br><span class="line">    <span class="type">task_t</span> *curr_task;  <span class="comment">// 当前正在进行的任务</span></span><br><span class="line">&#125;<span class="type">task_manager_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 任务管理器初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span>;    <span class="comment">// 初始任务初始化</span></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_first_take</span> <span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 返回first task</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    list_init(&amp;task_manager.ready_list);  <span class="comment">// 初始化就绪队列</span></span><br><span class="line">    list_init(&amp;task_manager.task_list);   <span class="comment">// 初始化所有任务队列</span></span><br><span class="line">    task_manager.curr_task = (<span class="type">task_t</span> *)<span class="number">0</span>; <span class="comment">// 设置当前任务为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    task_init(&amp;task_manager.first_task, <span class="number">0</span>, <span class="number">0</span>);  		<span class="comment">// Task Initialization</span></span><br><span class="line">    write_tr(task_manager.first_task.tss_sel);          <span class="comment">// 对TR寄存器初始化</span></span><br><span class="line">    task_manager.curr_task = &amp;task_manager.first_task;  <span class="comment">// 设置当前任务为first task </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_first_take</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;task_manager.first_task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-2-将任务加入就绪队列"><a href="#8-2-将任务加入就绪队列" class="headerlink" title="8.2 将任务加入就绪队列"></a>8.2 将任务加入就绪队列</h2><p>当任务已经初始化完成时，进入<code>created</code>状态；当加入就绪队列时，进入<code>ready</code>状态。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405152123227.png" alt="image-20240515212313112" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述程序/进程运行状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// uint32_t    *stack;      // 当前Task的任务栈（采用链表管理任务时不再采用stack，直接用硬件的TSS支持切换）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>                      <span class="comment">// 任务状态</span></span><br><span class="line">        TASK_CREATED,</span><br><span class="line">        TASK_RUNNING,</span><br><span class="line">        TASK_SLEEP,</span><br><span class="line">        TASK_READY,</span><br><span class="line">        TASK_WAITING,</span><br><span class="line">    &#125;state;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> name[TASK_NAME_SIZE];  <span class="comment">// 任务名称</span></span><br><span class="line"></span><br><span class="line">    <span class="type">list_node_t</span> run_node;       <span class="comment">// run_node插入ready_list中，而非将整个task_t加入</span></span><br><span class="line">    <span class="type">list_node_t</span> all_node;       <span class="comment">// all_node插入task_list中</span></span><br><span class="line"></span><br><span class="line">    <span class="type">tss_t</span>       tss;            <span class="comment">// TSS段</span></span><br><span class="line">    <span class="type">int</span>         tss_sel;        <span class="comment">// Task Selector</span></span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Task Initializtion */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ASSERT((task != (<span class="type">task_t</span> *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化TSS</span></span><br><span class="line">    tss_init(task, entry, esp);</span><br><span class="line">    <span class="comment">// 初始化任务</span></span><br><span class="line">    kernel_strncpy(task-&gt;name, name, TASK_NAME_SIZE);</span><br><span class="line">    task-&gt;state = TASK_CREATED;</span><br><span class="line">    <span class="comment">// 初始化结点</span></span><br><span class="line">    list_node_init(&amp;task-&gt;all_node);</span><br><span class="line">    list_node_init(&amp;task-&gt;run_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务加入ready_list</span></span><br><span class="line">    task_set_ready(task);</span><br><span class="line">    <span class="comment">// 任务加入task_list</span></span><br><span class="line">    list_insert_last(&amp;task_manager.task_list, &amp;task-&gt;all_node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_ready</span><span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    list_insert_first(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">    task-&gt;state = TASK_READY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_block</span><span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    list_remove(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3-任务主动放弃CPU"><a href="#8-3-任务主动放弃CPU" class="headerlink" title="8.3 任务主动放弃CPU"></a>8.3 任务主动放弃CPU</h2><p>为了避免某个进程长时间占用CPU，可以让进程主动释放CPU的使用权，但不应当让进程指定切换到哪个进程运行。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161022580.png" alt="image-20240516102215352"></p>
<p><strong>简单起见，当进程需要让出CPU时，只需要将自己移到就绪队列的尾部即可。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161024659.png" alt="image-20240516102441540" style="zoom:50%;" />



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的实现用到了7.4所设计的宏</span></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_next_run</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">list_node_t</span> *task_node = list_first(&amp;task_manager.ready_list);</span><br><span class="line">    <span class="keyword">return</span> list_node_parent(task_node, <span class="type">task_t</span>, run_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_current</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> task_manager.curr_task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sched_yield</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前就绪队列是否还有其他任务</span></span><br><span class="line">    <span class="keyword">if</span> (list_count(&amp;task_manager.ready_list) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 取当前任务，并将其重新加入到就绪队列尾部</span></span><br><span class="line">        <span class="type">task_t</span> *curr_task = task_current();</span><br><span class="line">        task_set_block(curr_task);</span><br><span class="line">        task_set_ready(curr_task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放CPU使用权，将进程切换到当前就绪队列的第一个任务</span></span><br><span class="line">        task_dispatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_dispatch</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *to = task_next_run();</span><br><span class="line">    <span class="keyword">if</span> (to != task_manager.curr_task) &#123;</span><br><span class="line">        <span class="type">task_t</span> *from = task_current();  <span class="comment">// 定义[原来正在运行的任务]为[将要被切换掉的任务]</span></span><br><span class="line">        task_manager.curr_task = to;    <span class="comment">// 将task_manager中[当前正在运行的任务]修改为[将要切换过去的任务]</span></span><br><span class="line">        to-&gt;state = TASK_RUNNING;       <span class="comment">// 修改此任务的状态</span></span><br><span class="line"></span><br><span class="line">        task_switch_from_to(from, to);  <span class="comment">// 执行任务切换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init.c </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    sys_sched_yield();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    sys_sched_yield();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p> 解析上述代码</p>
</blockquote>
<p>根据<code>sys_sched_yield();</code>改写了整个任务切换的逻辑，不再由当前进程指定要切换到哪一个进程中，而是：</p>
<ol>
<li>当前进程放弃CPU使用权，重新移动到就绪队列的尾部；</li>
<li>从就绪队列中获取下一个要执【【行的任务<code>task_t *to = task_next_run()</code>；</li>
<li>定义[原来正在运行的任务]为[将要被切换掉的任务]<code>task_t *from = task_current()</code>；</li>
<li>将task_manager中[当前正在运行的任务]修改为[将要切换过去的任务]<code>task_manager.curr_task = to</code>；</li>
<li>修改此任务的状态为<code>TASK_RUNNING</code>；</li>
<li>执行任务切换<code>task_switch_from_to(from, to)</code>。</li>
</ol>
<h2 id="8-4-让进程按时间片运行"><a href="#8-4-让进程按时间片运行" class="headerlink" title="8.4 让进程按时间片运行"></a>8.4 让进程按时间片运行</h2><p><code>sys_sched_yield()</code>必须由进程主动调用才能放弃CPU，如果不主动调用，进程仍然长期占用CPU。为了避免进程长时间占用CPU，可以强制其运行一定时间后释放CPU。</p>
<p><strong>本项目中选择[一段时间]为<code>100ms</code>。</strong>通过<code>task_time_tick()</code>函数实现。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161046155.png" alt="image-20240516104613960" style="zoom:50%;" />

<p>注意：需要在<code>init.c</code>中开启全局中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    irq_enable_global();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// sys_sched_yield();  注意要注释掉这个函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来对<code>task_init</code>进行修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Task Initializtion */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ASSERT((task != (<span class="type">task_t</span> *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化TSS</span></span><br><span class="line">    tss_init(task, entry, esp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化任务结点</span></span><br><span class="line">    kernel_strncpy(task-&gt;name, name, TASK_NAME_SIZE);</span><br><span class="line">    task-&gt;state = TASK_CREATED;</span><br><span class="line">    <span class="comment">// =========================== 加入 ========================== //</span></span><br><span class="line">    task-&gt;time_ticks = TASK_TIME_SLICE_DEFAULT;</span><br><span class="line">    task-&gt;slice_ticks = task-&gt;time_ticks;</span><br><span class="line">    <span class="comment">// ========================================================== //</span></span><br><span class="line">    list_node_init(&amp;task-&gt;all_node);</span><br><span class="line">    list_node_init(&amp;task-&gt;run_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务加入ready_list</span></span><br><span class="line">    task_set_ready(task);</span><br><span class="line">    <span class="comment">// 任务加入task_list</span></span><br><span class="line">    list_insert_last(&amp;task_manager.task_list, &amp;task-&gt;all_node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在<code>time.c</code>中加入任务相关的中断处理<code>task_time_tick()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time.c </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_time</span> <span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">    sys_tick++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向8259通知对应的中断已完成</span></span><br><span class="line">    pic_send_eoi(IRQ0_TIMER);</span><br><span class="line">    <span class="comment">// =========================== 加入 ========================== //</span></span><br><span class="line">    task_time_tick();  <span class="comment">// 任务相关的处理</span></span><br><span class="line">    <span class="comment">// ========================================================== //</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里<code>pic_send_eoi(IRQ0_TIMER);</code>和<code>task_time_tick();</code>的顺序不能错。原因如下：、</p>
<blockquote>
<p>在中断处理程序 <code>do_handler_time</code> 中，<code>pic_send_eoi</code> 和 <code>task_time_tick</code> 的顺序不能交换，主要是为了保证中断的正确处理和系统的稳定运行。以下是详细解释：</p>
<ul>
<li><code>pic_send_eoi</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pic_send_eoi</span> <span class="params">(<span class="type">int</span> irq_num)</span> &#123;</span><br><span class="line">    irq_num -= IRQ_PIC_START;  <span class="comment">// 将irq_num变为内部序号</span></span><br><span class="line">    <span class="keyword">if</span> (irq_num &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">        outb(PIC1_OCW2, PIC_OCW2_EOI);  <span class="comment">// 向第二块8259发送eoi指令</span></span><br><span class="line">    &#125;</span><br><span class="line">    outb(PIC0_OCW2, PIC_OCW2_EOI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数向 8259 可编程中断控制器 (PIC) 发送中断结束信号 (EOI)，通知 PIC 当前中断已经处理完毕，可以接受新的中断请求。这个过程非常关键，因为它控制着中断的优先级和处理顺序。</p>
<ul>
<li><code>task_time_tick</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_time_tick</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *curr_task = task_current();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若当前任务的时间切片在运行后减少为0，说明需要对其进行任务切换</span></span><br><span class="line">    <span class="keyword">if</span> (--curr_task-&gt;slice_ticks == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 重新设置时间切片</span></span><br><span class="line">        curr_task-&gt;slice_ticks = curr_task-&gt;time_ticks;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行任务切换</span></span><br><span class="line">        task_set_block(curr_task);</span><br><span class="line">        task_set_ready(curr_task);</span><br><span class="line">        task_dispatch();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数处理与任务调度相关的逻辑，例如更新当前任务的时间片，并在需要时触发任务切换。</p>
<ul>
<li>不能交换顺序的原因</li>
</ul>
<ol>
<li><strong>中断优先级控制</strong>：<ul>
<li>在中断处理程序中，优先向 PIC 发送 EOI 信号，确保 PIC 能够继续处理其他中断。这可以防止中断嵌套过多，避免中断响应延迟。</li>
</ul>
</li>
<li><strong>任务切换时的安全性</strong>：<ul>
<li><code>task_time_tick</code> 可能会触发任务切换，这意味着当前任务的上下文（CPU 寄存器状态、栈指针等）可能会被保存，并切换到另一个任务的上下文。如果在 <code>task_time_tick</code> 中执行任务切换之前没有发送 EOI 信号，可能会导致中断处理未完全结束就切换到另一个任务，造成中断处理不完整或混乱。</li>
</ul>
</li>
<li><strong>系统稳定性</strong>：<ul>
<li>及时发送 EOI 信号可以确保系统中断处理机制的稳定性，避免中断嵌套层数过多，导致系统无法及时响应其他硬件中断请求。</li>
</ul>
</li>
</ol>
<p>因此，将 <code>task_time_tick</code> 放在 <code>pic_send_eoi</code> 之后，可以确保在进行任务切换等复杂操作前，已经通知 PIC 当前中断处理完毕。这种顺序确保了中断处理的及时性和系统的稳定性。因此，<code>pic_send_eoi</code> 和 <code>task_time_tick</code> 的调用顺序不能交换。</p>
</blockquote>
<p>最后的实现效果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161536876.png" alt="image-20240516153646690"></p>
<h2 id="8-5-临界资源与临界区"><a href="#8-5-临界资源与临界区" class="headerlink" title="8.5 临界资源与临界区"></a>8.5 临界资源与临界区</h2><p>上述任务存在一些问题，即：<strong>在两个任务进行切换的时刻输出的信息是乱的。</strong>因此需要对其进行修改。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161540957.png" alt="image-20240516154041859"></p>
<h3 id="1、理论基础-10"><a href="#1、理论基础-10" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><ul>
<li><p>并发与并行</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161541337.png" alt="image-20240516154127142"></p>
<p>因此，当多个进程或任务共同访问统一资源时，有可能产生冲突。</p>
<p>如下图所示，假设<code>first_task</code>此时运行到<code>log_printf</code>函数时，正在执行串口输出，且时间较长。由于任务间按时间片方式轮流执行，因此可能输出到一半时<code>first_task</code>的时间片用完了，正好定时器中断也到了，那么此时就会将任务切换到<code>init_task</code>，会接下来打印<code>init_task</code>的信息，从而造成输出信息混乱。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161544397.png" alt="image-20240516154434937"></p>
</li>
<li><p>临界资源和临界区</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161548492.png" alt="image-20240516154831083"></p>
</li>
</ul>
<h3 id="2、互斥实现"><a href="#2、互斥实现" class="headerlink" title="2、互斥实现"></a>2、互斥实现</h3><p>解决方法1：互斥。即一次只允许一个进程在临界区中。互斥的实现方法之一是：禁用中断。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161550138.png" alt="image-20240516155039989" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// irq.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">irq_state_t</span>;</span><br><span class="line"><span class="type">irq_state_t</span> <span class="title function_">irq_enter_protection</span> <span class="params">(<span class="type">void</span>)</span>;        <span class="comment">// 进入临界区保护状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_leave_protection</span> <span class="params">(<span class="type">irq_state_t</span> state)</span>;  <span class="comment">// 退出临界区保护状态</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数可变的打印模版函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界资源保护</span></span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = str_buf;</span><br><span class="line">    <span class="comment">// 打印fmt相关内容</span></span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 串行接口忙检测</span></span><br><span class="line">        <span class="keyword">while</span> ((inb(COM1_PORT + <span class="number">5</span>) &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>)) == <span class="number">0</span>);        </span><br><span class="line">        outb(COM1_PORT, *p++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 退出临界资源保护模式</span></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// irq.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通过关闭中断的方式实现互斥，主要需要保存进入临界区之前中断的开关状态，避免退出时意外开启中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">irq_state_t</span> <span class="title function_">irq_enter_protection</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 读取原中断状态</span></span><br><span class="line">    <span class="type">irq_state_t</span> state = read_eflags();</span><br><span class="line">    <span class="comment">// 关中断</span></span><br><span class="line">    irq_disable_global();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_leave_protection</span> <span class="params">(<span class="type">irq_state_t</span> state)</span> &#123;</span><br><span class="line">    <span class="comment">// 写回中断状态，若原中断为关闭状态，则保持；若原中断为开启状态，则恢复打开</span></span><br><span class="line">    write_eflags(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpu_instr.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读EFLAGS寄存器</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">read_eflags</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> eflags;</span><br><span class="line"></span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;pushf\n\tpop %%eax&quot;</span>:<span class="string">&quot;=a&quot;</span>(eflags));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> eflags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写EFLAGS寄存器</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">write_eflags</span> <span class="params">(<span class="type">uint32_t</span> eflags)</span> &#123;</span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;push %%eax\n\tpopf&quot;</span>::<span class="string">&quot;a&quot;</span>(eflags));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时切换点会执行完整输出</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161610637.png" alt="image-20240516160955146"></p>
<h2 id="8-6-让进程能够延时运行"><a href="#8-6-让进程能够延时运行" class="headerlink" title="8.6 让进程能够延时运行"></a>8.6 让进程能够延时运行</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;main task: %d&quot;</span>, count++);  <span class="comment">// 需求：每隔一秒输出一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当进程需要延时运行时，应当将其从就绪队列中移出，以免占用CPU；等延时时间到达后，再将其移回就绪队列。</strong>因此，专门设计一个队列，用于放置需要延时的进程。<strong>在每个时钟节拍中断发生时，扫描延时队列，发现延时时间到，则再将进程移回就绪队列尾部。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161656774.png" alt="image-20240516165606592" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_manager_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">list_t</span> sleep_list;  <span class="comment">// 睡眠队列</span></span><br><span class="line">&#125;<span class="type">task_manager_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述程序/进程运行状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> sleep_ticks;            <span class="comment">// 延时</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_sleep</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> ticks)</span>;  <span class="comment">// 任务加入睡眠队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_wakeup</span> <span class="params">(<span class="type">task_t</span> *task)</span>;                 <span class="comment">// 任务移除睡眠队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_sleep</span> <span class="params">(<span class="type">uint32_t</span> ms)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务加入睡眠队列的尾部</span></span><br><span class="line"><span class="comment"> * @param ticks 要睡眠的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_sleep</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> ticks)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ticks == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task-&gt;sleep_ticks = ticks;</span><br><span class="line">    task-&gt;state = TASK_SLEEP;</span><br><span class="line">    list_insert_last(&amp;task_manager.sleep_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务移除睡眠队列 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_wakeup</span> <span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    list_remove(&amp;task_manager.sleep_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 实现睡眠机制，使当前任务进入睡眠状态一段时间，并切换到其他任务继续执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_sleep</span> <span class="params">(<span class="type">uint32_t</span> ms)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将任务从就绪队列移动到睡眠队列</span></span><br><span class="line">    task_set_block(task_manager.curr_task);</span><br><span class="line">    task_set_sleep(task_manager.curr_task, ms + (OS_TICKS_MS - <span class="number">1</span>) / OS_TICKS_MS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到就绪队列的下一个任务执行</span></span><br><span class="line">    task_dispatch();</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现效果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405161945180.png" alt="image-20240516194523931"></p>
<h2 id="8-7-让所有进程都能延时"><a href="#8-7-让所有进程都能延时" class="headerlink" title="8.7 让所有进程都能延时"></a>8.7 让所有进程都能延时</h2><p>当所有进程都进入睡眠状态时，就绪队列为空，也就是说在<code>task_dispatch()</code>中，<code>to</code>取出的下一个任务为空，造成操作系统崩溃。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通过任务队列实现任务切换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_dispatch</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line">    </span><br><span class="line">    <span class="type">task_t</span> *to = task_next_run();		<span class="comment">// !!!!!!!此处!!!!!!!</span></span><br><span class="line">    <span class="keyword">if</span> (to != task_manager.curr_task) &#123;</span><br><span class="line">        <span class="type">task_t</span> *from = task_current();  <span class="comment">// 定义[原来正在运行的任务]为[将要被切换掉的任务]</span></span><br><span class="line">        task_manager.curr_task = to;    <span class="comment">// 将task_manager中[当前正在运行的任务]修改为[将要切换过去的任务]</span></span><br><span class="line">        to-&gt;state = TASK_RUNNING;       <span class="comment">// 修改此任务的状态</span></span><br><span class="line"></span><br><span class="line">        task_switch_from_to(from, to);  <span class="comment">// 执行任务切换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：当就绪队列为空时，运行<strong>空闲进程</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_manager_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">task_t</span> idle_task;   <span class="comment">// 空闲进程</span></span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="type">task_manager_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 任务管理器初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    list_init(&amp;task_manager.ready_list);  <span class="comment">// 初始化就绪队列</span></span><br><span class="line">    list_init(&amp;task_manager.sleep_list);  <span class="comment">// 初始化睡眠队列</span></span><br><span class="line">    list_init(&amp;task_manager.task_list);   <span class="comment">// 初始化所有任务队列</span></span><br><span class="line">    task_manager.curr_task = (<span class="type">task_t</span> *)<span class="number">0</span>;  <span class="comment">// 设置当前任务为0</span></span><br><span class="line"></span><br><span class="line">    task_init(&amp;task_manager.idle_task,</span><br><span class="line">        <span class="string">&quot;idle_task&quot;</span>,</span><br><span class="line">        (<span class="type">uint32_t</span>)idle_task_entry,</span><br><span class="line">        (<span class="type">uint32_t</span>)(idle_task_stack + IDLE_TASK_SIZE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务加入就绪队列的尾部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_ready</span> <span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于空闲进程，不应加入时间片轮换中</span></span><br><span class="line">    <span class="keyword">if</span> (task == &amp;task_manager.idle_task) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list_insert_last(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">    task-&gt;state = TASK_READY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务移除就绪队列 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_block</span> <span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于空闲进程，不应加入时间片轮换中</span></span><br><span class="line">    <span class="keyword">if</span> (task == &amp;task_manager.idle_task) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list_remove(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  从就绪队列中选取下一个要运行的任务</span></span><br><span class="line"><span class="comment"> *         这里实际上需要根据run_node取到包含run_node的task的整个结构体的起始地址，</span></span><br><span class="line"><span class="comment"> *         因为对于要对task进行操作的函数来说，需要操作的是task这个整体</span></span><br><span class="line"><span class="comment"> * @return 指向该任务的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">task_next_run</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 若就绪队列为空，运行空闲进程</span></span><br><span class="line">    <span class="keyword">if</span> (list_count(&amp;task_manager.ready_list) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;task_manager.idle_task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">list_node_t</span> *task_node = list_first(&amp;task_manager.ready_list);</span><br><span class="line">    <span class="keyword">return</span> list_node_parent(task_node, <span class="type">task_t</span>, run_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现效果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162010349.png" alt="image-20240516201030225"></p>
<h1 id="九、进程间的同步与互斥"><a href="#九、进程间的同步与互斥" class="headerlink" title="九、进程间的同步与互斥"></a>九、进程间的同步与互斥</h1><h2 id="9-1-计数信号量及其初始化"><a href="#9-1-计数信号量及其初始化" class="headerlink" title="9.1 计数信号量及其初始化"></a>9.1 计数信号量及其初始化</h2><h3 id="1、理论基础-11"><a href="#1、理论基础-11" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>在多进程运行环境中，进程之间、进程与中断之间需要协作，也可以通过信号来同步行为。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162022801.png" alt="image-20240516202243580" style="zoom:50%;" />

<p>为实现这种行为上的同步，需要提供两种操作，等信号和发信号，且在某些情况下，可能连续发多次信号，因此可以将发送的信号数记录下来。</p>
<ul>
<li>等信号：如果信号计数&#x3D;0， 则进程等待；否则，计数减1，进程继续执行。</li>
<li>发信号：若有进程等待，则唤醒进程继续执行；否则，增加计数。</li>
</ul>
<blockquote>
<p><strong>可以类比停车场停车。</strong></p>
<p>等信号相当于车辆进入停车场，信号计数相当于空车位。</p>
<ul>
<li>信号计数为0相当于没有空车位，因此车辆需要等待（即进程等待）；</li>
<li>若信号计数不为0，则当前有空车位，车辆可以驶入（即进程执行），而空车位的数量要减1。</li>
</ul>
<p>发信号则相当于车辆离开停车场。</p>
<ul>
<li>若此时恰好有另一辆车要进入（待执行进程），那么这辆车可以直接进入（待执行进程被唤醒），空车位数不变（信号量不变）；</li>
<li>否则，空车位数加1（信号量加1）。</li>
</ul>
</blockquote>
<p>计数信号量：包含1）一个计数器，以及2）当计数为0时让进程排队等待的队列。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162035492.png" alt="image-20240516203555357" style="zoom:50%;" />

<h3 id="2、代码实现-2"><a href="#2、代码实现-2" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><p>新建<code>ipc</code>目录。</p>
<blockquote>
<p>IPC（Inter-Process Communication，进程间通信）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数信号量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">sem_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">list_t</span> wait_list;</span><br><span class="line">&#125;<span class="type">sem_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_init</span> <span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> init_count)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="9-2-发信号和等信号"><a href="#9-2-发信号和等信号" class="headerlink" title="9.2 发信号和等信号"></a>9.2 发信号和等信号</h2><ul>
<li><p>等信号：如果信号计数&#x3D;0， 则进程等待；否则，计数减1，进程继续执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 等信号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_wait</span> <span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 信号量不为0，进程可继续执行</span></span><br><span class="line">        sem-&gt;count--;  <span class="comment">// 信号量减1，表明当前进程获得一个信号</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 信号量为0，进程由就绪队列移动到等待队列</span></span><br><span class="line">        <span class="type">task_t</span> *curr =  task_current();</span><br><span class="line">        task_set_block(curr);</span><br><span class="line">        list_insert_last(&amp;sem-&gt;wait_list, &amp;curr-&gt;wait_node);</span><br><span class="line">        task_dispatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162047328.png" alt="image-20240516204721126" style="zoom: 50%;" />
</li>
<li><p>发信号：若有进程等待，则唤醒进程继续执行；否则，增加计数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 发信号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_notify</span> <span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list_count(&amp;sem-&gt;wait_list)) &#123;</span><br><span class="line">        <span class="comment">// 等待队列非空，有进程在等待执行</span></span><br><span class="line">        <span class="type">list_node_t</span> *node = list_remove_first(&amp;sem-&gt;wait_list);  <span class="comment">// 从等待队列中取第一个任务     </span></span><br><span class="line">        <span class="type">task_t</span> *task = list_node_parent(node, <span class="type">task_t</span>, wait_node);  <span class="comment">// 获取该任务对应的task_t地址</span></span><br><span class="line">        task_set_ready(task);   <span class="comment">// 设置该任务为就绪状态</span></span><br><span class="line"></span><br><span class="line">        task_dispatch();        <span class="comment">// 执行任务切换</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 等待队列为空，信号量加1</span></span><br><span class="line">        sem-&gt;count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162048307.png" alt="image-20240516204803152" style="zoom:50%;" /></li>
</ul>
<h2 id="9-3-使用计数信号量"><a href="#9-3-使用计数信号量" class="headerlink" title="9.3 使用计数信号量"></a>9.3 使用计数信号量</h2><p>实例：收到信号量打印信息。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162101361.png" alt="image-20240516210150112" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">task_t</span> sub_task;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> init_task_stack[<span class="number">1024</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_task_entry</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        sem_wait(&amp;sem);</span><br><span class="line">        log_printf(<span class="string">&quot;sub task: %d&quot;</span>, count++);</span><br><span class="line">        <span class="comment">// task_switch_from_to(&amp;sub_task, task_first_take());</span></span><br><span class="line">        <span class="comment">// sys_sched_yield();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a = 3 / 0;</span></span><br><span class="line">    <span class="comment">// irq_enable_global();</span></span><br><span class="line">    task_init(&amp;sub_task, <span class="string">&quot;sub task&quot;</span>, (<span class="type">uint32_t</span>)init_task_entry, (<span class="type">uint32_t</span>)&amp;init_task_stack[<span class="number">1024</span>]);</span><br><span class="line">    task_first_init();</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;sem, <span class="number">0</span>);  <span class="comment">// 信号量初始化（放在开中断前，以避免定时中断切换至其它任务，而此时信号量还未初始化）</span></span><br><span class="line">    irq_enable_global();  <span class="comment">// 打开全局中断</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        log_printf(<span class="string">&quot;main task: %d&quot;</span>, count++);</span><br><span class="line">        <span class="comment">// task_switch_from_to(task_first_take(), &amp;sub_task);</span></span><br><span class="line">        <span class="comment">// 修改上面这个函数，使得进程主动释放CPU的使用权，但不指定切换到哪个进程运行，实现如下</span></span><br><span class="line">        <span class="comment">// sys_sched_yield();</span></span><br><span class="line">        <span class="comment">// 注释掉上面这个函数，使得执行时间片切片运行的效果</span></span><br><span class="line">        sem_notify(&amp;sem);</span><br><span class="line">        sys_sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时和<code>8.7</code>相比就会先打印<code>main task</code>：<strong>因为此时<code>sub task</code>需要等到<code>main task</code>发信号，接收到信号时才会执行。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162110080.png" alt="image-20240516211037845"></p>
<h2 id="9-4-互斥锁及其初始化"><a href="#9-4-互斥锁及其初始化" class="headerlink" title="9.4 互斥锁及其初始化"></a>9.4 互斥锁及其初始化</h2><p>使用关闭中断的方式实现互斥，简单粗暴，容易造成中断和其它进程长时间得到运行或响应。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162120111.png" alt="image-20240516212005916" style="zoom:50%;" />

<p>类似地，可以为临界区加一把锁(互斥锁)，只有持有锁的进程才能进来，从而实现进程进入临界区的互斥。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162121845.png" alt="image-20240516212129597" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">smutex_t</span>&#123;</span> </span><br><span class="line">    <span class="type">task_t</span> *owner;      <span class="comment">// 当前持有锁的进程</span></span><br><span class="line">    <span class="type">int</span> locked_count;   <span class="comment">// 当前锁的上锁次数</span></span><br><span class="line">    <span class="type">list_t</span> wait_list;   <span class="comment">// 等待队列，存放进程</span></span><br><span class="line">&#125;<span class="type">mutex_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_init</span> <span class="params">(<span class="type">mutex_t</span> *mutex)</span>;  <span class="comment">// 互斥锁初始化</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 互斥锁初始化 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_init</span> <span class="params">(<span class="type">mutex_t</span> *mutex)</span> &#123;</span><br><span class="line">    mutex-&gt;owner = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line">    mutex-&gt;locked_count = <span class="number">0</span>;</span><br><span class="line">    list_init(&amp;mutex-&gt;wait_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-5-互斥锁的加解锁"><a href="#9-5-互斥锁的加解锁" class="headerlink" title="9.5 互斥锁的加解锁"></a>9.5 互斥锁的加解锁</h2><ul>
<li><p>上锁：如果已经上锁，则等待；否则，该进程自己上锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 上锁 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_lock</span> <span class="params">(<span class="type">mutex_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    <span class="comment">// 判断是否已上锁</span></span><br><span class="line">    <span class="keyword">if</span> (mutex-&gt;locked_count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前未上锁</span></span><br><span class="line">        mutex-&gt;locked_count++;  <span class="comment">// 上锁次数加1</span></span><br><span class="line">        mutex-&gt;owner = curr;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutex-&gt;owner == curr) &#123;</span><br><span class="line">        <span class="comment">// 若恰为本进程上锁，上锁次数加1</span></span><br><span class="line">        mutex-&gt;locked_count++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若非本进程上锁，加入等待队列</span></span><br><span class="line">        task_set_block(curr);</span><br><span class="line">        list_insert_last(&amp;mutex-&gt;wait_list, &amp;curr-&gt;wait_node);</span><br><span class="line">        task_dispatch();  <span class="comment">// 进程切换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162128904.png" alt="image-20240516212825736" style="zoom:50%;" />
</li>
<li><p>解锁：如果有进程等待，则唤醒进程继续执行；否则，直接解锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 解锁，注意只有锁的上锁者才能解锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_unlock</span> <span class="params">(<span class="type">mutex_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    <span class="keyword">if</span> (mutex-&gt;owner == curr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--mutex-&gt;locked_count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 若当前锁被上锁者解锁掉，首先释放掉这个锁</span></span><br><span class="line">            mutex-&gt;owner = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其次，若等待队列中仍然有进程等待，则等待队列中的下一个进程进行加锁操作</span></span><br><span class="line">            <span class="keyword">if</span> (list_count(&amp;mutex-&gt;wait_list)) &#123;</span><br><span class="line">                <span class="comment">// 该进程加入就绪队列</span></span><br><span class="line">                <span class="type">list_node_t</span> *node = list_remove_first(&amp;mutex-&gt;wait_list);</span><br><span class="line">                <span class="type">task_t</span> *task = list_node_parent(node, <span class="type">task_t</span>, wait_node);</span><br><span class="line">                task_set_ready(task);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重新加锁</span></span><br><span class="line">                mutex-&gt;locked_count = <span class="number">1</span>;</span><br><span class="line">                mutex-&gt;owner = task;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 任务切换</span></span><br><span class="line">                task_dispatch();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405162134988.png" alt="image-20240516213438830" style="zoom:50%;" /></li>
</ul>
<h2 id="9-6-应用互斥锁"><a href="#9-6-应用互斥锁" class="headerlink" title="9.6 应用互斥锁"></a>9.6 应用互斥锁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpu.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配一个GDT空闲表项 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gdt_alloc_desc</span><span class="params">()</span> &#123;</span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过第0项（保留使用）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; GDT_TABLE_SIZE; i++) &#123;</span><br><span class="line">        <span class="type">segment_desc_t</span> *desc = gdt_table + i;</span><br><span class="line">        <span class="keyword">if</span> (desc-&gt;attr == <span class="number">0</span>) &#123;</span><br><span class="line">            mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">return</span> i * <span class="keyword">sizeof</span>(<span class="type">gate_desc_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置中断门表项 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cpu_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    mutex_init(&amp;mutex);</span><br><span class="line">    init_gdt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 日志初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    mutex_init(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化串行接口，无需了解细节</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">1</span>, <span class="number">0x00</span>);  <span class="comment">// 关闭串行接口相关中断</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">3</span>, <span class="number">0x80</span>);  <span class="comment">// 数据发送速度</span></span><br><span class="line">    outb(COM1_PORT + <span class="number">0</span>, <span class="number">0x3</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">1</span>, <span class="number">0x00</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">3</span>, <span class="number">0x03</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">2</span>, <span class="number">0xc7</span>);</span><br><span class="line">    outb(COM1_PORT + <span class="number">4</span>, <span class="number">0x0F</span>);</span><br><span class="line">&#125;                  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数可变的打印模版函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理可变字符串</span></span><br><span class="line">    <span class="type">char</span> str_buf[<span class="number">128</span>];</span><br><span class="line">    va_list args;</span><br><span class="line"></span><br><span class="line">    kernel_memset(str_buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(str_buf));</span><br><span class="line">    va_start(args, fmt);  </span><br><span class="line">    kernel_vsprintf(str_buf, fmt, args);</span><br><span class="line">    va_end(args);  <span class="comment">// 释放args</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界资源保护</span></span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = str_buf;</span><br><span class="line">    <span class="comment">// 打印fmt相关内容</span></span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 串行接口忙检测</span></span><br><span class="line">        <span class="keyword">while</span> ((inb(COM1_PORT + <span class="number">5</span>) &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>)) == <span class="number">0</span>);        </span><br><span class="line">        outb(COM1_PORT, *p++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">    outb(COM1_PORT, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 退出临界资源保护模式</span></span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>实现效果：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405170816844.png" alt="image-20240517081626731"></p>
<p>可以看到，<code>main task</code>和<code>sub task</code>将轮流执行。</p>
<h1 id="十、虚拟内存管理和保护模式"><a href="#十、虚拟内存管理和保护模式" class="headerlink" title="十、虚拟内存管理和保护模式"></a>十、虚拟内存管理和保护模式</h1><h2 id="10-1-内存管理问题"><a href="#10-1-内存管理问题" class="headerlink" title="10.1 内存管理问题"></a>10.1 内存管理问题</h2><p>操作系统需要决定如何管理计算机中的整块内存。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405170959500.png" alt="image-20240517095902134" style="zoom: 33%;" />

<p>内存中存在多进程时，加载进程时存在一些问题：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171004646.png" alt="image-20240517100444945" style="zoom: 33%;" />

<p>为便于内存管理，<code>x86</code>的虚拟内存管理硬件将内存看做成相同大小的页。后续实际上不是按字节分配，而是按页分配的。 </p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171006887.png" alt="image-20240517100622430" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171007176.png" alt="image-20240517100745545" style="zoom: 33%;" />

<p>进程内部维护了一张表，用于实现这种进程和页之间的转换关系。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171009559.png" alt="image-20240517100935089" style="zoom: 33%;" />

<h2 id="10-2-位图数据结构与初始化"><a href="#10-2-位图数据结构与初始化" class="headerlink" title="10.2 位图数据结构与初始化"></a>10.2 位图数据结构与初始化</h2><ul>
<li><p><strong>问题：用什么样的方法管理内存页的分配与回收？</strong></p>
<ul>
<li><p>标记哪些页被使用了，哪些页没有被使用；</p>
</li>
<li><p>采用<strong>位图方式</strong>实现，如下图所示。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171011883.png" alt="image-20240517101143375" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">bitmap_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> bit_count;  <span class="comment">// 位图中的位总个数</span></span><br><span class="line">    <span class="type">uint8_t</span> *bits;  <span class="comment">// 位图字节数组</span></span><br><span class="line">&#125;<span class="type">bitmap_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools/bitmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools/klib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 计算位总个数所需字节数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_byte_count</span><span class="params">(<span class="type">int</span> bit_count)</span> &#123;</span><br><span class="line">    <span class="comment">// 考虑到6/8=0 &amp; 14/8=1这两种情况，需要进行向上取整</span></span><br><span class="line">    <span class="keyword">return</span> (bit_count + <span class="number">8</span> - <span class="number">1</span>) / <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 位图初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_init</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">uint8_t</span> *bits, <span class="type">int</span> count, <span class="type">int</span> init_bit)</span> &#123;</span><br><span class="line">    bitmap-&gt;bits = bits;</span><br><span class="line">    bitmap-&gt;bit_count = count;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bytes = bitmap_byte_count(bitmap-&gt;bit_count);</span><br><span class="line">    kernel_memset(bitmap-&gt;bits, init_bit ? <span class="number">0xFF</span> : <span class="number">0</span>, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="10-3-位图位的分配"><a href="#10-3-位图位的分配" class="headerlink" title="10.3 位图位的分配"></a>10.3 位图位的分配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取位图中某一位的状态 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_get_bit</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// index / 8                --&gt; 获取到该位处在哪个字节数组（每个字节数组是8位）</span></span><br><span class="line">    <span class="comment">// index % 8                --&gt; 获取到该位在字节数组内部对应的下标</span></span><br><span class="line">    <span class="comment">// &amp; (1 &lt;&lt; (index % 8))     --&gt; 左移下标位，并相与，即可取得该位的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 17 / 8 = 2  --&gt;  在第2个字节数组中</span></span><br><span class="line">    <span class="comment">// 17 % 8 = 1  --&gt;  第2个字节数组的第1位</span></span><br><span class="line">    <span class="keyword">return</span> bitmap-&gt;bits[index / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置位图中的某一位 </span></span><br><span class="line"><span class="comment"> * @param index 位的索引</span></span><br><span class="line"><span class="comment"> * @param count 要设置的位的总个数</span></span><br><span class="line"><span class="comment"> * @param bit   要设置的位的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_set_bit</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> index, <span class="type">int</span> count, <span class="type">int</span> bit)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; (i &lt; count) &amp;&amp; (index &lt; bitmap-&gt;bit_count); i++, index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bit) &#123;</span><br><span class="line">            <span class="comment">// 若bit为1，则进行置1</span></span><br><span class="line">            bitmap-&gt;bits[index / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，进行清0</span></span><br><span class="line">            bitmap-&gt;bits[index / <span class="number">8</span>] &amp;= (<span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 判断位图中某一位是否已设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_is_set</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bitmap_get_bit(bitmap, index) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在位图中寻找值匹配的连续N个位进行分配 </span></span><br><span class="line"><span class="comment"> * @param bit   要匹配的值</span></span><br><span class="line"><span class="comment"> * @param count 要匹配的位的总个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_alloc_nbits</span> <span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> bit, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">int</span> search_idx = <span class="number">0</span>;  <span class="comment">// 从第0位开始找</span></span><br><span class="line">    <span class="type">int</span> ok_idx = <span class="number">-1</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (search_idx &lt; bitmap-&gt;bit_count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bitmap_get_bit(bitmap, search_idx) != bit) &#123;</span><br><span class="line">            search_idx++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;  </span><br><span class="line">        <span class="comment">// 找到第一个值匹配的位</span></span><br><span class="line">        ok_idx = search_idx;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; (i &lt; count) &amp;&amp; (search_idx &lt; bitmap-&gt;bit_count); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bitmap_get_bit(bitmap, search_idx++) != bit) &#123;</span><br><span class="line">                <span class="comment">// 当前位值不匹配</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= count) &#123;</span><br><span class="line">            <span class="comment">// 找到了符合条件的多个位</span></span><br><span class="line">            bitmap_set_bit(bitmap, ok_idx, count, ~bit);  <span class="comment">// bit取反</span></span><br><span class="line">            <span class="keyword">return</span> ok_idx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-4-创建地址分配结构"><a href="#10-4-创建地址分配结构" class="headerlink" title="10.4 创建地址分配结构"></a>10.4 创建地址分配结构</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171101073.png" alt="image-20240517110120785" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">addr_alloc_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> start;         <span class="comment">// 位图的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> size;          <span class="comment">// 分配的存储空间[位图]的大小</span></span><br><span class="line">    <span class="type">uint32_t</span> page_size;     <span class="comment">// 内存块大小（内存以页的方式分配，因此又称页大小）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bitmap_t</span> bitmap;    </span><br><span class="line"></span><br><span class="line">    <span class="type">mutex_t</span> mutex;          <span class="comment">// 内存分配时的互斥操作</span></span><br><span class="line">&#125;<span class="type">addr_alloc_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 地址分配器初始化</span></span><br><span class="line"><span class="comment"> * @param bits      位图的字节缓冲区</span></span><br><span class="line"><span class="comment"> * @param start     管理内存的起始地址</span></span><br><span class="line"><span class="comment"> * @param size      管理内存的大小</span></span><br><span class="line"><span class="comment"> * @param page_size 内存块大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">addr_alloc_init</span> <span class="params">(<span class="type">addr_alloc_t</span> *alloc, <span class="type">uint8_t</span> *bits,</span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> start, <span class="type">uint32_t</span> size, <span class="type">uint32_t</span> page_size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 内存分配，从位图中获取相应的位并分配，将对应的位由0-&gt;1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">addr_alloc_page</span> <span class="params">(<span class="type">addr_alloc_t</span> *alloc, <span class="type">int</span> page_count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 内存释放</span></span><br><span class="line"><span class="comment"> * @param addr 释放的内存块的起始地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">addr_free_page</span> <span class="params">(<span class="type">addr_alloc_t</span> *alloc, <span class="type">uint32_t</span> addr, <span class="type">int</span> page_count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 内存初始化 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_init</span> <span class="params">(<span class="type">boot_info_t</span> *boot_info)</span> &#123;</span><br><span class="line">    <span class="type">addr_alloc_t</span> addr_alloc;</span><br><span class="line">    <span class="type">uint8_t</span> bits[<span class="number">9</span>];  <span class="comment">// 支持最多64个内存页的分配和释放</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4096:1KB  0x1000:4KB</span></span><br><span class="line">    addr_alloc_init(&amp;addr_alloc, bits, <span class="number">0x1000</span>, <span class="number">64</span>*<span class="number">4096</span>, <span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> addr = addr_alloc_page(&amp;addr_alloc, <span class="number">2</span>);</span><br><span class="line">        log_printf(<span class="string">&quot;alloc addr: 0x%x&quot;</span>, addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> addr = <span class="number">0x1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> addr = addr_free_page(&amp;addr_alloc, addr, <span class="number">2</span>);</span><br><span class="line">        addr += <span class="number">8192</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171448019.png" alt="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171448019.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addr_alloc_init(&amp;addr_alloc, bits, <span class="number">0x1000</span>, <span class="number">64</span>*<span class="number">4096</span>, <span class="number">4096</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> addr = addr_alloc_page(&amp;addr_alloc, <span class="number">2</span>);  <span class="comment">// 单步调试此处后，00处的[00]-&gt;[03]</span></span><br><span class="line">    log_printf(<span class="string">&quot;alloc addr: 0x%x&quot;</span>, addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240517145000377.png" alt="image-20240517145000377"></p>
<p>64个内存块分配完毕后：</p>
<p><img src="C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240517144742533.png" alt="image-20240517144742533"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171451064.png" alt="image-20240517145140955"></p>
<p>接下来对这64个内存块进行释放：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171451285.png" alt="image-20240517145130117"></p>
<h2 id="10-5-规划内存空间的分配"><a href="#10-5-规划内存空间的分配" class="headerlink" title="10.5 规划内存空间的分配"></a>10.5 规划内存空间的分配</h2><p>系统内存分两大块：</p>
<ul>
<li><code>1M以内</code>给<strong>操作系统</strong>使用；</li>
<li><code>1M以上</code>给<strong>进程</strong>使用。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171455366.png" alt="image-20240517145539043"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">show_mem_info</span><span class="params">(<span class="type">boot_info_t</span> *boot_info)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;mem region: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boot_info-&gt;ram_region_count; i++) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;[%d]: 0x%x - 0x%x&quot;</span>, i,</span><br><span class="line">            boot_info-&gt;ram_region_cfg[i].start,</span><br><span class="line">            boot_info-&gt;ram_region_cfg[i].size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">total_mem_size</span> <span class="params">(<span class="type">boot_info_t</span> *boot_info)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> mem_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boot_info-&gt;ram_region_count; i++) &#123;</span><br><span class="line">        mem_size += boot_info-&gt;ram_region_cfg[i].size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mem_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 内存初始化 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_init</span> <span class="params">(<span class="type">boot_info_t</span> *boot_info)</span> &#123;</span><br><span class="line">    <span class="comment">// 1MB内存空间起始，在链接脚本中定义</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> *mem_free_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印内存初始信息</span></span><br><span class="line">    log_printf(<span class="string">&quot;mem init&quot;</span>);</span><br><span class="line">    show_mem_info(boot_info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位图缓存的起始地址</span></span><br><span class="line">    <span class="type">uint8_t</span> *mem_free = (<span class="type">uint8_t</span> *)&amp;mem_free_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算1MB以上空间的空闲内存容量，并对齐页边界</span></span><br><span class="line">    <span class="type">uint32_t</span> mem_up1MB_free = total_mem_size(boot_info) - MEM_EXT_START;</span><br><span class="line">    mem_up1MB_free = down2(mem_up1MB_free, MEM_PAGE_SIZE);</span><br><span class="line">    log_printf(<span class="string">&quot;free memory: 0x%x, size: 0x%x&quot;</span>, MEM_EXT_START, mem_up1MB_free);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用地址分配机构对得到的内存进行管理</span></span><br><span class="line">    addr_alloc_init(&amp;paddr_alloc, mem_free, MEM_EXT_START, mem_up1MB_free, MEM_PAGE_SIZE);</span><br><span class="line">    mem_free += bitmap_byte_count(paddr_alloc.size / MEM_PAGE_SIZE);  <span class="comment">// 跳过位图缓存这一块内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，mem_free应该比EBDA地址要小</span></span><br><span class="line">    ASSERT(mem_free &lt; (<span class="type">uint8_t</span> *)MEM_EBDA_START);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>kernel.lds</code>中，取出位图缓存这一部分的起始地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x10000;</span><br><span class="line"></span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text)</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		*(.rodata)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.data : &#123;</span><br><span class="line">		*(.data)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.bss : &#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROVIDE(mem_free_start = . );     &lt;--  这一行就可以取取出.bss之后的内存起始地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存初始信息获取：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171531929.png" alt="image-20240517153147728"></p>
<p>位图缓存的起始地址：</p>
<blockquote>
<p> 0x000129c0 + 0x4f10 &#x3D; 0x17830</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171535529.png" alt="image-20240517153526379"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171534282.png" alt="image-20240517153424161"></p>
<p><code>1MB</code>以上空间的空闲内存容量（对齐页边界）：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171532892.png" alt="image-20240517153243765"></p>
<p>两个技巧函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 ** n</span></span><br><span class="line"><span class="comment">// size = 0x1010  bound = 0x1000(4KB)</span></span><br><span class="line"><span class="comment">// size &amp; ~(bound - 1) </span></span><br><span class="line"><span class="comment">//  = 0x1010 &amp; ~(0x0FFF) </span></span><br><span class="line"><span class="comment">//  = 0x1010 &amp; 0xFFFFF000    [0x0FFF在取反时会补足为32位]</span></span><br><span class="line"><span class="comment">//  = 0x1000</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">down2</span> <span class="params">(<span class="type">uint32_t</span> size, <span class="type">uint32_t</span> bound)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size &amp; ~(bound - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保留0x1010中最后的两位[10]，使其得到0x2000</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">up2</span> <span class="params">(<span class="type">uint32_t</span> size, <span class="type">uint32_t</span> bound)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (size + bound - <span class="number">1</span>) &amp; ~(bound - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-6-内存分页机制"><a href="#10-6-内存分页机制" class="headerlink" title="10.6 内存分页机制"></a>10.6 内存分页机制</h2><h3 id="1、分页机制理论基础"><a href="#1、分页机制理论基础" class="headerlink" title="1、分页机制理论基础"></a>1、分页机制理论基础</h3><p>对进程而言，它看到的是多段连续的内存空间；而实际上，其可能由不同的内存页组合而成。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171545775.png" alt="image-20240517154528056" style="zoom:50%;" />

<p>在访问特定的内存地址时，虚拟存储管理部件会自动地根据转换表将其转换到物理内存中的特定位置。</p>
<blockquote>
<p>也就是说，对于一个进程来说，它掌握的是属于自己的这套“线性地址”（逻辑地址），而实际上的内存是分布在对应的“物理地址”中。当该进程想访问自己的地址上编号为“0x1000”处的内容时，会经过一个转换表，将其映射到物理地址上的“0x20000”处。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171548139.png" alt="image-20240517154849803" style="zoom:50%;" />



<p>最简单的实现方法是使用一级转换表，表中存储了进程看到的内存页对应的实际物理内存页的起始地址转换关系。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171630549.png" alt="image-20240517163012208" style="zoom:50%;" />

<blockquote>
<p>在32位地址空间中，总共可以表示<code>2^32</code>个地址，即<code>4GB</code>的内存空间。**<code>4GB</code>的地址空间需要的页表大小是<code>4MB</code>**，分析如下：</p>
<ul>
<li><strong>32位地址空间的表示</strong></li>
</ul>
<ol>
<li>32位地址：一个<code>32</code>位的地址可以表示从 <code>0x00000000</code> 到 <code>0xFFFFFFFF</code>，即<code>2^32</code>个地址。</li>
<li>4GB内存：由于<code>2^32 = 4 * 2^30</code>，这就等于<code>4GB</code>的内存空间。</li>
</ol>
<ul>
<li><strong>分页机制</strong></li>
</ul>
<p>在分页机制中，内存被划分成固定大小的页。常见的页大小是<code>4KB</code>（<code>4096</code>字节）。<code>32</code>位地址分成两部分：页目录和页内偏移。</p>
<ul>
<li><strong>页表的结构</strong></li>
</ul>
<ol>
<li>页大小：<code>4KB = 2^12</code>字节。这意味着地址的低<code>12</code>位用于页内偏移。</li>
<li>页数：剩下的<code>20</code>位（32位 - 12位）用于表示页的索引。</li>
</ol>
<ul>
<li><strong>页表计算</strong></li>
</ul>
<ol>
<li>每个页表条目（PTE, Page Table Entry）通常占<code>4</code>字节（32位）</li>
<li>一个页表可以包含<code>2^10 = 1024</code>个条目（因为页大小为4KB，4KB &#x2F; 4Byte &#x3D; 1024条目）。</li>
</ol>
<ul>
<li><strong>一级页表大小</strong>：要映射整个4GB的内存空间，需要多少页表条目和页表呢？</li>
</ul>
<ol>
<li><p>页的数量：需要映射<code>4GB / 4KB = 2^20</code>个页。</p>
</li>
<li><p>页表的数量：</p>
</li>
</ol>
<ul>
<li>每个页表可以包含<code>1024</code>个页表条目（每个条目映射一个4KB的页）。</li>
<li>因此，需要的页表数量为<code>2^20(pages) / 1024(entries) = 1024(tables)</code>个。</li>
</ul>
<ol start="3">
<li>每个页表的大小：</li>
</ol>
<ul>
<li>每个页表有1024个条目，每个条目4字节：<code>1024(entries) * 4(bytes/entry) = 4KB</code>大小。</li>
</ul>
<ol start="4">
<li>总页表大小：</li>
</ol>
<ul>
<li><p>因此，1024个页表，每个4KB，总的页表空间需求为：</p>
<p><code>1024(tables) * 4KB(per table) = 4MB</code>。</p>
</li>
</ul>
<ul>
<li><strong>结论</strong>：为了存储4GB的内存地址空间所需的一级页表大小为 <strong>4MB</strong>。这包括了1024个页表，每个页表4KB。</li>
</ul>
</blockquote>
<p>因此，经过上述计算可以得知，一级转换表占用的4MB空间太大了，所以使用二级转换表。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171650837.png" alt="image-20240517165038676"></p>
<ul>
<li>第1级处理<code>4MB</code>的内存页的地址映射；</li>
<li>第2级处理<code>4KB</code>的内存页的地址映射。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171655736.png" alt="image-20240517165538461" style="zoom:50%;" />

<ul>
<li><strong>最高的10位</strong>保存对二级页表的索引；</li>
<li><strong>中间的10位</strong>保存相应物理内存页的起始地址；</li>
<li><strong>最低的12位</strong>指明在物理地址中的偏移。</li>
</ul>
<h3 id="2、在loader中开启分页机制"><a href="#2、在loader中开启分页机制" class="headerlink" title="2、在loader中开启分页机制"></a>2、在loader中开启分页机制</h3><p>接下来以一级页表为例进行测试，实现分页机制的打开：</p>
<p>直接进行<code>4MB</code>内存页的转换，以节省页表空间。<em>（注意采用该方式时需要打开<code>CR4</code>寄存器中的<code>PSE</code>位）</em></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171703932.png" alt="image-20240517170308820" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171736358.png" alt="image-20240517173645182" style="zoom: 80%;" />

<p>由于虚拟存储的分页机制存在，操作系统和进程不需要过多考虑实际物理内存的有效地址范围。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171717275.png" alt="image-20240517171749065" style="zoom:50%;" />

<p>在<code>loader</code>中开始分页机制时，需要保持<code>loader</code>中线性地址和物理地址相同，才能保证<code>loader</code>正常运行。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171718785.png" alt="image-20240517171857619" style="zoom:50%;" />

<p>具体涉及到<code>CR3</code>寄存，并将设计的表结构信息传给<code>CR3</code>寄存器。</p>
<ul>
<li>低12位无效。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171722017.png" alt="image-20240517172220845" style="zoom:80%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpu_instr.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取cr3</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">read_cr3</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> cr0;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %%cr3, %[v]&quot;</span>:[v]<span class="string">&quot;=r&quot;</span>(cr0));</span><br><span class="line">    <span class="keyword">return</span> cr0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入cr3</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">write_cr3</span> <span class="params">(<span class="type">uint32_t</span> v)</span> &#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %[v], %%cr3&quot;</span>::[v]<span class="string">&quot;r&quot;</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取cr4</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">read_cr4</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> cr0;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %%cr4, %[v]&quot;</span>:[v]<span class="string">&quot;=r&quot;</span>(cr0));</span><br><span class="line">    <span class="keyword">return</span> cr0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入cr4</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">write_cr4</span> <span class="params">(<span class="type">uint32_t</span> v)</span> &#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %[v], %%cr4&quot;</span>::[v]<span class="string">&quot;r&quot;</span>(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loader.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打开分页机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enable_page_mode</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 页目录表，共1024项，且需对齐到4KB处</span></span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> page_dir[<span class="number">1024</span>] __attribute__((aligned(<span class="number">4096</span>))) = &#123;</span><br><span class="line">        [<span class="number">0</span>] = PDE_P | PDE_W | PDE_PS</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	声明并初始化了一个对齐到4KB边界的页目录表，</span></span><br><span class="line"><span class="comment">        	并设置了第一个页目录项，指向一个4MB的大页，以便实现简单的分页机制。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置CR4 &amp; CR3寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> cr4 = read_cr4(); </span><br><span class="line">    write_cr4(cr4 | CR4_PSE);</span><br><span class="line">    write_cr3((<span class="type">uint32_t</span>)page_dir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置CR0的最高位开启分页机制</span></span><br><span class="line">    write_cr0(read_cr0() | CR0_PG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加载内核</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">load_kernel</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    enable_page_mode();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行调试，可以发现只有第<code>0</code>项当前被设置了。也就是说<code>0-4MB</code>范围的线性地址已经设置好了一个表项，映射到物理地址上的<code>0-4MB</code>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171741544.png" alt="image-20240517174108363" style="zoom:80%;" />

<h2 id="10-7-创建内核页表"><a href="#10-7-创建内核页表" class="headerlink" title="10.7 创建内核页表"></a>10.7 创建内核页表</h2><h3 id="1、代码实现"><a href="#1、代码实现" class="headerlink" title="1、代码实现"></a>1、代码实现</h3><p>分页机制除了能实现地址转换外，还可以实现对内存页的保护。借助这种保护机制，可以实现对操作系统的代码和数据进行保护。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171805215.png" alt="image-20240517180548963" style="zoom:50%;" />



<p>第一级页表的每个表项指向一个二级表，而二级页表的每个表项指向一个真实的物理页。</p>
<ul>
<li><p>二级页表中的第一级页表：</p>
<ul>
<li>注意第<code>1</code>位和第<code>2</code>位。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171807804.png" alt="image-20240517180726661" style="zoom:80%;" />
</li>
<li><p>二级页表中的第二级页表：</p>
<ul>
<li>同样注意第<code>1</code>位和第<code>2</code>位。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171807062.png" alt="image-20240517180747902" style="zoom:80%;" /></li>
</ul>
<p>以下区域设置为可读：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text : &#123;</span><br><span class="line">	*(.text)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">.rodata : &#123;</span><br><span class="line">	*(.rodata)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下区域设置为可读写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.data : &#123;</span><br><span class="line">	*(.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.bss : &#123;</span><br><span class="line">	*(.bss)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROVIDE(mem_free_start = . ); </span><br></pre></td></tr></table></figure>



<ul>
<li><strong>最高的10位</strong>保存对二级页表的索引，获取<code>Page Directory</code>中的对应表项；</li>
<li><strong>中间的10位</strong>保存相应物理内存页的起始地址；</li>
<li><strong>最低的12位</strong>指明在物理地址中的偏移。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171650837.png" alt="image-20240517165038676"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建内核页表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_kernel_table</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> s_text[], e_text[], s_data[];</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> kernel_base[];</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">        &#123;kernel_base, s_text, kernel_base, PTE_W&#125;,</span><br><span class="line">        &#123;s_text, e_text, s_text, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;s_data, (<span class="type">void</span> *)MEM_EBDA_START, s_data, PTE_W&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历kernel_map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(kernel_map) / <span class="keyword">sizeof</span>(<span class="type">memory_map_t</span>); i++) &#123;</span><br><span class="line">        <span class="type">memory_map_t</span> *<span class="built_in">map</span> = kernel_map + i;  <span class="comment">// 取出表项</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将map中的虚拟地址和物理地址进行4KB页边界对齐</span></span><br><span class="line">        <span class="type">uint32_t</span> vstart = down2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vstart, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">uint32_t</span> vend = up2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vend, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">uint32_t</span> pstart = down2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;pstart, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算这块虚拟空间包含的页的个数</span></span><br><span class="line">        <span class="type">int</span> page_count = (vend - vstart) / MEM_PAGE_SIZE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 建立vstart和pstart的映射</span></span><br><span class="line">        memory_create_map(kernel_page_dir, vstart, (<span class="type">uint32_t</span>)pstart, page_count, <span class="built_in">map</span>-&gt;perm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在page_dir中寻找vaddr对应的页表项/PTE</span></span><br><span class="line"><span class="comment"> * @param alloc 若PTE对应的Page Table不存在，是否需要进行分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pte_t</span> *<span class="title function_">find_pte</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取pde表项</span></span><br><span class="line">    <span class="type">pde_t</span> *pde = page_dir + pde_index(vaddr);  </span><br><span class="line">    <span class="type">pte_t</span> *page_table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断pde对应的Page Table是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (pde-&gt;present) &#123;</span><br><span class="line">        <span class="comment">// 若存在，直接获取page_table的物理地址</span></span><br><span class="line">        page_table = (<span class="type">pte_t</span> *)pde_paddr(pde);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，判断是否需要进行分配</span></span><br><span class="line">        <span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">pte_t</span> *)<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从物理页中分配一页内存</span></span><br><span class="line">        <span class="type">uint32_t</span> pg_paddr = addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pg_paddr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">pte_t</span> *)<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对新分配的表进行清空，以防止脏数据并保证安全性</span></span><br><span class="line">        page_table = (<span class="type">pte_t</span> *)pg_paddr;</span><br><span class="line">        kernel_memset(page_table, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        pde-&gt;v = pg_paddr | PDE_P | PDE_W | PDE_U;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page_table + pte_index(vaddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 建立虚拟地址和物理地址间的映射</span></span><br><span class="line"><span class="comment"> * @param page_dir  要建立映射的页表 </span></span><br><span class="line"><span class="comment"> * @param vaddr     虚拟空间起始地址 </span></span><br><span class="line"><span class="comment"> * @param paddr     物理空间起始地址</span></span><br><span class="line"><span class="comment"> * @param count     虚拟空间中包含的页个数 </span></span><br><span class="line"><span class="comment"> * @param perm      相关属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memory_create_map</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">uint32_t</span> paddr, <span class="type">int</span> count, <span class="type">uint32_t</span> perm)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历每一个页表项，建立其对应的映射关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;create map: v-0x%x p-0x%x, perm: 0x%x&quot;</span>, vaddr, paddr, perm);</span><br><span class="line"></span><br><span class="line">        <span class="type">pte_t</span> * pte = find_pte(page_dir, vaddr, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pte == (<span class="type">pte_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;create pte failed. pte == 0&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;             </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建映射的时候，这条pte应当是不存在的。</span></span><br><span class="line">        <span class="comment">// 如果存在，说明可能有问题</span></span><br><span class="line">        log_printf(<span class="string">&quot;\tpte addr: 0x%x&quot;</span>, (<span class="type">uint32_t</span>)pte);</span><br><span class="line">        <span class="comment">// 找到了对应的页表项/PTE</span></span><br><span class="line">        ASSERT(pte-&gt;present == <span class="number">0</span>);  <span class="comment">// 此时的present位应为0</span></span><br><span class="line">        pte-&gt;v = paddr | perm | PTE_P;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到下一个地址</span></span><br><span class="line">        vaddr += MEM_PAGE_SIZE;</span><br><span class="line">        paddr += MEM_PAGE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *<span class="title function_">find_pte</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    page_table = (<span class="type">pte_t</span> *)pg_paddr;</span><br><span class="line">    kernel_memset(page_table, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么要初始化?</li>
</ul>
<ol>
<li><strong>防止脏数据</strong>: 分配新的页表页后，该页表页中的内容可能包含先前分配但未清除的数据。初始化页表页（即清零）确保所有 PTE（页表项）都是空的，没有设置任何标志位或地址。</li>
<li><strong>安全性</strong>: 避免访问到未初始化的内存，防止潜在的安全漏洞。例如，未初始化的 PTE 可能指向随机地址，这会导致页错误或者其他意外行为。</li>
<li><strong>正确性</strong>: 页表页中的每个 PTE 都需要按照预期进行初始化。初始化保证了新分配的页表页在开始时不包含任何有效的映射，只有在后续显式设置时才包含有效映射。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182044761.png" alt="image-20240518204404435"></p>
<h3 id="2、代码调试"><a href="#2、代码调试" class="headerlink" title="2、代码调试"></a>2、代码调试</h3><p>在<code>qemu</code>中执行<code>info mem</code>为空，正确的话应该打印开启分页机制后的虚拟地址与物理地址的映射。此时为空说明分页机制已被打开，但所有的页表全为无效。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182052909.png" alt="image-20240518205244786"></p>
<p>原因分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在page_dir中寻找vaddr对应的页表项/PTE</span></span><br><span class="line"><span class="comment"> * @param alloc 若PTE对应的Page Table不存在，是否需要进行分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pte_t</span> *<span class="title function_">find_pte</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    	...</span><br><span class="line">        <span class="comment">// 对新分配的表进行清空，以防止脏数据并保证安全性</span></span><br><span class="line">        page_table = (<span class="type">pte_t</span> *)pg_paddr;</span><br><span class="line">        kernel_memset(page_table, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br><span class="line">    	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是对新分配的表进行清空，并没有建立pde表项，并没有建立<code>pde</code>与<code>page_table</code>之间的关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pde-&gt;v = pg_paddr | PDE_P;</span><br></pre></td></tr></table></figure>

<p>加上这一行后重新调试，发现最后两项存在问题。虚拟地址相同，但物理地址并没有实现页边界对齐。</p>
<p>因此需要对物理地址也进行页边界对齐。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182058011.png" alt="image-20240518205852888"></p>
<p>在以下函数中进行修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建内核页表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_kernel_table</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> s_text[], e_text[], s_data[];</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> kernel_base[];</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">        &#123;kernel_base, s_text, kernel_base, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;s_text, e_text, s_text, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;s_data, (<span class="type">void</span> *)MEM_EBDA_START, s_data, <span class="number">0</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历kernel_map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(kernel_map) / <span class="keyword">sizeof</span>(<span class="type">memory_map_t</span>); i++) &#123;</span><br><span class="line">        <span class="type">memory_map_t</span> *<span class="built_in">map</span> = kernel_map + i;  <span class="comment">// 取出表项</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将map中的虚拟地址和物理地址进行4KB页边界对齐</span></span><br><span class="line">        <span class="type">uint32_t</span> vstart = down2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vstart, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">uint32_t</span> vend = up2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vend, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">uint32_t</span> pstart = down2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;pstart, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算这块虚拟空间包含的页的个数</span></span><br><span class="line">        <span class="type">int</span> page_count = (vend - vstart) / MEM_PAGE_SIZE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 建立vstart和pstart的映射</span></span><br><span class="line">        <span class="comment">// memory_create_map(kernel_page_dir, vstart, (uint32_t)map-&gt;pstart, page_count, map-&gt;perm);</span></span><br><span class="line">        memory_create_map(kernel_page_dir, vstart, (<span class="type">uint32_t</span>)pstart, page_count, <span class="built_in">map</span>-&gt;perm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后出现以下结果，发现最后错误地出现了两个相同的项，导致在<code>memory_create_map()</code>中判断<code>ASSERT(pte-&gt;present == 0);</code> 时出错。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182102316.png" alt="image-20240518210246033"></p>
<p>经排查，这个错误和链接脚本的设置有关。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	PROVIDE(kernel_base = .);</span><br><span class="line">    . = <span class="number">0x10000</span>;</span><br><span class="line"></span><br><span class="line">	PROVIDE(s_text = .); </span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text)</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		*(.rodata)</span><br><span class="line">	&#125;</span><br><span class="line">	PROVIDE(e_text = .); </span><br><span class="line"></span><br><span class="line">	PROVIDE(s_data = .);   &lt;==== .data未页边界对齐</span><br><span class="line">	.data : &#123;</span><br><span class="line">		*(.data)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.bss : &#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROVIDE(mem_free_start = . ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在<code>kernel_elf.txt</code>文件中，<code>.data section</code>的起始地址并非是页边界对齐（<code>4KB</code>）的，因此会在后续产生页表项重复的情况。</p>
<p>详细来说，<code>.data</code>段的起始地址未对齐到页边界，会导致两个问题：</p>
<ol>
<li><strong>页表项重复</strong>： 当页表项映射未对齐的数据段时，一个页表项可能会覆盖两个不同的物理页。这会导致映射冲突，页表项出现重复或无效。</li>
<li><strong>访问异常</strong>： 未对齐的数据段会引起内存访问异常，因为在一个页中可能包含多个段的数据，导致不同的页表项映射到同一物理地址。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182107831.png" alt="image-20240518210723714"></p>
<p>因此，对链接脚本修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">. = ALIGN(<span class="number">4096</span>);   &lt;==== 加入这一行</span><br><span class="line">PROVIDE(s_data = .); </span><br><span class="line">.data : &#123;</span><br><span class="line">	*(.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时重新编译后，<code>.data section</code>的起始地址如下：<br><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182124084.png" alt="image-20240518212455979"></p>
<p>经过上述修改，<code>info mem</code>就有输出了：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182125920.png" alt="image-20240518212541791"></p>
<h3 id="3、权限设置"><a href="#3、权限设置" class="headerlink" title="3、权限设置"></a>3、权限设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">    &#123;kernel_base, s_text, kernel_base, PTE_W&#125;,</span><br><span class="line">    &#123;s_text, e_text, s_text, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;s_data, (<span class="type">void</span> *)MEM_EBDA_START, s_data, PTE_W&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码为操作系统访问的代码，因此第<code>2</code>位权限位设置为<code>0</code>，即<code>supervisor</code>；</p>
</li>
<li><p>此外，还要设置第<code>3</code>位，确定是只读还是可读写。由于采用的结构是二级表，因此每个表都有针对自己这个表的权限设置。对于<code>PTE</code>表项来说，在上述代码中设置<code>PTE_W</code>即可确定可读写；而对于<code>PDE</code>表项来说，在此处（<code>find_pte()</code>中）设置可读写以及用户可访问：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pde-&gt;v = pg_paddr | PDE_P | PDE_W | PDE_U;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>设置完权限后，<code>info mem</code>的信息更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182149317.png" alt="image-20240518214839313"></p>
<h2 id="10-8-为进程创建页表"><a href="#10-8-为进程创建页表" class="headerlink" title="10.8 为进程创建页表"></a>10.8 为进程创建页表</h2><h3 id="1、问题说明"><a href="#1、问题说明" class="headerlink" title="1、问题说明"></a>1、问题说明</h3><p>此时这个程序存在下列问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init.c </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    task_init(&amp;sub_task, <span class="string">&quot;sub task&quot;</span>, (<span class="type">uint32_t</span>)init_task_entry, (<span class="type">uint32_t</span>)&amp;init_task_stack[<span class="number">1024</span>]);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行到第<code>3</code>行的代码时，CPU会重启。进入这一行代码的内部进行调试，可以发现问题出在切换<code>TSS</code>的时刻。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Task Switch </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_switch_from_to</span> <span class="params">(<span class="type">task_t</span> *from, <span class="type">task_t</span> *to)</span> &#123;</span><br><span class="line">    switch_to_tss(to-&gt;tss_sel);</span><br><span class="line">    <span class="comment">// simple_switch(&amp;from-&gt;stack, to-&gt;stack);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远跳转</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">far_jump</span> <span class="params">(<span class="type">uint32_t</span> selector, <span class="type">uint32_t</span> offset)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> addr[] = &#123;offset, selector&#125;;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;ljmpl *(%[a])&quot;</span>::[a]<span class="string">&quot;r&quot;</span>(addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为每个进程的TSS结构中均有一个<code>CR3</code>字段，以允许每个进程拥有自己的页表。进程会从这个<code>CR3</code>字段中取出页表的起始地址并加载到实际的<code>CR3</code>寄存器中，也就是说切换到进程实际的页表。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182200116.png" alt="image-20240518220044967" style="zoom:80%;" />

<p>此外，需要借助保护机制来实现对操作系统的代码和数据的保护。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182202640.png" alt="image-20240518220254434" style="zoom:50%;" />

<p>两个进程运行起来之后，会共享<code>0x00000000~0x80000000</code>这部分的空间，也即操作系统代码。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405182208681.png" alt="image-20240518220857411" style="zoom:50%;" />



<h3 id="2、代码实现-3"><a href="#2、代码实现-3" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpu.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放GDT表项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gdt_free_sel</span><span class="params">(<span class="type">int</span> sel)</span> &#123;</span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    gdt_table[sel/<span class="keyword">sizeof</span>(<span class="type">segment_desc_t</span>)].attr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建进程自己的页表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">memory_create_uvm</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 分配一页内存给Page Directory</span></span><br><span class="line">    <span class="type">pde_t</span> *page_dir = (<span class="type">pde_t</span> *)addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (page_dir == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对第一级页表进行清空</span></span><br><span class="line">    <span class="comment">// 不需要对第二级页表进行清空是因为loader_32.c中执行了清零操作</span></span><br><span class="line">    kernel_memset((<span class="type">void</span> *)page_dir, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户进程PDE的开始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> user_pde_start = pde_index(MEM_TASK_BASE);</span><br><span class="line">    <span class="comment">// 为了实现多个进程间共享操作进程代码，遍历从低1MB空间的所有页表（操作系统部分）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; user_pde_start; i++) &#123;</span><br><span class="line">        <span class="comment">// 由于多个进程间操作系统部分的映射关系是一致的，如果要为这一部分的每一项都分配一个PTE页表，会造成内存浪费</span></span><br><span class="line">        <span class="comment">// 因此此处直接使用操作系统在0x0-0x7FFFFFFF的空间内配置的PTE表即可，即实现了多个进程间的映射共享</span></span><br><span class="line">        page_dir[i].v = kernel_page_dir[i].v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)page_dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>此时进行调试，会在<code>memory_create_uvm()</code>的这一步出错：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel_memset((<span class="type">void</span> *)page_dir, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br></pre></td></tr></table></figure>

<p>通过查看此时<code>QEMU</code>的内存映射关系可以得知，此时仅配置了<code>1MB</code>以下的内存关系的映射，而没有配置<code>1MB</code>以上的内存关系映射，但分配的<code>page_dir</code>的地址为<code>0x101000</code>，也就是说<code>QEMU</code>不知道该写到哪里。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191451190.png" alt="image-20240519145138077"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191451670.png" alt="image-20240519145108455"></p>
<p>因此需要对物理地址<code>0x101000</code>也进行一个映射，以获取其线性地址。</p>
<p>因此，对<code>kernel_map[]</code>进行改写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_EXT_START       (1024 * 1024)           <span class="comment">// 扩展内存的起始地址，从1MB（实模式内存限制）开始</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_EXT_END         (128 * 1024 * 1024)     <span class="comment">// 扩展内存的结束地址，目前只给QEMU分配了128M内存</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.c </span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">    &#123;kernel_base, s_text, kernel_base, PTE_W&#125;,</span><br><span class="line">    &#123;s_text, e_text, s_text, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;s_data, (<span class="type">void</span> *)MEM_EBDA_START, s_data, PTE_W&#125;,</span><br><span class="line">    &#123;(<span class="type">void</span> *)MEM_EXT_START, (<span class="type">void</span> *)MEM_EXT_END, (<span class="type">void</span> *)MEM_EXT_START, PTE_W&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="十一、隔离操作系统与进程"><a href="#十一、隔离操作系统与进程" class="headerlink" title="十一、隔离操作系统与进程"></a>十一、隔离操作系统与进程</h1><h2 id="11-1-隔离操作系统与进程"><a href="#11-1-隔离操作系统与进程" class="headerlink" title="11.1 隔离操作系统与进程"></a>11.1 隔离操作系统与进程</h2><p>目前所以进程（共3个）的代码和数据全部位于操作系统中，可以适当进行分离。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191512628.png" alt="image-20240519151246404" style="zoom:50%;" />

<p>主要实现以下三步：</p>
<blockquote>
<ol>
<li>建立进程的运行空间；</li>
<li>代码拷贝至指定区域；</li>
<li>从操作系统跳转至进程运行。</li>
</ol>
</blockquote>
<h3 id="1、代码分离"><a href="#1、代码分离" class="headerlink" title="1、代码分离"></a>1、代码分离</h3><blockquote>
<p><strong>实现方式：</strong>只需要单独新建一个文件把代码放进去，就可以实现代码分离。</p>
</blockquote>
<p>（1）首先，删除前序测试使用的<code>sub_task()</code>，并且为<code>first_task()</code>新建一个单独的<code>.c</code>文件，使得其在编译时在<code>/kernel</code>中得到一个单独的文件，而不是在<code>init.c</code>中一起编译。这样在后续进行代码拷贝时就会方便很多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first_task.c</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;core/task.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;first task.&quot;</span>);</span><br><span class="line">        sys_sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// first_task_entry.S</span><br><span class="line"></span><br><span class="line">	.text</span><br><span class="line">	.global first_task_entry</span><br><span class="line">	.extern first_task_main</span><br><span class="line">first_task_entry:</span><br><span class="line">    // 进程运行前，操作系统会为其初始化SS寄存器和CS寄存器</span><br><span class="line">	mov %ss, %ax</span><br><span class="line">	mov %ax, %ds</span><br><span class="line">	mov %ax, %es</span><br><span class="line">	mov %ax, %fs</span><br><span class="line">	mov %ax, %gs</span><br><span class="line">    // 跳转至32位的C环境运行</span><br><span class="line">	jmp first_task_main</span><br></pre></td></tr></table></figure>

<p>（2）更新<code>kernel/CMakeLists.txt</code>文件，在末尾加上<code>*.S</code>，从而完成对<code>first_task_entry.S</code>的编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB_RECURSE C_LIST &quot;*.c&quot; &quot;*.h&quot; &quot;*.S&quot;)</span><br></pre></td></tr></table></figure>

<p>（3）更新<code>first_task</code>的页表为自己的页表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置好first_task执行的入口函数，并修改对应的task_init中的entry参数为first_start</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">first_task_entry</span> <span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 声明入口函数</span></span><br><span class="line">    <span class="type">uint32_t</span> first_start = (<span class="type">uint32_t</span>)first_task_entry;  <span class="comment">// 获取入口函数地址</span></span><br><span class="line"></span><br><span class="line">    task_init(&amp;task_manager.first_task, <span class="string">&quot;first task&quot;</span>, first_start, <span class="number">0</span>);  <span class="comment">// Task Initialization</span></span><br><span class="line">    write_tr(task_manager.first_task.tss_sel);  <span class="comment">// 对TR寄存器初始化</span></span><br><span class="line">    task_manager.curr_task = &amp;task_manager.first_task;  <span class="comment">// 设置当前任务为first task </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换页表为进程自己的页表</span></span><br><span class="line">    mmu_set_page_dir(task_manager.first_task.tss.cr3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）实现代码跳转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从操作进程跳转到用户进程代码 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_to_first_task</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    ASSERT(curr != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出当前任务的tss中的eip字段，获取入口地址</span></span><br><span class="line">    <span class="type">tss_t</span> *tss = &amp;(curr-&gt;tss);</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        <span class="string">&quot;jmp *%[ip]&quot;</span>::[ip]<span class="string">&quot;r&quot;</span>(tss-&gt;eip)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;kernel is running...&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;Version: %s %s %s&quot;</span>, OS_VERSION, <span class="string">&quot;diy86&quot;</span>, <span class="string">&quot;os&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;%d %d %x %c&quot;</span>, <span class="number">123456</span>, <span class="number">-123</span>, <span class="number">0x12345</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化first_task，并跳转到进程代码中运行</span></span><br><span class="line">    task_first_init();</span><br><span class="line">    move_to_first_task();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）运行结果：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191559496.png" alt="image-20240519155930343"></p>
<p>从上图可以看到此时<code>first_task</code>的入口地址在<code>0x11b09</code>，依旧在<code>1MB</code>以下。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191556008.png" alt="image-20240519155627657"></p>
<h3 id="2、地址分离"><a href="#2、地址分离" class="headerlink" title="2、地址分离"></a>2、地址分离</h3><blockquote>
<p><strong>目标：</strong></p>
<p>1）告诉<code>first_task</code>应该到<code>0x80000000</code>以上的地址去运行；</p>
<p>2）但在存储时是和操作系统一起存放在<code>0x0-0x7FFFFFFF</code>的地址空间内。</p>
<p><strong>实现方式：</strong>在链接脚本<code>kernel.lds</code>中进行修改。</p>
</blockquote>
<ul>
<li><strong>相关理论基础：</strong></li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191611562.png" alt="image-20240519161104805" style="zoom:50%;" />

<ul>
<li>物理地址为存储地址；</li>
<li>虚拟地址为运行地址。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191611577.png" alt="image-20240519161116895" style="zoom: 50%;" />

<p>而在<code>kernel.lds</code>文件中，<code>. = 0x100000</code>实际上设置的是虚拟地址，也就是运行地址。这样的结果就是<code>paddr</code>和<code>vaddr</code>设置为一样的，因此在加载时kernel也会从这个地址上去加载。</p>
<p><strong>现在要做的就是：</strong></p>
<p><strong>1）告诉<code>first_task</code>应该到<code>0x80000000</code>以上的地址去运行；</strong></p>
<p><strong>2）但在存储时是和操作系统一起存放在<code>0x0-0x7FFFFFFF</code>的地址空间内。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191615645.png" alt="image-20240519161519963"></p>
<p>因此，可在链接脚本中分别指定段的加载地址和运行地址。当仅指定运行地址时，加载地址与运行地址相同。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191616105.png" alt="image-20240519161650286"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.data 0x2000: AT(ADDR(.text) +SIZEOF(.text))</span><br></pre></td></tr></table></figure>

<p>这一行的意思就是说：<code>.data</code>的运行地址为<code>0x2000</code>，但其存储的物理地址在（<code>AT</code>）<code>.text</code>的相邻处。</p>
<ul>
<li><strong>代码实现：</strong></li>
</ul>
<p><code>kernel_elf.txt</code></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191621670.png" alt="image-20240519162150219"></p>
<p>上图中的<code>VirtualAddr</code>和<code>PhysAddr</code>一致，且分别对应<code>.text/.rodata</code>和<code>.data/.bss</code>两部分。</p>
<p>（1）告诉<code>first_task</code>应该到<code>0x80000000</code>以上的地址去运行；</p>
<p>修改链接脚本<code>kernel.lds</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	. = 0x80000000;</span><br><span class="line">	.first_task : &#123;</span><br><span class="line">		*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">		*first_task*(.text .rodata .bss .data)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROVIDE(mem_free_start = . ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，<code>ELF</code>文件的<code>Program Header Table</code>表项会更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191631851.png" alt="image-20240519163152388"></p>
<p>（2）但此时存在一个问题</p>
<p>在<code>loader</code>加载时会扫描上图这个表，并根据每个表项的具体内容进行加载。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Elf32_Phdr *phdr = (Elf32_Phdr *)(file_buffer + elf_hdr-&gt;e_phoff) + i;  <span class="comment">// 偏移量：elf_hdr-&gt;e_phoff</span></span><br></pre></td></tr></table></figure>

<p>也即上图中的<code>Offset</code>和<code>PhysAddr</code>两项。但由于<code>0x80000000</code>这个物理地址是不存在的，因此加载会失败。所以需要将<code>first_task</code>的物理地址修改为比<code>.data/.bss</code>的物理地址大一些的地址即可。</p>
<p>取<code>Segment 01</code>的虚拟地址即可（因为<code>00</code>和<code>01</code>段的虚拟地址与物理地址的映射是对应的）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">e_data = .;</span><br><span class="line"></span><br><span class="line">. = 0x80000000;</span><br><span class="line">.first_task : AT(e_data) &#123;</span><br><span class="line">	*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">	*first_task*(.text .rodata .bss .data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时就完成了物理地址的修改：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191648559.png" alt="image-20240519164849109"></p>
<p>（3）此外，对于<code>mem_free_start</code>也需要进行相应的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">. = 0x80000000;</span><br><span class="line">.first_task : AT(e_data) &#123;</span><br><span class="line">*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">*first_task*(.text .rodata .bss .data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROVIDE(mem_free_start = . ); </span><br></pre></td></tr></table></figure>

<p>此时它在<code>kernel_elf.txt</code>中显示的物理地址为：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191651929.png" alt="image-20240519165112540"></p>
<p>这是因为加入<code>(2)</code>中的系列修改后，会改变它的地址。但这个地址实际上应该指向位图缓存的起始地址，如下图所示，也就是说应该在<code>1MB以下</code>的范围内：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405171455366.png" alt="image-20240517145539043"></p>
<p>所以，进行如下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">. = 0x80000000;</span><br><span class="line">.first_task : AT(e_data) &#123;</span><br><span class="line">	*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">	*first_task*(.text .rodata .bss .data)</span><br><span class="line">&#125;</span><br><span class="line">e_first_task = LOADADDR(.first_task) + SIZEOF(.first_task);</span><br><span class="line"></span><br><span class="line">PROVIDE(mem_free_start = e_first_task); </span><br></pre></td></tr></table></figure>

<p>这样位图缓存的地址就修改正确：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191655562.png" alt="image-20240519165543113"></p>
<h3 id="3、代码搬运"><a href="#3、代码搬运" class="headerlink" title="3、代码搬运"></a>3、代码搬运</h3><blockquote>
<p><strong>实现方式：</strong></p>
<p>1）找到first_task在物理空间的起始和结束地址；</p>
<p>2）在虚拟空间分配相应的内存空间；</p>
<p>3）进行代码搬运。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191657728.png" alt="image-20240519165724091" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">memory_alloc_page_for_page_dir</span> <span class="params">(<span class="type">uint32_t</span> page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">uint32_t</span> size, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录当前vaddr（运行地址，所以是虚拟地址）</span></span><br><span class="line">    <span class="type">uint32_t</span> curr_vaddr = vaddr;</span><br><span class="line">    <span class="comment">// 计算分配页的数量，注意页边界对齐</span></span><br><span class="line">    <span class="type">int</span> page_count = up2(size, MEM_PAGE_SIZE) / MEM_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐页分配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; page_count; i++) &#123;</span><br><span class="line">        <span class="comment">// 从物理内存中分配一页</span></span><br><span class="line">        <span class="type">uint32_t</span> paddr = addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (paddr == <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;mem alloc failed, no memory!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立物理内存和虚拟内存的映射关系</span></span><br><span class="line">        <span class="type">int</span> err = memory_create_map((<span class="type">pde_t</span> *)page_dir, curr_vaddr, paddr, <span class="number">1</span>, perm);</span><br><span class="line">        <span class="keyword">if</span> (paddr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 若建立当前映射失败，则释放当前已建立映射的页，因此addr_free_page传入vaddr</span></span><br><span class="line">            <span class="comment">// 这里不能传入paddr，因为这个paddr只是当前循环下分配的这一页的起始物理地址</span></span><br><span class="line">            log_printf(<span class="string">&quot;create memory failed, crr = %d.&quot;</span>, err);</span><br><span class="line">            addr_free_page(&amp;paddr_alloc, vaddr, i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 此外，可以实现虚拟和物理映射的断开，此处并未实现</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到下一个虚拟地址</span></span><br><span class="line">        curr_vaddr += MEM_PAGE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">memory_alloc_page_for</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> size, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> memory_alloc_page_for_page_dir(task_current()-&gt;tss.cr3, addr, size, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191729446.png" alt="image-20240519172917244"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191729964.png" alt="image-20240519172948838"></p>
<p>执行代码拷贝后，显示如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一页内存供代码存放使用，然后将代码复制过去</span></span><br><span class="line">memory_alloc_page_for(first_start, alloc_size, PTE_P | PTE_W);</span><br><span class="line">kernel_memcpy((<span class="type">void</span> *)first_start, (<span class="type">void</span> *)s_first_task, copy_size);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191730041.png" alt="image-20240519173019470"></p>
<p>查看对应的反汇编，和<code>first_task_entry.S</code>中的内容一致：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191731972.png" alt="image-20240519173119400"></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191731182.png" alt="image-20240519173158224" style="zoom: 80%;" />

<h2 id="11-2-调整应用的特权级"><a href="#11-2-调整应用的特权级" class="headerlink" title="11.2 调整应用的特权级"></a>11.2 调整应用的特权级</h2><h3 id="1、x86芯片的特权级定义"><a href="#1、x86芯片的特权级定义" class="headerlink" title="1、x86芯片的特权级定义"></a>1、x86芯片的特权级定义</h3><p>x86芯片支持四种特权级：</p>
<ul>
<li>第0级权限最高，用于运行操作系统；</li>
<li>第3级权限最低，用于运行应用程序；</li>
<li>其它两级用于运行操作系统服务(可选)。</li>
</ul>
<p>对于某个特权级来说：只允许访问相同或更低权限的代码或数据。通过这种特权分级的机制可以防止低特权级代码随意访问敏感数据或代码，如开关中断、写磁盘等。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191916522.png" alt="image-20240519191609991"></p>
<ol>
<li><p>数据段访问相关的3种与权限相关的配置位：</p>
<ul>
<li><p>段描述符<code>DPL</code>(Descriptor privilege level(DPL))，定义哪个特权级别的代码可以访问这个段。</p>
</li>
<li><p>选择子<code>RPL</code>(Requested privilege level(RPL))，表示请求访问段的特权级别。</p>
</li>
<li><p>段寄存器<code>CS</code>中的<code>CPL</code>(Current privilege level)，表示当前执行代码的特权级别。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>访问**数据段(<code>DS,ES,FS,GS</code>)**时，仅当<code>DPL&gt;= Max(CPL,RPL)</code>时才能访问。</p>
<p>当**访问<code>SS</code>**时，要求<code>CPL=DPL=RPL</code>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191919839.png" alt="image-20240519191939329"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191920132.png" alt="image-20240519192009659"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191920272.png" alt="image-20240519192046797"></p>
<p>对于访问权限，要求1）自身的权限要足够高；2）自己不能主动把权限放低。<strong>权限错误将产生段保护异常。</strong></p>
<p>如下图<code>CPL=0, RPL=3, DPL=2</code>这条线，就属于自己主动把权限放低了，因此也无法正确访问。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191931168.png" alt="image-20240519193151363"></p>
<ol start="2">
<li><p>代码段访问相关的3种与权限相关的配置位：</p>
<ul>
<li><p>段描述符<code>DPL</code>(Descriptor privilege level(DPL))和<code>C</code>位，定义哪个特权级别的代码可以访问这个段。</p>
</li>
<li><p>选择子<code>RPL</code>(Requested privilege level(RPL))，表示请求访问段的特权级别。</p>
</li>
<li><p>段寄存器<code>CS</code>中的<code>CPL</code>(Current privilege level)，表示当前执行代码的特权级别。</p>
</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191934137.png" alt="image-20240519193438668"></p>
<ul>
<li><p>访问非一致代码段时(<code>C=0</code>)，<code>CPL=DPL，且RPL&lt;=CPL</code>，即权限要一样。</p>
</li>
<li><p>访问一致性代码段时(<code>C=1</code>)到，要求<code>CPL&gt;=DPL，RPL不检查</code>，即访问者的权限要与被访问的代码权限相等或更低<strong>（但本项目未用到，因为不允许随便访问高权限的代码）</strong>。</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191936035.png" alt="image-20240519193654339" style="zoom: 50%;" />

<h3 id="2、平坦模型如何实现保护"><a href="#2、平坦模型如何实现保护" class="headerlink" title="2、平坦模型如何实现保护"></a>2、平坦模型如何实现保护</h3><p>对于本项目来说，由于采用了平坦模型，因此分段保护做不到真正的保护，实际上都写入了<code>0x0~0xFFFFFFFF</code>的空间。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191938454.png" alt="image-20240519193841332" style="zoom:50%;" />

<p>因此，结合分页机制进行保护。简化处理，操作系统运行于特权级<code>0</code>，应用进程运行于特权级<code>3</code>。全部使用非一致性代码段，<code>CPL=RPL</code>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191940126.png" alt="image-20240519194030428" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191940436.png" alt="image-20240519194056411" style="zoom:50%;" />

<h3 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_manager_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> app_code_sel;   <span class="comment">// 进程的代码段选择子</span></span><br><span class="line">    <span class="type">int</span> app_data_sel;   <span class="comment">// 进程的数据段选择子</span></span><br><span class="line">&#125;<span class="type">task_manager_t</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief TSS Initialization，当有程序/进程第一次运行时会调用tss_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tss_init</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 根据不同的权限选择不同的访问选择子</span></span><br><span class="line">    <span class="type">int</span> code_sel, data_sel;</span><br><span class="line">    code_sel = task_manager.app_code_sel | SEG_CPL3;</span><br><span class="line">    data_sel = task_manager.app_data_sel | SEG_CPL3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置TSS的相关字段</span></span><br><span class="line">    task-&gt;tss.eip = entry;  <span class="comment">// 调用tss_init的函数的入口地址（该函数第一次运行）</span></span><br><span class="line">    task-&gt;tss.esp = task-&gt;tss.esp0 = esp;  <span class="comment">// 指示调用tss_init的函数的栈顶的位置（此时栈为空）</span></span><br><span class="line">    task-&gt;tss.ss = task-&gt;tss.ss0 = data_sel;</span><br><span class="line">    task-&gt;tss.es = task-&gt;tss.ds = task-&gt;tss.fs = task-&gt;tss.gs = data_sel;</span><br><span class="line">    task-&gt;tss.cs = code_sel;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 任务管理器初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 设定任务数据段和代码段的特权级</span></span><br><span class="line">    <span class="type">int</span> sel = gdt_alloc_desc();</span><br><span class="line">    segment_desc_set(sel, <span class="number">0x00000000</span>, <span class="number">0xFFFFFFFF</span>,</span><br><span class="line">        SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D);</span><br><span class="line">    task_manager.app_data_sel = sel;</span><br><span class="line"></span><br><span class="line">    sel = gdt_alloc_desc();</span><br><span class="line">    segment_desc_set(sel, <span class="number">0x00000000</span>, <span class="number">0xFFFFFFFF</span>,</span><br><span class="line">        SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL | SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D);</span><br><span class="line">    task_manager.app_code_sel = sel;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时进行调试，可以看到相应的段寄存器的值：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405191955719.png" alt="image-20240519195526886"></p>
<p>这些值实际上的内核初始化时在<code>cpu_init()</code>中通过下面的代码设置的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化GDT表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 设计平坦模式下的代码段与数据段</span></span><br><span class="line">    <span class="comment">// 注意第#0号表项需要保留，不能使用</span></span><br><span class="line">    segment_desc_set(KERNEL_SELECTOR_DS, <span class="number">0</span>, <span class="number">0xFFFFFFFF</span>, </span><br><span class="line">        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA</span><br><span class="line">        | SEG_TYPE_RW | SEG_D</span><br><span class="line">    );</span><br><span class="line">    segment_desc_set(KERNEL_SELECTOR_CS, <span class="number">0</span>, <span class="number">0xFFFFFFFF</span>, </span><br><span class="line">        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE</span><br><span class="line">        | SEG_TYPE_RW | SEG_D</span><br><span class="line">    );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此说明此时<code>first_task</code>依旧是运行在特权级<code>0</code>的状态下。这是因为整个系统从内核加载、解析，一直到运行<code>first_task</code>时并没有对<code>TSS</code>的相关设置，只是对<code>TSS</code>进行了相应的初始化。</p>
<p>当进行第一次任务切换，由于运行了<code>sys_sleep()</code>函数，因此切换到<code>idle_task</code>时，相应的寄存器值就发生了改变。可以看到<code>CS</code>的低<code>2</code>位变成了<code>特权级3</code>，也就是说空闲任务运行在<code>特权级3</code>上。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192010866.png" alt="image-20240519201046181"></p>
<p>此时若按下<code>F11</code>，会发生异常。这是因为<code>idle_task</code>相关的代码是和操作系统代码绑定在一起编译的，存储在<code>1MB以下</code>的内存区域，而根据映射关系可知，这部分的<code>U/S</code>位是设置为<code>0</code>的，也就是用户特权级无法访问，但<code>idle_task</code>又处在用户级特权，相当于这里按照权限3去执行权限0的代码，因此发生了权限错误。</p>
<blockquote>
<p>目前存在的问题：</p>
<p><code>first_task</code>运行在权限级<code>0</code>，而<code>idle_task</code>反而运行在了权限级<code>3</code>，在后续应该对其进行调换。</p>
</blockquote>
<h2 id="11-3-调整异常处理函数"><a href="#11-3-调整异常处理函数" class="headerlink" title="11.3 调整异常处理函数"></a>11.3 调整异常处理函数</h2><h3 id="1、修改TSS字段初始化"><a href="#1、修改TSS字段初始化" class="headerlink" title="1、修改TSS字段初始化"></a>1、修改TSS字段初始化</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192018702.png" alt="image-20240519201803678"></p>
<p>当存在特权级变化时，若特权级<code>3</code>的程序&#x2F;任务发生了异常，则异常处理程序（<code>DPL=0</code>）不应在发生异常的那个栈中压入，而应该单独压入另一个特级为<code>0</code>的栈中。</p>
<p>针对<code>11.2</code>中的最后提出的问题，需要对<code>tss</code>初始化中的相关字段设置进行更改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task-&gt;tss.ss = task-&gt;tss.ss0 = data_sel;</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task-&gt;tss.ss0 = KERNEL_SELECTOR_DS;</span><br><span class="line">task-&gt;tss.ss = data_selc;</span><br></pre></td></tr></table></figure>

<p>此时就可以成功的跳转到<code>Page Fault Exception</code>异常中：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192048487.png" alt="image-20240519204839152"></p>
<h3 id="2、修改异常处理函数"><a href="#2、修改异常处理函数" class="headerlink" title="2、修改异常处理函数"></a>2、修改异常处理函数</h3><ul>
<li><p><code>do_handler_page_fault()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_handler_page_fault</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	    log_printf(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;IRQ/Exception happend: Page fault.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_PAGE_P) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tpage-level protection violation: 0x%x.&quot;</span>, read_cr2());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tPage doesn&#x27;t present 0x%x&quot;</span>, read_cr2());</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_PAGE_WR) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tThe access causing the fault was a read.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tThe access causing the fault was a write.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_PAGE_US) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tA supervisor-mode access caused the fault.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;\tA user-mode access caused the fault.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dump_core_regs(frame);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        hlt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>do_handler_general_protection</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_handler_general_protection</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">    log_printf(<span class="string">&quot;IRQ/Exception happend: General Protection.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_EXT) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;the exception occurred during delivery of an &quot;</span></span><br><span class="line">                <span class="string">&quot;event external to the program, such as an interrupt&quot;</span></span><br><span class="line">                <span class="string">&quot;or an earlier exception.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;the exception occurred during delivery of a&quot;</span></span><br><span class="line">                    <span class="string">&quot;software interrupt (INT n, INT3, or INTO).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;error_code &amp; ERR_IDT) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;the index portion of the error code refers &quot;</span></span><br><span class="line">                    <span class="string">&quot;to a gate descriptor in the IDT&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;the index refers to a descriptor in the GDT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    log_printf(<span class="string">&quot;segment index: %d&quot;</span>, frame-&gt;error_code &amp; <span class="number">0xFFF8</span>);</span><br><span class="line"></span><br><span class="line">    dump_core_regs(frame);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        hlt();</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>修改后打印的异常信息更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192103797.png" alt="image-20240519210348190"></p>
<h2 id="11-4-修改空闲任务的特权级"><a href="#11-4-修改空闲任务的特权级" class="headerlink" title="11.4 修改空闲任务的特权级"></a>11.4 修改空闲任务的特权级</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192104590.png" alt="image-20240519210438905"  />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief TSS Initialization，当有程序/进程第一次运行时会调用tss_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tss_init</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">int</span> flags, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 根据不同的权限选择不同的访问选择子</span></span><br><span class="line">    <span class="type">int</span> code_sel, data_sel;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; TASK_FLAGS_SYSTEM) &#123;</span><br><span class="line">        <span class="comment">// 系统权限</span></span><br><span class="line">        code_sel = KERNEL_SELECTOR_CS;</span><br><span class="line">        data_sel = KERNEL_SELECTOR_DS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用户权限</span></span><br><span class="line">        code_sel = task_manager.app_code_sel | SEG_CPL3;</span><br><span class="line">        data_sel = task_manager.app_data_sel | SEG_CPL3;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 任务管理器初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">// 空闲任务初始化</span></span><br><span class="line">    task_init(&amp;task_manager.idle_task,</span><br><span class="line">        <span class="string">&quot;idle_task&quot;</span>,</span><br><span class="line">        TASK_FLAGS_SYSTEM,</span><br><span class="line">        (<span class="type">uint32_t</span>)idle_task_entry,</span><br><span class="line">        (<span class="type">uint32_t</span>)(idle_task_stack + IDLE_TASK_SIZE));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-5-修改用户任务的特权级"><a href="#11-5-修改用户任务的特权级" class="headerlink" title="11.5 修改用户任务的特权级"></a>11.5 修改用户任务的特权级</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192114720.png" alt="image-20240519211415052"></p>
<p>要实现从高特权级向低特权级的转移，需要使用<code>IRET</code>指令。</p>
<p>可以参考中断切换的操作，在<code>first_task</code>的<code>TSS</code>初始化时，将相应的字段手动压入栈中；然后再执行<code>IRET</code>指令，就可以返回到特权级<code>3</code>的状态。从而实现一种从高到低的特权级切换，并将寄存器的值设置到<code>CPU</code>中。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192115446.png" alt="image-20240519211502898" style="zoom:50%;" />

<p>代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从操作进程跳转到用户进程代码 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_to_first_task</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    ASSERT(curr != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出当前任务的tss中的eip字段，获取入口地址</span></span><br><span class="line">    <span class="type">tss_t</span> *tss = &amp;(curr-&gt;tss);</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        <span class="comment">// 模拟IRET中断返回，切换入第1个可运行应用进程</span></span><br><span class="line">        <span class="comment">// 不过这里并不直接进入到进程的入口，而是先设置好段寄存器，再跳过去</span></span><br><span class="line">        <span class="string">&quot;push %[ss]\n\t&quot;</span>			<span class="comment">// SS</span></span><br><span class="line">        <span class="string">&quot;push %[esp]\n\t&quot;</span>			<span class="comment">// ESP</span></span><br><span class="line">        <span class="string">&quot;push %[eflags]\n\t&quot;</span>        <span class="comment">// EFLAGS</span></span><br><span class="line">        <span class="string">&quot;push %[cs]\n\t&quot;</span>			<span class="comment">// CS</span></span><br><span class="line">        <span class="string">&quot;push %[eip]\n\t&quot;</span>		    <span class="comment">// ip</span></span><br><span class="line">        <span class="string">&quot;iret\n\t&quot;</span></span><br><span class="line">        ::[ss]<span class="string">&quot;r&quot;</span>(tss-&gt;ss),</span><br><span class="line">          [esp]<span class="string">&quot;r&quot;</span>(tss-&gt;esp),</span><br><span class="line">          [eflags]<span class="string">&quot;r&quot;</span>(tss-&gt;eflags),</span><br><span class="line">          [cs]<span class="string">&quot;r&quot;</span>(tss-&gt;cs),</span><br><span class="line">          [eip]<span class="string">&quot;r&quot;</span>(tss-&gt;eip)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时调试得到的寄存器值如下。可以看到<code>ds/es/fs/gs</code>的值都变成了<code>0x0</code>，这是因为特权级<code>0</code>时这些寄存器存在一些值，而当切换到特权级<code>3</code>时，这些选择子会被清零。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192125386.png" alt="image-20240519212526869"></p>
<p>此时再单步调试<code>F11</code>，会发现<code>CPU</code>发生了复位。查看<code>info mem</code>可以看出，<code>0x800000000以上</code>的地址空间其权限状态，即<code>U/S</code>位依旧需要高特权级才能访问，但此时应该是低特权级程序去访问这段空间。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192128843.png" alt="image-20240519212808376"></p>
<p>因此，需要在内存分配的相关代码中进行修改。</p>
<ul>
<li>在<code>task_first_init</code>加入属性值<code>PTE_U</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 分配一页内存供代码存放使用，然后将代码复制过去</span></span><br><span class="line">    memory_alloc_page_for(first_start, alloc_size, PTE_P | PTE_W | PTE_U);</span><br><span class="line">    kernel_memcpy((<span class="type">void</span> *)first_start, (<span class="type">void</span> *)s_first_task, copy_size);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>find_pte</code>加入属性值<code>PDE_U</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在page_dir中寻找vaddr对应的页表项/PTE</span></span><br><span class="line"><span class="comment"> * @param alloc 若PTE对应的Page Table不存在，是否需要进行分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pte_t</span> *<span class="title function_">find_pte</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    pde-&gt;v = pg_paddr | PDE_P | PDE_W | PDE_U;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时寄存器值的设置更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192135719.png" alt="image-20240519213521035"></p>
<h2 id="11-6-为进程添加特权级0的栈空间"><a href="#11-6-为进程添加特权级0的栈空间" class="headerlink" title="11.6 为进程添加特权级0的栈空间"></a>11.6 为进程添加特权级0的栈空间</h2><p>目前进程<code>特权级0</code>和<code>特权级3</code>使用的是同一个栈，因此需要额外创建一个栈，以便进行不同特权级栈的分享。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192142734.png" alt="image-20240519214216716"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 任务初始化</span></span><br><span class="line">    <span class="comment">// task_init(&amp;task_manager.first_task, &quot;first task&quot;, 0, first_start, 0);  </span></span><br><span class="line">    <span class="comment">// 对first_task的esp进行修改如下：</span></span><br><span class="line">    task_init(&amp;task_manager.first_task, <span class="string">&quot;first task&quot;</span>, <span class="number">0</span>, first_start, first_start + alloc_size);  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief TSS Initialization，当有程序/进程第一次运行时会调用tss_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tss_init</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">int</span> flags, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内核栈，得到的是物理地址</span></span><br><span class="line">    <span class="type">uint32_t</span> kernel_stack = memory_alloc_page();</span><br><span class="line">    <span class="keyword">if</span> (kernel_stack == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> tss_init_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    task-&gt;tss.esp = esp;  <span class="comment">// 指示调用tss_init的函数的栈顶的位置（此时栈为空）</span></span><br><span class="line">    task-&gt;tss.esp0 = kernel_stack + MEM_PAGE_SIZE;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">tss_init_failed:</span><br><span class="line">    gdt_free_sel(tss_sel);</span><br><span class="line">    <span class="keyword">if</span> (kernel_stack) &#123;</span><br><span class="line">        memory_free_page(kernel_stack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取当前页表地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">pde_t</span> * <span class="title function_">current_page_dir</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">pde_t</span> *)task_current()-&gt;tss.cr3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 分配一页内存</span></span><br><span class="line"><span class="comment"> * 主要用于内核空间内存的分配，不用于进程内存空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">memory_alloc_page</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 内核空间虚拟地址与物理地址相同，因此可以直接调用</span></span><br><span class="line">    <span class="keyword">return</span> addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放一页内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_free_page</span> <span class="params">(<span class="type">uint32_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (addr &lt; MEM_TASK_BASE) &#123;</span><br><span class="line">        <span class="comment">// 若为内核空间，则直接释放</span></span><br><span class="line">        addr_free_page(&amp;paddr_alloc, addr, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若为进程空间，则还要释放页表</span></span><br><span class="line">        <span class="type">pte_t</span> * pte = find_pte(current_page_dir(), addr, <span class="number">0</span>);</span><br><span class="line">        ASSERT((pte == (<span class="type">pte_t</span> *)<span class="number">0</span>) &amp;&amp; pte-&gt;present);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放内存页</span></span><br><span class="line">        addr_free_page(&amp;paddr_alloc, pte_paddr(pte), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放页表</span></span><br><span class="line">        pte-&gt;v = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时进程就进入了特权级<code>3</code>的自己的栈：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192208389.png" alt="image-20240519220833546"></p>
<p>此时<code>info mem</code>的信息更新如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192210217.png" alt="image-20240519221009717"></p>
<p>此时继续运行会出现异常：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;first task.&quot;</span>);  <span class="comment">// F11单步调试此处出现异常</span></span><br><span class="line">        sys_sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192210492.png" alt="image-20240519221047950"></p>
<p>这是因为<code>log_printf</code>在操作系统进程（<code>0x00012bcd</code>）中，用户代码是没有权限访问的，因此需要在后续通过系统调用来解决。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405192213396.png" alt="image-20240519221354822" style="zoom: 80%;" />

<h1 id="十二、建立系统调用"><a href="#十二、建立系统调用" class="headerlink" title="十二、建立系统调用"></a>十二、建立系统调用</h1><h2 id="12-1-实现系统调用的调用和返回"><a href="#12-1-实现系统调用的调用和返回" class="headerlink" title="12.1 实现系统调用的调用和返回"></a>12.1 实现系统调用的调用和返回</h2><h3 id="1、调用门"><a href="#1、调用门" class="headerlink" title="1、调用门"></a>1、调用门</h3><p>（1）调用门的作用</p>
<p>到目前为此，由于特权级的影响，特权级为<code>3</code>的应用进程无法直接访问特权级为<code>0</code>的操作进程的代码。</p>
<p>切换特权级的几种方法：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201002440.png" alt="image-20240520100207964" style="zoom:50%;" />

<p>应用程序可以通过<strong>调用门接口</strong>，实现在低特权级下对操作系统提供的接口函数进行调用。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201004667.png" alt="image-20240520100431449" style="zoom:50%;" />

<p>（2）调用门的描述符</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201005983.png" alt="image-20240520100512741" style="zoom:50%;" />

<p>（3）调用门的工作流程</p>
<p>调用门描述符实际上存放到<code>GDT</code>表中，应用调用门时需要传入对应的调用门选择子。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201008417.png" alt="image-20240520100843015" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201008739.png" alt="image-20240520100854431" style="zoom:50%;" />

<p>（4）权限检查，设置<code>CPL=3, RPL=0</code>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201010501.png" alt="image-20240520101031276" style="zoom:50%;" />

<h3 id="2、创建调用门"><a href="#2、创建调用门" class="headerlink" title="2、创建调用门"></a>2、创建调用门</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpu.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化GDT表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 添加调用门描述符</span></span><br><span class="line">    <span class="comment">// (SELECTOR_SYSCALL &gt;&gt; 3)  =&gt; 段选择子的低3位用作其他用途，高13为才用于索引index</span></span><br><span class="line">    <span class="comment">// selector                 =&gt; KERNEL_SELECTOR_CS，是因为被调函数是操作系统的代码</span></span><br><span class="line">    <span class="comment">// offset                   =&gt; 由于段基地址为0，因此被调函数的入口地址即为偏移量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当执行call指令时，会取选择子KERNEL_SELECTOR_CS找到代码段的起始地址，</span></span><br><span class="line">    <span class="comment">// 然后根据偏移量(uint32_t)exception_handler_syscall进入函数内部</span></span><br><span class="line">    gate_desc_set((<span class="type">gate_desc_t</span> *)(gdt_table + (SELECTOR_SYSCALL &gt;&gt; <span class="number">3</span>)), </span><br><span class="line">        KERNEL_SELECTOR_CS, </span><br><span class="line">        (<span class="type">uint32_t</span>)exception_handler_syscall, </span><br><span class="line">        GATE_P_PRESENT | GATE_DPL3 | GATE_TYPE_SYSCALL | SYSCALL_PARAM_COUNT</span><br><span class="line">    );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// init.c/start.S</span><br><span class="line"></span><br><span class="line">	.global exception_handler_syscall</span><br><span class="line">exception_handler_syscall:</span><br><span class="line">    retf $(5*4)</span><br></pre></td></tr></table></figure>

<h3 id="3、实现调用和返回"><a href="#3、实现调用和返回" class="headerlink" title="3、实现调用和返回"></a>3、实现调用和返回</h3><p>如果为每一个系统调用都提供一个对应的调用门，会占用较多的描述符表项。<strong>因此，可通过一个或少量几个调用门实现系统调用，从而节省资源。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201032921.png" alt="image-20240520103254777" style="zoom:50%;" />

<p>进入调用门：远跳转；</p>
<p>退出调用门：RET。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201046034.png" alt="image-20240520104642832" style="zoom:50%;" />

<p>代码实现：</p>
<p>通用系统调用结构<code>sys_call()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// applib/libsys.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用参数列表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">syscall_args_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;     <span class="comment">// 被调用函数的ID</span></span><br><span class="line">    <span class="type">int</span> arg0;</span><br><span class="line">    <span class="type">int</span> arg1;</span><br><span class="line">    <span class="type">int</span> arg2;</span><br><span class="line">    <span class="type">int</span> arg3;</span><br><span class="line">&#125;<span class="type">syscall_args_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep       0       <span class="comment">// sys_sleep()的ID</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">sys_call</span> <span class="params">(<span class="type">syscall_args_t</span> * args)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> addr[] = &#123;<span class="number">0</span>, SELECTOR_SYSCALL | <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// far jump</span></span><br><span class="line">    __asm__ __volatile__ (</span><br><span class="line">        <span class="string">&quot;push %[arg3]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg2]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg1]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg0]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[id]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;lcalll *(%[a])&quot;</span></span><br><span class="line">        ::[arg3]<span class="string">&quot;r&quot;</span>(args-&gt;arg3),</span><br><span class="line">          [arg2]<span class="string">&quot;r&quot;</span>(args-&gt;arg2),</span><br><span class="line">          [arg1]<span class="string">&quot;r&quot;</span>(args-&gt;arg1),</span><br><span class="line">          [arg0]<span class="string">&quot;r&quot;</span>(args-&gt;arg0),</span><br><span class="line">          [id]<span class="string">&quot;r&quot;</span>(args-&gt;id),</span><br><span class="line">          [a]<span class="string">&quot;r&quot;</span>(addr)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sys_sleep的系统调用</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">msleep</span> <span class="params">(<span class="type">int</span> ms)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ms &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_sleep;</span><br><span class="line">    args.arg0 = ms;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sys_call(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>lcalll</code>，即远跳转指令需要提供两个参数，段选择子和段内偏移，由<code>addr[]</code>提供。</p>
<ul>
<li><code>addr[0] = 0</code>，表示<strong>段内偏移</strong>，它指向系统调用处理函数的入口点。</li>
<li><code>addr[1] = SELECTOR_SYSCALL | 0</code>表示<strong>段选择子</strong>。<ul>
<li><code>SELECTOR_SYSCALL</code> 是被调用系统函数的段选择子；</li>
<li><code>| 0</code>是因为<code>RPL</code>设置为<code>0</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201109576.png" alt="image-20240520110945445" style="zoom:50%;" />

<ul>
<li><p>在保护模式下，x86架构使用段选择子和段内偏移配合进行内存寻址。例如，远调用指令<code>lcall</code>会使用段选择子和段内偏移来确定调用的目标地址：</p>
<ol>
<li><strong>段选择子</strong>：决定使用哪个段描述符，该描述符提供段的基地址和权限;</li>
<li><strong>段内偏移</strong>：在基地址的基础上加上偏移量，确定最终的内存地址。</li>
</ol>
</li>
<li><p>举例说明</p>
</li>
</ul>
<p>假设有一个段选择子<code>0x08</code>，它指向GDT中的一个代码段描述符，该描述符的基地址是<code>0x40000000</code>。如果段内偏移是<code>0x1000</code>，则最终的线性地址是：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线性地址 = 段基地址 + 段内偏移</span><br><span class="line"><span class="code">          = 0x40000000 + 0x1000</span></span><br><span class="line"><span class="code">          = 0x40001000</span></span><br></pre></td></tr></table></figure>

<p>这种机制使得程序可以通过改变段选择子访问不同的内存段，同时确保通过权限控制防止未经授权的访问。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201059277.png" alt="image-20240520105948178"></p>
<p><code>far jump</code>将跳转到下图的代码处：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201100500.png" alt="image-20240520110014325" style="zoom: 80%;" />



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201210574.png" alt="image-20240520121051430"></p>
<p><code>ESP</code>指向<code>0x122fdc</code>地址处（<code>1MB空间以下</code>），其内存存储的值如下图所示。也就是说，在用户进程中压入<code>特权级3</code>的对应栈的相关参数已经复制到了<code>特权级0</code>的对应栈中。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201216326.png" alt="image-20240520121643956"></p>
<p>此时存在一些问题，若调用<code>RET</code>指令，不会执行特权级切换，因此需要采用<code>RETF</code>指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exception_handler_syscall:</span><br><span class="line">    // ret</span><br><span class="line">    retf  // far return，即返回到不同的代码段中</span><br></pre></td></tr></table></figure>

<p>同时要注意，直接调用<code>REFT</code>时，在将<code>EIP/CS</code>弹出到对应的寄存器后，会直接从Parameter的位置开始弹出，这是系统“以为的”<code>ESP/SS</code>，如下图所示。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201221626.png" alt="image-20240520122108506" style="zoom: 50%;" />

<p>因此需要进行如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exception_handler_syscall:</span><br><span class="line">    retf $(5*4)</span><br></pre></td></tr></table></figure>

<h2 id="12-2-具体的调用实现"><a href="#12-2-具体的调用实现" class="headerlink" title="12.2 具体的调用实现"></a>12.2 具体的调用实现</h2><p>在进入系统调用处理程序之前，除了硬件<strong>自动压栈</strong>之外，还需要<strong>手动压栈</strong>一部分寄存器的值，以便后续使用。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201224360.png" alt="image-20240520122430073"></p>
<p>在系统调用内部，使用<strong>系统调用表</strong>来保存所有系统调用处理函数的入口地址。当发生系统调用时，通过查表来获取跳转点。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201251661.png" alt="image-20240520125101409"></p>
<h3 id="1、寄存器出入栈管理"><a href="#1、寄存器出入栈管理" class="headerlink" title="1、寄存器出入栈管理"></a>1、寄存器出入栈管理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    .global exception_handler_syscall</span><br><span class="line">exception_handler_syscall:</span><br><span class="line">    # 寄存器入栈（此处为手动入栈，有部分由硬件自动入栈）</span><br><span class="line">    pusha</span><br><span class="line">    push %ds</span><br><span class="line">    push %es</span><br><span class="line">    push %fs</span><br><span class="line">    push %gs</span><br><span class="line">    pushf                # 手动压入调用门</span><br><span class="line">        </span><br><span class="line">    mov %esp, %eax</span><br><span class="line">    push %eax</span><br><span class="line">    call do_handler_syscall</span><br><span class="line">    add $<span class="number">4</span>, %esp</span><br><span class="line">        </span><br><span class="line">    # 寄存器出栈</span><br><span class="line">    popf</span><br><span class="line">    pop %gs</span><br><span class="line">    pop %fs</span><br><span class="line">    pop %es</span><br><span class="line">    pop %ds</span><br><span class="line">    popa</span><br><span class="line"></span><br><span class="line">    retf $(<span class="number">5</span>*<span class="number">4</span>) </span><br></pre></td></tr></table></figure>

<blockquote>
<pre><code>    pusha：将所有通用寄存器（EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI）的值压入栈中。
           这样可以保存调用者的寄存器状态。
    pushf：将标志寄存器 EFLAGS 的值压入栈中。
</code></pre>
</blockquote>
<blockquote>
<pre><code>mov %esp, %eax：
    将当前栈指针ESP的值移动到EAX寄存器中。
    这一步保存了当前的栈指针。
push %eax：
    将EAX寄存器（即栈指针ESP的值）压入栈中，作为参数传递给do_handler_syscall。
call do_handler_syscall：
    调用系统调用处理函数do_handler_syscall。
    在调用之前，栈中的ESP值被传递给该函数。
add $4, %esp：
    调整栈指针，移除之前压入的参数。
    由于调用do_handler_syscall后栈中多了一个参数（即EAX的值），需要将ESP增加4字节。
</code></pre>
</blockquote>
<h3 id="2、系统调用结构体"><a href="#2、系统调用结构体" class="headerlink" title="2、系统调用结构体"></a>2、系统调用结构体</h3><p>用于保存系统调用时的处理器状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用结构体，用于保存系统调用时的处理器状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">syscall_frame_t</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> eflags;</span><br><span class="line">	<span class="type">int</span> gs, fs, es, ds;</span><br><span class="line">	<span class="type">int</span> edi, esi, ebp, dummy, ebx, edx, ecx, eax;</span><br><span class="line">	<span class="type">int</span> eip, cs;</span><br><span class="line">	<span class="type">int</span> func_id, arg0, arg1, arg2, arg3;</span><br><span class="line">	<span class="type">int</span> esp, ss;</span><br><span class="line">&#125; <span class="type">syscall_frame_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">sys_call</span> <span class="params">(<span class="type">syscall_args_t</span> * args)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> addr[] = &#123;<span class="number">0</span>, SELECTOR_SYSCALL | <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// far jump</span></span><br><span class="line">    __asm__ __volatile__ (</span><br><span class="line">        <span class="string">&quot;push %[arg3]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg2]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg1]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[arg0]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;push %[id]\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;lcalll *(%[a])&quot;</span></span><br><span class="line">        :<span class="string">&quot;=a&quot;</span>(ret)</span><br><span class="line">        :[arg3]<span class="string">&quot;r&quot;</span>(args-&gt;arg3),</span><br><span class="line">         [arg2]<span class="string">&quot;r&quot;</span>(args-&gt;arg2),</span><br><span class="line">         [arg1]<span class="string">&quot;r&quot;</span>(args-&gt;arg1),</span><br><span class="line">         [arg0]<span class="string">&quot;r&quot;</span>(args-&gt;arg0),</span><br><span class="line">         [id]<span class="string">&quot;r&quot;</span>(args-&gt;id),</span><br><span class="line">         [a]<span class="string">&quot;r&quot;</span>(addr)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、转发表实现系统调用"><a href="#3、转发表实现系统调用" class="headerlink" title="3、转发表实现系统调用"></a>3、转发表实现系统调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*<span class="type">syscall_handler_t</span>)</span><span class="params">(<span class="type">uint32_t</span> arg0, <span class="type">uint32_t</span> arg1, <span class="type">uint32_t</span> arg2, <span class="type">uint32_t</span> arg3)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用的转发表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">syscall_handler_t</span> sys_table[] = &#123;</span><br><span class="line">    [SYS_sleep] = (<span class="type">syscall_handler_t</span>)sys_sleep,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在调用该函数时，传递的frame参数所指向的内存地址处保存了相关的寄存器信息。在exception_handler_syscall函数中，</span></span><br><span class="line"><span class="comment"> *        相关的寄存器值被保存到栈上，然后ESP寄存器的值（即当前栈顶指针）被传递给do_handler_syscall函数。</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *        这个函数需要进行转发，找到需要调用的相应的系统函数。在frame中包含一个字段func_id，在对应的调用函数中是压入到</span></span><br><span class="line"><span class="comment"> *        syscall_args_t的id字段，并压入特权级3的栈中；在执行系统调用时，会被拷贝到特权级0的栈中（自动入栈），从而对</span></span><br><span class="line"><span class="comment"> *        应到相应的系统函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_syscall</span> <span class="params">(<span class="type">syscall_frame_t</span> *frame)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;func_id &lt; <span class="keyword">sizeof</span>(sys_table) / <span class="keyword">sizeof</span>(sys_table[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="comment">// 查表取得处理函数，然后调用处理</span></span><br><span class="line">        <span class="type">syscall_handler_t</span> handler  = sys_table[frame-&gt;func_id];</span><br><span class="line">        <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">            <span class="type">int</span> ret = handler(frame-&gt;arg0, frame-&gt;arg1, frame-&gt;arg2, frame-&gt;arg3);</span><br><span class="line">            frame-&gt;eax = ret;  <span class="comment">// eax用于存放函数的返回值，因此用ret赋值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数索引超出转发表</span></span><br><span class="line">    <span class="type">task_t</span> *task = task_current();</span><br><span class="line">    log_printf(<span class="string">&quot;task: %s, Unkown syscall: %d&quot;</span>, task-&gt;name, frame-&gt;func_id);</span><br><span class="line">    frame-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释<code>frame-&gt;eax = ret;</code>，从下图可以看出最终的返回值放到了<code>%eax</code>中：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201607868.png" alt="image-20240520160709366" style="zoom: 80%;" />

<blockquote>
<p>在执行<code>lcalll</code>指令时，进入<code>start.S</code>中执行<code>exception_handler_syscall</code>进行寄存器的出入栈操作。1）首先通过<code>pusha</code>将<code>eax</code>压栈；2）再通过<code>sys_getpid()</code>获取到<code>pid</code>作为返回值，并放入<code>frame-&gt;eax</code>中，此时就对<code>eax</code>的值进行了修改；3）最后通过<code>popa</code>将<code>eax</code>出栈，返回到上一层的调用函数<code>sys_call</code>中。</p>
<p>以<code>getpid()</code>为例，调用的函数堆栈顺序如下：</p>
<p><code>getpid()  -&gt;  sys_call()  -&gt;  do_handler_syscall()  -&gt; sys_getpid()</code></p>
<p>也就是说，<code>ret</code>的返回如上述逆序。</p>
</blockquote>
<p>调试运行时<code>frame</code>的相关参数：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201512535.png" alt="image-20240520151212263"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201511396.png" alt="image-20240520151158125"></p>
<h1 id="十三、新进程的加载与创建"><a href="#十三、新进程的加载与创建" class="headerlink" title="十三、新进程的加载与创建"></a>十三、新进程的加载与创建</h1><h2 id="13-1-实现fork系统调用"><a href="#13-1-实现fork系统调用" class="headerlink" title="13.1 实现fork系统调用"></a>13.1 实现fork系统调用</h2><h3 id="1、理论基础-12"><a href="#1、理论基础-12" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><p>（1）流程</p>
<p>系统调用的流程如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201647344.png" alt="image-20240520164706084"></p>
<p>（2）功能详述</p>
<p><code>fork()</code>系统调用的功能：创建一个进程的副本，并且<strong>继续从调用fork的地址往下运行</strong>。（这一点很重要！）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create child proc failed.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child: %d\n&quot;</span>, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child task id=%d\n&quot;</span>, pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent: %d\n&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201647127.png" alt="image-20240520164718779"></p>
<h3 id="2、任务块的分配和释放"><a href="#2、任务块的分配和释放" class="headerlink" title="2、任务块的分配和释放"></a>2、任务块的分配和释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述程序/进程运行状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> *<span class="title">parent</span>;</span>     <span class="comment">// 指明父进程    </span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure>

<p>将多个任务块存储在一个静态分配的进程表<code>task_table</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> task_table[TASK_NR];                  <span class="comment">// 进程表，静态分配</span></span><br><span class="line"><span class="type">static</span> <span class="type">mutex_t</span> task_table_mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Task Initializtion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_init</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> flags, <span class="type">uint32_t</span> entry, <span class="type">uint32_t</span> esp)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    task-&gt;parent = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在进程表中进行分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> *<span class="title function_">alloc_task</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *task = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;task_table_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历进程表，找到没有名字的表项</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TASK_NR; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">task_t</span> *curr = task_table + i;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            task = curr;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;task_table_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在进程表中进行释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">task_t</span> *<span class="title function_">free_task</span> <span class="params">(<span class="type">task_t</span> *task)</span> &#123;</span><br><span class="line">    mutex_lock(&amp;task_table_mutex);</span><br><span class="line"></span><br><span class="line">    task-&gt;name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;task_table_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、初始化任务块"><a href="#3、初始化任务块" class="headerlink" title="3、初始化任务块"></a>3、初始化任务块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建子进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *parent_task = task_current();</span><br><span class="line">    <span class="type">task_t</span> *child_task = alloc_task();</span><br><span class="line">    <span class="keyword">if</span> (child_task == (<span class="type">task_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取父进程执行系统调用时压栈的寄存器信息</span></span><br><span class="line">    <span class="type">syscall_frame_t</span> *frame = (<span class="type">syscall_frame_t</span> *)(parent_task-&gt;tss.esp0 - <span class="keyword">sizeof</span>(<span class="type">syscall_frame_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// frame-&gt;eip                                           ==&gt;  父进程执行系统调用的返回地址</span></span><br><span class="line">    <span class="comment">// frame-&gt;esp + sizeof(uint32_t) * SYSCALL_PARAM_COUNT  ==&gt;  恢复到对寄存器状态压栈之前的esp所指向的地址</span></span><br><span class="line">    <span class="type">int</span> err = task_init(child_task, parent_task-&gt;name, <span class="number">0</span>, </span><br><span class="line">                frame-&gt;eip, frame-&gt;esp + <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * SYSCALL_PARAM_COUNT</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">tss_t</span> *tss = &amp;child_task-&gt;tss;</span><br><span class="line">    tss-&gt;eax = <span class="number">0</span>;  <span class="comment">// 设置子进程的eax的返回值，使得调用fork()后子进程返回0</span></span><br><span class="line">    tss-&gt;ebx = frame-&gt;ebx;</span><br><span class="line">    tss-&gt;edx = frame-&gt;edx;</span><br><span class="line">    tss-&gt;ecx = frame-&gt;ecx;</span><br><span class="line">    tss-&gt;esi = frame-&gt;esi;</span><br><span class="line">    tss-&gt;edi = frame-&gt;edi;</span><br><span class="line">    tss-&gt;ebp = frame-&gt;ebp;</span><br><span class="line"></span><br><span class="line">    tss-&gt;cs = frame-&gt;cs;</span><br><span class="line">    tss-&gt;ds = frame-&gt;ds;</span><br><span class="line">    tss-&gt;es = frame-&gt;es;</span><br><span class="line">    tss-&gt;fs = frame-&gt;fs;</span><br><span class="line">    tss-&gt;fs = frame-&gt;gs;</span><br><span class="line">    tss-&gt;eflags = frame-&gt;eflags;</span><br><span class="line"></span><br><span class="line">    child_task-&gt;parent = parent_task;</span><br><span class="line"></span><br><span class="line">    tss-&gt;cr3 = parent_task-&gt;tss.cr3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child_task-&gt;pid;</span><br><span class="line"></span><br><span class="line">fork_failed:</span><br><span class="line">    <span class="keyword">if</span> (child_task) &#123;</span><br><span class="line">        task_uninit(child_task);</span><br><span class="line">        free_task(child_task);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在<code>sys_call()</code>中，当运行到<code>lcalll</code>指令时，会跳转到<code>start.S</code>的代码中执行压栈操作，也就是说此时保存了父进程相关的寄存器的所有信息。因此子进程只要能够也获取到<code>lcalll</code>指令调用时的内存信息，也即找到父进程的<code>syscall_frame_t</code>的指针，就可以获取到上述状态。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405201950719.png" alt="image-20240520195025091"></p>
<p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">syscall_frame_t</span> *frame = (<span class="type">syscall_frame_t</span> *)(parent_task-&gt;tss.esp0 - <span class="keyword">sizeof</span>(<span class="type">syscall_frame_t</span>));</span><br></pre></td></tr></table></figure>



<p>父进程的执行完<code>fork()</code>后，是从特权级为<code>0</code>的代码返回到特权级为<code>3</code>的代码。</p>
<p>但对于子进程来说，只是通过<code>task_init</code>进行了初始化操作，包括对其<code>TSS</code>进行初始化。在父进程执行到<code>return</code>语句时它实际上并未运行，根据<code>first_task.c</code>的逻辑，会在父进程进入<code>msleep(1000);</code>睡眠时，通过任务切换<code>task_dispatch()</code>来切换到子进程中。此时子进程会从自己的<code>TSS</code>中进程对相关的寄存器进行状态恢复。</p>
<p>因此对于子进程来说，初始化子进程时传入的<code>esp</code>参数应该是和父进程的<code>esp</code>一致，但是区别在于子进程没有进行特权级切换，而是直接从特权级<code>3</code>的模式开始运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    pid = fork();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot;task id= %d&quot;</span>, pid);</span><br><span class="line">        <span class="comment">////======///</span></span><br><span class="line">        msleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">////======///</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、复制进程地址空间"><a href="#4、复制进程地址空间" class="headerlink" title="4、复制进程地址空间"></a>4、复制进程地址空间</h3><p>在为子进程创建用户地址空间时，若共用同一页表，实际所用的存储空间就完全处在一页，当涉及到可读写数据时就可能导致冲突。比如，当涉及到栈空间时，父进程可能在执行时对<code>ESP</code>进行修改，这样当切换到子进程运行时，只能得到被破坏的寄存器状态，可能会造成返回出错，导致<code>Page Fault</code>的发生。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202030623.png" alt="image-20240520203019242"></p>
<p>因此，在为子进程创建用户地址空间时，<strong>只需要扫描父进程中<code>0x800000000</code>以上存在映射的地址区域，进行类似的映射。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202057353.png" alt="image-20240520205735959" style="zoom:50%;" />

<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建子进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为子进程分配单独的页表</span></span><br><span class="line">    <span class="keyword">if</span> ((tss-&gt;cr3 = memory_copy_uvm(parent_task-&gt;tss.cr3)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 复制页表及其所有的内存空间 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">memory_copy_uvm</span> <span class="params">(<span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    <span class="comment">// 复制基础页表</span></span><br><span class="line">    <span class="type">uint32_t</span> to_page_dir = memory_create_uvm();</span><br><span class="line">    <span class="keyword">if</span> (to_page_dir == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> copy_uvm_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制页表中用户空间的各项</span></span><br><span class="line">    <span class="type">uint32_t</span> user_pde_start = pde_index(MEM_TASK_BASE);  <span class="comment">// PD表的索引</span></span><br><span class="line">    <span class="type">pde_t</span> *pde = (<span class="type">pde_t</span> *)page_dir + user_pde_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历用户空间页目录项</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = user_pde_start; i &lt; PDE_CNT; i++, pde++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pde-&gt;present) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历页表</span></span><br><span class="line">        <span class="type">pte_t</span> *pte = (<span class="type">pte_t</span> *)pde_paddr(pde);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; PTE_CNT; j++, pte++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pte-&gt;present) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 分配物理内存</span></span><br><span class="line">            <span class="type">uint32_t</span> page = addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (page == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> copy_uvm_failed;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立映射关系</span></span><br><span class="line">            <span class="type">uint32_t</span> vaddr = (i &lt;&lt; <span class="number">22</span>) | (j &lt;&lt; <span class="number">12</span>);</span><br><span class="line">            <span class="type">int</span> err = memory_create_map((<span class="type">pde_t</span> *)to_page_dir, vaddr, page, <span class="number">1</span>, get_pte_perm(pte));</span><br><span class="line">            <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> copy_uvm_failed;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 复制内容</span></span><br><span class="line">            kernel_memcpy((<span class="type">void</span> *)page, (<span class="type">void</span> *)vaddr, MEM_PAGE_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> to_page_dir;</span><br><span class="line"></span><br><span class="line">copy_uvm_failed:</span><br><span class="line">    <span class="keyword">if</span> (to_page_dir) &#123;</span><br><span class="line">        memory_destroy_uvm(to_page_dir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 销毁用户空间内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_destroy_uvm</span> <span class="params">(<span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> user_pde_start = pde_index(MEM_TASK_BASE);</span><br><span class="line">    <span class="type">pde_t</span> * pde = (<span class="type">pde_t</span> *)page_dir + user_pde_start;</span><br><span class="line"></span><br><span class="line">    ASSERT(page_dir != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放页表中对应的各项，不包含映射的内核页面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = user_pde_start; i &lt; PDE_CNT; i++, pde++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pde-&gt;present) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放页表对应的物理页 + 页表</span></span><br><span class="line">        <span class="type">pte_t</span> * pte = (<span class="type">pte_t</span> *)pde_paddr(pde);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; PTE_CNT; j++, pte++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pte-&gt;present) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            addr_free_page(&amp;paddr_alloc, pte_paddr(pte), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addr_free_page(&amp;paddr_alloc, (<span class="type">uint32_t</span>)pde_paddr(pde), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放页目录表</span></span><br><span class="line">    addr_free_page(&amp;paddr_alloc, page_dir, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-2-实现exec系统调用"><a href="#13-2-实现exec系统调用" class="headerlink" title="13.2 实现exec系统调用"></a>13.2 实现exec系统调用</h2><p>创建一个独立的应用程序文件，未来可<strong>单独放在磁盘上，并从磁盘上加载</strong>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202146108.png" alt="image-20240520214639703" style="zoom:50%;" />

<p>对于一个<code>C</code>语言构建的应用程序，其入口地址并不是<code>main()</code>函数，如下图所示。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405202148647.png" alt="image-20240520214815394" style="zoom:50%;" />

<h3 id="1、链接脚本设置"><a href="#1、链接脚本设置" class="headerlink" title="1、链接脚本设置"></a>1、链接脚本设置</h3><p>为了避免和<code>first_task</code>在调试时造成内存地址冲突，将起始地址设置为<code>0x81000000</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = 0x81000000; </span><br><span class="line"></span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ENTRY(_start)</code>这一句中的<code>_start</code>是<code>applib/crt0.S</code>文件的程序入口地址。这样做就是为了满足上图中<code>main</code>函数前还包含<code>crt0</code>和<code>clib</code>的框架结构。</p>
<h3 id="2、创建空exec调用"><a href="#2、创建空exec调用" class="headerlink" title="2、创建空exec调用"></a>2、创建空exec调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib_syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @name 指明进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">execve</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">char</span> * <span class="type">const</span> *argv, <span class="type">char</span> * <span class="type">const</span> *env)</span> &#123;</span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_execve;</span><br><span class="line">    args.arg0 = (<span class="type">int</span>)name;</span><br><span class="line">    args.arg1 = (<span class="type">int</span>)argv;</span><br><span class="line">    args.arg2 = (<span class="type">int</span>)env;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sys_call(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用的转发表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">syscall_handler_t</span> sys_table[] = &#123;</span><br><span class="line">	...</span><br><span class="line">    [SYS_execve] = (<span class="type">syscall_handler_t</span>)sys_execve,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用当前的进程去运行新的程序内容，即加载一个进程，并非创建一个新的进程 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_execve</span> <span class="params">(<span class="type">char</span> *name, <span class="type">char</span> **argv, <span class="type">char</span> **env)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *task = task_current();</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> old_page_dir = task-&gt;tss.cr3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为该进程创建新的页表</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载ELF文件到内存中。要放在开启新页表之后，这样才能对相应的内存区域写</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前进程的页表，并销毁原页表</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">exec_failed:</span><br><span class="line">    <span class="keyword">if</span> (new_page_dir) &#123;</span><br><span class="line">        task-&gt;tss.cr3 = old_page_dir;</span><br><span class="line">        mmu_set_page_dir(old_page_dir);</span><br><span class="line">        memory_destroy_uvm(new_page_dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解析1：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * conts * argv</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>char * const * argv</code> 表示一个指向常量字符指针数组的指针。</li>
<li>用于表示命令行参数的 <code>argv</code>，其中每个参数是一个字符串（<code>char *</code>）。</li>
<li>指针本身是常量（不能改变指向），但指向的内容（字符串）是可以修改的。</li>
</ul>
</blockquote>
<ul>
<li>解析2：为什么执行<code>sys_exec()</code>时，需要创建一个新页表？在<code>fork()</code>时子进程不是已经有了自己的新页表了吗？</li>
</ul>
<blockquote>
<ol>
<li><p>区别解释</p>
</li>
<li><p><code>fork</code> 函数：用于创建一个子进程，这个子进程是当前进程的副本。它会复制当前进程的页表，并在子进程的地址空间中共享同样的物理内存。这样做的目的是让子进程拥有与父进程相同的执行环境。</p>
</li>
</ol>
<ul>
<li><p><strong>页表复制</strong>：<code>fork</code> 时，通过<code>memory_copy_uvm</code>函数为子进程创建一个新的页表，该页表是父进程页表的副本。这使得父子进程各自独立，但初始时共享同样的物理内存。</p>
</li>
<li><p><strong>子进程的返回值</strong>：子进程的<code>eax</code>寄存器被设为0，以便<code>fork</code>系统调用在子进程中返回0，而在父进程中返回子进程的PID。</p>
</li>
</ul>
<ol start="2">
<li><p><code>execve</code> 函数：用于用一个新程序替换当前进程的内容。调用<code>execve</code>后，当前进程的地址空间会被新程序的地址空间替代。</p>
<ul>
<li><p><strong>新页表的创建</strong>：<code>execve</code>需要一个干净的、新的页表，用于加载和运行新的程序。这是因为 <code>execve</code> 的目的是清除当前进程的地址空间并加载新程序，所以必须分配一个新的页表。</p>
</li>
<li><p><strong>加载新程序</strong>：在新页表中加载新的程序，这样可以确保新程序有一个干净的内存环境，不受之前进程状态的影响。</p>
</li>
<li><p><strong>销毁旧页表</strong>：一旦新程序成功加载，旧的页表被销毁，以释放不再需要的资源。</p>
</li>
</ul>
</li>
<li><p>执行流程中的细节</p>
</li>
</ol>
<p> 在<code>sys_execve</code>函数中，以下步骤确保了这一点：</p>
<ol>
<li><p><strong>旧页表的保存</strong>；</p>
</li>
<li><p><strong>新页表的创建</strong>；</p>
</li>
<li><p><strong>加载新程序</strong>；</p>
</li>
<li><p><strong>切换到新页表</strong>。</p>
</li>
<li><p>总结：这种设计方式确保了每个系统调用的预期功能和行为：<code>fork</code> 保留现有执行环境，而 <code>execve</code> 则彻底替换执行环境。</p>
</li>
</ol>
<ul>
<li><p><code>fork</code> 通过复制当前进程的页表，为子进程创建了一个新的、但初始内容相同的地址空间。</p>
</li>
<li><p><code>execve</code> 通过创建一个全新的页表并加载新程序，确保新程序在一个干净的内存环境中运行。</p>
</li>
</ul>
</blockquote>
<h3 id="3、添加虚拟文件访问接口"><a href="#3、添加虚拟文件访问接口" class="headerlink" title="3、添加虚拟文件访问接口"></a>3、添加虚拟文件访问接口</h3><p>为实现应用程序的加载，需要完成两点工作：</p>
<ul>
<li>分配相应的存储空间；</li>
<li>从<code>ELF</code>文件中读取数据并写入内存页中。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211017716.png" alt="image-20240521101728080"></p>
<p>目前仍未实现文件系统，因此采用下图的方式进行简单实现，只针对<code>shell.elf</code>文件进行处理：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211019558.png" alt="image-20240521101905366"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/include/fs/fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FS_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FS_H_</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> flags, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_lseek</span><span class="params">(<span class="type">int</span> file, <span class="type">int</span> ptr, <span class="type">int</span> dir)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_close</span><span class="params">(<span class="type">int</span> file)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _FS_H_</span></span></span><br></pre></td></tr></table></figure>

<h3 id="4、解析并加载ELF文件"><a href="#4、解析并加载ELF文件" class="headerlink" title="4、解析并加载ELF文件"></a>4、解析并加载ELF文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加载一个Phdr的数据到内存中</span></span><br><span class="line"><span class="comment"> * @param phdr      要加载的程序头</span></span><br><span class="line"><span class="comment"> * @param page_dir  程序头加载到的页表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_phdr</span><span class="params">(<span class="type">int</span> file, Elf32_Phdr *phdr, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    <span class="comment">// 生成的ELF文件要求是页边界对齐的</span></span><br><span class="line">    ASSERT((phdr-&gt;p_vaddr &amp; (MEM_PAGE_SIZE - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    <span class="type">int</span> err = memory_alloc_page_for_page_dir(page_dir, phdr-&gt;p_vaddr, phdr-&gt;p_memsz, PTE_P | PTE_U | PTE_W);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;no memory&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整当前的读写位置</span></span><br><span class="line">    <span class="comment">// 具体来说，指针需要从Phdr的位置移动到该Phdr指向的代码/数据段的具体位置，也即p_offset参数</span></span><br><span class="line">    <span class="keyword">if</span> (sys_lseek(file, phdr-&gt;p_offset, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为段分配所有的内存空间，后续操作如果失败将在上层释放</span></span><br><span class="line">    <span class="type">uint32_t</span> vaddr = phdr-&gt;p_vaddr;     <span class="comment">// 内存中的起始地址，只针对传入的新创建的page_dir参数有效</span></span><br><span class="line">    <span class="type">uint32_t</span> size = phdr-&gt;p_filesz;     <span class="comment">// 要拷贝的文件大小</span></span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断当前需要被拷贝的大小，一次最多只能拷贝一页</span></span><br><span class="line">        <span class="type">int</span> curr_size = (size &gt; MEM_PAGE_SIZE) ? MEM_PAGE_SIZE : size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到当前vaddr在page_dir中对应的物理地址</span></span><br><span class="line">        <span class="type">uint32_t</span> paddr = memory_get_paddr(page_dir, vaddr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这里传入(char *)vaddr，会将新页表中对应的内存地址传给当前使用的旧页表中</span></span><br><span class="line">        <span class="keyword">if</span> (sys_read(file, (<span class="type">char</span> *)paddr, curr_size) &lt; curr_size) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size -= curr_size;</span><br><span class="line">        vaddr += curr_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加载elf文件到内存中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">load_elf_file</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    Elf32_Ehdr elf_hdr;</span><br><span class="line">    Elf32_Phdr elf_phdr;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> file = sys_open(name, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (file &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;open failed. %s&quot;</span>, name);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先，读取文件头（ELF Header）</span></span><br><span class="line">    <span class="type">int</span> cnt = sys_read(file, (<span class="type">char</span> *)&amp;elf_hdr, <span class="keyword">sizeof</span>(elf_hdr));</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; <span class="keyword">sizeof</span>(Elf32_Ehdr)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;elf hdr too small. size= %d&quot;</span>, cnt);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做必要性检查</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr.e_ident[<span class="number">0</span>] != <span class="number">0x7F</span>) || (elf_hdr.e_ident[<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">        || (elf_hdr.e_ident[<span class="number">2</span>] != <span class="string">&#x27;L&#x27;</span>) || (elf_hdr.e_ident[<span class="number">3</span>] != <span class="string">&#x27;F&#x27;</span>)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;check elf indent failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须是可执行文件和针对386处理器的类型，且有入口</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr.e_type != ET_EXEC) || (elf_hdr.e_machine != ET_386) || (elf_hdr.e_entry == <span class="number">0</span>)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;check elf type or entry failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须有程序头部</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr.e_phentsize == <span class="number">0</span>) || (elf_hdr.e_phoff == <span class="number">0</span>)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;none programe header&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次，读取程序头（Program Header），将内容拷贝到相应的位置</span></span><br><span class="line">    <span class="type">uint32_t</span> e_phoff = elf_hdr.e_phoff;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elf_hdr.e_phnum; i++, e_phoff += elf_hdr.e_phentsize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sys_lseek(file, e_phoff, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取程序头后解析，这里不用读取到新进程的页表中，因为只是临时使用下</span></span><br><span class="line">        cnt = sys_read(file, (<span class="type">char</span> *)&amp;elf_phdr, <span class="keyword">sizeof</span>(Elf32_Phdr));</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="keyword">sizeof</span>(Elf32_Phdr)) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单做一些检查，主要判断是否是可加载的类型，并且要求加载的地址必须是用户空间</span></span><br><span class="line">        <span class="keyword">if</span> ((elf_phdr.p_type != PT_LOAD) || (elf_phdr.p_vaddr &lt; MEM_TASK_BASE)) &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载当前程序头</span></span><br><span class="line">        <span class="type">int</span> err = load_phdr(file, &amp;elf_phdr, page_dir);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;load program hdr failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    sys_close(file);</span><br><span class="line">    <span class="keyword">return</span> elf_hdr.e_entry;</span><br><span class="line"></span><br><span class="line">load_failed:</span><br><span class="line">    <span class="keyword">if</span> (file &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sys_close(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>有一个要注意的点在于：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211223596.png" alt="image-20240521122318108"></p>
<p>绿色框中框出的这两部分看起来好像是连续的，实际在对其进行拷贝时会发现它并非是连续的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">load_elf_file</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载当前程序头</span></span><br><span class="line">    <span class="comment">// =============================================== //</span></span><br><span class="line">    <span class="type">int</span> err = load_phdr(file, &amp;elf_phdr, page_dir);</span><br><span class="line">    <span class="comment">// =============================================== //</span></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;load program hdr failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> load_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_phdr</span><span class="params">(<span class="type">int</span> file, Elf32_Phdr *phdr, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// =============================================== //</span></span><br><span class="line">    <span class="comment">// 为所有的段分配内存空间并复制</span></span><br><span class="line">    <span class="comment">// =============================================== //</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述程序，在<code>21</code>行调用<code>load_phdr()</code>时传入了新建进程时新创建的页表<code>page_dir</code>，但在<code>load_phdr()</code>内部执行到段分配空间并复制时，实际用到的并非是这个新创建的<code>page_dir</code>，而是<code>first_task</code>在运行时创建的那个页表。</p>
<p>由于在<code>page_dir</code>这个页表中包含的映射关系并未被启用，也就是说在这个新页表中连续的一段内存空间在原来的页表中实际上是不连续的。需要将原页表的内容不连续地拷贝到新页表中。</p>
<p>需要像下面这样操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到当前vaddr在page_dir中对应的物理地址</span></span><br><span class="line"><span class="type">uint32_t</span> paddr = memory_get_paddr(page_dir, vaddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这里传入(char *)vaddr，会将新页表中对应的内存地址传给当前使用的旧页表中</span></span><br><span class="line"><span class="keyword">if</span> (sys_read(file, (<span class="type">char</span> *)paddr, curr_size) &lt; curr_size) &#123;</span><br><span class="line">    log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、分配栈并进入进程执行"><a href="#5、分配栈并进入进程执行" class="headerlink" title="5、分配栈并进入进程执行"></a>5、分配栈并进入进程执行</h3><p>新进程的栈分配空间与<code>first_task</code>可能不相同。</p>
<p><code>first_task</code>的栈是紧挨着<code>.bss</code>段放置的，整体的空间不够大，对于<code>shell</code>来说，当后期涉及到堆空间以及一些较大的栈空间需求时很会麻烦，因此需要重新建立。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_TASK_STACK_TOP  0xE0000000              <span class="comment">// shell进程的栈空间起始地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_TASK_STACK_SIZE     (MEM_PAGE_SIZE * 500)   <span class="comment">// shell进程的栈空间大小</span></span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211449653.png" alt="image-20240521144933288" style="zoom:50%;" />

<p>这个新分配的栈是需要返回给<code>shell</code>使用在特权级<code>3</code>的状态下的，但进程在使用时也会涉及到系统调用和中断等处理。因此，对于操作系统相关的代码可以<strong>继续使用原来建立的特权级<code>0</code>的栈</strong>，此处只需要对<strong>新分配属于自己的特权级<code>3</code>的栈</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211451843.png" alt="image-20240521145151527"></p>
<p>特权级<code>0</code>的栈保存了<code>frst_task</code>的相关信息，由于此处对于原来的页表进行了销毁，因此若不做相应的处理，返回到的内存地址处实际上是没有任何有效信息的，会造成错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新当前进程的页表</span></span><br><span class="line">task-&gt;tss.cr3 = new_page_dir;</span><br><span class="line">mmu_set_page_dir(new_page_dir);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁原来的旧页表</span></span><br><span class="line">memory_destroy_uvm(old_page_dir);</span><br></pre></td></tr></table></figure>

<p>因此<strong>在更新页表前（上述代码）</strong>，需要先找到特权级<code>0</code>的栈，并对其中的相关寄存器值进行修改，以便在系统调用返回时能够切换回到<code>shell</code>进程中。</p>
<p>对寄存器值的修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用当前的进程去运行新的程序内容，即加载一个进程，并非创建一个新的进程 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_execve</span> <span class="params">(<span class="type">char</span> *name, <span class="type">char</span> **argv, <span class="type">char</span> **env)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载完毕，为程序的执行做必要准备</span></span><br><span class="line">    <span class="comment">// 注意，exec的作用是替换掉当前进程，所以只要改变当前进程的执行流即可</span></span><br><span class="line">    <span class="comment">// 当该进程恢复运行时，像完全重新运行一样，所以用户栈要设置成初始模式</span></span><br><span class="line">    <span class="comment">// 运行地址要设备成整个程序的入口地址</span></span><br><span class="line">    <span class="type">syscall_frame_t</span> * frame = (<span class="type">syscall_frame_t</span> *)(task-&gt;tss.esp0 - <span class="keyword">sizeof</span>(<span class="type">syscall_frame_t</span>));</span><br><span class="line">    frame-&gt;eip = entry;  <span class="comment">// 修改为shell进程的入口地址</span></span><br><span class="line">    frame-&gt;eax = frame-&gt;ebx = frame-&gt;ecx = frame-&gt;edx = <span class="number">0</span>;</span><br><span class="line">    frame-&gt;esi = frame-&gt;edi = frame-&gt;ebp = <span class="number">0</span>;</span><br><span class="line">    frame-&gt;eflags = EFLAGS_DEFAULT| EFLAGS_IF;  <span class="comment">// 段寄存器无需修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内核栈不用设置，保持不变，后面调用memory_destroy_uvm并不会销毁内核栈的映射。</span></span><br><span class="line">    <span class="comment">// 但用户栈需要更改, 同样要加上调用门的参数压栈空间</span></span><br><span class="line">    frame-&gt;esp = stack_top - <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * SYSCALL_PARAM_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前进程的页表</span></span><br><span class="line">    task-&gt;tss.cr3 = new_page_dir;</span><br><span class="line">    mmu_set_page_dir(new_page_dir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁原来的旧页表</span></span><br><span class="line">    memory_destroy_uvm(old_page_dir);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、为进程传递参数"><a href="#6、为进程传递参数" class="headerlink" title="6、为进程传递参数"></a>6、为进程传递参数</h3><p><code>cstart.c</code>实际上是有参数的，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cstart</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    main(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// argc 存储参数的总个数，含应用程序的名字</span></span><br><span class="line"><span class="comment">// argv 参数的字符串指针数组</span></span><br></pre></td></tr></table></figure>

<p>在<code>C</code>语言中，如果需要传参的话，会将参数放入栈中。而此时的<code>esp = 0xE0000000</code>，对于当前进程来说，此时的参数保存在<code> 0xE0000000</code>以上的位置，但实际上此处是并未分配内存的，因此会造成异常。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211557399.png" alt="image-20240521155717841" style="zoom:50%;" />

<p>因此，在调用<code>main</code>函数之前，需要先往栈中压入<code>argc/argv</code>参数值：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211620385.png" alt="image-20240521162034894" style="zoom:50%;" />

<p>修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程参数结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_args_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> ret_addr;</span><br><span class="line">    <span class="type">uint32_t</span> argc;</span><br><span class="line">    <span class="type">char</span> **argv;</span><br><span class="line">&#125; <span class="type">task_args_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用当前的进程去运行新的程序内容，即加载一个进程，并非创建一个新的进程 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_execve</span> <span class="params">(<span class="type">char</span> *name, <span class="type">char</span> **argv, <span class="type">char</span> **env)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配用户栈空间，预留环境环境及参数的空间</span></span><br><span class="line">    <span class="type">uint32_t</span> stack_top = MEM_TASK_STACK_TOP - MEM_TASK_ARG_SIZE;</span><br><span class="line">    <span class="type">int</span> err = memory_alloc_page_for_page_dir(</span><br><span class="line">        new_page_dir, </span><br><span class="line">        MEM_TASK_STACK_TOP - MEM_TASK_STACK_SIZE,</span><br><span class="line">        MEM_TASK_STACK_SIZE,</span><br><span class="line">        PTE_P | PTE_U | PTE_W</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> exec_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制参数，写入到栈顶的后边</span></span><br><span class="line">    <span class="type">int</span> argc = string_count(argv);</span><br><span class="line">    err = copy_args((<span class="type">char</span> *)stack_top, new_page_dir, argc, argv);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> exec_failed;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）参数拷贝函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 参数拷贝</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param to        要拷贝到何处</span></span><br><span class="line"><span class="comment"> * @param page_dir  对应的页表</span></span><br><span class="line"><span class="comment"> * @param argc      要拷贝的参数个数</span></span><br><span class="line"><span class="comment"> * @param argv      要拷贝的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_args</span><span class="params">(<span class="type">char</span> *to, <span class="type">uint32_t</span> page_dir, <span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// 在stack_top中依次写入argc, argv指针，参数字符串</span></span><br><span class="line">    <span class="type">task_args_t</span> task_args;</span><br><span class="line">    task_args.argc = argc;</span><br><span class="line">    task_args.argv = (<span class="type">char</span> **)(to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制各项参数, 跳过task_args和参数表</span></span><br><span class="line">    <span class="comment">// 定义各argv参数写入的内存空间</span></span><br><span class="line">    <span class="type">char</span> * dest_arg = to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>) + <span class="keyword">sizeof</span>(<span class="type">char</span> *) * (argc);   <span class="comment">// 留出结束符</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// argv表</span></span><br><span class="line">    <span class="type">char</span> ** dest_argv_tb = (<span class="type">char</span> **)memory_get_paddr(page_dir, (<span class="type">uint32_t</span>)(to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>)));</span><br><span class="line">    ASSERT(dest_argv_tb != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="type">char</span> *from = argv[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能用kernel_strcpy，因为to和argv不在一个页表里</span></span><br><span class="line">        <span class="type">int</span> len = kernel_strlen(from) + <span class="number">1</span>;  <span class="comment">// +1是为了加上&#x27;\0&#x27;</span></span><br><span class="line">        <span class="type">int</span> err = memory_copy_uvm_data((<span class="type">uint32_t</span>)dest_arg, page_dir, (<span class="type">uint32_t</span>)from, len);</span><br><span class="line">        ASSERT(err &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关联字符串与对应的字符串指针</span></span><br><span class="line">        dest_argv_tb[i] = dest_arg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录下位置后，复制的位置前移</span></span><br><span class="line">        dest_arg += len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入task_args</span></span><br><span class="line">    <span class="keyword">return</span> memory_copy_uvm_data((<span class="type">uint32_t</span>)to, page_dir, (<span class="type">uint32_t</span>)&amp;task_args, <span class="keyword">sizeof</span>(task_args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task_args.argv = (<span class="type">char</span> **)(to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>));  <span class="comment">// 得到char **argv的起始地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *dest_arg = to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>) + <span class="keyword">sizeof</span>(<span class="type">char</span> *) * argc;  <span class="comment">// 获取argv中具体的每一个字符串的起始地址</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211649751.png" alt="image-20240521164949480" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task_args.argv = (<span class="type">char</span> **)(to + <span class="keyword">sizeof</span>(<span class="type">task_args_t</span>));  <span class="comment">// 得到argv的起始地址</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211641068.png" alt="image-20240521164157766" style="zoom:50%;" />

<p>（2）重要函数：在不同的页表间拷贝数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在不同的页表间拷贝数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param to        要拷贝的目的地址</span></span><br><span class="line"><span class="comment"> * @param page_dir  地址所在的页表</span></span><br><span class="line"><span class="comment"> *                  注意传入的page_dir为新页表，而当前仍在使用旧页表，因此需要结合物理地址来操作</span></span><br><span class="line"><span class="comment"> * @param from      当前地址</span></span><br><span class="line"><span class="comment"> * @param size      拷贝的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memory_copy_uvm_data</span><span class="params">(<span class="type">uint32_t</span> to, <span class="type">uint32_t</span> page_dir, <span class="type">uint32_t</span> from, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取to对应的物理地址</span></span><br><span class="line">        <span class="type">uint32_t</span> to_paddr = memory_get_paddr(page_dir, to);</span><br><span class="line">        <span class="keyword">if</span> (to_paddr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// to_paddr在自己所在物理页的偏移量</span></span><br><span class="line">        <span class="type">uint32_t</span> offset_in_page = to_paddr &amp; (MEM_PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将from的数据拷贝到该偏移量处</span></span><br><span class="line">        <span class="type">uint32_t</span> curr_size = MEM_PAGE_SIZE - offset_in_page;</span><br><span class="line">        <span class="keyword">if</span> (curr_size &gt; size) &#123;</span><br><span class="line">            curr_size = size;</span><br><span class="line">        &#125;</span><br><span class="line">        kernel_memcpy((<span class="type">void</span> *)to_paddr, (<span class="type">void</span> *)from, curr_size);</span><br><span class="line"></span><br><span class="line">        size -= curr_size;</span><br><span class="line">        to += curr_size;</span><br><span class="line">        from += curr_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-3-实现sys-yiled系统调用"><a href="#13-3-实现sys-yiled系统调用" class="headerlink" title="13.3 实现sys_yiled系统调用"></a>13.3 实现sys_yiled系统调用</h2><h3 id="1、解决task-init遗留问题"><a href="#1、解决task-init遗留问题" class="headerlink" title="1、解决task_init遗留问题"></a>1、解决task_init遗留问题</h3><p>在<code>sys_fork()</code>中，创建子进程时会调用<code>task_init()</code>函数，在这个函数中会对进程进行初始化，然后就加入<code>ready_list</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务加入ready_list</span></span><br><span class="line">task_set_ready(task);</span><br></pre></td></tr></table></figure>

<p>但在<code>sys_fork()</code>中，执行的逻辑是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建子进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 对子进程进行初始化，并对必要的字段进行调整</span></span><br><span class="line">    <span class="type">int</span> err = task_init(child_task, parent_task-&gt;name, <span class="number">0</span>, </span><br><span class="line">                frame-&gt;eip, frame-&gt;esp + <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * SYSCALL_PARAM_COUNT</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从父进程的栈中取部分状态，然后写入子进程的tss</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为子进程分配单独的页表</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child_task-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，在<code>#8</code>行就将这个子进程加入<code>ready_list</code>中了，但此时的子进程仍未初始化完毕，包括对<code>TSS</code>以及对内存空间等的初始化，此时若发生了定时中断，就会发生<code>task_dispatch()</code>，切换到还未初始化完成的子进程中进行，造成错误。如下图所示，在执行完<code>first_task</code>的相关任务后，运行到<code>shell</code>进程的<code>fork()</code>操作时，会出现<code>CPU</code>重启：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shell/main.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot;arg: %s&quot;</span>, (<span class="type">int</span>)argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fork();</span><br><span class="line">    yield();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot;shell pid=%d&quot;</span>, getpid());</span><br><span class="line">        msleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405211941992.png" alt="image-20240521194153623"></p>
<p>因此，需要对<code>task_init()</code>进行修改，删除加入就绪队列的部分，并新建一个函数专门用于启动进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 启动任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_start</span><span class="params">(<span class="type">task_t</span> * task)</span> &#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line">    </span><br><span class="line">    task_set_ready(task);</span><br><span class="line">    </span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、测试sys-yield"><a href="#2、测试sys-yield" class="headerlink" title="2、测试sys_yield()"></a>2、测试sys_yield()</h3><p><code>fork()</code>会调用两次。</p>
<p>出现异常：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221254675.png" alt="image-20240522125434543"></p>
<p>调试结果如下：</p>
<blockquote>
<p>根据提供的信息，故障发生时的关键寄存器和状态如下：</p>
<ul>
<li><strong>CS</strong>: 8 (内核代码段)</li>
<li><strong>EIP</strong>: 0x13757</li>
<li><strong>EAX</strong>: 0x13E000 (发生Page fault时访问的地址)</li>
<li><strong>ESP</strong>: 0x12FF2C</li>
<li><strong>EFLAGS</strong>: 0x206</li>
<li><strong>Error code</strong>: 11 (0000 1011)</li>
</ul>
<ul>
<li>Page fault错误代码分析</li>
</ul>
<ol>
<li>错误代码<code>11</code>（0000 1011）解释如下：</li>
</ol>
<ul>
<li><p>第0位（P）：0，表示该页没有被加载到内存中。</p>
</li>
<li><p>第1位（W&#x2F;R）：1，表示是写操作引起的。</p>
</li>
<li><p>第2位（U&#x2F;S）：1，表示是用户模式访问引起的。</p>
</li>
<li><p>第3位（RSV）：0，保留位。</p>
</li>
</ul>
<ol start="2">
<li>错误原因分析</li>
</ol>
<p>根据错误代码和寄存器值，访问地址0x13E000没有被映射到内存中，导致Page fault。发生Page fault的地方在0x13757，表示发生错误的指令位于该地址。</p>
<ol start="3">
<li><p>可能原因及排查步骤</p>
</li>
<li><p><strong>检查页表和内存管理</strong>：</p>
<ul>
<li>确保在fork过程中，子进程正确地继承和复制了父进程的页表。</li>
<li>在<code>sys_execve</code>过程中，确保新的页表正确创建和切换。</li>
<li>确保<code>memory_copy_uvm</code>函数正确地复制了页表。</li>
</ul>
</li>
<li><p><strong>查看发生异常的代码段</strong>：</p>
<ul>
<li>确定<code>EIP</code>值0x13757处的代码在执行什么操作。可能需要反汇编或调试来了解具体指令。</li>
</ul>
</li>
<li><p><strong>检查栈和寄存器状态</strong>：</p>
<ul>
<li><p>确认栈指针（ESP）和基址指针（EBP）的值是否合理。</p>
</li>
<li><p>检查<code>sys_execve</code>和<code>sys_fork</code>过程中对栈的操作是否正确。</p>
</li>
</ul>
</li>
<li><p><strong>日志和调试信息</strong>：</p>
<ul>
<li>增加更多日志，特别是在切换页表和分配内存时，记录相关操作的详细信息。</li>
</ul>
</li>
</ol>
</blockquote>
<h1 id="十四、使用c标准库中的printf输出"><a href="#十四、使用c标准库中的printf输出" class="headerlink" title="十四、使用c标准库中的printf输出"></a>十四、使用c标准库中的printf输出</h1><p>本章节搭建了文件系统框架，引入了字符设备驱动程序，并引用<code>newlib</code>。</p>
<h2 id="14-1-增加文件系统调用"><a href="#14-1-增加文件系统调用" class="headerlink" title="14.1 增加文件系统调用"></a>14.1 增加文件系统调用</h2><p>整理<code>app</code>库下面的所有文件：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405220934175.png" alt="image-20240522093404627" style="zoom:50%;" />

<p>在<code>libapp.a</code>中包含了<code>lib_syscall.c</code>相关的代码。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405220952365.png" alt="image-20240522095247136"></p>
<p>因此在将<code>lib_syscall.h</code>中的内联函数修改到<code>lib_syscall.c</code>中后，需要将<code>shell</code>工程与<code>applib.a</code>这个库链接起来。</p>
<p>在<code>kernel/CMakeLists.txt</code>中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(LIBS_FLAGS &quot;-L $&#123;CMAKE_BINARY_DIR&#125;/source/applib/ -lapp&quot;)</span><br><span class="line">set(CMAKE_EXE_LINKER_FLAGS &quot;-m elf_i386  -T $&#123;PROJECT_SOURCE_DIR&#125;/kernel.lds $&#123;LIBS_FLAGS&#125;&quot;)</span><br></pre></td></tr></table></figure>



<p>此时调试，会发现进入<code>getpid()</code>内部时出现异常，其中	<code>EIP=0x13D77</code>，说明是在<code>1MB</code>空间内出现了异常。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">3</span>;  <span class="comment">// 父子进程各自拥有一份自己的count</span></span><br><span class="line">    <span class="type">int</span> pid = getpid();  <span class="comment">// here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405220958926.png" alt="image-20240522095820675"></p>
<p>在<code>kernel_dis.txt</code>文件中对<code>getpid()</code>进程搜索，发现其所处的位置即在<code>1MB</code>空间内。但它作为一个系统调用的接口函数，不应该放在操作系统空间内，而应该放在用户进程空间内，即<code>0x80000000</code>以上的位置。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221000006.png" alt="image-20240522100021888"></p>
<p>因此需要对<code>kernel/kernel.lds</code>进行修改，将<code>applib</code>相关的代码和数据放到<code>0x80000000</code>以上的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">. = 0x80000000;</span><br><span class="line">PROVIDE(s_first_task = LOADADDR(.first_task));</span><br><span class="line">.first_task : AT(e_data) &#123;</span><br><span class="line">	*first_task_entry*(.text .rodata .bss .data)</span><br><span class="line">	*first_task*(.text .rodata .bss .data)</span><br><span class="line">	*lib_syscall*(.text .rodata .bss .data)</span><br><span class="line">&#125;</span><br><span class="line">PROVIDE(e_first_task = LOADADDR(.first_task) + SIZEOF(.first_task));</span><br></pre></td></tr></table></figure>

<p>再次调试，<code>EIP</code>的地址正确：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221007171.png" alt="image-20240522100723076"></p>
<h2 id="14-2-导入newlib-c并引入printf"><a href="#14-2-导入newlib-c并引入printf" class="headerlink" title="14.2 导入newlib c并引入printf"></a>14.2 导入newlib c并引入printf</h2><p><code>newlib</code>库简介：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221022455.png" alt="image-20240522102216196"></p>
<p>引入<code>newlib</code>库之后的整体结构：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221023403.png" alt="image-20240522102346233" style="zoom:50%;" />

<p>在<code>shell</code>工程中引入<code>newlib</code>库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(LIBS_FLAGS &quot;-L $&#123;CMAKE_BINARY_DIR&#125;/source/applib/ -lapp -L $&#123;CMAKE_BINARY_DIR&#125;/../../newlib/i686-elf/lib -lm -lc&quot;)</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221057186.png" alt="image-20240522105741951"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221059676.png" alt="image-20240522105925398"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加载elf文件到内存中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">load_elf_file</span> <span class="params">(<span class="type">task_t</span> *task, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> page_dir)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次，读取程序头（Program Header），将内容拷贝到相应的位置</span></span><br><span class="line">    <span class="type">uint32_t</span> e_phoff = elf_hdr.e_phoff;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elf_hdr.e_phnum; i++, e_phoff += elf_hdr.e_phentsize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sys_lseek(file, e_phoff, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取程序头后解析，这里不用读取到新进程的页表中，因为只是临时使用下</span></span><br><span class="line">        cnt = sys_read(file, (<span class="type">char</span> *)&amp;elf_phdr, <span class="keyword">sizeof</span>(Elf32_Phdr));</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="keyword">sizeof</span>(Elf32_Phdr)) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;read file failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单做一些检查，主要判断是否是可加载的类型，并且要求加载的地址必须是用户空间</span></span><br><span class="line">        <span class="keyword">if</span> ((elf_phdr.p_type != PT_LOAD) || (elf_phdr.p_vaddr &lt; MEM_TASK_BASE)) &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载当前程序头</span></span><br><span class="line">        <span class="type">int</span> err = load_phdr(file, &amp;elf_phdr, page_dir);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;load program hdr failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> load_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ========================= 新增 ========================= //</span></span><br><span class="line">        <span class="comment">// 设置first_task的堆起始地址和结束地址</span></span><br><span class="line">        task-&gt;heap_start = elf_phdr.p_vaddr + elf_phdr.p_memsz;  </span><br><span class="line">        	<span class="comment">// 通过循环，最终指向进程地址空间中最后一个表项的末端地址</span></span><br><span class="line">        	<span class="comment">// 也就是指向.bss的末端地址</span></span><br><span class="line">        task-&gt;heap_end = task-&gt;heap_start;</span><br><span class="line">        <span class="comment">// ========================= 新增 ========================= //</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、sbrk"><a href="#1、sbrk" class="headerlink" title="1、sbrk()"></a>1、sbrk()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 调整堆的内存分配，返回堆之前的指针</span></span><br><span class="line"><span class="comment"> *        目前并不处理incr小于0的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">sys_sbrk</span><span class="params">(<span class="type">int</span> incr)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> *task = task_current();</span><br><span class="line">    <span class="type">int</span> pre_incr = incr;</span><br><span class="line">    <span class="type">char</span> *pre_heap_end = (<span class="type">char</span> *)task-&gt;heap_end;  <span class="comment">// 获取当前堆的末端地址</span></span><br><span class="line"></span><br><span class="line">    ASSERT(incr &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (incr == <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;sbrk(0): end=0x%x&quot;</span>, pre_heap_end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre_heap_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增长空间的起始地址（即原末端地址），和末端地址</span></span><br><span class="line">    <span class="type">uint32_t</span> start = task-&gt;heap_end;</span><br><span class="line">    <span class="type">uint32_t</span> end = start + incr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x81001024 - 0x81001048      0x81001024并非页边界对齐 ： 0x81001000 </span></span><br><span class="line">    <span class="comment">// 0x81001000 - 0x81001FFF      假定这块内存已经存在</span></span><br><span class="line">    <span class="type">int</span> start_offset = start % MEM_PAGE_SIZE;  <span class="comment">// 0x24，start地址在页中的偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (start_offset) &#123;</span><br><span class="line">        <span class="comment">// 若起始地址并非页边界对齐</span></span><br><span class="line">        <span class="keyword">if</span> (start_offset + incr &lt;= MEM_PAGE_SIZE) &#123;</span><br><span class="line">            <span class="comment">// 0x24 + incr 若并未超过一页，直接在原内存中分配</span></span><br><span class="line">            task-&gt;heap_end = end;  <span class="comment">// 0x81001048</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> pre_heap_end;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若超过一页，则先分配掉一页</span></span><br><span class="line">            <span class="type">uint32_t</span> curr_size = MEM_PAGE_SIZE - start_offset;  <span class="comment">// 当前页可分配内存</span></span><br><span class="line">            start += curr_size;</span><br><span class="line">            incr -= curr_size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若incr还有剩余，则新分配页来处理</span></span><br><span class="line">    <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> curr_size = end - start;</span><br><span class="line">        <span class="type">int</span> err = memory_alloc_page_for(start, curr_size, PTE_P | PTE_U | PTE_W);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;sbrk: alloc mem failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">char</span> *)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_printf(<span class="string">&quot;sbrk(%d): end = 0x%x&quot;</span>, pre_incr, end);</span><br><span class="line">    task-&gt;heap_end = end;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span> * )pre_heap_end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib_syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    sbrk(<span class="number">0</span>);</span><br><span class="line">    sbrk(<span class="number">100</span>);</span><br><span class="line">    sbrk(<span class="number">200</span>);</span><br><span class="line">    sbrk(<span class="number">4096</span> * <span class="number">2</span> + <span class="number">200</span>);</span><br><span class="line">    sbrk(<span class="number">4096</span> * <span class="number">5</span> + <span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from shell\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot; -- arg: %s&quot;</span>, (<span class="type">int</span>)argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fork();</span><br><span class="line">    yield();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        print_msg(<span class="string">&quot;shell pid=%d&quot;</span>, getpid());</span><br><span class="line">        msleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221251345.png" alt="image-20240522125116933"></p>
<h3 id="2、printf"><a href="#2、printf" class="headerlink" title="2、printf()"></a>2、printf()</h3><p><code>printf()</code>最终会通过文件系统的接口，将格式化好的数据写入标准输出。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405221944469.png" alt="image-20240522194431100" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 写文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    ptr[len] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 加入结束符</span></span><br><span class="line">    log_printf(<span class="string">&quot;%s&quot;</span>, ptr);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十五、使用控制台与键盘进行输入输出"><a href="#十五、使用控制台与键盘进行输入输出" class="headerlink" title="十五、使用控制台与键盘进行输入输出"></a>十五、使用控制台与键盘进行输入输出</h1><h2 id="15-1-控制台简介"><a href="#15-1-控制台简介" class="headerlink" title="15.1 控制台简介"></a>15.1 控制台简介</h2><p>操作系统启动后可以分为图形模式和文本模式。但图形界面并不是一个操作系统必须的组件。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230918110.png" alt="image-20240523091843752" style="zoom:50%;" />

<p><strong>每个</strong>显示的字符由<strong>两个</strong>配置字节数据控制：</p>
<ul>
<li>一个字节用于显示的字符；</li>
<li>一个字节用于配置显示属性。</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230920616.png" alt="image-20240523092019270" style="zoom: 50%;" />

<p>计算机上电启动后，显示器默认设置成<code>80列x25行</code>的文本显示模式。一屏的显示需要<code>80*25*2=4000</code>字节的显存，因此<code>32KB</code>可以装下<code>8</code>屏幕的显示内容。</p>
<ul>
<li><p>可以同时在几个虚拟屏幕上显示，相当于打开多个命令行窗口并显示相应的内容；<strong>（本项目主要实现）</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230925271.png" alt="image-20240523092543957" style="zoom:50%;" />
</li>
<li><p>也可以将<code>32KB</code>显存分成<code>8</code>块，每块分别用于显示虚拟的控制台界面。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405230926563.png" alt="image-20240523092610198" style="zoom:50%;" /></li>
</ul>
<h2 id="15-2-在控制台上显示字符串"><a href="#15-2-在控制台上显示字符串" class="headerlink" title="15.2 在控制台上显示字符串"></a>15.2 在控制台上显示字符串</h2><h3 id="1、控制台结构体定义"><a href="#1、控制台结构体定义" class="headerlink" title="1、控制台结构体定义"></a>1、控制台结构体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符颜色</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">color_t</span> &#123;</span></span><br><span class="line">    COLOR_Black			= <span class="number">0</span>,</span><br><span class="line">    COLOR_Blue			= <span class="number">1</span>,</span><br><span class="line">    COLOR_Green			= <span class="number">2</span>,</span><br><span class="line">    COLOR_Cyan			= <span class="number">3</span>,</span><br><span class="line">    COLOR_Red			= <span class="number">4</span>,</span><br><span class="line">    COLOR_Magenta		= <span class="number">5</span>,</span><br><span class="line">    COLOR_Brown			= <span class="number">6</span>,</span><br><span class="line">    COLOR_Gray			= <span class="number">7</span>,</span><br><span class="line">    COLOR_Dark_Gray 	= <span class="number">8</span>,</span><br><span class="line">    COLOR_Light_Blue	= <span class="number">9</span>,</span><br><span class="line">    COLOR_Light_Green	= <span class="number">10</span>,</span><br><span class="line">    COLOR_Light_Cyan	= <span class="number">11</span>,</span><br><span class="line">    COLOR_Light_Red		= <span class="number">12</span>,</span><br><span class="line">    COLOR_Light_Magenta	= <span class="number">13</span>,</span><br><span class="line">    COLOR_Yellow		= <span class="number">14</span>,</span><br><span class="line">    COLOR_White			= <span class="number">15</span></span><br><span class="line">&#125;<span class="type">color_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述显存字符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">disp_char_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">char</span> foreground : <span class="number">4</span>;</span><br><span class="line">        <span class="type">char</span> background : <span class="number">3</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint16_t</span> v;  <span class="comment">// 16位，一个字节表示字符；另一个字节表示属性</span></span><br><span class="line">&#125;<span class="type">disp_char_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">console_t</span> &#123;</span></span><br><span class="line">    <span class="type">disp_char_t</span> *disp_base;             <span class="comment">// 控制台基地址</span></span><br><span class="line">    <span class="type">int</span> disp_rows, disp_cols;           <span class="comment">// 总的行列数</span></span><br><span class="line">    <span class="type">int</span> cursor_row, cursor_col;         <span class="comment">// 当前光标所在的行列数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">color_t</span> foreground, background;     <span class="comment">// 字符颜色</span></span><br><span class="line">&#125;<span class="type">console_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、显示字符串"><a href="#2、显示字符串" class="headerlink" title="2、显示字符串"></a>2、显示字符串</h3><p>目前的所有写操作都定向到了<code>fs.c</code>部分，在<code>sys_write()</code>中采用<code>log_printf()</code>来输出，对其进行修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 写文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    console_write(<span class="number">0</span>, ptr, len);</span><br><span class="line">    <span class="comment">// ptr[len] = &#x27;\0&#x27;;</span></span><br><span class="line">    <span class="comment">// log_printf(&quot;%s&quot;, ptr);</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此时调试，进入页异常：<code>Page doesn&#39;t present 0xB80A0</code>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231017216.png" alt="image-20240523101700997"></p>
<p>这是因为在创建内核页表时，没有加入显存部分的映射：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建内核页表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_kernel_table</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 地址映射表, 用于建立内核级的地址映射</span></span><br><span class="line">    <span class="comment">// 地址不变，但是添加了属性</span></span><br><span class="line">    <span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">        &#123;kernel_base,   s_text,         <span class="number">0</span>,              PTE_W&#125;,                           <span class="comment">// 内核栈区</span></span><br><span class="line">        &#123;s_text,        e_text,         s_text,         <span class="number">0</span>&#125;,                               <span class="comment">// 内核代码区</span></span><br><span class="line">        &#123;s_data,        (<span class="type">void</span> *)(MEM_EBDA_START - <span class="number">1</span>),   s_data,        PTE_W&#125;,            <span class="comment">// 内核数据区</span></span><br><span class="line">        <span class="comment">// ========================================== 新增 ========================================== //</span></span><br><span class="line">        &#123;(<span class="type">void</span> *)CONSOLE_DISP_ADDR, (<span class="type">void</span> *)CONSOLE_DISP_END, (<span class="type">void</span> *)CONSOLE_DISP_ADDR, PTE_W&#125;,  <span class="comment">// 控制台</span></span><br><span class="line">        <span class="comment">// ========================================== 新增 ========================================== //</span></span><br><span class="line">        &#123;(<span class="type">void</span> *)MEM_EXT_START, (<span class="type">void</span> *)MEM_EXT_END,     (<span class="type">void</span> *)MEM_EXT_START, PTE_W&#125;,   <span class="comment">// 扩展存储空间一一映射，方便直接操作</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串显示函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 控制台写内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param console 要写第几块控制台，所以传入int</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 写入的字符数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">console_write</span> <span class="params">(<span class="type">int</span> console, <span class="type">char</span> *data, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> *c = console_buf + console;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; size; len++) &#123;</span><br><span class="line">        <span class="comment">// 依次取出要写入的字符</span></span><br><span class="line">        <span class="type">char</span> ch = *data++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行写入操作，显示字符串</span></span><br><span class="line">        show_char(c, ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的输出结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231024410.png" alt="image-20240523102431257"></p>
<p>对上述函数进行改进：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 控制台写内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param console 要写第几块控制台，所以传入int</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 写入的字符数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">console_write</span> <span class="params">(<span class="type">int</span> console, <span class="type">char</span> *data, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> *c = console_buf + console;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; size; len++) &#123;</span><br><span class="line">        <span class="comment">// 依次取出要写入的字符</span></span><br><span class="line">        <span class="type">char</span> ch = *data++;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">                move_to_col0(console);      <span class="comment">// 行号不变，列号变0</span></span><br><span class="line">                move_next_line(console);    <span class="comment">// 行号下移，列号不变</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:         </span><br><span class="line">            <span class="comment">// 执行写入操作，显示字符串</span></span><br><span class="line">            show_char(c, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、清屏"><a href="#3、清屏" class="headerlink" title="3、清屏"></a>3、清屏</h3><p>只需要将当前屏幕对应的显存显示内容全部用空格符清空，或者用前景色和后景色相同的字符清空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 清屏操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_diaplay</span><span class="params">(<span class="type">console_t</span> *console)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算整个屏幕的字符量</span></span><br><span class="line">    <span class="type">int</span> size = console-&gt;disp_cols * console-&gt;disp_rows;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从基地址开始依次遍历</span></span><br><span class="line">    <span class="type">disp_char_t</span> *start = console-&gt;disp_base;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++, start++) &#123;</span><br><span class="line">        start-&gt;c = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        start-&gt;foreground = console-&gt;foreground;</span><br><span class="line">        start-&gt;background = console-&gt;background;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、滚屏"><a href="#4、滚屏" class="headerlink" title="4、滚屏"></a>4、滚屏</h3><p>注意以下两种情况需要滚屏：</p>
<ul>
<li>1）当光标前移时，若到达行末尾处需要移动到下一行，此时就需要判断当前是否需要滚屏；</li>
<li>2）在控制台写入内容时，若遇到换行操作，也需要判断当前是否需要滚屏。</li>
</ul>
<p>将除最底部的行外全部上移一行，再将最下边一行清空。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231031828.png" alt="image-20240523103159602" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 擦除从start到end的行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">erase_rows</span> <span class="params">(<span class="type">console_t</span> * console, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">disp_char_t</span> * disp_start = console-&gt;disp_base + console-&gt;disp_cols * start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">disp_char_t</span> * disp_end = console-&gt;disp_base + console-&gt;disp_cols * (end + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (disp_start &lt; disp_end) &#123;</span><br><span class="line">        disp_start-&gt;c = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        disp_start-&gt;foreground = console-&gt;foreground;</span><br><span class="line">        disp_start-&gt;background = console-&gt;background;</span><br><span class="line"></span><br><span class="line">        disp_start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 整体屏幕上移若干行</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param lines 上移的行数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">scroll_up</span><span class="params">(<span class="type">console_t</span> * console, <span class="type">int</span> lines)</span> &#123;</span><br><span class="line">    <span class="comment">// 整体上移</span></span><br><span class="line">    <span class="type">disp_char_t</span> * dest = console-&gt;disp_base;</span><br><span class="line">    <span class="type">disp_char_t</span> * src = console-&gt;disp_base + console-&gt;disp_cols * lines;</span><br><span class="line">    <span class="comment">// console-&gt;disp_rows - lines    上移后剩余的行数A</span></span><br><span class="line">    <span class="comment">// A *console-&gt;disp_cols         整体剩余的字符数（也就是上移后需要显示字符数）</span></span><br><span class="line">    <span class="type">uint32_t</span> size = (console-&gt;disp_rows - lines) * console-&gt;disp_cols * <span class="keyword">sizeof</span>(<span class="type">disp_char_t</span>);</span><br><span class="line">    kernel_memcpy(dest, src, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 擦除最后一行</span></span><br><span class="line">    erase_rows(console, console-&gt;disp_rows - lines, console-&gt;disp_rows - <span class="number">1</span>);</span><br><span class="line">    console-&gt;cursor_row -= lines;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-3-设置光标并重定向日志输出到显示器"><a href="#15-3-设置光标并重定向日志输出到显示器" class="headerlink" title="15.3 设置光标并重定向日志输出到显示器"></a>15.3 设置光标并重定向日志输出到显示器</h2><p>光标的位置分<strong>高8位和低8位</strong>两部分来表示，由于当前显示为<code>80*25</code>，共<code>2000</code>个字符，所以位置取值为<code>0~1999</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 读取当前光标的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_cursor_pos</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line"></span><br><span class="line"> 	outb(<span class="number">0x3D4</span>, <span class="number">0x0F</span>);		<span class="comment">// 写低地址</span></span><br><span class="line">	pos = inb(<span class="number">0x3D5</span>);</span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0x0E</span>);		<span class="comment">// 写高地址</span></span><br><span class="line">	pos |= inb(<span class="number">0x3D5</span>) &lt;&lt; <span class="number">8</span>;   </span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 更新鼠标的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_cursor_pos</span> <span class="params">(<span class="type">console_t</span> * console)</span> &#123;</span><br><span class="line">	<span class="type">uint16_t</span> pos = console-&gt;cursor_row *  console-&gt;display_cols + console-&gt;cursor_col;</span><br><span class="line"></span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0x0F</span>);		<span class="comment">// 写低地址</span></span><br><span class="line">	outb(<span class="number">0x3D5</span>, (<span class="type">uint8_t</span>) (pos &amp; <span class="number">0xFF</span>));</span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0x0E</span>);		<span class="comment">// 写高地址</span></span><br><span class="line">	outb(<span class="number">0x3D5</span>, (<span class="type">uint8_t</span>) ((pos &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-4-保存并恢复光标位置"><a href="#15-4-保存并恢复光标位置" class="headerlink" title="15.4 保存并恢复光标位置"></a>15.4 保存并恢复光标位置</h2><p><code>ANSI</code>转义序列(<code>ANSI escape sequences</code>)，可用于控制视频终端上的光标位置、颜色和其他选项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\0337Hello, world!\0338123\n&quot;</span>);  <span class="comment">// 123lo,world!</span></span><br></pre></td></tr></table></figure>

<p><code>\0337</code>在<code>7</code>的位置保存光标位置，然后在<code>\0338</code>中<code>8</code>的位置用<code>123</code>进行替换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 普通状态下的字符的写入处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_normal</span> <span class="params">(<span class="type">console_t</span> * console, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> ASCII_ESC:</span><br><span class="line">            console-&gt;write_state = CONSOLE_WRITE_ESC;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 写入以ESC开头的序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_esc</span> <span class="params">(<span class="type">console_t</span> * console, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// https://blog.csdn.net/ScilogyHunter/article/details/106874395</span></span><br><span class="line">    <span class="comment">// ESC状态处理, 转义序列模式 ESC 0x20-0x27(0或多个) 0x30-0x7e</span></span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:		<span class="comment">// ESC 7 保存光标</span></span><br><span class="line">            save_cursor(console);</span><br><span class="line">            console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:		<span class="comment">// ESC 8 恢复光标</span></span><br><span class="line">            restore_cursor(console);</span><br><span class="line">            console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 控制台写内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param console 要写第几块控制台，所以传入int</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 写入的字符数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">console_write</span> <span class="params">(<span class="type">int</span> console, <span class="type">char</span> *data, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> *c = console_buf + console;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; size; len++) &#123;</span><br><span class="line">        <span class="comment">// 依次取出要写入的字符</span></span><br><span class="line">        <span class="type">char</span> ch = *data++;</span><br><span class="line">        <span class="keyword">switch</span> (c-&gt;write_state) &#123;</span><br><span class="line">            <span class="keyword">case</span> CONSOLE_WRITE_NORMAL: &#123;</span><br><span class="line">                write_normal(c, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CONSOLE_WRITE_ESC:</span><br><span class="line">                write_esc(c, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update_cursor_pos(c);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-5-更新显示字体的颜色"><a href="#15-5-更新显示字体的颜色" class="headerlink" title="15.5 更新显示字体的颜色"></a>15.5 更新显示字体的颜色</h2><blockquote>
<p>详见《LINUX内核完全剖析：基于0.12内核》附录部分。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231527961.png" alt="image-20240523152720901" style="zoom:50%;" />&#96;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理ESC [Pn;Pn 开头的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_esc_square</span> <span class="params">(<span class="type">console_t</span> * console, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 接收参数</span></span><br><span class="line">    <span class="keyword">if</span> ((c &gt;= <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (c &lt;= <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 解析当前参数</span></span><br><span class="line">        <span class="type">int</span> * param = &amp;console-&gt;esc_param[console-&gt;curr_param_index];</span><br><span class="line">        *param = *param * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c == <span class="string">&#x27;;&#x27;</span>) &amp;&amp; console-&gt;curr_param_index &lt; ESC_PARAM_MAX) &#123;</span><br><span class="line">        <span class="comment">// 参数结束，继续处理下一个参数</span></span><br><span class="line">        console-&gt;curr_param_index++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 结束上一字符的处理</span></span><br><span class="line">        console-&gt;curr_param_index++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已经接收到所有的字符，继续处理</span></span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: <span class="comment">// 设置字符属性</span></span><br><span class="line">            set_font_style(console);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:	<span class="comment">// 光标左移n个位置 ESC [Pn D</span></span><br><span class="line">            move_left(console, console-&gt;esc_param[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            move_right(console, console-&gt;esc_param[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">            move_cursor(console);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>:</span><br><span class="line">            erase_in_display(console);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-6-键盘初始化"><a href="#15-6-键盘初始化" class="headerlink" title="15.6 键盘初始化"></a>15.6 键盘初始化</h2><p>计算机中使用键盘控制器(<code>8042</code>)控制鼠标和键盘。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231600337.png" alt="image-20240523160008317" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231601872.png" alt="image-20240523160123502" style="zoom: 80%;" />

<p><strong>只需要对键盘的中断进行重写设置，而不需要自己去重新初始化键盘。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kbd_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    irq_install(IRQ1_KEYBOARD, (<span class="type">irq_handler_t</span>)exception_handler_kbd);</span><br><span class="line">    irq_enable(IRQ1_KEYBOARD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_kbd</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在<code>init/start.S</code>中进行增加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 硬件中断</span><br><span class="line">exception_handler kbd, 0x21, 0</span><br></pre></td></tr></table></figure>

<h2 id="15-7-借助按键映射表进行键值转换"><a href="#15-7-借助按键映射表进行键值转换" class="headerlink" title="15.7 借助按键映射表进行键值转换"></a>15.7 借助按键映射表进行键值转换</h2><p>当按键按下时和弹出时，都会产生一串扫描码，<strong>其数值并不与键盘上的字符ASCII相同</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231618145.png" alt="image-20240523161852835"></p>
<h1 id="十六、设备管理与文件系统"><a href="#十六、设备管理与文件系统" class="headerlink" title="十六、设备管理与文件系统"></a>十六、设备管理与文件系统</h1><h2 id="16-1-设备管理框架"><a href="#16-1-设备管理框架" class="headerlink" title="16.1 设备管理框架"></a>16.1 设备管理框架</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231934732.png" alt="image-20240523193407466" style="zoom:50%;" />

<p>在计算系统中，往往有很多种不同类型的设备，操作系统需要对这些设备进行统一管理。为每种类型设备都提供一套操作接口并不现实，且操作系统难以处理。因此，需要对设备进行“<strong>抽象</strong>”，得到所谓的“<strong>设备管理层</strong>”，负责对不同类型的设备进行抽象管理。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231936141.png" alt="image-20240523193634814" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231936997.png" alt="image-20240523193649716" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_NAME_SIZE       32</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DEV_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">dev_desc_t</span>;</span></span><br><span class="line"><span class="comment">// 特定设备结构（定义该类设备下特殊设备的特殊性质）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">device_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dev_desc_t</span> *<span class="title">desc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mode;       <span class="comment">// 特殊属性</span></span><br><span class="line">    <span class="type">int</span> minor;      <span class="comment">// 次设备号（主次设备号决定具体是哪个设备）</span></span><br><span class="line">    <span class="type">void</span> *data;     <span class="comment">// 设备相关参数</span></span><br><span class="line">    <span class="type">int</span> open_count; <span class="comment">// 设备打开次数</span></span><br><span class="line">&#125;<span class="type">device_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象设备结构（定义某类设备的一般特性）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">dev_desc_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[DEV_NAME_SIZE];   <span class="comment">// 设备名称</span></span><br><span class="line">    <span class="type">int</span> major;                  <span class="comment">// 主设备号</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="type">device_t</span> *dev);</span><br><span class="line">    <span class="type">int</span> (*read)(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size);</span><br><span class="line">    <span class="type">int</span> (*write)(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size);</span><br><span class="line">    <span class="type">int</span> (*control)(<span class="type">device_t</span> *dev, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="type">device_t</span> *dev);</span><br><span class="line">&#125;<span class="type">dev_desc_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="16-2-增加tty设备"><a href="#16-2-增加tty设备" class="headerlink" title="16.2 增加tty设备"></a>16.2 增加tty设备</h2><h3 id="1、理论-1"><a href="#1、理论-1" class="headerlink" title="1、理论"></a>1、理论</h3><p>由于键盘和显示器密切相关，因此将二者抽象为一种硬件设备<code>tty</code>。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231949301.png" alt="image-20240523194931067" style="zoom:50%;" />

<p>操作系统需要提供一套抽象机制，对所有设备进行抽象管理，以向上屏蔽复杂的硬件细节。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405231950402.png" alt="image-20240523195038914"></p>
<p>上图中左边的<code>5</code>个函数最终会被注册到<code>_dev_desc_t</code>的<code>5</code>个函数指针中。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232005483.png" alt="image-20240523200517185"  />

<h3 id="2、增加tty设备的过程"><a href="#2、增加tty设备的过程" class="headerlink" title="2、增加tty设备的过程"></a>2、增加<code>tty</code>设备的过程</h3><ol>
<li><p>新增<code>tty.c</code>和<code>tty.h</code>；</p>
</li>
<li><p>在<code>tty.c</code>中实现<code>tty</code>相应的设备管理操作；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_open</span> <span class="params">(<span class="type">device_t</span> *dev)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_write</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_control</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1)</span>;</span><br></pre></td></tr></table></figure>

<p>并将上述操作注册到<code>dev_desc_t</code>中，定义一个<code>dev_tty_desc</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dev_desc_t</span> dev_tty_desc = &#123;</span><br><span class="line">    .name = <span class="string">&quot;tty&quot;</span>,</span><br><span class="line">    .major = DEV_TTY,</span><br><span class="line">    .open = tty_open,</span><br><span class="line">    .read = tty_read,</span><br><span class="line">    .write = tty_write,</span><br><span class="line">    .control = tty_control,</span><br><span class="line">    .close = tty_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>dev.c</code>中声明外部变量<code>dev_tty_desc</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">dev_desc_t</span> dev_tty_desc;</span><br></pre></td></tr></table></figure>

<p>接下来根据<code>tty</code>相关操作实现上层接口函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dev_open</span> <span class="params">(<span class="type">int</span> major, <span class="type">int</span> minor, <span class="type">void</span> *data)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_read</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_write</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_control</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_close</span> <span class="params">(<span class="type">int</span> dev_id)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为<code>tty</code>设备添加结构描述</p>
<p>根据<code>32KB</code>显存可显示<code>8</code>块屏幕，将键盘与<code>8</code>块（虚拟）屏幕共享：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232032635.png" alt="image-20240523203230358" style="zoom: 67%;" />

<p>因此，为所有设备定义一个<code>tty</code>数组，分别对应一部分显存。但是，由于操作系统的运行速度很快，因此向设备发送指令&#x2F;数据也很快；但设备的速度很慢，所以硬件写指令&#x2F;数据很慢，所以需要在设备驱动中配置缓存，用于解决这种速度不匹配的问题。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232037597.png" alt="image-20240523203716361"></p>
</li>
</ol>
<p>当前在<code>log.c</code>中采用<code>console_write()</code>进行打印操作，但未来也可能有其他的设备需要进行打印操作，因此需要进行修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> log_dev_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化日志输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    mutex_init(&amp;mutex);</span><br><span class="line">    log_dev_id = dev_open(DEV_TTY, <span class="number">0</span>, (<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 日志打印</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// console_write(0, str_buf, kernel_strlen(str_buf));</span></span><br><span class="line">    dev_write(log_dev_id, <span class="number">0</span>, str_buf, kernel_strlen(str_buf));</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">// console_write(0, &amp;c, 1);</span></span><br><span class="line">    dev_write(log_dev_id, <span class="number">0</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样后续修改设备时，只需要在初始化时对<code>dev_open</code>进行改动即可。</p>
<h3 id="3、定义tty设备"><a href="#3、定义tty设备" class="headerlink" title="3、定义tty设备"></a>3、定义tty设备</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_IBUF_SIZE				512		<span class="comment">// tty输入缓存大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_OBUF_SIZE				512		<span class="comment">// tty输出缓存大小</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的 FIFO（First In, First Out）缓冲区，</span></span><br><span class="line"><span class="comment"> * 用于在字符设备（例如终端）中管理数据流。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tty_fifo_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *buf;      <span class="comment">// 指向存储缓冲区数据的指针</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">// 缓冲区的最大字节数</span></span><br><span class="line">    <span class="type">int</span> read;       <span class="comment">// 当前读位置的索引</span></span><br><span class="line">    <span class="type">int</span> write;      <span class="comment">// 当前写位置的索引</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 缓冲区中已有的数据量</span></span><br><span class="line">&#125;<span class="type">tty_fifo_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tty_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> obuf[TTY_OBUF_SIZE];  <span class="comment">// 输出缓冲区</span></span><br><span class="line">    <span class="type">tty_fifo_t</span> ofifo;          <span class="comment">// 输出FIFO队列</span></span><br><span class="line">    <span class="type">char</span> ibuf[TTY_IBUF_SIZE];  <span class="comment">// 输入缓冲区</span></span><br><span class="line">    <span class="type">tty_fifo_t</span> ififo;          <span class="comment">// 输入处理后的FIFO队列</span></span><br><span class="line">&#125;<span class="type">tty_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4、打开tty设备"><a href="#4、打开tty设备" class="headerlink" title="4、打开tty设备"></a>4、打开tty设备</h3><p>当<code>write</code>指向队列尾部时，会重新移到队头的位置，直到整个队列中没有空闲位置。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232051032.png" alt="image-20240523205100776" style="zoom:50%;" />

<p>由于整个系统中存在多个<code>tty</code>设备，因此对于键盘的初始化应该仅设置为一次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kbd_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> inited = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!inited) &#123;</span><br><span class="line">        irq_install(IRQ1_KEYBOARD, (<span class="type">irq_handler_t</span>)exception_handler_kbd);</span><br><span class="line">        irq_enable(IRQ1_KEYBOARD);</span><br><span class="line"></span><br><span class="line">        inited = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于<code>console</code>的初始化，需要区别第<code>0</code>块还是其他块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 控制台初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">console_init</span> <span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> *console = console_buf + idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里类型转换为disp_char_t *，那么CONSOLE_COL_MAX * CONSOLE_ROW_MAX就不必再乘以2</span></span><br><span class="line">    <span class="comment">// uint16_t *v = 0x1234;</span></span><br><span class="line">    <span class="comment">// v++;  // v = 0x1236，会按照uint16_t的类型来自增</span></span><br><span class="line">    console-&gt;disp_base = (<span class="type">disp_char_t</span> *)(CONSOLE_DISP_ADDR + idx *(CONSOLE_COL_MAX * CONSOLE_ROW_MAX));</span><br><span class="line"></span><br><span class="line">    console-&gt;disp_cols = CONSOLE_COL_MAX;</span><br><span class="line">    console-&gt;disp_rows = CONSOLE_ROW_MAX;</span><br><span class="line">    console-&gt;foreground = COLOR_White;</span><br><span class="line">    console-&gt;background = COLOR_Black;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console-&gt;cursor_col = 0;  不这样写，避免清空Boot和Loader的信息</span></span><br><span class="line">    <span class="comment">// console-&gt;cursor_row = 0;</span></span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> cursor_pos = read_cursor_pos();</span><br><span class="line">        console-&gt;cursor_row = cursor_pos / console-&gt;disp_cols;</span><br><span class="line">        console-&gt;cursor_col = cursor_pos % console-&gt;disp_cols;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        console-&gt;cursor_row = <span class="number">0</span>;</span><br><span class="line">        console-&gt;cursor_col = <span class="number">0</span>;    </span><br><span class="line">        clear_display(console);</span><br><span class="line">        update_cursor_pos(console);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console-&gt;old_cursor_row = console-&gt;cursor_row;</span><br><span class="line">    console-&gt;old_cursor_col = console-&gt;cursor_col;</span><br><span class="line"></span><br><span class="line">    console-&gt;write_state = CONSOLE_WRITE_NORMAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、通过tty设备写显示数据"><a href="#5、通过tty设备写显示数据" class="headerlink" title="5、通过tty设备写显示数据"></a>5、通过tty设备写显示数据</h3><p>下图所示的缓存按字节存储数据，其中<code>write</code>指向下一待写入数据的位置，<code>read</code>指向下一数据读取的位置。</p>
<p>注项目中实际并未涉及到中断部分。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232118966.png" alt="image-20240523211809752" style="zoom:50%;" />

<p>最简单的方式，进程向硬件写入数据，然后等待硬件发送完成，再写入数据，如此反复，直到所有数据发送完毕。整个过程效率很低。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232120477.png" alt="image-20240523212056141"  />

<p>当加入缓存后，整个实现机制就改变了。一般情况下，进程负责向缓存写入数据，然后启动硬件发送机制，之后由硬件自动完成所有数据的发送，从而完成高效率地数据发送机制。</p>
<p>相比查询来说，速度要更快，进程不必等待。也就是说，在要发送的数据量小于缓存区的大小时，进程只需要将数据丢入缓存区即可退出，不需要再去考虑硬件的后续处理。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232122435.png" alt="image-20240523212223213"></p>
<p>当调用到<code>console_write()</code>时的调用堆栈如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405232144307.png" alt="image-20240523214408045"></p>
<h2 id="16-3-文件系统初始化"><a href="#16-3-文件系统初始化" class="headerlink" title="16.3 文件系统初始化"></a>16.3 文件系统初始化</h2><p>操作系统使用文件系统对磁盘上的存储进行管理，给应用程序提供以文件组织的视图。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405240932371.png" alt="image-20240524093221478"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405240932986.png" alt="image-20240524093256519"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405240933690.png" alt="image-20240524093348655"></p>
<p>定义相关结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_NAME_SIZE      32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_TABLE_SIZE     2048</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">file_type_t</span> &#123;</span></span><br><span class="line">    FILE_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">    FILE_TTY,</span><br><span class="line">&#125;<span class="type">file_type_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">file_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> file_name[FILE_NAME_SIZE];     <span class="comment">// 文件名称</span></span><br><span class="line">    <span class="type">file_type_t</span> type;                   <span class="comment">// 文件类型</span></span><br><span class="line">    <span class="type">uint32_t</span> size;                      <span class="comment">// 文件大小</span></span><br><span class="line">    <span class="type">int</span> ref;                            <span class="comment">// 文件打开次数</span></span><br><span class="line">    <span class="type">int</span> dev_id;                         <span class="comment">// 文件对应设备号</span></span><br><span class="line">    <span class="type">int</span> pos;                            <span class="comment">// 文件当前读取位置</span></span><br><span class="line">    <span class="type">int</span> mode;                           <span class="comment">// 文件读取模式，只读/读写</span></span><br><span class="line">&#125;<span class="type">file_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">file_table_init</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">file_t</span> *<span class="title function_">file_alloc</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">file_free</span> <span class="params">(<span class="type">file_t</span> *file)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="16-4-为进程添加文件打开表"><a href="#16-4-为进程添加文件打开表" class="headerlink" title="16.4 为进程添加文件打开表"></a>16.4 为进程添加文件打开表</h3><p>在实际应用场合中，往往同时运行着很多应用进程，每个应用进程都可能会进行文件的读写操作。因此，存在下列问题：</p>
<ul>
<li>每个进程需要记录自己打开了哪些文件；</li>
<li>同一件文件可能同时被多个进程同时打开。</li>
</ul>
<p>因此，为了实现文件打开的共享，每个进程只保存一个指针表，其中每项指向自己所打开的文件描述符。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405241450969.png" alt="image-20240524145013782" style="zoom:50%;" />



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_alloc_fd</span> <span class="params">(<span class="type">file_t</span> *file)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">task_remove_fd</span> <span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">file_t</span> *<span class="title function_">task_file</span> <span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="16-4-打开tty设备并向其写入数据"><a href="#16-4-打开tty设备并向其写入数据" class="headerlink" title="16.4 打开tty设备并向其写入数据"></a>16.4 打开tty设备并向其写入数据</h2><p>文件系统是处于设备管理层之上的。如果对文件进行相应的操作，不能直接调用tty相关的代码，因此文件系统调用设备管理相关的代码，其再调用tty相关的代码。</p>
<p>也就是说，调用层级从高到低依次如下：<code>sys-&gt;dev-&gt;tty</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> flags, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_lseek</span><span class="params">(<span class="type">int</span> file, <span class="type">int</span> ptr, <span class="type">int</span> dir)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_close</span><span class="params">(<span class="type">int</span> file)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_isatty</span><span class="params">(<span class="type">int</span> file)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_fstat</span><span class="params">(<span class="type">int</span> file, <span class="keyword">struct</span> stat *st)</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dev.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_open</span> <span class="params">(<span class="type">int</span> major, <span class="type">int</span> minor, <span class="type">void</span> *data)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_read</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_write</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_control</span> <span class="params">(<span class="type">int</span> dev_id, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_close</span> <span class="params">(<span class="type">int</span> dev_id)</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tty.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_open</span> <span class="params">(<span class="type">device_t</span> *dev)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_write</span> <span class="params">(<span class="type">device_t</span> * dev, <span class="type">int</span> addr, <span class="type">char</span> * buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_control</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> cmd, <span class="type">int</span> arg0, <span class="type">int</span> arg1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_close</span> <span class="params">(<span class="type">device_t</span> *dev)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="16-5-从tty读取键值字符串并显示"><a href="#16-5-从tty读取键值字符串并显示" class="headerlink" title="16.5 从tty读取键值字符串并显示"></a>16.5 从tty读取键值字符串并显示</h2><p>原理图如下：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242032828.png" alt="image-20240524203218224" style="zoom:50%;" />

<h3 id="1、向缓冲区写入，并通知硬件数据已到达"><a href="#1、向缓冲区写入，并通知硬件数据已到达" class="headerlink" title="1、向缓冲区写入，并通知硬件数据已到达"></a>1、向缓冲区写入，并通知硬件数据已到达</h3><p>当有按键按下时，调用<code>tty_in()</code>，此时：</p>
<p>1）首先通过信号量判断缓冲区是否有空闲区域；</p>
<p>2）若有，则会将按下的字符<code>ch</code>放入<code>ififo</code>缓冲区，并通过<code>sem_notify()</code>通知硬件有数据到达；</p>
<p>3）否则，进入等待状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kbd.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理单字符的标准键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_normal_key</span> <span class="params">(<span class="type">uint8_t</span> raw_code)</span> &#123;</span><br><span class="line">    <span class="type">char</span> key = get_key(raw_code);		<span class="comment">// 去掉最高位</span></span><br><span class="line">    <span class="type">int</span> is_make = is_make_code(raw_code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂时只处理按键按下的状态</span></span><br><span class="line">	<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (is_make) &#123;</span><br><span class="line">            ...</span><br><span class="line">            tty_in(<span class="number">0</span>, key);  <span class="comment">// important</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tty.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 输入tty字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_in</span> <span class="params">(<span class="type">int</span> idx, <span class="type">char</span> ch)</span> &#123;</span><br><span class="line">	<span class="type">tty_t</span> *tty = tty_devs + idx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将ch放入ififo缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> (sem_count(&amp;tty-&gt;isem) &gt;= TTY_IBUF_SIZE) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写入辅助队列，通知数据到达</span></span><br><span class="line">	tty_fifo_put(&amp;tty-&gt;ififo, ch);</span><br><span class="line">	sem_notify(&amp;tty-&gt;isem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、从缓冲区读取数据"><a href="#2、从缓冲区读取数据" class="headerlink" title="2、从缓冲区读取数据"></a>2、从缓冲区读取数据</h3><p>通过缓存实现进程和中断之间的配合。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *pbuf = buf;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;  <span class="comment">// 当前读取长度</span></span><br><span class="line">	<span class="comment">// 遍历buf读数据</span></span><br><span class="line">	<span class="keyword">while</span> (len &lt; size) &#123;</span><br><span class="line">		sem_wait(&amp;tty-&gt;isem);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> ch;</span><br><span class="line">		<span class="comment">// 从缓冲区取数据</span></span><br><span class="line">		tty_fifo_get(&amp;tty-&gt;ififo, &amp;ch);</span><br><span class="line">       ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-6-打开标准输出及错误输出文件"><a href="#16-6-打开标准输出及错误输出文件" class="headerlink" title="16.6 打开标准输出及错误输出文件"></a>16.6 打开标准输出及错误输出文件</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242035079.png" alt="image-20240524203555183"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242040884.png" alt="image-20240524204007541"></p>
<blockquote>
<p>在操作系统中，TTY设备（终端设备）通常与标准输入输出文件（即 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code>）关联，以便用户能够通过终端设备与系统交互。具体的关联机制可能因操作系统的不同而有所差异，但大致可以分为以下几个步骤和组件：</p>
<ol>
<li><strong>设备驱动与设备文件的关联</strong></li>
</ol>
<p>TTY设备的驱动程序定义了如何与实际的终端硬件进行交互。设备文件（如 <code>/dev/tty</code>）是设备驱动的一个接口，使用户空间程序可以通过文件系统与设备驱动交互。设备文件通常在操作系统启动时由设备驱动创建并注册到文件系统中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// TTY设备驱动的初始化</span></span><br><span class="line">&gt;<span class="type">void</span> <span class="title function_">tty_init</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 注册TTY设备</span></span><br><span class="line">   <span class="type">dev_desc_t</span> dev_tty_desc = &#123;</span><br><span class="line">       .name = <span class="string">&quot;tty&quot;</span>,</span><br><span class="line">       .major = DEV_TTY,</span><br><span class="line">       .open = tty_open,</span><br><span class="line">       .read = tty_read,</span><br><span class="line">       .write = tty_write,</span><br><span class="line">       .control = tty_control,</span><br><span class="line">       .close = tty_close,</span><br><span class="line">   &#125;;</span><br><span class="line">   register_device(&amp;dev_tty_desc);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>设备文件与文件描述符的关联</strong></li>
</ol>
<p>当用户空间的程序打开一个TTY设备文件时，内核会为该设备文件分配一个文件描述符，并将该文件描述符与TTY设备驱动的操作函数（如 <code>open</code>、<code>read</code>、<code>write</code> 等）关联起来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 打开TTY设备文件</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">tty_open</span><span class="params">(<span class="type">device_t</span> *dev)</span> &#123;</span><br><span class="line">   <span class="comment">// 初始化TTY设备</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 读取TTY设备文件</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">tty_read</span><span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">   <span class="comment">// 从TTY设备读取数据</span></span><br><span class="line">   <span class="keyword">return</span> size;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 写入TTY设备文件</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">tty_write</span><span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">   <span class="comment">// 向TTY设备写入数据</span></span><br><span class="line">   <span class="keyword">return</span> size;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>标准输入输出与文件描述符的关联</strong></li>
</ol>
<p>在程序启动时，操作系统会为标准输入输出（<code>stdin</code>、<code>stdout</code>、<code>stderr</code>）分配文件描述符（通常是 <code>0</code>、<code>1</code> 和 <code>2</code>），并将这些文件描述符与TTY设备文件关联起来。这使得程序可以通过标准输入输出进行与终端设备的交互。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">void</span> <span class="title function_">setup_standard_io</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 打开标准输入</span></span><br><span class="line">   <span class="type">file_t</span> *stdin_file = sys_open(<span class="string">&quot;/dev/tty&quot;</span>, O_RDONLY);</span><br><span class="line">   curr_task-&gt;file_table[<span class="number">0</span>] = stdin_file;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 打开标准输出</span></span><br><span class="line">   <span class="type">file_t</span> *stdout_file = sys_open(<span class="string">&quot;/dev/tty&quot;</span>, O_WRONLY);</span><br><span class="line">   curr_task-&gt;file_table[<span class="number">1</span>] = stdout_file;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 打开标准错误输出</span></span><br><span class="line">   <span class="type">file_t</span> *stderr_file = sys_open(<span class="string">&quot;/dev/tty&quot;</span>, O_WRONLY);</span><br><span class="line">   curr_task-&gt;file_table[<span class="number">2</span>] = stderr_file;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>关联关系图</strong></li>
</ol>
<p>以下是TTY设备与标准输入输出文件关联关系的思维导图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;lua复制代码+----------------------+           +----------------------+</span><br><span class="line">&gt;| 用户空间程序        |           | 操作系统             |</span><br><span class="line">&gt;|                      |           |                      |</span><br><span class="line">&gt;| +------------------+ |           | +------------------+ |</span><br><span class="line">&gt;| | 标准输入（stdin）| |           | | TTY设备文件      | |</span><br><span class="line">&gt;| +------------------+ |           | +------------------+ |</span><br><span class="line">&gt;| | 标准输出（stdout）| |           | | 设备驱动        | |</span><br><span class="line">&gt;| +------------------+ |           | +------------------+ |</span><br><span class="line">&gt;| | 标准错误（stderr）| |           | | 设备文件系统    | |</span><br><span class="line">&gt;| +------------------+ |           | +------------------+ |</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">        | 关联                                  | 关联</span><br><span class="line">        v                                       v</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">&gt;| 文件描述符表        |           | 设备描述符表         |</span><br><span class="line">&gt;| (file_table)        |           | (device_table)       |</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">        | 关联                                  | 关联</span><br><span class="line">        v                                       v</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">&gt;| 设备文件            |           | TTY设备驱动         |</span><br><span class="line">&gt;| (/dev/tty)          |           | (tty_open, tty_read, |</span><br><span class="line">&gt;|                     |           |  tty_write, ...)     |</span><br><span class="line">&gt;+----------------------+           +----------------------+</span><br><span class="line">        | 关联</span><br><span class="line">        v</span><br><span class="line">&gt;+----------------------+</span><br><span class="line">&gt;| 硬件设备            |</span><br><span class="line">&gt;| (终端硬件)          |</span><br><span class="line">&gt;+----------------------+</span><br></pre></td></tr></table></figure>

<p>解释每一步的关联</p>
<ol>
<li><strong>用户空间程序</strong>通过标准输入（<code>stdin</code>）、标准输出（<code>stdout</code>）和标准错误（<code>stderr</code>）进行I&#x2F;O操作，这些操作实际上是对文件描述符表（<code>file_table</code>）中的文件描述符进行操作。</li>
<li><strong>文件描述符表</strong>中的文件描述符（如 <code>0</code>, <code>1</code>, <code>2</code>）对应TTY设备文件（如 <code>/dev/tty</code>）。</li>
<li><strong>设备文件</strong>（如 <code>/dev/tty</code>）通过设备描述符表（<code>device_table</code>）与TTY设备驱动（如 <code>tty_open</code>、<code>tty_read</code>、<code>tty_write</code> 等）关联。</li>
<li><strong>TTY设备驱动</strong>负责与实际的硬件设备（终端硬件）进行交互。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 复制文件描述符</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param file 当前文件的fd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_dup</span> <span class="params">(<span class="type">int</span> file)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((file &lt; <span class="number">0</span>) || (file &gt;= TASK_OFILE_NR)) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;file(%d) is not valid.&quot;</span>, file);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">file_t</span> *p_file = task_file(file);</span><br><span class="line">    <span class="keyword">if</span> (!p_file) &#123;</span><br><span class="line">		log_printf(<span class="string">&quot;file not opened&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在打开文件表中分配新的表项，同样指向该任务</span></span><br><span class="line">    <span class="type">int</span> fd = task_alloc_fd(p_file);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        p_file-&gt;ref++;</span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log_printf(<span class="string">&quot;No task file avaliable&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-7-允许切换tty窗口"><a href="#16-7-允许切换tty窗口" class="headerlink" title="16.7 允许切换tty窗口"></a>16.7 允许切换tty窗口</h2><h3 id="1、通过快捷键方式切换"><a href="#1、通过快捷键方式切换" class="headerlink" title="1、通过快捷键方式切换"></a>1、通过快捷键方式切换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kbd.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_fx_key</span> <span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = key - KEY_F1;</span><br><span class="line">    <span class="keyword">if</span> (kbd_state.lctrl_press || kbd_state.rctrl_press) &#123;</span><br><span class="line">        tty_select(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理单字符的标准键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_normal_key</span> <span class="params">(<span class="type">uint8_t</span> raw_code)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 功能键：写入键盘缓冲区，由应用自行决定如何处理</span></span><br><span class="line">    <span class="keyword">case</span> KEY_F1:</span><br><span class="line">    <span class="keyword">case</span> KEY_F2:</span><br><span class="line">    <span class="keyword">case</span> KEY_F3:</span><br><span class="line">    <span class="keyword">case</span> KEY_F4:</span><br><span class="line">    <span class="keyword">case</span> KEY_F5:</span><br><span class="line">    <span class="keyword">case</span> KEY_F6:</span><br><span class="line">    <span class="keyword">case</span> KEY_F7:</span><br><span class="line">    <span class="keyword">case</span> KEY_F8:</span><br><span class="line">        do_fx_key(key);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tty.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 选择tty</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_select</span> <span class="params">(<span class="type">int</span> tty)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (tty != curr_tty) &#123;</span><br><span class="line">		console_select(tty);</span><br><span class="line">		curr_tty = tty;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_select</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="type">console_t</span> * console = console_buf + idx;</span><br><span class="line">    <span class="keyword">if</span> (console-&gt;disp_base == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 可能没有初始化，先初始化一下</span></span><br><span class="line">        console_init(idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint16_t</span> pos = idx * console-&gt;display_cols * console-&gt;display_rows;</span><br><span class="line"></span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0xC</span>);		<span class="comment">// 写高地址</span></span><br><span class="line">	outb(<span class="number">0x3D5</span>, (<span class="type">uint8_t</span>) ((pos &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">	outb(<span class="number">0x3D4</span>, <span class="number">0xD</span>);		<span class="comment">// 写低地址</span></span><br><span class="line">	outb(<span class="number">0x3D5</span>, (<span class="type">uint8_t</span>) (pos &amp; <span class="number">0xFF</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新光标到当前屏幕</span></span><br><span class="line">    update_cursor_pos(console);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试代码</span></span><br><span class="line">    <span class="type">char</span> num = idx + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    show_char(console, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、在first-task中初始化8个窗口"><a href="#2、在first-task中初始化8个窗口" class="headerlink" title="2、在first_task中初始化8个窗口"></a>2、在first_task中初始化8个窗口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/init/first_task.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">first_task_main</span> <span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">    <span class="title function_">for</span> <span class="params">(<span class="type">int</span> i = <span class="number">0</span>; i &lt; TTY_NR; i++)</span> &#123;</span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            print_msg(<span class="string">&quot;create shell proc failed&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            <span class="type">char</span> tty_num[<span class="number">5</span>] = <span class="string">&quot;tty:?&quot;</span>;</span><br><span class="line">            tty_num[<span class="number">4</span>] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">char</span> * argv[] = &#123;tty_num, (<span class="type">char</span> *)<span class="number">0</span>&#125;;</span><br><span class="line">            execve(<span class="string">&quot;/shell.elf&quot;</span>, argv, (<span class="type">char</span> **)<span class="number">0</span>);</span><br><span class="line">            print_msg(<span class="string">&quot;create shell proc failed&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                msleep(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        msleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// open(&quot;tty:0&quot;, 0);            // fd = 0，标准输入</span></span><br><span class="line">    open(argv[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">    dup(<span class="number">0</span>);                   <span class="comment">// fd = 1，标准输出</span></span><br><span class="line">    dup(<span class="number">0</span>);                   <span class="comment">// fd = 2，标准错误输出</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from shell!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;os version: %s\n&quot;</span>, OS_VERSION);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        gets(cmd_buf);</span><br><span class="line">        <span class="built_in">puts</span>(cmd_buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf(&quot;shell pid= %d\n&quot;, getpid());</span></span><br><span class="line">        <span class="comment">// msleep(1000);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，还要在<code>conmsole.c</code>中进行相应的调整。</p>
<h1 id="十七、实现一个命令行解释器"><a href="#十七、实现一个命令行解释器" class="headerlink" title="十七、实现一个命令行解释器"></a>十七、实现一个命令行解释器</h1><h2 id="17-1-初始化命令行解释器"><a href="#17-1-初始化命令行解释器" class="headerlink" title="17.1 初始化命令行解释器"></a>17.1 初始化命令行解释器</h2><p><code>shell</code>俗称壳，即<strong>命令行解释器</strong>，它允许用户交互式的输入命令并解释执行，并且可以调用出相应的应用程序运行，从而让用户能够使用内核的 功能去操作计算机。<code>shell</code>也是一门程序语言，其定义了相应的语法规则，允许用户编写脚本。脚本编写后，由<code>shell</code>解释执行，不需要编译生成可执行程序。除非图形化的<code>shell</code>之外，还有图形化的<code>shell</code>，允许用户用鼠标等进行控制。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242158605.png" alt="image-20240524215849436"></p>
<p>本项目的目标是提供一个命令行的<code>shell</code>，支持执行内置的命令以及加载磁盘上的程序运行。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405242232682.png" alt="image-20240524223243130"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// command line interface</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLI_INPUT_SIZE     1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置命令结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">cli_cmd_t</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;       <span class="comment">// 命令名称</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *usage;      <span class="comment">// 命令功能</span></span><br><span class="line">    <span class="type">int</span> (*do_func)(<span class="type">int</span> argc, <span class="type">char</span> **argv);</span><br><span class="line">&#125;<span class="type">cli_cmd_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行接口结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">cli_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> curr_input[CLI_INPUT_SIZE];  <span class="comment">// 输入缓冲区</span></span><br><span class="line">    <span class="type">const</span> <span class="type">cli_cmd_t</span> *cmd_start;</span><br><span class="line">    <span class="type">const</span> <span class="type">cli_cmd_t</span> *cmd_end;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *promot;               <span class="comment">// 每次按下回车时显示的提示信息</span></span><br><span class="line">&#125;<span class="type">cli_t</span>;</span><br></pre></td></tr></table></figure>



<h3 id="1、show-promot"><a href="#1、show-promot" class="headerlink" title="1、show_promot()"></a>1、show_promot()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 显示命令行提示符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_promot</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, cli.promot);  <span class="comment">// 注意此处不能使用puts函数</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、为什么不能用 <code>puts</code>？</strong></p>
<ul>
<li><p><code>puts</code> 和 <code>printf</code> 的区别：</p>
<blockquote>
<ul>
<li><strong><code>puts</code>：</strong><ul>
<li><code>puts</code> 函数用于输出字符串，并在末尾自动添加一个换行符 <code>\n</code>。</li>
<li>它的原型是：<code>int puts(const char *str);</code></li>
<li>当你调用 <code>puts(&quot;Hello&quot;);</code> 时，实际输出的是 <code>&quot;Hello\n&quot;</code>。</li>
<li><code>puts</code> 自动刷新输出缓冲区。</li>
</ul>
</li>
<li><strong><code>printf</code>：</strong><ul>
<li><code>printf</code> 函数用于格式化输出，可以输出字符串、整数、浮点数等多种类型的数据。</li>
<li>它的原型是：<code>int printf(const char *format, ...);</code></li>
<li><code>printf(&quot;Hello&quot;);</code> 仅输出 <code>&quot;Hello&quot;</code>，不会自动添加换行符。</li>
<li><code>printf</code> 默认情况下不自动刷新输出缓冲区，除非遇到换行符或手动调用 <code>fflush</code>。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>在 <code>show_promot</code> 函数中不能使用 <code>puts</code> 的原因：</p>
<p><code>show_promot</code> 函数的目的是显示命令行提示符。通常情况下，命令行提示符不需要在末尾自动添加换行符，因为这样会导致用户输入内容出现在下一行，而不是提示符之后。例如：</p>
<ul>
<li><p>使用 <code>printf</code> 和 <code>fflush</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, cli.promot);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>

<p>输出是：<code>cli.promot</code> 直接跟随用户输入。</p>
</li>
<li><p>使用 <code>puts</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(cli.promot);</span><br></pre></td></tr></table></figure>

<p>输出是：<code>cli.promot\n</code>，用户输入会在下一行开始，这不是希望的行为。</p>
</li>
</ul>
</li>
</ul>
<p><strong>2、为什么要加上 <code>fflush</code>？</strong></p>
<ul>
<li><p>缓冲区和 <code>fflush</code>：</p>
<ul>
<li><p><strong>缓冲区</strong>：</p>
<ul>
<li>在标准 I&#x2F;O 库中，输出通常是缓冲的。这意味着输出操作先将数据存储在缓冲区中，只有在缓冲区满、遇到换行符、程序正常结束或手动刷新缓冲区时，数据才会实际输出到终端或文件。</li>
</ul>
</li>
<li><p>**<code>fflush</code>**：</p>
<ul>
<li><code>fflush</code> 函数用于强制刷新输出缓冲区，将缓冲区中的数据立即输出到目标设备。<ul>
<li>它的原型是：<code>int fflush(FILE *stream);</code></li>
<li>当你调用 <code>fflush(stdout);</code> 时，它会刷新标准输出缓冲区，确保所有缓冲的数据立即输出。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在 <code>show_promot</code> 函数中使用 <code>fflush</code> 的原因：</p>
<p>当我们使用 <code>printf</code> 输出命令行提示符时，缓冲区中的数据可能不会立即输出到终端。这意味着用户可能不会立即看到提示符，从而无法开始输入。为了确保提示符立即显示出来，我们需要手动刷新标准输出缓冲区。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, cli.promot);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>

<p>这样可以确保提示符在 <code>printf</code> 调用后立即显示，用户可以看到提示符并开始输入。</p>
</li>
</ul>
<p><strong>3、总结</strong></p>
<p>在 <code>show_promot</code> 函数中：</p>
<ol>
<li>不能使用 <code>puts</code> 是因为 <code>puts</code> 会在字符串末尾自动添加换行符，这不符合命令行提示符的预期行为。</li>
<li>使用 <code>printf</code> 后调用 <code>fflush(stdout)</code> 是为了确保提示符立即显示在终端上，避免缓冲区未被及时刷新导致的显示延迟。</li>
</ol>
<h3 id="2、在shell中按下回退键，回退键也会被写入"><a href="#2、在shell中按下回退键，回退键也会被写入" class="headerlink" title="2、在shell中按下回退键，回退键也会被写入"></a>2、在shell中按下回退键，回退键也会被写入</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405251645958.png" alt="image-20240525164517703"></p>
<p>解决方法：在<code>tty.c/tty_read()</code>中加入相应的处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> addr, <span class="type">char</span> *buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *pbuf = buf;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;  <span class="comment">// 当前读取长度</span></span><br><span class="line">	<span class="comment">// 遍历buf读数据</span></span><br><span class="line">	<span class="keyword">while</span> (len &lt; size) &#123;</span><br><span class="line">		sem_wait(&amp;tty-&gt;isem);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> ch;</span><br><span class="line">		<span class="comment">// 从缓冲区取数据</span></span><br><span class="line">		tty_fifo_get(&amp;tty-&gt;ififo, &amp;ch);</span><br><span class="line">		<span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">        <span class="comment">// ================ 新增 ================ //</span></span><br><span class="line">		<span class="keyword">case</span> ASCII_DEL:</span><br><span class="line">			<span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			len--;</span><br><span class="line">			pbuf--;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// ================ 新增 ================ //</span></span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-2-进程主动退出exit"><a href="#17-2-进程主动退出exit" class="headerlink" title="17.2 进程主动退出exit()"></a>17.2 进程主动退出exit()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 退出进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数有两个关键步骤：</p>
<h3 id="1、步骤一"><a href="#1、步骤一" class="headerlink" title="1、步骤一"></a>1、<strong>步骤一</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找当前进程（curr_task）所有的子进程，并将其转交给init进程（first_task）</span></span><br><span class="line"><span class="type">int</span> move_child = <span class="number">0</span>;  <span class="comment">// 标志是否需要唤醒first_task</span></span><br><span class="line">mutex_lock(&amp;task_table_mutex);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TASK_OFILE_NR; i++) &#123;</span><br><span class="line">    <span class="type">task_t</span> *task = task_table + i;</span><br><span class="line">    <span class="comment">// 判断当前进程（curr_task）是否有子进程</span></span><br><span class="line">    <span class="keyword">if</span> (task-&gt;parent == curr_task) &#123;</span><br><span class="line">        <span class="comment">// 若有，则转给first_task，由first_task进行处理</span></span><br><span class="line">        task-&gt;parent = &amp;task_manager.first_task;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果子进程中有僵尸进程，将其唤醒并回收资源</span></span><br><span class="line">        <span class="comment">// 但注意并不由当前进程（curr_task）自己回收，因为自己将要退出</span></span><br><span class="line">        <span class="keyword">if</span> (task-&gt;state == TASK_ZOMBIE) &#123;</span><br><span class="line">            move_child = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;task_table_mutex);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>寻找子进程并转交给 <code>first_task</code></strong>:<ul>
<li><strong>目的</strong>: 确保当前进程（<code>curr_task</code>）退出后，其所有的子进程不会成为孤儿进程。孤儿进程需要被重新指定为 <code>first_task</code>（通常是系统的守护进程）的子进程。</li>
<li>操作<ul>
<li>遍历 <code>task_table</code> 中的所有任务。</li>
<li>如果某任务的 <code>parent</code> 是 <code>curr_task</code>，则将该任务的 <code>parent</code> 改为 <code>first_task</code>。</li>
<li>如果该任务是僵尸进程（<code>TASK_ZOMBIE</code>），设置 <code>move_child</code> 标志为1，表示需要唤醒 <code>first_task</code> 来处理这些僵尸进程。</li>
</ul>
</li>
</ul>
</li>
<li><strong>加锁和解锁</strong>:<ul>
<li><strong>目的</strong>: 保证对 <code>task_table</code> 的操作是线程安全的。</li>
<li><strong>操作</strong>: 在遍历和修改 <code>task_table</code> 时，加锁 (<code>mutex_lock</code>) 和解锁 (<code>mutex_unlock</code>) 确保其他线程不能同时修改任务表。</li>
</ul>
</li>
</ol>
<h3 id="2、步骤二"><a href="#2、步骤二" class="headerlink" title="2、步骤二"></a>2、步骤二</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒first_task</span></span><br><span class="line"><span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"><span class="type">task_t</span> * parent = curr_task-&gt;parent;</span><br><span class="line"><span class="comment">// 若需要唤醒first_task，且当前进程（curr_task）的父进程不是first_task，唤醒first_task</span></span><br><span class="line"><span class="keyword">if</span> (move_child &amp;&amp; (parent != &amp;task_manager.first_task)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task_manager.first_task.state == TASK_WAITING) &#123;</span><br><span class="line">        task_set_ready(&amp;task_manager.first_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有父进程在wait，则唤醒父任务进行回收</span></span><br><span class="line"><span class="comment">// 如果父进程没有等待，则一直处理僵死状态？</span></span><br><span class="line"><span class="keyword">if</span> (parent-&gt;state == TASK_WAITING) &#123;</span><br><span class="line">    task_set_ready(curr_task-&gt;parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存返回值，当前进程（curr_task）进入僵尸状态</span></span><br><span class="line">curr_task-&gt;status = status;</span><br><span class="line">curr_task-&gt;state = TASK_ZOMBIE;</span><br><span class="line">task_set_block(curr_task);</span><br><span class="line">task_dispatch();</span><br><span class="line">irq_leave_protection(state);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>唤醒 <code>first_task</code></strong>:<ul>
<li><strong>目的</strong>: 如果有子进程转交给了 <code>first_task</code> 并且这些子进程中有僵尸进程，确保 <code>first_task</code> 可以及时处理这些僵尸进程。</li>
<li>操作<ul>
<li>如果 <code>move_child</code> 标志为<code>1</code>且 <code>curr_task</code> 的父进程不是 <code>first_task</code>，并且 <code>first_task</code> 当前处于等待状态（<code>TASK_WAITING</code>），则将 <code>first_task</code> 设置为就绪状态（<code>task_set_ready</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>唤醒父任务</strong>:<ul>
<li><strong>目的</strong>: 如果 <code>curr_task</code> 的父任务在等待（例如通过 <code>wait</code> 系统调用等待子进程结束），需要唤醒父任务来处理当前进程的退出。</li>
<li>操作<ul>
<li>如果 <code>curr_task</code> 的父任务处于等待状态（<code>TASK_WAITING</code>），将其设置为就绪状态（<code>task_set_ready</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>处理当前进程的退出</strong>:<ul>
<li><strong>目的</strong>: 将当前进程标记为僵尸状态，并阻塞当前任务以等待其父进程回收。</li>
<li>操作<ul>
<li>设置 <code>curr_task</code> 的返回状态（<code>status</code>）。</li>
<li>将 <code>curr_task</code> 的状态设置为僵尸状态（<code>TASK_ZOMBIE</code>）。</li>
<li>阻塞当前任务（<code>task_set_block</code>）。</li>
<li>调度其他任务运行（<code>task_dispatch</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>进入和离开中断保护</strong>:<ul>
<li><strong>目的</strong>: 确保在执行关键部分代码时不会被中断打断。</li>
<li><strong>操作</strong>: 进入中断保护（<code>irq_enter_protection</code>）和离开中断保护（<code>irq_leave_protection</code>）。</li>
</ul>
</li>
</ol>
<h3 id="3、两个步骤对比"><a href="#3、两个步骤对比" class="headerlink" title="3、两个步骤对比"></a>3、两个步骤对比</h3><ul>
<li><strong>第一步</strong>: 处理当前进程的子进程，将其重新分配给 <code>first_task</code>，并标记是否有僵尸进程需要处理。</li>
<li><strong>第二步</strong>: 唤醒 <code>first_task</code> 以处理重新分配的子进程和僵尸进程，同时处理当前进程的父任务和将当前进程设置为僵尸状态。</li>
</ul>
<h2 id="17-3-进程等待wait"><a href="#17-3-进程等待wait" class="headerlink" title="17.3 进程等待wait()"></a>17.3 进程等待wait()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 等待子进程退出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1、遍历任务表，寻找僵尸状态的子进程"><a href="#1、遍历任务表，寻找僵尸状态的子进程" class="headerlink" title="1、遍历任务表，寻找僵尸状态的子进程"></a>1、遍历任务表，寻找僵尸状态的子进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;task_table_mutex);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TASK_NR; i++) &#123;</span><br><span class="line">    <span class="type">task_t</span> * task = task_table + i;</span><br><span class="line">    <span class="keyword">if</span> (task-&gt;parent != curr_task) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task-&gt;state == TASK_ZOMBIE) &#123;</span><br><span class="line">        <span class="type">int</span> pid = task-&gt;pid;</span><br><span class="line"></span><br><span class="line">        *status = task-&gt;status;</span><br><span class="line"></span><br><span class="line">        memory_destroy_uvm(task-&gt;tss.cr3);</span><br><span class="line">        memory_free_page(task-&gt;tss.esp0 - MEM_PAGE_SIZE);</span><br><span class="line">        kernel_memset(task, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">task_t</span>));</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;task_table_mutex);</span><br><span class="line">        <span class="keyword">return</span> pid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;task_table_mutex);</span><br></pre></td></tr></table></figure>

<ul>
<li>加锁和解锁<ul>
<li>通过 <code>mutex_lock</code> 和 <code>mutex_unlock</code> 来保护对 <code>task_table</code> 的访问，防止并发修改。</li>
</ul>
</li>
<li>检查子进程<ul>
<li>遍历 <code>task_table</code>，检查每个任务的父进程是否是当前进程（<code>curr_task</code>）。</li>
<li>如果找到一个子进程处于 <code>TASK_ZOMBIE</code> 状态，则准备回收其资源。</li>
</ul>
</li>
</ul>
<h3 id="2、回收僵尸进程"><a href="#2、回收僵尸进程" class="headerlink" title="2、回收僵尸进程"></a>2、回收僵尸进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = task-&gt;pid;</span><br><span class="line">*status = task-&gt;status;</span><br><span class="line"></span><br><span class="line">memory_destroy_uvm(task-&gt;tss.cr3);</span><br><span class="line">memory_free_page(task-&gt;tss.esp0 - MEM_PAGE_SIZE);</span><br><span class="line">kernel_memset(task, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">task_t</span>));</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;task_table_mutex);</span><br><span class="line"><span class="keyword">return</span> pid;</span><br></pre></td></tr></table></figure>

<ul>
<li>保存退出状态<ul>
<li>将子进程的退出状态保存到 <code>status</code> 指向的变量中。</li>
</ul>
</li>
<li>回收资源<ul>
<li>销毁子进程的用户虚拟内存（<code>memory_destroy_uvm</code>）。</li>
<li>释放子进程的内核栈（<code>memory_free_page</code>）。</li>
<li>清空任务结构（<code>kernel_memset</code>）。</li>
</ul>
</li>
<li>解锁并返回<ul>
<li>解锁任务表互斥量，返回子进程的 <code>pid</code>。</li>
</ul>
</li>
</ul>
<h3 id="3、等待子进程退出"><a href="#3、等待子进程退出" class="headerlink" title="3、等待子进程退出"></a>3、等待子进程退出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line">task_set_block(curr_task);</span><br><span class="line">curr_task-&gt;state = TASK_WAITING;</span><br><span class="line">task_dispatch();</span><br><span class="line">irq_leave_protection(state);</span><br></pre></td></tr></table></figure>

<ul>
<li>进入中断保护<ul>
<li>进入中断保护状态，防止在关键操作期间被中断打断。</li>
</ul>
</li>
<li>设置当前进程为等待状态<ul>
<li>将当前进程的状态设置为 <code>TASK_WAITING</code>，并阻塞当前进程（<code>task_set_block</code>）。</li>
</ul>
</li>
<li>任务调度<ul>
<li>通过 <code>task_dispatch</code> 切换到其他任务运行。</li>
</ul>
</li>
<li>离开中断保护<ul>
<li>离开中断保护状态。</li>
</ul>
</li>
</ul>
<h3 id="4、关键步骤总结"><a href="#4、关键步骤总结" class="headerlink" title="4、关键步骤总结"></a>4、关键步骤总结</h3><ol>
<li><strong>遍历任务表，寻找僵尸状态的子进程</strong>。</li>
<li><strong>回收僵尸进程</strong><ul>
<li>保存退出状态。</li>
<li>销毁子进程资源。</li>
<li>清空任务结构。</li>
</ul>
</li>
<li><strong>等待子进程退出</strong><ul>
<li>进入中断保护。</li>
<li>设置当前进程为等待状态。</li>
<li>任务调度。</li>
<li>离开中断保护。</li>
</ul>
</li>
</ol>
<h2 id="17-4-让子进程继承父进程已打开的文件"><a href="#17-4-让子进程继承父进程已打开的文件" class="headerlink" title="17.4 让子进程继承父进程已打开的文件"></a>17.4 让子进程继承父进程已打开的文件</h2><h3 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252002902.png" alt="image-20240525200208616"></p>
<p>出现<code>file not opened</code>是因为在<code>fork()</code>操作的<code>task_init()</code>中，对于<code>file_table</code>进行了清零操作，因此就使得子进程并未继承父进程已打开的文件，无法调用标准输入输出文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel_memset(&amp;task-&gt;file_table, <span class="number">0</span>, <span class="keyword">sizeof</span>(task-&gt;file_table));</span><br></pre></td></tr></table></figure>

<h3 id="2、解决方法"><a href="#2、解决方法" class="headerlink" title="2、解决方法"></a>2、解决方法</h3><p>在<code>sys_fork()</code>中加入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝打开的文件</span></span><br><span class="line">copy_opened_files(child_task);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从当前进程中拷贝已经打开的文件列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">copy_opened_files</span><span class="params">(<span class="type">task_t</span> * child_task)</span> &#123;</span><br><span class="line">    <span class="type">task_t</span> * parent = task_current();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TASK_OFILE_NR; i++) &#123;</span><br><span class="line">        <span class="type">file_t</span> * file = parent-&gt;file_table[i];</span><br><span class="line">        <span class="keyword">if</span> (file) &#123;</span><br><span class="line">            file_inc_ref(file);</span><br><span class="line">            child_task-&gt;file_table[i] = parent-&gt;file_table[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252000979.png" alt="image-20240525200053427"></p>
<h1 id="十八、使用文件系统管理硬件设备"><a href="#十八、使用文件系统管理硬件设备" class="headerlink" title="十八、使用文件系统管理硬件设备"></a>十八、使用文件系统管理硬件设备</h1><h2 id="18-1-描述一个文件系统"><a href="#18-1-描述一个文件系统" class="headerlink" title="18.1 描述一个文件系统"></a>18.1 描述一个文件系统</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252046871.png" alt="image-20240525204658527" style="zoom:50%;" />

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252013293.png" alt="image-20240525201314917"></p>
<p> <img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252018279.png" alt="image-20240525201853857"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252020223.png" alt="image-20240525202007781"></p>
<h3 id="1、问题1：如何通过路径区分不同的设备"><a href="#1、问题1：如何通过路径区分不同的设备" class="headerlink" title="1、问题1：如何通过路径区分不同的设备"></a>1、问题1：如何通过路径区分不同的设备</h3><p>针对问题一：借鉴设备管理层的方法，针对不同类型的设备，添加相应的文件系统层接口实现。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405261156858.png" alt="image-20240526115647584" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252025262.png" alt="image-20240525202527701" style="zoom:50%;" />

<h2 id="18-2-挂载设备文件系统"><a href="#18-2-挂载设备文件系统" class="headerlink" title="18.2 挂载设备文件系统"></a>18.2 挂载设备文件系统</h2><h3 id="1、挂载原理"><a href="#1、挂载原理" class="headerlink" title="1、挂载原理"></a>1、挂载原理</h3><p>对于不同类型的文件系统，使用统一的链接进行挂载和管理。</p>
<p>在<code>mount_list</code>中存放了所支持的所有类型的文件系统，存放每个文件系统的名称（如<code>/dev</code>）和对应的操作（以函数指针的方式保存）。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405252050216.png" alt="image-20240525205036777"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fs_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fs_op_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*mount)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">int</span> major, <span class="type">int</span> minor);   <span class="comment">// mount 挂载</span></span><br><span class="line">    <span class="type">void</span> (*unmount)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs);                      <span class="comment">// unmount 取消挂载</span></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">file_t</span> *file);  <span class="comment">// fs的相关信息会放入file中</span></span><br><span class="line">    <span class="type">int</span> (*read)(<span class="type">char</span> *buf, <span class="type">int</span> size, <span class="type">file_t</span> *file);</span><br><span class="line">    <span class="type">int</span> (*write)(<span class="type">char</span> *buf, <span class="type">int</span> size, <span class="type">file_t</span> *file);</span><br><span class="line">    <span class="type">int</span> (*seek)(<span class="type">file_t</span> *file, <span class="type">uint32_t</span> offset, <span class="type">int</span> dir);</span><br><span class="line">    <span class="type">int</span> (*stat)(<span class="type">file_t</span> *file, <span class="keyword">struct</span> stat *st);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="type">file_t</span> *file);</span><br><span class="line">&#125;<span class="type">fs_op_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载文件系统类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">fs_type_t</span> &#123;</span></span><br><span class="line">    FS_DEVFS,</span><br><span class="line">&#125;<span class="type">fs_type_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象文件结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fs_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> mount_point[FS_MOUNTP_SIZE];   <span class="comment">// 挂载文件系统名称</span></span><br><span class="line">    <span class="type">fs_type_t</span> type;     <span class="comment">// 挂载文件系统类型</span></span><br><span class="line">    <span class="type">fs_op_t</span> *op;        <span class="comment">// 指明该结构对应的文件系统的相关操作</span></span><br><span class="line">    <span class="type">void</span> *data;         <span class="comment">// 底层调用时使用，上层调用不使用</span></span><br><span class="line">    <span class="type">int</span> dev_id;         <span class="comment">// 设备id</span></span><br><span class="line">    <span class="type">list_node_t</span> node;   <span class="comment">// 链表节点</span></span><br><span class="line">    <span class="type">mutex_t</span> *mutex;</span><br><span class="line">&#125;<span class="type">fs_t</span>;</span><br></pre></td></tr></table></figure>



<p>在函数调用方面，从高层到底层依次如下：</p>
<p><code>devfs_func =&gt; dev_func =&gt; tty_func</code></p>
<h3 id="2、具体挂载流程"><a href="#2、具体挂载流程" class="headerlink" title="2、具体挂载流程"></a>2、具体挂载流程</h3><p>在文件系统的挂载过程中，<code>mount</code> 函数调用另一个同名的 <code>mount</code> 函数可能会引起混淆。事实上，这里有两个不同的 <code>mount</code> 函数，分别属于不同的上下文。一个是高层次的文件系统管理函数，另一个是具体文件系统的操作函数。</p>
<p><strong>（1）高层次的 <code>mount</code> 函数</strong></p>
<p>负责管理挂载的总体流程，包括检查是否已经挂载、分配资源、调用具体文件系统的挂载操作等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">fs_t</span> *<span class="title function_">mount</span> <span class="params">(<span class="type">fs_type_t</span> type, <span class="type">char</span> *mount_point, <span class="type">int</span> dev_major, <span class="type">int</span> dev_minor)</span> &#123;</span><br><span class="line">    <span class="type">fs_t</span> *fs = (<span class="type">fs_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    log_printf(<span class="string">&quot;mount file system, name: &amp;s, dev: %x&quot;</span>, mount_point, dev_major);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前文件系统是否已被挂载</span></span><br><span class="line">    <span class="type">list_node_t</span> *curr = list_first(&amp;mounted_list);</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="type">fs_t</span> *fs = list_node_parent(curr, <span class="type">fs_t</span>, node);</span><br><span class="line">        <span class="keyword">if</span> (kernel_strncmp(fs-&gt;mount_point, mount_point, FS_MOUNTP_SIZE) == <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;fs is already mounted&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> mount_failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr = list_node_next(curr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到一个free_node对应的文件系统fs</span></span><br><span class="line">    <span class="type">list_node_t</span> *free_node = list_remove_first(&amp;free_list);</span><br><span class="line">    <span class="keyword">if</span> (!free_node) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;no free, mounted failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> mount_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    fs = list_node_parent(free_node, <span class="type">fs_t</span>, node);</span><br><span class="line">    <span class="type">fs_op_t</span> *op = get_fs_op(type, dev_major);</span><br><span class="line">    <span class="keyword">if</span> (!op) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;unsupported fs type: %d&quot;</span>, type);</span><br><span class="line">        <span class="keyword">goto</span> mount_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件系统fs通用初始化</span></span><br><span class="line">    kernel_memset(fs, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">fs_t</span>));</span><br><span class="line">    kernel_strncpy(fs-&gt;mount_point, mount_point, FS_MOUNTP_SIZE);</span><br><span class="line">    fs-&gt;op = op;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂载文件系统</span></span><br><span class="line">    <span class="keyword">if</span> (op-&gt;mount(fs, dev_major, dev_minor) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;mount fs %s failed&quot;</span>, mount_point);</span><br><span class="line">        <span class="keyword">goto</span> mount_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    list_insert_last(&amp;mounted_list, &amp;fs-&gt;node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">mount_failed:</span><br><span class="line">    <span class="keyword">if</span> (fs) &#123;</span><br><span class="line">        <span class="comment">// 回收fs</span></span><br><span class="line">        list_insert_first(&amp;free_list, &amp;fs-&gt;node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">fs_t</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）具体文件系统的 <code>mount</code> 函数</strong></p>
<p>这个 <code>mount</code> 函数是每个具体文件系统实现的一个函数，它被注册到文件系统操作结构（<code>fs_op_t</code>）中。在高层次的 <code>mount</code> 函数中调用 <code>op-&gt;mount</code> 时，实际上是调用具体文件系统的挂载实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fs_op_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*mount)(<span class="type">fs_t</span> *fs, <span class="type">int</span> dev_major, <span class="type">int</span> dev_minor);</span><br><span class="line">    <span class="comment">// 其他操作函数...</span></span><br><span class="line">&#125; <span class="type">fs_op_t</span>;</span><br></pre></td></tr></table></figure>

<p>具体文件系统的挂载函数负责实际的挂载工作，比如初始化文件系统的内部结构、检查设备、加载超级块等。例如，假设我们有一个简单的 <code>devfs</code> 文件系统，它的挂载函数可能是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">devfs_mount</span><span class="params">(<span class="type">fs_t</span> *fs, <span class="type">int</span> dev_major, <span class="type">int</span> dev_minor)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化devfs文件系统的内部结构</span></span><br><span class="line">    <span class="comment">// 检查设备</span></span><br><span class="line">    <span class="comment">// 加载超级块等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0表示成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）挂载流程详解</strong></p>
<ol>
<li><strong>调用高层次的 <code>mount</code> 函数</strong>：在文件系统初始化过程中，调用 <code>mount</code> 函数，例如 <code>fs_t *fs = mount(FS_DEVFS, &quot;/dev&quot;, 0, 0);</code>。</li>
<li><strong>检查是否已经挂载</strong>：高层次的 <code>mount</code> 函数检查指定的挂载点是否已经挂载文件系统。</li>
<li><strong>分配文件系统结构</strong>：从空闲列表中获取一个 <code>fs_t</code> 结构，并初始化。</li>
<li><strong>获取文件系统操作结构</strong>：通过文件系统类型和主设备号找到对应的文件系统操作结构 <code>fs_op_t</code>。</li>
<li><strong>调用具体文件系统的挂载函数</strong>：通过 <code>op-&gt;mount</code> 调用具体文件系统的挂载函数，例如 <code>devfs_mount</code>。</li>
<li><strong>将挂载的文件系统添加到挂载列表</strong>：如果挂载成功，将文件系统结构 <code>fs_t</code> 添加到挂载列表中。</li>
</ol>
<p><strong>（4）思维导图</strong></p>
<p>以下是这个流程的思维导图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">yaml复制代码  高层次的 mount 函数</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  检查是否已经挂载</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  分配文件系统结构</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  获取文件系统操作结构 (fs_op_t)</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  调用具体文件系统的 mount 函数 (op-&gt;mount)</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">  如果挂载成功，添加到挂载列表</span><br></pre></td></tr></table></figure>

<p>通过这个流程图，可以看到高层次的 <code>mount</code> 函数如何协调和管理整个挂载过程，而具体文件系统的 <code>mount</code> 函数则负责实际的挂载操作。</p>
<h2 id="18-3-打开dev-tty0设备"><a href="#18-3-打开dev-tty0设备" class="headerlink" title="18.3 打开dev&#x2F;tty0设备"></a>18.3 打开dev&#x2F;tty0设备</h2><p>设备文件系统并不对应于某个实际的硬件设备，而是抽象出来的用于管理所有硬件设备的一种文件系统。</p>
<p>修改<code>sys_open()</code>，使其变得比较通用，步骤如下：</p>
<ol>
<li><p>分配文件描述符链接</p>
</li>
<li><p>将分配的file结构和一个fd关联</p>
</li>
<li><p>根据传入的路径解析对应的fs结构</p>
<ul>
<li><p>检查名称是否以挂载点开头，如果没有，则认为name在根目录下</p>
</li>
<li><p>即只允许根目录下的遍历</p>
</li>
</ul>
</li>
<li><p>设置file内部相关字段</p>
</li>
<li><p>调用fs内部特定的open函数进行文件打开操作</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打开文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> flags, ...)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> err = fs-&gt;op-&gt;open(fs, name, file);  <span class="comment">// 就是这一句保证了其通用性</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>后续要增加其他设备时只需要修改此处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// devfs.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">devfs_open</span> <span class="params">(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">file_t</span> *file)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历所有支持的设备类型列表，根据path中的路径，找到相应的设备类型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(devfs_type_list) / <span class="keyword">sizeof</span>(devfs_type_list[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="type">devfs_type_t</span> *type = devfs_type_list + i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找相同的名称，然后从中提取后续部分，转换成字符串</span></span><br><span class="line">        <span class="type">int</span> type_name_len = kernel_strlen(type-&gt;name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 举例：path:tty0  |  type-&gt;name:tty</span></span><br><span class="line">        <span class="comment">// 如果存在挂载点路径，则跳过该路径，取下级子目录</span></span><br><span class="line">        <span class="keyword">if</span> (kernel_strncmp(path, type-&gt;name, type_name_len) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 转换得到设备子序号</span></span><br><span class="line">            <span class="type">int</span> minor;</span><br><span class="line">            <span class="keyword">if</span> ((kernel_strlen(path) &gt; type_name_len) &amp;&amp; (path_to_num(path + type_name_len, &amp;minor) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                log_printf(<span class="string">&quot;Get device num failed. %s&quot;</span>, path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开设备</span></span><br><span class="line">            <span class="type">int</span> dev_id = dev_open(type-&gt;dev_type, minor, (<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (dev_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                log_printf(<span class="string">&quot;Open device failed:%s&quot;</span>, path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 纪录所在的设备号</span></span><br><span class="line">            file-&gt;dev_id = dev_id;  <span class="comment">// file的设备号指向打开的特定的设备</span></span><br><span class="line">            file-&gt;fs = fs;          <span class="comment">// file所属的文件系统</span></span><br><span class="line">            file-&gt;pos = <span class="number">0</span>;</span><br><span class="line">            file-&gt;size = <span class="number">0</span>;</span><br><span class="line">            file-&gt;type = type-&gt;file_type;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十九、磁盘与fat16文件系统"><a href="#十九、磁盘与fat16文件系统" class="headerlink" title="十九、磁盘与fat16文件系统"></a>十九、磁盘与fat16文件系统</h1><h2 id="19-1-磁盘基本特性简介"><a href="#19-1-磁盘基本特性简介" class="headerlink" title="19.1 磁盘基本特性简介"></a>19.1 磁盘基本特性简介</h2><h3 id="1、MBR是什么"><a href="#1、MBR是什么" class="headerlink" title="1、MBR是什么"></a>1、MBR是什么</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262044874.png" alt="image-20240526204427543"></p>
<h3 id="2、磁盘的分区和扇区有什么区别"><a href="#2、磁盘的分区和扇区有什么区别" class="headerlink" title="2、磁盘的分区和扇区有什么区别"></a>2、磁盘的分区和扇区有什么区别</h3><p>磁盘分区和扇区是磁盘存储管理中的两个基本概念，但它们指的是不同层次的内容。</p>
<p><strong>1、扇区（<code>Sector</code>）</strong></p>
<p><strong>扇区</strong>是硬盘存储的最小单位。硬盘上的数据被划分为一个一个的扇区进行存储和读取。传统上，一个扇区的大小是512字节，但在一些现代硬盘中，这个大小可以是4096字节（4K扇区）。</p>
<ul>
<li><strong>扇区大小</strong>：通常为512字节或4096字节。</li>
<li><strong>位置</strong>：硬盘表面被划分成多个轨道，每个轨道再分成多个扇区。</li>
<li><strong>标识</strong>：每个扇区有一个唯一的地址，传统上使用柱面（Cylinder）、磁头（Head）、扇区（Sector，简称CHS）来标识，现在更多地使用逻辑块地址（LBA，Logical Block Addressing）来标识。</li>
</ul>
<p><strong>2、分区（<code>Partition</code>）</strong></p>
<p><strong>分区</strong>是硬盘上的一段连续的存储区域，可以被操作系统或用户作为一个独立的逻辑磁盘来使用。分区将一个物理硬盘划分为一个或多个独立的部分，每个部分可以包含文件系统、操作系统或其他数据。</p>
<ul>
<li><strong>分区类型</strong><ul>
<li><strong>主分区（Primary Partition）</strong>：硬盘上最多可以有四个主分区。</li>
<li><strong>扩展分区（Extended Partition）</strong>：扩展分区本身不能直接用于存储数据，但可以包含多个逻辑分区。</li>
<li><strong>逻辑分区（Logical Partition）</strong>：位于扩展分区内，可以用于存储数据。</li>
</ul>
</li>
<li><strong>用途</strong>：每个分区可以格式化为不同的文件系统，例如FAT32、NTFS、EXT4等，可以用于安装操作系统或存储数据。</li>
<li><strong>管理</strong>：分区信息存储在硬盘的分区表中，传统的MBR（Master Boot Record）分区表最多支持四个主分区或三个主分区加一个扩展分区，GPT（GUID Partition Table）分区表支持更多的分区和更大的磁盘。</li>
</ul>
<p><strong>3、区别和联系</strong></p>
<p>（1）区别</p>
<ol>
<li><strong>定义和作用</strong>：<ul>
<li><strong>扇区</strong>是硬盘的最小存储单元，具体指硬盘上物理的存储位置。</li>
<li><strong>分区</strong>是硬盘上的逻辑区域，包含多个扇区，可以被操作系统识别和使用。</li>
</ul>
</li>
<li><strong>大小和范围</strong>：<ul>
<li><strong>扇区</strong>的大小通常是固定的（512字节或4096字节）。</li>
<li><strong>分区</strong>的大小可以变化不定，取决于用户或系统的配置，可以包含许多扇区。</li>
</ul>
</li>
<li><strong>管理和用途</strong>：<ul>
<li><strong>扇区</strong>由硬盘控制器直接管理，硬件层面上的数据存储单位。</li>
<li><strong>分区</strong>由操作系统和分区表管理，逻辑层面上的数据管理单位。</li>
</ul>
</li>
</ol>
<p>（2）联系</p>
<ol>
<li><strong>分区包含扇区</strong>：<ul>
<li>一个分区由多个连续的扇区组成，分区的大小和位置通过扇区来确定。</li>
</ul>
</li>
<li><strong>共同作用</strong>：<ul>
<li>分区划分后，操作系统在分区上创建文件系统，文件系统管理扇区上的数据存储。</li>
<li>分区表记录每个分区的起始扇区和大小，操作系统通过分区表来访问和管理硬盘上的数据。</li>
</ul>
</li>
</ol>
<p><strong>4、示例</strong></p>
<p>假设有一个大小为<code>1TB</code>的硬盘，使用传统的<code>512</code>字节扇区：</p>
<ul>
<li><strong>扇区</strong>：整个硬盘包含约<code>2^40 / 2^9 = 2^31</code>个扇区，即大约<code>21亿</code>个扇区。</li>
<li>分区<ul>
<li>第一个分区：从第<code>2048</code>扇区开始，大小为<code>200GB</code>（约400,000,000个扇区）。</li>
<li>第二个分区：从第<code>400,002,048</code>扇区开始，大小为<code>300GB</code>（约600,000,000个扇区）。</li>
<li>其他部分可以划分为更多分区或留作未分区空间。</li>
</ul>
</li>
</ul>
<p>通过分区工具（如fdisk、parted等）可以查看和管理硬盘上的分区信息，每个分区都会有一个对应的起始和结束扇区。文件系统（如NTFS、EXT4等）则进一步管理分区内的数据，决定如何在扇区中存储和检索文件。</p>
<blockquote>
<p>总结来说，<strong>扇区是物理存储单位</strong>，<strong>分区是逻辑存储单位</strong>，分区包含多个扇区，分区表管理和记录分区信息。</p>
</blockquote>
<h3 id="3、初始化磁盘结构和分区结构"><a href="#3、初始化磁盘结构和分区结构" class="headerlink" title="3、初始化磁盘结构和分区结构"></a>3、初始化磁盘结构和分区结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分区结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">disk_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">partinfo_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[PART_NAME_SIZE];  <span class="comment">// 分区名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">disk_t</span> *<span class="title">disk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        FS_INVALID = <span class="number">0x00</span>,</span><br><span class="line">        FS_FAT16_0 = <span class="number">0x6</span>,</span><br><span class="line">        FS_FAT16_1 = <span class="number">0xE</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start_sector;   <span class="comment">// 起始扇区号</span></span><br><span class="line">    <span class="type">int</span> total_sector;   <span class="comment">// 占用的扇区数量</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">partinfo_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述特定磁盘结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">disk_t</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[DISK_NAME_SIZE];</span><br><span class="line">    <span class="type">int</span> sector_size;    <span class="comment">// 扇区大小</span></span><br><span class="line">    <span class="type">int</span> sector_count;   <span class="comment">// 扇区个数</span></span><br><span class="line">    <span class="type">partinfo_t</span> partinfo[DISK_PRIMARY_PART_CNT];  <span class="comment">// 分区信息</span></span><br><span class="line">&#125;<span class="type">disk_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="19-2-识别系统中已有的磁盘"><a href="#19-2-识别系统中已有的磁盘" class="headerlink" title="19.2 识别系统中已有的磁盘"></a>19.2 识别系统中已有的磁盘</h2><h3 id="1、系统中有多少块硬盘"><a href="#1、系统中有多少块硬盘" class="headerlink" title="1、系统中有多少块硬盘"></a>1、系统中有多少块硬盘</h3><p>两条总线，<code>primary bus</code>和<code>secondary bus</code>，每条总线分别对应两个硬盘。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262111920.png" alt="image-20240526211100606"></p>
<h3 id="2、磁盘检测"><a href="#2、磁盘检测" class="headerlink" title="2、磁盘检测"></a>2、磁盘检测</h3><p>可以通过识别命令来检测硬盘的存在，以及硬盘相关的信息。原始参考资料见:<a target="_blank" rel="noopener" href="https://wiki.osdev.org/ATA_PIO_Mode%E3%80%82%E4%BB%A5%E4%B8%8B%E4%BB%85%E5%88%97%E5%87%BA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9">https://wiki.osdev.org/ATA_PIO_Mode。以下仅列出项目中使用的部分内容</a><br>具体流程如下:</p>
<ul>
<li>写<code>Drive/HeadRegster</code>寄存器(地址<code>0x1F6</code>)：<code>0xA0</code>(master drive)或者<code>0xB0</code>(slave driver)</li>
<li>将扇区数量寄存器、<code>LBAlo,LBAmid,和LBAhi10</code>(地址<code>0x1F2-0x1F5</code>)全设置成0</li>
<li>向命令寄存器(地址<code>0x1F7</code>)发送<code>IDENTIFY</code>命令(<code>0xEC</code>)</li>
<li>读取状态寄存器(<code>0x1F7</code>)：如果值为0，则表明该硬盘不存在。如果其它值，等待DRQ置位或者ERR置位</li>
<li>如果<code>ERR</code>清令状态，从<code>0x1F0</code>读取<code>256</code>个<code>16</code>位的数据，其中保存了有关该磁盘相关的信息。</li>
</ul>
<p>返回的256个<code>16</code>位的数据内容：</p>
<ul>
<li>第<code>100-103</code>个数据，共<code>64</code>位：保存了该磁盘总的扇区数量</li>
</ul>
<h3 id="3、代码细节"><a href="#3、代码细节" class="headerlink" title="3、代码细节"></a>3、代码细节</h3><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#define DISK_NAME_SIZE              <span class="number">32</span></span><br><span class="line">#define PART_NAME_SIZE              <span class="number">32</span></span><br><span class="line">#define DISK_PRIMARY_PART_CNT       (<span class="number">4</span>+<span class="number">1</span>)</span><br><span class="line">#define DISK_CNT                    <span class="number">2</span></span><br><span class="line">#define DISK_PER_CHANNEL            <span class="number">2</span>           <span class="comment">// 每通道磁盘数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://wiki.osdev.org/ATA_PIO_Mode#IDENTIFY_command</span></span><br><span class="line"><span class="comment">// 只考虑支持主总线primary bus</span></span><br><span class="line">#define IOBASE_PRIMARY              <span class="number">0</span>x1F0</span><br><span class="line">#define	DISK_DATA(disk)				(disk-&gt;port_base + <span class="number">0</span>)		<span class="comment">// 数据寄存器</span></span><br><span class="line">#define	DISK_ERROR(disk)			(disk-&gt;port_base + <span class="number">1</span>)		<span class="comment">// 错误寄存器</span></span><br><span class="line">#define	DISK_SECTOR_COUNT(disk)		(disk-&gt;port_base + <span class="number">2</span>)		<span class="comment">// 扇区数量寄存器</span></span><br><span class="line">#define	DISK_LBA_LO(disk)			(disk-&gt;port_base + <span class="number">3</span>)		<span class="comment">// LBA寄存器</span></span><br><span class="line">#define	DISK_LBA_MID(disk)			(disk-&gt;port_base + <span class="number">4</span>)		<span class="comment">// LBA寄存器</span></span><br><span class="line">#define	DISK_LBA_HI(disk)			(disk-&gt;port_base + <span class="number">5</span>)		<span class="comment">// LBA寄存器</span></span><br><span class="line">#define	DISK_DRIVE(disk)			(disk-&gt;port_base + <span class="number">6</span>)		<span class="comment">// 磁盘或磁头</span></span><br><span class="line">#define	DISK_STATUS(disk)			(disk-&gt;port_base + <span class="number">7</span>)		<span class="comment">// 状态寄存器</span></span><br><span class="line">#define	DISK_CMD(disk)				(disk-&gt;port_base + <span class="number">7</span>)		<span class="comment">// 命令寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ATA命令</span></span><br><span class="line">#define	DISK_CMD_IDENTIFY			<span class="number">0</span>xEC	    <span class="comment">// IDENTIFY命令</span></span><br><span class="line">#define	DISK_CMD_READ				<span class="number">0</span>x24	    <span class="comment">// 读命令</span></span><br><span class="line">#define	DISK_CMD_WRITE				<span class="number">0</span>x34	    <span class="comment">// 写命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态寄存器</span></span><br><span class="line">#define DISK_STATUS_ERR             (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)    <span class="comment">// 发生错误</span></span><br><span class="line">#define DISK_STATUS_DRQ             (<span class="number">1</span> &lt;&lt; <span class="number">3</span>)    <span class="comment">// 准备好接受数据或者输出数据</span></span><br><span class="line">#define DISK_STATUS_DF              (<span class="number">1</span> &lt;&lt; <span class="number">5</span>)    <span class="comment">// 驱动错误</span></span><br><span class="line">#define DISK_STATUS_BUSY            (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)    <span class="comment">// 正忙</span></span><br><span class="line"></span><br><span class="line">#define	DISK_DRIVE_BASE		    <span class="number">0</span>xE0		<span class="comment">// 驱动器号基础值:0xA0 + LBA</span></span><br></pre></td></tr></table></figure>

<h3 id="4、结果"><a href="#4、结果" class="headerlink" title="4、结果"></a>4、结果</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262205497.png" alt="image-20240526220510242"></p>
<p>1、<code>sda</code>：放<code>boot/loader/kernel</code>；</p>
<p>2、<code>sdb</code>：放<code>FAT16</code>磁盘文件系统，放置相应的应用程序。</p>
<h2 id="19-3-解析磁盘分区表"><a href="#19-3-解析磁盘分区表" class="headerlink" title="19.3 解析磁盘分区表"></a>19.3 解析磁盘分区表</h2><p>分区表中共<code>4</code>个表项，每个表项包含了起始扇区、总扇区数、文件系统类型等关键性信息。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262212616.png" alt="image-20240526221201306"></p>
<blockquote>
<p><strong>MBR（主引导记录，Master Boot Record）</strong>是传统的磁盘分区表格式之一，用于在硬盘上划分不同的分区。它位于硬盘的第一个扇区（即0柱面、0磁头、1扇区），占用512字节。MBR不仅包含用于启动操作系统的引导代码，还包含分区表，用于描述磁盘上分区的布局。</p>
<p>（1）MBR由三个主要部分组成：</p>
<ol>
<li><strong>引导程序（Bootloader）</strong>：446字节</li>
</ol>
<p>  引导程序包含启动代码，用于引导操作系统。当计算机启动时，BIOS（或UEFI）会加载MBR中的引导代码，并执行它。这个引导代码通常用于查找活动分区，并加载该分区的引导扇区，以便进一步启动操作系统。</p>
<ol start="2">
<li><strong>分区表（Partition Table）</strong>：64字节</li>
</ol>
<p>  分区表包含四个分区项，每个分区项占用16字节。每个分区项描述一个分区的信息。</p>
<p>  一个分区项的格式如下：</p>
<ul>
<li><strong>引导标志（1字节）</strong>：表示该分区是否为活动分区（引导分区），值为0x80表示活动分区，0x00表示非活动分区。</li>
<li><strong>起始CHS地址（3字节）</strong>：分区起始地址，以CHS（柱面、磁头、扇区）格式表示。</li>
<li><strong>分区类型（1字节）</strong>：表示分区类型，例如0x83表示Linux分区，0x07表示NTFS分区。</li>
<li><strong>结束CHS地址（3字节）</strong>：分区结束地址，以CHS格式表示。</li>
<li><strong>起始LBA地址（4字节）</strong>：分区起始地址，以LBA（逻辑块地址）格式表示。</li>
<li><strong>分区大小（4字节）</strong>：分区的大小，以扇区为单位。</li>
</ul>
<ol start="3">
<li><strong>签名（Signature）</strong>：2字节</li>
</ol>
<p>  MBR的最后两个字节是签名，固定为0x55AA，用于标识这是一个有效的MBR。如果这两个字节不匹配，BIOS会认为硬盘上没有有效的MBR，不会继续引导。</p>
<p>（2）示例</p>
<p>假设我们有一个硬盘，其MBR如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&gt;0000: 33 C0 8E D0 BC 00 7C 8B F4 50 07 50 1F FB FC BE 00 7C ...</span></span><br><span class="line">&gt;...</span><br><span class="line"><span class="section">&gt;01BE: 00 01 01 00 07 FE FF FF 3F 00 00 00 BF 9E 0D 00</span></span><br><span class="line"><span class="section">&gt;01CE: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="section">&gt;01DE: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="section">&gt;01EE: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="section">&gt;01FE: 55 AA</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li><strong>引导程序</strong>：从偏移量<code>0x0000</code>到<code>0x01BD</code>，共<code>446</code>字节。</li>
<li><strong>分区表</strong></li>
<li>第一个分区项从<code>0x01BE</code>到<code>0x01CD</code>。<ul>
<li><strong>引导标志</strong>：0x00，表示非活动分区。</li>
<li><strong>起始CHS地址</strong>：0x010100，表示柱面1，磁头1，扇区1。</li>
<li><strong>分区类型</strong>：0x07，表示NTFS分区。</li>
<li><strong>结束CHS地址</strong>：0xFEFFFF，表示柱面1023，磁头254，扇区63。</li>
<li><strong>起始LBA地址</strong>：0x0000003F，表示LBA地址63。</li>
<li><strong>分区大小</strong>：0x0DBF9EBF，表示分区大小为22934559扇区（约11GB）。</li>
</ul>
</li>
<li>其他三个分区项从<code>0x01CE</code>到<code>0x01ED</code>，当前示例中这些分区项未使用，全为0。</li>
<li><strong>签名</strong>：最后两个字节<code>0x55AA</code>。</li>
</ul>
<p>（3）分区操作</p>
<p>操作系统和磁盘工具通过读写MBR中的分区表来管理硬盘分区。例如，创建、删除、调整分区大小等操作都涉及到修改MBR中的分区表信息。</p>
<p>（4）MBR的局限性</p>
<p>由于MBR使用32位地址来表示分区大小，因此单个分区的最大容量为2^32个扇区（每扇区512字节），即2TB。此外，MBR分区表最多只能有四个主分区或三个主分区和一个扩展分区（扩展分区内可以包含多个逻辑分区）。这些局限性促使了GPT（GUID Partition Table）等更现代的分区表格式的出现，支持更大的磁盘和更多的分区。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 检测分区表信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">detect_part_info</span><span class="params">(<span class="type">disk_t</span> *disk)</span> &#123;</span><br><span class="line">    <span class="type">mbr_t</span> mbr;</span><br><span class="line"></span><br><span class="line">    ata_send_cmd(disk, <span class="number">0</span>, <span class="number">1</span>, DISK_CMD_READ);</span><br><span class="line">    <span class="type">int</span> err = ata_wait_data(disk);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;read mbr failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ata_read_data(disk, &amp;mbr, <span class="keyword">sizeof</span>(mbr));</span><br><span class="line">    <span class="type">part_item_t</span> *item = mbr.part_item;  <span class="comment">// 指向分区表起始位置</span></span><br><span class="line">    <span class="type">partinfo_t</span> *part_info = disk-&gt;partinfo + <span class="number">1</span>;  <span class="comment">// 第0个表项已被使用，所以从第1个表项开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MBR_PRIMARY_PART_NR; i++, item++, part_info++) &#123;</span><br><span class="line">        part_info-&gt;type = item-&gt;system_id;</span><br><span class="line">        <span class="keyword">if</span> (part_info-&gt;type == FS_INVALID) &#123;</span><br><span class="line">            part_info-&gt;total_sector = <span class="number">0</span>;</span><br><span class="line">            part_info-&gt;start_sector = <span class="number">0</span>;</span><br><span class="line">            part_info-&gt;disk = (<span class="type">disk_t</span> *)<span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            kernel_sprintf(part_info-&gt;name, <span class="string">&quot;%s%d&quot;</span>, disk-&gt;name, i+<span class="number">1</span>);</span><br><span class="line">            part_info-&gt;total_sector = item-&gt;total_sectors;</span><br><span class="line">            part_info-&gt;start_sector = item-&gt;relative_sectors;</span><br><span class="line">            part_info-&gt;disk = disk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405262245138.png" alt="image-20240526224546950"></p>
<h2 id="19-4-增加磁盘设备管理"><a href="#19-4-增加磁盘设备管理" class="headerlink" title="19.4 增加磁盘设备管理"></a>19.4 增加磁盘设备管理</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270914097.png" alt="image-20240527091359469"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270914740.png" alt="image-20240527091426820"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dev.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DEV_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">    DEV_TTY,</span><br><span class="line">    DEV_DISK,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dev.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">dev_desc_t</span> dev_tty_desc;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">dev_desc_t</span> dev_disk_desc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象设备表（静态注册）</span></span><br><span class="line"><span class="type">static</span> <span class="type">dev_desc_t</span> *dev_desc_tbl[] = &#123;</span><br><span class="line">    &amp;dev_tty_desc,</span><br><span class="line">    &amp;dev_disk_desc,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// disk.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">dev_desc_t</span> dev_disk_desc = &#123;</span><br><span class="line">    .name = <span class="string">&quot;disk&quot;</span>,</span><br><span class="line">    .major = DEV_DISK,</span><br><span class="line">    .open = disk_open,</span><br><span class="line">    .read = disk_read,</span><br><span class="line">    .write = disk_write,</span><br><span class="line">    .control = disk_control,</span><br><span class="line">    .close = disk_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>disk_open()</code></p>
<ol>
<li><p>根据次设备号取磁盘号和分区号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> disk_idx = (*dev*-&gt;minor &gt;&gt; <span class="number">4</span>) - <span class="number">0xa</span>;  *<span class="comment">// 取高4位*</span></span><br><span class="line"><span class="type">int</span> part_idx = *dev*-&gt;minor &amp; <span class="number">0xF</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据磁盘编号取对应磁盘</p>
</li>
<li><p>根据分区号取对应分区</p>
</li>
<li><p>将分区信息保存到data中</p>
</li>
<li><p>打开相应中断</p>
</li>
</ol>
<h2 id="19-5-实现磁盘的读取和写入"><a href="#19-5-实现磁盘的读取和写入" class="headerlink" title="19.5 实现磁盘的读取和写入"></a>19.5 实现磁盘的读取和写入</h2><p>由于每条总线上的<code>2</code>块磁盘<strong>共用相同的中断和IO端口</strong>，考虑到多进程可能同时对磁盘进行读写操作，因此最好是加上锁。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270936751.png" alt="image-20240527093651259"></p>
<p>在<code>identify_disk()</code>中调用了<code>ata_wait_data()</code>来等到数据到达磁盘：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = ata_wait_data(disk);  <span class="comment">// 在此过程中一直占用CPU，效率较低</span></span><br></pre></td></tr></table></figure>

<p>这个等待过程是一个<code>do-while</code>循环，在此过程中一直占用CPU，效率较低。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">// 等待数据或者有错误</span></span><br><span class="line">       status = inb(DISK_STATUS(disk));</span><br><span class="line">       <span class="keyword">if</span> ((status &amp; (DISK_STATUS_BUSY | DISK_STATUS_DRQ | DISK_STATUS_ERR)) != DISK_STATUS_BUSY) &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;<span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>因此考虑结合<strong>信号量和中断</strong>来进行处理。</p>
<p>当进程向磁盘发送读写请求后，在磁盘准备数据的期间，进程暂时主动放弃CPU，并进入等待队列；当磁盘的数据准备好后，向对应的进程发送中断信号，告知进程。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405270948328.png" alt="image-20240527094819093" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">disk_read</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> start_sector, <span class="type">char</span> *buf, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">partinfo_t</span> *part_info = (<span class="type">partinfo_t</span> *)dev-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (!part_info) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;get part info failed, device: %d&quot;</span>, dev-&gt;minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">disk_t</span> *disk = part_info-&gt;disk;</span><br><span class="line">    <span class="keyword">if</span> (disk == (<span class="type">disk_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;no disk, device: %d&quot;</span>, dev-&gt;minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    task_on_op = <span class="number">1</span>;</span><br><span class="line">    ata_send_cmd(disk, part_info-&gt;start_sector + start_sector, count, DISK_CMD_READ);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; count; cnt++, buf+=disk-&gt;sector_size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task_current()) &#123;</span><br><span class="line">            sem_wait(disk-&gt;op_sem);  <span class="comment">// 避开系统初始化时在此处卡死</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> err = ata_wait_data(disk);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;disk(%s) read error: start sector: %d, count: %d&quot;</span>,</span><br><span class="line">                disk-&gt;name, start_sector, count</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ata_read_data(disk, buf, disk-&gt;sector_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;mutex);  </span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">disk_write</span> <span class="params">(<span class="type">device_t</span> *dev, <span class="type">int</span> start_sector, <span class="type">char</span> *buf, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">partinfo_t</span> *part_info = (<span class="type">partinfo_t</span> *)dev-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (!part_info) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;get part info failed, device: %d&quot;</span>, dev-&gt;minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">disk_t</span> *disk = part_info-&gt;disk;</span><br><span class="line">    <span class="keyword">if</span> (disk == (<span class="type">disk_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;no disk, device: %d&quot;</span>, dev-&gt;minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    task_on_op = <span class="number">1</span>;</span><br><span class="line">    ata_send_cmd(disk, part_info-&gt;start_sector + start_sector, count, DISK_CMD_WRITE);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; count; cnt++, buf+=disk-&gt;sector_size) &#123;</span><br><span class="line">        ata_write_data(disk, buf, disk-&gt;sector_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (task_current()) &#123;</span><br><span class="line">            sem_wait(disk-&gt;op_sem);  <span class="comment">// 避开系统初始化时在此处卡死</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> err = ata_wait_data(disk);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;disk(%s) read error: start sector: %d, count: %d&quot;</span>,</span><br><span class="line">                disk-&gt;name, start_sector, count</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;mutex);  </span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-6-FAT16文件系统"><a href="#19-6-FAT16文件系统" class="headerlink" title="19.6 FAT16文件系统"></a>19.6 FAT16文件系统</h2><h3 id="1、FAT16"><a href="#1、FAT16" class="headerlink" title="1、FAT16"></a>1、FAT16</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271025353.png" alt="image-20240527102544023"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271027930.png" alt="image-20240527102751513"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271028998.png" alt="image-20240527102858618"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271034500.png" alt="image-20240527103442028"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271036205.png" alt="image-20240527103603679"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271038250.png" alt="image-20240527103821885"></p>
<h3 id="2、FAT表项配置"><a href="#2、FAT表项配置" class="headerlink" title="2、FAT表项配置"></a>2、FAT表项配置</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271051879.png" alt="image-20240527105122660"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// 解析DBR参数，解析出有用的参数</span></span><br><span class="line">    <span class="type">fat_t</span> *fat = &amp;fs-&gt;fat_data;</span><br><span class="line">    fat-&gt;fat_buffer = (<span class="type">uint8_t</span> *)dbr;</span><br><span class="line">    fat-&gt;bytes_per_sec = dbr-&gt;BPB_BytsPerSec;</span><br><span class="line">    fat-&gt;tbl_start = dbr-&gt;BPB_RsvdSecCnt;</span><br><span class="line">    fat-&gt;tbl_sectors = dbr-&gt;BPB_FATSz16;</span><br><span class="line">    fat-&gt;tbl_cnt = dbr-&gt;BPB_NumFATs;</span><br><span class="line">    fat-&gt;root_ent_cnt = dbr-&gt;BPB_RootEntCnt;</span><br><span class="line">    fat-&gt;sec_per_cluster = dbr-&gt;BPB_SecPerClus;</span><br><span class="line">    fat-&gt;cluster_byte_size = fat-&gt;sec_per_cluster * dbr-&gt;BPB_BytsPerSec;</span><br><span class="line">	fat-&gt;root_start = fat-&gt;tbl_start + fat-&gt;tbl_sectors * fat-&gt;tbl_cnt;</span><br><span class="line">    fat-&gt;data_start = fat-&gt;root_start + fat-&gt;root_ent_cnt * <span class="number">32</span> / SECTOR_SIZE;</span><br><span class="line">    fat-&gt;curr_sector = <span class="number">-1</span>;</span><br><span class="line">    fat-&gt;fs = fs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 简单检查是否是FAT16文件系统</span></span><br><span class="line">	<span class="keyword">if</span> (fat-&gt;tbl_cnt != <span class="number">2</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;fat table num error, major: %x, minor: %x&quot;</span>, major, minor);</span><br><span class="line">		<span class="keyword">goto</span> mount_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kernel_memcmp(dbr-&gt;BS_FileSysType, <span class="string">&quot;FAT16&quot;</span>, <span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        log_printf(<span class="string">&quot;not a fat16 file system, major: %x, minor: %x&quot;</span>, major, minor);</span><br><span class="line">        <span class="keyword">goto</span> mount_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录相关的打开信息</span></span><br><span class="line">    fs-&gt;type = FS_FAT16;</span><br><span class="line">    fs-&gt;data = &amp;fs-&gt;fat_data;</span><br><span class="line">    fs-&gt;dev_id = dev_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">mount_failed:</span><br><span class="line">    <span class="keyword">if</span> (dbr) &#123;</span><br><span class="line">        memory_free_page((<span class="type">uint32_t</span>)dbr);</span><br><span class="line">    &#125;</span><br><span class="line">    dev_close(dev_id);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatfs_unmount</span> <span class="params">(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs)</span> &#123;</span><br><span class="line">    <span class="type">fat_t</span> * fat = (<span class="type">fat_t</span> *)fs-&gt;data;</span><br><span class="line"></span><br><span class="line">    dev_close(fs-&gt;dev_id);</span><br><span class="line">    memory_free_page((<span class="type">uint32_t</span>)fat-&gt;fat_buffer);  <span class="comment">// 释放FAT表项缓冲</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-7-遍历目录命令ls"><a href="#19-7-遍历目录命令ls" class="headerlink" title="19.7 遍历目录命令ls"></a>19.7 遍历目录命令ls</h2><p>目前的项目有一个问题：</p>
<p>在<code>first_task()</code>中有系统调用相关的工作，因此在<code>kernel.lds</code>中将系统调用相关的代码和数据放到了内核空间中，如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PROVIDE(s_text = .);</span><br><span class="line">.text : &#123;</span><br><span class="line">	*(EXCLUDE_FILE(*first_task* *lib_syscall*) .text)</span><br><span class="line">&#125;</span><br><span class="line">.rodata : &#123;</span><br><span class="line">	*(EXCLUDE_FILE(*first_task* *lib_syscall*) .rodata)</span><br><span class="line">&#125;</span><br><span class="line">PROVIDE(e_text = .);</span><br><span class="line"></span><br><span class="line">. = ALIGN(4096);</span><br><span class="line">PROVIDE(s_data = .);</span><br><span class="line">.data : &#123;</span><br><span class="line">	*(EXCLUDE_FILE(*first_task* *lib_syscall*) .data)</span><br><span class="line">&#125;</span><br><span class="line">.bss : &#123;</span><br><span class="line">	*(EXCLUDE_FILE(*first_task* *lib_syscall*) .bss)</span><br><span class="line">&#125;</span><br><span class="line">e_data = .;</span><br></pre></td></tr></table></figure>

<p>然而我们在<code>lib_syscall.c</code>的下述函数中调用了<code>newlib</code>库的<code>malloc()/free()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DIR *<span class="title function_">opendir</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span> <span class="params">(DIR *dir)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span> <span class="params">(DIR *dir)</span>;</span><br></pre></td></tr></table></figure>

<p>但是在链接脚本中并没有把内核空间和<code>newlib</code>库链接起来，因此在编译时就找不到<code>malloc()/free()</code>。</p>
<p>有两种解决方法：</p>
<ol>
<li>将<code>newlib</code>库也加入到内核空间中；——不推荐，会使得内核体积膨胀</li>
<li>将<code>lib_syscall.c</code>复制一份到<code>kernel/init</code>中，同时在<code>CMakeLists.txt</code>中去掉<code>-lapp</code>。</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// set(LIBS_FLAGS <span class="string">&quot;-L $&#123;CMAKE_BINARY_DIR&#125;/source/applib/ -lapp&quot;</span>)</span><br><span class="line">set(LIBS_FLAGS <span class="string">&quot;-L $&#123;CMAKE_BINARY_DIR&#125;/source/applib/&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>增加<code>ls</code>命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 显示目录</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_ls</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span> &#123;</span><br><span class="line">    DIR *p_dir = opendir(<span class="string">&quot;temp&quot;</span>);  <span class="comment">// 本项目暂只支持顶层目录访问</span></span><br><span class="line">    <span class="keyword">if</span> (p_dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open dir failed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(p_dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c %s %d&quot;</span>,</span><br><span class="line">            entry-&gt;type = FILE_DIR ? <span class="string">&#x27;d&#x27;</span> : <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">            entry-&gt;name,</span><br><span class="line">            entry-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(p_dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">file_type_t</span> &#123;</span></span><br><span class="line">    FILE_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">    FILE_TTY,</span><br><span class="line">    FILE_DIR,</span><br><span class="line">    FILE_NORMAL,</span><br><span class="line">&#125;<span class="type">file_type_t</span>;</span><br></pre></td></tr></table></figure>

<p>由于对每个类型的文件的遍历方式不同，因此在<code>_fs_op_t</code>中增加相应的接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fs_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fs_op_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*mount)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">int</span> major, <span class="type">int</span> minor);   <span class="comment">// mount 挂载</span></span><br><span class="line">    <span class="type">void</span> (*unmount)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs);                      <span class="comment">// unmount 取消挂载</span></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">file_t</span> *file);  <span class="comment">// fs的相关信息会放入file中</span></span><br><span class="line">    <span class="type">int</span> (*read)(<span class="type">char</span> *buf, <span class="type">int</span> size, <span class="type">file_t</span> *file);</span><br><span class="line">    <span class="type">int</span> (*write)(<span class="type">char</span> *buf, <span class="type">int</span> size, <span class="type">file_t</span> *file);</span><br><span class="line">    <span class="type">int</span> (*seek)(<span class="type">file_t</span> *file, <span class="type">uint32_t</span> offset, <span class="type">int</span> dir);</span><br><span class="line">    <span class="type">int</span> (*stat)(<span class="type">file_t</span> *file, <span class="keyword">struct</span> stat *st);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="type">file_t</span> *file);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*opendir) (<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, <span class="type">const</span> <span class="type">char</span> *name, DIR *dir);</span><br><span class="line">    <span class="type">int</span> (*readdir) (<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, DIR *dir, <span class="keyword">struct</span> dirent *dirent);</span><br><span class="line">    <span class="type">int</span> (*closedir) (<span class="keyword">struct</span> <span class="type">_fs_t</span> *fs, DIR *dir);</span><br><span class="line">&#125;<span class="type">fs_op_t</span>;</span><br></pre></td></tr></table></figure>

<p>具体的调用实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name, DIR * dir)</span> &#123;</span><br><span class="line">	fs_protect(root_fs);</span><br><span class="line">	<span class="type">int</span> err = root_fs-&gt;op-&gt;opendir(root_fs, name, dir);</span><br><span class="line">	fs_unprotect(root_fs);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_readdir</span><span class="params">(DIR* dir, <span class="keyword">struct</span> dirent * dirent)</span> &#123;</span><br><span class="line">	fs_protect(root_fs);</span><br><span class="line">	<span class="type">int</span> err = root_fs-&gt;op-&gt;readdir(root_fs, dir, dirent);</span><br><span class="line">	fs_unprotect(root_fs);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_closedir</span><span class="params">(DIR *dir)</span> &#123;</span><br><span class="line">	fs_protect(root_fs);</span><br><span class="line">	<span class="type">int</span> err = root_fs-&gt;op-&gt;closedir(root_fs, dir);</span><br><span class="line">	fs_unprotect(root_fs);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">DIR *<span class="title function_">opendir</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    DIR *dir = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DIR));</span><br><span class="line">    <span class="keyword">if</span> (dir == (DIR *)<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (DIR *)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_opendir;</span><br><span class="line">    args.arg0 = (<span class="type">int</span>)path;</span><br><span class="line">    args.arg1 = (<span class="type">int</span>)dir;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err = sys_call(&amp;args);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(dir);</span><br><span class="line">        <span class="keyword">return</span> (DIR *)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span> <span class="params">(DIR *dir)</span> &#123;</span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_readdir;</span><br><span class="line">    args.arg0 = (<span class="type">int</span>)dir;</span><br><span class="line">    args.arg1 = (<span class="type">int</span>)&amp;dir-&gt;dirent;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err = sys_call(&amp;args);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// free(dir);  // 这里不应该free(dir)，否则就会和closedir()中的free重复</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">struct</span> dirent *)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;dir-&gt;dirent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span> <span class="params">(DIR *dir)</span> &#123;</span><br><span class="line">    <span class="type">syscall_args_t</span> args;</span><br><span class="line">    args.id = SYS_closedir;</span><br><span class="line">    args.arg0 = (<span class="type">int</span>)dir;</span><br><span class="line">    sys_call(&amp;args);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尤其注意<code>readdir()</code>这一行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free(dir);  // 这里不应该free(dir)，否则就会和closedir()中的free重复</span></span><br></pre></td></tr></table></figure>



<p>FAT16文件系统将顶层目录下的所有文件和目录的信息放在<strong>根目录区</strong>中，因此可以通过读取根目录区中的内容获取根目录下所有的文件和目录信息。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271559579.png" alt="image-20240527155922869"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271559465.png" alt="image-20240527155900689"></p>
<h2 id="19-8-文件查看命令less"><a href="#19-8-文件查看命令less" class="headerlink" title="19.8 文件查看命令less"></a>19.8 文件查看命令less</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271834662.png" alt="image-20240527183438134"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 列出文本文件内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_less</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271856539.png" alt="image-20240527185627202"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405271857558.png" alt="image-20240527185722278"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/13/Computer/C++/%E5%AF%B9%E5%90%AB%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E8%BF%9B%E8%A1%8Csizeof/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/13/Computer/C++/%E5%AF%B9%E5%90%AB%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E8%BF%9B%E8%A1%8Csizeof/" class="post-title-link" itemprop="url">对含有虚函数的类进行sizeof</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-13 18:57:45" itemprop="dateCreated datePublished" datetime="2024-06-13T18:57:45+08:00">2024-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-05 10:41:33" itemprop="dateModified" datetime="2024-07-05T10:41:33+08:00">2024-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>561</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoMember</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i1;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g3</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h3</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * B3继承空类和B2：</span></span><br><span class="line"><span class="comment"> *  由于本身有数据成员，所以空类的大小并未计算进来；</span></span><br><span class="line"><span class="comment"> *  继承B2的数据成员i1</span></span><br><span class="line"><span class="comment"> * 最终的大小为：4(i2) + 8(vptr) + 4(i1) = 16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B3</span> : <span class="keyword">public</span> NoMember, <span class="keyword">public</span> B2 &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h1</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * B4继承B1和B2：</span></span><br><span class="line"><span class="comment"> *  继承B1的数据成员ch</span></span><br><span class="line"><span class="comment"> *  继承B2的数据成员i1</span></span><br><span class="line"><span class="comment"> * 4(i3) + 8(vptr_B1) + 1(ch) + 4(i1) + 8(vptr_B2) = 25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B4</span> : <span class="keyword">public</span> B1, <span class="keyword">public</span> B2 &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i3;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g2</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h2</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共用虚基类A的虚表指针，内存大小为 4(int) + 8(指向虚基类A的指针) = 12</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfunB</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共用虚基类A的虚表指针，内存大小为 4(int) + 8(指向虚基类A的指针) = 12</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfunC</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于B,C都是虚继承，因此D只包含一个A的副本</span></span><br><span class="line"><span class="comment">// 内存大小为 4(int) + 8(B类中指向虚基类A的指针) + 8(C类中指向虚基类A的指针) = 20</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfunD</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(char b[10]) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="number">10</span>; <span class="comment">// 定义数组大小</span></span><br><span class="line">    std::array&lt;<span class="type">int</span>, n&gt; arr; <span class="comment">// 创建 std::array 对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(std::array&lt;int, &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;&gt;) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::string s1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(std::string s1) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s1) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(Base) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(NoMember) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(NoMember) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B1) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B1) &lt;&lt; std::endl;  <span class="comment">// 9    |   16</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B2) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B2) &lt;&lt; std::endl;  <span class="comment">// 12   |   16</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B3) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B3) &lt;&lt; std::endl;  <span class="comment">// 16   |   16</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B4) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B4) &lt;&lt; std::endl;  <span class="comment">// 25   |   32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(A) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; std::endl;  <span class="comment">// 4</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(B) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; std::endl;  <span class="comment">// 12</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(C) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(C) &lt;&lt; std::endl;  <span class="comment">// 12</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(D) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(D) &lt;&lt; std::endl;  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/12/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/12/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-12 17:03:47" itemprop="dateCreated datePublished" datetime="2024-06-12T17:03:47+08:00">2024-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-12 10:23:38" itemprop="dateModified" datetime="2024-07-12T10:23:38+08:00">2024-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>34k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2:03</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h2 id="一、线程与进程"><a href="#一、线程与进程" class="headerlink" title="一、线程与进程"></a>一、线程与进程</h2><h3 id="1、进程和线程以及并发和并行的概念是什么？"><a href="#1、进程和线程以及并发和并行的概念是什么？" class="headerlink" title="1、进程和线程以及并发和并行的概念是什么？"></a>1、进程和线程以及并发和并行的概念是什么？</h3><p><strong>进程</strong>：</p>
<ul>
<li>进程是系统资源分配的最小单位；</li>
<li>进程在 Linux 中通过 <code>fork</code> 系统调用创建，子进程拥有独立的内存空间。每个进程有独立的进程控制块 PCB，包含进程状态、寄存器、内存管理信息等。</li>
</ul>
<p><strong>线程</strong>：</p>
<ul>
<li>线程是操作系统中的最小执行单元；</li>
<li>线程在 Linux 中通过 <code>pthread_create</code> 创建，每个线程都有独立的线程控制块 TCB，但共享进程的资源。</li>
</ul>
<p><strong>并发和并行</strong>：并发是在单个处理器上多个任务交替执行，实现多个线程同时执行的假象；而并行是在多个处理器上实现多个线程同时执行。</p>
<blockquote>
<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，<strong>一个进程崩溃后，在保护模式下不会对其它进程产生影响</strong>，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，<strong>一个线程死掉就等于整个进程死掉</strong>，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<p>在 Linux 中，<strong>线程不会拥有独立的内存空间。所有线程共享进程的虚拟地址空间，但每个线程拥有自己独立的栈空间和寄存器集合。</strong>共享内存空间使得线程之间的通信比进程间通信更加高效，但也意味着需要通过同步机制（如互斥锁）来保护共享资源，防止竞态条件。</p>
</blockquote>
<h3 id="2、线程比进程具有哪些优势？"><a href="#2、线程比进程具有哪些优势？" class="headerlink" title="2、线程比进程具有哪些优势？"></a>2、线程比进程具有哪些优势？</h3><ol>
<li>线程在程序中是独立的，并发的执行流，只是同一进程中的多个线程间的隔离程度较小；</li>
<li>当操作系统创建⼀个进程时，必须为进程分配独立的内存空间，并分配大量相关资源；但对于同一进程中的多个线程来说，它们共享进程的虚拟地址空间，每个线程只拥有自己独立的栈空间和寄存器集合。</li>
</ol>
<h3 id="【-】3、什么时候用多进程？什么时候用多线程？"><a href="#【-】3、什么时候用多进程？什么时候用多线程？" class="headerlink" title="【*】3、什么时候用多进程？什么时候用多线程？"></a>【*】3、什么时候用多进程？什么时候用多线程？</h3><ol>
<li><p>需要<strong>频繁创建销毁</strong>的优先用线程；</p>
<p>线程的创建和销毁相对于进程来说更为轻量级，开销更小。线程共享同一个进程的地址空间，可以快速创建和销毁，而进程创建时需要分配独立的地址空间，并且系统调用的开销较大。</p>
</li>
<li><p>需要<strong>进行大量计算</strong>的优先使用线程；</p>
<p>大量计算任务通常需要频繁访问和操作内存。线程共享同一个进程的地址空间，可以快速访问共享数据，避免了进程间通信的开销。另外，线程之间的上下文切换速度较快，更适合 CPU 密集型的计算任务。</p>
</li>
<li><p><strong>强相关的处理</strong>用线程，<strong>弱相关的处理</strong>用进程；</p>
<p>强相关的处理通常需要频繁访问和操作相同的数据。由于线程共享同一地址空间，数据共享和同步相对简单，适合处理强相关的任务。弱相关的处理任务之间相对独立，进程之间互不干扰，独立的地址空间增加了隔离性和安全性，因此弱相关的处理任务使用进程更加合适。</p>
</li>
<li><p>可能要扩展到<strong>多机分布</strong>的用进程，<strong>多核分布</strong>的用线程。</p>
<p><strong>多机分布要求任务能够在不同的物理机器上独立运行</strong>。进程具有独立的地址空间和资源，可以在不同机器之间通过网络进行通信，适合分布式系统。而<strong>多核分布则是指在同一台多核机器上进行并行处理</strong>。线程共享同一进程的地址空间，能够在多核 CPU 上高效运行，利用多核的并行计算能力。</p>
</li>
</ol>
<h3 id="【-】4、线程内存存储在哪里？"><a href="#【-】4、线程内存存储在哪里？" class="headerlink" title="【*】4、线程内存存储在哪里？"></a>【*】4、线程内存存储在哪里？</h3><ol>
<li><strong>线程栈</strong>（Thread Stack）：每个线程都有自己的栈空间，这是线程存储本地变量、函数参数和返回地址的地方。线程栈通常有固定的大小，这个大小可以在创建线程时指定，也可能由操作系统预设。这部分内存通常位于用户空间的栈内存中。</li>
<li><strong>寄存器集</strong>：包括程序计数器、堆栈指针和其他必要的硬件寄存器。这些通常是在处理器内部维护的，并且每个线程都有自己的寄存器状态。</li>
<li><strong>线程局部存储（TLS）</strong>：这是一种允许数据在多个线程之间被隔离的机制。每个线程可以访问自己的专用数据副本，对其他线程不可见。这在编程中用于保持数据的线程安全性。</li>
<li><strong>线程控制块（TCB）</strong>：这是一个内核数据结构，包含了管理线程所需的所有信息，如线程的状态、优先级、调度信息等。线程控制块通常存储在操作系统内核的内存中。</li>
</ol>
<p>这些部分合在一起定义了一个线程的运行环境。每个线程的栈是独立的，但它们共享进程的堆和其他全局资源。</p>
<h3 id="5、线程中的锁包含哪些？"><a href="#5、线程中的锁包含哪些？" class="headerlink" title="5、线程中的锁包含哪些？"></a>5、线程中的锁包含哪些？</h3><ol>
<li><strong>互斥锁</strong>：用于对共享资源的互斥访问。当有线程对该资源加了互斥锁后，其他线程尝试加锁时会被阻塞，直至锁被释放。</li>
<li><strong>递归锁</strong>：是一种特殊的互斥锁，当有同一个线程尝试对同一个线程不断加锁时，不会被阻塞。</li>
<li><strong>读写锁</strong>：允许多个线程同时进行读操作，但仅允许一个线程进行写操作，使用在读多于写的场景。</li>
<li><strong>自旋锁</strong>：当有线程对资源加了自旋锁后，其他线程尝试加锁时将忙等待，而非被阻塞。</li>
</ol>
<h3 id="6、什么是死锁？"><a href="#6、什么是死锁？" class="headerlink" title="6、什么是死锁？"></a>6、什么是死锁？</h3><p><strong>死锁</strong>（Deadlock）是指在多线程或多进程的环境中，两个或多个执行单元因为争夺资源而造成的一种相互等待的现象，如果没有外力干涉，这些进程将无法向前推进。</p>
<h3 id="7、死锁产生的原因"><a href="#7、死锁产生的原因" class="headerlink" title="7、死锁产生的原因"></a>7、死锁产生的原因</h3><p>死锁产生主要有以下几个条件，这些条件<strong>同时满足</strong>时，就可能发生死锁：</p>
<ol>
<li><strong>互斥条件</strong>：资源不能被多个线程（或进程）共享，只能被一个线程（或进程）所占用。</li>
<li><strong>请求与保持条件</strong>：线程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他线程占有。</li>
<li><strong>不剥夺条件</strong>：线程所获得的资源在未使用完之前，不能被其他线程强行剥夺。</li>
<li><strong>循环等待条件</strong>：存在一种线程资源循环等待链，每个线程占有一种资源并等待另一种被下一个线程占有的资源。</li>
</ol>
<h3 id="【-】8、如何避免死锁？"><a href="#【-】8、如何避免死锁？" class="headerlink" title="【*】8、如何避免死锁？"></a>【*】8、如何避免死锁？</h3><ol>
<li>系统对进程发出每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源。如果分配后系统可能发生死锁，则不予分配，否则予以分配。保证系统不进入死锁状态的动态策略。</li>
<li>在系统设计、进程调度等方面注意如何让这四个必要条件不成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</li>
</ol>
<h3 id="9、如果有两个线程-1、2-去访问同一个资源-C-，并且二者必须同时获取锁-A-和-B-才可以访问-C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？"><a href="#9、如果有两个线程-1、2-去访问同一个资源-C-，并且二者必须同时获取锁-A-和-B-才可以访问-C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？" class="headerlink" title="9、如果有两个线程 1、2 去访问同一个资源 C ，并且二者必须同时获取锁 A 和 B 才可以访问 C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？"></a>9、如果有两个线程 1、2 去访问同一个资源 C ，并且二者必须同时获取锁 A 和 B 才可以访问 C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？</h3><ol>
<li>如果两个线程同时去分别获取不同的锁时，会出现死锁，比如线程 1 先获得锁 A 而线程 2 先获得锁 B，然后二者都会等待；</li>
<li>正确的获取和释放顺序是：<ol>
<li><strong>按照固定顺序获取锁</strong>：所有线程都按照相同的顺序获取锁，例如，先获取锁 <code>A</code>，然后获取锁 <code>B</code>；</li>
<li><strong>使用 try-lock 方法</strong>：尝试获取锁，如果获取不到，就放弃所有已持有的锁，稍后重试。</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex lockA;</span><br><span class="line">std::mutex lockB;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guardA</span><span class="params">(lockA)</span></span>; <span class="comment">// 获取锁A</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>)); <span class="comment">// 模拟一些工作</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guardB</span><span class="params">(lockB)</span></span>; <span class="comment">// 获取锁B</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 1 has acquired both locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guardA</span><span class="params">(lockA)</span></span>; <span class="comment">// 获取锁A</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>)); <span class="comment">// 模拟一些工作</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guardB</span><span class="params">(lockB)</span></span>; <span class="comment">// 获取锁B</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread 2 has acquired both locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10、从锁的粒度来说，有哪些？"><a href="#10、从锁的粒度来说，有哪些？" class="headerlink" title="10、从锁的粒度来说，有哪些？"></a>10、从锁的粒度来说，有哪些？</h3><p>（1）<strong>粗粒度锁</strong>：</p>
<ul>
<li><strong>全局锁</strong>：对整个应用程序或系统加锁，通常用于单个进程或单个应用实例中；</li>
<li><strong>模块级锁</strong>：对某个模块或组件加锁，通常用于大型系统中。</li>
</ul>
<p>（2）<strong>细粒度锁</strong>：</p>
<ul>
<li><strong>对象锁</strong>：对单个对象加锁。</li>
<li><strong>方法锁</strong>：对单个方法加锁；</li>
<li><strong>变量锁</strong>：对单个变量或数据结构加锁。</li>
</ul>
<h3 id="11、悲观锁和乐观锁？"><a href="#11、悲观锁和乐观锁？" class="headerlink" title="11、悲观锁和乐观锁？"></a>11、悲观锁和乐观锁？</h3><p>悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。互斥锁、自旋锁、读写锁都属于悲观锁。</p>
<p>相反的，如果并发操作之间的冲突很少，就可以使用乐观锁，它的工作方式是：在读取数据时不加锁，而是在更新数据时检查数据是否发生变化。如果数据没有变化，则进行更新；如果数据发生变化，则放弃更新并重新尝试。</p>
<h3 id="12、忙等待和阻塞的区别是什么？"><a href="#12、忙等待和阻塞的区别是什么？" class="headerlink" title="12、忙等待和阻塞的区别是什么？"></a>12、忙等待和阻塞的区别是什么？</h3><p><strong>（1）忙等待（Busy Waiting）</strong>：忙等待指线程在等待锁或资源可用期间<strong>不断地检查锁的状态，而不进行任何上下文切换</strong>，这种等待方式会使线程保持活跃状态，具有低延迟的特点，但占用 CPU 时间。适用于高并发、低延迟需求的实时系统；如果锁等待时间较长，忙等待会导致大量的 CPU 资源浪费。</p>
<p><strong>（2）阻塞（Blocking）</strong>：阻塞指线程在等待锁或资源可用期间会<strong>被挂起，进入睡眠状态，直到条件满足或锁可用时被唤醒</strong>。这种机制需要操作系统的线程调度和上下文切换支持，但释放了 CPU 资源，以便被其他线程使用。适用于长时间等待或锁持有时间较长的情况，避免了 CPU 资源的浪费。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忙等待</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 忙等待，直到 ready 变为 true</span></span><br><span class="line">    <span class="keyword">while</span> (!ready) &#123;  </span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));  <span class="comment">// 忙等待期间可以加入适当的休眠，减少 CPU 资源浪费</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker is running!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(worker)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));  <span class="comment">// 模拟一些工作</span></span><br><span class="line">    ready = <span class="literal">true</span>;  <span class="comment">// 设置ready为true，此时worker线程会自动检测到这一情况并执行</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞等待，直到ready变为true</span></span><br><span class="line">    <span class="comment">// 此处ready为共享变量，因此用lock来保护</span></span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> ready; &#125;);  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker is running!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(worker)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));      <span class="comment">// 模拟一些工作</span></span><br><span class="line">    <span class="comment">// 唤醒worker线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();  </span><br><span class="line">    <span class="comment">// worker线程会在ready变为true之前阻塞等待，而不会浪费CPU资源进行忙等待</span></span><br><span class="line">    <span class="comment">// 一旦ready变为true，worker线程就会被唤醒并继续执行</span></span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>t.join();</code> 是用于等待线程完成执行的一种方法。<code>std::thread</code> 类的 <code>join</code> 成员函数可以确保主线程（或其他调用 <code>join</code> 的线程）等待一个线程完成其执行，并在其完成后继续执行。</p>
<p>具体作用如下：</p>
<ol>
<li><strong>等待线程完成：</strong> <code>t.join();</code> 会阻塞调用线程，直到线程 <code>t</code> 完成其执行。</li>
<li><strong>清理资源：</strong> <code>join</code> 还会清理与线程相关的资源。如果不调用 <code>join</code> 或 <code>detach</code>，在线程对象生命周期结束时会导致程序异常。</li>
</ol>
</blockquote>
<h3 id="13、一个进程可以创建多少线程？和什么有关？"><a href="#13、一个进程可以创建多少线程？和什么有关？" class="headerlink" title="13、一个进程可以创建多少线程？和什么有关？"></a>13、一个进程可以创建多少线程？和什么有关？</h3><p>分不同系统去看。</p>
<ul>
<li>如果是 <code>32</code> 位系统，用户态的虚拟空间只有 <code>3G</code>，如果创建线程时分配的栈空间是 <code>10M</code>，那么一个进程最多只能创建 <code> 300 (3G/10M)</code> 个左右的线程。</li>
<li>如果是 <code>64</code> 位系统，用户态的虚拟空间大到有 <code>128T</code>，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制，比如以下三个内核参数：<ul>
<li><code>/proc/sys/kernel/threads-max</code>，表示系统支持的最大线程数，默认值是 <code>14553</code>；</li>
<li><code>/proc/sys/kernel/pid_max</code>，表示系统全局的 PID 号数值的限制，每一个进程或线程都有 ID，ID 的值超过这个数，进程或线程就会创建失败，默认值是 <code>32768</code>；</li>
<li><code>/proc/sys/vm/max_map_count</code>，表示限制一个进程可以拥有的 VMA (虚拟内存区域)的数量，默认值是 <code>65530</code>。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202407032203672.png" alt="image-20240703220333465" style="zoom:80%;" />

<h3 id="14、多线程如何保证线程安全？"><a href="#14、多线程如何保证线程安全？" class="headerlink" title="14、多线程如何保证线程安全？"></a>14、多线程如何保证线程安全？</h3><ol>
<li>使用<strong>互斥锁（Mutex）</strong>保护共享资源。</li>
<li>使用<strong>自旋锁（Spinlock）</strong>在短时间锁定的场景。</li>
<li>使用<strong>条件变量（Condition Variable）</strong>进行线程间通信。</li>
<li>使用<strong>原子操作（Atomic Operations）</strong>进行无锁编程。</li>
<li>使用<strong>读写锁（Reader-Writer Lock）</strong>优化读多写少的场景。</li>
<li>使用<strong>线程局部存储（Thread-Local Storage）</strong>确保每个线程独立的数据。</li>
</ol>
<h3 id="15、多线程环境下对变量的读写操作是否是原子的？"><a href="#15、多线程环境下对变量的读写操作是否是原子的？" class="headerlink" title="15、多线程环境下对变量的读写操作是否是原子的？"></a>15、多线程环境下对变量的读写操作是否是原子的？</h3><p>不一定是原子性的。（1）对基本数据类型的赋值操作通常被认为是原子性的，因为它们在单个指令周期内完成；（2）而对于那些被总线带宽、cache line 以及 page 大小给分隔开的内存地址的访问则不是原子性的。</p>
<p>以下是举例说明：</p>
<p>1）对于 <code>x=1</code> 来说，因为 x 是 int 类型，在 x86 上由硬件直接提供了原子性支持。在进行这样的赋值操作时，CPU 会将整个 32 位的值一次性写入到内存中，而不是分开写入。因此，即使有多个线程同时执行类似 <code>x=1</code> 的赋值语句，也不会出现损坏 x 值的情况。</p>
<p>2）对于 <code>x++</code> 和 <code>++x</code> 来说，这样的操作在多线程环境下是需要同步的。因为 x86 会按三条指令的形式来处理这种语句：A. 从内存中读 x 的值到寄存器中；B. 对寄存器加 1；C. 再把新值写回 x 所处的内存地址。</p>
<blockquote>
<p>（1）一些基本的内存读写操作本身已经被硬件提供了原子性保证（例如读写单个字节的操作）；</p>
<p>（2）一些需要保证原子性但是没有被第（1）条机制提供支持的操作（例如read-modify-write）可以通过使用”LOCK#”来锁定总线，从而保证操作的原子性；</p>
<p>（3）因为很多内存数据是已经存放在L1&#x2F;L2 cache中了，对这些数据的原子操作只需要与本地的cache打交道，而不需要与总线打交道，所以CPU就提供了cache  coherency机制来保证其它的那些也cache了这些数据的processor能读到最新的值（关于cache coherency可以参加我的<a target="_blank" rel="noopener" href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/">一篇博文</a>）。</p>
</blockquote>
<blockquote>
<p>从Intel486 processor开始，<strong>以下的基本内存操作是原子的</strong>：<br>• Reading or writing a byte（<strong>一个字节的读写</strong>）<br>• Reading or writing a word aligned on a 16-bit boundary（<strong>对齐到16位边界的字的读写</strong>）<br>• Reading or writing a doubleword aligned on a 32-bit boundary（<strong>对齐到32位边界的双字的读写</strong>）</p>
<p>从Pentium processor开始，除了之前支持的原子操作外又新增了以下原子操作：<br>• Reading or writing a quadword aligned on a 64-bit boundary（<strong>对齐到64位边界的四字的读写</strong>）<br>• 16-bit accesses to uncached memory locations that fit within a 32-bit data bus（<strong>未缓存且在32位数据总线范围之内的内存地址的访问</strong>）</p>
<p>从P6 family processors开始，除了之前支持的原子操作又新增了以下原子操作：<br>• Unaligned 16-, 32-, and 64-bit accesses to cached memory that fit within a cache line（<strong>对单个cache line中缓存地址的未对齐的16&#x2F;32&#x2F;64位访问</strong>）</p>
<p><strong>那么哪些操作是非原子的呢？</strong><br>Accesses to cacheable memory that are split across bus widths, cache lines, and page boundaries are not guaranteed to be atomic by the Intel Core 2 Duo, Intel® Atom™, Intel Core Duo, Pentium M, Pentium 4, Intel Xeon, P6 family, Pentium, and Intel486 processors.（说点简单点，<strong>那些被总线带宽、cache line以及page大小给分隔开了的内存地址的访问不是原子的</strong>，你如果想保证这些操作是原子的，你就得求助于机制（2），对总线发出相应的控制信号才行）。</p>
</blockquote>
<h3 id="16、为什么线程的开销要小于进程的开销？"><a href="#16、为什么线程的开销要小于进程的开销？" class="headerlink" title="16、为什么线程的开销要小于进程的开销？"></a>16、为什么线程的开销要小于进程的开销？</h3><p>首先，任务调度的开销主要包含以下两个方面：</p>
<ol>
<li><p>CPU执行任务调度的开销，主要是<strong>上下文切换</strong>的开销；</p>
</li>
<li><p>任务调度后，CPU Cache&#x2F;TLB 不命中，导致<strong>缺页中断</strong>的开销。</p>
</li>
</ol>
<p>针对第 1 点，无论是进程调度还是线程调度都是必须的，因此两者的差异体现在第 2 点。</p>
<p>进程切换会导致页表、cache、TLB 中的内容发生变化，原进程保存的内容无效，新的进程必须重新加载，导致缺页中断增多，cache，TLB 也命中率下降。而线程切换会保留页表、cache、TLB 中的内容，因为多个线程之间共享进程的这部分资源。因此线程调度的开销要小于进程调度的开销。</p>
<h3 id="17、线程池中的线程数如何确定？"><a href="#17、线程池中的线程数如何确定？" class="headerlink" title="17、线程池中的线程数如何确定？"></a>17、线程池中的线程数如何确定？</h3><p>一般的经验法则是<strong>根据系统的硬件资源，特别是 CPU 的核心数</strong>来确定线程数。</p>
<ul>
<li><p>对于<strong>计算密集型任务</strong>，线程数通常设置为等于或稍大于 CPU 核心数。这样可以最大化CPU利用率，避免上下文切换的开销。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numThreads = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line"><span class="comment">// 返回可用的并发线程数（通常等于CPU核心数）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于<strong>I&#x2F;O 密集型任务</strong>，由于任务在执行过程中需要等待 I&#x2F;O 操作完成，因此线程数可设置为高于 CPU 核心数以隐藏 I&#x2F;O 等待时间，提高整体吞吐量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numThreads = std::thread::<span class="built_in">hardware_concurrency</span>() * <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 这个倍数可以根据实际情况调整，通常在2到4之间。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="18、为什么线程池可以提高吞吐量？"><a href="#18、为什么线程池可以提高吞吐量？" class="headerlink" title="18、为什么线程池可以提高吞吐量？"></a>18、为什么线程池可以提高吞吐量？</h3><ul>
<li><strong>减少线程创建和销毁的开销</strong>，线程池在初始化时会创建一定数量的线程，并将它们保存在池中。当任务到达时，线程池会分配一个空闲线程来执行任务，而不是每次都创建新线程。这样可以减少线程创建和销毁的开销，提高了任务处理的效率。</li>
<li><strong>复用线程资源</strong>，执行完一个任务后线程不会立即销毁，而是继续等待新的任务。这样可以避免频繁地创建和销毁线程，减少系统资源的消耗。</li>
<li><strong>控制并发线程数量</strong>，防止因过多线程竞争资源导致系统性能下降的情况发生。</li>
</ul>
<h3 id="【-】19、现在让你来设计一个支持最大并发数的线程池你可能会怎么设计呢？"><a href="#【-】19、现在让你来设计一个支持最大并发数的线程池你可能会怎么设计呢？" class="headerlink" title="【*】19、现在让你来设计一个支持最大并发数的线程池你可能会怎么设计呢？"></a>【*】19、现在让你来设计一个支持最大并发数的线程池你可能会怎么设计呢？</h3><p>可以考虑以下两方面：</p>
<ol>
<li><p><strong>任务管理</strong></p>
<ul>
<li><p><strong>任务队列</strong>：使用一个线程安全的队列存储待执行的任务。任务按照提交的顺序执行。</p>
</li>
<li><p><strong>调度机制</strong>：当线程池有空闲线程时，从任务队列中取出任务执行。如果任务队列为空，线程可以进入等待状态。</p>
</li>
</ul>
</li>
<li><p><strong>线程池管理</strong></p>
</li>
</ol>
<ul>
<li><p><strong>固定数量线程池</strong>：初始化时创建固定数量的线程（如3个），每个线程从任务队列中获取任务并执行。线程池的线程数量保持不变。</p>
</li>
<li><p><strong>动态管理</strong>：如果采用动态管理策略，可以根据负载调整线程数量，但在最大并发数内。</p>
</li>
<li><p><strong>同步机制</strong>：使用信号量或条件变量控制最大并发数。线程执行任务时减少计数，完成后增加计数，确保同时运行的线程不超过最大并发数。</p>
</li>
<li><p><strong>停止和清理</strong>：提供接口用于优雅地停止线程池，并确保所有任务完成后释放资源。</p>
</li>
</ul>
<blockquote>
<p>假设队列里边的任务是按时间顺序管理的，那么如果有个高优先级的事件你怎么处理，比如说我移动了一下鼠标它不可能等待所有线程执行完去执行，那怎么处理这样的事件？</p>
<p>如果任务队列的任务之间有依赖关系要怎么处理呢？如果采用同步是不是就死锁了？</p>
</blockquote>
<h3 id="20、C-多线程编程时要链接什么库，怎么找到对应的动态库？"><a href="#20、C-多线程编程时要链接什么库，怎么找到对应的动态库？" class="headerlink" title="20、C++ 多线程编程时要链接什么库，怎么找到对应的动态库？"></a>20、C++ 多线程编程时要链接什么库，怎么找到对应的动态库？</h3><p>链接 <code>pthread(POSIX threads)</code> 库或 C++11 标准库提供的线程支持库。</p>
<blockquote>
<ol>
<li><p>使用<code>pthread</code>库</p>
</li>
<li><p>链接<code>pthread</code>库</p>
<p>在Linux系统中，使用<code>pthread</code>库时需要在编译时加上<code>-pthread</code>选项。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o my_program my_program.cpp -pthread</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找和链接动态库</p>
<p>动态库一般位于系统的标准库路径中，如<code>/usr/lib</code>或<code>/usr/local/lib</code>。在运行时，操作系统会自动从这些路径中查找所需的动态库。如果动态库位于非标准路径，可以通过设置<code>LD_LIBRARY_PATH</code>环境变量来指定动态库路径。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/path/to/your/library:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>pthread</code>库进行多线程编程</p>
</li>
<li><p>使用 C++11 标准库：不需要额外链接任何库，编译器会自动处理。</p>
</li>
</ol>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o my_program my_program.cpp -std=c++11</span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="21、多线程切换，CPU-和内存会做一些什么处理？"><a href="#21、多线程切换，CPU-和内存会做一些什么处理？" class="headerlink" title="21、多线程切换，CPU 和内存会做一些什么处理？"></a>21、多线程切换，CPU 和内存会做一些什么处理？</h3><ol>
<li><strong>保存当前线程的上下文：</strong> 包括程序计数器（PC）、寄存器状态、栈指针（SP）、调度器信息等，便于在之后恢复线程时能够继续执行。</li>
<li><strong>加载下一个线程的上下文：</strong> CPU 根据调度算法选择下一个需要执行的线程，然后加载其上下文信息到寄存器和其他硬件状态中。</li>
<li><strong>切换内存空间：</strong> 不同进程的线程可能涉及页表（Page Table）等内存映射表的切换，以确保能访问到正确的内存空间。</li>
<li><strong>处理器流水线的清空和填充：</strong> 在进行线程切换时，可能存在流水线（Pipeline）中的指令未执行完毕。因此可能需要将流水线清空，以避免对新线程执行的指令产生影响。</li>
<li><strong>更新调度器信息：</strong>包括线程的状态（就绪、运行、阻塞等），以及相关的时间片（Time Slice）等调度参数。</li>
</ol>
<blockquote>
<p>进程切换的意义在于<strong>实现多任务操作系统的基本功能，使多个进程能够在有限的CPU资源下共享执行时间</strong>。</p>
</blockquote>
<h3 id="22、如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？"><a href="#22、如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？" class="headerlink" title="22、如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？"></a>22、如果现在有远远多于线程数量的任务在等待处理，要怎么分析这个问题？</h3><p>首先判断这个请求数量远远多于线程是否是常态：</p>
<ul>
<li>如果是常态则先要考虑是不是线程数量设置有问题，其次判断机器是否能力不足以处理这些数据；</li>
<li>假如说硬件和软件都没有问题，那么考虑这个问题为什么会产生，是不是<strong>高计算密集型任务</strong>太多了。如果说当前请求任务比较复杂，那么考虑进行分类，将处理的特别慢的请求作为一个特定类，将一些线程固定给他们使用，而不是所有线程都用来处理这种任务，因为既然很慢，那么慢1个和慢10个点区别就没有那么大了，然后将其他线程用来处理能够快速处理完的请求。</li>
</ul>
<h3 id="23、线程间的通信包括哪些方式？"><a href="#23、线程间的通信包括哪些方式？" class="headerlink" title="23、线程间的通信包括哪些方式？"></a>23、线程间的通信包括哪些方式？</h3><ol>
<li><p><strong>互斥锁（Mutex）</strong>：用于控制多个线程对共享资源的访问，保证同一时间只有一个线程可以访问资源。</p>
</li>
<li><p><strong>条件变量</strong>：利用线程间共享全局变量进行同步的一种机制。允许一个或多个线程在某些条件下暂停执行并等待，直到另一个线程通知它们条件已经满足，从而避免了线程不断轮询检查该条件是否成立而降低效率的情况。</p>
<ol>
<li><p>包含两种等待方式，无条件等待<code>pthread_cond_wait()</code>和计时等待<code>pthread_cond_timewait()</code>两种。注意无论哪种等待方式，都必须和一个互斥锁配合，以防止多个线程同时请求竞争条件；</p>
<blockquote>
<p><strong>条件变量为什么要和互斥锁一起使用？</strong></p>
<p>这是为了应对线程<code>1</code>在调用<code>pthread_cond_wait()</code>但线程<code>1</code>还没有进入<code>wait cond</code>的状态时，线程<code>2</code>调用了<code>cond_singal</code>的情况。 </p>
<p>如果不用互斥锁的话，这个<code>cond_singal</code>就丢失了。加了锁的情况下，线程<code>2</code>必须等到<code>mutex</code>被释放（也就是<code>pthread_cond_wait()</code>释放锁并进入<code>wait_cond</code>状态 ，此时线程<code>2</code>上锁） 的时候才能调用<code>cond_singal</code>。</p>
</blockquote>
</li>
<li><p>互斥锁必须是普通锁或者适应锁；</p>
</li>
<li><p>在调用<code>pthread_cond_wait()</code>前必须由本线程加锁，而在更新条件等待队列以前，<code>mutex</code>保持锁定状态，并<strong>在线程挂起进入等待前解锁</strong>；</p>
<blockquote>
<p><strong>为什么必须由本线程加锁，而不在函数内部定义？</strong></p>
<p>无法确定会有多少用户使用条件变量，所以每个互斥锁都须要动态定义，而且管理大量互斥锁的开销太大，使用用户定义的锁会更加灵活又方便。</p>
</blockquote>
</li>
<li><p>在条件满足从而离开<code>pthread_cond_wait()</code>之前，<code>mutex</code>将被重新加锁，以与进入<code>pthread_cond_wait()</code>前的加锁动作对应。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">thread2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);  <span class="comment">// 调用前由本线程加锁</span></span><br><span class="line">        pthread_cond_wait(&amp;cond,&amp;mutex);  <span class="comment">// 无条件等待（经历了解锁-&gt;加锁的过程）</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>信号量（Semaphores）</strong>：如同进程一样，线程也可以通过信号量来实现通信，虽然是轻量级的。 </p>
<ol>
<li><p>初始化信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span> <span class="params">(<span class="type">sem_t</span> *sem , <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// sem 		- 指定要初始化的信号量； </span></span><br><span class="line"><span class="comment">// pshared 	- 信号量 sem 的共享选项，linux只支持0，表示它是当前进程的局部信号量； </span></span><br><span class="line"><span class="comment">// value 	- 信号量 sem 的初始值。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>信号量值加<code>1 </code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>信号量值减<code>1 </code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>

<p>如果<code>sem</code>所指的信号量的数值为<code>0</code>，函数将会等待直到有其它线程使它不再是<code>0</code>为止，此时相当于获取到该信号。</p>
</li>
<li><p>销毁信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>事件（Event）</strong>：类似于条件变量，用于通知一个或多个正在等待的线程某个事件已经发生。</p>
</li>
<li><p><strong>屏障（Barriers）</strong>：用于多个线程同步到某一点，当所有线程都达到屏障点后，它们再同时开始执行后续操作。常用于并行计算，确保所有线程在进行下一步操作前已完成当前操作。</p>
</li>
</ol>
<h3 id="【-】24、线程同步是什么？从底层原理分析一下为什么会出现线程同步？"><a href="#【-】24、线程同步是什么？从底层原理分析一下为什么会出现线程同步？" class="headerlink" title="【*】24、线程同步是什么？从底层原理分析一下为什么会出现线程同步？"></a>【*】24、线程同步是什么？从底层原理分析一下为什么会出现线程同步？</h3><ol>
<li><p><strong>线程同步</strong>是多线程编程中保证多个线程安全访问共享资源或协调工作的一种机制。它确保在任何给定时刻，只有一个线程可以访问特定的数据或代码块，以防止数据损坏或不一致性。</p>
</li>
<li><p>底层原理上，线程同步问题主要是由于<strong>并发性、不确定性和原子性</strong>导致的：</p>
<ol>
<li><strong>并发性</strong>：多个线程同时执行，导致对共享资源的访问不可控；</li>
<li><strong>不确定性</strong>：线程的执行顺序和执行时间不确定，可能导致对共享资源的交叉访问</li>
<li><strong>原子性</strong>：对共享资源的操作可能不是原子操作，而是由多条指令组成，这会导致中间状态的出现，从而引发问题。</li>
</ol>
</li>
</ol>
<h3 id="25、处理多线程同步问题有哪些机制？如果想等待线程-a-执行完任务后再去执行-b，这种情况要怎么处理？"><a href="#25、处理多线程同步问题有哪些机制？如果想等待线程-a-执行完任务后再去执行-b，这种情况要怎么处理？" class="headerlink" title="25、处理多线程同步问题有哪些机制？如果想等待线程 a 执行完任务后再去执行 b，这种情况要怎么处理？"></a>25、处理多线程同步问题有哪些机制？如果想等待线程 a 执行完任务后再去执行 b，这种情况要怎么处理？</h3><p>在处理多线程同步问题时，常用的机制包括<strong>互斥锁、条件变量、信号量</strong>等。</p>
<p><strong>等待线程A执行完任务后再执行线程B的处理方式</strong></p>
<ol>
<li><p><strong>使用信号量：</strong></p>
<ul>
<li><p>通过 sem_init() 初始化信号量为 0。</p>
</li>
<li><p>线程 A 执行完任务后调用 sem_post() 释放信号量，通知线程 B 可以继续执行。</p>
</li>
<li><p>线程 B 调用 sem_wait() 等待信号量被释放，然后继续执行。</p>
</li>
</ul>
</li>
<li><p><strong>使用条件变量和互斥锁结合的方式：</strong></p>
<ul>
<li>创建互斥锁和条件变量，互斥锁用于保护共享数据的访问；条件变量作为共享状态变量，用于阻塞一个或多个线程，直到接收到其他线程的通知。</li>
<li>线程 A 执行完其任务后，修改共享状态变量，通知等待线程任务已完成。</li>
<li>线程 B 等待线程 A 完成任务，收到通知后继续执行。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">// For sleep function</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem;  <span class="comment">// 信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 任务A执行</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2. 释放信号量</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 等待信号量</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sem);</span><br><span class="line">    <span class="comment">// 2. 任务B执行</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 初始化信号量，初始值为0</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;sem);  <span class="comment">// 销毁信号量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;  <span class="comment">// 互斥锁</span></span><br><span class="line">std::condition_variable cv;  <span class="comment">// 条件变量</span></span><br><span class="line"><span class="type">bool</span> taskA_completed = <span class="literal">false</span>;  <span class="comment">// 任务A是否完成的标志</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 任务A执行</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2. 修改标志</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        taskA_completed = <span class="literal">true</span>;  <span class="comment">// 设置任务A完成的标志</span></span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();  <span class="comment">// cv.notify_one()/cv.notify_all() 通知等待线程任务A已完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 检测标志</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> taskA_completed; &#125;); <span class="comment">// cv.wait() 等待任务A完成</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 任务B执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="26、进程的五种状态分别是？"><a href="#26、进程的五种状态分别是？" class="headerlink" title="26、进程的五种状态分别是？"></a>26、进程的五种状态分别是？</h3><p>进程一共有 5 种状态，分别是<strong>创建、就绪、运行、阻塞、终止</strong>。</p>
<ul>
<li>运行状态就是进程正在 CPU 上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。</li>
<li>就绪状态就是说进程已处于准备运行的状态，即进程获得了除 CPU 之外的一切所需资源，一旦得到 CPU 即可运行。</li>
<li>阻塞状态就是进程正在等待某一事件而暂停运行，比如等待某资源为可用或等待 I&#x2F;O 完成。即使 CPU 空闲，该进程也不能运行。</li>
</ul>
<h3 id="【-】27、进程不同状态转换的关系？"><a href="#【-】27、进程不同状态转换的关系？" class="headerlink" title="【*】27、进程不同状态转换的关系？"></a>【*】27、进程不同状态转换的关系？</h3><p>进程在不同状态之间的转换过程如下：</p>
<ul>
<li><strong>创建态到就绪态</strong>：当进程创建完成并且准备好执行时，进程从创建态转换到就绪态，等待被调度执行。</li>
<li><strong>就绪态到运行态</strong>：当操作系统调度到了进程并且为其分配了CPU资源时，进程从就绪态转换到运行态，开始执行。</li>
<li><strong>运行态到阻塞态</strong>：当进程等待某些事件发生时，比如等待I&#x2F;O操作完成或者等待信号量的通知，进程从运行态转换到阻塞态。</li>
<li><strong>阻塞态到就绪态</strong>：当等待的事件发生并且进程重新具备执行条件时，进程从阻塞态转换到就绪态，等待被重新调度执行。</li>
<li><strong>运行态到终止态</strong>：当进程执行完成或者被操作系统终止时，进程从运行态转换到终止态，等待被清理和回收。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406131948229.png" alt="在这里插入图片描述"></p>
<h3 id="28、孤儿进程和僵尸进程是什么，怎么处理？"><a href="#28、孤儿进程和僵尸进程是什么，怎么处理？" class="headerlink" title="28、孤儿进程和僵尸进程是什么，怎么处理？"></a>28、孤儿进程和僵尸进程是什么，怎么处理？</h3><p>（1）<strong>孤儿进程</strong>：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被<code>init</code>进程（进程号为<code>1</code>）所收养，并由 <code>init</code> 进程对它们完成状态收集工作。</p>
<p>（2）<strong>僵尸进程</strong>：一个进程使用<code>fork</code>创建子进程，如果子进程退出，而父进程并没有调用<code>wait</code>或<code>waitpid</code>获取子进程的状态信息，那么<strong>子进程的进程描述符</strong>仍然保存在系统中。这种进程称之为僵尸进程。</p>
<p>（3）<strong>解决方案</strong>：</p>
<ul>
<li><p><strong>1）kill 杀死元凶父进程（一般不用）</strong></p>
</li>
<li><p><strong>2）通过信号机制，在处理函数中调用 wait，回收资源</strong></p>
<p>通过信号机制，子进程退出时向父进程发送 <code>SIGCHLD</code> 信号，父进程调用 <code>signal(SIGCHLD, sig_child)</code> 去处理 <code>SIGCHLD</code> 信号，在信号处理函数 <code>sig_child()</code> 中调用 <code>wait</code> 进行处理僵尸进程。什么时候得到子进程信号，什么时候进行信号处理，过程中父进程可以继续做其他工作，不用去阻塞等待。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_child</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> stat;</span><br><span class="line">    <span class="comment">// 使用循环回收所有已经结束的子进程</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Child &quot;</span> &lt;&lt; pid &lt;&lt; <span class="string">&quot; terminated&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGCHLD, sig_child); <span class="comment">// 设置信号处理程序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Child process &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; started&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">2</span>); <span class="comment">// 模拟子进程工作</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">// 子进程结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程可以继续做其他工作，不会被阻塞</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parent process doing work...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="29、两个进程的内核空间是共享的吗？"><a href="#29、两个进程的内核空间是共享的吗？" class="headerlink" title="29、两个进程的内核空间是共享的吗？"></a>29、两个进程的内核空间是共享的吗？</h3><p>在大多数现代操作系统中，包括 Linux 和 Windows，内核空间是在所有进程之间共享的。这意味着内核空间中的代码和数据结构对所有进程来说都是相同的，并且在任何时候都位于相同的物理内存位置。</p>
<h3 id="30、进程间的通信包括哪些方式？"><a href="#30、进程间的通信包括哪些方式？" class="headerlink" title="30、进程间的通信包括哪些方式？"></a>30、进程间的通信包括哪些方式？</h3><ol>
<li><p><strong>管道</strong>，半双工的通信方式，通常用于具有亲缘关系的进程之间的通信。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建管道</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>命名管道</strong>，与普通管道类似，但可以在无亲缘关系的进程之间使用。命名管道通过文件系统进行通信。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FILE <span class="string">&quot;/tmp/my_fifo&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;&#x27;hi midori&#x27; from writer(fifo)&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    fd = open(FIFO_FILE, O_WRONLY);  <span class="comment">// 打开命名管道</span></span><br><span class="line">    write(fd, message, <span class="built_in">strlen</span>(message) + <span class="number">1</span>);      <span class="comment">// 向命名管道写入数据</span></span><br><span class="line">    close(fd);      <span class="comment">// 关闭命名管道</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>消息队列</strong>，允许一个或多个进程向队列中发送消息，并从队列中接收消息。消息队列通常用于在不同进程之间传递结构化的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_buffer</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> msg_type;</span><br><span class="line">    <span class="type">char</span> msg_text[MSG_SIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建消息队列或获取现有消息队列的标识符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向消息队列发送消息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从消息队列接收消息</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对消息队列进行控制操作，如获取信息、修改权限、删除消息队列等</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>信号量</strong>，控制进程间访问共享资源的机制，可以用来解决进程同步和互斥的问题，防止竞态条件的发生。</p>
</li>
<li><p><strong>共享内存</strong>：</p>
<ul>
<li><p><strong>效率最高</strong>，允许多个进程共享同一块内存区域，没有数据复制的开销，进程可以直接读写共享内存中的数据。</p>
</li>
<li><p>不过，1）需要额外的同步机制（如信号量或互斥锁）来防止并发访问问题；2）同时，共享内存的数据一旦被破坏，所有依赖于该数据的进程都会受到影响，容错性较差；3）需要注意临界变量的保护。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建共享内存段或获取现有共享内存段的标识符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将共享内存连接到当前进程的地址空间，返回共享内存段的首地址</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将共享内存段从当前进程的地址空间中分离，即解除映射</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对共享内存段进行控制操作，如获取信息、修改权限、删除共享内存段等</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>套接字</strong>，适用于在不同主机和不同进程之间进行通信，通常用于网络编程。</p>
</li>
</ol>
<h3 id="【-】31、进程调度算法"><a href="#【-】31、进程调度算法" class="headerlink" title="【*】31、进程调度算法"></a>【*】31、进程调度算法</h3><ol>
<li><p><strong>先来先服务 first-come first-serverd(FCFS)<strong>：</strong>非抢占式的调度算法，</strong>按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
</li>
<li><p><strong>短作业优先 shortest job first(SJF)<strong>：</strong>非抢占式的调度算法，</strong>按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
</li>
<li><p><strong>最短剩余时间优先 shortest remaining time next(SRTN)<strong>：</strong>最短作业优先的抢占式版本</strong>，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
</li>
<li><p><strong>时间片轮转</strong>：将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li><p>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间；</p>
</li>
<li><p>而如果时间片过长，那么实时性就不能得到保证。</p>
</li>
</ul>
</li>
<li><p><strong>优先级调度</strong>：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
</li>
<li><p><strong>多级反馈队列</strong>：一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1、2、4、8…。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换7次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队烈上的进程。可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
</li>
</ol>
<h3 id="32、进程同步的方式？"><a href="#32、进程同步的方式？" class="headerlink" title="32、进程同步的方式？"></a>32、进程同步的方式？</h3><ul>
<li><strong>互斥锁</strong>，一种用于保护共享资源的同步机制，确保同一时间只有一个进程可以访问共享资源。</li>
<li><strong>信号量</strong>，用于控制对共享资源的访问。</li>
<li><strong>条件变量</strong>，允许进程在某个条件不满足的情况下阻塞自己，直到有其他进程通知条件满足。</li>
<li><strong>共享内存</strong>，允许多个进程共享一块内存区域，以便快速交换数据。</li>
<li><strong>消息队列</strong>，允许进程通过发送和接收消息进行通信。</li>
</ul>
<h3 id="33、信号量和互斥锁解决父子线程同时阻塞的区别？"><a href="#33、信号量和互斥锁解决父子线程同时阻塞的区别？" class="headerlink" title="33、信号量和互斥锁解决父子线程同时阻塞的区别？"></a>33、信号量和互斥锁解决父子线程同时阻塞的区别？</h3><p>假设有一个场景，其中父线程和子线程需要按特定顺序访问某个资源（例如，父线程需要等待子线程完成某个任务后才能继续执行）。</p>
<ul>
<li><strong>使用互斥锁</strong>：如果使用互斥锁，需要<strong>配合条件变量</strong>来实现这种顺序控制。<strong>互斥锁本身只能保证互斥，不能控制线程之间的执行顺序</strong>。父线程需要在条件变量上等待一个特定条件（通常由子线程设置）。</li>
<li><strong>使用信号量</strong>：信号量可以更直接地控制执行顺序。父线程等待子线程释放某个信号后才能继续执行，这样就控制了对资源的访问顺序。</li>
</ul>
<h3 id="34、windows-下-thread-create-会有什么问题？"><a href="#34、windows-下-thread-create-会有什么问题？" class="headerlink" title="34、windows 下 thread_create 会有什么问题？"></a>34、windows 下 thread_create 会有什么问题？</h3><p>？</p>
<h3 id="35、知道哪些信号的含义？SIGALRM-SIGSEGV-SIGINT"><a href="#35、知道哪些信号的含义？SIGALRM-SIGSEGV-SIGINT" class="headerlink" title="35、知道哪些信号的含义？SIGALRM, SIGSEGV, SIGINT?"></a>35、知道哪些信号的含义？SIGALRM, SIGSEGV, SIGINT?</h3><p><strong>SIGALRM</strong>：时钟定时器超时信号，通常用于定时操作。</p>
<p><strong>SIGSEGV</strong>：非法内存访问信号，通常由无效的指针或越界访问引发。</p>
<p><strong>SIGINT</strong>：中断信号，通常由用户通过 Ctrl+C 发出，用于中断程序执行。</p>
<h3 id="36、Ctrl-C-后发生了什么？"><a href="#36、Ctrl-C-后发生了什么？" class="headerlink" title="36、Ctrl+C 后发生了什么？"></a>36、Ctrl+C 后发生了什么？</h3><p>按下 Ctrl+C 后，会向前台运行的进程发送 SIGINT 信号。这个信号通常用于中断和终止正在运行的程序。如果程序捕获并处理了 SIGINT 信号，它可以执行清理操作或选择忽略信号；否则，默认行为是终止程序。</p>
<h3 id="37、sigaction-可以干哪些事情？解释一下屏蔽集？"><a href="#37、sigaction-可以干哪些事情？解释一下屏蔽集？" class="headerlink" title="37、sigaction 可以干哪些事情？解释一下屏蔽集？"></a>37、sigaction 可以干哪些事情？解释一下屏蔽集？</h3><p><code>sigaction</code> 是一个用于设置和检测信号处理方式的系统调用，主要有以下功能：</p>
<ol>
<li><strong>设置信号处理函数</strong>：可以用于指定一个函数，用来处理特定信号发生时的行为。</li>
<li><strong>指定信号的处理方式</strong>：可以指定信号的处理方式，比如忽略信号、执行默认操作、或者调用指定的处理函数。</li>
<li><strong>检查和修改信号的屏蔽集</strong>：可以检查当前对信号的屏蔽状态，也可以修改进程对信号的屏蔽集。</li>
</ol>
<p><strong>屏蔽集</strong> 是一个用来管理信号处理的机制，它决定了<strong>在特定时间点一个进程可以接收哪些信号</strong>。当信号被屏蔽时，进程在收到该信号时不会立即处理，而是被加入到<strong>未决信号集</strong>中，直到信号被解除屏蔽后才会处理。屏蔽集可以通过 <code>sigprocmask</code> 系统调用来设置和修改。</p>
<h3 id="38、线程崩溃，进程一定会崩溃吗？"><a href="#38、线程崩溃，进程一定会崩溃吗？" class="headerlink" title="38、线程崩溃，进程一定会崩溃吗？"></a>38、线程崩溃，进程一定会崩溃吗？</h3><p>一般来说，如果线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃。因为在进程中，<strong>各个线程的地址空间是共享的</strong>，既然是共享，那么某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程，这种操作是危险的，操作系统会认为这很可能导致一系列严重的后果，于是干脆让整个进程崩溃。</p>
<h2 id="二、内存模型-虚拟内存"><a href="#二、内存模型-虚拟内存" class="headerlink" title="二、内存模型&#x2F;虚拟内存"></a>二、内存模型&#x2F;虚拟内存</h2><h3 id="39、什么是虚拟内存？"><a href="#39、什么是虚拟内存？" class="headerlink" title="39、什么是虚拟内存？"></a>39、什么是虚拟内存？</h3><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301943905.png" alt="img" style="zoom: 67%;" />

<h3 id="40、为什么操作系统要使用虚拟内存？"><a href="#40、为什么操作系统要使用虚拟内存？" class="headerlink" title="40、为什么操作系统要使用虚拟内存？"></a>40、为什么操作系统要使用虚拟内存？</h3><ol>
<li>第一，虚拟内存可以<strong>使得进程的运行内存超过物理内存大小</strong>，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li>
<li>第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就<strong>解决了多进程之间地址冲突的问题</strong>。</li>
<li>第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统<strong>提供了更好的安全性</strong>。</li>
</ol>
<h3 id="41、虚拟内存有没有大小的限制？"><a href="#41、虚拟内存有没有大小的限制？" class="headerlink" title="41、虚拟内存有没有大小的限制？"></a>41、虚拟内存有没有大小的限制？</h3><ol>
<li><p>虚拟内存的大小<strong>受到地址线的限制</strong>：</p>
<ul>
<li><p><code>32</code>位系统下虚拟内存空间的大小为2^32^字节（约4GB）；</p>
</li>
<li><p><code>64</code>位系统下虚拟内存空间的大小为2^64^字节。</p>
</li>
</ul>
</li>
<li><p>另外，操作系统还可以通过配置来限制每个进程能够使用的虚拟内存大小。</p>
</li>
</ol>
<h3 id="【-】42、虚拟内存中分页算法是为了解决什么样的问题？"><a href="#【-】42、虚拟内存中分页算法是为了解决什么样的问题？" class="headerlink" title="【*】42、虚拟内存中分页算法是为了解决什么样的问题？"></a>【*】42、虚拟内存中分页算法是为了解决什么样的问题？</h3><p>虚拟内存中的分页算法是为了解决<strong>连续长内存分配时物理内存不足</strong>的问题。它通过<strong>将内存分成固定大小的页面（page），并将页面映射到物理内存或者存储在磁盘上的页面文件</strong>中，来提供更大的地址空间。</p>
<h3 id="43、虚拟内存的内存模型如何？"><a href="#43、虚拟内存的内存模型如何？" class="headerlink" title="43、虚拟内存的内存模型如何？"></a>43、虚拟内存的内存模型如何？</h3><p>其内存分布或内存模型实际上就是虚拟内存。主要分为以下几个部分，分别是：<code>.text</code>段，<code>.rodata</code>段，<code>.data</code>段，<code>.bss</code>段，堆，内存映射区，栈，内核空间。其中，各项主要内容如下：</p>
<p>（1）<code>.text</code>段 ：主要存在程序编译后的机器指令；</p>
<p>（2）<code>.rodata</code>段 ：主要存放程序中的各种只读变量；</p>
<p>（3）<code>.data</code>段：主要存放指定了初始值的全局变量和静态变量；</p>
<p>（4）<code>.bss</code>段：主要存放没有指定初始值的全局变量和静态变量，这些未初始化的全局变量被加载进内存之后会被初始化为 0 值；</p>
<p>（5）堆：由程序员进行动态分配，如调用 malloc 或 new；</p>
<p>（6）文件映射与匿名映射区：存放动态链接库中的代码段，数据段，BSS 段，以及通过 mmap 系统调用映射的共享内存区；</p>
<p>（7）栈：由编译器自动分配释放，存放调用函数过程中使用到的局部变量和函数参数等；</p>
<p>（8）内核空间：存放操作系统的一些内核数据和代码。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/ffb6e1727e2289f142f6a2a6291cd68c.png" alt="image.png" style="zoom: 50%;" />

<img src="https://cdn.xiaolincoding.com//mysql/other/532e6cdf4899588f8b873b6435cba2d8.png" alt="image.png" style="zoom: 33%;" />

<h3 id="44、为什么要区分代码段和数据段？"><a href="#44、为什么要区分代码段和数据段？" class="headerlink" title="44、为什么要区分代码段和数据段？"></a>44、为什么要区分代码段和数据段？</h3><ul>
<li><strong>访问权限控制</strong>：<strong>代码段通常设置为只读</strong>，以防止程序代码被意外或恶意修改，这可能导致程序行为不正确或系统安全受到威胁。<strong>数据段则通常需要读写权限</strong>，因为程序在运行时需要修改数据。</li>
<li><strong>分页策略</strong>：代码段和数据段可能会<strong>采用不同的分页和交换策略</strong>。例如，代码页可能较少交换出内存，因为它们被频繁访问；而数据段的某些部分<strong>如果使用不频繁可以被交换出去</strong>以节约资源。</li>
</ul>
<h3 id="45、堆和栈有什么样的区别？"><a href="#45、堆和栈有什么样的区别？" class="headerlink" title="45、堆和栈有什么样的区别？"></a>45、堆和栈有什么样的区别？</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301519980.png" alt="image-20240630151957779"></p>
<h3 id="46、什么时候用栈，什么时候用堆？"><a href="#46、什么时候用栈，什么时候用堆？" class="headerlink" title="46、什么时候用栈，什么时候用堆？"></a>46、什么时候用栈，什么时候用堆？</h3><ol>
<li><p>与堆相比，栈不会导致内存碎片，分配效率高。<strong>函数返回地址，函数的局部变量，调用参数以及使用的寄存器</strong>等信息都采取栈的形式存放，如果<strong>少量数据需要频繁的操作</strong>，那么在程序中动态申请少量栈内存会获得很好的性能提升。</p>
</li>
<li><p>堆可以申请的内存大很多，与堆相比，栈的使用没那么灵活，如果<strong>分配大量的内存空间</strong>，推荐使用堆内存，保存着程序运行时使用 new 和 malloc 等动态分配的内存。</p>
</li>
</ol>
<h3 id="47、不同段上的对象的生命周期是怎样的？"><a href="#47、不同段上的对象的生命周期是怎样的？" class="headerlink" title="47、不同段上的对象的生命周期是怎样的？"></a>47、不同段上的对象的生命周期是怎样的？</h3><ol>
<li><p><code>.data/.bss</code> 段的生命周期<strong>和程序的生命周期一致</strong>，在程序加载到内存时被分配，程序结束时被销毁；</p>
</li>
<li><p><code>堆</code>上的对象<strong>由程序员进行动态分配</strong>；</p>
</li>
<li><p><code>栈</code>上的对象由编译器进行分配，当<strong>离开作用域范围时被编译器销毁</strong>。</p>
</li>
</ol>
<h3 id="48、如何让对象只能存在于栈-堆中？"><a href="#48、如何让对象只能存在于栈-堆中？" class="headerlink" title="48、如何让对象只能存在于栈&#x2F;堆中？"></a>48、如何让对象只能存在于栈&#x2F;堆中？</h3><ol>
<li>如果<strong>将<code>operator new</code>设置为私有的</strong>，此时尝试在堆上分配内存失败，对象就会<strong>存在于栈中</strong>。</li>
<li>由于编译器在栈上分配内存时会自动调用其构造函数和析构函数，因此如果<strong>将析构函数设置为私有的</strong>，在栈上分配内存失败，对象就会<strong>存在于堆中</strong>。</li>
</ol>
<h3 id="49、栈的速度为什么比堆上的要快？"><a href="#49、栈的速度为什么比堆上的要快？" class="headerlink" title="49、栈的速度为什么比堆上的要快？"></a>49、<strong>栈的速度为什么比堆上的要快？</strong></h3><p>栈的读取速度比堆上的要快，主要是由于以下几个原因：</p>
<ol>
<li><strong>数据结构的特点</strong>：栈是一种线性数据结构，其操作是基于栈顶的，因此可以通过简单的指针操作来读取栈上的数据。相比之下，堆是一种树形数据结构，要读取堆上的数据可能需要进行指针的跳转和内存的查找操作，因此相对更为复杂和耗时。</li>
<li><strong>内存布局的连续性</strong>：栈上的内存分配是连续的，数据项之间存储的地址是相邻的，这使得栈上的数据读取更为高效，因为可以通过栈指针进行连续的内存读取操作。而堆上的内存分配是动态的，可能是分散的，需要通过指针跳转来访问不同的内存块，导致读取速度较慢。 </li>
<li><strong>硬件优化</strong>：由于栈的读取操作频繁且简单，因此处理器和编译器通常会对栈上的操作进行优化，例如采用特定的指令集或硬件机制来提高栈操作的执行效率。相比之下，堆上的内存操作较为复杂，难以进行同样程度的优化。</li>
</ol>
<h3 id="50、栈何时会溢出？"><a href="#50、栈何时会溢出？" class="headerlink" title="50、栈何时会溢出？"></a>50、<strong>栈何时会溢出</strong>？</h3><ol>
<li><p>递归调用层次过深：如果一个程序中存在递归调用，而递归调用的层次过深，会导致栈空间不足，从而发生栈溢出。</p>
</li>
<li><p>局部变量占用过多空间：当一个函数中声明了过多的局部变量，或者某个局部变量占用的内存空间过大时，会导致栈空间快速耗尽，从而发生栈溢出。</p>
</li>
<li><p>大量函数调用嵌套：如果程序中存在大量的函数调用嵌套，而栈空间不足以容纳所有的函数调用信息，也会导致栈溢出。</p>
</li>
</ol>
<blockquote>
<p>在 C&#x2F;C++ 中，可以使用编译器选项 <code>-Wl,--stack,&lt;size&gt;</code> 来设置栈的大小。</p>
</blockquote>
<h3 id="51、new-和-malloc-的区别？"><a href="#51、new-和-malloc-的区别？" class="headerlink" title="51、new 和 malloc 的区别？"></a>51、new 和 malloc 的区别？</h3><p>主要包含以下区别：</p>
<ol>
<li>malloc 是 C 中的函数，但可以同时在 C&#x2F;C++ 中使用；new 是 C++ 特有的操作符，只能在 C++ 中使用；</li>
<li>malloc 在使用时需要指定分配内存的大小，如 <code>malloc(sizeof(int))</code>，但 new 的使用则比较简洁，如 <code>new int</code>；</li>
<li>malloc 分配的内存是未定义的，而 new 在分配内存时还会调用构造函数进行初始化；</li>
<li>malloc 返回的是 void * 类型的指针，需要进行强制类型转换以得到需要的指针类型，而 new 会自动转换为响应的指针类型；</li>
<li>malloc 调用 free 进行释放， new 调用 delete 进行释放。</li>
<li>若内存分配失败，malloc 调用会返回 nullptr，而 new 调用会返回 <code>std::bad_alloc</code>。</li>
</ol>
<h3 id="52、既然有了-malloc-free，为什么还需要-new-delete-呢？"><a href="#52、既然有了-malloc-free，为什么还需要-new-delete-呢？" class="headerlink" title="52、既然有了 malloc&#x2F;free，为什么还需要 new&#x2F;delete 呢？"></a>52、既然有了 malloc&#x2F;free，为什么还需要 new&#x2F;delete 呢？</h3><ul>
<li>malloc&#x2F;free 和 new&#x2F;delete 都是用来申请内存和回收内存的。</li>
<li>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而 malloc&#x2F;free 是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给 malloc&#x2F;free，所以 new&#x2F;delete 是必不可少的。</li>
</ul>
<h3 id="53、malloc-函数的底层实现是什么？"><a href="#53、malloc-函数的底层实现是什么？" class="headerlink" title="53、malloc() 函数的底层实现是什么？"></a>53、malloc() 函数的底层实现是什么？</h3><ol>
<li>当开辟的空间<strong>小于 128kb</strong> 时，调用 <code>brk()</code> 函数，先遍历空闲内存链表，如果有已释放且空间足够的内存块就拿来用。如果找不到就移动指针 <code>_enddata</code>，即堆区的末尾地址，将「堆顶」指针往高地址推。</li>
<li>当开辟的空间<strong>大于 128kb</strong>  时，系统调用 <code>mmap()</code> 在堆和栈之间找一块空闲内存分配.</li>
<li><code>malloc()</code> 在分配用户传入大小的内存时，还<strong>额外分配一个用于管理的内存</strong>，大小为 8 字节。因此，free() 函数只传入一个内存地址却能知道要释放多大的内存。而由于堆中的内存是成块分配的，与内存对齐有关，在 64 位系统中，内存对齐为 16 字节，因此<strong>实际分配的内存大小还要考虑 8 字节的管理内存和内存对齐</strong>。</li>
</ol>
<blockquote>
<p>brk() 是将「堆顶」指针向高地址移动，获得新的内存空间；mmap() 是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</p>
<p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mem_control_block</span> &#123;</span><br><span class="line">    <span class="type">int</span> is_available;      <span class="comment">// 1表可用，0表不可用</span></span><br><span class="line">    <span class="type">int</span> size;                 <span class="comment">// 总大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="【-】54、mmap-的原理"><a href="#【-】54、mmap-的原理" class="headerlink" title="【*】54、mmap() 的原理"></a>【*】54、mmap() 的原理</h3><h3 id="55、假设分配一块内存-int-p-int-malloc-100-那么-free-p-50-可不可以，为什么；如果想把这块内存扩充到200字节，应该怎么做？"><a href="#55、假设分配一块内存-int-p-int-malloc-100-那么-free-p-50-可不可以，为什么；如果想把这块内存扩充到200字节，应该怎么做？" class="headerlink" title="55、假设分配一块内存 int* p &#x3D; (int*)malloc(100); 那么 free(p+50) 可不可以，为什么；如果想把这块内存扩充到200字节，应该怎么做？"></a>55、假设分配一块内存 int* p &#x3D; (int*)malloc(100); 那么 free(p+50) 可不可以，为什么；如果想把这块内存扩充到200字节，应该怎么做？</h3><p>（1）<strong>free(p+50) 是否有效？</strong></p>
<ul>
<li><strong>不可以</strong>。<code>free()</code> 函数要求传入的指针必须是由 <code>malloc()</code>、<code>calloc()</code> 或 <code>realloc()</code> 返回的指针的起始地址。如果传入的是偏移后的地址（如 <code>p + 50</code>），会导致未定义行为。<code>malloc()</code> 在分配用户传入大小的内存时，还<strong>额外分配一个用于管理的内存</strong>，大小为 8 字节， <code>free()</code> 需要据此来释放正确的内存区域，而偏移后的指针不包含这些信息。</li>
</ul>
<p>（2）<strong>将内存扩充到 200 字节应该如何操作？</strong></p>
<ul>
<li><p>在 C 语言中，<code>malloc</code> 分配的内存是固定大小的，一旦分配完成后，大小不能直接更改。要将内存扩充到 200 字节，可以使用 <code>realloc</code> 函数。<code>realloc</code> 函数可以重新分配先前通过 <code>malloc</code> 或 <code>calloc</code> 分配的内存块，将其大小调整为新的字节数。</p>
</li>
<li><p>例如，要将 <code>p</code> 指向的内存块扩充到 200 字节，可以使用以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* q = (<span class="type">int</span>*)<span class="built_in">realloc</span>(p, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">if</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    p = q; <span class="comment">// 更新 p，因为 realloc 可能会返回新的地址</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>realloc(p, 200)</code> 将尝试将原始分配的内存块大小调整为 200 字节。如果内存块成功扩展，<code>realloc</code> 返回一个指向新分配区域的指针，并且原来的 <code>p</code> 指针仍然有效（或者更新为新的地址）。如果失败，返回 <code>NULL</code>，并且原来的 <code>p</code> 指针仍然有效。</p>
</li>
</ul>
<h3 id="56、malloc、realloc、calloc-的区别"><a href="#56、malloc、realloc、calloc-的区别" class="headerlink" title="56、malloc、realloc、calloc 的区别"></a>56、malloc、realloc、calloc 的区别</h3><ol>
<li><code>malloc</code> 函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_size)</span></span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">20</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>申请 20 个 int 类型的空间。</p>
<ol start="2">
<li><code>calloc</code> 函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">calloc</span><span class="params">(<span class="type">size_t</span> n,<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">calloc</span>(<span class="number">20</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>省去了人为空间计算；malloc 申请的空间的值是随机初始化的，calloc 申请的空间的值是初始化为0的；</p>
<ol start="3">
<li><code>realloc</code> 函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">realloc</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></table></figure>

<p>给动态分配的空间分配额外的空间，用于扩充容量。</p>
<h3 id="57、对于-malloc-分配的内存，调用-free-后立即释放吗？"><a href="#57、对于-malloc-分配的内存，调用-free-后立即释放吗？" class="headerlink" title="57、对于 malloc() 分配的内存，调用 free() 后立即释放吗？"></a>57、对于 malloc() 分配的内存，调用 free() 后立即释放吗？</h3><p>在使用 <code>brk()</code> 或 <code>sbrk()</code> 分配的情况下，这块内存并不会立即返还给操作系统，而是标记为<strong>可再利用状态</strong>，并被 <code>ptmalloc</code> 使用双链表保存起来。当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时 <code>ptmalloc</code> 也会尝试对小块内存进行合并，避免过多的内存碎片。如果释放的是堆末端的内存，程序的断点可能会被回退，从而实际上将内存返还给操作系统。</p>
<p>而对于使用 <code>mmap()</code> 分配的较大内存块，在调用 <code>free()</code> 后通常会通过 <code>munmap()</code> 立即返还给操作系统。</p>
<h3 id="58、既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么-malloc-不全部使用-mmap-来实现，而是仅仅对于大于-128k-的大块内存才使用-mmap-？"><a href="#58、既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么-malloc-不全部使用-mmap-来实现，而是仅仅对于大于-128k-的大块内存才使用-mmap-？" class="headerlink" title="58、既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么 malloc() 不全部使用 mmap() 来实现，而是仅仅对于大于 128k 的大块内存才使用 mmap()？"></a>58、既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么 malloc() 不全部使用 mmap() 来实现，而是仅仅对于大于 128k 的大块内存才使用 mmap()？</h3><p>因为向操作系统申请内存需要进行系统调用，而执行系统调用会在内核态和用户态之间切换，耗费不少时间，如果都用 mmap 来分配内存，等于每次都要执行系统调用。此外，mmap 分配的内存每次释放的时候，都会归还给操作系统。由于每次  mmap 分配的虚拟地址都是缺页状态的，在第一次访问该虚拟地址的时候，就会触发缺页中断。</p>
<p>也就是说，<strong>频繁通过 mmap 分配的内存的话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大</strong>。</p>
<p>为了改进这两个问题，malloc 通过 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。等下次再申请内存的时候，就直接从内存池取出对应的内存块，而且可能这个内存块的虚拟地址与物理地址的映射关系还存在，这样不仅减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低 CPU 的消耗。</p>
<h3 id="59、kmalloc-和用户态的-malloc-有什么区别。"><a href="#59、kmalloc-和用户态的-malloc-有什么区别。" class="headerlink" title="59、kmalloc() 和用户态的 malloc() 有什么区别。"></a>59、kmalloc() 和用户态的 malloc() 有什么区别。</h3><ul>
<li><code>kmalloc()</code> 是在<strong>内核空间</strong>中使用的内存分配函数，主要用于为内核模块或驱动程序分配内存，直接从操作系统的<strong>内核内存池</strong>中分配内存，这部分内存通常是预先保留给内核的，不会被用户空间的应用程序直接访问。</li>
<li><code>malloc()</code> 是在<strong>用户空间</strong>中使用的内存分配函数，用于应用程序分配内存，分配的内存来自于用户空间的堆区，这部分内存是由操作系统管理，供所有用户程序共享使用。</li>
</ul>
<h3 id="60、在已申请的内存中构造对象如何实现？"><a href="#60、在已申请的内存中构造对象如何实现？" class="headerlink" title="60、在已申请的内存中构造对象如何实现？"></a>60、在已申请的内存中构造对象如何实现？</h3><p>使用<code>placement new</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="built_in">sizeof</span>(MyClass)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在buffer指定的地址上构造MyClass对象</span></span><br><span class="line">MyClass* pMyClass = <span class="built_in">new</span> (buffer) <span class="built_in">MyClass</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动调用析构函数</span></span><br><span class="line">pMyClass-&gt;~<span class="built_in">MyClass</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>构造和析构</strong>：使用 placement new 构造对象后，必须手动调用该对象的析构函数来确保正确的资源释放。因为普通的 delete 操作符会尝试释放内存，这在使用 placement new 时是不适用的。</li>
<li><strong>对齐要求</strong>：需要确保传递给 placement new 的内存地址满足对象的对齐要求。</li>
</ul>
<h3 id="【-】61、new-、operator-new-和-placement-new-区别"><a href="#【-】61、new-、operator-new-和-placement-new-区别" class="headerlink" title="【*】61、new 、operator new 和 placement new 区别"></a>【*】61、new 、operator new 和 placement new 区别</h3><p>（1）<code>new</code>：<strong>不能被重载</strong>，其行为总是一致的。它<strong>先调用 operator new 分配内存，然后调用构造函数初始化那段内存</strong>。</p>
<p>（2）<code>operator new</code>：要实现不同的内存分配行为，应该重载 operator new，而不是 new。<strong>如果类中没有重载 operator new，那么调用的就是全局的 ::operator  new 来完成堆的分配。</strong></p>
<ul>
<li>operator new 就像 operator + 一样，是可以重载的。****同理，operator new[]、operator delete、operator delete[] 也是可以重载的。</li>
<li>重载时，返回类型必须声明为 void*，第一个参数类型必须为表达要求分配空间的大小（字节），类型为 size_t，可以带其它参数。</li>
</ul>
<p>（3）<code>placement new</code>：<strong>只是 operator new 重载的一个标准、全局的版本</strong>。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。placement new 允许在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。原型中 void* p 实际上就是指向一个已经分配好的内存缓冲区的的首地址。</p>
<h3 id="【-】62、对于-delete-parray，编译器怎么知道-parray-这个指针实际指向的是数组还是单个元素？"><a href="#【-】62、对于-delete-parray，编译器怎么知道-parray-这个指针实际指向的是数组还是单个元素？" class="headerlink" title="【*】62、对于 delete[] parray，编译器怎么知道 parray 这个指针实际指向的是数组还是单个元素？"></a>【*】62、对于 delete[] parray，编译器怎么知道 parray 这个指针实际指向的是数组还是单个元素？</h3><p><strong>对象在分配时分配器会自动写一个日志，即在分配的内存之前有一个结构，用于记录分配的大小，分配内容的 <code>sizeof</code> 等等。</strong>直观来说，<code>delete</code>和<code>delete[]</code>都是传入一个<code>void*</code>，因此如果不保存日志就无法知道分配时到底是分配了一个还是多个单元。所以虽然<code>delete</code>和<code>delete[]</code>不同，但是分配器在执行释放过程中都会读取这个日志，从而了解到底应该释放多少内存。</p>
<p>但是有个前提：对象类型（或其基类）有显式析构函数。换句话说，析构函数是<code>non-virtual</code>的。<strong>对于析构函数是 virtual 的情况，delete[] 时无需调用其析构函数，因此此时 VC 把 delete[] 当做 delete 同样处理。</strong></p>
<h3 id="【-】63、比如有一个-1G-的数据，频繁调用-new-malloc-以及-delete-free，如何优化性能？"><a href="#【-】63、比如有一个-1G-的数据，频繁调用-new-malloc-以及-delete-free，如何优化性能？" class="headerlink" title="【*】63、比如有一个 1G 的数据，频繁调用 new&#x2F;malloc 以及 delete&#x2F;free，如何优化性能？"></a>【*】63、比如有一个 1G 的数据，频繁调用 new&#x2F;malloc 以及 delete&#x2F;free，如何优化性能？</h3><p>频繁调用 <code>new</code>&#x2F;<code>malloc</code> 和 <code>delete</code>&#x2F;<code>free</code> 可能导致内存分配和释放的开销增加，从而影响系统性能。针对这种情况，可以考虑以下优化策略：</p>
<ol>
<li><strong>内存池管理</strong>：实现自定义的内存池，预先分配一定大小的内存块，而不是每次调用 <code>new</code>&#x2F;<code>malloc</code> 时都向系统请求内存。这样可以减少系统调用次数和内存碎片化。内存池可以是固定大小的块，也可以是根据需要动态增长或缩减的块。它们可以通过链表或者数组来管理。</li>
<li><strong>重用机制</strong>：尽可能重用已分配的内存块。在需要释放内存时，不立即释放，而是放入一个空闲链表或者空闲对象池中，以便下次分配时能够快速重用。对于频繁分配相同大小的内存，可以采用内存池的方式进行管理，避免反复请求和释放系统内存。</li>
<li><strong>内存分配策略优化</strong>：对于需要频繁分配和释放的小对象，可以考虑使用更高效的分配策略，如 <code>std::allocator</code> 或者专门优化的内存分配器（如 tcmalloc 或 jemalloc）。这些分配器通常比标准库的 <code>malloc</code> 和 <code>free</code> 实现更加高效，能够降低内存碎片化和系统调用次数。</li>
<li><strong>内存分配的时机和位置</strong>：在程序设计阶段，合理规划和设计内存的分配和释放时机，尽量避免频繁的动态内存分配和释放。可以考虑在初始化阶段预分配一部分内存，减少后续的动态内存操作频率。</li>
</ol>
<h3 id="64、内存分配的过程是怎样的？"><a href="#64、内存分配的过程是怎样的？" class="headerlink" title="64、内存分配的过程是怎样的？"></a>64、内存分配的过程是怎样的？</h3><p>应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。当<strong>应用程序第一次读写这块虚拟内存</strong>时，CPU在访问时会发现这个虚拟内存没有映射到物理内存， 就会产生<strong>缺页中断</strong>，进程从用户态切换到内核态，通过缺页中断的处理函数将虚拟地址映射到一段空闲的物理内存上。</p>
<h3 id="65、内存紧张-没有空闲物理内存时有哪些操作？"><a href="#65、内存紧张-没有空闲物理内存时有哪些操作？" class="headerlink" title="65、内存紧张&#x2F;没有空闲物理内存时有哪些操作？"></a>65、内存紧张&#x2F;没有空闲物理内存时有哪些操作？</h3><p>如果没有空闲的物理内存，那么内核就会开始进行<strong>回收内存</strong>的工作，回收的方式主要是两种：直接内存回收和后台内存回收。</p>
<ul>
<li><strong>后台内存回收</strong>（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程<strong>异步</strong>的，不会阻塞进程的执行。</li>
<li><strong>直接内存回收</strong>（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是<strong>同步</strong>的，会阻塞进程的执行。</li>
</ul>
<p>如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，内核触发 <strong>OOM （Out of Memory）机制</strong>。OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406302002710.png" alt="img"></p>
<h3 id="66、哪些内存可以被回收？"><a href="#66、哪些内存可以被回收？" class="headerlink" title="66、哪些内存可以被回收？"></a>66、哪些内存可以被回收？</h3><p>主要有<strong>文件页和匿名页</strong>两类内存可以被回收。</p>
<ul>
<li><strong>文件页</strong>（File-backed  Page）：内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）都叫作文件页。根据是否被修改并写入磁盘分为干净页和脏页，<strong>回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存</strong>。</li>
<li><strong>匿名页</strong>（Anonymous Page）：这部分内存没有实际载体，不像文件缓存有硬盘文件这样一个载体，比如堆、栈数据等。这部分内存很可能还要再次被访问，所以不能直接释放内存，它们<strong>回收的方式是通过 Linux 的 Swap 机制</strong>，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。</li>
</ul>
<p>文件页和匿名页的回收都是基于 LRU 算法，也就是优先回收不常访问的内存。LRU 回收算法，实际上维护着活跃内存页链表和不活跃内存页链表两个双向链表，越接近链表尾部，就表示内存页越不常访问。这样，在回收内存时，系统就可以根据活跃程度，优先回收不活跃的内存。</p>
<blockquote>
<ul>
<li><strong>active_list</strong> 是活跃内存页链表，存放最近被访问过（活跃）的内存页；</li>
<li><strong>inactive_list</strong> 不活跃内存页链表，存放很少被访问（非活跃）的内存页。</li>
</ul>
</blockquote>
<h3 id="【-】67、针对回收内存页导致的性能影响，有哪些解决方式？"><a href="#【-】67、针对回收内存页导致的性能影响，有哪些解决方式？" class="headerlink" title="【*】67、针对回收内存页导致的性能影响，有哪些解决方式？"></a>【*】67、针对回收内存页导致的性能影响，有哪些解决方式？</h3><ol>
<li><p><strong>设置 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness，调整文件页和匿名页的回收倾向，尽量倾向于回收文件页；</strong></p>
<p>从文件页和匿名页的回收操作来看，文件页的回收操作对系统的影响相比匿名页的回收操作会少一点，因为文件页对于干净页回收是不会发生磁盘 I&#x2F;O 的，而匿名页的 Swap 换入换出这两个操作都会发生磁盘 I&#x2F;O。</p>
<blockquote>
<p>Linux 提供了一个 <code>/proc/sys/vm/swappiness</code> 选项，用来调整文件页和匿名页的回收倾向。其数值范围是 0-100，数值越大，越倾向于回收匿名页；数值越小，越倾向于回收文件页。</p>
</blockquote>
</li>
</ol>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaolin ~]<span class="comment"># cat /proc/sys/vm/swappiness</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>一般建议 swappiness 设置为 0（默认值是 60），这样在回收内存的时候，会更倾向于文件页的回收，但是并不代表不会回收匿名页。</p>
</blockquote>
<ol start="2">
<li><p><strong>设置 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;min_free_kbytes，调整 kswapd 内核线程异步回收内存的时机；</strong></p>
<blockquote>
<p>如果系统时不时发生抖动，并且在抖动的时间段里如果通过 sar -B 观察到 pgscand 数值很大，那大概率是因为「直接内存回收」导致的。针对这个问题，解决的办法是通过尽早的触发「后台内存回收」来避免应用程序进行直接内存回收。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>kswapd 会定期扫描内存的使用情况，根据剩余内存（pages_free）的情况来进行内存回收的工作。如果剩余内存（pages_free）在页低阈值（pages_low）和页最小阈值（pages_min）之间，说明内存压力比较大，剩余内存不多了。<strong>这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值（pages_high）为止</strong>。虽然会触发内存回收，但是不会阻塞应用程序，因为两者关系是异步的。</p>
</blockquote>
<ol start="3">
<li><strong>设置  &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;zone_reclaim_mode，调整 NUMA 架构下内存回收策略，建议设置为  0，这样在回收本地内存之前，会在其他 Node 寻找空闲内存，从而避免在系统还有很多空闲内存的情况下，因本地 Node  的本地内存不足，发生频繁直接内存回收导致性能下降的问题。</strong></li>
</ol>
<h3 id="68、在-4GB-物理内存的机器上，申请-8GB-内存，会怎么样？"><a href="#68、在-4GB-物理内存的机器上，申请-8GB-内存，会怎么样？" class="headerlink" title="68、在 4GB 物理内存的机器上，申请 8GB 内存，会怎么样？"></a>68、在 4GB 物理内存的机器上，申请 8GB 内存，会怎么样？</h3><ul>
<li>在 <code>32</code> 位操作系统，因为进程理论上最大能申请 <code>3GB</code> 大小的虚拟内存，所以直接申请 <code>8GB</code> 内存，会申请失败。</li>
<li>在 <code>64</code> 位操作系统，因为进程理论上最大能申请 <code>128TB</code> 大小的虚拟内存，即使物理内存只有 <code>4GB</code>，申请 <code>8GB</code> 内存也是没问题，因为申请的内存是虚拟内存。<strong>如果这块虚拟内存被访问了</strong>，要看系统有没有 Swap 分区：<ul>
<li>如果没有 <code>Swap</code> 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 <code>OOM</code>（内存溢出）；</li>
<li>如果有 <code>Swap</code> 分区，即使物理内存只有 <code>4GB</code>，程序也能正常使用 <code>8GB</code> 的内存，进程可以正常运行；</li>
</ul>
</li>
</ul>
<h3 id="【-】69、函数进栈退栈原理，esp、ebp、实参怎么传递？怎么退栈之类的过程？"><a href="#【-】69、函数进栈退栈原理，esp、ebp、实参怎么传递？怎么退栈之类的过程？" class="headerlink" title="【*】69、函数进栈退栈原理，esp、ebp、实参怎么传递？怎么退栈之类的过程？"></a>【*】69、函数进栈退栈原理，esp、ebp、实参怎么传递？怎么退栈之类的过程？</h3><ol>
<li><p><strong>进栈过程</strong></p>
<ol>
<li>将当前函数的返回地址和栈帧指针 ebp 压入栈中，<strong>保存调用者的环境</strong>；</li>
<li>将栈指针 esp 的值赋给栈帧指针 ebp，<strong>设置被调用函数的栈帧</strong>；</li>
<li>将栈指针（<code>esp</code>）的值赋给栈帧指针（<code>ebp</code>），形成新的栈帧；</li>
<li>为被调用函数的局部变量和临时变量预留空间，调整栈指针（<code>esp</code>）。</li>
<li>将实参按照调用约定的顺序压入栈中。</li>
</ol>
</li>
<li><p><strong>执行函数</strong></p>
<ul>
<li><p>被调用函数开始执行，其局部变量和临时变量使用新栈帧中的空间；</p>
</li>
<li><p>函数执行过程中，<code>ebp</code> 用于访问局部变量，<code>esp</code> 随着栈操作不断变化。</p>
</li>
</ul>
</li>
<li><p><strong>退栈过程</strong></p>
<ol>
<li>函数执行完毕后，将栈指针（<code>esp</code>）恢复到调用函数的栈帧起始位置，通常是通过<code>mov esp, ebp</code>实现；</li>
<li>将调用者的栈帧指针（<code>ebp</code>）恢复，通常是通过<code>pop ebp</code>实现；</li>
<li>从栈中弹出返回地址，通常是通过<code>ret</code>指令实现，<code>ret</code>指令会弹出栈顶的地址到程序计数器（<code>eip</code>），从而跳转回调用函数的下一条指令。</li>
</ol>
</li>
</ol>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编代码大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">_main:</span><br><span class="line">    push ebp            ; 保存调用者的栈帧指针</span><br><span class="line">    mov ebp, esp        ; 设置新的栈帧指针</span><br><span class="line">    sub esp, 8          ; 为局部变量预留空间</span><br><span class="line">    push 2              ; 将实参2压入栈</span><br><span class="line">    push 1              ; 将实参1压入栈</span><br><span class="line">    call _foo           ; 调用foo函数</span><br><span class="line">    add esp, 8          ; 调用后清理参数空间</span><br><span class="line">    mov esp, ebp        ; 恢复调用者的栈帧指针</span><br><span class="line">    pop ebp             ; 弹出调用者的栈帧指针</span><br><span class="line">    ret                 ; 返回调用者</span><br><span class="line"></span><br><span class="line">_foo:</span><br><span class="line">    push ebp            ; 保存foo函数的栈帧指针</span><br><span class="line">    mov ebp, esp        ; 设置新的栈帧指针</span><br><span class="line">    sub esp, 4          ; 为局部变量预留空间</span><br><span class="line">    mov eax, [ebp+8]    ; 将第一个参数加载到eax</span><br><span class="line">    mov edx, [ebp+12]   ; 将第二个参数加载到edx</span><br><span class="line">    add eax, edx        ; 计算a + b</span><br><span class="line">    mov [ebp-4], eax    ; 将结果保存到局部变量c</span><br><span class="line">    mov esp, ebp        ; 恢复foo函数的栈帧指针</span><br><span class="line">    pop ebp             ; 弹出foo函数的栈帧指针</span><br><span class="line">    ret                 ; 返回调用者</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主函数调用子函数</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301556491.png" alt="在这里插入图片描述"></p>
<p>子函数返回主函数</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301556054.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="70、分段为什么会产生内存碎片的问题？"><a href="#70、分段为什么会产生内存碎片的问题？" class="headerlink" title="70、分段为什么会产生内存碎片的问题？"></a>70、分段为什么会产生内存碎片的问题？</h3><ol>
<li>当程序动态分配内存时，如果<strong>请求的内存大小比当前空闲块大，但分配的内存不是连续的</strong>，就会在已有的空闲块中留下未被利用的空间。</li>
<li>当程序释放内存时，如果<strong>释放的内存顺序不是按照申请的顺序释放</strong>，会导致内存空闲块的分布变得不连续。这样在后续再次分配内存时，可能无法利用之前释放的碎片空间，从而导致更多的碎片产生。</li>
<li>某些内存分配算法（如首次适应、最佳适应）会根据当前的空闲内存块选择最合适的块分配给请求的内存大小。如果空闲块的分布不合理或者已分配的内存块大小和释放的大小不匹配，就容易产生碎片。</li>
</ol>
<h3 id="71、分段为什么会导致内存交换效率低的问题？"><a href="#71、分段为什么会导致内存交换效率低的问题？" class="headerlink" title="71、分段为什么会导致内存交换效率低的问题？"></a>71、分段为什么会导致内存交换效率低的问题？</h3><p>对于多进程的系统来说，用分段的方式，外部内存碎片是很容易产生的，产生了外部内存碎片时就不得不重新 <code>Swap</code> 内存区域，这个过程会产生性能瓶颈。因为硬盘的访问速度要比内存慢太多了，而每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong>为了解决内存分段的「外部内存碎片和内存交换效率低」的问题，就出现了内存分页（<code>Paging</code>）。</p>
<h3 id="72、Swap-分区"><a href="#72、Swap-分区" class="headerlink" title="72、Swap 分区"></a>72、Swap 分区</h3><p>Swap 就是<strong>把一块磁盘空间或者本地文件当成内存来使用</strong>，它包含<strong>换出和换入</strong>两个过程：</p>
<ul>
<li><strong>换出（Swap Out）</strong> ，是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存；</li>
<li><strong>换入（Swap In）</strong>，是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来。</li>
</ul>
<p>Linux 中的 Swap 机制会在内存不足和内存闲置的场景下触发：</p>
<ul>
<li><strong>内存不足</strong>：当系统需要的内存超过了可用的物理内存时，内核会将内存中不常使用的内存页交换到磁盘上为当前进程让出内存，保证正在执行的进程的可用性，这个内存回收的过程是强制的直接内存回收（Direct Page Reclaim）。直接内存回收是同步的过程，会阻塞当前申请内存的进程。</li>
<li><strong>内存闲置</strong>：应用程序在启动阶段使用的大量内存在启动后往往都不会使用，通过后台运行的守护进程（kSwapd），可以将这部分只使用一次的内存交换到磁盘上为其他内存的申请预留空间。kSwapd 是 Linux 负责页面置换（Page replacement）的守护进程，也是负责交换闲置内存的主要进程，它会在空闲内存低于一定水位时，回收内存页中的空闲内存保证系统中的其他进程可以尽快获得申请的内存。kSwapd 是后台进程，所以回收内存的过程是异步的，不会阻塞当前申请内存的进程。</li>
</ul>
<h3 id="73、分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？"><a href="#73、分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？" class="headerlink" title="73、分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？"></a>73、分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？</h3><p>分页机制将内存划分为一个个固定大小的页面，彼此间紧密排列，因此和分段机制相比它不会产生外部内存碎片。但要注意由于内存分页机制的最小分配单位是一页，因此即使程序大小不足一页，也会至少分配一个完整的页。因此分页机制会出现内部碎片的现象。</p>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，并暂时写在硬盘上，称为<strong>换出</strong>。一旦需要的时候，再加载进来，称为<strong>换入</strong>。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<strong>内存交换的效率就相对比较高。</strong></p>
<p>更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是<strong>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</strong></p>
<h3 id="74、页表是什么，页多大，为什么是-4KB？"><a href="#74、页表是什么，页多大，为什么是-4KB？" class="headerlink" title="74、页表是什么，页多大，为什么是 4KB？"></a>74、页表是什么，页多大，为什么是 4KB？</h3><p>页表是操作系统中用于实现虚拟内存管理的一种数据结构，它用于将虚拟地址映射到物理地址。这种机制允许计算机的操作系统为每个运行的程序提供一种看似连续的内存地址空间，即使物理内存是分散存储的。</p>
<p>在多数现代操作系统中，标准的页面大小是 <code>4KB</code>（4096字节）。Linux 会以页面为单位对内存进行管理，每次执行内存分配时都至少分配一个页面。<strong>过小的页面大小会带来较大的页表项</strong>，增加寻址时 TLB的查找速度和额外开销；<strong>过大的页面大小会浪费内存空间，造成内部碎片</strong>，降低内存的利用率；上个世纪在设计内存页大小时充分考虑了上述的两个因素，最终选择了 <code>4KB</code> 的内存页作为操作系统最常见的页大小，这个大小也就沿用至今。</p>
<h3 id="75、分页机制下，虚拟地址和物理地址是如何映射的？"><a href="#75、分页机制下，虚拟地址和物理地址是如何映射的？" class="headerlink" title="75、分页机制下，虚拟地址和物理地址是如何映射的？"></a>75、分页机制下，虚拟地址和物理地址是如何映射的？</h3><p>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，页表是存储在内存里的，<strong>内存管理单元</strong> （MMU）完成<strong>将虚拟地址转换成物理地址</strong>的工作。当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，<strong>进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行</strong>。</p>
<p>对于一个内存地址转换，包含以下 3 个步骤：</p>
<ul>
<li>把虚拟内存地址<strong>切分</strong>成页号和偏移量；</li>
<li>根据<strong>页号</strong>，从<strong>页表</strong>里面查询对应的<strong>物理页号</strong>；</li>
<li>用物理页号<strong>加上</strong>前面的偏移量，就得到了物理内存地址。</li>
</ul>
<blockquote>
<p><strong>64 位虚拟地址格式</strong>：全局页目录项（9位）+ 上层页目录项（9位）+ 中间页目录项（9位）+ 页表项（9位）+ 页内偏移（12位）。共 48 位。</p>
<p><strong>32 位虚拟地址格式</strong>：页目录项（10位）+ 页表项（10位） + 页内偏移（12位）。共 32 位。</p>
</blockquote>
<h3 id="76、为什么会产生多级页表？"><a href="#76、为什么会产生多级页表？" class="headerlink" title="76、为什么会产生多级页表？"></a>76、为什么会产生多级页表？</h3><p>对于单页表的实现方式，在 32 位和页大小 <code>4KB</code> 的环境下，一个进程的页表需要装下 <strong>100 多万个</strong>「页表项」，并且每个页表项是占用 <strong>4 字节</strong>大小的，于是<strong>相当于每个页表需占用 4MB 大小的空间</strong>。因此把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 <code>1024</code> 个页表（二级页表），每个表（二级页表）中包含 <code>1024</code> 个「页表项」，形成<strong>二级分页</strong>。</p>
<p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了地址转换的速度，也就是带来了时间上的开销。程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。利用这一特性，可以<strong>把最常访问的几个页表项存储到访问速度更快的硬件</strong>，于是在 CPU 芯片中，加入了一个<strong>专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB</strong>（Translation Lookaside Buffer） ，通常称为页表缓存、转址旁路缓存、快表等。</p>
<h3 id="77、缺页中断什么时候发生？"><a href="#77、缺页中断什么时候发生？" class="headerlink" title="77、缺页中断什么时候发生？"></a>77、缺页中断什么时候发生？</h3><ol>
<li>当<strong>程序要访问的页面不在物理内存中</strong>时，会触发缺页中断。这通常发生在虚拟内存中，即当前只有部分的页面写入了物理内存；</li>
<li>当<strong>程序尝试进行一个违反内存规则的操作</strong>时，也会触发缺页中断。比如，当程序试图对一个只读页面进行写操作，或是访问一个不允许被访问的页面。</li>
</ol>
<h3 id="【-】78、常见的缺页中断算法-页面置换算法有哪些？"><a href="#【-】78、常见的缺页中断算法-页面置换算法有哪些？" class="headerlink" title="【*】78、常见的缺页中断算法&#x2F;页面置换算法有哪些？"></a>【*】78、常见的缺页中断算法&#x2F;页面置换算法有哪些？</h3><ol>
<li><p>最佳页面置换算法（<em>OPT</em>）：最佳页面置换算法基本思路是，<strong>置换在「未来」最长时间不访问的页面</strong>。</p>
</li>
<li><p>先进先出置换算法（<em>FIFO</em>）：<strong>选择在内存驻留时间很长的页面进行中置换</strong>，这个就是「先进先出置换」算法的思想。</p>
</li>
<li><p>最近最久未使用的置换算法（<em>LRU</em>）：发生缺页时，<strong>选择最长时间没有被访问的页面进行置换</strong>，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。</p>
</li>
<li><p>时钟页面置换算法（<em>Lock</em>）：该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。</p>
</li>
<li><p>当发生缺页中断时，算法首先检查表针指向的页面：</p>
<ul>
<li><p>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</p>
</li>
<li><p>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止。</p>
</li>
</ul>
</li>
<li><p>最不常用置换算法（<em>LFU</em>）：<strong>当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰</strong>。</p>
</li>
</ol>
<h3 id="【-】79、写时拷贝在操作系统中有哪些应用？"><a href="#【-】79、写时拷贝在操作系统中有哪些应用？" class="headerlink" title="【*】79、写时拷贝在操作系统中有哪些应用？"></a>【*】79、写时拷贝在操作系统中有哪些应用？</h3><ol>
<li><strong>内存管理</strong>：<ul>
<li><strong>分页系统</strong>：在许多操作系统中，写时拷贝技术常用于内存管理。当进程执行 fork 操作创建子进程时，操作系统并不立即为子进程复制父进程的整个地址空间。相反，它让<strong>父子进程共享同一物理内存页面</strong>，<strong>只有当其中一个进程尝试修改这些共享页面时，操作系统才会复制这些页面（COW），从而实现了资源的有效利用和快速的进程创建。</strong></li>
<li><strong>虚拟内存系统</strong>：在虚拟内存系统中，写时拷贝技术可以减少不必要的数据复制，提高内存使用效率，<strong>只有在需要写入时才进行物理内存的分配和数据复制</strong>。</li>
</ul>
</li>
<li><strong>文件系统</strong>：<ul>
<li><strong>快照功能</strong>：在支持快照的文件系统（如 ZFS 或 Btrfs ）中，写时拷贝用于实现文件系统的版本控制。当文件系统状态需要保存为历史快照时，原始数据保持不变，任何对数据的修改都通过复制修改前的数据块来实现，从而快速创建快照并节省空间。</li>
</ul>
</li>
</ol>
<h2 id="三、编译程序相关"><a href="#三、编译程序相关" class="headerlink" title="三、编译程序相关"></a>三、编译程序相关</h2><h3 id="【-】80、从-C-文件到可执行文件经过了哪几个阶段？具体描述。"><a href="#【-】80、从-C-文件到可执行文件经过了哪几个阶段？具体描述。" class="headerlink" title="【*】80、从 C++ 文件到可执行文件经过了哪几个阶段？具体描述。"></a>【*】80、从 C++ 文件到可执行文件经过了哪几个阶段？具体描述。</h3><blockquote>
<p><strong>预处理、编译、汇编、链接</strong>，最后生成可执行文件。</p>
</blockquote>
<ol>
<li><p><strong>预处理阶段</strong>：对伪指令和特殊符号进行处理，将<code>.c</code>文件转为<code>.i</code>文件；</p>
<ol>
<li>处理包含指令 <code>#include</code>；</li>
<li>进行宏展开；</li>
<li>进行条件编译，如 <code>#if</code>、<code>#endif</code>、<code>#ifdef</code> 等；</li>
<li>处理 <code>#include</code> 预编译指令；</li>
<li>删除所有的注释 <code>//</code> 和 <code>/**/</code>；</li>
<li>保留所有的 <code>#pragma</code> 编译器指令，编译器需要使用它们；</li>
<li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息。</li>
</ol>
</li>
<li><p><strong>编译阶段</strong>：将编译文件转换成汇编代码，生成相应的汇编代码<code>.s</code>文件；</p>
</li>
<li><p><strong>汇编阶段</strong>：将汇编文件转化成机器码，将 <code>.s</code> 文件转为 <code>.o</code> 文件，即可重定位目标文件</p>
</li>
<li><p><strong>链接阶段</strong>：将多个目标文件及所需要的库连接成最终的可执行目标文件。链接分为<strong>静态链接</strong>和<strong>动态链接</strong>，静态链接和动态链接的最大区别就是链接的时机不一样，静态链接是在形成可执行文件之前，动态链接是在程序执行时。</p>
<ol>
<li><strong>主要工作</strong>：<ul>
<li>符号解析。在目标文件和库中存在许多符号（如函数名或变量名等），需要在其他的目标文件或库中找到相应的定义，并将它们连接起来，使得程序在运行时可以找到正确的内存地址。</li>
<li>地址分配。给目标文件和库分配内存地址，并确定其在程序中的内存布局。同时需要完成重定位的工作，用实际的内存地址去替换其中的地址引用。</li>
<li>库依赖管理。链接器处理程序和库之间的依赖关系，确保所有库都被正确地包含在目标文件中。同时要处理库与库之间的依赖关系。</li>
</ul>
</li>
<li><strong>静态链接</strong><ul>
<li>源文件中的函数和数据预处理、编译、汇编形成目标文件，而静态链接库就是多个目标文件的集合。使用静态链接库时，链接器直接从库中复制这些函数和数据，并将它们和应用程序的其他模块组合起来，创建最终的可执行文件；链接是以目标文件为单位的，若多个函数都放在了一个目标文件中，可能很多没有的函数也会被一起链接进入了输出结果中。</li>
<li>缺点：<ul>
<li>每一个可执行文件中对所有需要的目标文件都需要一份副本，如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本</li>
<li>更新困难，每当库函数的代码发生改动，需要重新进行编译、连接形成可执行程序</li>
</ul>
</li>
<li>优点：可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度更快</li>
</ul>
</li>
<li><strong>动态链接</strong><ul>
<li>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接那样运行前就把所有程序模块都链接成一个单独的可执行文件。</li>
<li>动态链接的过程：假定程序 p1.o 和 p2.o 都依赖于库 lib.o，并且假定先运行 p1.o，系统首先会加载 p1.o，发现p1.o 用到了 lib.o，于是将 lib.o 加载到内存；当运行 p2.o 时，发现 p2.o 依赖于 lib.o，而此时 lib.o 已经加载到内存中了，因此不需要重新加载，此时会将已经存在的 lib.o 映射到 p2.o 的虚拟地址空间中，从而进行链接，形成可执行文件。</li>
<li>优点：<ul>
<li>即使多个程序依赖于同一个库，在执行时也共享同一份副本；</li>
<li>更新时只需要替换原来的目标文件，而无需将所有程序都重新链接一遍，当程序下次运行时，新版本的目标文件会自动被加载到内存中并连接起来，完成了程序的更新。</li>
</ul>
</li>
<li>缺点：由于链接过程从编译阶段推迟到了程序运行时，所以运行速度相对于静态链接更慢。</li>
<li><strong>动态链接如何实现重定位的：</strong>在形成可执行文件时，发现引用了一个外部的函数，此时会检查动态链接库，发现函数名时一个动态链接符号，此时在可执行程序就不对这个符号进行重定位，就把这个过程留到装载时在进行</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="【-】81、在-terminal-输入-main-out-是怎么运行起来的？"><a href="#【-】81、在-terminal-输入-main-out-是怎么运行起来的？" class="headerlink" title="【*】81、在 terminal 输入 .&#x2F;main.out 是怎么运行起来的？"></a>【*】81、在 terminal 输入 .&#x2F;main.out 是怎么运行起来的？</h3><p>在终端输入 <code>./main.out</code> 实际上是在运行名为 <code>main.out</code> 的可执行文件。这个过程涉及了操作系统的执行文件路径解析和进程创建：</p>
<ol>
<li><strong>路径解析</strong>: 终端会根据当前工作目录（或者通过绝对路径指定的位置）找到 <code>main.out</code> 可执行文件的位置。</li>
<li><strong>权限检查</strong>: 操作系统会检查当前用户是否有权限执行这个文件。如果没有权限，会提示权限不足的错误。</li>
<li><strong>进程创建</strong>: 如果权限允许，操作系统会为 <code>main.out</code> 创建一个新的进程，并加载到内存中执行。这个过程包括但不限于：<ul>
<li>将程序代码和静态数据加载到内存。</li>
<li>为程序分配堆空间和栈空间。</li>
<li>设置程序的初始状态，如传递命令行参数、环境变量等。</li>
<li>开始执行程序的 <code>main</code> 函数或者入口函数。</li>
</ul>
</li>
<li><strong>程序执行</strong>: <code>main.out</code> 开始执行，根据程序中的逻辑进行各种操作，直至程序结束或者被终止。</li>
<li><strong>退出</strong>: 程序执行完毕后，操作系统会回收分配给该程序的资源，并返回到终端或者调用者。</li>
</ol>
<h3 id="82、为什么需要有链接的过程？"><a href="#82、为什么需要有链接的过程？" class="headerlink" title="82、为什么需要有链接的过程？"></a>82、为什么需要有链接的过程？</h3><p>因为软件开发的规模很大，不可能将它们都放在同一个模块中。因此按照层次化以及模块化的视线方法，将代码分成多个部分，每个部分分别开发。因此就需要在最后将它们组装起来，这就是链接的过程。通过链接，实现<strong>符号解析、地址分配和库依赖管理</strong>等工作。</p>
<h3 id="83、假设有一个-A-dll-和-B-dll，A-dll-调用了-B-dll-的方法，A-dll-是如何找到-B-dll-中的方法的？"><a href="#83、假设有一个-A-dll-和-B-dll，A-dll-调用了-B-dll-的方法，A-dll-是如何找到-B-dll-中的方法的？" class="headerlink" title="83、假设有一个 A.dll 和 B.dll，A.dll 调用了 B.dll 的方法，A.dll 是如何找到 B.dll 中的方法的？"></a>83、假设有一个 A.dll 和 B.dll，A.dll 调用了 B.dll 的方法，A.dll 是如何找到 B.dll 中的方法的？</h3><p>在使用动态库时，链接器会将<strong>动态库的相关信息</strong>，包括动态库的<strong>名字</strong>、<strong>符号表</strong>以及<strong>可重定位信息</strong>存储到相应的<strong>可执行文件</strong>中。在可执行文件运行时，链接器会根据这些信息找到对应的动态库，从而找到 A.dll 引用的 B.dll 的相关方法，并通过重定位找到其物理内存地址。</p>
<h3 id="84、假设有一个-A-cpp-和-B-cpp，A-cpp-调用了-B-cpp-的方法，A-cpp-是如何找到-B-cpp-中的方法的？"><a href="#84、假设有一个-A-cpp-和-B-cpp，A-cpp-调用了-B-cpp-的方法，A-cpp-是如何找到-B-cpp-中的方法的？" class="headerlink" title="84、假设有一个 A.cpp 和 B.cpp，A.cpp 调用了 B.cpp 的方法，A.cpp 是如何找到 B.cpp 中的方法的？"></a>84、假设有一个 A.cpp 和 B.cpp，A.cpp 调用了 B.cpp 的方法，A.cpp 是如何找到 B.cpp 中的方法的？</h3><p>在汇编后，A.cpp 生成了 A.o 文件，B.cpp 生成了 B.o 的文件，A.o 和 B.o 文件都有着自己的符号表。在链接的过程，链接器会<strong>根据两者的符号表来做符号决议，判断是否能够找到引用的外部的符号，如果找到外部唯一的符号，就会进行重定位操作来修正这一符号的地址，从而完成调用</strong>。</p>
<h3 id="85、函数调用中堆和栈的变化情况是怎样的？"><a href="#85、函数调用中堆和栈的变化情况是怎样的？" class="headerlink" title="85、函数调用中堆和栈的变化情况是怎样的？"></a>85、函数调用中堆和栈的变化情况是怎样的？</h3><p>函数调用时主要影响的是<strong>栈（stack）</strong>的变化，而不直接影响<strong>堆（heap）</strong>的变化。</p>
<ul>
<li><strong>函数进栈</strong>：<ul>
<li>调用函数时，会先将函数的参数压入栈中，参数的顺序通常是从右向左依次压入。</li>
<li>接着将当前函数的返回地址压入栈中，这个返回地址指向了调用该函数的下一条指令，用于函数执行结束后返回到调用处继续执行。</li>
<li>如果函数中有局部变量，则会在栈上为这些变量分配空间，并进行初始化。</li>
<li>最后，将当前栈指针（ESP）的值赋给基址指针（EBP），建立当前函数的栈帧。</li>
</ul>
</li>
<li><strong>函数退栈</strong>：<ul>
<li>当函数执行结束时，首先会将局部变量的值从栈中弹出，释放局部变量所占用的空间。</li>
<li>接着会将基址指针（EBP）的值赋给栈指针（ESP），恢复到函数调用之前的栈状态。</li>
</ul>
</li>
</ul>
<p>在这个过程中，函数的参数传递通常是通过栈来完成的。对于一般的函数调用，在调用函数前，调用者会将参数压入栈中；而在函数内部，被调用函数通过栈指针（ESP）来访问这些参数。在 x86 架构中，通常采用栈来传递函数参数，参数从右向左依次入栈。</p>
<h3 id="86、代码崩溃怎么解决，常见的原因是什么？"><a href="#86、代码崩溃怎么解决，常见的原因是什么？" class="headerlink" title="86、代码崩溃怎么解决，常见的原因是什么？"></a>86、代码崩溃怎么解决，常见的原因是什么？</h3><p><strong>（1）常见的崩溃原因</strong></p>
<ol>
<li><strong>访问非法内存</strong>，如已释放的内存（悬挂指针）、未初始化的指针或越界访问数组或字符串</li>
<li><strong>资源管理错误</strong>，如内存泄露，或文件或网络句柄未正确关闭</li>
<li><strong>并发错误</strong>：1）竞态条件：多个线程或进程争用数据，未正确同步；2）死锁：多个线程或进程相互等待对方持有的资源</li>
<li><strong>栈溢出</strong>：递归调用过深，或大量局部变量分配</li>
<li><strong>除零错误</strong>：整数或浮点数除以零</li>
</ol>
<p><strong>（2）解决方法</strong></p>
<ol>
<li><strong>调试工具</strong>：使用调试器（如 GDB）检查崩溃时的栈跟踪（stack trace）</li>
<li><strong>代码审查</strong></li>
<li><strong>增加日志记录</strong>：在关键操作前后添加日志记录，以追踪崩溃前的程序状态和行为；使用断言检查程序运行时的预期状态</li>
<li><strong>单元测试</strong>：编写和维护单元测试</li>
<li><strong>优化设计</strong>，避免过深的递归调用，考虑使用循环或其他算法策略；为并发操作设计合理的锁策略和线程同步机制</li>
</ol>
<h3 id="87、什么时候会发生段错误？"><a href="#87、什么时候会发生段错误？" class="headerlink" title="87、什么时候会发生段错误？"></a>87、<strong>什么时候会发生段错误？</strong></h3><p>段错误通常发生在<strong>访问非法内存地址</strong>的时候，具体来说分为以下几种情况： </p>
<ol>
<li>使用野指针；</li>
<li>试图修改字符串常量的内容。</li>
</ol>
<h3 id="88、程序崩溃产生-core-dump-一般怎么处理？"><a href="#88、程序崩溃产生-core-dump-一般怎么处理？" class="headerlink" title="88、程序崩溃产生 core dump 一般怎么处理？"></a>88、程序崩溃产生 core dump 一般怎么处理？</h3><p>core dump 是程序由于异常在运行时<strong>异常退出或者终止</strong>，在一定的条件下<strong>生成的一个叫做 core 的文件</strong>，这个 core 文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对其进行分析可以定位到程序异常发生时对应的堆栈调用信息。</p>
<p>一般采用<strong>使用 gdb 命令</strong>对 core 文件进行调试。</p>
<h3 id="89、当程序运行时，如何将其加载到进程地址空间？"><a href="#89、当程序运行时，如何将其加载到进程地址空间？" class="headerlink" title="89、当程序运行时，如何将其加载到进程地址空间？"></a>89、当程序运行时，如何将其加载到进程地址空间？</h3><ol>
<li>从可执行文件中的代码段中找到程序的入口地址；</li>
<li>接着操作系统将虚拟地址转换为对应的物理地址，并在内存中进行执行；</li>
<li>执行完毕后，切换到下一行代码进行类似的操作，直到程序运行完毕。</li>
</ol>
<h3 id="90、执行一个系统调用时，OS-发生的过程，越详细越好"><a href="#90、执行一个系统调用时，OS-发生的过程，越详细越好" class="headerlink" title="90、执行一个系统调用时，OS 发生的过程，越详细越好"></a>90、执行一个系统调用时，OS 发生的过程，越详细越好</h3><ol>
<li><p>执行用户程序(如: fork)</p>
</li>
<li><p>根据 glibc 中的函数实现，取得系统调用号并执行<code>int $0x80</code>产生中断。</p>
</li>
<li><p>进行地址空间的转换和堆栈的切换，执行 SAVE_ALL。（进行内核模式）</p>
</li>
<li><p>进行中断处理，根据系统调用表调用内核函数。</p>
</li>
<li><p>执行内核函数。</p>
</li>
<li><p>执行 RESTORE_ALL 并返回用户模式</p>
</li>
</ol>
<h3 id="91、动态链接和静态链接的区别？"><a href="#91、动态链接和静态链接的区别？" class="headerlink" title="91、动态链接和静态链接的区别？"></a>91、动态链接和静态链接的区别？</h3><ol>
<li><p>静态链接</p>
<ol>
<li><p>静态链接时指<strong>所有需要的库代码在编译时就被嵌入到可执行文件中，最终生成的可执行文件中包含了所有的库代码</strong>；</p>
</li>
<li><p>优点是具有<strong>独立性和版本一致性</strong>，可执行文件不依赖于外部库，且所有使用的库版本都是编译时版本，不会因系统库版本变化而导致问题；</p>
</li>
<li><p>缺点是<strong>文件大小过大且更新不便</strong>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o myprogram myprogram.c -static</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>动态链接</p>
<ol>
<li>动态链接是指<strong>库代码在运行时被加载，可执行文件中只包含对动态库的引用，库半身是单独的文件</strong>；</li>
<li>优点是<strong>文件大小小、易于更新，且多个程序可以共享同一个动态库</strong>；</li>
<li>缺点是<strong>依赖性强，启动时间增长</strong>，可执行文件依赖于外部库，如果这些库在系统中缺失或版本不兼容，可能会造成问题。同时程序启动时需要加载库，可能会增加启动时间。</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301606610.png" alt="image-20240630160655511"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406301607955.png" alt="image-20240630160706843"></p>
<h2 id="四、Linux相关"><a href="#四、Linux相关" class="headerlink" title="四、Linux相关"></a>四、Linux相关</h2><h3 id="【-】92、Linux-常用命令（1）"><a href="#【-】92、Linux-常用命令（1）" class="headerlink" title="【*】92、Linux 常用命令（1）"></a>【*】92、Linux 常用命令（1）</h3><ol>
<li><p>切换目录：<code>cd</code></p>
</li>
<li><p>查看端口绑定情况：<code>lsof -i : [端口号]</code>或<code>netstat -tuln</code>（列出所有监听端口）</p>
</li>
<li><p>查看CPU利用率：<code>top</code>或<code>htop</code></p>
</li>
<li><p>查看进程状态：<code>ps</code>，其中进程的状态码如下：</p>
</li>
</ol>
<ul>
<li>**R (Running)**：进程正在运行或在运行队列中等待</li>
<li>**S (Sleeping)**：进程处于睡眠状态，等待某个事件或资源。</li>
<li>**D (Uninterruptible Sleep)**：进程处于不可中断的睡眠状态，通常是在等待I&#x2F;O操作</li>
<li>**T (Stopped)**：进程已停止运行，通常是因为它正在被调试或已经收到停止信号</li>
<li>**Z (Zombie)**：进程已完成执行，但仍在进程表中等待父进程读取其退出状态</li>
<li>**I (Idle)**：这是一个空闲的内核线程，这个状态在某些版本的ps输出中可能不会显示</li>
</ul>
<ol start="5">
<li>查询网络状态：<code>ifconfig</code>、<code>netstat -r # 显示路由表</code></li>
<li>查看磁盘：<code>df -h</code>、<code>lsblk</code></li>
<li>查看是哪个进程的内存占用最大：<code>top</code>+<code>M</code>键、<code>ps aux --sort=-%mem | head -10</code></li>
<li>查找文件：<code>find</code>、<code>locate</code></li>
<li>查找文件内容：<code>grep -r &quot;hello&quot; /path/to/directory</code></li>
<li>查找系统命令的位置：<code>which ls</code></li>
</ol>
<h3 id="93、0、1、2-的文件描述符是什么含义？指向什么类型的文件？"><a href="#93、0、1、2-的文件描述符是什么含义？指向什么类型的文件？" class="headerlink" title="93、0、1、2 的文件描述符是什么含义？指向什么类型的文件？"></a>93、0、1、2 的文件描述符是什么含义？指向什么类型的文件？</h3><ol>
<li>文件描述符 0（标准输入）：指向标准输入设备，通常是终端（键盘）。</li>
<li>文件描述符 1（标准输出）：指向标准输出设备，通常是终端（屏幕）。</li>
<li>文件描述符 2（标准错误）：指向标准错误设备，通常也是终端（屏幕）。</li>
</ol>
<h3 id="【-】94、Linux-系统中的中断为什么分为上下两个部分？"><a href="#【-】94、Linux-系统中的中断为什么分为上下两个部分？" class="headerlink" title="【*】94、Linux 系统中的中断为什么分为上下两个部分？"></a>【*】94、Linux 系统中的中断为什么分为上下两个部分？</h3><p>在 Linux 系统中，中断处理通常被分为上半部（Top Half）和下半部（Bottom Half）：</p>
<ol>
<li><strong>上半部</strong>：上半部是<strong>中断处理的第一阶段</strong>，它在 CPU 接收到中断信号后立即执行。<strong>在这一阶段中，中断和调度器通常被禁用，以避免在处理中断时发生新的中断，从而保证处理的原子性</strong>。上半部的代码通常包含<strong>处理中断的关键代码</strong>，这部分代码的执行时间应尽可能短，以快速释放CPU资源，处理更多的中断或其他任务。</li>
<li><strong>下半部</strong>：下半部处理的是<strong>中断处理的后续部分</strong>，通常在上半部完成后，通过<strong>添加工作项到工作队列中</strong>来延后执行。<strong>在下半部执行时，中断通常是被允许的</strong>，这样可以在处理较长时间的任务时不阻塞其他中断的处理。下半部负责完成<strong>数据处理、复制等</strong>操作，这些操作不需要立即完成，可以稍后处理。</li>
</ol>
<p>这种分割方法的主要优点是能够快速响应中断，同时又不会因为长时间的数据处理而阻塞 CPU，影响系统的整体性能。通过这种方式，Linux 系统能够在保证响应速度的同时，也能有效地处理大量的数据。</p>
<h3 id="95、Linux-用户态如何进入内核态？"><a href="#95、Linux-用户态如何进入内核态？" class="headerlink" title="95、Linux 用户态如何进入内核态？"></a>95、Linux 用户态如何进入内核态？</h3><ol>
<li><strong>系统调用（System Call）</strong>：<strong>系统调用</strong>是最常见的从用户态切换到内核态的方式。程序在需要执行诸如文件操作、网络通信、进程控制等操作时，会通过系统调用请求操作系统提供服务。Linux 提供了大量的系统调用，例如<code>read()</code>, <code>write()</code>, <code>open()</code>, <code>fork()</code>等。系统调用通过软件中断（通常是中断指令<code>int 0x80</code>或<code>syscall</code>指令）来实现，此时处理器从用户态切换到内核态，并跳转到预定义的内核入口点执行相应的内核代码。</li>
<li><strong>异常（Exception）</strong>：当程序执行出现错误时（如除零、访问非法内存等），会触发异常，处理器切换到内核态，调动<strong>异常处理程序</strong>来响应和处理这些错误事件。</li>
<li><strong>中断（Interrupt）</strong>：当外部设备（如键盘、鼠标、网络接口等）需要处理时，它们会向处理器发送中断信号。此时正在执行的用户程序被挂起，处理器切换到内核态，调动<strong>中断处理函数</strong>来响应和处理这些外部事件。</li>
</ol>
<h3 id="96、如何用-gbd-调试发现线程阻塞？"><a href="#96、如何用-gbd-调试发现线程阻塞？" class="headerlink" title="96、如何用 gbd 调试发现线程阻塞？"></a>96、如何用 gbd 调试发现线程阻塞？</h3><ol>
<li><p><strong>启动GDB并附加到进程</strong></p>
<p>从 GDB 启动程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb ./your_program</span><br><span class="line">run [arguments]</span><br></pre></td></tr></table></figure>

<p> 附加到已经运行的程序：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -p [pid]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>列出所有线程</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info threads</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>切换线程</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread [thread-id]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>检查线程的栈帧</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backtrace</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>检查锁的状态。</strong>如果怀疑是死锁或资源竞争引起的阻塞，可以检查锁的状态。</p>
</li>
</ol>
<h3 id="97、gdb-查看所有线程线程栈的命令是什么？"><a href="#97、gdb-查看所有线程线程栈的命令是什么？" class="headerlink" title="97、gdb 查看所有线程线程栈的命令是什么？"></a>97、gdb 查看所有线程线程栈的命令是什么？</h3><ol>
<li>查看所有线程： <code>info threads</code></li>
<li>查看所有线程的栈信息： <code>thread apply all bt</code></li>
</ol>
<h3 id="98、gdb-查看内存地址的命令是什么？"><a href="#98、gdb-查看内存地址的命令是什么？" class="headerlink" title="98、gdb 查看内存地址的命令是什么？"></a>98、gdb 查看内存地址的命令是什么？</h3><p><code>x/NFU address</code></p>
<ul>
<li><code>N</code> 表示要检查的单元格的数量。</li>
<li><code>F</code> 表示显示格式，例如 <code>x</code>（十六进制）、<code>d</code>（十进制）、<code>u</code>（无符号十进制）、<code>t</code>（二进制）、<code>a</code>（地址）、<code>i</code>（机器指令）、<code>c</code>（字符）等。</li>
<li><code>U</code> 表示单位大小，例如 <code>b</code>（字节）、<code>h</code>（半字，2字节）、<code>w</code>（字，4字节）、<code>g</code>（双字，8字节）。</li>
</ul>
<h2 id="处理器相关"><a href="#处理器相关" class="headerlink" title="处理器相关"></a>处理器相关</h2><h3 id="99、浮点数在计算机中怎么存储？"><a href="#99、浮点数在计算机中怎么存储？" class="headerlink" title="99、浮点数在计算机中怎么存储？"></a>99、浮点数在计算机中怎么存储？</h3><p>浮点数在计算机中的存储通常采用IEEE 754标准，这是一种广泛使用的浮点数表示方法，具体如下：</p>
<ol>
<li><strong>符号位（Sign）</strong>：用一个位来表示数值的正负，0表示正数，1表示负数。</li>
<li><strong>指数位（Exponent）</strong>：用来表示数值的指数部分，以二进制补码表示。指数部分确定了浮点数的大小范围。</li>
<li><strong>尾数位（Fraction&#x2F;Mantissa）</strong>：也称为尾数或者系数，用来表示浮点数的小数部分。通常为带有隐含的整数1的小数分数。</li>
</ol>
<p>根据IEEE 754标准，浮点数可以分为单精度（32位）和双精度（64位）两种格式：</p>
<ul>
<li><strong>单精度浮点数（float）</strong>：由32位组成，其中1位符号位，8位指数位，23位尾数位。</li>
<li><strong>双精度浮点数（double）</strong>：由64位组成，其中1位符号位，11位指数位，52位尾数位。</li>
</ul>
<p>浮点数的存储过程如下：</p>
<ul>
<li><strong>规格化（Normalization）</strong>：尾数部分总是以某个基数（通常为2）的形式表示，例如1.xxxxxx形式。尾数的最高位总是1，且不存储在浮点数中，称为隐含位。</li>
<li><strong>指数偏移（Exponent Biasing）</strong>：指数部分采用偏移值来表示，这个偏移值是为了能够表示负数指数和正数指数，避免使用纯粹的补码表示。</li>
<li><strong>特殊值和溢出（Special Values and Overflow）</strong>：IEEE 754定义了一些特殊的浮点数值，如正无穷大、负无穷大、NaN（Not a Number）等，以及处理溢出情况。</li>
</ul>
<p>浮点数的存储和计算是通过这些位字段来实现的，具体的运算和精度受到硬件支持和IEEE 754标准的限制。</p>
<h3 id="100、怎么判断两个浮点数是否相等？"><a href="#100、怎么判断两个浮点数是否相等？" class="headerlink" title="100、怎么判断两个浮点数是否相等？"></a>100、怎么判断两个浮点数是否相等？</h3><p>相减，并与预先设定的精度进行比较。不能采用 <code>==</code> 来判断。</p>
<h3 id="101、什么是大小端？如何区分？有几种方法？网络通信一般是什么字节序？"><a href="#101、什么是大小端？如何区分？有几种方法？网络通信一般是什么字节序？" class="headerlink" title="101、什么是大小端？如何区分？有几种方法？网络通信一般是什么字节序？"></a>101、什么是大小端？如何区分？有几种方法？网络通信一般是什么字节序？</h3><ol>
<li><p>大端字节序是指高位字节存储在内存的低地址端，低位字节存储在内存的高地址端；小端字节序则与之相反。</p>
</li>
<li><p>区分的方法如下：</p>
<p>（1）通过检查整数的首个字节来确定字节序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">char</span> *c = (<span class="type">char</span>*)&amp;x;</span><br><span class="line">    <span class="keyword">if</span> (*c == <span class="number">0x78</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Little Endian\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big Endian\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）<code>htons()</code>和<code>ntohs()</code></p>
<ul>
<li><code>htons(host_port)</code>：将端口号从主机字节序转换为网络字节序</li>
<li><code>ntohs(net_port)</code>：将端口号从网络字节序转换回主机字节序</li>
</ul>
</li>
<li><p>网络通信一般是大端字节序，即无论发送和接收的系统是大端还是小端，数据在通过网络传输时都必须转换为网络字节序。</p>
</li>
</ol>
<h3 id="102、什么是-qps-和-tps-，如何计算？"><a href="#102、什么是-qps-和-tps-，如何计算？" class="headerlink" title="102、什么是 qps 和 tps ，如何计算？"></a>102、什么是 qps 和 tps ，如何计算？</h3><p>（1）<strong>QPS（Queries Per Second）</strong>：每秒查询率，是衡量每秒能处理多少个查询请求的指标。它通常用于评估搜索引擎、数据库服务器和 Web 服务器的性能。QPS 可以通过将总查询数除以时间（秒）来计算。</p>
<p>（2）<strong>TPS（Transactions Per Second）</strong>：每秒事务数，是衡量系统每秒能处理多少个事务的指标。一个事务是指一个完整的业务操作，可能包含多个查询和更新。TPS 是数据库操作和商业应用（如在线支付平台）的常用性能指标。TPS 的计算方法与 QPS 类似，将总事务数除以时间（秒）。</p>
<h3 id="103、CPU-利用率拉满的时候在线程池中增加线程是否能提高-qps？"><a href="#103、CPU-利用率拉满的时候在线程池中增加线程是否能提高-qps？" class="headerlink" title="103、CPU 利用率拉满的时候在线程池中增加线程是否能提高 qps？"></a>103、CPU 利用率拉满的时候在线程池中增加线程是否能提高 qps？</h3><p>（1）对于 CPU 密集型应用，CPU 是性能瓶颈。如果 CPU 利用率已经达到 100%，这意味着 CPU 资源已经被完全使用。在这种情况下，增加更多的线程实际上会导致线程之间的竞争更加激烈，因为更多的线程需要共享有限的 CPU 资源。这可能导致上下文切换增加，反而降低了程序的效率和 QPS。</p>
<p>（2）对于 IO 密集型应用，主要的瓶颈在于 IO 操作，如磁盘读写或网络通信等。即使 CPU 利用率很高，增加线程数仍然可能提高 QPS，因为当一部分线程在等待 IO 操作完成时，其他线程可以继续执行，从而提高整体的吞吐量。在这种情况下，增加线程数可以有效利用 CPU 在等待 IO 时的空闲周期，提高 QPS。</p>
<p>（3）混合型应用同时包含 CPU 密集型和 IO 密集型的操作。在这种情况下，是否增加线程以提高 QPS 取决于应用中 CPU 密集型和 IO 密集型操作的比例。如果 IO 操作占主导，增加线程可能有助于提高 QPS；但如果 CPU 密集型操作占主导，增加线程可能不会带来预期的效果，甚至可能因为线程竞争导致性能下降。</p>
<h3 id="104、什么是-CPU-密集型应用和-I-O-密集型应用？"><a href="#104、什么是-CPU-密集型应用和-I-O-密集型应用？" class="headerlink" title="104、什么是 CPU 密集型应用和 I&#x2F;O 密集型应用？"></a>104、什么是 CPU 密集型应用和 I&#x2F;O 密集型应用？</h3><p>（1）CPU 密集型应用是指那些需要进行大量计算，消耗大量 CPU 资源的应用。这类应用的特点是 CPU 使用率很高，因为它们主要进行数学计算、逻辑判断或者数据处理等操作，这些操作需要大量的 CPU 周期来完成。CPU 密集型应用的性能很大程度上依赖于 CPU 的处理能力。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>科学计算软件</li>
<li>图像处理和视频编码</li>
<li>大数据处理应用</li>
<li>游戏服务器的游戏逻辑处理</li>
<li>加密和解密操作</li>
</ul>
<p>（2）IO 密集型应用是指那些主要时间花费在输入输出操作上，而不是 CPU 计算上的应用。这类应用的特点是频繁地进行磁盘操作或网络通信，CPU 使用率不高，但是需要等待 IO 操作的完成，因此对 IO 性能的依赖很高。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>Web 服务器</li>
<li>数据库服务器</li>
<li>文件服务器</li>
<li>客户端&#x2F;服务器应用</li>
<li>大规模日志处理系统</li>
</ul>
<h3 id="105、I-O-密集型任务把-I-O-和业务逻辑分离有什么好处？"><a href="#105、I-O-密集型任务把-I-O-和业务逻辑分离有什么好处？" class="headerlink" title="105、I&#x2F;O 密集型任务把 I&#x2F;O 和业务逻辑分离有什么好处？"></a>105、I&#x2F;O 密集型任务把 I&#x2F;O 和业务逻辑分离有什么好处？</h3><p>（1）在 IO 密集型应用中，IO 操作（如文件读写、网络数据传输等）往往是性能瓶颈。通过异步 IO 或使用专门的线程&#x2F;进程处理 IO 操作，主业务逻辑不需要等待 IO 操作的完成，从而减少等待时间，提高整体应用的响应速度和吞吐量。</p>
<p>（2）分离 IO 和业务逻辑可以使系统更有效地使用 CPU 和 IO 资源。当 IO 操作在执行时，通常涉及等待外部设备响应，这段时间CPU可以处理其他任务，从而提高资源的利用率。</p>
<p>（3）当 IO 操作与业务逻辑分开后，更易于对系统进行扩展。例如，可以根据需要增加处理 IO 的线程或进程，或者改用更高效的 IO 处理模式（如使用更高级的异步 IO 库），而不需要重大修改应用的业务逻辑部分。</p>
<p>（4）分离 IO 和业务逻辑可以使测试变得更加简单。可以独立地对 IO 部分和业务逻辑部分进行测试，例如使用模拟的 IO 操作来测试业务逻辑，确保业务逻辑的正确性而不受 IO 影响。</p>
<h3 id="106、CPU-流水线技术是什么？"><a href="#106、CPU-流水线技术是什么？" class="headerlink" title="106、CPU 流水线技术是什么？"></a>106、CPU 流水线技术是什么？</h3><p>CPU 流水线技术是一种将指令分解为多步骤并让这些步骤并行执行的技术，从而提高 CPU 的执行效率。<strong>流水线技术通过将指令执行过程分解为取指令、译码、执行、访存和写回等阶段</strong>，每个阶段由不同的硬件单元处理，使得<strong>多条指令能够重叠执行</strong>，提高了处理速度。</p>
<h3 id="107、流水线技术中的分支预测的实现和意义？"><a href="#107、流水线技术中的分支预测的实现和意义？" class="headerlink" title="107、流水线技术中的分支预测的实现和意义？"></a>107、流水线技术中的分支预测的实现和意义？</h3><p>（1） 分支预测是流水线技术中用来<strong>处理指令跳转（如条件分支）带来的中断问题</strong>。现代 CPU 使用复杂的算法来预测程序中的分支跳转是否会发生，以及跳转到哪里。常见的分支预测技术包括静态分支预测（如始终预测跳转或不跳转）和动态分支预测（如基于历史信息的预测）。</p>
<p>（2）分支预测的主要目的是减少由于分支指令导致的流水线中断，从而提高程序执行的效率。正确的分支预测可以使 CPU 继续填充流水线而不必等待分支决定，错误的预测则会导致已经进入流水线的指令被撤销，降低效率。</p>
<h3 id="108、内核和应用进行数据交互的方法有哪些？"><a href="#108、内核和应用进行数据交互的方法有哪些？" class="headerlink" title="108、内核和应用进行数据交互的方法有哪些？"></a>108、内核和应用进行数据交互的方法有哪些？</h3><ol>
<li><strong>系统调用</strong> (System Calls):<ul>
<li>系统调用是应用程序与操作系统内核之间进行交互的主要方式。应用程序通过系统调用请求内核提供服务，如文件操作、进程控制、网络通信等。系统调用提供了一种安全的机制来执行硬件操作或访问内核级资源。</li>
</ul>
</li>
<li><strong>中断和异常</strong> (Interrupts and Exceptions):<ul>
<li>中断是外部设备或条件触发的，用于通知内核需要处理某些事件。异常则是程序执行错误时的一种特殊类型的中断，如除零错误或访问违规。</li>
<li>应用程序可以通过处理这些中断和异常来与内核交互，响应外部事件或错误。</li>
</ul>
</li>
<li><strong>共享内存</strong> (Shared Memory):<ul>
<li>共享内存是一种高效的数据交换方式，允许内核和一个或多个进程之间共享一段内存区域。这种方法可以避免复制数据，提高性能。</li>
</ul>
</li>
<li><strong>信号</strong> (Signals):<ul>
<li>信号是一种通知机制，用于通知进程发生了某些事件。内核可以向进程发送信号，以响应外部事件或内部错误，进程也可以发送信号给其他进程。</li>
</ul>
</li>
<li><strong>管道和套接字</strong> (Pipes and Sockets):<ul>
<li>管道提供了一种进程间通信的方法，允许数据在进程之间单向流动。套接字则支持更复杂的网络通信，包括进程间和网络间的数据交换。</li>
</ul>
</li>
<li><strong>文件系统操作</strong>:<ul>
<li>文件系统提供了一种存储和检索数据的方法，应用程序可以通过文件操作API与内核交互，进行数据的读写、查询和管理。</li>
</ul>
</li>
</ol>
<h3 id="109、系统调用从用户到内核的底层实现是什么？"><a href="#109、系统调用从用户到内核的底层实现是什么？" class="headerlink" title="109、系统调用从用户到内核的底层实现是什么？"></a>109、系统调用从用户到内核的底层实现是什么？</h3><ol>
<li><strong>系统调用接口</strong>：用户程序通常通过一个库（如 C 标准库）提供的封装函数来发起系统调用。这些库函数会设置好所有必要的参数供系统调用使用。</li>
<li><strong>陷入指令（Trap）</strong>：库函数内部会执行一个特殊的指令，通常是<code>syscall</code>（在 x86-64 架构中）或<code>int 0x80</code>（在较老的 x86 架构中）。这个指令会生成一个软件中断，将处理器从用户模式切换到内核模式。</li>
<li><strong>系统调用编号</strong>：每个系统调用都有一个唯一的编号。这个编号由用户程序设置在一个特定的寄存器（如 x86 中的 EAX）中，内核通过这个编号来识别具体执行哪一个系统调用。</li>
<li><strong>上下文切换</strong>：执行系统调用指令后，CPU 进入内核模式，操作系统接管控制权。此时，操作系统会保存用户程序的状态（如寄存器等），并准备执行相应的内核函数。</li>
<li><strong>执行系统调用</strong>：内核根据寄存器中的系统调用编号，通过查找系统调用表来找到对应的处理函数，并执行之。</li>
<li><strong>返回用户态</strong>：系统调用完成后，操作系统将结果返回给用户程序，恢复用户程序的上下文，并将CPU控制权返回给用户程序。</li>
<li><strong>结果传递</strong>：系统调用的结果通常通过寄存器或用户空间的内存位置返回给用户程序。</li>
</ol>
<h3 id="110、内核的调度方式是什么？"><a href="#110、内核的调度方式是什么？" class="headerlink" title="110、内核的调度方式是什么？"></a>110、内核的调度方式是什么？</h3><p>在 Linux 操作系统中，内核的调度方式是指如何管理和调度系统中的进程和线程，以优化性能和响应时间。Linux 内核使用多种调度策略和算法，主要包括以下几种：</p>
<ol>
<li><strong>完全公平调度器（Completely Fair Scheduler, CFS）</strong></li>
<li><strong>实时调度器</strong>，Linux 提供了两种实时调度策略：<code>SCHED_FIFO</code>（先进先出）和 <code>SCHED_RR</code>（时间片轮转）。</li>
<li><strong>Deadline 调度器（SCHED_DEADLINE）</strong>，这是一种较新的调度策略，用于确保任务在指定的截止时间之前完成。</li>
<li><strong>Cgroups 和任务组</strong>，Linux 还支持通过控制组（cgroups）对进程进行分组管理，这允许系统管理员根据需要对不同组的资源使用进行限制和监控。</li>
</ol>
<h3 id="111、为什么要设计用户态和内核态两种状态？"><a href="#111、为什么要设计用户态和内核态两种状态？" class="headerlink" title="111、为什么要设计用户态和内核态两种状态？"></a>111、为什么要设计用户态和内核态两种状态？</h3><p>这样做是为了保护操作系统的核心部分不被用户程序直接访问和修改，从而增加系统的稳定性和安全性。</p>
<p>（1）内核态主要允许操作系统访问受保护的硬件资源和内存区域，而用户态的控制程序则限制执行一些会影响系统稳定性和安全性的操作。</p>
<p>（2）如果用户态程序崩溃，它通常不会影响运行在内核态的系统核心部分，因此整个操作系统可以继续稳定运行。</p>
<p>（3）同时用户态程序也可能因为一些错误而尝试执行非法操作，此时操作系统可以拦截这些操作，避免对核心部分造成影响。</p>
<h3 id="112、单片机启动程序，在执行-main-之前的是什么"><a href="#112、单片机启动程序，在执行-main-之前的是什么" class="headerlink" title="112、单片机启动程序，在执行 main 之前的是什么"></a>112、单片机启动程序，在执行 main 之前的是什么</h3><p>在单片机启动程序中，执行main函数之前的过程主要包括以下几个步骤：</p>
<ol>
<li><strong>硬件设置</strong>：单片机上电后，首先进行的是硬件的初始化，包括设置堆栈指针（SP）和程序计数器（PC）。</li>
<li><strong>启动文件执行</strong>：接下来，单片机会执行启动文件，通常是名为 <code>startup_xxxxx.s</code> 的汇编语言文件。这个文件负责设置单片机的初始环境和配置，为 main 函数的执行做准备。</li>
<li><strong>初始化代码</strong>：在启动文件执行后，可能还会有一些初始化代码，这些代码用于初始化单片机的硬件和软件环境，比如设置时钟、配置中断等。</li>
<li><strong>跳转到main函数</strong>：所有的初始化和设置完成后，单片机最终会跳转到 main 函数开始执行用户的程序。</li>
</ol>
<p>这个过程确保了单片机在执行用户代码之前，硬件和系统环境已经被正确地设置和初始化，从而可以正确地运行用户程序。</p>
<h3 id="113、怎么在-main-函数执行之前打印字符串？"><a href="#113、怎么在-main-函数执行之前打印字符串？" class="headerlink" title="113、怎么在 main 函数执行之前打印字符串？"></a>113、怎么在 main 函数执行之前打印字符串？</h3><p>使用全局对象的构造函数。全局对象的构造函数在程序开始执行之前被调用，因此可以在这里进行一些初始化操作，包括打印字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GlobalPrinter</span> &#123;</span><br><span class="line">    <span class="comment">// 在构造函数中打印字符串</span></span><br><span class="line">    <span class="built_in">GlobalPrinter</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Printed before main starts!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局对象，其构造函数会在 main 函数之前执行</span></span><br><span class="line">GlobalPrinter printer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside main function.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>GlobalPrinter</code> 结构体是一个全局对象，其构造函数在程序启动时执行，因此会在 <code>main</code> 函数执行之前打印 <code>&quot;Printed before main starts!&quot;</code>。</p>
<h3 id="114、cpu-怎么从内存中获取数据的，要经过哪些模块（比如执行-load-指令时）？"><a href="#114、cpu-怎么从内存中获取数据的，要经过哪些模块（比如执行-load-指令时）？" class="headerlink" title="114、cpu 怎么从内存中获取数据的，要经过哪些模块（比如执行 load 指令时）？"></a>114、cpu 怎么从内存中获取数据的，要经过哪些模块（比如执行 load 指令时）？</h3><p>当 CPU 执行 load 指令从内存中获取数据时，通常会经过以下几个主要阶段和模块：</p>
<ol>
<li><strong>地址计算</strong>：CPU 根据 load 指令中的内存地址计算要访问的物理地址。这个地址通常是通过将逻辑地址（由程序中指定的地址）转换为物理地址来完成的。</li>
<li><strong>地址总线传输</strong>：CPU 使用地址总线将计算得到的物理地址发送到内存控制器（Memory Controller）。</li>
<li><strong>内存寻址</strong>：内存控制器接收到地址后，根据地址在物理内存中定位要访问的数据块。</li>
<li><strong>数据传输</strong>：内存控制器根据地址访问内存中的数据，并通过数据总线将数据传输回 CPU。</li>
<li><strong>数据接收</strong>：CPU 接收到数据，并将其存储到指定的寄存器或者目的地。</li>
</ol>
<h3 id="115、arm-和-x86-比较明显的区别是什么？"><a href="#115、arm-和-x86-比较明显的区别是什么？" class="headerlink" title="115、arm 和 x86 比较明显的区别是什么？"></a>115、arm 和 x86 比较明显的区别是什么？</h3><p><strong>指令集架构：</strong></p>
<ul>
<li><strong>x86 架构</strong>：主要用于个人电脑和服务器，采用复杂的指令集（CISC），例如 Intel 的 x86 和 x86-64（即64位扩展）架构。x86 架构的特点是指令集较为复杂，包含大量的指令和寄存器，能够执行复杂的操作，但功耗较高。</li>
<li><strong>ARM 架构</strong>：最初设计用于低功耗和嵌入式系统，采用精简指令集（RISC）。ARM 架构的特点是指令集简洁高效，适合于低功耗和嵌入式设备，如智能手机、平板电脑、嵌入式系统等。</li>
</ul>
<h3 id="116、如果发现系统变慢，linux-会怎么考虑怎么排查这个问题？"><a href="#116、如果发现系统变慢，linux-会怎么考虑怎么排查这个问题？" class="headerlink" title="116、如果发现系统变慢，linux 会怎么考虑怎么排查这个问题？"></a>116、如果发现系统变慢，linux 会怎么考虑怎么排查这个问题？</h3><ol>
<li><p><strong>观察系统资源使用情况</strong>：</p>
<p>使用命令 <code>top</code> 或 <code>htop</code> 查看当前系统的 CPU 使用率、内存使用情况、进程状态以及各个进程的资源消耗情况。特别关注是否有某个进程消耗过多的 CPU 或内存。</p>
</li>
<li><p><strong>检查系统负载情况</strong>：使用 <code>uptime</code> 命令或者查看 <code>/proc/loadavg</code> 文件，检查系统的负载情况。如果负载过高（load average 高于 CPU 核心数），说明系统可能存在过多的并发任务或者进程阻塞。</p>
</li>
<li><p><strong>查看日志文件</strong>：检查系统日志文件（如 <code>/var/log/messages</code>、<code>/var/log/syslog</code>）以及特定服务的日志（如 Apache、MySQL 等），寻找异常或者错误信息。日志文件通常会记录系统的各种事件和错误情况。</p>
</li>
<li><p><strong>检测磁盘使用情况</strong>：使用 <code>df</code> 命令查看磁盘分区的使用情况，尤其是是否出现磁盘空间不足或者磁盘 I&#x2F;O 瓶颈的情况。</p>
</li>
<li><p><strong>网络流量分析</strong>：使用 <code>netstat</code> 或者 <code>iftop</code> 查看网络连接和流量情况，检查是否有异常的网络活动或者网络流量过高。</p>
</li>
<li><p><strong>检查系统进程</strong>：使用 <code>ps</code> 命令查看当前运行的进程，并检查是否有异常或者不必要的进程占用资源。</p>
</li>
<li><p><strong>性能分析工具</strong>：使用工具如 <code>sar</code>、<code>vmstat</code>、<code>iostat</code> 等进行系统性能分析，查看 CPU、内存、磁盘和网络的详细使用情况，帮助定位性能瓶颈。</p>
</li>
<li><p><strong>检查硬件问题</strong>：如果排查软件问题后仍未找到原因，可能需要考虑硬件问题。通过检查硬件状态和日志（如 <code>/var/log/dmesg</code>）来排除硬件故障的可能性。</p>
</li>
</ol>
<h2 id="六、Linux-命令相关"><a href="#六、Linux-命令相关" class="headerlink" title="六、Linux 命令相关"></a>六、Linux 命令相关</h2><h3 id="117、哪些状态的进程无法被-kill？"><a href="#117、哪些状态的进程无法被-kill？" class="headerlink" title="117、哪些状态的进程无法被 kill？"></a>117、哪些状态的进程无法被 kill？</h3><p><strong>内核线程（Kernel Threads）</strong>：内核线程是在内核空间中执行的线程，通常由操作系统内核创建和管理。这些线程通常处于内核态，而不是用户态，因此无法通过kill命令来终止。</p>
<p><strong>僵尸进程（Zombie Processes）</strong>：僵尸进程是已经结束但是父进程尚未对其进行处理的子进程，这种进程处于僵尸状态。虽然它们已经结束了执行，但是它们的进程描述符仍然存在于系统中，直到父进程调用 wait 或 waitpid 等系统调用来获取它们的退出状态。在僵尸状态下，进程通常是无法通过kill命令来终止的。</p>
<p><strong>被内核保护的进程</strong>：一些特殊的进程可能受到内核的保护，例如一些关键的系统服务或者核心进程。这些进程通常由操作系统内核管理，并且可能受到权限限制，无法被普通用户通过kill命令终止。</p>
<h3 id="118、kill-是怎么实现终止进程的？"><a href="#118、kill-是怎么实现终止进程的？" class="headerlink" title="118、kill 是怎么实现终止进程的？"></a>118、kill 是怎么实现终止进程的？</h3><p>在 Linux 系统中，kill 命令用于向指定进程发送信号，其中包括终止进程的 SIGKILL 信号（信号编号为 9）和其他各种信号。终止进程的实现涉及操作系统内核的功能和进程管理机制。</p>
<p>当用户使用 kill 命令向某个进程发送 SIGKILL 信号时，操作系统内核会首先验证当前用户是否具有足够的权限来发送信号给目标进程。如果具有足够的权限，则内核会查找目标进程的进程描述符，并向其发送指定的信号。</p>
<p>接收到信号的进程会根据信号的类型采取不同的行动。对于 SIGKILL 信号，目标进程会被立即终止，无法进行信号处理或者捕获。此外，进程终止时，内核会对其进行一系列清理工作，包括释放该进程所占用的资源、解除与其他进程的关联等。</p>
<h3 id="119、Linux-常用命令（2）"><a href="#119、Linux-常用命令（2）" class="headerlink" title="119、Linux 常用命令（2）"></a>119、Linux 常用命令（2）</h3><h4 id="（1）查看哪个进程的内存占用最大？"><a href="#（1）查看哪个进程的内存占用最大？" class="headerlink" title="（1）查看哪个进程的内存占用最大？"></a>（1）查看哪个进程的内存占用最大？</h4><ol>
<li><p><code>top</code>+<code>M</code>键</p>
</li>
<li><p><code>ps</code>结合<code>sort</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux --<span class="built_in">sort</span>=-%mem | <span class="built_in">head</span> -n 10</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>htop</code></p>
</li>
</ol>
<h4 id="（2）查看进程打开了什么端口？"><a href="#（2）查看进程打开了什么端口？" class="headerlink" title="（2）查看进程打开了什么端口？"></a>（2）查看进程打开了什么端口？</h4><p> <code>netstat -tulnp</code> ，列出当前系统中所有正在监听的 TCP 和 UDP 端口以及对应的进程信息。</p>
<h4 id="（3）查看进程是否存活？"><a href="#（3）查看进程是否存活？" class="headerlink" title="（3）查看进程是否存活？"></a>（3）查看进程是否存活？</h4><p><code>ps -p &lt;PID&gt;</code>，查看指定 PID 的进程信息，如果返回了进程信息，则表示该进程存活。</p>
<h4 id="（4）查看进程-id-？"><a href="#（4）查看进程-id-？" class="headerlink" title="（4）查看进程 id ？"></a>（4）查看进程 id ？</h4><p> <code>ps aux | grep &lt;进程名&gt;</code> ，查看指定进程名的所有进程，并显示它们的进程 ID。</p>
<h4 id="（5）查看进程状态？"><a href="#（5）查看进程状态？" class="headerlink" title="（5）查看进程状态？"></a>（5）查看进程状态？</h4><p><code>ps</code> ，查看进程的状态。</p>
<p><code>ps aux</code> 命令可以列出系统中所有进程的详细信息，包括状态、PID、CPU 利用率等。</p>
<h4 id="（6）lsof-指令主要是干什么的？"><a href="#（6）lsof-指令主要是干什么的？" class="headerlink" title="（6）lsof 指令主要是干什么的？"></a>（6）lsof 指令主要是干什么的？</h4><p><code>lsof（list open files）</code>主要用于显示当前系统中打开的文件列表，包括文件、目录、网络套接字等。通过 lsof 命令可以查看某个进程打开了哪些文件、网络连接等信息，用于定位进程问题、分析系统资源利用等。</p>
<h4 id="（7）-如何让进程后台运行？"><a href="#（7）-如何让进程后台运行？" class="headerlink" title="（7） 如何让进程后台运行？"></a>（7） 如何让进程后台运行？</h4><ol>
<li><p><strong>使用 &amp; 符号</strong>：</p>
<ul>
<li><p>在命令行中，在命令的末尾加上 <code>&amp;</code> 符号，可以让该命令在后台执行。</p>
</li>
<li><p>例如，要让 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python script.py</span><br></pre></td></tr></table></figure>

<p> 在后台运行，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python script.py &amp;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用 nohup 命令</strong>：</p>
<ul>
<li><p><code>nohup</code> 命令用于将程序以忽略挂断信号的方式运行，这样即使终端关闭，程序也会继续在后台运行。</p>
</li>
<li><p>使用方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> python script.py &amp;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="（8）查看一个进程可以打开多少文件描述符？"><a href="#（8）查看一个进程可以打开多少文件描述符？" class="headerlink" title="（8）查看一个进程可以打开多少文件描述符？"></a>（8）查看一个进程可以打开多少文件描述符？</h4><p>在大多数 Linux 系统中，一个进程最多可以同时打开 1024 个文件。</p>
<p>不过，可以通过修改系统配置来增加： </p>
<ul>
<li><code>ulimit -n</code>：查看当前进程的文件描述符限制；</li>
<li><code>ulimit -n 4096</code>：将文件描述符限制增加到 4096。注意的是，文件描述符限制是系统范围的，而不是针对单个进程的。因此，对文件描述符限制的修改将影响到所有正在运行的进程。</li>
</ul>
<h4 id="（9）查看-CPU-核心数？"><a href="#（9）查看-CPU-核心数？" class="headerlink" title="（9）查看 CPU 核心数？"></a>（9）查看 CPU 核心数？</h4><p><strong>方法一</strong>：<code>lscpu</code> 命令，在输出中查找 <code>CPU(s):</code> 字段。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong>：读取 <code>/proc/cpuinfo</code> 文件可以，统计 <code>processor</code> 字段的行数，等于逻辑 CPU 核心的数量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep <span class="string">&quot;processor&quot;</span> | <span class="built_in">wc</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /proc/cpuinfo：这个命令用于打印 CPU 信息到标准输出。</span></span><br><span class="line"><span class="comment"># grep &quot;processor&quot;：通过管道 | 将 cat 命令的输出传递给 grep 命令，</span></span><br><span class="line"><span class="comment">#				    然后使用 grep 进行筛选，只保留包含 &quot;processor&quot; 字符串的行，</span></span><br><span class="line"><span class="comment">#					这些行包含了每个 CPU 核心的信息。</span></span><br><span class="line"><span class="comment"># wc -l：</span></span><br><span class="line"><span class="comment">#	wc 命令用于统计文件的行数，参数 -l 表示只统计行数。</span></span><br><span class="line"><span class="comment">#   通过 | 管道将 grep 命令的输出传递给 wc 命令，然后 wc 统计行数。</span></span><br><span class="line"><span class="comment">#	因为每个 CPU 核心的信息占据一行，所以统计出来的行数就是 CPU 的核心数。</span></span><br></pre></td></tr></table></figure>

<p><strong>方法三</strong>：<code>nproc</code> 命令，直接显示可用的处理器数量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nproc</span></span><br></pre></td></tr></table></figure>

<p><strong>方法四</strong>：<code>top</code> 和 <code>htop</code> 命令也可以显示 CPU 信息。在 <code>htop</code> 中，可以在界面顶部看到 CPU 核心的数量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">htop</span><br></pre></td></tr></table></figure>

<p><strong>方法五</strong>：<code>dmesg</code> 命令，查看启动日志，可以找到 CPU 信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i cpu</span><br></pre></td></tr></table></figure>

<h4 id="（10）如何按照内存使用情况对进程排序查看？"><a href="#（10）如何按照内存使用情况对进程排序查看？" class="headerlink" title="（10）如何按照内存使用情况对进程排序查看？"></a>（10）如何按照内存使用情况对进程排序查看？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -o %MEM</span><br></pre></td></tr></table></figure>

<h4 id="（11）查看磁盘状态？"><a href="#（11）查看磁盘状态？" class="headerlink" title="（11）查看磁盘状态？"></a>（11）查看磁盘状态？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">df</span> -sh &lt;目录名&gt;</span><br></pre></td></tr></table></figure>

<h4 id="（12）查看日志文件的前一百行？"><a href="#（12）查看日志文件的前一百行？" class="headerlink" title="（12）查看日志文件的前一百行？"></a>（12）查看日志文件的前一百行？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 100 &lt;日志文件&gt;</span><br></pre></td></tr></table></figure>

<h4 id="（13）-ps-aux-，-aux-是干什么的？"><a href="#（13）-ps-aux-，-aux-是干什么的？" class="headerlink" title="（13） ps -aux ， aux 是干什么的？"></a>（13） ps -aux ， aux 是干什么的？</h4><p>在 <code>ps -aux</code> 命令中，<code>aux</code> 是选项，用于指定显示所有进程的详细信息。其中：</p>
<ul>
<li><code>a</code> 选项表示显示所有进程，包括与终端无关的进程。</li>
<li><code>u</code> 选项表示显示用户及与进程相关的详细信息，如用户 ID、CPU 占用率、内存占用等。</li>
<li><code>x</code> 选项表示显示与终端无关的进程。</li>
</ul>
<p>因此，<code>ps -aux</code> 命令用于显示系统中所有进程的详细信息，包括与终端无关的进程。</p>
<h4 id="（14）本地和远程服务器之间传输文件的是什么？"><a href="#（14）本地和远程服务器之间传输文件的是什么？" class="headerlink" title="（14）本地和远程服务器之间传输文件的是什么？"></a>（14）本地和远程服务器之间传输文件的是什么？</h4><p><code>scp</code></p>
<h4 id="（15）查找文件名包含某个关键字的文件"><a href="#（15）查找文件名包含某个关键字的文件" class="headerlink" title="（15）查找文件名包含某个关键字的文件"></a>（15）查找文件名包含某个关键字的文件</h4><p><code>find 目录 -name &quot;特定字符串&quot;</code></p>
<h3 id="120、Linux-包含哪些部分？"><a href="#120、Linux-包含哪些部分？" class="headerlink" title="120、Linux 包含哪些部分？"></a>120、Linux 包含哪些部分？</h3><ol>
<li>内核，操作系统的核心部分，负责管理计算机的硬件资源，包括处理器、内存、设备驱动程序等。它提供了系统调用接口，允许用户程序与硬件交互；</li>
<li>Shell，用户与操作系统交互的界面，它可以解释用户输入的命令并将其转换为操作系统能够理解的形式，常见的 Shell 包括 Bash、Zsh、Korn 等；</li>
<li>文件系统，指文件和目录在存储设备上的组织方式，它提供了对文件和目录的创建、读取、写入和删除等操作。常见的文件系统包括 ext4、NTFS、FAT32 等；</li>
<li>GNU 工具，一组用于开发和管理 Linux 系统的软件工具，包括编译器、调试器、文本编辑器等。常见的 GNU 工具包括 GCC、GDB、Emacs 等；</li>
<li>图形用户界面 GUI</li>
<li>应用程序。</li>
</ol>
<h3 id="121、操作系统包含哪些部分？"><a href="#121、操作系统包含哪些部分？" class="headerlink" title="121、操作系统包含哪些部分？"></a>121、操作系统包含哪些部分？</h3><ol>
<li><strong>内核（Kernel）</strong>：操作系统的核心部分，负责管理计算机的硬件资源，包括处理器、内存、设备驱动程序等。内核提供了系统调用接口，允许用户程序与硬件交互；</li>
<li><strong>文件系统（File System）</strong>：用于组织和管理计算机存储设备上的文件和目录。文件系统提供了文件的创建、读取、写入、删除等操作，以及对文件和目录的权限管理；</li>
<li><strong>进程管理（Process Management）</strong>：负责创建、调度和管理进程。进程是程序的执行实例，进程管理器控制着进程的创建、调度、终止等操作，并提供了进程间通信的机制；</li>
<li><strong>内存管理（Memory Management）</strong>：管理计算机的内存资源，包括内存的分配、释放、页面交换等操作。内存管理器负责为进程分配内存空间，并确保不同进程之间的内存地址空间互相隔离；</li>
<li><strong>文件系统（File System）</strong>：用于组织和管理计算机存储设备上的文件和目录。文件系统提供了文件的创建、读取、写入、删除等操作，以及对文件和目录的权限管理；</li>
<li><strong>设备驱动程序（Device Drivers）</strong>：负责与计算机的硬件设备进行通信，控制设备的操作和数据传输。设备驱动程序允许操作系统与硬件设备之间进行交互，以实现对硬件的控制和管理；</li>
<li><strong>用户界面（User Interface）</strong>：提供用户与操作系统交互的界面，包括命令行界面（CLI）和图形用户界面（GUI）。用户界面使用户能够通过输入命令或使用图形化界面来操作计算机；</li>
<li><strong>网络管理（Networking）</strong>：管理计算机与网络之间的通信和连接。网络管理器负责配置网络参数、管理网络接口、处理数据传输等操作，以确保计算机能够与其他设备进行通信。</li>
</ol>
<h2 id="七、文件系统"><a href="#七、文件系统" class="headerlink" title="七、文件系统"></a>七、文件系统</h2><h3 id="122、文件系统的基本组成"><a href="#122、文件系统的基本组成" class="headerlink" title="122、文件系统的基本组成"></a>122、文件系统的基本组成</h3><h3 id="123、虚拟文件系统"><a href="#123、虚拟文件系统" class="headerlink" title="123、虚拟文件系统"></a>123、虚拟文件系统</h3><h3 id="124、文件的存储"><a href="#124、文件的存储" class="headerlink" title="124、文件的存储"></a>124、文件的存储</h3><h3 id="125、空闲空间管理"><a href="#125、空闲空间管理" class="headerlink" title="125、空闲空间管理"></a>125、空闲空间管理</h3><h3 id="126、文件系统的结构"><a href="#126、文件系统的结构" class="headerlink" title="126、文件系统的结构"></a>126、文件系统的结构</h3><h3 id="127、目录的存储"><a href="#127、目录的存储" class="headerlink" title="127、目录的存储"></a>127、目录的存储</h3><h3 id="128、软链接和硬链接"><a href="#128、软链接和硬链接" class="headerlink" title="128、软链接和硬链接"></a>128、软链接和硬链接</h3><h3 id="129、文件I-O"><a href="#129、文件I-O" class="headerlink" title="129、文件I&#x2F;O"></a>129、文件I&#x2F;O</h3><h3 id="130、进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？"><a href="#130、进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？" class="headerlink" title="130、进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？"></a>130、进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？</h3><h2 id="八、设备管理"><a href="#八、设备管理" class="headerlink" title="八、设备管理"></a>八、设备管理</h2><h3 id="131、键盘敲入-A-字母时，操作系统期间发生了什么？"><a href="#131、键盘敲入-A-字母时，操作系统期间发生了什么？" class="headerlink" title="131、键盘敲入 A 字母时，操作系统期间发生了什么？"></a>131、键盘敲入 A 字母时，操作系统期间发生了什么？</h3><h2 id="九、网络系统"><a href="#九、网络系统" class="headerlink" title="九、网络系统"></a>九、网络系统</h2><h3 id="132、什么是零拷贝？"><a href="#132、什么是零拷贝？" class="headerlink" title="132、什么是零拷贝？"></a>132、什么是零拷贝？</h3><h3 id="133、I-O-多路复用：select-poll-epoll"><a href="#133、I-O-多路复用：select-poll-epoll" class="headerlink" title="133、I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll"></a>133、I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll</h3><h3 id="134、高性能网络模式：Reactor-和-Proactor"><a href="#134、高性能网络模式：Reactor-和-Proactor" class="headerlink" title="134、高性能网络模式：Reactor 和 Proactor"></a>134、高性能网络模式：Reactor 和 Proactor</h3><h3 id="135、什么是一致性哈希？"><a href="#135、什么是一致性哈希？" class="headerlink" title="135、什么是一致性哈希？"></a>135、什么是一致性哈希？</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/12/Computer/C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/12/Computer/C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">智能指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-12 14:29:34" itemprop="dateCreated datePublished" datetime="2024-06-12T14:29:34+08:00">2024-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-05 10:41:47" itemprop="dateModified" datetime="2024-07-05T10:41:47+08:00">2024-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/06/12/Computer/C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/11/Computer/C++/%E5%B8%B8%E7%94%A8STL%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/11/Computer/C++/%E5%B8%B8%E7%94%A8STL%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">常用STL容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-11 15:54:29" itemprop="dateCreated datePublished" datetime="2024-06-11T15:54:29+08:00">2024-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-05 10:41:55" itemprop="dateModified" datetime="2024-07-05T10:41:55+08:00">2024-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/06/11/Computer/C++/%E5%B8%B8%E7%94%A8STL%E5%AE%B9%E5%99%A8/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/11/Computer/DataStruct/%E6%97%B6%E9%97%B4&%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/11/Computer/DataStruct/%E6%97%B6%E9%97%B4&%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" class="post-title-link" itemprop="url">时间&空间复杂度</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-11 14:30:41" itemprop="dateCreated datePublished" datetime="2024-06-11T14:30:41+08:00">2024-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-05 10:40:55" itemprop="dateModified" datetime="2024-07-05T10:40:55+08:00">2024-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/DataStruct/" itemprop="url" rel="index"><span itemprop="name">DataStruct</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>884</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/06/11/Computer/DataStruct/%E6%97%B6%E9%97%B4&%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/28/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/28/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-28 09:30:35" itemprop="dateCreated datePublished" datetime="2024-05-28T09:30:35+08:00">2024-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-03 22:09:48" itemprop="dateModified" datetime="2024-07-03T22:09:48+08:00">2024-07-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>48k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2:54</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h2 id="1、为什么要有TCP-IP网络模型？"><a href="#1、为什么要有TCP-IP网络模型？" class="headerlink" title="1、为什么要有TCP&#x2F;IP网络模型？"></a>1、为什么要有TCP&#x2F;IP网络模型？</h2><p>为了实现不同设备间的通信，需要网络通信。又由于需要兼容多样性的设备，因此需要一套通用的网络协议。</p>
<h2 id="2、TCP-IP网络模型概述"><a href="#2、TCP-IP网络模型概述" class="headerlink" title="2、TCP&#x2F;IP网络模型概述"></a>2、TCP&#x2F;IP网络模型概述</h2><p><strong>1、应用层</strong></p>
<p>应用层工作在操作系统的用户态，不关心数据如何传输，只需要为用户提供应用功能，如 HTTP、FTP、Telent、DNS 和 SMTP 等。</p>
<p><strong>2、传输层</strong></p>
<p>传输层为应用层提供网络支持，包含两个传输协议，TCP（可靠）和UDP（不可靠）。由于应用需要传输的数据可能会非常大，因此当传输层的数据包超过 MSS（TCP 最大报文段长度）时 ，就要将数据包分块（即TCP段）。当设备作为接收方时，传输层则要负责把数据包传给应用，根据传输层报文中携带的端口号，应用层识别出该报文发送给哪个应用。</p>
<p><strong>3、网络层</strong></p>
<p>网络层负责将数据从一个设备传输到另一个设备（与此相比，传输层只负责作为应用间数据传输的媒介）。网络层最常使用的是 IP 协议（Internet Protocol），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p>
<p>路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。除了<strong>寻址能力</strong>， IP 协议还有另一个重要的能力就是<strong>路由</strong>。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</p>
<p>所以，<strong>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</strong>。</p>
<p><strong>4、网络接口层</strong></p>
<p>网络接口层主要为网络层提供链路级别传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。以太网在判断网络包目的地时必须采用相匹配的方式才能在以太网中将包发往目的地，MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</p>
<p><strong>5、总结</strong></p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png" alt="img" style="zoom: 50%;" />

<p>每一层的封装格式：</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img" style="zoom: 50%;" />

<h2 id="3、键入网址到网页显示，期间发生了什么？"><a href="#3、键入网址到网页显示，期间发生了什么？" class="headerlink" title="3、键入网址到网页显示，期间发生了什么？"></a>3、键入网址到网页显示，期间发生了什么？</h2><blockquote>
<p><strong>第一步</strong>，浏览器对 URL 进行解析，确定 Web 服务器和文件名；</p>
<p><strong>第二步</strong>，生成发送给 Web 服务器的 HTTP 请求信息；</p>
<p><strong>第三步</strong>，通过 DNS 查询与服务器域名对应的 IP 地址；</p>
<p><strong>第四步</strong>，将 HTTP 的传输工作交给操作系统中的协议栈；</p>
<p><strong>第五步</strong>，将请求信息封装为 TCP 报文，交给下面的网络层处理；</p>
<p><strong>第六步</strong>，根据查询到的 IP 信息将 TCP 报文封装为 IP 报文；</p>
<p><strong>第七步</strong>，根据自己的网络获取源 MAC 地址，根据 ARP 协议找到目的 IP 地址对应的 MAC 地址，从而封装好 MAC 报文，生成最终的网络包；</p>
<p><strong>第八步</strong>，通过网卡将网络包这串数字信号转为电信号，通过网线发送出去；</p>
<p><strong>第九步</strong>，通过交换机和路由器的转发，最终到达Web服务器；</p>
<p><strong>第十步</strong>，Web 服务器的 HTTP 进程接收到请求报文后，将请求的网页封装在 HTTP 响应报文里，根据类似的步骤发送至客户端。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405280953095.png" alt="简单的网络模型"></p>
<p>1、第一步，浏览器对URL进行解析，确定Web服务器和文件名；</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281022515.jpeg" alt="URL 解析"></p>
<ul>
<li><strong>当URL中并未给出表示数据源&#x2F;文件的路径名时，请求的是哪个文件？</strong></li>
</ul>
<p>当没有路径名时，就代表访问根目录下事先设置的<strong>默认文件</strong>，也就是 &#x2F;index.html 或者 &#x2F;default.html 等这些文件。</p>
<p>2、第二步，生成发送给Web服务器的HTTP请求信息；</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281022489.png" alt="HTTP 的消息格式" style="zoom:50%;" />

<p>3、<strong>第三步：通过DNS查询与服务器域名对应的IP地址；</strong></p>
<p>DNS服务器负责保存Web服务器域名与IP的对应关系。当然，首先会考虑是否能在缓存中直接找到，因此总的寻找顺序如下：</p>
<p>1、浏览器自身的缓存；</p>
<p>2、操作系统自身的缓存；</p>
<p>3、hosts文件；</p>
<p>4、本地DNS服务器。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281023787.png" alt="域名解析的工作流程"></p>
<p>4、第四步，将HTTP的传输工作交给操作系统中的协议栈；</p>
<ul>
<li>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作；</li>
<li>TCP&#x2F;UDP接受应用层的委托，执行收发数据的操作；</li>
<li>IP协议控制网络包的收发操作；</li>
<li>网卡驱动程序负责控制网卡硬件；</li>
<li>网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</li>
</ul>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg" alt="img" style="zoom:50%;" />

<p>5、第五步，将请求信息封装为TCP报文，交给下面的网络层处理；</p>
<ul>
<li>根据三次握手建立连接；</li>
<li>将HTTP信息以 <code>MSS</code> 的长度为单位进行拆分；</li>
<li>封装TCP报文。</li>
</ul>
<p>6、第六步，根据查询到的IP信息将TCP报文封装为IP报文；</p>
<ul>
<li><strong>假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？</strong></li>
</ul>
<p>当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。这个时候就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址 IP。</p>
<p>7、第七步，根据自己的网络获取源MAC地址，根据ARP协议找到目的IP地址对应的MAC地址，从而封装好MAC报文，生成最终的网络包；</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281111484.jpeg" alt="MAC 层报文" style="zoom:50%;" />

<p>8、第八步，通过网卡将网络包这串数字信号转为电信号，通过网线发送出去；</p>
<p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png" alt="数据包" style="zoom: 67%;" />

<p>9、第九步，通过交换机和路由器的转发，最终到达Web服务器；</p>
<p><strong>交换机的工作方式和网卡不同：</strong></p>
<p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p>
<p>10、第十步，Web服务器的HTTP进程接收到请求报文后，将请求的网页封装在HTTP相应报文里，根据类似的步骤发送至客户端。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/25.jpg" alt="网络分层模型" style="zoom:50%;" />

<blockquote>
<ul>
<li>读者问：“请问公网服务器的 Mac 地址是在什么时机通过什么方式获取到的？我看 arp 获取Mac地址只能获取到内网机器的 Mac 地址吧？”</li>
</ul>
<p>在发送数据包时，如果目标主机不是本地局域网，填入的MAC地址是路由器，也就是把数据包转发给路由器，路由器一直转发下一个路由器，直到转发到目标主机的路由器，发现 IP 地址是自己局域网内的主机，就会 ARP 请求获取目标主机的 MAC 地址，从而转发到这个服务器主机。</p>
<p>转发的过程中，源IP地址和目标IP地址是不会变的（前提：没有使用 NAT 网络的），源 MAC 地址和目标 MAC 地址是会变化的。</p>
</blockquote>
<h2 id="4、Linux接收网络包的流程"><a href="#4、Linux接收网络包的流程" class="headerlink" title="4、Linux接收网络包的流程"></a>4、Linux接收网络包的流程</h2><blockquote>
<p>当网卡接收到网络包后，通过 DMA 将网络包写入 Ring Buffer 中，并通过中断和轮询的方式告诉操作系统该网络包已到达。</p>
<p>操作系统首先调用<strong>硬中断</strong>处理函数表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以，不需要再通知 CPU 了，接着发起<strong>软中断</strong>，恢复刚才屏蔽的中断。软中断则从 Ring Buffer 中获取一个数据帧，即<code>sk_buff</code>，作为网络包交给网络协议栈进行逐层处理。</p>
<p>逐层处理的过程是（1）先进入网络接口层，检查报文的合法性，并并找出上层协议的类型；（2）交给网络层，取出 IP 包，判断是要转发出去还是交给本机上层处理；（3）传输层取出 TCP&#x2F;UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，将数据放入 Socket 对应的接收缓冲区；（4）最后，应用进程调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。</p>
</blockquote>
<p><strong>Linux 系统是如何收发网络包的？</strong></p>
<p>Linux 网络协议栈：</p>
<ul>
<li>应用程序需要通过系统调用，来跟 Socket 层进行数据交互；</li>
<li>Socket 层的下面就是传输层、网络层和网络接口层；</li>
<li>最下面的一层，则是网卡驱动程序和硬件网卡设备；</li>
</ul>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281119851.png" alt="img" style="zoom: 50%;" />





<p>一个网络包的收发流程：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281124646.png" alt="img"></p>
<p>（1）网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。</p>
<p>（2）通过触发中断的方式来告诉操作系统这个网络包已到达，但为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 <strong>NAPI 机制</strong>，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是<strong>不采用中断的方式读取数据</strong>，而是首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据。</p>
<ul>
<li>硬件中断处理函数：<ul>
<li>需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。</li>
<li>接着，发起「软中断」，然后恢复刚才屏蔽的中断。</li>
</ul>
</li>
<li>软件中断处理函数：<ul>
<li>内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，轮询处理数据。</li>
<li>ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 <code>sk_buff</code> 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</li>
</ul>
</li>
</ul>
<p>（3）逐层处理的流程如下。</p>
<ul>
<li>首先，会先进入到网络接口层，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给网络层。</li>
<li>到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。</li>
<li>传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。</li>
<li>最后，应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。</li>
</ul>
<p>至此，一个网络包的接收过程就已经结束了。</p>
<h2 id="5、Linux发送网络包的流程"><a href="#5、Linux发送网络包的流程" class="headerlink" title="5、Linux发送网络包的流程"></a>5、Linux发送网络包的流程</h2><blockquote>
<p>首先，应用进程调用Socket发送数据的接口，从用户态进入内核态，内核申请一个<code>sk_buff</code>内存，将用户待发送的数据拷贝到<code>sk_buff</code>内存，并将其加入到发送缓冲区。</p>
<p>其次，网络协议栈从Socket发送缓冲区取出<code>sk_buff</code>，<code>sk_buff</code>通过调整其data的指针，可以表示各个层的数据包。因此按照TCP&#x2F;IP协议栈从上到下逐层处理，最终将<code>sk_buff</code>放到网卡的发送队列中。注意如果使用的是 TCP 传输协议发送数据，需要先拷贝一个新的 <code>sk_buff</code> 副本。</p>
<p>此时，会触发「软中断」告诉网卡驱动程序有新的网络包需要发送。驱动程序从发送队列中读取<code>sk_buff</code>并挂到<code>Ring Buffer</code>中，并将<code>sk_buff</code>的数据映射到网卡可访问的内存DMA区域，并触发真实的发送。</p>
<p>当数据发送完成后，网卡设备会触发硬中断释放内存，主要是释放<code>sk_buff</code> 内存和清理<code>Ring Buffer</code>内存。并且，当收到这个 TCP 报文的 ACK 应答时，传输层会释放原始的<code>sk_buff</code>。</p>
</blockquote>
<p>（1）首先，应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 <code>sk_buff</code>内存，<strong>将用户待发送的数据拷贝到 <code>sk_buff</code> 内存，并将其加入到发送缓冲区</strong>。</p>
<p>（2）接下来，网络协议栈从 Socket 发送缓冲区中取出<code>sk_buff</code>，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理。</p>
<p><strong>（3）如果使用的是 TCP 传输协议发送数据，那么先拷贝一个新的 <code>sk_buff</code> 副本 ，这是因为 <code>sk_buff</code>后续在调用网络层，最后到达网卡发送完成的时候，这个<code>sk_buff</code>会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK  之前，这个<code>sk_buff</code>不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是<code>sk_buff</code>的一个拷贝，等收到 ACK 再真正删除。</strong></p>
<p>（4）接着，对<code>sk_buff</code> 填充 TCP 头。这里提一下，<code>sk_buff</code>可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。</p>
<blockquote>
<p>为了在层级之间传递数据时不发生拷贝，只用<code>sk_buff</code> 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 <code>sk_buff</code> 中 <code>data</code> 的指针，比如：</p>
<ul>
<li>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb-&gt;data 的值，来逐步剥离协议首部。</li>
<li>当要发送报文时，创建 <code>sk_buff</code> 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb-&gt;data 的值来增加协议首部。</li>
</ul>
</blockquote>
<p>（5）然后交给网络层，在网络层里会做这些工作：选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。处理完这些工作后会交给网络接口层处理。</p>
<p>（6）网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对<code>sk_buff</code> 填充帧头和帧尾，接着将 <code>sk_buff</code> 放到网卡的发送队列中。</p>
<p>（7）这一些工作准备好后，会触发「软中断」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取<code>sk_buff</code>，将这个<code>sk_buff</code>挂到 RingBuffer 中，接着将<code>sk_buff</code>数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。</p>
<p>（8）当数据发送完成以后，其实工作并没有结束，因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存，主要是释放<code>sk_buff</code> 内存和清理 RingBuffer 内存。</p>
<p>（9）最后，当收到这个 TCP 报文的 ACK 应答时，传输层就会释放原始的<code>sk_buff</code>。</p>
<blockquote>
<ul>
<li>发送网络数据的时候，涉及几次内存拷贝操作？</li>
</ul>
<p>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 <code>sk_buff</code> 内存，将用户待发送的数据拷贝到 <code>sk_buff</code> 内存，并将其加入到发送缓冲区。</p>
<p>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 <code>sk_buff</code> 都会被克隆一个新的副本出来。副本 <code>sk_buff</code>  会被送往网络层，等它发送完的时候就会释放掉，然后原始的 <code>sk_buff</code> 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的  ACK 时，才会释放原始的 <code>sk_buff</code> 。</p>
<p>第三次，当 IP 层发现 <code>sk_buff</code> 大于 MTU 时才需要进行。会再申请额外的 <code>sk_buff</code>，并将原来的 <code>sk_buff</code> 拷贝为多个小的 <code>sk_buff</code>。</p>
</blockquote>
<h3 id="技术补充"><a href="#技术补充" class="headerlink" title="技术补充"></a>技术补充</h3><h4 id="（1）DMA（Direct-Memory-Access）"><a href="#（1）DMA（Direct-Memory-Access）" class="headerlink" title="（1）DMA（Direct Memory Access）"></a>（1）DMA（Direct Memory Access）</h4><p>一种内存访问技术，允许某些电脑内部的硬件子系统（电脑外设）可以独立地直接读写系统内存，而不需要中央处理器（CPU）介入处理。</p>
<ol>
<li>传统CPU存取数据</li>
</ol>
<p>CPU 不直接存取外设的原因：</p>
<ul>
<li>CPU 的工作速度和外设的工作速度差距太大；</li>
<li>外设格式种类繁多，无法直接存取，需要经过转换</li>
</ul>
<p>基于上述原因，CPU 不能直接从外设获取或者向外设写入内容。传统CPU 获取数据的步骤如下：</p>
<blockquote>
<p>1、CPU 将外设数据加载到内存（和CPU的处理速度最接近）</p>
<p>2、CPU 检查 cache 是否有自己需要的数据（是否命中）</p>
<p>3、如果命中，直接返回数据；如未命中，继续从内存获取（这里暂时不考虑MMU）</p>
<p>4、返回数据</p>
</blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405281501833.png" alt="img" style="zoom:50%;" />

<ol start="2">
<li>DMA</li>
</ol>
<p>由上面CPU 读取数据来看，无论是将外设数据搬移到内存，还是从内存读取数据，都需要CPU 的参与。为了让 CPU 能够专注于处理手中事务，DMA 将负责数据的搬移工作。</p>
<p>DMA（Direct Memory Access）即直接存储器访问，借助内部的控制器来实现内存和外设之间的数据传输。有了DMA，CPU 可以专注于内存数据的存取；数据的搬运过程完全可以交由DMA硬件完成。有了DMA以后，不代表完全不需要CPU了，只是不会像中断那样频繁向CPU发送请求。</p>
<img src="https://img-blog.csdnimg.cn/57fc82764f3c4ca9b45bef7d402a083a.png" alt="img" style="zoom:50%;" />

<h4 id="（2）ksoftirqd内核线程"><a href="#（2）ksoftirqd内核线程" class="headerlink" title="（2）ksoftirqd内核线程"></a>（2）ksoftirqd内核线程</h4><p><a target="_blank" rel="noopener" href="https://www.kerneltravel.net/blog/2020/ksoftirqd_ljr/">Linux内核网络中的软中断ksoftirqd</a></p>
<p>当执行到网卡通过硬件中断（IRQ）通知CPU，告诉它有数据来了，CPU会根据中断表，调用已经注册的中断函数，这个中断函数会调到驱动程序（NIC Driver）中相应的函数。驱动先禁用网卡的中断，表示驱动程序已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知CPU了，这样可以提高效率，避免CPU不停的被中断。</p>
<p>由于硬中断处理程序执行的过程中不能被中断，所以如果它执行时间过长，会导致CPU没法响应其它硬件的中断，于是内核引入软中断，这样可以将硬中断处理函数中耗时的部分移到软中断处理函数里面来慢慢处理。内核中的<code>ksoftirqd</code>进程专门负责软中断的处理，当它收到软中断后，就会调用相应软中断所对应的处理函数，网卡驱动模块抛出的软中断，<code>ksoftirqd</code>会调用网络模块的<code>net_rx_action</code>函数。</p>
<p>中断是一种异步的事件处理机制，用来提高系统的并发处理能力。中断事件发生，会触发执行中断处理程序，而中断处理程序被分为上半部和下半部这两个部分。上半部对应硬中断，用来快速处理中断；下半部对应软中断，用来异步处理上半部未完成的工作。Linux 中的软中断包括网络收发、定时、调度、RCU 锁等各种类型，我们可以查看 proc 文件系统中的 <code>/proc/softirqs</code>  ，观察软中断的运行情况。在 Linux 中，每个 CPU 都对应一个软中断内核线程，名字是 <code>ksoftirqd/CPU </code>编号。当软中断事件的频率过高时，内核线程也会因为 CPU 使用率过高而导致软中断处理不及时，进而引发网络收发延迟、调度缓慢等性能问题。</p>
<h4 id="（3）NAPI机制分析"><a href="#（3）NAPI机制分析" class="headerlink" title="（3）NAPI机制分析"></a>（3）NAPI机制分析</h4><h1 id="二、HTTP篇"><a href="#二、HTTP篇" class="headerlink" title="二、HTTP篇"></a>二、HTTP篇</h1><blockquote>
<p>HTTP 是一个用于在<strong>服务器和服务器之间</strong>，或<strong>服务器和本地浏览器之间</strong>传输文字、图片、音频和视频等超文本数据的规范和约定。</p>
</blockquote>
<h2 id="6、HTTP是什么？"><a href="#6、HTTP是什么？" class="headerlink" title="6、HTTP是什么？"></a>6、HTTP是什么？</h2><p>HTTP是超文本传输协议，也就是<code>HyperText Transfer Protocol</code>。</p>
<p>「超文本」：文字、图片和视频等的混合体。其本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现出来的就是一个有文字、有画面的网页了。</p>
<h2 id="7、HTTP的常见状态码有哪些？"><a href="#7、HTTP的常见状态码有哪些？" class="headerlink" title="7、HTTP的常见状态码有哪些？"></a>7、HTTP的常见状态码有哪些？</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291014235.png" alt="HTTP常见状态码"></p>
<h2 id="8、HTTP的常见字段有哪些？"><a href="#8、HTTP的常见字段有哪些？" class="headerlink" title="8、HTTP的常见字段有哪些？"></a>8、HTTP的常见字段有哪些？</h2><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291021674.png" alt="HTTP常见字段"></p>
<h2 id="9、Get-与-Post"><a href="#9、Get-与-Post" class="headerlink" title="9、Get 与 Post"></a>9、Get 与 Post</h2><p><strong>GET 的语义是从服务器获取指定的资源</strong>。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。GET 方法是安全、幂等、可被缓存的。</p>
<p><strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>。POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。POST 不安全，不幂等，（大部分实现）不可缓存。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291431547.png" alt="GET 请求"></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291431269.png" alt="POST 请求"></p>
<h2 id="10、HTTP缓存技术"><a href="#10、HTTP缓存技术" class="headerlink" title="10、HTTP缓存技术"></a>10、HTTP缓存技术</h2><blockquote>
<p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p>
<p>强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存。决定是否使用缓存的主动性在于浏览器这边。基于两个HTTP响应头部字段实现：Cache-Control和Expires。</p>
<p>协商缓存指的是与服务端协商之后，通过协商结果来判断是否使用本地缓存。涉及304状态码。基于两种头部来实现，一种是请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段，另一种是请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段。注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p>
</blockquote>
<h3 id="（1）强制缓存"><a href="#（1）强制缓存" class="headerlink" title="（1）强制缓存"></a>（1）强制缓存</h3><p>下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291035054.png" alt="img"></p>
<p>强缓存利用下面两个HTTP响应头部字段实现：</p>
<ul>
<li><code>Cache-Control</code>， 是一个相对时间，优先级较高；</li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
<h3 id="（2）协商缓存"><a href="#（2）协商缓存" class="headerlink" title="（2）协商缓存"></a>（2）协商缓存</h3><p>当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 <code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</p>
<p>协商缓存的过程如下：</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png" alt="img" style="zoom:50%;" />

<p>协商缓存可以基于两种头部来实现。</p>
<p>第一种：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现，这两个字段的意思是：</p>
<ul>
<li>响应头部中的 <code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li>
<li>请求头部中的 <code>If-Modified-Since</code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有  If-Modified-Since，则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP  200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li>
</ul>
<p>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段，这两个字段的意思是：</p>
<ul>
<li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li>
<li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li>
</ul>
<p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291109906.png" alt="img"></p>
<p><strong>当使用 ETag 字段实现的协商缓存的过程：</strong></p>
<ul>
<li><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</p>
</li>
<li><p>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：</p>
<ul>
<li>如果没有过期，则直接使用本地缓存；</li>
<li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</li>
</ul>
</li>
<li><p>服务器再次收到请求后，</p>
<p>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：</p>
<ul>
<li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li>
<li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>
</ul>
</li>
<li><p>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</p>
</li>
</ul>
<h2 id="11、HTTP-与-HTTPS-有哪些区别？"><a href="#11、HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="11、HTTP 与 HTTPS 有哪些区别？"></a>11、HTTP 与 HTTPS 有哪些区别？</h2><blockquote>
<ul>
<li>TTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li>两者的默认端口不一样，HTTP 默认端口号是 <code>80</code>，HTTPS 默认端口号是 <code>443</code>。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
</blockquote>
<h2 id="12、HTTPS-解决了-HTTP-的哪些问题？"><a href="#12、HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="12、HTTPS 解决了 HTTP 的哪些问题？"></a>12、HTTPS 解决了 HTTP 的哪些问题？</h2><blockquote>
<p>HTTP 存在三个风险：1）窃听风险；2）篡改风险；3）冒充风险。</p>
<p>HTTPS 通过在 HTTP 与 TCP 之间加入<code>SLL/TLS</code>协议，解决上述风险，具体实现如下：</p>
<p>1、<strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</p>
<p>2、<strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</p>
<p>3、将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</p>
</blockquote>
<p>HTTP 存在三个风险：<strong>1）窃听风险；2）篡改风险；3）冒充风险。</strong></p>
<p>HTTPS 通过在 HTTP 与 TCP 之间加入<code>SLL/TLS</code>协议，解决上述风险，具体实现如下：</p>
<blockquote>
<p>1、<strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291122854.png" alt="混合加密" style="zoom:80%;" />

<blockquote>
<ol>
<li><strong>对称加密 vs. 非对称加密：</strong></li>
</ol>
<ul>
<li><strong>对称加密：</strong> 在对称加密中，加密和解密使用相同的密钥。发送方和接收方必须共享同一个密钥，这种密钥的管理相对简单，但存在密钥分发和安全性的挑战。</li>
<li><strong>非对称加密：</strong> 非对称加密使用一对密钥，公钥和私钥。公钥用于加密数据，私钥用于解密数据。发送方可以使用接收方的公钥加密数据，只有接收方拥有相应的私钥才能解密数据。</li>
</ul>
<ol start="2">
<li><strong>哈希散列算法：</strong></li>
</ol>
<ul>
<li><strong>哈希散列算法不是加密算法：</strong> 哈希散列算法是一种单向函数，它将任意长度的输入转换为固定长度的输出，称为哈希值。哈希算法是不可逆的，即无法从哈希值还原出原始输入。因此，哈希散列算法不属于加密算法，而是用于数据完整性验证、数字签名等领域。</li>
</ul>
</blockquote>
<p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p>
<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」方式加密明文数据。</li>
</ul>
<p>采用「混合加密」的方式的原因：</p>
<ul>
<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>
</ul>
<blockquote>
<p>2、<strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291125568.png" alt="img"></p>
<p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。为了避免这种情况，计算机里会用<strong>非对称加密算法</strong>来解决，共有两个密钥：</p>
<ul>
<li>一个是公钥，这个是可以公开给所有人的；</li>
<li>一个是私钥，这个必须由本人管理，不可泄露。</li>
</ul>
<p>这两个密钥可以<strong>双向加解密</strong>的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。</p>
<p>流程的不同，意味着目的也不相同：</p>
<ul>
<li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li>
<li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li>
</ul>
<p>一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。</p>
<p>所以非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p>
<blockquote>
<p>3、将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</p>
</blockquote>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="数子证书工作流程" style="zoom: 80%;" />

<h2 id="13、HTTPS-是如何建立连接的？其间交互了什么？"><a href="#13、HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="13、HTTPS  是如何建立连接的？其间交互了什么？"></a>13、HTTPS  是如何建立连接的？其间交互了什么？</h2><p>SSL&#x2F;TLS协议基本流程：</p>
<ol>
<li><p>TLS 的「握手阶段」（根据不同的密钥算法，有不同的握手流程）</p>
<ul>
<li><p>客户端向服务器索要并验证服务器的公钥；</p>
</li>
<li><p>双方协商产生「会话秘钥」；</p>
</li>
</ul>
</li>
<li><p>通信阶段</p>
<ul>
<li>采用「会话秘钥」进行通信。</li>
</ul>
</li>
</ol>
<p>常见的密钥交换算法：<code>RSA</code>算法和<code>ECDHE</code>算法。</p>
<p>以<code>RSA</code>算法为例，展示TLS握手流程（<strong>四次握手</strong>）：</p>
<p>注意：<strong>服务器和客户端通过三个随机数（Client Random、Server Random、pre-master key），以及双方协商的加密算法，<em>各自</em>生成本次通信的「会话秘钥」</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405301058385.jpeg" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p>
<h2 id="14、HTTPS-一定安全可靠吗？"><a href="#14、HTTPS-一定安全可靠吗？" class="headerlink" title="14、HTTPS 一定安全可靠吗？"></a>14、HTTPS 一定安全可靠吗？</h2><h4 id="（1）HTTPS一定安全可靠吗，如果有假基站获取了转发全部信息的作用，这样是不是假基站就获取到了全部信息，从而造成信息泄露？"><a href="#（1）HTTPS一定安全可靠吗，如果有假基站获取了转发全部信息的作用，这样是不是假基站就获取到了全部信息，从而造成信息泄露？" class="headerlink" title="（1）HTTPS一定安全可靠吗，如果有假基站获取了转发全部信息的作用，这样是不是假基站就获取到了全部信息，从而造成信息泄露？"></a>（1）HTTPS一定安全可靠吗，如果有假基站获取了转发全部信息的作用，这样是不是假基站就获取到了全部信息，从而造成信息泄露？</h4><blockquote>
<p>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。</p>
</blockquote>
<p>这个问题的场景是这样的：客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.png" alt="img" style="zoom:50%;" />



<p>从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。那么中间人就可以解开浏览器发起的 HTTPS  请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS  请求和响应的数据。</p>
<p>但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291132705.png" alt="img"></p>
<p>所以，<strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p>
<h4 id="（2）为什么抓包工具能截取-HTTPS-数据？"><a href="#（2）为什么抓包工具能截取-HTTPS-数据？" class="headerlink" title="（2）为什么抓包工具能截取 HTTPS 数据？"></a>（2）为什么抓包工具能截取 HTTPS 数据？</h4><blockquote>
<p>抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，就会认为这个证书是有效的。</p>
</blockquote>
<p>很多抓包工具 之所以可以明文看到 HTTPS 数据，工作原理与中间人一致。</p>
<p>对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:</p>
<ol>
<li>中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；</li>
<li>中间人，作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；</li>
</ol>
<p>中间人要拿到私钥只能通过如下方式：</p>
<ol>
<li>去网站服务端拿到私钥；</li>
<li>去CA处拿域名签发私钥；</li>
<li>自己签发证书，切要被浏览器信任；</li>
</ol>
<p>不用解释，抓包工具只能使用第三种方式取得中间人的身份。使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。</p>
<p>抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。</p>
<h4 id="（3）如何避免被中间人抓取数据？"><a href="#（3）如何避免被中间人抓取数据？" class="headerlink" title="（3）如何避免被中间人抓取数据？"></a>（3）如何避免被中间人抓取数据？</h4><blockquote>
<p>1、不要点击任务证书非法的网站；</p>
<p>2、通过 HTTPS 双向认证来避免，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</p>
</blockquote>
<p>我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样 HTTPS 数据就不会被中间人截取到了。</p>
<p>当然，我们还可以通过 <strong>HTTPS 双向认证</strong>来避免这种问题。一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。<strong>如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</strong></p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291145819.png" alt="img"></p>
<h2 id="15、HTTP-1-1"><a href="#15、HTTP-1-1" class="headerlink" title="15、HTTP&#x2F;1.1"></a>15、HTTP&#x2F;1.1</h2><blockquote>
<p>优点：</p>
<ol>
<li>简单</li>
<li>灵活和易于拓展</li>
<li>应用广泛和跨平台</li>
</ol>
<p>缺点：</p>
<ol>
<li>无状态</li>
<li>明文传输</li>
<li>不安全</li>
</ol>
<p>性能：</p>
<ol>
<li>长连接</li>
<li>管道网络传输</li>
</ol>
</blockquote>
<p><strong>优点：</strong></p>
<ol>
<li><p>简单</p>
<p>基本的报文格式是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式。</p>
</li>
<li><p>灵活和易于拓展</p>
<p>HTTP 协议里的各类请求方法、URI&#x2F;URL、状态码和头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</p>
<p>同时 HTTP 由于是工作在应用层（ <code>OSI</code> 第七层），其<strong>下层可以随意变化</strong>，比如：</p>
<ul>
<li>HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL&#x2F;TLS 安全传输层；</li>
<li>HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 传输协议使用的是 TCP 协议，而到了 HTTP&#x2F;3.0 传输协议改用了 UDP 协议。</li>
</ul>
</li>
<li><p>应用广泛和跨平台</p>
</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><p>无状态</p>
<p>HTTP协议本身是无状态的，也就是说每个请求之间是相互独立的，服务器不会在不同请求之间保留任何关于客户端请求的状态信息。这意味着<strong>每个HTTP请求都是独立的，服务器不会记住之前的请求或会话信息。</strong></p>
<p>对于无状态的问题，解法方案有很多种，其中比较简单的方式用 <strong>Cookie</strong> 技术。</p>
<p><code>Cookie</code> 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291443907.png" alt="Cookie 技术"></p>
</li>
<li><p>明文传输</p>
</li>
<li><p>不安全</p>
</li>
</ol>
<p><strong>性能：</strong></p>
<ol>
<li><p>长连接：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。如果某个 HTTP 长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291444931.png" alt="短连接与长连接"></p>
</li>
<li><p>管道网络传输：在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong>但是<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。所以，<strong>HTTP&#x2F;1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291445813.png" alt="管道网络传输"></p>
</li>
</ol>
<blockquote>
<p><strong>注意</strong></p>
<p>实际上 HTTP&#x2F;1.1 管道化技术不是默认开启，而且浏览器基本都没有支持，所以<strong>后面所有文章讨论 HTTP&#x2F;1.1 都是建立在没有使用管道化的前提</strong>。大家知道有这个功能，但是没有被使用就行了。</p>
</blockquote>
<ol start="3">
<li><p>队头阻塞：当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291447597.png" alt="队头阻塞"></p>
</li>
</ol>
<h2 id="16、HTTP-2"><a href="#16、HTTP-2" class="headerlink" title="16、HTTP&#x2F;2"></a>16、HTTP&#x2F;2</h2><blockquote>
<p>HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p>
<ol>
<li>头部压缩</li>
<li>二进制格式</li>
<li>并发传输</li>
<li>服务器主动推送资源</li>
</ol>
<p>但其缺陷在于：HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</p>
</blockquote>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/25-HTTP2.png" alt="HTT/1 ~ HTTP/2" style="zoom:80%;" />

<ol>
<li><p>头部压缩</p>
<p>HTTP&#x2F;2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p>
<p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p>
</li>
<li><p>二进制格式</p>
<p>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291449629.png" alt="HTTP/1 与 HTTP/2 "></p>
<p>比如状态码 200 ，在 HTTP&#x2F;1.1 是用 ‘2’’0’’0’ 三个字符来表示（二进制：00110010 00110000 00110000），共用了 3 个字节，如下图</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291450660.png" alt="img"></p>
<p>在 HTTP&#x2F;2 对于状态码 200 的二进制编码是 10001000，只用了 1 字节就能表示，相比于 HTTP&#x2F;1.1 节省了 2 个字节，如下图：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291450575.png" alt="img"></p>
</li>
<li><p>并发传输</p>
<p>引入了 Stream 概念，多个 Stream 复用在一条 TCP 连接。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291452845.png" alt="img"></p>
<p>1 个 TCP 连接包含多个 Stream，1个Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP&#x2F;1  中的请求或响应，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP&#x2F;2  最小单位，以二进制压缩格式存放 HTTP&#x2F;1 中的内容（头部和包体）。</p>
<p><strong>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP  消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应</strong>。</p>
<p>比如下图，服务端<strong>并行交错地</strong>发送了两个响应： Stream 1 和 Stream 3，这两个 Stream 都是跑在一个 TCP 连接上，客户端收到后，会根据相同的 Stream ID 有序组装成 HTTP 消息。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291453175.jpeg" alt="img"></p>
</li>
<li><p>服务器主动推送资源</p>
<p>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p>
<p>比如下图，Stream 1 是客户端向服务端请求的资源，属于客户端建立的 Stream，所以该 Stream 的 ID 是奇数（数字  1）；Stream 2 和 4 都是服务端主动向客户端推送的资源，属于服务端建立的 Stream，所以这两个 Stream 的 ID  是偶数（数字 2 和 4）。</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291453212.png" alt="img"></p>
<p>HTTP&#x2F;2的仍旧存在“队头阻塞”问题，但是问题不是在HTTP层面，而是在TCP层面。</p>
<p><strong>HTTP&#x2F;2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP  层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1  个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2  应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</strong></p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291455599.jpeg" alt="img" style="zoom:67%;" />

<p>举个例子，如下图：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291455330.gif" alt="img"></p>
</li>
</ol>
<h2 id="17、HTTP-3"><a href="#17、HTTP-3" class="headerlink" title="17、HTTP&#x2F;3"></a>17、HTTP&#x2F;3</h2><blockquote>
<p>为了解决HTTP&#x2F;2的队头阻塞问题，HTTP&#x2F;3将下层的TCP协议修改成了UDP协议。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405291456442.jpeg" alt="HTTP/1 ~ HTTP/3"></p>
<p>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP&#x2F;2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p>
<p>QUIC 有以下 3 个特点。</p>
<ul>
<li>无队头阻塞</li>
<li>更快的连接建立</li>
<li>连接迁移</li>
</ul>
<p>1、无队头阻塞</p>
<p>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p>
<p>QUIC 有自己的一套机制可以保证传输的可靠性的。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>，这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/quic%E6%97%A0%E9%98%BB%E5%A1%9E.jpeg" alt="img" style="zoom: 67%;" />

<p>2、更快的连接建立</p>
<p>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p>
<p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。此外，HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS&#x2F;1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.png" alt="TCP HTTPS（TLS/1.3） 和 QUIC HTTPS "></p>
<p>3、连接迁移</p>
<p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309231026577.png" alt="TCP 四元组" style="zoom:50%;" />

<p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p>
<p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p>
<p><strong>所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</strong></p>
<p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而  QUIC 是基于 UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。HTTP&#x2F;3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。</p>
<h2 id="18、HTTP-1-1-该如何优化？"><a href="#18、HTTP-1-1-该如何优化？" class="headerlink" title="18、HTTP&#x2F;1.1 该如何优化？"></a>18、HTTP&#x2F;1.1 该如何优化？</h2><blockquote>
<p><strong>HTTP&#x2F;1.1 如何优化&#x2F;大量网络请求如何优化？</strong></p>
<p>第一个思路是，通过缓存技术来避免具有重复性的 HTTP 请求。客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带资源的 304 响应，告诉客户端缓存的响应仍然有效。</p>
<p>第二个思路是，减少 HTTP 请求的次数，有以下方法：</p>
<ol>
<li>将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数；</li>
<li>将多个小资源合并成一个大资源再传输，减少 HTTP 请求次数以及头部的重复传输，以及减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗；</li>
<li>按需访问资源，只访问当前用户看得到&#x2F;用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数。</li>
</ol>
<p>第三个思路是，通过压缩响应资源，降低传输资源的大小，从而提高传输效率，所以应当选择更优秀的压缩算法。</p>
</blockquote>
<ol>
<li><p>对于一些具有重复性的HTTP请求，可以考虑将这对「请求-响应」的数据<strong>缓存在本地</strong>，这样在下一次就可以直接读取本地的数据，不必再通过网络获取服务器响应了。</p>
<ul>
<li>具体来说，客户端会把第一次请求以及响应的数据以key-value的形式保存在本地磁盘上，其中请求的URL为key，响应为数据。当后续发起相同请求时，就可以先在本地磁盘上进行查询和读取。</li>
<li>客户端在重新发送请求时，会在请求的<code>Etag</code>头部带上第一次请求的响应头部中的摘要，作为唯一标识响应的资源。服务器收到该请求时，会将本地资源的摘要与请求中的摘要进行对比：<ul>
<li>若相同，则返回<code>304</code>状态码，告诉客户端该缓存仍有效；</li>
<li>若不同，则返回最新的资源。</li>
</ul>
</li>
</ul>
</li>
<li><p>减少HTTP请求可以从以下三方面入手：</p>
<ol>
<li>减少重定向请求次数。<ul>
<li>重定向请求是指当服务器的某个资源从url1转移到url2后，对于不知情的客户端来说，它将继续请求url1，这时服务器将返回<code>302</code>状态码和<code>Location</code>头部，告诉客户端资源已经转移到url2了，于是客户端再重新发送url2请求以获取资源。</li>
<li>重定向请求越多，客户端发起的HTTP请求就越多；此外，若通过「客户端-代理服务器-服务器」来传送资源，客户端与服务器之间需要进行2次消息传递。以上做法无疑将大大降低网络性能。</li>
<li>因此，如果<strong>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了</strong>。</li>
</ul>
</li>
<li>合并请求。<ul>
<li>将多个访问小文件的请求合并成一个大的请求。这样虽然传输的总资源大小不变，但减少了重复发送的HTTP头部。</li>
<li>此外，由于HTTP&#x2F;1.1是请求响应模型，为了防止单个请求的阻塞，一般浏览器会同时发送5-6个请求，每个请求都是不同的TCP连接。若能够合并请求，将减少TCP连接的数量，并省去TCP握手和慢启动过程耗费的时间。</li>
</ul>
</li>
<li>延迟发送请求。<ul>
<li>对于资源进行<strong>按需获取</strong>。比如请求网页时，没必要一次性获取全部资源，而是只获取用户所看到的页面资源，当用户向下滑动页面时再向服务器接着获取，从而达到延迟发送请求的效果。</li>
</ul>
</li>
</ol>
</li>
<li><p>通过压缩的方式减少HTTP响应的数据大小。</p>
<ul>
<li><p>无损压缩。</p>
<ul>
<li>指资源经过压缩后信息不被破坏，还能完全恢复到压缩前的原样。适用于文本文件、程序可执行文件和程序源代码等。</li>
<li>在请求字段中通过<code>Accept-Encoding</code>告知服务器客户端支持的压缩算法；在响应头部中通过<code>Content-Encoding</code>字段告诉客户端服务器采用的压缩算法。</li>
<li>常见算法：<code>gzip</code>、<code>Brotli</code></li>
</ul>
</li>
<li><p>有损压缩。</p>
<ul>
<li><p>将次要的数据合并，牺牲一些质量来减少数据量、提高压缩比。适用于多媒体数据，如音频、视频和图片等。</p>
</li>
<li><p>在请求字段中通过<code>Accept</code>字段里的「 q 质量因子」，告诉服务器期望的资源质量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: audio/*; q=0.2, audio/basic</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="19、HTTPS-RSA-握手解析"><a href="#19、HTTPS-RSA-握手解析" class="headerlink" title="19、HTTPS RSA 握手解析"></a>19、HTTPS RSA 握手解析</h2><blockquote>
<p>传统的TLS握手采用RSA算法实现密钥交换。在将TLS证书部署服务器端时，证书文件其实就是服务器端的公钥，会在TLS握手阶段传递给客户端。而服务器端的私钥则一直留在服务器端，并确保其不被窃取。</p>
<p>在RSA密钥协商算法中，客户端会生成随机密钥，并使用服务器端的公钥加密后传给服务器端。根据非对称加密算法，公钥加密的信息仅能通过similarity解密，这样服务器端解密后，双方就得到了相同的密钥，再用这个密钥来加密应用信息。</p>
<p><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。为了解决这个问题，后面就出现了 ECDHE 密钥协商算法。</p>
<p>包含四次握手过程：</p>
<ul>
<li><strong>第一次握手</strong></li>
<li>客户端发送「<strong>Client Hello</strong>」，包含<ul>
<li>1）LS版本号；</li>
<li>2）支持的密码套件列表；</li>
<li>3）生成的随机数<strong>Client Random</strong>。</li>
</ul>
</li>
<li><strong>第二次握手</strong></li>
<li>服务器端返回「<strong>Server Hello</strong>」，包含<ul>
<li>1）确认的TLS版本号；</li>
<li>2）从密码套件列表中选择的密码套件；</li>
<li>3）生成的随机数<strong>Server Random</strong>。</li>
</ul>
</li>
<li>服务器端发送「<strong>Server Certificate</strong>」，包含数字证书；</li>
<li>服务器端发送「<strong>Server Hello Done</strong>」，表明自己本次发送完毕。</li>
<li><strong>第三次握手</strong></li>
<li>客户端发送「<strong>Client Key Exchange</strong>」；</li>
<li>双方根据已经得到的三个随机数（<strong>Client Random、Server Random、pre-master</strong>），生成<strong>会话密钥（Master Secret）</strong>；</li>
<li>客户端发送「<strong>Change Cipher Spec</strong>」，告诉服务器端开始使用加密方式发送消息；</li>
<li>客户端再发送「<strong>Encrypted Handshake Message（Finishd）</strong>」；</li>
<li><strong>第四次握手</strong>：</li>
<li>服务器也是同样的操作，发送「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」；如果双方都验证加密和解密没问题，那么握手正式完成。</li>
</ul>
</blockquote>
<p><code>RSA</code>算法需要经过四次握手，也就是<code>2</code>个RTT的时延。由于HTTPS是应用层协议，因此需要先完成TCP连接建立，再完成TLS握手过程，才能建立通信安全的连接。</p>
<ul>
<li><p><strong>第一次握手</strong></p>
<ul>
<li>客户端发送「<strong>Client Hello</strong>」，包含<ul>
<li>1）LS版本号；</li>
<li>2）支持的密码套件列表；</li>
<li>3）生成的随机数<strong>Client Random</strong>；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>第二次握手</strong></p>
<ul>
<li><p>服务器端返回「<strong>Server Hello</strong>」，包含</p>
<ul>
<li>1）确认的TLS版本号；</li>
<li>2）从密码套件列表中选择的密码套件；</li>
<li>3）生成的随机数<strong>Server Random</strong>；</li>
</ul>
</li>
<li><p>服务器端发送「<strong>Server Certificate</strong>」，包含数字证书</p>
<ul>
<li><p>数字证书中包含以下信息：公钥、持有者信息、证书认证机构（CA）的信息、CA 对这份文件的数字签名及使用的算法、证书有效期，以及一些其他的额外信息；</p>
</li>
<li><p>证书由CA（Certificate Authority，证书认证机构）签名，签发和认证流程如下，主要涉及1）Hash算法；2）CA私钥加密，CA公钥解密：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405301235768.png" alt="img"></p>
</li>
</ul>
<blockquote>
<p><strong>CA 签发证书</strong>的过程，如上图左边部分：</p>
<ul>
<li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li>
<li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li>
<li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li>
</ul>
<p><strong>客户端校验服务端的数字证书</strong>的过程，如上图右边部分：</p>
<ul>
<li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li>
<li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li>
<li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li>
</ul>
</blockquote>
</li>
<li><p>服务器端发送「<strong>Server Hello Done</strong>」，表明自己本次发送完毕</p>
</li>
</ul>
</li>
<li><p><strong>第三次握手</strong></p>
<ul>
<li>客户端发送「<strong>Client Key Exchange</strong>」，包含新生成的随机数<strong>pre-master</strong>，并由服务器的 RSA 公钥加密；</li>
<li>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (<strong>pre-master</strong>)；</li>
<li>双方根据已经得到的三个随机数（<strong>Client Random、Server Random、pre-master</strong>），生成<strong>会话密钥（Master Secret）</strong>，它是对称密钥，用于对后续的 HTTP 请求&#x2F;响应的数据加解密；</li>
<li>客户端发送「<strong>Change Cipher Spec</strong>」，告诉服务器端开始使用加密方式发送消息；</li>
<li>客户端再发送「<strong>Encrypted Handshake Message（Finishd）</strong>」消息，把之前所有发送的数据做个<strong>摘要</strong>，再用会话密钥（<strong>Master Secret</strong>）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。</li>
</ul>
</li>
<li><p><strong>第四次握手</strong></p>
<ul>
<li>服务器也是同样的操作，发送「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息；</li>
<li>如果双方都验证加密和解密没问题，那么握手正式完成。</li>
</ul>
</li>
</ul>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/tls%E6%8F%A1%E6%89%8B.png" alt="img" style="zoom: 67%;" />

<h2 id="20、HTTPS-ECDHE-握手解析"><a href="#20、HTTPS-ECDHE-握手解析" class="headerlink" title="20、HTTPS ECDHE 握手解析"></a>20、HTTPS ECDHE 握手解析</h2><blockquote>
<p>算法演进：DH -&gt; DHE -&gt; DCDHE</p>
</blockquote>
<p>（1）DH算法</p>
<p>核心数学思想：离散对数。离散对数的概念如下图：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405301449682.png" alt="img" style="zoom:67%;" />

<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202405301537291.png" alt="image-20240530153742715"></p>
<p>四次握手过程：</p>
<ul>
<li><strong>第一次握手</strong><ul>
<li>客户端发送「<strong>Client Hello</strong>」，包含<ul>
<li>1）LS版本号；</li>
<li>2）支持的密码套件列表；</li>
<li>3）生成的随机数<strong>Client Random</strong>；</li>
</ul>
</li>
</ul>
</li>
<li><strong>第二次握手</strong><ul>
<li>服务器端返回「<strong>Server Hello</strong>」，包含<ul>
<li>1）确认的TLS版本号；</li>
<li>2）从密码套件列表中选择的密码套件；</li>
<li>3）生成的随机数<strong>Server Random</strong>；</li>
</ul>
</li>
<li>服务器端发送「<strong>Server Certificate</strong>」，包含数字证书</li>
<li>服务器端发送「<strong>Server Hello Done</strong>」，包含<ul>
<li>选择<strong>椭圆曲线</strong>，选好了椭圆曲线相当于椭圆曲线<strong>基点 G</strong> 也定好了，这些都会公开给客户端；</li>
<li>生成随机数作为服务端椭圆曲线的私钥，保留到本地；</li>
<li>根据基点 G 和私钥计算出<strong>服务端的椭圆曲线公钥</strong>，这个会公开给客户端。</li>
</ul>
</li>
<li>服务器端发送「<strong>Server Key Exchange</strong>」，表明自己本次发送完毕</li>
</ul>
</li>
<li><strong>第三次握手</strong><ul>
<li>客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成<strong>客户端的椭圆曲线公钥；</strong></li>
<li>客户端发送「<strong>Client Key Exchange</strong>」；</li>
<li>双方根据已经得到的<strong>对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G</strong>，计算出点(x, y)；<strong>最终的会话密钥，就是用「客户端随机数 + 服务端随机数 +  x 」三个材料生成的</strong>。</li>
<li>客户端发送「<strong>Change Cipher Spec</strong>」，告诉服务器端开始使用加密方式发送消息；</li>
<li>客户端再发送「<strong>Encrypted Handshake Message（Finishd）</strong>」消息，把之前所有发送的数据做个<strong>摘要</strong>，再用会话密钥（<strong>Master Secret</strong>）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。</li>
</ul>
</li>
<li><strong>第四次握手</strong><ul>
<li>服务器也是同样的操作，发送「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息；</li>
<li>如果双方都验证加密和解密没问题，那么握手正式完成。</li>
</ul>
</li>
</ul>
<h2 id="21、HTTPS-如何优化？"><a href="#21、HTTPS-如何优化？" class="headerlink" title="21、HTTPS 如何优化？"></a>21、HTTPS 如何优化？</h2><blockquote>
<p>产生性能消耗的两个环节：</p>
<ul>
<li>第一个环节， TLS 协议握手过程；</li>
<li>第二个环节，握手后的对称加密报文传输。</li>
</ul>
<p>主要针对第一个环节进行优化，考虑以下方面：</p>
<ul>
<li><strong>硬件优化</strong><ul>
<li>由于HTTPS 协议是计算密集型，而不是 I&#x2F;O 密集型，因此对CPU性能进行提升，选择可以支持 AES-NI 特性的 CPU；</li>
</ul>
</li>
<li><strong>协议优化</strong><ul>
<li>用ECDHE算法替代RSA算法；</li>
<li>椭圆曲线尽量选择x25519曲线；</li>
<li>对称加密算法方面，如果对安全性需求不是特别高，可以选用 AES_128_GCM，由于密钥长度较短，比 AES_256_GCM 速度更快；</li>
</ul>
</li>
<li><strong>证书优化</strong><ul>
<li><strong>证书传输</strong>方面，选择椭圆曲线（ECDSA）证书而不是 RSA 证书，因为在相同安全强度下， ECC 密钥长度比 RSA 短的多；</li>
<li><strong>证书验证</strong>方面，采用OSCP Stapling；</li>
</ul>
</li>
<li><strong>会话复用：</strong>把首次 TLS 握手协商的对称加密密钥缓存起来，待下次需要建立 HTTPS 连接时，直接「复用」这个密钥<ul>
<li><strong>Session ID</strong>：客户端和服务器首次  TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识，Session ID 和会话密钥相当于 key-value 的关系。</li>
<li><strong>Session Ticket</strong>：服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端，类似于 HTTP 的 Cookie。客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信。</li>
</ul>
</li>
</ul>
</blockquote>
<p>TLS 协议握手过程的性能消耗：</p>
<ul>
<li>对于 ECDHE 密钥协商算法，握手过程中会客户端和服务端都需要临时生成椭圆曲线公私钥；</li>
<li>客户端验证证书时，会访问 CA 获取 CRL 或者 OCSP，目的是验证服务器的证书是否有被吊销；</li>
<li>双方计算 Pre-Master，也就是对称加密密钥；</li>
</ul>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/tls%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97.png" alt="img" style="zoom:67%;" />

<h1 id="三、TCP篇"><a href="#三、TCP篇" class="headerlink" title="三、TCP篇"></a>三、TCP篇</h1><h2 id="3-1-TCP头格式"><a href="#3-1-TCP头格式" class="headerlink" title="3.1 TCP头格式"></a>3.1 TCP头格式</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101258417.png" alt="TCP 头格式" style="zoom:50%;" />

<p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p>
<p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p>
<p><strong>控制位：</strong></p>
<ul>
<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li>
</ul>
<h2 id="3-2-什么是-TCP-？"><a href="#3-2-什么是-TCP-？" class="headerlink" title="3.2 什么是 TCP ？"></a>3.2 什么是 TCP ？</h2><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p>
<ul>
<li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP  报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP  报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li>
</ul>
<h2 id="3-3-如何唯一确定一个TCP连接？"><a href="#3-3-如何唯一确定一个TCP连接？" class="headerlink" title="3.3 如何唯一确定一个TCP连接？"></a>3.3 如何唯一确定一个TCP连接？</h2><p>通过TCP四元组确定：源地址、源端口、目的地址和目的端口。</p>
<blockquote>
<p>有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？</p>
</blockquote>
<p>服务端通常固定在某个本地端口上监听，等待客户端的连接请求。因此，客户端 IP 和端口是可变的，其理论值计算公式如下:</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230436594.png" alt="img" style="zoom: 67%;" />

<p>对 IPv4，客户端的 IP 数最多为 <code>2</code> 的 <code>32</code> 次方，客户端的端口数最多为 <code>2</code> 的 <code>16</code> 次方，也就是服务端单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方。</p>
<p>当然，服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：</p>
<ul>
<li>文件描述符限制，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：<ul>
<li><strong>系统级</strong>：当前系统可打开的最大数量，通过 <code>cat /proc/sys/fs/file-max</code> 查看；</li>
<li><strong>用户级</strong>：指定用户可打开的最大数量，通过 <code>cat /etc/security/limits.conf</code> 查看；</li>
<li><strong>进程级</strong>：单个进程可打开的最大数量，通过 <code>cat /proc/sys/fs/nr_open</code> 查看；</li>
</ul>
</li>
<li><strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。</li>
</ul>
<h2 id="3-4-TCP和UDP的区别，分别的应用场景？"><a href="#3-4-TCP和UDP的区别，分别的应用场景？" class="headerlink" title="3.4 TCP和UDP的区别，分别的应用场景？"></a>3.4 TCP和UDP的区别，分别的应用场景？</h2><h3 id="1、TCP-和-UDP-区别"><a href="#1、TCP-和-UDP-区别" class="headerlink" title="1、TCP 和 UDP 区别"></a>1、TCP 和 UDP 区别</h3><p><em><strong>1. 连接</strong></em></p>
<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p><em><strong>2. 服务对象</strong></em></p>
<ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<p><em><strong>3. 可靠性</strong></em></p>
<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP 协议实现可靠传输？</a></li>
</ul>
<p><em><strong>4. 拥塞控制、流量控制</strong></em></p>
<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<p><em><strong>5. 首部开销</strong></em></p>
<ul>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
<p><em><strong>6. 传输方式</strong></em></p>
<ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
<p><em><strong>7. 分片不同</strong></em></p>
<ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>
<h3 id="2、TCP-和-UDP-应用场景"><a href="#2、TCP-和-UDP-应用场景" class="headerlink" title="2、TCP 和 UDP 应用场景"></a>2、TCP 和 UDP 应用场景</h3><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<ul>
<li><code>FTP</code> 文件传输；</li>
<li><code>HTTP</code> &#x2F; <code>HTTPS</code>；</li>
</ul>
<p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li>
<li>视频、音频等多媒体通信；</li>
<li>广播通信；</li>
</ul>
<blockquote>
<p>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</p>
</blockquote>
<p>原因是 TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p>
<blockquote>
<p>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</p>
</blockquote>
<p>先说说 TCP 是如何计算负载数据长度：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230445811.png" alt="img" style="zoom:50%;" />

<p>其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。</p>
<p>大家这时就奇怪了问：“UDP 也是基于 IP 层的呀，那 UDP 的数据长度也可以通过这个公式计算呀？ 为何还要有「包长度」呢？”</p>
<p>这么一问，确实感觉 UDP 的「包长度」是冗余的。</p>
<p>我查阅了很多资料，我觉得有两个比较靠谱的说法：</p>
<ul>
<li>第一种说法：因为为了网络设备硬件设计和处理方便，首部长度需要是 <code>4</code> 字节的整数倍。如果去掉 UDP 的「包长度」字段，那 UDP 首部长度就不是 <code>4</code> 字节的整数倍了，所以我觉得这可能是为了补全 UDP 首部长度是  <code>4</code> 字节的整数倍，才补充了「包长度」字段。</li>
<li>第二种说法：如今的 UDP 协议是基于 IP 协议发展的，而当年可能并非如此，依赖的可能是别的不提供自身报文长度或首部长度的网络层协议，因此 UDP 报文首部需要有长度字段以供计算。</li>
</ul>
<h2 id="3-5-三次握手相关"><a href="#3-5-三次握手相关" class="headerlink" title="3.5 三次握手相关"></a>3.5 三次握手相关</h2><h3 id="1、详细说明三次握手"><a href="#1、详细说明三次握手" class="headerlink" title="1、详细说明三次握手"></a>1、详细说明三次握手</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手" style="zoom:50%;" />

<ol>
<li>服务端主动监听某个端口，处于 <code>LISTEN</code> 状态，等待客户端的连接请求；</li>
<li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态；</li>
<li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态；</li>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED</code> 状态；</li>
<li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li>
</ol>
<blockquote>
<p><strong>TIP：客户端发送三次握手（ack 报文）后就可以发送数据了，而被动方此时还是 syn_received 状态，如果 ack 丢了，那客户端发的数据是不是也白白浪费了？</strong></p>
<p>不是的，即使服务端还是在 syn_received 状态，收到了客户端发送的数据，还是可以建立连接的，并且还可以正常收到这个数据包。这是因为数据报文中是有 ack 标识位，也有确认号，这个确认号就是确认收到了第二次握手。如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%9B%B8%E5%90%8Cack.png" alt="img"></p>
<p>所以，服务端收到这个数据报文，是可以正常建立连接的，然后就可以正常接收这个数据包了。</p>
</blockquote>
<h3 id="2、为什么是三次握手？不是两次、四次？"><a href="#2、为什么是三次握手？不是两次、四次？" class="headerlink" title="2、为什么是三次握手？不是两次、四次？"></a>2、为什么是三次握手？不是两次、四次？</h3><blockquote>
<p>不使用「两次握手」和「四次握手」的原因：</p>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
<p>从以下两个原因进行分析：</p>
<p>原因一：避免历史连接，造成资源浪费；</p>
<p>原因二：同步双方初始序列号。</p>
</blockquote>
<p><strong>（1）原因一：避免历史连接，造成资源浪费</strong></p>
<p>防止已经失效的连接请求报文段突然又传到服务端，因而产生错误。</p>
<p>这种情况是：<strong>客户端发出的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到下一个连接释放以后的某个时间才到达服务器端。</strong>当服务器端收到此失效报文后，会误认为是客户端发出的一个新连接请求，于是客户端又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要服务器端发出确认报文就会认为新的连接已经建立了，但此时客户端并没有发出建立连接的请求，因此不会向服务器端发送数据。服务器端没有收到数据就会一直等待，这样就会白白浪费掉很多资源。</p>
<blockquote>
<p><strong>TIP：如果服务端在收到 RST 报文之前，先收到了「新 SYN 报文」，也就是服务端收到客户端报文的顺序是：「旧 SYN 报文」-&gt;「新 SYN 报文」，此时会发生什么?</strong></p>
<p>当服务端第一次收到 SYN 报文，也就是收到 「旧 SYN 报文」时，就会回复 <code>SYN + ACK</code> 报文给客户端，此报文中的确认号是 91（90+1）。</p>
<p>然后这时再收到「新 SYN 报文」时，就会回 <a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/challenge_ack.html">Challenge Ack</a>报文给客户端，<strong>这个 ack 报文并不是确认收到「新 SYN 报文」的，而是上一次的 ack 确认号</strong>，也就是91（90+1）。所以客户端收到此 ACK 报文时，发现自己期望收到的确认号应该是 101，而不是 91，于是就会回 RST 报文。</p>
</blockquote>
<p><strong>（2）原因二：同步双方初始序列号</strong></p>
<p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li>
</ul>
<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p>
<p>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<h3 id="3、为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#3、为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="3、为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>3、为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h3><blockquote>
<p>主要原因有两个方面：</p>
<ul>
<li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li>
<li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收。</li>
</ul>
</blockquote>
<p><strong>详述方面一：为了防止历史报文被下一个相同四元组的连接接收</strong></p>
<p>如果每次建立连接客户端和服务端的初始化序列号都「不一样」，就有大概率因为历史报文的序列号「不在」对方接收窗口，从而很大程度上避免了历史报文，相反，如果每次建立连接客户端和服务端的初始化序列号都「一样」，就有大概率遇到历史报文的序列号刚「好在」对方的接收窗口内，从而导致历史报文被新连接成功接收。</p>
<p>所以，每次初始化序列号不一样很大程度上能够避免历史报文被下一个相同四元组的连接接收，注意是很大程度上，并不是完全避免了，<strong>因为序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据</strong>，所以需要用时间戳的机制来判断历史报文。</p>
<h3 id="4、初始序列号-ISN-是如何随机产生的？"><a href="#4、初始序列号-ISN-是如何随机产生的？" class="headerlink" title="4、初始序列号 ISN 是如何随机产生的？"></a>4、初始序列号 ISN 是如何随机产生的？</h3><p>起始 <code>ISN</code> 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时。</p>
<p>RFC793 提到初始化序列号 ISN 随机生成算法：ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)。</p>
<ul>
<li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li>
<li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li>
</ul>
<p>可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。</p>
<h3 id="5、既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#5、既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="5、既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>5、既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h3><blockquote>
<p>如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，此时，<strong>如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP  层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 +  数据）」。</p>
<p>所以，为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。经过 TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片，大大增加了重传的效率。</p>
</blockquote>
<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230633447.png" alt="MTU 与 MSS" style="zoom: 67%;" />

<ul>
<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li>
<li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li>
</ul>
<p>如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，当 IP 层有一个超过 <code>MTU</code> 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上一层 TCP 传输层。</p>
<p>此时，<strong>如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP  层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 +  数据）」。</p>
<p>因此，可以得知由 IP 层进行分片传输，是非常没有效率的。</p>
<p>所以，为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230628926.png" alt="握手阶段协商 MSS"></p>
<p>经过 TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片，大大增加了重传的效率。</p>
<h3 id="6、第一次握手丢失了，会发生什么？"><a href="#6、第一次握手丢失了，会发生什么？" class="headerlink" title="6、第一次握手丢失了，会发生什么？"></a>6、第一次握手丢失了，会发生什么？</h3><blockquote>
<p>当第一次握手丢失了（SYN 丢失），客户端会重传 SYN 报文。</p>
<p>若重传 SYN 报文达到最大重传次数，还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</p>
</blockquote>
<p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 <code>SYN_SENT</code> 状态。</p>
<p>若第一次握手丢失，导致客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</p>
<p>根据不同内核的设定，超时时间也有所不同。当客户端在超时时间后依旧没收到服务端的 SYN-ACK 报文时，客户端就会重发 SYN 报文N次，在 Linux 里，客户端的 SYN 报文最大重传次数N由 <code>tcp_syn_retries</code>内核参数控制，这个参数是可以自定义的，默认值一般是 5。</p>
<p>若重发N次后还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</p>
<h3 id="7、第二次握手丢失了，会发生什么？"><a href="#7、第二次握手丢失了，会发生什么？" class="headerlink" title="7、第二次握手丢失了，会发生什么？"></a>7、第二次握手丢失了，会发生什么？</h3><blockquote>
<p>当第二次握手丢失了（SYN, ACK 报文丢失），客户端和服务端都会重传：</p>
<ul>
<li>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 <code>tcp_syn_retries</code>内核参数决定；</li>
<li>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定。</li>
</ul>
<p>当客户端超时重传 SYN 报文达到最大重传次数，再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</p>
<p>同理，当服务端超时重传 SYN-ACK 报文达到最大重传次数，再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。</p>
</blockquote>
<p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 <code>SYN_RCVD</code> 状态。</p>
<p>第二次握手的 <code>SYN-ACK</code> 报文其实有两个目的 ：</p>
<ul>
<li>第二次握手里的 ACK， 是对第一次握手的确认报文；</li>
<li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</li>
</ul>
<p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。</p>
<p>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p>
<h3 id="8、第三次握手丢失了，会发生什么？"><a href="#8、第三次握手丢失了，会发生什么？" class="headerlink" title="8、第三次握手丢失了，会发生什么？"></a>8、第三次握手丢失了，会发生什么？</h3><blockquote>
<p>当第三次握手丢失了（ACK 报文丢失），服务器端会重传 SYN-ACK 报文。</p>
<p>当服务端超时重传 SYN-ACK 报文达到最大重传次数时，再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接</p>
</blockquote>
<p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 <code>ESTABLISH</code> 状态。</p>
<p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p>
<h3 id="9、为什么ACK信号是SYN信号值-1？"><a href="#9、为什么ACK信号是SYN信号值-1？" class="headerlink" title="9、为什么ACK信号是SYN信号值+1？"></a>9、为什么ACK信号是SYN信号值+1？</h3><p>TCP（传输控制协议）的三次握手过程是建立一个可靠的连接会话的关键步骤。在这个过程中，ACK（确认）信号的值为SYN（同步）信号的值加1的原因主要是为了确认双方的接收能力和确保序列号的同步。</p>
<h3 id="10、三次握手的过程中可以携带数据吗"><a href="#10、三次握手的过程中可以携带数据吗" class="headerlink" title="10、三次握手的过程中可以携带数据吗"></a>10、三次握手的过程中可以携带数据吗</h3><p>第三次握手的时候可以携带数据，第一次和第二次握手不可以。</p>
<h3 id="11、什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#11、什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="11、什么是 SYN 攻击？如何避免 SYN 攻击？"></a>11、什么是 SYN 攻击？如何避免 SYN 攻击？</h3><p><strong>（1）什么是SYN攻击？</strong></p>
<p><strong>什么是 TCP 半连接和全连接队列。</strong></p>
<p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<ul>
<li>半连接队列，也称 SYN 队列；</li>
<li>全连接队列，也称 accept 队列；</li>
</ul>
<p>我们先来看下 Linux 内核的 <code>SYN</code> 队列（半连接队列）与 <code>Accpet</code> 队列（全连接队列）是如何工作的？</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101543018.png" alt="正常流程" style="zoom:50%;" />

<p>正常流程：</p>
<ul>
<li>当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；</li>
<li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li>
<li>服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；</li>
<li>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出连接对象。</li>
</ul>
<p>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文。</p>
<p> TCP 连接建立需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，<strong>当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃，导致客户端无法和服务端建立连接</strong>，使得服务端不能为正常用户服务。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101541969.png" alt="SYN 攻击" style="zoom: 80%;" />

<p><strong>（2）如何避免 SYN 攻击？</strong></p>
<blockquote>
<p>避免 SYN 攻击方式，可以有以下四种方法：</p>
<ul>
<li>调大 netdev_max_backlog；</li>
<li>增大 TCP 半连接队列；</li>
<li>开启 tcp_syncookies；</li>
<li>减少 SYN+ACK 重传次数</li>
</ul>
</blockquote>
<h2 id="3-6-四次挥手相关"><a href="#3-6-四次挥手相关" class="headerlink" title="3.6 四次挥手相关"></a>3.6 四次挥手相关</h2><h3 id="1、详细说明四次挥手"><a href="#1、详细说明四次挥手" class="headerlink" title="1、详细说明四次挥手"></a>1、详细说明四次挥手</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101556792.png" alt="客户端主动关闭连接 —— TCP 四次挥手" style="zoom: 67%;" />

<ul>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<p>可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p>
<h3 id="2、为什么挥手需要四次？"><a href="#2、为什么挥手需要四次？" class="headerlink" title="2、为什么挥手需要四次？"></a>2、为什么挥手需要四次？</h3><p>再来回顾下四次挥手双方发 <code>FIN</code> 包的过程，就能理解为什么需要四次了。</p>
<ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，因此是需要四次挥手。</p>
<h3 id="3、第一次挥手丢失了，会发生什么？"><a href="#3、第一次挥手丢失了，会发生什么？" class="headerlink" title="3、第一次挥手丢失了，会发生什么？"></a>3、第一次挥手丢失了，会发生什么？</h3><p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 <code>FIN_WAIT_1</code> 状态。</p>
<p>正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 <code>FIN_WAIT2</code>状态。如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 <code>tcp_orphan_retries</code> 参数控制。</p>
<p>当客户端重传 FIN 报文的次数超过 <code>tcp_orphan_retries</code> 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么直接进入到 <code>close</code> 状态。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.png" alt="img" style="zoom:50%;" />

<h3 id="4、第二次挥手丢失了，会发生什么？"><a href="#4、第二次挥手丢失了，会发生什么？" class="headerlink" title="4、第二次挥手丢失了，会发生什么？"></a>4、第二次挥手丢失了，会发生什么？</h3><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 <code>CLOSE_WAIT</code> 状态。</p>
<p>在前面我们也提了，<strong>ACK 报文是不会重传的</strong>，所以如果服务端的第二次挥手丢失了，<strong>客户端就会触发超时重传机制，重传 FIN 报文</strong>，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.png" alt="img" style="zoom:50%;" />

<p>这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 <code>FIN_WAIT2</code> 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。</p>
<p>对于 <strong>close 函数</strong>关闭的连接，由于无法再发送和接收数据，所以<code>FIN_WAIT2</code> 状态不可以持续太久，而 <code>tcp_fin_timeout</code> 控制了这个状态下连接的持续时长，默认值是 60 秒。这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/fin_wait_2.drawio.png" alt="img" style="zoom:50%;" />

<p>但是注意，如果主动关闭方使用 <strong>shutdown 函数</strong>关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 <code>FIN_WAIT2</code> 状态（<code>tcp_fin_timeout</code> 无法控制 shutdown 关闭的连接）。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/fin_wait_2%E6%AD%BB%E7%AD%89.drawio.png" alt="img" style="zoom:50%;" />

<h3 id="5、第三次挥手丢失了，会发生什么？"><a href="#5、第三次挥手丢失了，会发生什么？" class="headerlink" title="5、第三次挥手丢失了，会发生什么？"></a>5、第三次挥手丢失了，会发生什么？</h3><p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 <code>CLOSE_WAIT</code> 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。</p>
<p>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 <code>tcp_orphan_retries</code> 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101604609.png" alt="img" style="zoom:50%;" />

<h3 id="6、第四次挥手丢失了，会发生什么？"><a href="#6、第四次挥手丢失了，会发生什么？" class="headerlink" title="6、第四次挥手丢失了，会发生什么？"></a>6、第四次挥手丢失了，会发生什么？</h3><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 <code>TIME_WAIT</code> 状态。</p>
<p>在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 <code>tcp_orphan_retries</code> 参数控制。</p>
<p>举个例子，假设 tcp_orphan_retries 为 2，当第四次挥手一直丢失时，发生的过程如下：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101603186.png" alt="img" style="zoom:50%;" />

<h3 id="7、为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#7、为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="7、为什么 TIME_WAIT 等待的时间是 2MSL？"></a>7、为什么 TIME_WAIT 等待的时间是 2MSL？</h3><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 <code>TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。<strong>TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</strong>。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p>
<p>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 <code>FIN</code> 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。可以看到 <strong>2MSL时长</strong> 这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。<code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p>
<p><strong>Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。其定义在 Linux 内核代码里的名称为 TCP_TIMEWAIT_LEN：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_TIMEWAIT_LEN (60*HZ) <span class="comment">/* how long to wait to destroy TIME-WAIT </span></span></span><br><span class="line"><span class="comment"><span class="meta">                                    state, about 60 seconds  */</span></span></span><br></pre></td></tr></table></figure>

<p>如果要修改 TIME_WAIT 的时间长度，只能修改 Linux 内核代码里 TCP_TIMEWAIT_LEN 的值，并重新编译 Linux 内核。</p>
<h3 id="8、为什么需要-TIME-WAIT-状态？"><a href="#8、为什么需要-TIME-WAIT-状态？" class="headerlink" title="8、为什么需要 TIME_WAIT 状态？"></a>8、为什么需要 TIME_WAIT 状态？</h3><blockquote>
<p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p>
<p>需要 TIME-WAIT 状态，主要是两个原因：</p>
<ul>
<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li>
<li>保证「被动关闭连接」的一方，能被正确的关闭；</li>
</ul>
</blockquote>
<p><strong>（1）原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收</strong></p>
<p>为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 <code>2MSL</code> 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p>
<p><strong>（2）原因二：保证「被动关闭连接」的一方，能被正确的关闭</strong></p>
<p>TIME-WAIT 的另一个作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p>
<p>如果客户端（主动关闭方）最后一次 ACK 报文（第四次挥手）在网络中丢失了，那么按照 TCP 可靠性原则，服务端（被动关闭方）会重发 FIN 报文。</p>
<p>假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSE 状态，如果该  ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说不是一个优雅的终止方式。</p>
<p>为了防止这种情况出现，客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TIME-WAIT%E8%BF%9E%E6%8E%A5%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%AD.drawio.png" alt="TIME-WAIT 时间正常，确保了连接正常关闭" style="zoom:50%;" />

<p>客户端在收到服务端重传的 FIN 报文时，TIME_WAIT 状态的等待时间，会重置回 2MSL。</p>
<h3 id="9、TIME-WAIT-过多有什么危害？"><a href="#9、TIME-WAIT-过多有什么危害？" class="headerlink" title="9、TIME_WAIT 过多有什么危害？"></a>9、TIME_WAIT 过多有什么危害？</h3><p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ul>
<li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li>
<li>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</li>
</ul>
<p>客户端和服务端 TIME_WAIT 过多，造成的影响是不同的。</p>
<p><strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的。因此，客户端（发起连接方）都是和「目的 IP+ 目的 PORT 」都一样的服务端建立连接的话，当客户端的 TIME_WAIT  状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的 IP+ 目的 PORT」都一样的服务端建立连接了。不过，即使是在这种场景下，只要连接的是不同的服务端，端口是可以重复使用的，所以客户端还是可以向其他服务端发起连接的，这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。</p>
<p><strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。</p>
<h3 id="10、如何优化-TIME-WAIT？"><a href="#10、如何优化-TIME-WAIT？" class="headerlink" title="10、如何优化 TIME_WAIT？"></a>10、如何优化 TIME_WAIT？</h3><blockquote>
<p>这里给出优化 TIME-WAIT 的几个方式，都是有利有弊：</p>
<ul>
<li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li>
<li>net.ipv4.tcp_max_tw_buckets</li>
<li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li>
</ul>
</blockquote>
<h3 id="11、服务器出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#11、服务器出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="11、服务器出现大量 TIME_WAIT 状态的原因有哪些？"></a>11、服务器出现大量 TIME_WAIT 状态的原因有哪些？</h3><blockquote>
<p>首先要知道 TIME_WAIT 状态是主动关闭连接方才会出现的状态，所以<strong>如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接</strong>。</p>
<p>问题来了，<strong>什么场景下服务端会主动断开连接呢？</strong></p>
<ul>
<li>第一个场景：HTTP 没有使用长连接</li>
<li>第二个场景：HTTP 长连接超时</li>
<li>第三个场景：HTTP 长连接的请求数量达到上限</li>
</ul>
</blockquote>
<p>接下来，分别介绍下。</p>
<p><strong>（1）第一个场景：HTTP 没有使用长连接</strong></p>
<p>只要任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，就无法使用 HTTP 长连接机制，这样在完成一次 HTTP 请求&#x2F;处理后，就会关闭连接。<strong>根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<blockquote>
<p>客户端禁用了 HTTP Keep-Alive，服务端开启 HTTP Keep-Alive，谁是主动关闭方？</p>
</blockquote>
<p>当客户端禁用了 HTTP Keep-Alive，这时候 HTTP 请求的 header 就会有 <code>Connection:close</code> 信息，这时服务端在发完 HTTP 响应后，就会主动关闭连接。</p>
<p>为什么要这么设计呢？HTTP 是请求-响应模型，发起方一直是客户端，HTTP Keep-Alive 的初衷是<strong>为客户端后续的请求重用连接</strong>，如果我们<strong>在某次 HTTP 请求-响应模型中，请求的 header 定义了 <code>connection：close</code> 信息，那不再重用这个连接的时机就只有在服务端了</strong>，所以我们在 HTTP 请求-响应这个周期的「末端」关闭连接是合理的。</p>
<blockquote>
<p>客户端开启了 HTTP Keep-Alive，服务端禁用了 HTTP Keep-Alive，谁是主动关闭方？</p>
</blockquote>
<p>当客户端开启了 HTTP Keep-Alive，而服务端禁用了 HTTP Keep-Alive，这时服务端在发完 HTTP 响应后，服务端也会主动关闭连接。</p>
<p><strong>因此，当服务端出现大量的 TIME_WAIT 状态连接的时候，可以排查下是否客户端和服务端都开启了 HTTP Keep-Alive，因为任意一方没有开启  HTTP Keep-Alive，都会导致服务端在处理完一个 HTTP 请求后，就主动关闭连接，此时服务端上就会出现大量的 TIME_WAIT 状态的连接。</strong></p>
<p>针对这个场景下，解决的方式也很简单，让客户端和服务端都开启 HTTP Keep-Alive 机制。</p>
<p><strong>（2）第二个场景：HTTP 长连接超时</strong></p>
<p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。HTTP 长连接可以在同一个 TCP 连接上接收和发送多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销。</p>
<p>为了避免资源浪费的情况，web 服务软件一般都会提供一个参数，用来指定 HTTP 长连接的超时时间，比如 nginx 提供的 keepalive_timeout 参数。假设设置了 HTTP 长连接的超时时间是 60 秒，nginx 就会启动一个「定时器」，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<p><strong>当服务端出现大量 TIME_WAIT 状态的连接时，如果现象是有大量的客户端建立完 TCP 连接后，很长一段时间没有发送数据，那么大概率就是因为 HTTP 长连接超时，导致服务端主动关闭连接，产生大量处于 TIME_WAIT 状态的连接。可以往网络问题的方向排查，比如是否是因为网络问题，导致客户端发送的数据一直没有被服务端接收到，以至于 HTTP 长连接超时。</strong></p>
<p><strong>（3）第三个场景：HTTP 长连接的请求数量达到上限</strong></p>
<p>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。比如 nginx 的 keepalive_requests 这个参数，这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个 HTTP 长连接上已经接收并处理的客户端请求的数量。<strong>如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<p>keepalive_requests 参数的默认值是 100 ，意味着每个 HTTP 长连接最多只能跑 100  次请求，这个参数往往被大多数人忽略，因为当 QPS (每秒请求数) 不是很高时，默认值 100 凑合够用。</p>
<p>但是，<strong>对于一些 QPS 比较高的场景，比如超过 10000 QPS，甚至达到 30000 , 50000 甚至更高，如果 keepalive_requests 参数值是 100，这时候就 nginx 就会很频繁地关闭连接，那么此时服务端上就会出大量的 TIME_WAIT 状态</strong>。</p>
<p>针对这个场景下，解决的方式也很简单，调大 nginx 的 keepalive_requests 参数就行。</p>
<h3 id="12、服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#12、服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="12、服务器出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>12、服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h3><p>CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p>
<p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p>
<p>那什么情况会导致服务端的程序没有调用 close 函数关闭连接？这时候通常需要排查代码。</p>
<p>我们先来分析一个普通的 TCP 服务端的流程：</p>
<ol>
<li>创建服务端 socket，bind 绑定端口、listen 监听端口</li>
<li>将服务端 socket 注册到 epoll</li>
<li>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</li>
<li>将已连接的 socket 注册到 epoll</li>
<li>epoll_wait 等待事件发生</li>
<li>对方连接关闭时，我方调用 close</li>
</ol>
<p>可能导致服务端没有调用 close 函数的原因，如下。</p>
<p><strong>第一个原因</strong>：第 2 步没有做，没有将服务端 socket 注册到 epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了。</p>
<p>不过这种原因发生的概率比较小，这种属于明显的代码逻辑 bug，在前期 read view 阶段就能发现的了。</p>
<p><strong>第二个原因</strong>： 第 3 步没有做，有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。</p>
<p>发生这种情况可能是因为服务端在执行 accpet  函数之前，代码卡在某一个逻辑或者提前抛出了异常。</p>
<p><strong>第三个原因</strong>：第 4 步没有做，通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。发生这种情况可能是因为服务端在将已连接的 socket 注册到 epoll 之前，代码卡在某一个逻辑或者提前抛出了异常。</p>
<p><strong>第四个原因</strong>：第 6 步没有做，当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。</p>
<p>可以发现，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。</p>
<h3 id="13、如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#13、如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="13、如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>13、如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于   <code>ESTABLISH</code> 状态，占用着系统资源。</p>
<p>为了避免这种情况，TCP 设置了<strong>保活机制</strong>。这个机制的原理是这样的：</p>
<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP  连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<h3 id="14、如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a href="#14、如果已经建立了连接，但是服务端的进程崩溃会发生什么？" class="headerlink" title="14、如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a>14、如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h3><p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN  报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p>
<blockquote>
<p>我自己做了个实验，使用 kill -9 来模拟进程崩溃的情况，发现<strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。</p>
</blockquote>
<h2 id="3-7-Socket编程"><a href="#3-7-Socket编程" class="headerlink" title="3.7 Socket编程"></a>3.7 Socket编程</h2><h3 id="1、针对-TCP-应该如何-Socket-编程？"><a href="#1、针对-TCP-应该如何-Socket-编程？" class="headerlink" title="1、针对 TCP 应该如何 Socket 编程？"></a>1、针对 TCP 应该如何 Socket 编程？</h3><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230545997.png" alt="基于 TCP 协议的客户端和服务端工作"></p>
<ul>
<li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li>
<li>服务端调用 <code>bind</code>，将 socket 绑定在指定的 IP 地址和端口;</li>
<li>服务端调用 <code>listen</code>，进行监听；</li>
<li>服务端调用 <code>accept</code>，等待客户端连接；</li>
<li>客户端调用 <code>connect</code>，向服务端的地址和端口发起连接请求；</li>
<li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li>
<li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li>
<li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li>
</ul>
<p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p>
<p>所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p>
<p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>
<h3 id="2、accept-发生在三次握手的哪一步？"><a href="#2、accept-发生在三次握手的哪一步？" class="headerlink" title="2、accept 发生在三次握手的哪一步？"></a>2、accept 发生在三次握手的哪一步？</h3><p>我们先看看客户端连接服务端时，发送了什么？</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/socket%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="socket 三次握手" style="zoom:50%;" />

<ul>
<li>客户端的协议栈向服务端发送了 SYN 包，并告诉服务端当前发送序列号 client_isn，客户端进入 SYN_SENT 状态；</li>
<li>服务端的协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 client_isn+1，表示对 SYN 包 client_isn 的确认，同时服务端也发送一个 SYN  包，告诉客户端当前我的发送序列号为 server_isn，服务端进入 SYN_RCVD 状态；</li>
<li>客户端协议栈收到 ACK 之后，使得应用程序从 <code>connect</code> 调用返回，表示客户端到服务端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务端的 SYN 包进行应答，应答数据为 server_isn+1；</li>
<li>ACK 应答包到达服务端后，服务端的 TCP 连接进入 ESTABLISHED 状态，同时服务端协议栈使得 <code>accept</code> 阻塞调用返回，这个时候服务端到客户端的单向连接也建立成功。至此，客户端与服务端两个方向的连接都建立成功。</li>
</ul>
<p>从上面的描述过程，我们可以得知<strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。</strong></p>
<h2 id="3-8-TCP可靠性相关"><a href="#3-8-TCP可靠性相关" class="headerlink" title="3.8 TCP可靠性相关"></a>3.8 TCP可靠性相关</h2><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/3.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="img" style="zoom:50%;" />

<h3 id="1、重传机制"><a href="#1、重传机制" class="headerlink" title="1、重传机制"></a>1、重传机制</h3><blockquote>
<p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p>
<p>常见的重传机制：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
<li>SACK</li>
<li>D-SACK</li>
</ul>
</blockquote>
<p><strong>（1）超时重传</strong></p>
<p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p>
<p>TCP 会在以下两种情况发生超时重传：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<p><strong>超时重传时间 RTO 的值应该略大于报文往返  RTT 的值</strong>。如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是<strong>超时间隔加倍。</strong>也就是<strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p>
<blockquote>
<p>超时时间应该设置为多少呢？</p>
</blockquote>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/6.jpg?" alt="RTT" style="zoom:50%;" />

<p><code>RTT</code>（Round-Trip Time 往返时延）指的是<strong>数据发送时刻到接收到确认的时刻的差值</strong>，也就是包的往返时间。实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个<strong>动态变化的值</strong>。</p>
<p>超时重传时间是以 <code>RTO</code> （Retransmission Timeout 超时重传时间）表示。假设在重传的情况下，超时时间 <code>RTO</code> 「较长或较短」时的表现如下：</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/7.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="超时时间较长与较短" style="zoom:50%;" />

<p>因此，<strong>超时重传时间 RTO 的值应该略大于报文往返  RTT 的值</strong>。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/8.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="RTO 应略大于 RTT" style="zoom: 67%;" />

<p><strong>（2）快速重传</strong></p>
<p>TCP 还有另外一种<strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
<p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<strong>重传的时候，是重传一个，还是重传所有的问题。</strong></p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传机制" style="zoom: 80%;" />



<p>为了解决不知道该重传哪些 TCP 报文，于是就有 <code>SACK</code> 方法。</p>
<p><strong>（3）SACK 方法</strong></p>
<p><code>SACK</code>（ Selective Acknowledgment）， <strong>选择性确认</strong>。</p>
<p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<p>如果要支持 <code>SACK</code>，必须双方都要支持。在 Linux 下，可以通过 <code>net.ipv4.tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）。</p>
<p><strong>（4）Duplicate SACK</strong></p>
<p>Duplicate SACK 又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</strong></p>
<p><code>D-SACK</code> 有这么几个好处：</p>
<ol>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了;</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了;</li>
</ol>
<p>在 Linux 下可以通过 <code>net.ipv4.tcp_dsack</code> 参数开启&#x2F;关闭这个功能（Linux 2.4 后默认打开）。</p>
<h3 id="2、滑动窗口"><a href="#2、滑动窗口" class="headerlink" title="2、滑动窗口"></a>2、滑动窗口</h3><blockquote>
<p>引入窗口概念的原因</p>
</blockquote>
<p>TCP 每发送一个数据，都要进行一次确认应答。这样的传输方式有一个缺点：数据包的<strong>往返时间越长，通信的效率就越低</strong>。为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。窗口大小是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p>
<p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/15.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="用滑动窗口方式并行处理" style="zoom: 67%;" />

<p>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p>
<blockquote>
<p>窗口大小由哪一方决定？</p>
</blockquote>
<p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</p>
<p><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong></p>
<p>所以，通常窗口的大小是由接收方的窗口大小来决定的。</p>
<p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>
<blockquote>
<p>接收窗口和发送窗口的大小是相等的吗？</p>
</blockquote>
<p>并不是完全相等，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。</p>
<p>因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</p>
<h3 id="3、流量控制"><a href="#3、流量控制" class="headerlink" title="3、流量控制"></a>3、流量控制</h3><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p>
<p>为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p>
<p><strong>（1）窗口关闭</strong></p>
<p>TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。<strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</strong></p>
<blockquote>
<p>窗口关闭潜在的危险</p>
</blockquote>
<p>接收方向发送方通告窗口大小时，是通过 <code>ACK</code> 报文来通告的。那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/24.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="窗口关闭潜在的危险" style="zoom:50%;" />

<blockquote>
<p>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</p>
</blockquote>
<p>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/25.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="窗口探测" style="zoom: 50%;" />

<ul>
<li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；</li>
<li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li>
</ul>
<p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code>RST</code> 报文来中断连接。</p>
<h3 id="4、拥塞控制"><a href="#4、拥塞控制" class="headerlink" title="4、拥塞控制"></a>4、拥塞控制</h3><blockquote>
<p>为什么要有拥塞控制呀，不是有流量控制了吗？</p>
</blockquote>
<p>前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p>
<p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。<strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p>
<p>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。</p>
<blockquote>
<p>什么是拥塞窗口？和发送窗口有什么关系呢？</p>
</blockquote>
<p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p>
<p>我们在前面提到过发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p>
<p>拥塞窗口 <code>cwnd</code> 变化的规则：</p>
<ul>
<li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li>
<li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li>
</ul>
<blockquote>
<p>那么怎么知道当前网络是否出现了拥塞呢？</p>
</blockquote>
<p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p>
<blockquote>
<p>拥塞控制有哪些控制算法？</p>
</blockquote>
<p>拥塞控制主要是四个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<h2 id="3-9-如何理解是-TCP-面向字节流协议？"><a href="#3-9-如何理解是-TCP-面向字节流协议？" class="headerlink" title="3.9 如何理解是 TCP 面向字节流协议？"></a>3.9 如何理解是 TCP 面向字节流协议？</h2><p>之所以会说 TCP 是面向字节流的协议，UDP 是面向报文的协议，是因为操作系统对 TCP 和 UDP 协议的<strong>发送方的机制不同</strong>，也就是问题原因在发送方。</p>
<blockquote>
<p>先来说说为什么 UDP 是面向报文的协议？</p>
</blockquote>
<p>当用户消息通过 UDP 协议传输时，<strong>操作系统不会对消息进行拆分</strong>，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是<strong>每个 UDP 报文就是一个用户消息的边界</strong>，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。</p>
<p>操作系统在收到 UDP 报文后，会将其插入到队列里，<strong>队列里的每一个元素就是一个 UDP 报文</strong>，这样当用户调用 recvfrom() 系统调用读数据的时候，就会从队列里取出一个数据，然后从内核里拷贝给用户缓冲区。</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406101710378.png" alt="图片" style="zoom: 67%;" />

<blockquote>
<p>再来说说为什么 TCP 是面向字节流的协议？</p>
</blockquote>
<p>当用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。这时，接收方的程序如果不知道发送方发送的消息的长度，也就是不知道消息的边界时，是无法读出一个有效的用户消息的，因为用户消息被拆分成多个 TCP 报文后，并不能像 UDP 那样，一个 UDP 报文就能代表一个完整的用户消息。</p>
<p>举个实际的例子来说明。</p>
<p>发送方准备发送 「Hi.」和「I am Xiaolin」这两个消息。</p>
<p>在发送端，当我们调用 send 函数完成数据“发送”以后，数据并没有被真正从网络上发送出去，只是从应用程序拷贝到了操作系统内核协议栈中。至于什么时候真正被发送，<strong>取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件</strong>。也就是说，我们不能认为每次 send 调用发送的数据，都会作为一个整体完整地消息被发送出去。</p>
<p>如果我们考虑实际网络传输过程中的各种影响，假设发送端陆续调用 send 函数先后发送 「Hi.」和「I am Xiaolin」 报文，那么实际的发送很有可能是这几种情况。</p>
<p>第一种情况，这两个消息被分到同一个 TCP 报文，像这样：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/02dce678f870c8c70482b6e37dbb5574.png" alt="图片" style="zoom:67%;" />

<p>第二种情况，「I am Xiaolin」的部分随 「Hi」 在一个 TCP 报文中发送出去，像这样：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/f58b70cde860188b8f95a433e2f5293b.png" alt="图片" style="zoom: 67%;" />

<p>第三种情况，「Hi.」 的一部分随 TCP 报文被发送出去，另一部分和 「I am Xiaolin」 一起随另一个 TCP 报文发送出去，像这样。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/68080e783d7acc842fa254e4f9ec5630.png" alt="图片" style="zoom:67%;" />

<p>类似的情况还能举例很多种，因此，<strong>我们不能认为一个用户消息对应一个 TCP 报文，正因为这样，所以 TCP 是面向字节流的协议</strong>。当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 TCP 粘包问题，这时接收方不知道消息的边界的话，是无法读出有效的消息。要解决这个问题，要交给<strong>应用程序</strong>。</p>
<h2 id="3-10-如何解决粘包？"><a href="#3-10-如何解决粘包？" class="headerlink" title="3.10 如何解决粘包？"></a>3.10 如何解决粘包？</h2><blockquote>
<p>粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。</p>
<p>一般有三种方式分包的方式：</p>
<ul>
<li>固定长度的消息；</li>
<li>特殊字符作为边界；</li>
<li>自定义消息结构。</li>
</ul>
</blockquote>
<p><strong>（1）固定长度的消息</strong></p>
<p>这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。</p>
<p><strong>（2）特殊字符作为边界</strong></p>
<p>在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。</p>
<p>HTTP 是一个非常好的例子。HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/a49a6bb8cd38ae1738d9c00aec68b444.png" alt="图片" style="zoom:50%;" />

<p>有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。</p>
<p><strong>（3）自定义消息结构</strong></p>
<p>自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。</p>
<p>比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    <span class="type">u_int32_t</span> message_length; </span><br><span class="line">    <span class="type">char</span> message_data[]; </span><br><span class="line">&#125; message;</span><br></pre></td></tr></table></figure>

<p>当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。</p>
<h2 id="3-11-已建立连接的TCP，收到SYN会发生什么？"><a href="#3-11-已建立连接的TCP，收到SYN会发生什么？" class="headerlink" title="3.11 已建立连接的TCP，收到SYN会发生什么？"></a>3.11 已建立连接的TCP，收到SYN会发生什么？</h2><p><strong>1. 客户端的 SYN 报文里的端口号与历史连接不相同</strong></p>
<p>如果客户端恢复后发送的 SYN 报文中的源端口号跟上一次连接的源端口号不一样，此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。</p>
<p>那旧连接里处于 Established 状态的服务端最后会怎么样呢？</p>
<ul>
<li>如果服务端发送了数据包给客户端，由于客户端的连接已经被关闭了，此时客户的内核就会回 RST 报文，服务端收到后就会释放连接；</li>
<li>如果服务端一直没有发送数据包给客户端，在超过一段时间后，TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。</li>
</ul>
<p><strong>2. 客户端的 SYN 报文里的端口号与历史连接相同</strong></p>
<p>如果客户端恢复后，发送的 SYN 报文中的源端口号跟上一次连接的源端口号一样，也就是处于 Established 状态的服务端收到了这个 SYN 报文。</p>
<p><strong>处于 Established 状态的服务端，如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN  报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。</strong></p>
<p><strong>接着，客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。</strong></p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/est_syn.png" alt="img" style="zoom:50%;" />

<h2 id="3-12-四次挥手中收到乱序的-FIN-包会如何处理？"><a href="#3-12-四次挥手中收到乱序的-FIN-包会如何处理？" class="headerlink" title="3.12 四次挥手中收到乱序的 FIN 包会如何处理？"></a>3.12 四次挥手中收到乱序的 FIN 包会如何处理？</h2><blockquote>
<p><strong>在 FIN_WAIT_2 状态下，是如何处理收到的乱序到 FIN 报文，然后 TCP 连接又是什么时候才进入到 TIME_WAIT 状态?</strong></p>
</blockquote>
<p><strong>在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文，那么就被会加入到「乱序队列」，并不会进入到 TIME_WAIT 状态。</strong></p>
<p><strong>等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，然后会检测乱序队列中是否有可用的数据，如果能在乱序队列中找到与当前报文的序列号保持的顺序的报文，就会看该报文是否有 FIN 标志，如果发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。</strong></p>
<img src="https://cdn.xiaolincoding.com//mysql/other/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5p6XY29kaW5n,size_20,color_FFFFFF,t_70,g_se,x_16-20230309230147654.png" alt="img" style="zoom: 67%;" />

<h2 id="3-13-在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？"><a href="#3-13-在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？" class="headerlink" title="3.13 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？"></a>3.13 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？</h2><blockquote>
<p><strong>1、收到合法 SYN</strong></p>
<p>如果处于 TIME_WAIT 状态的连接收到「合法的 SYN 」后，<strong>就会重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程</strong>。</p>
<p><strong>2、收到非法的 SYN</strong></p>
<p>如果处于 TIME_WAIT 状态的连接收到「非法的 SYN 」后，就会<strong>再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号（ack num），就回 RST 报文给服务端</strong>。</p>
</blockquote>
<img src="https://cdn.xiaolincoding.com//mysql/other/74b53919396dcda634cfd5b5795cbf16.png" alt="图片" style="zoom: 67%;" />

<p>针对这个问题，<strong>关键是要看 SYN 的「序列号和时间戳」是否合法</strong>，因为处于 TIME_WAIT 状态的连接收到 SYN 后，会判断 SYN 的「序列号和时间戳」是否合法，然后根据判断结果的不同做不同的处理。</p>
<ul>
<li><strong>合法 SYN</strong>：客户端的  SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>，<strong>并且</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>大</strong>。</li>
<li><strong>非法 SYN</strong>：客户端的  SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>，<strong>或者</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>小</strong>。</li>
</ul>
<p>上面 SYN 合法判断是基于双方都开启了 TCP 时间戳机制的场景，如果双方都没有开启 TCP 时间戳机制，则 SYN 合法判断如下：</p>
<ul>
<li><strong>合法 SYN</strong>：客户端的  SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>。</li>
<li><strong>非法 SYN</strong>：客户端的  SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>。</li>
</ul>
<h2 id="3-14-在-TIME-WAIT-状态，收到-RST-会断开连接吗？"><a href="#3-14-在-TIME-WAIT-状态，收到-RST-会断开连接吗？" class="headerlink" title="3.14 在 TIME_WAIT 状态，收到 RST 会断开连接吗？"></a>3.14 在 TIME_WAIT 状态，收到 RST 会断开连接吗？</h2><p>在前面我留了一个疑问，处于 TIME_WAIT 状态的连接，收到 RST 会断开连接吗？</p>
<p>会不会断开，关键看 <code>net.ipv4.tcp_rfc1337</code> 这个内核参数（默认情况是为 0）：</p>
<ul>
<li>如果这个参数设置为 0， 收到 RST 报文会提前结束 TIME_WAIT 状态，释放连接。</li>
<li>如果这个参数设置为 1， 就会丢掉 RST 报文。</li>
</ul>
<h2 id="3-15-针对某个TCP-连接，一端断电和进程崩溃有什么区别？"><a href="#3-15-针对某个TCP-连接，一端断电和进程崩溃有什么区别？" class="headerlink" title="3.15  针对某个TCP 连接，一端断电和进程崩溃有什么区别？"></a>3.15  针对某个TCP 连接，一端断电和进程崩溃有什么区别？</h2><blockquote>
<p>如果是「<strong>客户端进程崩溃</strong>」，那么内核会发送 FIN 报文，与服务端进行四次挥手。</p>
<p>但是，「<strong>客户端主机宕机</strong>」，后续还要看服务端会不会发送数据：</p>
<ul>
<li>如果服务端有发送数据，由于客户端已经不存在，收不到数据报文的响应报文，服务端的数据报文会超时重传，当重传总间隔时长达到一定阈值（内核会根据 tcp_retries2 设置的值计算出一个阈值）后，会断开 TCP 连接；</li>
<li>如果服务端一直不会发送数据，再看服务端有没有开启 TCP keepalive 机制？</li>
<li>如果有开启，服务端在一段时间没有进行数据交互时，会触发 TCP keepalive 机制，探测对方是否存在，如果探测到对方已经消亡，则会断开自身的 TCP 连接；</li>
<li>如果没有开启，服务端的 TCP 连接会一直存在，并且一直保持在 ESTABLISHED 状态。</li>
</ul>
</blockquote>
<h3 id="1、没有数据传输的情况"><a href="#1、没有数据传输的情况" class="headerlink" title="1、没有数据传输的情况"></a>1、没有数据传输的情况</h3><blockquote>
<p>一个TCP连接，没有打开keepalive，没有数据交互，现在一端突然掉电和一端的进程crush了，这两种情况有什么区别呢？</p>
</blockquote>
<ul>
<li><p>TCP keepalive实际上就是 <strong>TCP 的保活机制</strong>：</p>
<p>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</p>
<ul>
<li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li>
<li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li>
</ul>
<p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。</p>
</li>
</ul>
<h4 id="（1）主机崩溃"><a href="#（1）主机崩溃" class="headerlink" title="（1）主机崩溃"></a>（1）主机崩溃</h4><p>知道了 TCP keepalive 作用，我们再回过头看题目中的「主机崩溃」这种情况。</p>
<blockquote>
<p>在没有开启 TCP keepalive，且双方一直没有数据交互的情况下，如果客户端的「主机崩溃」了，会发生什么？</p>
</blockquote>
<p>客户端主机崩溃了，服务端是<strong>无法感知到的</strong>，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程。</p>
<p>所以，我们可以得知一个点，<strong>在没有使用 TCP 保活机制且双方不传输数据的情况下</strong>，一方的 TCP 连接处在 ESTABLISHED 状态，并不代表另一方的连接还一定正常。</p>
<h4 id="（2）进程崩溃"><a href="#（2）进程崩溃" class="headerlink" title="（2）进程崩溃"></a>（2）进程崩溃</h4><blockquote>
<p>那题目中的「进程崩溃」的情况呢？</p>
</blockquote>
<p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN  报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP四次挥手的过程。</p>
<p>使用 kill -9 来模拟进程崩溃的情况，发现<strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</p>
<h3 id="2、有数据传输的情况"><a href="#2、有数据传输的情况" class="headerlink" title="2、有数据传输的情况"></a>2、有数据传输的情况</h3><h4 id="（1）客户端主机宕机，又迅速重启"><a href="#（1）客户端主机宕机，又迅速重启" class="headerlink" title="（1）客户端主机宕机，又迅速重启"></a>（1）客户端主机宕机，又迅速重启</h4><p>在客户端主机宕机后，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的报文。服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：</p>
<ul>
<li>如果客户端主机上<strong>没有</strong>进程绑定该 TCP 报文的目标端口号，那么客户端内核就会<strong>回复 RST 报文，重置该 TCP 连接</strong>；</li>
<li>如果客户端主机上<strong>有</strong>进程绑定该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会<strong>回复 RST 报文，重置该 TCP 连接</strong>。</li>
</ul>
<p>所以，<strong>只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接</strong>。</p>
<h4 id="（2）客户端主机宕机，一直没有重启"><a href="#（2）客户端主机宕机，一直没有重启" class="headerlink" title="（2）客户端主机宕机，一直没有重启"></a>（2）客户端主机宕机，一直没有重启</h4><p>这种情况，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。</p>
<blockquote>
<p>那 TCP 的数据报文具体重传几次呢？</p>
</blockquote>
<p>在 Linux 系统中，提供一个叫 tcp_retries2 配置项，默认值是 15，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/20210615134059647.png" alt="在这里插入图片描述"></p>
<p>这个内核参数是控制在 TCP 连接建立的情况下，超时重传的最大次数。</p>
<p>不过 tcp_retries2 设置了 15 次，并不代表 TCP 超时重传了 15 次才会通知应用程序终止该 TCP 连接，<strong>内核会根据 tcp_retries2 设置的值，计算出一个 timeout</strong>（<em>如果 tcp_retries2 &#x3D;15，那么计算得到的 timeout &#x3D; 924600 ms</em>），<strong>如果重传间隔超过这个 timeout，则认为超过了阈值，就会停止重传，然后就会断开 TCP 连接</strong>。</p>
<p>在发生超时重传的过程中，每一轮的超时时间（RTO）都是<strong>倍数增长</strong>的，比如如果第一轮 RTO 是 200 毫秒，那么第二轮 RTO 是 400 毫秒，第三轮 RTO 是 800 毫秒，以此类推。而 RTO 是基于 RTT（一个包的往返时间） 来计算的，如果 RTT 较大，那么计算出来的 RTO 就越大，那么经过几轮重传后，很快就达到了上面的 timeout 值了。</p>
<p>最小 RTO 和最大 RTO 是在 Linux 内核中定义好了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_RTO_MAX ((unsigned)(120*HZ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_RTO_MIN ((unsigned)(HZ/5))</span></span><br></pre></td></tr></table></figure>

<p>Linux 2.6+ 使用 1000 毫秒的 HZ，因此<code>TCP_RTO_MIN</code>约为 200 毫秒，<code>TCP_RTO_MAX</code>约为 120 秒。</p>
<h2 id="3-16-拔掉网线后，-原本的-TCP-连接还存在吗？"><a href="#3-16-拔掉网线后，-原本的-TCP-连接还存在吗？" class="headerlink" title="3.16 拔掉网线后， 原本的 TCP 连接还存在吗？"></a>3.16 拔掉网线后， 原本的 TCP 连接还存在吗？</h2><p>实际上，TCP 连接在 Linux 内核中是一个名为 <code>struct socket</code> 的结构体，该结构体的内容包含 TCP 连接的状态等信息。当拔掉网线的时候，操作系统并不会变更该结构体的任何内容，所以 TCP 连接的状态也不会发生改变。</p>
<p><strong>因此，拔掉网线这个动作并不会影响 TCP 连接的状态。</strong>接下来，要看拔掉网线后，双方做了什么动作，此问题需要分场景来讨论：</p>
<ul>
<li>拔掉网线后，有数据传输；</li>
<li>拔掉网线后，没有数据传输。</li>
</ul>
<h3 id="1、拔掉网线后，有数据传输"><a href="#1、拔掉网线后，有数据传输" class="headerlink" title="1、拔掉网线后，有数据传输"></a>1、拔掉网线后，有数据传输</h3><p>在客户端拔掉网线后，服务端向客户端发送的数据报文会得不到任何的响应，在等待一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的数据报文。</p>
<ul>
<li><p><strong>如果在服务端重传报文的过程中，客户端刚好把网线插回去了</strong>，由于拔掉网线并不会改变客户端的 TCP 连接状态，并且还是处于 ESTABLISHED 状态，所以这时客户端是可以正常接收服务端发来的数据报文的，然后客户端就会回 ACK 响应报文。</p>
<p>此时，客户端和服务端的 TCP 连接依然存在的，就感觉什么事情都没有发生；</p>
</li>
<li><p>但是，<strong>如果如果在服务端重传报文的过程中，客户端一直没有将网线插回去</strong>，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。</p>
<p>而等客户端插回网线后，如果客户端向服务端发送了数据，由于服务端已经没有与客户端相同四元祖的 TCP 连接了，因此服务端内核就会回复 RST 报文，客户端收到后就会释放该 TCP 连接。</p>
<p>此时，客户端和服务端的 TCP 连接都已经断开了。</p>
</li>
</ul>
<h3 id="2、拔掉网线后，没有数据传输"><a href="#2、拔掉网线后，没有数据传输" class="headerlink" title="2、拔掉网线后，没有数据传输"></a>2、拔掉网线后，没有数据传输</h3><p>针对拔掉网线后，没有数据传输的场景，还得看是否开启了 TCP keepalive 机制 （TCP 保活机制）。</p>
<ul>
<li><p>如果<strong>没有开启</strong> TCP keepalive 机制，在客户端拔掉网线后，并且双方都没有进行数据传输，那么客户端和服务端的 TCP 连接将会一直保持存在。</p>
</li>
<li><p>而如果<strong>开启</strong>了 TCP keepalive 机制，在客户端拔掉网线后，即使双方都没有进行数据传输，在持续一段时间后，TCP 就会发送探测报文：</p>
<ul>
<li><p>如果<strong>对端是正常工作</strong>的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</p>
</li>
<li><p>如果<strong>对端主机宕机</strong>（<em>注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机</em>），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</p>
</li>
</ul>
<p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。</p>
</li>
</ul>
<h2 id="3-17-tcp-tw-reuse-为什么默认是关闭的？"><a href="#3-17-tcp-tw-reuse-为什么默认是关闭的？" class="headerlink" title="3.17 tcp_tw_reuse 为什么默认是关闭的？"></a>3.17 tcp_tw_reuse 为什么默认是关闭的？</h2><blockquote>
<p>其实这题在变相问「<strong>如果 TIME_WAIT 状态持续时间过短或者没有，会有什么问题？</strong>」因为开启 tcp_tw_reuse 参数可以快速复用处于 TIME_WAIT 状态的 TCP 连接时，相当于缩短了 TIME_WAIT 状态的持续时间。</p>
</blockquote>
<blockquote>
<p>tcp_tw_reuse 的作用是让客户端快速复用处于 TIME_WAIT 状态的端口，相当于跳过了 TIME_WAIT 状态，这可能会出现这样的两个问题：</p>
<ul>
<li>历史 RST 报文可能会终止后面相同四元组的连接，因为 PAWS 检查到即使 RST 是过期的，也不会丢弃。</li>
<li>如果第四次挥手的 ACK 报文丢失了，有可能被动关闭连接的一方不能被正常的关闭;</li>
</ul>
</blockquote>
<h3 id="1、tcp-tw-reuse-是什么？"><a href="#1、tcp-tw-reuse-是什么？" class="headerlink" title="1、tcp_tw_reuse 是什么？"></a>1、tcp_tw_reuse 是什么？</h3><p>在 Linux  操作系统下，TIME_WAIT 状态的持续时间是 60 秒，这意味着这 60 秒内，客户端一直会占用着这个端口。要知道，端口资源也是有限的，一般可以开启的端口为 32768~61000 ，也可以通过如下参数设置指定范围：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_local_port_range</span><br></pre></td></tr></table></figure>

<p><strong>如果客户端（主动关闭连接方）的 TIME_WAIT 状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务器发起连接了，但是被使用的端口，还是可以继续对另外一个服务器发起连接的。这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。</p>
<p>好在，Linux 操作系统提供了两个可以系统参数来快速回收处于 TIME_WAIT 状态的连接，这两个参数都是默认关闭的：</p>
<ul>
<li>net.ipv4.tcp_tw_reuse，如果开启该选项的话，客户端（连接发起方） 在调用 connect() 函数时，<strong>如果内核选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了</strong>。所以该选项只适用于连接发起方。</li>
<li>net.ipv4.tcp_tw_recycle，如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收，该参数在 <strong>NAT 的网络下是不安全的</strong>！详细见这篇文章介绍：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/syn_drop.html">SYN 报文什么时候情况下会被丢弃？</a></li>
</ul>
<p>要使得上面这两个参数生效，有一个前提条件，就是要打开 TCP 时间戳，即 net.ipv4.tcp_timestamps&#x3D;1（默认即为 1）。开启了 tcp_timestamps 参数，TCP 头部就会使用时间戳选项，它有两个好处，<strong>一个是便于精确计算 RTT ，另一个是能防止序列号回绕（PAWS）</strong>。</p>
<p>序列号是一个 32 位的无符号整型，上限值是 4GB，超过 4GB  后就需要将序列号回绕进行重用。这在以前网速慢的年代不会造成什么问题，但在一个速度足够快的网络中传输大量数据时，序列号的回绕时间就会变短。如果序列号回绕的时间极短，我们就会再次面临之前延迟的报文抵达后序列号依然有效的问题。</p>
<p>为了解决这个问题，就需要有 TCP 时间戳。</p>
<p>试看下面的示例，假设 TCP 的发送窗口是 1 GB，并且使用了时间戳选项，发送方会为每个 TCP 报文分配时间戳数值，我们假设每个报文时间加 1，然后使用这个连接传输一个 6GB 大小的数据流。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/bf004909d9e44c3bc740737ced6731a0.png" alt="图片"></p>
<p>32 位的序列号在时刻 D 和 E 之间回绕。假设在时刻B有一个报文丢失并被重传，又假设这个报文段在网络上绕了远路并在时刻 F 重新出现。如果 TCP 无法识别这个绕回的报文，那么数据完整性就会遭到破坏。</p>
<p>使用时间戳选项能够有效的防止上述问题，如果丢失的报文会在时刻 F 重新出现，由于它的时间戳为 2，小于最近的有效时间戳（5 或 6），因此防回绕序列号算法（PAWS）会将其丢弃。</p>
<p>防回绕序列号算法要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，<strong>如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包</strong>。</p>
<h3 id="2、为什么-tcp-tw-reuse-默认是关闭的？"><a href="#2、为什么-tcp-tw-reuse-默认是关闭的？" class="headerlink" title="2、为什么 tcp_tw_reuse  默认是关闭的？"></a>2、为什么 tcp_tw_reuse  默认是关闭的？</h3><h4 id="（1）第一个问题"><a href="#（1）第一个问题" class="headerlink" title="（1）第一个问题"></a>（1）第一个问题</h4><p>我们知道开启 tcp_tw_reuse 的同时，也需要开启 tcp_timestamps，意味着可以用时间戳的方式有效的判断回绕序列号的历史报文。但是，防回绕序列号函数的源码中，对于 <strong>RST 报文</strong>， <strong>即使其时间戳过期了，只要 RST 报文的序列号在对方的接收窗口内，也是能被接受的</strong>。</p>
<p>假设有这样的场景：</p>
<p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406102019052.png" alt="img"></p>
<ul>
<li>客户端向一个还没有被服务端监听的端口发起了 HTTP 请求，接着服务端就会回 RST 报文给对方，很可惜的是 <strong>RST 报文被网络阻塞了</strong>。</li>
<li>由于客户端迟迟没有收到 TCP 第二次握手，于是重发了 SYN 包，与此同时服务端已经开启了服务，监听了对应的端口。于是接下来，客户端和服务端就进行了 TCP 三次握手、数据传输（HTTP应答-响应）、四次挥手。</li>
<li>因为<strong>客户端开启了 tcp_tw_reuse，于是快速复用 TIME_WAIT 状态的端口，又与服务端建立了一个与刚才相同的四元组的连接</strong>。</li>
<li>接着，<strong>前面被网络延迟 RST 报文这时抵达了客户端，而且 RST 报文的序列号在客户端的接收窗口内，由于防回绕序列号算法不会防止过期的 RST，所以 RST 报文会被客户端接受了，于是客户端的连接就断开了</strong>。</li>
</ul>
<p>上面这个场景就是开启 tcp_tw_reuse 的风险，<strong>因为快速复用 TIME_WAIT 状态的端口，导致新连接可能被回绕序列号的 RST 报文断开，而如果不跳过 TIME_WAIT 状态，而是停留 2MSL 时长，那么这个 RST 报文就不会出现在下一个新的连接</strong>。</p>
<h4 id="（2）第二个问题"><a href="#（2）第二个问题" class="headerlink" title="（2）第二个问题"></a>（2）第二个问题</h4><p>开启 tcp_tw_reuse 来快速复用 TIME_WAIT 状态的连接，如果第四次挥手的 ACK 报文丢失了，服务端会触发超时重传，重传第三次挥手报文，处于 syn_sent 状态的客户端收到服务端重传第三次挥手报文，则会回 RST 给服务端。如下图：</p>
<img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406102019869.png" alt="img" style="zoom:67%;" />



<h2 id="3-18-TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？"><a href="#3-18-TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？" class="headerlink" title="3.18 TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？"></a>3.18 TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</h2><p>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。</p>
<p>TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。</p>
<h2 id="3-19-端口复用问题"><a href="#3-19-端口复用问题" class="headerlink" title="3.19 端口复用问题"></a>3.19 端口复用问题</h2><h3 id="1、TCP-和-UDP-可以同时绑定相同的端口吗？"><a href="#1、TCP-和-UDP-可以同时绑定相同的端口吗？" class="headerlink" title="1、TCP 和 UDP 可以同时绑定相同的端口吗？"></a>1、TCP 和 UDP 可以同时绑定相同的端口吗？</h3><p>TCP 和 UDP 服务端网络相似的一个地方，就是会调用 bind 绑定端口。</p>
<p>TCP 网络编程如下，服务端执行 listen() 系统调用就是监听端口的动作。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.png" alt="img" style="zoom: 67%;" />

<p>UDP 网络编程如下，服务端是没有监听这个动作的，只有执行  bind()  系统调用来绑定端口的动作。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/udp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.png" alt="img" style="zoom: 80%;" />

<blockquote>
<p>TCP 和 UDP 可以同时绑定相同的端口吗？</p>
</blockquote>
<p>答案：<strong>可以的</strong>。</p>
<p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。</p>
<p>所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。</p>
<p>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。</p>
<p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。因此， TCP&#x2F;UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80 号端口，二者并不冲突。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97.jpeg" alt="img" style="zoom:50%;" />

<h3 id="2、多个-TCP-服务进程可以绑定同一个端口吗？"><a href="#2、多个-TCP-服务进程可以绑定同一个端口吗？" class="headerlink" title="2、多个 TCP 服务进程可以绑定同一个端口吗？"></a>2、多个 TCP 服务进程可以绑定同一个端口吗？</h3><blockquote>
<p>默认情况下，<strong>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”</strong>。</p>
<p>如果想多个进程绑定相同的 IP 地址和端口，也是有办法的，就是对 socket 设置 SO_REUSEPORT 属性。SO_REUSEADDR 作用是：<strong>如果当前启动进程绑定的 IP+PORT 与处于TIME_WAIT 状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了 SO_REUSEADDR 选项，那么该进程就可以绑定成功</strong>。</p>
</blockquote>
<p>默认情况下，<strong>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”</strong>。</p>
<p>注意，如果 TCP 服务进程 A 绑定的地址是  0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是 192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。这是因为 0.0.0.0  地址比较特殊，代表任意地址，意味着绑定了 0.0.0.0  地址，相当于把主机上的所有 IP 地址都绑定了。</p>
<p>如果想多个进程绑定相同的 IP 地址和端口，也是有办法的，就是对 socket 设置 SO_REUSEPORT 属性（内核 3.9 版本提供的新特性）。</p>
<blockquote>
<p>重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？</p>
</blockquote>
<p>当 TCP 服务进程重启之后，总是碰到“Address in use”的报错信息，TCP 服务进程不能很快地重启，而是要过一会才能重启成功。这是因为当我们重启 TCP 服务进程的时候，意味着通过服务器端发起了关闭连接操作，于是就会经过四次挥手，而对于主动关闭方，会在 TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。</p>
<p><strong>当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT  仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind()  函数的时候，就会返回了 Address already in use 的错误</strong>。</p>
<p>而等 TIME_WAIT 状态的连接结束后，重启 TCP 服务进程就能成功。</p>
<blockquote>
<p>重启 TCP 服务进程时，如何避免“Address in use”的报错信息？</p>
</blockquote>
<p>我们可以在调用 bind 前，对 socket 设置 SO_REUSEADDR 属性，可以解决这个问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br></pre></td></tr></table></figure>

<p>因为 SO_REUSEADDR 作用是：<strong>如果当前启动进程绑定的 IP+PORT 与处于TIME_WAIT 状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了 SO_REUSEADDR 选项，那么该进程就可以绑定成功</strong>。</p>
<p>举个例子，服务端有个监听 0.0.0.0 地址和 8888 端口的 TCP 服务进程。‍</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/5.png" alt="img"></p>
<p>有个客户端（IP地址：192.168.1.100）已经和服务端（IP 地址：172.19.11.200）建立了 TCP 连接，那么在 TCP 服务进程重启时，服务端会与客户端经历四次挥手，服务端的 TCP 连接会短暂处于 TIME_WAIT 状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端地址:端口           服务端地址:端口        TCP 连接状态</span><br><span class="line">192.168.1.100:37272     172.19.11.200:8888    TIME_WAI</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 TCP 服务进程没有对 socket 设置 SO_REUSEADDR  属性，那么在重启时，由于存在一个和绑定 IP+PORT 一样的 TIME_WAIT 状态的连接，那么在执行 bind() 函数的时候，就会返回了 Address already in use 的错误；</li>
<li>如果 TCP 服务进程对 socket 设置 SO_REUSEADDR 属性了，那么在重启时，即使存在一个和绑定 IP+PORT 一样的 TIME_WAIT 状态的连接，依然可以正常绑定成功，因此可以正常重启成功。</li>
</ul>
<p>因此，在所有 TCP 服务器程序中，调用 bind 之前最好对 socket 设置 SO_REUSEADDR 属性，这不会产生危害，相反，它会帮助我们在很快时间内重启服务端程序。‍</p>
<p><strong>前面我提到过这个问题</strong>：如果 TCP 服务进程 A 绑定的地址是  0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是 192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。</p>
<p>这个问题也可以由 SO_REUSEADDR 解决，因为它的<strong>另外一个作用</strong>：绑定的 IP地址 + 端口时，只要 IP 地址不是正好(exactly)相同，那么允许绑定。比如，0.0.0.0:8888 和192.168.1.100:8888，虽然逻辑意义上前者包含了后者，但是 0.0.0.0 泛指所有本地 IP，而 192.168.1.100 特指某一IP，两者并不是完全相同，所以在对 socket 设置 SO_REUSEADDR 属性后，那么执行 bind() 时候就会绑定成功。</p>
<h3 id="3、客户端的端口可以重复使用吗？"><a href="#3、客户端的端口可以重复使用吗？" class="headerlink" title="3、客户端的端口可以重复使用吗？"></a>3、客户端的端口可以重复使用吗？</h3><p>TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP  连接的。所以如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992  的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。</p>
<blockquote>
<p>客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？</p>
</blockquote>
<p>针对这个问题要看，客户端是否都是与同一个服务器（目标地址和目标端口一样）建立连接。</p>
<p>如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。</p>
<p>但是，<strong>因为只要客户端连接的服务器不同，端口资源可以重复使用的</strong>。</p>
<p>所以，如果客户端都是与不同的服务器建立连接，即使客户端端口资源只有几万个， 客户端发起百万级连接也是没问题的（当然这个过程还会受限于其他资源，比如文件描述符、内存、CPU 等）。</p>
<blockquote>
<p>如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？</p>
</blockquote>
<p>前面我们提到，如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。</p>
<p>针对这个问题，也是有解决办法的，那就是在客户端打开 <code>net.ipv4.tcp_tw_reuse</code> 这个内核参数。</p>
<p><strong>因为开启了这个内核参数后，客户端调用 connect  函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于  TIME_WAIT  状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1  秒，那么就会重用这个连接，然后就可以正常使用该端口了。</strong></p>
<p>再次提醒一次，开启了 net.ipv4.tcp_tw_reuse  内核参数，是客户端（连接发起方） 在调用 connect() 函数时才起作用，所以在服务端开启这个参数是没有效果的。</p>
<blockquote>
<p>客户端端口选择的流程总结</p>
</blockquote>
<p>至此，我们已经把客户端在执行 connect 函数时，内核选择端口的情况大致说了一遍，为了让大家更明白客户端端口的选择过程，我画了一流程图。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/%E7%AB%AF%E5%8F%A3%E9%80%89%E6%8B%A9.jpg" alt="img"></p>
<h3 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、<strong>总结</strong></h3><blockquote>
<p>TCP 和 UDP 可以同时绑定相同的端口吗？</p>
</blockquote>
<p>可以的。</p>
<p>TCP 和 UDP 传输协议，在内核中是由两个完全独立的软件模块实现的。</p>
<p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p>
<p>因此， TCP&#x2F;UDP 各自的端口号也相互独立，互不影响。</p>
<blockquote>
<p>多个 TCP 服务进程可以同时绑定同一个端口吗？</p>
</blockquote>
<p>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。</p>
<p>如果两个 TCP 服务进程绑定的端口都相同，而 IP 地址不同，那么执行 bind() 不会出错。</p>
<blockquote>
<p>如何解决服务端重启时，报错“Address already in use”的问题？</p>
</blockquote>
<p>当我们重启 TCP 服务进程的时候，意味着通过服务器端发起了关闭连接操作，于是就会经过四次挥手，而对于主动关闭方，会在 TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。</p>
<p>当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT  仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind()  函数的时候，就会返回了 Address already in use 的错误。</p>
<p>要解决这个问题，我们可以对 socket 设置 SO_REUSEADDR 属性。</p>
<p>这样即使存在一个和绑定 IP+PORT 一样的 TIME_WAIT 状态的连接，依然可以正常绑定成功，因此可以正常重启成功。</p>
<blockquote>
<p>客户端的端口可以重复使用吗？</p>
</blockquote>
<p>在客户端执行 connect 函数的时候，只要客户端连接的服务器不是同一个，内核允许端口重复使用。</p>
<p>TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。</p>
<p>所以，如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。</p>
<blockquote>
<p>客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？</p>
</blockquote>
<p>要看客户端是否都是与同一个服务器（目标地址和目标端口一样）建立连接。</p>
<p>如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT  状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。即使在这种状态下，还是可以与其他服务器建立连接的，只要客户端连接的服务器不是同一个，那么端口是重复使用的。</p>
<blockquote>
<p>如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？</p>
</blockquote>
<p>打开 net.ipv4.tcp_tw_reuse  这个内核参数。</p>
<p>因为开启了这个内核参数后，客户端调用 connect  函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于  TIME_WAIT 状态。</p>
<p>如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。</p>
<h2 id="3-20-服务端没有-listen，客户端发起连接建立，会发生什么？"><a href="#3-20-服务端没有-listen，客户端发起连接建立，会发生什么？" class="headerlink" title="3.20 服务端没有 listen，客户端发起连接建立，会发生什么？"></a>3.20 服务端没有 listen，客户端发起连接建立，会发生什么？</h2><blockquote>
<p>服务端如果只 bind了 ip 和端口，但是没有调用 listen 让这个 socket 监听连接，这时候如果客户端朝这个服务端 socket 发数据，会发生啥？</p>
</blockquote>
<p>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，此时客户端对服务端发起连接建立，服务端会回 RST 报文。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>Linux 内核处理收到 TCP 报文的入口函数是  tcp_v4_rcv，在收到 TCP 报文后，会调用 __inet_lookup_skb 函数找到 TCP 报文所属 socket 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">  </span><br><span class="line"> sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, th-&gt;source, th-&gt;dest);</span><br><span class="line"> <span class="keyword">if</span> (!sk)</span><br><span class="line">  <span class="keyword">goto</span> no_tcp_socket;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__inet_lookup_skb</code> 函数首先查找连接建立状态的socket（<code>__inet_lookup_established</code>），在没有命中的情况下，才会查找监听套接口（<code>__inet_lookup_listener</code>）。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/88416aa95d255495e07fb3a002b2167b.png" alt="图片"></p>
<p>查找监听套接口（<code>__inet_lookup_listener</code>）这个函数的实现是，<strong>根据目的地址和目的端口算出一个哈希值，然后在哈希表找到对应监听该端口的 socket。</strong>本次的案例中，服务端是没有调用 listen 函数的，所以自然也是找不到监听该端口的 socket。所以，__inet_lookup_skb 函数最终找不到对应的 socket，于是跳转到no_tcp_socket。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/54ee363e149ee3dfba30efb1a542ef5c.png" alt="图片"></p>
<p>在这个错误处理中，只要收到的报文（skb）的「校验和」没问题的话，内核就会调用 tcp_v4_send_reset 发送 RST 中止这个连接。</p>
<p>至此，整个源码流程就解析完。</p>
<h2 id="3-21-没有-listen，能建立-TCP-连接吗？"><a href="#3-21-没有-listen，能建立-TCP-连接吗？" class="headerlink" title="3.21 没有 listen，能建立 TCP 连接吗？"></a>3.21 没有 listen，能建立 TCP 连接吗？</h2><blockquote>
<p>不使用 listen ，可以建立 TCP 连接吗？</p>
</blockquote>
<p>答案，<strong>是可以的，客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有listen，就能建立连接</strong>。</p>
<blockquote>
<p>那没有listen，为什么还能建立连接？</p>
</blockquote>
<p>我们知道执行 listen 方法时，会创建半连接队列和全连接队列。三次握手的过程中会在这两个队列中暂存连接信息。所以形成连接，前提是你得有个地方存放着，方便握手的时候能根据 IP + 端口等信息找到对应的 socket。</p>
<blockquote>
<p>那么客户端会有半连接队列吗？</p>
</blockquote>
<p>显然没有，因为客户端没有执行listen，而半连接队列和全连接队列都是在执行 listen 方法时，内核自动创建的。但内核还有个全局 hash 表，可以用于存放 sock 连接的信息。这个全局 hash 表其实还细分为 ehash，bhash和listen_hash等，但因为过于细节，大家理解成有一个全局 hash 就够了，</p>
<p><strong>在 TCP 自连接的情况中，客户端在 connect 方法时，最后会将自己的连接信息放入到这个全局 hash  表中，然后将信息发出，消息在经过回环地址重新回到 TCP 传输层的时候，就会根据 IP + 端口信息，再一次从这个全局 hash  中取出信息。于是握手包一来一回，最后成功建立连接</strong>。</p>
<p>TCP 同时打开的情况也类似，只不过从一个客户端变成了两个客户端而已。</p>
<h2 id="3-22-TCP-四次挥手，可以变成三次吗？"><a href="#3-22-TCP-四次挥手，可以变成三次吗？" class="headerlink" title="3.22 TCP 四次挥手，可以变成三次吗？"></a>3.22 TCP 四次挥手，可以变成三次吗？</h2><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406102122868.png" alt="在这里插入图片描述" style="zoom: 80%;" />

<blockquote>
<p>当被动关闭方在 TCP 挥手过程中，<strong>如果「没有数据要发送」，同时「没有开启 TCP_QUICKACK（默认情况就是没有开启，没有开启  TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制）」</strong>，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</p>
</blockquote>
<p><strong>所以，出现三次挥手现象，是因为 TCP 延迟确认机制导致的。</strong></p>
<blockquote>
<p>什么是  TCP 延迟确认机制？</p>
</blockquote>
<p>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。 TCP 延迟确认的策略：</p>
<ul>
<li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li>
<li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li>
<li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li>
</ul>
<img src="https://cdn.xiaolincoding.com//mysql/other/33f3d2d54a924b0a80f565038327e0e4.png" alt="img" style="zoom: 67%;" />

<h2 id="3-23-TCP-序列号和确认号是如何变化的？"><a href="#3-23-TCP-序列号和确认号是如何变化的？" class="headerlink" title="3.23 TCP 序列号和确认号是如何变化的？"></a>3.23 TCP 序列号和确认号是如何变化的？</h2><ul>
<li>三次握手中 TCP 序列号和确认号的变化</li>
<li>数据传输中 TCP 序列号和确认号的变化</li>
<li>四次挥手中 TCP 序列号和确认号的变化</li>
</ul>
<h3 id="1、万能公式"><a href="#1、万能公式" class="headerlink" title="1、万能公式"></a>1、万能公式</h3><p>我根据经验总结了一条万能公式。</p>
<p><strong>发送的 TCP 报文：</strong></p>
<ul>
<li><strong>公式一：序列号 &#x3D; 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</strong></li>
<li><strong>公式二：确认号 &#x3D; 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</strong></li>
</ul>
<p>TCP 序列号和确认号在 TCP 头部的位置：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/41da16ec3ea04e27bcb35a93c0193855.png" alt="在这里插入图片描述" style="zoom:50%;" />

<p>这里重点关注这三个字段的作用：</p>
<ul>
<li><strong>序列号</strong>：在建立连接时由内核生成的随机数作为其初始值，通过 SYN 报文传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></li>
<li><strong>确认号</strong>：指下一次「期望」收到的数据的序列号，发送端收到接收方发来的 ACK 确认报文以后，就可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></li>
<li><strong>控制位：</strong>用来标识 TCP 报文是什么类型的报文，比如是 SYN 报文、数据报文、ACK 报文，FIN 报文等。</li>
</ul>
<h3 id="2、三次握手阶段的变化"><a href="#2、三次握手阶段的变化" class="headerlink" title="2、三次握手阶段的变化"></a>2、三次握手阶段的变化</h3><p>先来说说三次握手中 TCP 序列号和确认号的变化。</p>
<p>假设客户端的初始化序列号为 client_isn，服务端的初始化序列号为 server_isn，TCP 三次握手的流程如下：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/06c4ed62087040438f86ba64e9e609e7.png" alt="在这里插入图片描述" style="zoom:50%;" />

<blockquote>
<p>为什么第二次和第三次握手报文中的确认号是将对方的序列号 + 1 后作为确认号呢？</p>
</blockquote>
<p>SYN 报文是特殊的 TCP 报文，用于建立连接时使用，虽然 SYN 报文不携带用户数据，但是 <strong>TCP 将 SYN 报文视为 1 字节的数据</strong>，当对方收到了 SYN 报文后，在回复 ACK 报文时，就需要将 ACK 报文中的确认号设置为 SYN 的序列号 + 1 ，这样做是有两个目的：</p>
<ul>
<li><strong>告诉对方，我方已经收到 SYN 报文。</strong></li>
<li><strong>告诉对方，我方下一次「期望」收到的报文的序列号为此确认号，比如客户端与服务端完成三次握手之后，服务端接下来期望收到的是序列号为  client_isn + 1 的 TCP 数据报文。</strong></li>
</ul>
<h3 id="2、数据传输阶段的变化"><a href="#2、数据传输阶段的变化" class="headerlink" title="2、数据传输阶段的变化"></a>2、数据传输阶段的变化</h3><p>完成了，三次握手后，客户端就可以发送第一个 ** **TCP 数据报文了，假设客户端即将要发送 10 字节的数据，流程图下：</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/dadf9a94328a4446b32ebabf1623c729.png" alt="在这里插入图片描述" style="zoom:50%;" />

<p>可以看到，<strong>客户端与服务端完成 TCP 三次握手后，发送的第一个 「TCP 数据报文的序列号和确认号」都是和「第三次握手的 ACK 报文中序列号和确认号」一样的</strong>。</p>
<blockquote>
<p>之前有读者问，如果客户端发送的第三次握手  ACK 报文丢失了，处于 SYN_RCVD 状态服务端收到了客户端第一个 TCP 数据报文会发生什么？</p>
</blockquote>
<p>刚才前面我也说了，发送的第一个 「TCP 数据报文的序列号和确认号」都是和「第三次握手的 ACK 报文中序列号和确认号」一样的，并且该 TCP 数据报文也有将 ACK 标记位置为 1。如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/942c2a1e67224c8c8bd41b13d7c89a96.png" alt="在这里插入图片描述"></p>
<p>所以，服务端收到这个数据报文，是可以正常完成连接的建立，然后就可以正常接收这个数据包了。</p>
<h3 id="4、四次挥手阶段的变化"><a href="#4、四次挥手阶段的变化" class="headerlink" title="4、四次挥手阶段的变化"></a>4、四次挥手阶段的变化</h3><p>最后，我们来看看四次挥手阶段中，序列号和确认号的变化。</p>
<p>数据传输阶段结束后，客户端发起了 FIN 报文，请求服务端端开该 TCP 连接，此时就进入了 TCP 四次挥手阶段，如下图。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/ae18cbf6071c47b98014a68d05c37d16.png" alt="在这里插入图片描述" style="zoom:50%;" />

<h2 id="3-24-TCP快速打开（TFO）"><a href="#3-24-TCP快速打开（TFO）" class="headerlink" title="3.24 TCP快速打开（TFO）"></a>3.24 TCP快速打开（TFO）</h2><h2 id="3-25-TCP报文中的时间戳有什么作用？"><a href="#3-25-TCP报文中的时间戳有什么作用？" class="headerlink" title="3.25 TCP报文中的时间戳有什么作用？"></a>3.25 TCP报文中的时间戳有什么作用？</h2><p>TCP Timestamps Option 由四部分构成：</p>
<p>类别（kind）、长度（Length）、发送⽅时间戳（TS value）、回显时间戳（TS Echo Reply）。</p>
<p>TCP 的时间戳主要解决两⼤问题：</p>
<ul>
<li><p><strong>计算往返时延 RTT(Round-Trip Time)：</strong></p>
<p>在启⽤ Timestamps 选项以后，因为 ACK 包⾥包含了 TSval 和 TSecr，这样⽆论是正常确认包，还是</p>
<p>重传确认包，都可以通过这两个值计算出 RTT。</p>
</li>
<li><p><strong>防止序列号的回绕问题：</strong></p>
<p>TCP 的序列号⽤ 32bit 来表示，因此在 2^32 字节的数据传输后序列号就会溢出回绕。TCP 的窗⼝经过</p>
<p>窗⼝缩放可以最⾼到 1GB（2^30)，在⾼速⽹络中，序列号在很短的时间内就会被重复使⽤。</p>
</li>
</ul>
<h2 id="3-26-TCP场景问题"><a href="#3-26-TCP场景问题" class="headerlink" title="3.26 TCP场景问题"></a>3.26 TCP场景问题</h2><h3 id="1、收到-IP-数据包解析以后，怎么知道这个分组应该投递到上层的哪一个协议（UDP-或-TCP）？"><a href="#1、收到-IP-数据包解析以后，怎么知道这个分组应该投递到上层的哪一个协议（UDP-或-TCP）？" class="headerlink" title="1、收到 IP 数据包解析以后，怎么知道这个分组应该投递到上层的哪一个协议（UDP 或 TCP）？"></a>1、收到 IP 数据包解析以后，怎么知道这个分组应该投递到上层的哪一个协议（UDP 或 TCP）？</h3><p>通过查看 IP 头部中的 “协议字段”（Protocol field）来实现的。</p>
<ol>
<li><strong>接收 IP 数据包</strong>： 当一个 IP 数据包到达时，首先由网络层（即 IP 协议栈）进行处理。此时，系统会解析 IP 头部以提取相关信息。</li>
<li><strong>解析 IP 头部</strong>： IP 头部包含了很多重要的信息，其中包括源地址、目的地址、总长度、标识、片偏移、TTL（生存时间）、协议字段等。我们关心的是其中的协议字段。</li>
<li><strong>检查协议字段</strong>： IP 头部中的协议字段（Protocol field）位于 IP 头部的第 9 个字节。这个字段是一个 8 位的值，用来指示上层协议的类型。不同的协议有不同的编号：<ul>
<li>6：TCP（传输控制协议）</li>
<li>17：UDP（用户数据报协议）</li>
<li>1：ICMP（互联网控制消息协议）</li>
<li>其他值：对应其他上层协议</li>
</ul>
</li>
<li><strong>投递到相应的上层协议</strong>： 根据协议字段的值，IP 协议栈会将数据包投递到相应的上层协议处理程序。例如：<ul>
<li>如果协议字段的值是 6，系统会将数据包投递到 TCP 协议栈处理。</li>
<li>如果协议字段的值是 17，系统会将数据包投递到 UDP 协议栈处理。</li>
</ul>
</li>
</ol>
<h3 id="2、TCP-提供了一种字节流服务，而收发双方都不保持记录的边界，应用程序应该如何提供他们自己的记录标识呢？"><a href="#2、TCP-提供了一种字节流服务，而收发双方都不保持记录的边界，应用程序应该如何提供他们自己的记录标识呢？" class="headerlink" title="2、TCP 提供了一种字节流服务，而收发双方都不保持记录的边界，应用程序应该如何提供他们自己的记录标识呢？"></a>2、TCP 提供了一种字节流服务，而收发双方都不保持记录的边界，应用程序应该如何提供他们自己的记录标识呢？</h3><p>应⽤程序使⽤⾃⼰约定的规则来表示消息的边界，⽐如有⼀些使⽤回⻋+换⾏（”\r\n”），⽐如 Redis的通信协议（RESP protocol）。</p>
<h2 id="3-27-telnet的用法"><a href="#3-27-telnet的用法" class="headerlink" title="3.27 telnet的用法"></a>3.27 telnet的用法</h2><p>Telnet 是一个网络协议和程序，允许用户通过命令行接口登录到远程计算机或网络设备。它使用 TCP 端口 23，提供一个简单的、未加密的通信方式，适用于访问和管理远程设备。</p>
<h3 id="1、连接到远程主机"><a href="#1、连接到远程主机" class="headerlink" title="1、连接到远程主机"></a>1、连接到远程主机</h3><p>要使用 Telnet 连接到远程主机，可以在命令行输入以下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet [hostname] [port]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>[hostname]</code> 是远程主机的 IP 地址或域名。</li>
<li><code>[port]</code> 是可选的端口号。如果未指定，默认端口为 23。</li>
</ul>
<p>例如，连接到 IP 地址为 <code>192.168.1.1</code> 的主机：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.1.1</span><br></pre></td></tr></table></figure>

<p>或连接到 <code>example.com</code> 的主机：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet example.com</span><br></pre></td></tr></table></figure>

<h3 id="2、检查端口是否开放"><a href="#2、检查端口是否开放" class="headerlink" title="2、检查端口是否开放"></a>2、检查端口是否开放</h3><p>Telnet 还可以用于检查某个端口是否在远程主机上开放。例如，检查 <code>example.com</code> 上的端口 80：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet example.com 80</span><br></pre></td></tr></table></figure>

<p>如果连接成功，表示端口 80 是开放的。</p>
<h3 id="3、使用-Telnet-脚本自动化任务"><a href="#3、使用-Telnet-脚本自动化任务" class="headerlink" title="3、使用 Telnet 脚本自动化任务"></a>3、使用 Telnet 脚本自动化任务</h3><p>Telnet 客户端支持自动化脚本，可以使用 Expect 等工具来实现自动化。例如，使用 Expect 脚本登录远程主机并执行命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/expect -f</span></span><br><span class="line"></span><br><span class="line">spawn telnet 192.168.1.1</span><br><span class="line">expect <span class="string">&quot;login:&quot;</span></span><br><span class="line">send <span class="string">&quot;your_username\r&quot;</span></span><br><span class="line">expect <span class="string">&quot;Password:&quot;</span></span><br><span class="line">send <span class="string">&quot;your_password\r&quot;</span></span><br><span class="line">expect <span class="string">&quot;$&quot;</span></span><br><span class="line">send <span class="string">&quot;ls -la\r&quot;</span></span><br><span class="line">expect <span class="string">&quot;$&quot;</span></span><br><span class="line">send <span class="string">&quot;exit\r&quot;</span></span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure>

<p>将上述内容保存为 <code>telnet_script.exp</code>，然后运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect telnet_script.exp</span><br></pre></td></tr></table></figure>

<h2 id="3-28-netstat的⽤法"><a href="#3-28-netstat的⽤法" class="headerlink" title="3.28 netstat的⽤法"></a>3.28 netstat的⽤法</h2><p>netstat 命令⽤于显示各种⽹络相关信息。</p>
<p>常⻅参数</p>
<blockquote>
<p>-a (all)显示所有选项，默认不显示LISTEN相关</p>
<p>-t (tcp)仅显示tcp相关选项</p>
<p>-u (udp)仅显示udp相关选项</p>
<p>-n 拒绝显示别名，能显示数字的全部转化成数字。</p>
<p>-l 仅列出有在 Listen (监听) 的服務状态</p>
<p>-p 显示建⽴相关链接的程序名</p>
<p>-r 显示路由信息，路由表</p>
<p>-e 显示扩展信息，例如uid等</p>
<p>-s 按各个协议进⾏统计</p>
<p>-c 每隔⼀个固定时间，执⾏该netstat命令</p>
</blockquote>
<h2 id="3-29-tcpdump"><a href="#3-29-tcpdump" class="headerlink" title="3.29 tcpdump"></a>3.29 tcpdump</h2><h2 id="3-30-wireshark"><a href="#3-30-wireshark" class="headerlink" title="3.30 wireshark"></a>3.30 wireshark</h2><h2 id="3-31-如果要设计一个QQ，在网络协议上如何设计？"><a href="#3-31-如果要设计一个QQ，在网络协议上如何设计？" class="headerlink" title="3.31 如果要设计一个QQ，在网络协议上如何设计？"></a>3.31 如果要设计一个QQ，在网络协议上如何设计？</h2><p>登陆采用TCP协议和HTTP协议，你和好友之间发送消息，主要采用UDP协议，内⽹传⽂件采用了P2P技术。</p>
<p>总的来说：</p>
<ol>
<li><p>登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会有⼀个TCP连接来保持在线状态。</p>
</li>
<li><p>和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。</p>
</li>
<li><p>如果是在内网里面的两个客户端传⽂件，QQ采用的是P2P技术，不需要服务器中转。</p>
</li>
</ol>
<h2 id="3-32-用了TCP协议，一定不会丢包吗？"><a href="#3-32-用了TCP协议，一定不会丢包吗？" class="headerlink" title="3.32 用了TCP协议，一定不会丢包吗？"></a>3.32 用了TCP协议，一定不会丢包吗？</h2><h3 id="1、数据包的发送流程"><a href="#1、数据包的发送流程" class="headerlink" title="1、数据包的发送流程"></a>1、数据包的发送流程</h3><ol>
<li>把消息从用户空间拷贝到内核空间的发送缓冲区(send_buffer)；</li>
<li>顺着传输层、网络层，通过 Qdisc(排队规则) 进行流控进入到数据链路层；</li>
<li>通过 RingBuffer 发送到物理层的网卡；</li>
<li>目的机器 DMA 从网卡收包到 RingBuffer，网卡触发硬中断给 CPU；</li>
<li>CPU触发软中断让 ksoftirqd 去 RingBuffer收包，按着协议栈向上传输。</li>
</ol>
<h3 id="2、几个丢包的可能性"><a href="#2、几个丢包的可能性" class="headerlink" title="2、几个丢包的可能性"></a>2、几个丢包的可能性</h3><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111917261.png" alt="image-20240611191756056" style="zoom: 67%;" />

<h2 id="3-33-如何基于UDP实现可靠传输？"><a href="#3-33-如何基于UDP实现可靠传输？" class="headerlink" title="3.33 如何基于UDP实现可靠传输？"></a>3.33 如何基于UDP实现可靠传输？</h2><h3 id="1、QUIC如何实现可靠传输？"><a href="#1、QUIC如何实现可靠传输？" class="headerlink" title="1、QUIC如何实现可靠传输？"></a>1、QUIC如何实现可靠传输？</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111919871.png" alt="image-20240611191943734"></p>
<h3 id="2、QUIC如何解决TCP队头阻塞问题？"><a href="#2、QUIC如何解决TCP队头阻塞问题？" class="headerlink" title="2、QUIC如何解决TCP队头阻塞问题？"></a>2、QUIC如何解决TCP队头阻塞问题？</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111919210.png" alt="image-20240611191958139"></p>
<h3 id="3、QUIC如何做流量控制？"><a href="#3、QUIC如何做流量控制？" class="headerlink" title="3、QUIC如何做流量控制？"></a>3、QUIC如何做流量控制？</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111920242.png" alt="image-20240611192007166"></p>
<h3 id="4、QUIC更快的连接建立"><a href="#4、QUIC更快的连接建立" class="headerlink" title="4、QUIC更快的连接建立"></a>4、QUIC更快的连接建立</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111920442.png" alt="image-20240611192013378"></p>
<h3 id="5、QUIC如何迁移连接？"><a href="#5、QUIC如何迁移连接？" class="headerlink" title="5、QUIC如何迁移连接？"></a>5、QUIC如何迁移连接？</h3><p><img src="https://raw.githubusercontent.com/hioomph/typora_image/main/img/202406111920900.png" alt="image-20240611192018839"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/06/Computer/C++/C++%20Allocator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="midorii">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MIDORII'S JOURNEY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/06/Computer/C++/C++%20Allocator/" class="post-title-link" itemprop="url">C++ Allocator</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-06 20:33:14" itemprop="dateCreated datePublished" datetime="2024-05-06T20:33:14+08:00">2024-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-05 10:39:34" itemprop="dateModified" datetime="2024-07-05T10:39:34+08:00">2024-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h2 id="1、GNU-allocator总述（pool-allocator"><a href="#1、GNU-allocator总述（pool-allocator" class="headerlink" title="1、GNU allocator总述（pool_allocator)"></a>1、GNU allocator总述（pool_allocator)</h2><p>allocator，作为一个STL的分配器，其底层是由<code>new/delete</code>进行实现的。</p>
<h3 id="在GNU的编译器里面"><a href="#在GNU的编译器里面" class="headerlink" title="在GNU的编译器里面"></a><strong>在GNU的编译器里面</strong></h3><ul>
<li>对于比较大的或者一般的allocator，我们一般调用<code>::operator new/delete allocator和deallocate</code>进行</li>
<li>对于较小块内存的分配，在GNU2.9里面有一个比较特殊的设计。</li>
</ul>
<!--more-->

<h3 id="GNU-pool-allocator分配器简述"><a href="#GNU-pool-allocator分配器简述" class="headerlink" title="GNU pool allocator分配器简述"></a><strong>GNU pool allocator分配器简述</strong></h3><ul>
<li><p>核心思想</p>
<ul>
<li><p>首先分配一个数组，里面含有16个指针，这16个指针在未来会再一次指向对应的内存空间，每一个指针都会负责比前一个指针多8bytes的数据。</p>
</li>
<li><p>每一个指针再一次分配的时候。一般会分配40个和对象+一个上一个分配空间&#x2F;4的一样大的空间，每一个空间里面包括一个嵌入式指针，指向下一块空间，其中20个作为现在的用池，用来进行对象的安放。剩下的就作为后面的战备池每一次分配出去一个，指针就往下移动一个。</p>
</li>
<li><p>当需要分配新的对象的时候</p>
<ul>
<li>如果战备池子有充足的空间，就从战备池子取一定的空间，具体看战备池能取出多少就取出多少，最多不超过20个。<ul>
<li>如果战备池子没有多余的空间，就重新分配一块内存，同时如果战备池的空间不足以分配当前一个对象，就将这个空间交还给对应的链表。</li>
<li>如果在无法分配内存的情况下，就会从现有的，比他大一级的池子（右边第一个池子）里面分配内存，只是裁剪出来一块挂到对应的链表中。当右边没有的时候就会分配失败。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>优点与缺点</p>
<ul>
<li><p>优点</p>
<ul>
<li>减少了cookie，使得软件拥有了更大的内存分配空间。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>无法释放已经分配的内存，存在着不少的内存浪费的情况。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2、loki-allocator"><a href="#2、loki-allocator" class="headerlink" title="2、loki allocator"></a>2、loki allocator</h2><p>loki allocator是分配器里面一个比较特殊的设计。</p>
<h3 id="设计框架"><a href="#设计框架" class="headerlink" title="设计框架"></a><strong>设计框架</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">底层：</span><br><span class="line">   底层作为alloc直接管理的一个基层，他是中层的一个嵌套类</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">chunk</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>* pData;  --指针，指向分配内存的头部</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> firstAvailableBlock;--记录下一个可以供给分配的内存</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> blocks;--记录总的可分配格子的大小</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">中层：</span><br><span class="line">   中层作为alloc管理基层的工具，以一个小型的vector为基础。担任分配和释放的操作</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixedAlloctor</span>&#123;</span><br><span class="line">	vector&lt;chuck&gt; chucks; --管理底层的<span class="function">vector</span></span><br><span class="line"><span class="function">	chuck* <span class="title">allocChucks</span><span class="params">()</span></span>; --分配<span class="function">chuck</span></span><br><span class="line"><span class="function">	chuck* <span class="title">deallocChucks</span><span class="params">()</span></span>; --销毁chuck</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">高层：</span><br><span class="line">	高层继承中层，作为主要的对外接口，去分配和释放内存，他的客户是STL</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallObjAllocator</span>&#123;</span><br><span class="line">	vector&lt;FixedAllocator&gt; pool; --管理中层的vector</span><br><span class="line">	FixedAllocator* pLastAlloc;  --指向最后一个可以分配的alloc</span><br><span class="line">	FixedAllocator* pLastDealloc;--指向最后一个销毁的alloc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><p>1.首先，创建一个smallobjallocator，然后制定分配的内存和大小。</p>
<ul>
<li>一般情况下，一次性默认要4096字节空间，超过256字节就不使用loki了。</li>
</ul>
<p>2.每一次进行分配内存的时候指定内存大小，然后进行分配。</p>
<p>3.在释放的时候需要其制定的内存大小和指针就可以进行释放了。</p>
<h3 id="工作逻辑"><a href="#工作逻辑" class="headerlink" title="工作逻辑"></a><strong>工作逻辑</strong></h3><p>chuck</p>
<p>1.chuck首先按照上层的要求进行初始化。调用init。初始化大小，初始化内存空间及其对应的数字</p>
<p>2.然后索要对应的内存，进行分配，如果分配的内存大小和之前相同，就从之前的取</p>
<p>3.在alloc的时候</p>
<ul>
<li>chuck首先找到下一个可以分配的内存，将其分配出去，</li>
<li>同时将内存写好中的数字记录下来，这个数字就是下一个可以分配的内存空间</li>
</ul>
<p>4.在dealloc的时候</p>
<ul>
<li><p>首先利用从中间向两边找的准则，找到对应的位置（中间层，剩下的是底层）</p>
</li>
<li><p>chuck然后找到将进来的指针进行强制类型转换</p>
</li>
<li><p>然后将原先的下一个内存的数字给他</p>
</li>
<li><p>然后通过指针去找他和之前有几个格子的距离，为firstAvailblocks赋予新的值</p>
</li>
</ul>
<p>其他两层按照vector的方式去进行操作和管理。</p>
<h2 id="3、new-allocator与malloc-allocator"><a href="#3、new-allocator与malloc-allocator" class="headerlink" title="3、new_allocator与malloc_allocator"></a>3、new_allocator与malloc_allocator</h2><p>new_allocator与malloc-allocator唯一的区别就是。</p>
<ul>
<li>new allocator可以重载operator::new,可以实现自由的构建malloc不行，他直接调用malloc去使用。</li>
<li>重载operator::new的一个功能就是可以在一定程度上接管alloc所作的工作，去灵活的管理。</li>
</ul>
<h2 id="4、array-allocator"><a href="#4、array-allocator" class="headerlink" title="4、array_allocator"></a>4、array_allocator</h2><p>array_allocator是一个数组类型的分配器，他可以分配固定的内存。</p>
<p>在main程序运行之前，底层函数就已经通过固定的程序让array_allocator这个其依赖的基本数据结构array可用了。</p>
<h2 id="5、debug-allocator"><a href="#5、debug-allocator" class="headerlink" title="5、debug_allocator"></a>5、debug_allocator</h2><p>这个是一个allocator的适配器，类似于stack，他可以帮助程序员调试allocator的内部操作，没什么用。</p>
<h2 id="6、bitmap-allocator"><a href="#6、bitmap-allocator" class="headerlink" title="6、bitmap_allocator"></a>6、bitmap_allocator</h2><h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a><strong>层次结构</strong></h3><p>bitmap_allocator结构分为两层</p>
<p>记录层：这层主要用来记录那些blocks的内存被分配掉了,private&#x2F;public关系省略了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">bitmap</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> useCount;  <span class="comment">//记录使用的blocks数目</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> superBlockSize;  <span class="comment">//记录整个记录层和管理层一共占用的空间总数</span></span><br><span class="line">	<span class="type">char</span> bitmapGuide[bitmapSize] = ‘F’;  <span class="comment">//用16个字符记录使用的数目,bitmapSize是一个可以变的数目，后续根据是否需要扩容决定</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>管理层：这层主要用来管理对应的分配出来的blocks，做实质的alloc&#x2F;dealloc操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">block</span>&#123;</span><br><span class="line">	T *p; --有一个指针</span><br><span class="line">	<span class="built_in">block</span>(<span class="type">int</span> number = <span class="number">4096</span>)&#123;</span><br><span class="line">		p=<span class="keyword">new</span> <span class="built_in">T</span>(number/<span class="built_in">sizeof</span>(<span class="built_in">T</span>()))  <span class="comment">// 为T分配一块内存，这块内存按照传入的字节大小去除一个T对象本身的大小（注意这段代码是伪代码，本身是错误的）</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">tempate &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> superBlock&#123;</span><br><span class="line">	block&lt;T&gt; blocks[<span class="number">64</span>]  <span class="comment">// 这块默认是64个blocks，64个blocks组成一个superBlocks</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在有以上两个之后，然后</span></span><br><span class="line">superBlock&lt;T&gt; blockss;  <span class="comment">// 创建内存</span></span><br><span class="line"><span class="function">mini_vector&lt;T*&gt; <span class="title">vector</span><span class="params">(<span class="number">2</span>,<span class="literal">nullptr</span>)</span></span>;  <span class="comment">// 创建一个minivector，这个是用来储存blockss的头尾指针的</span></span><br><span class="line">vector[<span class="number">0</span>]=&amp;(blockss[<span class="number">0</span>]);</span><br><span class="line">vector[<span class="number">1</span>]=&amp;(blockss[<span class="number">63</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h3><p>具体图解见笔记。</p>
<ul>
<li><p>对于少量内存分配</p>
<ul>
<li><p>选择一格，把他们分配出去</p>
</li>
<li><p>在记录层记录blocks数目的记录加一（已经使用一格）</p>
</li>
<li><p>更改bitmap</p>
<ul>
<li>注意，bitmap的读条方式是，bitmap地图从左往右，对应内存池的从右边向左边的格子，利用二进制表明其是否被占用</li>
</ul>
</li>
</ul>
</li>
<li><p>对于大量内存分配</p>
<ul>
<li><p>如果在一个bitmap不够的情况下就变成原来的两倍，也就是bitmap大小为32，有128个blocks</p>
</li>
<li><p>后面每一次分配都会加量一次（原先x2），每一次全回收都会减量一次（原先&#x2F;2）</p>
</li>
</ul>
</li>
<li><p>对于回收</p>
<ul>
<li><p>和malloc一样，他会有一个“垃圾寄存处”，当不需要的时候，会重新分配一个minivector来寄存这些已经全回收的内存，如果需要的话也是优先看手上有没有</p>
</li>
<li><p>如果有则使用，当有64个组以上的minivector的时候，进行回收。</p>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="midorii"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">midorii</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">midorii</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">287k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:25</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
